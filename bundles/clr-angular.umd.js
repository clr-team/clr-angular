(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('rxjs'), require('@angular/animations'), require('rxjs/operators'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@clr/angular', ['exports', '@angular/core', '@angular/common', 'rxjs', '@angular/animations', 'rxjs/operators', '@angular/forms'], factory) :
    (factory((global.clr = global.clr || {}, global.clr.angular = {}),global.ng.core,global.ng.common,global.rxjs,global.ng.animations,global.rxjs.operators,global.ng.forms));
}(this, (function (exports,i0,common,rxjs,animations,operators,forms) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIconCustomTag = /** @class */ (function () {
        function ClrIconCustomTag() {
        }
        ClrIconCustomTag.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-icon' },] }
        ];
        return ClrIconCustomTag;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_ICON_DIRECTIVES = [ClrIconCustomTag];
    var ClrIconModule = /** @class */ (function () {
        function ClrIconModule() {
        }
        ClrIconModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CLR_ICON_DIRECTIVES], exports: [CLR_ICON_DIRECTIVES] },] }
        ];
        return ClrIconModule;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var Point = {
        RIGHT_CENTER: 0,
        RIGHT_TOP: 1,
        RIGHT_BOTTOM: 2,
        TOP_CENTER: 3,
        TOP_RIGHT: 4,
        TOP_LEFT: 5,
        BOTTOM_CENTER: 6,
        BOTTOM_RIGHT: 7,
        BOTTOM_LEFT: 8,
        LEFT_CENTER: 9,
        LEFT_TOP: 10,
        LEFT_BOTTOM: 11,
    };
    Point[Point.RIGHT_CENTER] = 'RIGHT_CENTER';
    Point[Point.RIGHT_TOP] = 'RIGHT_TOP';
    Point[Point.RIGHT_BOTTOM] = 'RIGHT_BOTTOM';
    Point[Point.TOP_CENTER] = 'TOP_CENTER';
    Point[Point.TOP_RIGHT] = 'TOP_RIGHT';
    Point[Point.TOP_LEFT] = 'TOP_LEFT';
    Point[Point.BOTTOM_CENTER] = 'BOTTOM_CENTER';
    Point[Point.BOTTOM_RIGHT] = 'BOTTOM_RIGHT';
    Point[Point.BOTTOM_LEFT] = 'BOTTOM_LEFT';
    Point[Point.LEFT_CENTER] = 'LEFT_CENTER';
    Point[Point.LEFT_TOP] = 'LEFT_TOP';
    Point[Point.LEFT_BOTTOM] = 'LEFT_BOTTOM';
    /** @type {?} */
    var POSITION_RELATIVE = 'relative';
    /** @type {?} */
    var POSITION_ABSOLUTE = 'absolute';
    /** @type {?} */
    var POSITION_FIXED = 'fixed';
    /** @type {?} */
    var OVERFLOW_SCROLL = 'scroll';
    /** @type {?} */
    var OVERFLOW_AUTO = 'auto';
    var Popover = /** @class */ (function () {
        function Popover(element) {
            this.element = element;
            /*
                 * Containers up to the first positioned one will have an event on scroll
                 */
            this.scrollableElements = [];
            this.boundOnScrollListener = this.emitScrollEvent.bind(this);
            // Browsers don't agree with what to do if some of these are not specified, so we set them all to be safe.
            element.style.position = POSITION_ABSOLUTE;
            element.style.top = 0;
            element.style.bottom = 'auto';
            element.style.left = 0;
            element.style.right = 'auto';
        }
        // TODO: need a way to account for parameters that change dynamically (positioning).
        // TODO: need a way to account for parameters that change dynamically (positioning).
        /**
         * @param {?} anchor
         * @param {?} anchorAlign
         * @param {?} popoverAlign
         * @param {?=} __3
         * @return {?}
         */
        Popover.prototype.anchor =
            // TODO: need a way to account for parameters that change dynamically (positioning).
            /**
             * @param {?} anchor
             * @param {?} anchorAlign
             * @param {?} popoverAlign
             * @param {?=} __3
             * @return {?}
             */
            function (anchor, anchorAlign, popoverAlign, _a) {
                // TODO: we are assuming here that the popover is inside or next to the anchor.
                // We'd need to go up the popover tree too otherwise
                var _b = _a === void 0 ? {} : _a, _c = _b.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _b.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _b.useAnchorParent, useAnchorParent = _e === void 0 ? false : _e;
                this.addScrollEventListeners(anchor);
                if (useAnchorParent) {
                    anchor = anchor.parentNode;
                }
                // explicitly override anchor's style to static
                anchor.style.position = 'static';
                /** @type {?} */
                var anchorRect = anchor.getBoundingClientRect();
                /** @type {?} */
                var popoverRect = this.element.getBoundingClientRect();
                // position of left top corner of anchor + the offset
                /** @type {?} */
                var leftDiff = anchorRect.left - popoverRect.left + offsetX;
                /** @type {?} */
                var topDiff = anchorRect.top - popoverRect.top + offsetY;
                // first, adjust positioning based on anchor's align point
                switch (anchorAlign) {
                    case Point.LEFT_TOP:
                    case Point.TOP_LEFT:
                        break;
                    case Point.TOP_CENTER:
                        leftDiff += anchorRect.width / 2;
                        break;
                    case Point.TOP_RIGHT:
                        leftDiff += anchorRect.width;
                        break;
                    case Point.RIGHT_TOP:
                        leftDiff += anchorRect.width;
                        break;
                    case Point.LEFT_BOTTOM:
                        topDiff += anchorRect.height;
                        break;
                    case Point.BOTTOM_LEFT:
                        topDiff += anchorRect.height;
                        break;
                    case Point.BOTTOM_CENTER:
                        topDiff += anchorRect.height;
                        leftDiff += anchorRect.width / 2;
                        break;
                    case Point.BOTTOM_RIGHT:
                        topDiff += anchorRect.height;
                        leftDiff += anchorRect.width;
                        break;
                    case Point.RIGHT_BOTTOM:
                        topDiff += anchorRect.height;
                        leftDiff += anchorRect.width;
                        break;
                    case Point.LEFT_CENTER:
                        topDiff += anchorRect.height / 2;
                        break;
                    case Point.RIGHT_CENTER:
                        topDiff += anchorRect.height / 2;
                        leftDiff += anchorRect.width;
                        break;
                    default:
                }
                // second, adjust positioning based on popover's align point
                switch (popoverAlign) {
                    case Point.LEFT_TOP:
                    case Point.TOP_LEFT:
                        break;
                    case Point.TOP_CENTER:
                        leftDiff -= popoverRect.width / 2;
                        break;
                    case Point.TOP_RIGHT:
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.RIGHT_TOP:
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.LEFT_BOTTOM:
                        topDiff -= popoverRect.height;
                        break;
                    case Point.BOTTOM_LEFT:
                        topDiff -= popoverRect.height;
                        break;
                    case Point.BOTTOM_CENTER:
                        topDiff -= popoverRect.height;
                        leftDiff -= popoverRect.width / 2;
                        break;
                    case Point.BOTTOM_RIGHT:
                        topDiff -= popoverRect.height;
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.RIGHT_BOTTOM:
                        topDiff -= popoverRect.height;
                        leftDiff -= popoverRect.width;
                        break;
                    case Point.LEFT_CENTER:
                        topDiff -= popoverRect.height / 2;
                        break;
                    case Point.RIGHT_CENTER:
                        topDiff -= popoverRect.height / 2;
                        leftDiff -= popoverRect.width;
                        break;
                    default:
                }
                // Third, adjust with popover's margins based on the two align points.
                // Here, we make an assumption that popover is primarily positioned outside the
                // anchor with minor offset. Without this assumption, it's impossible to apply
                // the popover's margins in a predictable way. For example, assume that a popover
                // and its anchor are exactly the same size. if a popover is positioned inside the
                // anchor (which is technically possible), then it becomes impossible to know what to do
                // if the popover has a non-zero margin value all around (because applying the margin in
                // all four directions will result in no margin visually, which isn't what we want).
                // Therefore, our logic makes assumptions about margins of interest given the points,
                // and only covers the cases where popover is outside the anchor.
                /** @type {?} */
                var popoverComputedStyle = getComputedStyle(this.element);
                /** @type {?} */
                var marginLeft = parseInt(popoverComputedStyle.marginLeft, 10);
                /** @type {?} */
                var marginRight = parseInt(popoverComputedStyle.marginRight, 10);
                /** @type {?} */
                var marginTop = parseInt(popoverComputedStyle.marginTop, 10);
                /** @type {?} */
                var marginBottom = parseInt(popoverComputedStyle.marginBottom, 10);
                switch (anchorAlign) {
                    case Point.LEFT_TOP:
                    case Point.TOP_LEFT:
                    case Point.TOP_RIGHT:
                    case Point.RIGHT_TOP:
                        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                            topDiff -= marginBottom;
                            leftDiff -= marginRight;
                        }
                        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                            topDiff -= marginTop;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                            topDiff += marginTop;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                            topDiff += marginTop;
                            leftDiff -= marginRight;
                        }
                        break;
                    case Point.LEFT_BOTTOM:
                    case Point.BOTTOM_LEFT:
                    case Point.BOTTOM_RIGHT:
                    case Point.RIGHT_BOTTOM:
                        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                            topDiff -= marginBottom;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                            topDiff -= marginBottom;
                            leftDiff -= marginRight;
                        }
                        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                            topDiff += marginTop;
                            leftDiff += marginLeft;
                        }
                        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                            topDiff += marginTop;
                            leftDiff -= marginRight;
                        }
                        break;
                    case Point.TOP_CENTER:
                        topDiff -= marginBottom;
                        leftDiff += marginLeft;
                        leftDiff -= marginRight;
                        break;
                    case Point.BOTTOM_CENTER:
                        topDiff += marginTop;
                        leftDiff += marginLeft;
                        leftDiff -= marginRight;
                        break;
                    case Point.LEFT_CENTER:
                        topDiff += marginTop;
                        topDiff -= marginBottom;
                        leftDiff -= marginRight;
                        break;
                    case Point.RIGHT_CENTER:
                        topDiff += marginTop;
                        topDiff -= marginBottom;
                        leftDiff += marginLeft;
                        break;
                    default:
                }
                this.element.style.transform = "translateX(" + Math.round(leftDiff) + "px) translateY(" + Math.round(topDiff) + "px)";
                return this._scroll.asObservable();
            };
        /**
         * @return {?}
         */
        Popover.prototype.release = /**
         * @return {?}
         */
            function () {
                this.element.style.transform = '';
                this.removeScrollEventListeners();
            };
        /**
         * @param {?} container
         * @return {?}
         */
        Popover.prototype.isPositioned = /**
         * @param {?} container
         * @return {?}
         */
            function (container) {
                /** @type {?} */
                var position = getComputedStyle(container).position;
                return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
            };
        /**
         * @return {?}
         */
        Popover.prototype.emitScrollEvent = /**
         * @return {?}
         */
            function () {
                this._scroll.next();
            };
        /**
         * @param {?} e
         * @return {?}
         */
        Popover.prototype.addScrollEventListeners = /**
         * @param {?} e
         * @return {?}
         */
            function (e) {
                this._scroll = new rxjs.Subject();
                /** @type {?} */
                var anchor = e;
                /** @type {?} */
                var current = e;
                while (current && current !== document) {
                    if (this.scrolls(current)) {
                        current.addEventListener('scroll', this.boundOnScrollListener);
                        this.scrollableElements.push(current);
                    }
                    if (current !== anchor && this.isPositioned(current)) {
                        break;
                    }
                    current = current.parentNode;
                }
            };
        /**
         * @return {?}
         */
        Popover.prototype.removeScrollEventListeners = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                try {
                    for (var _b = __values(this.scrollableElements), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var elem = _c.value;
                        elem.removeEventListener('scroll', this.boundOnScrollListener);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                this.scrollableElements.length = 0;
                if (this._scroll) {
                    this._scroll.complete();
                    delete this._scroll;
                }
            };
        /**
         * @param {?} container
         * @return {?}
         */
        Popover.prototype.scrolls = /**
         * @param {?} container
         * @return {?}
         */
            function (container) {
                /** @type {?} */
                var computedStyles = getComputedStyle(container);
                return (computedStyles.overflowX === OVERFLOW_SCROLL ||
                    computedStyles.overflowX === OVERFLOW_AUTO ||
                    computedStyles.overflowY === OVERFLOW_SCROLL ||
                    computedStyles.overflowY === OVERFLOW_AUTO);
            };
        return Popover;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var openCount = 0;
    /** @type {?} */
    var waiting = [];
    // pending create functions
    var PopoverDirectiveOld = /** @class */ (function () {
        function PopoverDirectiveOld(templateRef, viewContainer) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.popoverOptions = {};
            this.clrPopoverOldChange = new i0.EventEmitter(false);
        }
        Object.defineProperty(PopoverDirectiveOld.prototype, "clrPopoverOld", {
            set: /**
             * @param {?} open
             * @return {?}
             */ function (open) {
                var _this = this;
                if (open) {
                    if (this.popoverOptions.allowMultipleOpen) {
                        this.createPopover();
                    }
                    else {
                        if (openCount === 0) {
                            this.createPopover();
                        }
                        else {
                            waiting.push(function () {
                                _this.createPopover();
                            });
                        }
                    }
                }
                else {
                    this.viewContainer.clear();
                    this.destroyPopover();
                    if (!this.popoverOptions.allowMultipleOpen) {
                        if (waiting.length > 0) {
                            /** @type {?} */
                            var createPopoverFn = waiting.shift();
                            createPopoverFn();
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PopoverDirectiveOld.prototype.createPopover = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var embeddedViewRef = ( /** @type {?} */(this.viewContainer.createEmbeddedView(this.templateRef)));
                // TODO: Not sure of the risks associated with using this. Find an alternative.
                // Needed for find the correct height and width of dynamically created views
                // inside of the popover. For Eg: Button Groups
                embeddedViewRef.detectChanges();
                // filter out other nodes in the view ref so we are only left with element nodes
                /** @type {?} */
                var elementNodes = embeddedViewRef.rootNodes.filter(function (node) {
                    return node.nodeType === 1;
                });
                // we take the first element node in the embedded view; usually there should only be one anyways
                this._popoverInstance = new Popover(elementNodes[0]);
                this._subscription = this._popoverInstance
                    .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                    .subscribe(function () {
                    _this.clrPopoverOldChange.emit(false);
                });
                openCount++;
            };
        /**
         * @return {?}
         */
        PopoverDirectiveOld.prototype.destroyPopover = /**
         * @return {?}
         */
            function () {
                if (this._popoverInstance) {
                    this._subscription.unsubscribe();
                    this._popoverInstance.release();
                    delete this._popoverInstance;
                    openCount--;
                }
            };
        /**
         * @return {?}
         */
        PopoverDirectiveOld.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.destroyPopover();
            };
        PopoverDirectiveOld.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPopoverOld]' },] }
        ];
        /** @nocollapse */
        PopoverDirectiveOld.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        PopoverDirectiveOld.propDecorators = {
            anchorElem: [{ type: i0.Input, args: ['clrPopoverOldAnchor',] }],
            anchorPoint: [{ type: i0.Input, args: ['clrPopoverOldAnchorPoint',] }],
            popoverPoint: [{ type: i0.Input, args: ['clrPopoverOldPopoverPoint',] }],
            popoverOptions: [{ type: i0.Input, args: ['clrPopoverOldOptions',] }],
            clrPopoverOldChange: [{ type: i0.Output, args: ['clrPopoverOldChange',] }],
            clrPopoverOld: [{ type: i0.Input }]
        };
        return PopoverDirectiveOld;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var POPOVER_DIRECTIVES = [PopoverDirectiveOld];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCommonPopoverModule = /** @class */ (function () {
        function ClrCommonPopoverModule() {
        }
        ClrCommonPopoverModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [POPOVER_DIRECTIVES], exports: [POPOVER_DIRECTIVES] },] }
        ];
        return ClrCommonPopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
     * This does not mean you should extend it, simply implementing it is fine.
     * @abstract
     */
    var /**
     * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
     * This does not mean you should extend it, simply implementing it is fine.
     * @abstract
     */ LoadingListener = /** @class */ (function () {
        function LoadingListener() {
        }
        return LoadingListener;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var ClrLoadingState = {
        DEFAULT: 0,
        LOADING: 1,
        SUCCESS: 2,
        ERROR: 3,
    };
    ClrLoadingState[ClrLoadingState.DEFAULT] = 'DEFAULT';
    ClrLoadingState[ClrLoadingState.LOADING] = 'LOADING';
    ClrLoadingState[ClrLoadingState.SUCCESS] = 'SUCCESS';
    ClrLoadingState[ClrLoadingState.ERROR] = 'ERROR';
    var ClrLoading = /** @class */ (function () {
        // We find the first parent that handles something loading
        function ClrLoading(listener) {
            this.listener = listener;
            this._loadingState = ClrLoadingState.DEFAULT;
        }
        Object.defineProperty(ClrLoading.prototype, "loadingState", {
            get: /**
             * @return {?}
             */ function () {
                return this._loadingState;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === true) {
                    value = ClrLoadingState.LOADING;
                }
                else if (!value) {
                    value = ClrLoadingState.DEFAULT;
                }
                if (value === this._loadingState) {
                    return;
                }
                this._loadingState = value;
                if (this.listener) {
                    this.listener.loadingStateChange(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrLoading.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.loadingState = ClrLoadingState.DEFAULT;
            };
        ClrLoading.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrLoading]' },] }
        ];
        /** @nocollapse */
        ClrLoading.ctorParameters = function () {
            return [
                { type: LoadingListener, decorators: [{ type: i0.Optional }] }
            ];
        };
        ClrLoading.propDecorators = {
            loadingState: [{ type: i0.Input, args: ['clrLoading',] }]
        };
        return ClrLoading;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ButtonInGroupService = /** @class */ (function () {
        function ButtonInGroupService() {
            this._changes = new rxjs.Subject();
        }
        Object.defineProperty(ButtonInGroupService.prototype, "changes", {
            get: /**
             * @return {?}
             */ function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} button
         * @return {?}
         */
        ButtonInGroupService.prototype.updateButtonGroup = /**
         * @param {?} button
         * @return {?}
         */
            function (button) {
                this._changes.next(button);
            };
        ButtonInGroupService.decorators = [
            { type: i0.Injectable }
        ];
        return ButtonInGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrButton = /** @class */ (function () {
        function ClrButton(buttonInGroupService) {
            this.buttonInGroupService = buttonInGroupService;
            this._enableService = false;
            this._inMenu = false;
            this._classNames = 'btn';
            this._name = null;
            this._type = null;
            this._disabled = null;
            this._click = new i0.EventEmitter(false);
        }
        Object.defineProperty(ClrButton.prototype, "inMenu", {
            get: /**
             * @return {?}
             */ function () {
                return this._inMenu;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this._inMenu !== value) {
                    this._inMenu = value;
                    // We check if the service flag is enabled
                    // and if the service exists because the service is optional
                    if (this._enableService && this.buttonInGroupService) {
                        this.buttonInGroupService.updateButtonGroup(this);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "classNames", {
            get: /**
             * @return {?}
             */ function () {
                return this._classNames;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    /** @type {?} */
                    var classNames = value.split(' ');
                    if (classNames.indexOf('btn') === -1) {
                        classNames.push('btn');
                    }
                    this._classNames = classNames.join(' ');
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "name", {
            get: /**
             * @return {?}
             */ function () {
                return this._name;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    this._name = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this._type;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'string') {
                    this._type = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButton.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== null && value !== false) {
                    this._disabled = '';
                }
                else {
                    this._disabled = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} state
         * @return {?}
         */
        ClrButton.prototype.loadingStateChange = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                this.loading = state === ClrLoadingState.LOADING;
            };
        /**
         * @return {?}
         */
        ClrButton.prototype.emitClick = /**
         * @return {?}
         */
            function () {
                this._click.emit(true);
            };
        /**
         * @return {?}
         */
        ClrButton.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._enableService = true;
            };
        ClrButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-button',
                        template: "\n        <ng-template #buttonProjectedRef>\n            <button \n                [class]=\"classNames\" \n                (click)=\"emitClick()\"\n                [attr.type]=\"type\"\n                [attr.name]=\"name\"\n                [attr.disabled]=\"disabled\">\n                <span class=\"spinner spinner-inline\" *ngIf=\"loading\"></span>\n                <ng-content></ng-content>\n            </button>\n        </ng-template>\n    ",
                        providers: [{ provide: LoadingListener, useExisting: ClrButton }]
                    }] }
        ];
        /** @nocollapse */
        ClrButton.ctorParameters = function () {
            return [
                { type: ButtonInGroupService, decorators: [{ type: i0.SkipSelf }, { type: i0.Optional }] }
            ];
        };
        ClrButton.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['buttonProjectedRef',] }],
            inMenu: [{ type: i0.Input, args: ['clrInMenu',] }],
            classNames: [{ type: i0.Input, args: ['class',] }],
            name: [{ type: i0.Input, args: ['name',] }],
            type: [{ type: i0.Input, args: ['type',] }],
            disabled: [{ type: i0.Input, args: ['disabled',] }],
            _click: [{ type: i0.Output, args: ['click',] }]
        };
        return ClrButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @type {?} */
    var CLR_MENU_POSITIONS = [
        'bottom-left',
        'bottom-right',
        'top-left',
        'top-right',
        'left-bottom',
        'left-top',
        'right-bottom',
        'right-top',
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // @TODO Put the Required type back in when our minimumly supported version of Angular uses
    // TS 2.8 or greater (should be Angular 7)
    // export class ClrCommonStringsService implements Required<ClrCommonStrings> {
    var 
    // @TODO Put the Required type back in when our minimumly supported version of Angular uses
    // TS 2.8 or greater (should be Angular 7)
    // export class ClrCommonStringsService implements Required<ClrCommonStrings> {
    ClrCommonStringsService = /** @class */ (function () {
        function ClrCommonStringsService() {
            this.open = 'Open';
            this.close = 'Close';
            this.show = 'Show';
            this.hide = 'Hide';
            this.expand = 'Expand';
            this.collapse = 'Collapse';
            this.more = 'More';
            this.select = 'Select';
            this.selectAll = 'Select All';
            this.previous = 'Previous';
            this.next = 'Next';
            this.current = 'Jump to current';
            this.info = 'Info';
            this.success = 'Success';
            this.warning = 'Warning';
            this.danger = 'Error';
            this.rowActions = 'Available actions';
            this.pickColumns = 'Show or hide columns';
        }
        return ClrCommonStringsService;
    }());
    /**
     * @param {?=} existing
     * @return {?}
     */
    function commonStringsFactory(existing) {
        /** @type {?} */
        var defaults = new ClrCommonStringsService();
        if (existing) {
            return __assign({}, defaults, existing);
        }
        return defaults;
    }
    /** @type {?} */
    var COMMON_STRINGS_PROVIDER = {
        useFactory: commonStringsFactory,
        // We have a circular dependency for now, we can address it later once these
        // tree-shakeable providers have proper documentation.
        deps: [[new i0.Optional(), new i0.SkipSelf(), i0.forwardRef(function () { return ClrCommonStrings; })]],
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var ClrCommonStrings = /** @class */ (function () {
        function ClrCommonStrings() {
        }
        ClrCommonStrings.decorators = [
            { type: i0.Injectable, args: [__assign({ providedIn: 'root' }, COMMON_STRINGS_PROVIDER),] }
        ];
        /** @nocollapse */ ClrCommonStrings.ngInjectableDef = i0.defineInjectable({ factory: function ClrCommonStrings_Factory() { return new ClrCommonStrings(); }, token: ClrCommonStrings, providedIn: "root" });
        return ClrCommonStrings;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrButtonGroup = /** @class */ (function () {
        function ClrButtonGroup(buttonGroupNewService, elementRef, commonStrings) {
            this.buttonGroupNewService = buttonGroupNewService;
            this.elementRef = elementRef;
            this.commonStrings = commonStrings;
            this.inlineButtons = [];
            this.menuButtons = [];
            this._openMenu = false;
            this.anchorPoint = Point.BOTTOM_LEFT; // default if menuPosition isn't set
            // default if menuPosition isn't set
            this.popoverPoint = Point.LEFT_TOP; // default if menuPosition isn't set
            /**
             * Flag with indicates if the overflow menu toggle was clicked.
             * If true, this can save us traversing the DOM to find
             * whether the click was withing the button group toggle
             * or menu in the onMouseClick method
             */
            this._overflowMenuToggleClicked = false;
        }
        /**
         * 1. Initializes the initial Button Group View
         * 2. Subscribes to changes on the ContentChildren
         *    in case the user content projection changes
         */
        /**
         * 1. Initializes the initial Button Group View
         * 2. Subscribes to changes on the ContentChildren
         *    in case the user content projection changes
         * @return {?}
         */
        ClrButtonGroup.prototype.ngAfterContentInit = /**
         * 1. Initializes the initial Button Group View
         * 2. Subscribes to changes on the ContentChildren
         *    in case the user content projection changes
         * @return {?}
         */
            function () {
                var _this = this;
                this.initializeButtons();
                this.buttonGroupNewService.changes.subscribe(function (button) { return _this.rearrangeButton(button); });
                this.buttons.changes.subscribe(function () {
                    _this.initializeButtons();
                });
            };
        /**
         * Moves the button into the other ViewContainer
         * when an update is received.
         *
         * @param button
         */
        /**
         * Moves the button into the other ViewContainer
         * when an update is received.
         *
         * @param {?} button
         * @return {?}
         */
        ClrButtonGroup.prototype.rearrangeButton = /**
         * Moves the button into the other ViewContainer
         * when an update is received.
         *
         * @param {?} button
         * @return {?}
         */
            function (button) {
                /** @type {?} */
                var fromView;
                /** @type {?} */
                var toView;
                if (button.inMenu) {
                    fromView = this.inlineButtons;
                    toView = this.menuButtons;
                }
                else {
                    fromView = this.menuButtons;
                    toView = this.inlineButtons;
                }
                /** @type {?} */
                var index = fromView.indexOf(button);
                if (index > -1) {
                    fromView.splice(index, 1);
                    /** @type {?} */
                    var moveIndex = this.getMoveIndex(button);
                    if (moveIndex <= toView.length) {
                        toView.splice(moveIndex, 0, button);
                    }
                }
            };
        /**
         * Author: Eudes
         *
         * Finds the order of a button w.r.t other buttons
         *
         * @param buttonToMove
         * @returns
         */
        /**
         * Author: Eudes
         *
         * Finds the order of a button w.r.t other buttons
         *
         * @param {?} buttonToMove
         * @return {?}
         */
        ClrButtonGroup.prototype.getMoveIndex = /**
         * Author: Eudes
         *
         * Finds the order of a button w.r.t other buttons
         *
         * @param {?} buttonToMove
         * @return {?}
         */
            function (buttonToMove) {
                /** @type {?} */
                var tempArr = this.buttons.filter(function (button) { return button.inMenu === buttonToMove.inMenu; });
                return tempArr.indexOf(buttonToMove);
            };
        /**
         * @return {?}
         */
        ClrButtonGroup.prototype.initializeButtons = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var tempInlineButtons = [];
                /** @type {?} */
                var tempInMenuButtons = [];
                this.buttons.forEach(function (button) {
                    if (button.inMenu) {
                        tempInMenuButtons.push(button);
                    }
                    else {
                        tempInlineButtons.push(button);
                    }
                });
                this.inlineButtons = tempInlineButtons;
                this.menuButtons = tempInMenuButtons;
            };
        Object.defineProperty(ClrButtonGroup.prototype, "menuPosition", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuPosition;
            },
            set: /**
             * @param {?} pos
             * @return {?}
             */ function (pos) {
                if (pos && CLR_MENU_POSITIONS.indexOf(pos) > -1) {
                    this._menuPosition = pos;
                }
                else {
                    this._menuPosition = 'bottom-left';
                }
                // set the popover values based on menu position
                switch (this._menuPosition) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_RIGHT;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_LEFT;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_RIGHT;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-top':
                        this.anchorPoint = Point.RIGHT_TOP;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-bottom':
                        this.anchorPoint = Point.RIGHT_BOTTOM;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'left-top':
                        this.anchorPoint = Point.LEFT_TOP;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'left-bottom':
                        this.anchorPoint = Point.LEFT_BOTTOM;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    default:
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrButtonGroup.prototype, "openMenu", {
            get: /**
             * @return {?}
             */ function () {
                return this._openMenu;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._openMenu = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
         * clicked. Also set a flag that indicates that the toggle
         * was clicked so that we don't traverse the DOM to find the
         * location of the click.
         */
        // default if menuPosition isn't set
        /**
         * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
         * clicked. Also set a flag that indicates that the toggle
         * was clicked so that we don't traverse the DOM to find the
         * location of the click.
         * @return {?}
         */
        ClrButtonGroup.prototype.toggleMenu =
            // default if menuPosition isn't set
            /**
             * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
             * clicked. Also set a flag that indicates that the toggle
             * was clicked so that we don't traverse the DOM to find the
             * location of the click.
             * @return {?}
             */
            function () {
                this.openMenu = !this.openMenu;
                this._overflowMenuToggleClicked = true;
            };
        // TODO: Generic Directive to handle this
        /**
         * Called on mouse clicks anywhere in the DOM.
         * Checks to see if the mouseclick happened on the host or outside
         */
        // TODO: Generic Directive to handle this
        /**
         * Called on mouse clicks anywhere in the DOM.
         * Checks to see if the mouseclick happened on the host or outside
         * @param {?} target
         * @return {?}
         */
        ClrButtonGroup.prototype.onMouseClick =
            // TODO: Generic Directive to handle this
            /**
             * Called on mouse clicks anywhere in the DOM.
             * Checks to see if the mouseclick happened on the host or outside
             * @param {?} target
             * @return {?}
             */
            function (target) {
                if (this.openMenu && !this._overflowMenuToggleClicked) {
                    // Reset the overflow menu toggle clicked flag
                    this._overflowMenuToggleClicked = false;
                    /** @type {?} */
                    var current = target;
                    // Get the element in the DOM on which the mouse was clicked
                    /** @type {?} */
                    var host = this.elementRef.nativeElement;
                    if (current.classList.contains('dropdown-menu')) {
                        current = current.parentNode;
                        while (current) {
                            if (current === document) {
                                this.openMenu = false;
                                return;
                            }
                            // If clicked on dropdown menu and menu is in host
                            // do nothing
                            if (current === host) {
                                return;
                            }
                            current = current.parentNode;
                        }
                    }
                    this.openMenu = false;
                }
                this._overflowMenuToggleClicked = false; // Reset the overflow menu toggle clicked flag
            };
        ClrButtonGroup.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-button-group',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-container *ngFor=\"let inlineButton of inlineButtons\">\n    <ng-template [ngTemplateOutlet]=\"inlineButton.templateRef\"></ng-template>\n</ng-container>\n<ng-container *ngIf=\"menuButtons.length > 0\">\n    <div\n        class=\"btn-group-overflow open\"\n        [ngClass]=\"menuPosition\"\n        #anchor>\n        <button\n            class=\"btn dropdown-toggle\"\n            (click)=\"toggleMenu()\">\n            <clr-icon shape=\"ellipsis-horizontal\" [attr.title]=\"commonStrings.more\"></clr-icon>\n        </button>\n        <div\n            class=\"dropdown-menu\"\n            *clrPopoverOld=\"openMenu; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint;\">\n            <ng-template [ngTemplateOutlet]=\"ref\"></ng-template>\n        </div>\n    </div>\n</ng-container>\n<ng-template #ref>\n    <ng-container *ngFor=\"let menuButton of menuButtons\">\n        <ng-template [ngTemplateOutlet]=\"menuButton.templateRef\"></ng-template>\n    </ng-container>\n</ng-template>\n",
                        providers: [ButtonInGroupService],
                        host: { '[class.btn-group]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrButtonGroup.ctorParameters = function () {
            return [
                { type: ButtonInGroupService },
                { type: i0.ElementRef },
                { type: ClrCommonStrings }
            ];
        };
        ClrButtonGroup.propDecorators = {
            buttons: [{ type: i0.ContentChildren, args: [ClrButton,] }],
            menuPosition: [{ type: i0.Input, args: ['clrMenuPosition',] }],
            onMouseClick: [{ type: i0.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return ClrButtonGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_BUTTON_GROUP_DIRECTIVES = [ClrButton, ClrButtonGroup];
    var ClrButtonGroupModule = /** @class */ (function () {
        function ClrButtonGroupModule() {
        }
        ClrButtonGroupModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrCommonPopoverModule],
                        declarations: [CLR_BUTTON_GROUP_DIRECTIVES],
                        exports: [CLR_BUTTON_GROUP_DIRECTIVES],
                    },] }
        ];
        return ClrButtonGroupModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLoadingButton = /** @class */ (function () {
        function ClrLoadingButton(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.buttonState = ClrLoadingState;
            this.state = ClrLoadingState.DEFAULT;
            this.clrLoadingChange = new i0.EventEmitter(false);
        }
        /**
         * @param {?} state
         * @return {?}
         */
        ClrLoadingButton.prototype.loadingStateChange = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                if (state === this.state) {
                    return;
                }
                this.state = state;
                switch (state) {
                    case ClrLoadingState.DEFAULT:
                        this.renderer.removeStyle(this.el.nativeElement, 'width');
                        if (!this.disabled) {
                            this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                        }
                        break;
                    case ClrLoadingState.LOADING:
                        this.setExplicitButtonWidth();
                        this.renderer.setAttribute(this.el.nativeElement, 'disabled', '');
                        break;
                    case ClrLoadingState.SUCCESS:
                        this.setExplicitButtonWidth();
                        break;
                    case ClrLoadingState.ERROR:
                        this.loadingStateChange(ClrLoadingState.DEFAULT);
                        break;
                    default:
                        break;
                }
                this.clrLoadingChange.emit(state);
            };
        /**
         * @return {?}
         */
        ClrLoadingButton.prototype.setExplicitButtonWidth = /**
         * @return {?}
         */
            function () {
                if (this.el.nativeElement && this.el.nativeElement.getBoundingClientRect) {
                    /** @type {?} */
                    var boundingClientRect = this.el.nativeElement.getBoundingClientRect();
                    this.renderer.setStyle(this.el.nativeElement, 'width', boundingClientRect.width + "px");
                }
            };
        ClrLoadingButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'button[clrLoading]',
                        template: "\n        <ng-container [ngSwitch]=\"state\">\n            <span *ngSwitchCase=\"buttonState.LOADING\">\n                <span @spinner class=\"spinner spinner-inline\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.SUCCESS\">\n                <span @validated (@validated.done)=\"this.loadingStateChange(this.buttonState.DEFAULT)\" class=\"spinner spinner-inline spinner-check\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.DEFAULT\" @defaultButton>\n                <ng-content></ng-content>\n            </span>\n        </ng-container>\n    ",
                        providers: [{ provide: LoadingListener, useExisting: ClrLoadingButton }],
                        animations: [
                            animations.trigger('defaultButton', [
                                animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                                // TODO: see if we can get leave animation to work before spinner's enter animation
                                animations.transition(':leave', [animations.style({ opacity: 0 })]),
                            ]),
                            animations.trigger('spinner', [
                                animations.transition(':enter', [animations.style({ opacity: 0 }), animations.animate('200ms 100ms ease-in', animations.style({ opacity: 1 }))]),
                                animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
                            ]),
                            animations.trigger('validated', [
                                animations.transition(':enter', [
                                    animations.animate('600ms', animations.keyframes([
                                        animations.style({ transform: 'scale(0,0)', offset: 0 }),
                                        animations.style({ opacity: 1, offset: 0.2 }),
                                        animations.style({ transform: 'scale(1.2,1.2)', offset: 0.4 }),
                                        animations.style({ transform: 'scale(.9,.9)', offset: 0.6 }),
                                        animations.style({ transform: 'scale(1,1)', offset: 1 }),
                                    ])),
                                ]),
                                animations.transition(':leave', [animations.style({ opacity: 1 }), animations.animate('100ms ease-out', animations.style({ opacity: 0 }))]),
                            ]),
                        ],
                        host: { '[attr.disabled]': "disabled? '' : null" }
                    }] }
        ];
        /** @nocollapse */
        ClrLoadingButton.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        ClrLoadingButton.propDecorators = {
            disabled: [{ type: i0.Input, args: ['disabled',] }],
            clrLoadingChange: [{ type: i0.Output, args: ['clrLoadingChange',] }]
        };
        return ClrLoadingButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_LOADING_BUTTON_DIRECTIVES = [ClrLoadingButton];
    var ClrLoadingButtonModule = /** @class */ (function () {
        function ClrLoadingButtonModule() {
        }
        ClrLoadingButtonModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [CLR_LOADING_BUTTON_DIRECTIVES],
                        exports: [CLR_LOADING_BUTTON_DIRECTIVES],
                    },] }
        ];
        return ClrLoadingButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrButtonModule = /** @class */ (function () {
        function ClrButtonModule() {
        }
        ClrButtonModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [ClrLoadingButtonModule, ClrButtonGroupModule],
                    },] }
        ];
        return ClrButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var EmptyAnchor = /** @class */ (function () {
        function EmptyAnchor() {
        }
        EmptyAnchor.decorators = [
            { type: i0.Component, args: [{
                        template: ''
                    }] }
        ];
        return EmptyAnchor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Internal module, please do not export!
     */
    var ClrHostWrappingModule = /** @class */ (function () {
        function ClrHostWrappingModule() {
        }
        ClrHostWrappingModule.decorators = [
            { type: i0.NgModule, args: [{ declarations: [EmptyAnchor], exports: [EmptyAnchor], entryComponents: [EmptyAnchor] },] }
        ];
        return ClrHostWrappingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrControlError = /** @class */ (function () {
        function ClrControlError() {
        }
        ClrControlError.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-control-error',
                        template: "\n    <ng-content></ng-content>\n    ",
                        host: { '[class.clr-subtext]': 'true' }
                    }] }
        ];
        return ClrControlError;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrControlHelper = /** @class */ (function () {
        function ClrControlHelper() {
        }
        ClrControlHelper.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-control-helper',
                        template: "\n    <ng-content></ng-content>\n    ",
                        host: { '[class.clr-subtext]': 'true' }
                    }] }
        ];
        return ClrControlHelper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NgControlService = /** @class */ (function () {
        function NgControlService() {
            // Observable to subscribe to the control, since its not available immediately for projected content
            this._controlChanges = new rxjs.Subject();
        }
        Object.defineProperty(NgControlService.prototype, "controlChanges", {
            get: /**
             * @return {?}
             */ function () {
                return this._controlChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} control
         * @return {?}
         */
        NgControlService.prototype.setControl = /**
         * @param {?} control
         * @return {?}
         */
            function (control) {
                this._controlChanges.next(control);
            };
        NgControlService.decorators = [
            { type: i0.Injectable }
        ];
        return NgControlService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var IfErrorService = /** @class */ (function () {
        function IfErrorService(ngControlService) {
            var _this = this;
            this.ngControlService = ngControlService;
            // Implement our own status changes observable, since Angular controls don't
            // fire on events like blur, and we want to return the control instead of a string
            this._statusChanges = new rxjs.Subject();
            this.subscriptions = [];
            // Wait for the control to be available
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                if (control) {
                    _this.control = control;
                    _this.listenForChanges();
                }
            }));
        }
        Object.defineProperty(IfErrorService.prototype, "statusChanges", {
            get: /**
             * @return {?}
             */ function () {
                return this._statusChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        // Subscribe to the status change events, only after touched and emit the control
        // Subscribe to the status change events, only after touched and emit the control
        /**
         * @return {?}
         */
        IfErrorService.prototype.listenForChanges =
            // Subscribe to the status change events, only after touched and emit the control
            /**
             * @return {?}
             */
            function () {
                var _this = this;
                this.subscriptions.push(this.control.statusChanges.pipe(operators.filter(function () { return _this.control.touched; })).subscribe(function () {
                    _this._statusChanges.next(_this.control);
                }));
            };
        // Allows a control to push a status check upstream, such as on blur
        // Allows a control to push a status check upstream, such as on blur
        /**
         * @return {?}
         */
        IfErrorService.prototype.triggerStatusChange =
            // Allows a control to push a status check upstream, such as on blur
            /**
             * @return {?}
             */
            function () {
                if (this.control) {
                    this._statusChanges.next(this.control);
                }
            };
        // Clean up subscriptions
        // Clean up subscriptions
        /**
         * @return {?}
         */
        IfErrorService.prototype.ngOnDestroy =
            // Clean up subscriptions
            /**
             * @return {?}
             */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        IfErrorService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        IfErrorService.ctorParameters = function () {
            return [
                { type: NgControlService }
            ];
        };
        return IfErrorService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfError = /** @class */ (function () {
        function ClrIfError(service, template, container) {
            this.service = service;
            this.template = template;
            this.container = container;
            this.displayed = false;
            if (!this.service) {
                throw new Error('clrIfError can only be used within a form control container element like clr-input-container');
            }
            else {
                this.displayError(false);
            }
        }
        /**
         * @return {?}
         */
        ClrIfError.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscription = this.service.statusChanges.subscribe(function (control) {
                    // If there is a specific error to track, check it, otherwise check overall validity
                    if (_this.error) {
                        _this.displayError(control.hasError(_this.error));
                    }
                    else {
                        _this.displayError(control.invalid);
                    }
                });
            };
        /**
         * @return {?}
         */
        ClrIfError.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        /**
         * @param {?} invalid
         * @return {?}
         */
        ClrIfError.prototype.displayError = /**
         * @param {?} invalid
         * @return {?}
         */
            function (invalid) {
                if (invalid && !this.displayed) {
                    this.container.createEmbeddedView(this.template);
                    this.displayed = true;
                }
                else if (!invalid) {
                    this.container.clear();
                    this.displayed = false;
                }
            };
        ClrIfError.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfError]' },] }
        ];
        /** @nocollapse */
        ClrIfError.ctorParameters = function () {
            return [
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrIfError.propDecorators = {
            error: [{ type: i0.Input, args: ['clrIfError',] }]
        };
        return ClrIfError;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var counter = 0;
    var ControlIdService = /** @class */ (function () {
        function ControlIdService() {
            this._id = 'clr-form-control-' + ++counter;
            this._idChange = new rxjs.BehaviorSubject(this._id);
        }
        Object.defineProperty(ControlIdService.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                this._idChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ControlIdService.prototype, "idChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._idChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        ControlIdService.decorators = [
            { type: i0.Injectable }
        ];
        return ControlIdService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var Layouts = {
        VERTICAL: 'vertical',
        HORIZONTAL: 'horizontal',
        COMPACT: 'compact',
    };
    var LayoutService = /** @class */ (function () {
        function LayoutService() {
            this.layout = Layouts.VERTICAL;
            // This is basically a replacement for Object.values(), which IE11 and Node <9 don't support :(
            // String enums cannot be reverse-mapped, meaning Layouts['COMPACT'] does not return 'compact' so
            // this exists to deal with this little caveat to get the list of the values as an array.
            this.layoutValues = Object.keys(Layouts).map(function (key) { return Layouts[key]; });
        }
        /**
         * @return {?}
         */
        LayoutService.prototype.isVertical = /**
         * @return {?}
         */
            function () {
                return this.layout === Layouts.VERTICAL;
            };
        Object.defineProperty(LayoutService.prototype, "layoutClass", {
            get: /**
             * @return {?}
             */ function () {
                return "clr-form-" + this.layout;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} layout
         * @return {?}
         */
        LayoutService.prototype.isValid = /**
         * @param {?} layout
         * @return {?}
         */
            function (layout) {
                return this.layoutValues.indexOf(layout) > -1;
            };
        LayoutService.decorators = [
            { type: i0.Injectable }
        ];
        return LayoutService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLabel = /** @class */ (function () {
        function ClrLabel(controlIdService, layoutService, ngControlService, renderer, el) {
            this.controlIdService = controlIdService;
            this.layoutService = layoutService;
            this.ngControlService = ngControlService;
            this.renderer = renderer;
            this.el = el;
            this.subscriptions = [];
        }
        /**
         * @return {?}
         */
        ClrLabel.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Only add the clr-control-label if it is inside a control container
                if (this.controlIdService || this.ngControlService) {
                    this.renderer.addClass(this.el.nativeElement, 'clr-control-label');
                }
                // Only set the grid column classes if we are in the right context and if they aren't already set
                if (this.layoutService &&
                    !this.layoutService.isVertical() &&
                    this.el.nativeElement &&
                    this.el.nativeElement.className.indexOf('clr-col') < 0) {
                    this.renderer.addClass(this.el.nativeElement, 'clr-col-xs-12');
                    this.renderer.addClass(this.el.nativeElement, 'clr-col-md-2');
                }
                if (this.controlIdService && !this.forAttr) {
                    this.subscriptions.push(this.controlIdService.idChange.subscribe(function (id) { return (_this.forAttr = id); }));
                }
            };
        /**
         * @return {?}
         */
        ClrLabel.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrLabel.decorators = [
            { type: i0.Directive, args: [{ selector: 'label' },] }
        ];
        /** @nocollapse */
        ClrLabel.ctorParameters = function () {
            return [
                { type: ControlIdService, decorators: [{ type: i0.Optional }] },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        ClrLabel.propDecorators = {
            forAttr: [{ type: i0.HostBinding, args: ['attr.for',] }, { type: i0.Input, args: ['for',] }]
        };
        return ClrLabel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var IS_NEW_FORMS_LAYOUT = new i0.InjectionToken('IS_NEW_FORMS_LAYOUT');
    /** @type {?} */
    var IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER = {
        provide: IS_NEW_FORMS_LAYOUT,
        useValue: true,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrForm = /** @class */ (function () {
        function ClrForm() {
        }
        ClrForm.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrForm]',
                        providers: [LayoutService, IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER],
                        host: { '[class.clr-form]': 'true' },
                    },] }
        ];
        return ClrForm;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLayout = /** @class */ (function () {
        function ClrLayout(layoutService) {
            this.layoutService = layoutService;
        }
        /**
         * @return {?}
         */
        ClrLayout.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // Only set the layout if it is a valid option
                if (this.layout && this.layoutService.isValid(this.layout)) {
                    this.layoutService.layout = this.layout;
                }
            };
        ClrLayout.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrLayout]',
                        host: {
                            '[class]': 'layoutService.layoutClass',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrLayout.ctorParameters = function () {
            return [
                { type: LayoutService }
            ];
        };
        ClrLayout.propDecorators = {
            layout: [{ type: i0.Input, args: ['clrLayout',] }]
        };
        return ClrLayout;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCommonFormsModule = /** @class */ (function () {
        function ClrCommonFormsModule() {
        }
        ClrCommonFormsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
                        exports: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
                    },] }
        ];
        return ClrCommonFormsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCheckboxWrapper = /** @class */ (function () {
        function ClrCheckboxWrapper() {
            // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
            // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
            // but we'd still need to insert a label
            this._dynamic = false;
        }
        ClrCheckboxWrapper.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-checkbox-wrapper',
                        template: "\n    <ng-content select=\"[clrCheckbox]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                        host: {
                            '[class.clr-checkbox-wrapper]': 'true',
                        },
                        providers: [ControlIdService]
                    }] }
        ];
        ClrCheckboxWrapper.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrCheckboxWrapper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ControlClassService = /** @class */ (function () {
        function ControlClassService() {
            this.className = '';
        }
        /**
         * @param {?=} invalid
         * @param {?=} grid
         * @param {?=} additional
         * @return {?}
         */
        ControlClassService.prototype.controlClass = /**
         * @param {?=} invalid
         * @param {?=} grid
         * @param {?=} additional
         * @return {?}
         */
            function (invalid, grid, additional) {
                if (invalid === void 0) {
                    invalid = false;
                }
                if (grid === void 0) {
                    grid = false;
                }
                if (additional === void 0) {
                    additional = '';
                }
                /** @type {?} */
                var controlClasses = [this.className, additional];
                if (invalid) {
                    controlClasses.push('clr-error');
                }
                if (grid && this.className.indexOf('clr-col') === -1) {
                    controlClasses.push('clr-col-md-10 clr-col-xs-12');
                }
                return controlClasses.join(' ').trim();
            };
        // We want to remove the column classes from the input up to the container
        // We want to remove the column classes from the input up to the container
        /**
         * @param {?} renderer
         * @param {?} element
         * @return {?}
         */
        ControlClassService.prototype.initControlClass =
            // We want to remove the column classes from the input up to the container
            /**
             * @param {?} renderer
             * @param {?} element
             * @return {?}
             */
            function (renderer, element) {
                if (element && element.className) {
                    this.className = element.className;
                    /** @type {?} */
                    var klasses = element.className.split(' ');
                    klasses.forEach(function (klass) {
                        if (klass.startsWith('clr-col')) {
                            renderer.removeClass(element, klass);
                        }
                    });
                }
            };
        ControlClassService.decorators = [
            { type: i0.Injectable }
        ];
        return ControlClassService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
     * still undefined.
     * TODO - make sure these comment annotations do not break ng-packgr.
     * @template W
     */
    var /**
     * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
     * still undefined.
     * TODO - make sure these comment annotations do not break ng-packgr.
     * @template W
     */ HostWrapper = /** @class */ (function () {
        function HostWrapper(containerType, vcr, index) {
            if (index === void 0) {
                index = 0;
            }
            this.injector = vcr.injector;
            // If the host is already wrapped, we don't do anything
            if (!this.injector.get(containerType, null)) {
                /** @type {?} */
                var cfr = this.injector.get(i0.ComponentFactoryResolver);
                /** @type {?} */
                var el = this.injector.get(i0.ElementRef);
                // We need a new anchor, since we're projecting the current one.
                vcr.createComponent(cfr.resolveComponentFactory(EmptyAnchor));
                /** @type {?} */
                var factory = cfr.resolveComponentFactory(containerType);
                // Craft the element array based on what slot to use. Angular only uses the index to determine
                // which ng-content to project into, so if you have more than one ng-content you'll need to set
                // the index in the constructor appropriately
                /** @type {?} */
                var element = [];
                element[index] = [el.nativeElement];
                // We're assuming only one projection slot, but in more complex cases we might want to provide
                // a different array of projected elements.
                /** @type {?} */
                var containerRef = vcr.createComponent(factory, undefined, undefined, element);
                // We can now remove the useless anchor
                vcr.remove(0);
                // We note that the container was dynamically created
                containerRef.instance._dynamic = true;
                // We keep the wrapper's injector to access the dependencies that weren't available before.
                this.injector = containerRef.injector;
            }
        }
        /**
         * @template T
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        HostWrapper.prototype.get = /**
         * @template T
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
            function (token, notFoundValue) {
                return this.injector.get(token, notFoundValue);
            };
        return HostWrapper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template W
     */
    var WrappedFormControl = /** @class */ (function () {
        // I lost way too much time trying to make this work without injecting the ViewContainerRef and the Injector,
        // I'm giving up. So we have to inject these two manually for now.
        function WrappedFormControl(wrapperType, vcr, index) {
            if (index === void 0) {
                index = 0;
            }
            this.wrapperType = wrapperType;
            this.vcr = vcr;
            this.index = index;
        }
        Object.defineProperty(WrappedFormControl.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return this._id;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                if (this.controlIdService) {
                    this.controlIdService.id = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template T
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
        WrappedFormControl.prototype.getProviderFromContainer = /**
         * @template T
         * @param {?} token
         * @param {?=} notFoundValue
         * @return {?}
         */
            function (token, notFoundValue) {
                return this._containerInjector.get(token, notFoundValue);
            };
        /**
         * @return {?}
         */
        WrappedFormControl.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._containerInjector = new HostWrapper(this.wrapperType, this.vcr, this.index);
                this.controlIdService = this._containerInjector.get(ControlIdService);
                if (this._id) {
                    this.controlIdService.id = this._id;
                }
                else {
                    this._id = this.controlIdService.id;
                }
                // No need to subscribe to controlIdService.idChange because the input is the only one that can update the id.
            };
        WrappedFormControl.propDecorators = {
            id: [{ type: i0.HostBinding }, { type: i0.Input }]
        };
        return WrappedFormControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCheckbox = /** @class */ (function (_super) {
        __extends(ClrCheckbox, _super);
        function ClrCheckbox(vcr, ngControlService, ifErrorService, control, controlClassService, el, renderer) {
            var _this = _super.call(this, ClrCheckboxWrapper, vcr, 0) || this;
            _this.ngControlService = ngControlService;
            _this.ifErrorService = ifErrorService;
            _this.control = control;
            if (controlClassService) {
                controlClassService.initControlClass(renderer, el.nativeElement);
            }
            return _this;
        }
        /**
         * @return {?}
         */
        ClrCheckbox.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.ngControlService) {
                    this.ngControlService.setControl(this.control);
                }
            };
        /**
         * @return {?}
         */
        ClrCheckbox.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
            };
        ClrCheckbox.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrCheckbox]' },] }
        ];
        /** @nocollapse */
        ClrCheckbox.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService, decorators: [{ type: i0.Optional }] },
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        ClrCheckbox.propDecorators = {
            onBlur: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return ClrCheckbox;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCheckboxContainer = /** @class */ (function () {
        // @TODO Solve for group validation, which doesn't work now with ngModelGroup
        // Blocked by https://github.com/angular/angular/issues/20268
        // @Input()
        // set clrFormGroup(value: FormGroup) {
        //   this.formGroup = value;
        // }
        // @Input()
        // set clrFormArray(value: FormArray) {
        //   this.formGroup = value;
        // }
        function ClrCheckboxContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this.inline = false;
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        Object.defineProperty(ClrCheckboxContainer.prototype, "clrInline", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline;
            },
            // private formGroup: AbstractControl;
            /*
             * Here we want to support the following cases
             * clrInline - true by presence
             * clrInline="true|false" - unless it is explicitly false, strings are considered true
             * [clrInline]="true|false" - expect a boolean
             */
            set: 
            // private formGroup: AbstractControl;
            /*
               * Here we want to support the following cases
               * clrInline - true by presence
               * clrInline="true|false" - unless it is explicitly false, strings are considered true
               * [clrInline]="true|false" - expect a boolean
               */
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === 'string') {
                    this.inline = value === 'false' ? false : true;
                }
                else {
                    this.inline = !!value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // @TODO put a solution in for form group validation
                // if (!this.formGroup) {
                this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (control) {
                    _this.invalid = control.invalid;
                }));
                // } else {
                //   // Because ngModel does this, we have to delay a tick to get the result
                //   Promise.resolve().then(() => {
                //     this.subscriptions.push(
                //       this.formGroup.statusChanges.subscribe(() => {
                //         this.invalid = this.formGroup.invalid;
                //       })
                //     );
                //   });
                // }
            };
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
            };
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrCheckboxContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
            };
        ClrCheckboxContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-checkbox-container',
                        template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-checkbox-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n  ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [NgControlService, ControlClassService, IfErrorService]
                    }] }
        ];
        /** @nocollapse */
        ClrCheckboxContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrCheckboxContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }],
            clrInline: [{ type: i0.Input }]
        };
        return ClrCheckboxContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCheckboxModule = /** @class */ (function () {
        function ClrCheckboxModule() {
        }
        ClrCheckboxModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
                        declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                        exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                        entryComponents: [ClrCheckboxWrapper],
                    },] }
        ];
        return ClrCheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var activeCounter = 0;
    /** @type {?} */
    var IF_ACTIVE_ID = new i0.InjectionToken('IF_ACTIVE_ID');
    /**
     * @return {?}
     */
    function tokenFactory() {
        return ++activeCounter;
    }
    /** @type {?} */
    var IF_ACTIVE_ID_PROVIDER = {
        provide: IF_ACTIVE_ID,
        useFactory: tokenFactory,
    };
    var IfActiveService = /** @class */ (function () {
        function IfActiveService() {
            /**
             * *****
             * \@property _currentChange
             *
             * \@description
             * A RXJS Subject that updates and provides subscriptions to for the current current state of a component template
             * implemting the IfActive structural directive.
             *
             */
            this._currentChange = new rxjs.Subject();
        }
        Object.defineProperty(IfActiveService.prototype, "currentChange", {
            /*********
             *
             * @description
             * A getter function that provides an observable for the _current Subject.
             *
             */
            get: /**
             * ******
             *
             * \@description
             * A getter function that provides an observable for the _current Subject.
             *
             * @return {?}
             */ function () {
                return this._currentChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IfActiveService.prototype, "current", {
            /*********
             *
             * @description
             * A getter that returns the current value of this IfActive instance.
             * @returns
             */
            get: /**
             * ******
             *
             * \@description
             * A getter that returns the current value of this IfActive instance.
             * @return {?}
             */ function () {
                return this._current;
            },
            /*********
             *
             * @description
             * A setter function that updates the current state of _current for this instance of IfActive structural directive.
             * And, broadcasts the new value to all subscribers.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter function that updates the current state of _current for this instance of IfActive structural directive.
             * And, broadcasts the new value to all subscribers.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._current !== value) {
                    this._current = value;
                    this._currentChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        IfActiveService.decorators = [
            { type: i0.Injectable }
        ];
        return IfActiveService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfActive = /** @class */ (function () {
        function ClrIfActive(ifActiveService, id, template, container) {
            var _this = this;
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.template = template;
            this.container = container;
            this.wasActive = false;
            /**
             * *******
             * \@property activeChange
             *
             * \@description
             * An event emitter that emits when the active property is set to allow for 2way binding when the directive is
             * used with de-structured / de-sugared syntax.
             *
             */
            this.activeChange = new i0.EventEmitter(false);
            this.checkAndUpdateView(ifActiveService.current);
            this.subscription = this.ifActiveService.currentChange.subscribe(function (newCurrentId) {
                _this.checkAndUpdateView(newCurrentId);
            });
        }
        /**
         * @param {?} currentId
         * @return {?}
         */
        ClrIfActive.prototype.checkAndUpdateView = /**
         * @param {?} currentId
         * @return {?}
         */
            function (currentId) {
                /** @type {?} */
                var isNowActive = currentId === this.id;
                // only emit if the new active state is changed since last time.
                if (isNowActive !== this.wasActive) {
                    this.updateView(isNowActive);
                    this.activeChange.emit(isNowActive);
                    this.wasActive = isNowActive;
                }
            };
        Object.defineProperty(ClrIfActive.prototype, "active", {
            /********
             *
             * @description
             * A getter that returns the current IfActiveService.active value.
             */
            get: /**
             * *****
             *
             * \@description
             * A getter that returns the current IfActiveService.active value.
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            /*********
             *
             * @description
             * A setter that updates IfActiveService.active with value.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter that updates IfActiveService.active with value.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this.ifActiveService.current = this.id;
                }
            },
            enumerable: true,
            configurable: true
        });
        /*********
         *
         * @description
         * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param value
         */
        /**
         * ******
         *
         * \@description
         * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
        ClrIfActive.prototype.updateView = /**
         * ******
         *
         * \@description
         * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.container.createEmbeddedView(this.template);
                }
                else {
                    this.container.clear();
                }
            };
        /**
         * @return {?}
         */
        ClrIfActive.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        ClrIfActive.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfActive]' },] }
        ];
        /** @nocollapse */
        ClrIfActive.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrIfActive.propDecorators = {
            active: [{ type: i0.Input, args: ['clrIfActive',] }],
            activeChange: [{ type: i0.Output, args: ['clrIfActiveChange',] }]
        };
        return ClrIfActive;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var IfOpenService = /** @class */ (function () {
        function IfOpenService() {
            /**
             * *****
             * \@property _openChange
             *
             * \@description
             * A RXJS Subject that updates and provides subscriptions to for the current open state of a component template
             * implemting the IfOpen structural directive.
             */
            this._openChange = new rxjs.Subject();
            /**
             *  Popovers might need to ignore click events on an element
             *  (eg: popover opens on focus on an input field. Clicks should be ignored in this case)
             */
            this._ignoredElementChange = new rxjs.Subject();
        }
        Object.defineProperty(IfOpenService.prototype, "openChange", {
            /*********
             *
             * @description
             * A getter function that provides an observable for the _opened Subject.
             *
             */
            get: /**
             * ******
             *
             * \@description
             * A getter function that provides an observable for the _opened Subject.
             *
             * @return {?}
             */ function () {
                return this._openChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IfOpenService.prototype, "open", {
            /*********
             *
             * @description
             * A getter that returns the current value of this IfOpen instance.
             *
             */
            get: /**
             * ******
             *
             * \@description
             * A getter that returns the current value of this IfOpen instance.
             *
             * @return {?}
             */ function () {
                return this._open;
            },
            /*********
             *
             * @description
             * A setter function that updates the current state of _open for this instance of IfOpen structural directive. And,
             * broadcasts the new value to all subscribers.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter function that updates the current state of _open for this instance of IfOpen structural directive. And,
             * broadcasts the new value to all subscribers.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this._open !== value) {
                    this._open = value;
                    this._openChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        IfOpenService.prototype.toggleWithEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.originalEvent = event;
                this.open = !this.open;
                delete this.originalEvent;
            };
        Object.defineProperty(IfOpenService.prototype, "ignoredElementChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._ignoredElementChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} element
         * @return {?}
         */
        IfOpenService.prototype.registerIgnoredElement = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                this._ignoredElementChange.next(element);
            };
        IfOpenService.decorators = [
            { type: i0.Injectable }
        ];
        return IfOpenService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfOpen = /** @class */ (function () {
        function ClrIfOpen(ifOpenService, template, container) {
            var _this = this;
            this.ifOpenService = ifOpenService;
            this.template = template;
            this.container = container;
            /**
             * *******
             * \@property openChange
             *
             * \@description
             * An event emitter that emits when the open property is set to allow for 2way binding when the directive is
             * used with de-structured / de-sugared syntax.
             */
            this.openChange = new i0.EventEmitter(false);
            this.subscription = this.ifOpenService.openChange.subscribe(function (change) {
                _this.updateView(change);
                _this.openChange.emit(change);
            });
        }
        Object.defineProperty(ClrIfOpen.prototype, "open", {
            /********
             *
             * @description
             * A getter that returns the current IfOpenService.open value.
             *
             */
            get: /**
             * *****
             *
             * \@description
             * A getter that returns the current IfOpenService.open value.
             *
             * @return {?}
             */ function () {
                return this.ifOpenService.open;
            },
            /*********
             *
             * @description
             * A setter that updates IfOpenService.open with value.
             *
             * @param value
             */
            set: /**
             * ******
             *
             * \@description
             * A setter that updates IfOpenService.open with value.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.ifOpenService.open = value;
            },
            enumerable: true,
            configurable: true
        });
        /*********
         *
         * @description
         * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param value
         */
        /**
         * ******
         *
         * \@description
         * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
        ClrIfOpen.prototype.updateView = /**
         * ******
         *
         * \@description
         * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
         * Clears all views from the ViewContainerRef
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.container.createEmbeddedView(this.template);
                }
                else {
                    this.container.clear();
                }
            };
        /**
         * @return {?}
         */
        ClrIfOpen.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        ClrIfOpen.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfOpen]' },] }
        ];
        /** @nocollapse */
        ClrIfOpen.ctorParameters = function () {
            return [
                { type: IfOpenService },
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrIfOpen.propDecorators = {
            open: [{ type: i0.Input, args: ['clrIfOpen',] }],
            openChange: [{ type: i0.Output, args: ['clrIfOpenChange',] }]
        };
        return ClrIfOpen;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CONDITIONAL_DIRECTIVES = [ClrIfActive, ClrIfOpen];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrConditionalModule = /** @class */ (function () {
        function ClrConditionalModule() {
        }
        ClrConditionalModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CONDITIONAL_DIRECTIVES], exports: [CONDITIONAL_DIRECTIVES] },] }
        ];
        return ClrConditionalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var FocusTrapTracker = /** @class */ (function () {
        function FocusTrapTracker() {
            this._previousFocusTraps = [];
        }
        Object.defineProperty(FocusTrapTracker.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._previousFocusTraps.push(this._current);
                this._current = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusTrapTracker.prototype, "nbFocusTrappers", {
            get: /**
             * @return {?}
             */ function () {
                return this._previousFocusTraps.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FocusTrapTracker.prototype.activatePreviousTrapper = /**
         * @return {?}
         */
            function () {
                this._current = this._previousFocusTraps.pop();
            };
        FocusTrapTracker.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ FocusTrapTracker.ngInjectableDef = i0.defineInjectable({ factory: function FocusTrapTracker_Factory() { return new FocusTrapTracker(); }, token: FocusTrapTracker, providedIn: "root" });
        return FocusTrapTracker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var FocusTrapDirective = /** @class */ (function () {
        function FocusTrapDirective(el, injector, focusTrapsTracker, renderer, platformId) {
            this.el = el;
            this.injector = injector;
            this.focusTrapsTracker = focusTrapsTracker;
            this.renderer = renderer;
            this.platformId = platformId;
            this.document = this.injector.get(common.DOCUMENT);
            this.focusTrapsTracker.current = this;
            this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
        }
        /**
         * @param {?} event
         * @return {?}
         */
        FocusTrapDirective.prototype.onFocusIn = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var nativeElement = this.el.nativeElement;
                if (this.focusTrapsTracker.current === this && event.target && !nativeElement.contains(event.target)) {
                    nativeElement.focus();
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.createFocusableOffScreenEl = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var offScreenSpan = this.renderer.createElement('span');
                this.renderer.setAttribute(offScreenSpan, 'tabindex', '0');
                this.renderer.addClass(offScreenSpan, 'offscreen-focus-rebounder');
                return offScreenSpan;
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.addReboundEls = /**
         * @return {?}
         */
            function () {
                // We will add these focus rebounding elements only in the following conditions:
                // 1. It should be running inside browser platform as it accesses document.body element
                // 2. We should NOT add them more than once. Hence, we are counting a number of focus trappers
                //    and only add on the first focus trapper.
                if (common.isPlatformBrowser(this.platformId) && this.focusTrapsTracker.nbFocusTrappers === 1) {
                    this.topReboundEl = this.createFocusableOffScreenEl();
                    this.bottomReboundEl = this.createFocusableOffScreenEl();
                    // Add reboundBeforeTrapEl to the document body as the first child
                    this.renderer.insertBefore(this.document.body, this.topReboundEl, this.document.body.firstChild);
                    // Add reboundAfterTrapEl to the document body as the last child
                    this.renderer.appendChild(this.document.body, this.bottomReboundEl);
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.removeReboundEls = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId) &&
                    this.focusTrapsTracker.nbFocusTrappers === 1 &&
                    this.topReboundEl &&
                    this.bottomReboundEl) {
                    this.renderer.removeChild(this.document.body, this.topReboundEl);
                    this.renderer.removeChild(this.document.body, this.bottomReboundEl);
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.setPreviousFocus = /**
         * @return {?}
         */
            function () {
                if (this.previousActiveElement && this.previousActiveElement.focus) {
                    this.previousActiveElement.focus();
                }
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (common.isPlatformBrowser(this.platformId)) {
                    this.previousActiveElement = ( /** @type {?} */(this.document.activeElement));
                }
                this.addReboundEls();
            };
        /**
         * @return {?}
         */
        FocusTrapDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.removeReboundEls();
                this.setPreviousFocus();
                this.focusTrapsTracker.activatePreviousTrapper();
            };
        FocusTrapDirective.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrFocusTrap]' },] }
        ];
        /** @nocollapse */
        FocusTrapDirective.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Injector },
                { type: FocusTrapTracker },
                { type: i0.Renderer2 },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        FocusTrapDirective.propDecorators = {
            onFocusIn: [{ type: i0.HostListener, args: ['document:focusin', ['$event'],] }]
        };
        return FocusTrapDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var FOCUS_TRAP_DIRECTIVES = [FocusTrapDirective];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrFocusTrapModule = /** @class */ (function () {
        function ClrFocusTrapModule() {
        }
        ClrFocusTrapModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [FOCUS_TRAP_DIRECTIVES],
                        exports: [FOCUS_TRAP_DIRECTIVES],
                    },] }
        ];
        return ClrFocusTrapModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2017 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @type {?} */
    var UP_ARROW = 38;
    /** @type {?} */
    var DOWN_ARROW = 40;
    /** @type {?} */
    var RIGHT_ARROW = 39;
    /** @type {?} */
    var LEFT_ARROW = 37;
    /** @type {?} */
    var ESC = 27;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * This is the en-001 short locale date format. Setting as default.
     * @type {?}
     */
    var DEFAULT_LOCALE_FORMAT = 'dd/MM/y';
    // https://en.wikipedia.org/wiki/Date_format_by_country
    /** @type {?} */
    var LITTLE_ENDIAN_REGEX = /d+.+m+.+y+/i;
    /** @type {?} */
    var MIDDLE_ENDIAN_REGEX = /m+.+d+.+y+/i;
    // No need for BIG_ENDIAN_REGEX because anything that doesn't satisfy the above 2
    // is automatically BIG_ENDIAN
    /** @type {?} */
    var DELIMITER_REGEX = /d+|m+|y+/i;
    /** @type {?} */
    var USER_INPUT_REGEX = /\d+/g;
    /** @type {?} */
    var MOBILE_USERAGENT_REGEX = /Mobi/i;
    /** @type {?} */
    var RTL_REGEX = /\u200f/g;
    /** @type {?} */
    var YEAR = 'YYYY';
    /** @type {?} */
    var MONTH = 'MM';
    /** @type {?} */
    var DATE = 'DD';
    /** @type {?} */
    var LITTLE_ENDIAN = {
        name: 'LITTLE_ENDIAN',
        format: [DATE, MONTH, YEAR],
    };
    /** @type {?} */
    var MIDDLE_ENDIAN = {
        name: 'MIDDLE_ENDIAN',
        format: [MONTH, DATE, YEAR],
    };
    /** @type {?} */
    var BIG_ENDIAN = {
        name: 'BIG_ENDIAN',
        format: [YEAR, MONTH, DATE],
    };
    /** @type {?} */
    var NO_OF_DAYS_IN_A_WEEK = 7;
    /** @type {?} */
    var NO_OF_ROWS_IN_CALENDAR_VIEW = 6;
    /** @type {?} */
    var TOTAL_DAYS_IN_DAYS_VIEW = NO_OF_DAYS_IN_A_WEEK * NO_OF_ROWS_IN_CALENDAR_VIEW;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Returns the number of days in a month.
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function getNumberOfDaysInTheMonth(year, month) {
        // If we go to the next month, but use a day of 0, it returns the last day from the previous month
        return new Date(year, month + 1, 0).getDate();
    }
    /**
     * Returns the day for the corresponding date where 0 represents Sunday.
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    function getDay(year, month, date) {
        return new Date(year, month, date).getDay();
    }
    /**
     * Takes in a year and if it is a 2 digit year, returns the corresponding 4 digit year.
     * Window of 80 years before and 20 years after the present year.
     * Credit: https://github.com/globalizejs/globalize/blob/e1b31cd6a4f1cff75b185b68b7a32220aac5196f/src/date/parse.js
     * @param {?} year
     * @return {?}
     */
    function parseToFourDigitYear(year) {
        if (year > 9999 || (year > 100 && year < 999) || year < 10) {
            return -1;
        }
        if (year > 999) {
            return year;
        }
        /** @type {?} */
        var currYear = new Date().getFullYear();
        /** @type {?} */
        var century = Math.floor(currYear / 100) * 100;
        /** @type {?} */
        var result = year + century;
        if (result > currYear + 20) {
            result = result - 100;
        }
        return result;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var DayViewModel = /** @class */ (function () {
        function DayViewModel(dayModel, isTodaysDate, isDisabled, isSelected, isFocusable) {
            if (isTodaysDate === void 0) {
                isTodaysDate = false;
            }
            if (isDisabled === void 0) {
                isDisabled = false;
            }
            if (isSelected === void 0) {
                isSelected = false;
            }
            if (isFocusable === void 0) {
                isFocusable = false;
            }
            this.dayModel = dayModel;
            this.isTodaysDate = isTodaysDate;
            this.isDisabled = isDisabled;
            this.isSelected = isSelected;
            this.isFocusable = isFocusable;
        }
        Object.defineProperty(DayViewModel.prototype, "tabIndex", {
            /**
             * Gets the tab index based on the isFocusable flag.
             */
            get: /**
             * Gets the tab index based on the isFocusable flag.
             * @return {?}
             */ function () {
                return this.isFocusable ? 0 : -1;
            },
            enumerable: true,
            configurable: true
        });
        return DayViewModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CalendarModel = /** @class */ (function () {
        function CalendarModel(year, month) {
            this.year = year;
            this.month = month;
            this.initializeDaysInCalendar();
        }
        /**
         * Populates the days array with the DayModels in the current Calendar.
         */
        /**
         * Populates the days array with the DayModels in the current Calendar.
         * @return {?}
         */
        CalendarModel.prototype.initializeDaysInCalendar = /**
         * Populates the days array with the DayModels in the current Calendar.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var noOfDaysInCalendar = getNumberOfDaysInTheMonth(this.year, this.month);
                this.days = Array(noOfDaysInCalendar)
                    .fill(null)
                    .map(function (date, index) {
                    return new DayModel(_this.year, _this.month, index + 1);
                });
            };
        /**
         * Checks if the calendar passed is equal to the current calendar.
         */
        /**
         * Checks if the calendar passed is equal to the current calendar.
         * @param {?} calendar
         * @return {?}
         */
        CalendarModel.prototype.isEqual = /**
         * Checks if the calendar passed is equal to the current calendar.
         * @param {?} calendar
         * @return {?}
         */
            function (calendar) {
                if (calendar) {
                    return this.year === calendar.year && this.month === calendar.month;
                }
                return false;
            };
        /**
         * Checks if a DayModel is in the Calendar
         */
        /**
         * Checks if a DayModel is in the Calendar
         * @param {?} day
         * @return {?}
         */
        CalendarModel.prototype.isDayInCalendar = /**
         * Checks if a DayModel is in the Calendar
         * @param {?} day
         * @return {?}
         */
            function (day) {
                if (day) {
                    return this.year === day.year && this.month === day.month;
                }
                return false;
            };
        /**
         * Returns CalendarModel of the previous month.
         */
        /**
         * Returns CalendarModel of the previous month.
         * @return {?}
         */
        CalendarModel.prototype.previousMonth = /**
         * Returns CalendarModel of the previous month.
         * @return {?}
         */
            function () {
                if (this.month === 0) {
                    return new CalendarModel(this.year - 1, 11);
                }
                else {
                    return new CalendarModel(this.year, this.month - 1);
                }
            };
        /**
         * Returns CalendarModel of the next month.
         */
        /**
         * Returns CalendarModel of the next month.
         * @return {?}
         */
        CalendarModel.prototype.nextMonth = /**
         * Returns CalendarModel of the next month.
         * @return {?}
         */
            function () {
                if (this.month === 11) {
                    return new CalendarModel(this.year + 1, 0);
                }
                else {
                    return new CalendarModel(this.year, this.month + 1);
                }
            };
        return CalendarModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DayModel = /** @class */ (function () {
        function DayModel(year, month, date) {
            this.year = year;
            this.month = month;
            this.date = date;
        }
        Object.defineProperty(DayModel.prototype, "calendar", {
            /**
             * Returns the Calendar for the current DayModel.
             */
            get: /**
             * Returns the Calendar for the current DayModel.
             * @return {?}
             */ function () {
                return new CalendarModel(this.year, this.month);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if the passed CalendarDate is equal to itself.
         */
        /**
         * Checks if the passed CalendarDate is equal to itself.
         * @param {?} day
         * @return {?}
         */
        DayModel.prototype.isEqual = /**
         * Checks if the passed CalendarDate is equal to itself.
         * @param {?} day
         * @return {?}
         */
            function (day) {
                if (day) {
                    return this.year === day.year && this.month === day.month && this.date === day.date;
                }
                return false;
            };
        /**
         * Converts the CalendarDate into the Javascript Date object.
         */
        /**
         * Converts the CalendarDate into the Javascript Date object.
         * @return {?}
         */
        DayModel.prototype.toDate = /**
         * Converts the CalendarDate into the Javascript Date object.
         * @return {?}
         */
            function () {
                return new Date(this.year, this.month, this.date);
            };
        /**
         * Returns a new DayModel which is incremented based on the value passed.
         */
        /**
         * Returns a new DayModel which is incremented based on the value passed.
         * @param {?} value
         * @return {?}
         */
        DayModel.prototype.incrementBy = /**
         * Returns a new DayModel which is incremented based on the value passed.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // Creating new Javascript Date object to increment because
                // it will automatically take care of switching to next or previous
                // months & years without we having to worry about it.
                /** @type {?} */
                var date = new Date(this.year, this.month, this.date + value);
                return new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
            };
        /**
         * Clones the current day model.
         */
        /**
         * Clones the current day model.
         * @return {?}
         */
        DayModel.prototype.clone = /**
         * Clones the current day model.
         * @return {?}
         */
            function () {
                return new DayModel(this.year, this.month, this.date);
            };
        return DayModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var CalendarViewModel = /** @class */ (function () {
        function CalendarViewModel(calendar, selectedDay, focusableDay, today, firstDayOfWeek) {
            this.calendar = calendar;
            this.selectedDay = selectedDay;
            this.focusableDay = focusableDay;
            this.today = today;
            this.firstDayOfWeek = firstDayOfWeek;
            this.currMonthDayViews = [];
            this.initializeCalendarView();
        }
        Object.defineProperty(CalendarViewModel.prototype, "calendarView", {
            /**
             * DayViewModel matrix. Size 6x7
             */
            get: /**
             * DayViewModel matrix. Size 6x7
             * @return {?}
             */ function () {
                return this._calendarView;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Generates a 6x7 matrix of DayViewModel based on the Calendar.
         * The 6x7 matrix is structured according to the first day of the week.
         * 6 rows to accommodate months which might have dates spanning over 6 weeks.
         * 7 columns because there are 7 days in a week :P :D
         */
        /**
         * Generates a 6x7 matrix of DayViewModel based on the Calendar.
         * The 6x7 matrix is structured according to the first day of the week.
         * 6 rows to accommodate months which might have dates spanning over 6 weeks.
         * 7 columns because there are 7 days in a week :P :D
         * @return {?}
         */
        CalendarViewModel.prototype.initializeCalendarView = /**
         * Generates a 6x7 matrix of DayViewModel based on the Calendar.
         * The 6x7 matrix is structured according to the first day of the week.
         * 6 rows to accommodate months which might have dates spanning over 6 weeks.
         * 7 columns because there are 7 days in a week :P :D
         * @return {?}
         */
            function () {
                // Generate prev and next month calendar models.
                /** @type {?} */
                var prevMonthCalendar = this.calendar.previousMonth();
                /** @type {?} */
                var nextMonthCalendar = this.calendar.nextMonth();
                // Get no of days from prev and next months.
                /** @type {?} */
                var daysFromPrevMonthInCalView = this.numDaysFromPrevMonthInCalView(this.calendar.year, this.calendar.month);
                /** @type {?} */
                var daysFromNextMonthInCalView = TOTAL_DAYS_IN_DAYS_VIEW - (this.calendar.days.length + daysFromPrevMonthInCalView);
                // Generate prev, curr and next day view models
                /** @type {?} */
                var prevMonthDayViews = [];
                /** @type {?} */
                var nextMonthDayViews = [];
                if (daysFromPrevMonthInCalView > 0) {
                    prevMonthDayViews = this.generateDayViewModels(prevMonthCalendar.days.slice(-1 * daysFromPrevMonthInCalView), true, false);
                }
                this.currMonthDayViews = this.generateDayViewModels(this.calendar.days, false, true);
                if (daysFromNextMonthInCalView > 0) {
                    nextMonthDayViews = this.generateDayViewModels(nextMonthCalendar.days.slice(0, daysFromNextMonthInCalView), true, false);
                }
                // Generate calendar view and initialize flags
                this._calendarView = this.generateCalendarView(prevMonthDayViews, this.currMonthDayViews, nextMonthDayViews);
                this.initializeSelectedDay();
                this.initializeFocusableDay();
            };
        /**
         * Generates a DayViewModel array based on the DayModel passed
         */
        /**
         * Generates a DayViewModel array based on the DayModel passed
         * @param {?} days
         * @param {?} isDisabled
         * @param {?} isCurrentCalendar
         * @return {?}
         */
        CalendarViewModel.prototype.generateDayViewModels = /**
         * Generates a DayViewModel array based on the DayModel passed
         * @param {?} days
         * @param {?} isDisabled
         * @param {?} isCurrentCalendar
         * @return {?}
         */
            function (days, isDisabled, isCurrentCalendar) {
                /** @type {?} */
                var dayViews = days.map(function (day) {
                    return new DayViewModel(day, false, isDisabled, false, false);
                });
                if (isCurrentCalendar && this.calendar.isDayInCalendar(this.today)) {
                    dayViews[this.today.date - 1].isTodaysDate = true;
                }
                return dayViews;
            };
        /**
         * Gets the first day of the current month to figure out how many dates of previous month
         * are needed to complete the Calendar View based on the first day of the week.
         * eg: Assuming locale en-US, the first day of the week is Sunday,
         * if first day of the current month lands on Wednesday, then
         * (this.getDay function would return 3 since
         * first day of the week is 0), we need the 3 days from the previous month.
         */
        /**
         * Gets the first day of the current month to figure out how many dates of previous month
         * are needed to complete the Calendar View based on the first day of the week.
         * eg: Assuming locale en-US, the first day of the week is Sunday,
         * if first day of the current month lands on Wednesday, then
         * (this.getDay function would return 3 since
         * first day of the week is 0), we need the 3 days from the previous month.
         * @param {?} currentYear
         * @param {?} currentMonth
         * @return {?}
         */
        CalendarViewModel.prototype.numDaysFromPrevMonthInCalView = /**
         * Gets the first day of the current month to figure out how many dates of previous month
         * are needed to complete the Calendar View based on the first day of the week.
         * eg: Assuming locale en-US, the first day of the week is Sunday,
         * if first day of the current month lands on Wednesday, then
         * (this.getDay function would return 3 since
         * first day of the week is 0), we need the 3 days from the previous month.
         * @param {?} currentYear
         * @param {?} currentMonth
         * @return {?}
         */
            function (currentYear, currentMonth) {
                /** @type {?} */
                var firstDayOfCurrMonth = getDay(currentYear, currentMonth, 1);
                if (firstDayOfCurrMonth >= this.firstDayOfWeek) {
                    return firstDayOfCurrMonth - this.firstDayOfWeek;
                }
                else {
                    return NO_OF_DAYS_IN_A_WEEK + firstDayOfCurrMonth - this.firstDayOfWeek;
                }
            };
        /**
         * Checks if the Day passed is in the CalendarView.
         */
        /**
         * Checks if the Day passed is in the CalendarView.
         * @param {?} day
         * @return {?}
         */
        CalendarViewModel.prototype.isDayInCalendarView = /**
         * Checks if the Day passed is in the CalendarView.
         * @param {?} day
         * @return {?}
         */
            function (day) {
                if (!this.calendar.isDayInCalendar(day)) {
                    return false;
                }
                return true;
            };
        /**
         * Using the DayViewModels from the previous, current and next month, this function
         * generates the CalendarView.
         */
        /**
         * Using the DayViewModels from the previous, current and next month, this function
         * generates the CalendarView.
         * @param {?} prev
         * @param {?} curr
         * @param {?} next
         * @return {?}
         */
        CalendarViewModel.prototype.generateCalendarView = /**
         * Using the DayViewModels from the previous, current and next month, this function
         * generates the CalendarView.
         * @param {?} prev
         * @param {?} curr
         * @param {?} next
         * @return {?}
         */
            function (prev, curr, next) {
                /** @type {?} */
                var combinationArr = __spread(prev, curr, next);
                /** @type {?} */
                var calendarView = [];
                for (var i = 0; i < NO_OF_ROWS_IN_CALENDAR_VIEW; i++) {
                    calendarView[i] = combinationArr.slice(i * NO_OF_DAYS_IN_A_WEEK, (i + 1) * NO_OF_DAYS_IN_A_WEEK);
                }
                return calendarView;
            };
        /**
         * Initialize the selected day if the day is in the calendar.
         */
        /**
         * Initialize the selected day if the day is in the calendar.
         * @return {?}
         */
        CalendarViewModel.prototype.initializeSelectedDay = /**
         * Initialize the selected day if the day is in the calendar.
         * @return {?}
         */
            function () {
                if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
                    this.currMonthDayViews[this.selectedDay.date - 1].isSelected = true;
                }
            };
        /**
         * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
         * we check for the selected day. If selected day is not set then check if today is in the current
         * calendar. If not then just set the 15th of the current calendar month.
         */
        /**
         * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
         * we check for the selected day. If selected day is not set then check if today is in the current
         * calendar. If not then just set the 15th of the current calendar month.
         * @return {?}
         */
        CalendarViewModel.prototype.initializeFocusableDay = /**
         * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
         * we check for the selected day. If selected day is not set then check if today is in the current
         * calendar. If not then just set the 15th of the current calendar month.
         * @return {?}
         */
            function () {
                if (this.focusableDay && this.isDayInCalendarView(this.focusableDay)) {
                    this.setFocusableFlag(this.focusableDay, true);
                }
                else if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
                    this.setFocusableFlag(this.selectedDay, true);
                    this.focusableDay = this.selectedDay.clone();
                }
                else if (this.isDayInCalendarView(this.today)) {
                    this.setFocusableFlag(this.today, true);
                    this.focusableDay = this.today.clone();
                }
                else {
                    this.focusableDay = new DayModel(this.calendar.year, this.calendar.month, 15);
                    this.setFocusableFlag(this.focusableDay, true);
                }
            };
        /**
         * @param {?} day
         * @param {?} flag
         * @return {?}
         */
        CalendarViewModel.prototype.setFocusableFlag = /**
         * @param {?} day
         * @param {?} flag
         * @return {?}
         */
            function (day, flag) {
                if (day) {
                    this.currMonthDayViews[day.date - 1].isFocusable = flag;
                }
            };
        /**
         * Updates the focusable day in the calendar.
         */
        /**
         * Updates the focusable day in the calendar.
         * @param {?} day
         * @return {?}
         */
        CalendarViewModel.prototype.updateFocusableDay = /**
         * Updates the focusable day in the calendar.
         * @param {?} day
         * @return {?}
         */
            function (day) {
                this.setFocusableFlag(this.focusableDay, false);
                this.setFocusableFlag(day, true);
                this.focusableDay = day;
            };
        return CalendarViewModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service is responsible for:
     * 1. Initializing the displayed calendar.
     * 2. Moving the calendar to the next, previous or current months
     * 3. Managing the focused and selected day models.
     */
    var DateNavigationService = /** @class */ (function () {
        function DateNavigationService() {
            /**
             * Variable to store today's date.
             */
            this._todaysFullDate = new Date();
            this._selectedDayChange = new rxjs.Subject();
            this._displayedCalendarChange = new rxjs.Subject();
            this._focusOnCalendarChange = new rxjs.Subject();
            this._focusedDayChange = new rxjs.Subject();
        }
        Object.defineProperty(DateNavigationService.prototype, "displayedCalendar", {
            get: /**
             * @return {?}
             */ function () {
                return this._displayedCalendar;
            },
            enumerable: true,
            configurable: true
        });
        // not a setter because i want this to remain private
        // not a setter because i want this to remain private
        /**
         * @param {?} value
         * @return {?}
         */
        DateNavigationService.prototype.setDisplayedCalendar =
            // not a setter because i want this to remain private
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (!this._displayedCalendar.isEqual(value)) {
                    this._displayedCalendar = value;
                    this._displayedCalendarChange.next();
                }
            };
        /**
         * @return {?}
         */
        DateNavigationService.prototype.initializeTodaysDate = /**
         * @return {?}
         */
            function () {
                this._todaysFullDate = new Date();
                this._today = new DayModel(this._todaysFullDate.getFullYear(), this._todaysFullDate.getMonth(), this._todaysFullDate.getDate());
            };
        Object.defineProperty(DateNavigationService.prototype, "today", {
            get: /**
             * @return {?}
             */ function () {
                return this._today;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "selectedDayChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectedDayChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Notifies that the selected day has changed so that the date can be emitted to the user.
         * Note: Only to be called from day.ts
         */
        /**
         * Notifies that the selected day has changed so that the date can be emitted to the user.
         * Note: Only to be called from day.ts
         * @param {?} dayModel
         * @return {?}
         */
        DateNavigationService.prototype.notifySelectedDayChanged = /**
         * Notifies that the selected day has changed so that the date can be emitted to the user.
         * Note: Only to be called from day.ts
         * @param {?} dayModel
         * @return {?}
         */
            function (dayModel) {
                if (dayModel.isEqual(this.selectedDay)) {
                    return;
                }
                this.selectedDay = dayModel;
                this._selectedDayChange.next(dayModel);
            };
        /**
         * Initializes the calendar based on the selected day.
         */
        /**
         * Initializes the calendar based on the selected day.
         * @return {?}
         */
        DateNavigationService.prototype.initializeCalendar = /**
         * Initializes the calendar based on the selected day.
         * @return {?}
         */
            function () {
                this.focusedDay = null; // Can be removed later on the store focus
                this.initializeTodaysDate();
                if (this.selectedDay) {
                    this._displayedCalendar = new CalendarModel(this.selectedDay.year, this.selectedDay.month);
                }
                else {
                    this._displayedCalendar = new CalendarModel(this.today.year, this.today.month);
                }
            };
        /**
         * @param {?} month
         * @return {?}
         */
        DateNavigationService.prototype.changeMonth = /**
         * @param {?} month
         * @return {?}
         */
            function (month) {
                this.setDisplayedCalendar(new CalendarModel(this._displayedCalendar.year, month));
            };
        /**
         * @param {?} year
         * @return {?}
         */
        DateNavigationService.prototype.changeYear = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.setDisplayedCalendar(new CalendarModel(year, this._displayedCalendar.month));
            };
        /**
         * Moves the displayed calendar to the next month.
         */
        /**
         * Moves the displayed calendar to the next month.
         * @return {?}
         */
        DateNavigationService.prototype.moveToNextMonth = /**
         * Moves the displayed calendar to the next month.
         * @return {?}
         */
            function () {
                this.setDisplayedCalendar(this._displayedCalendar.nextMonth());
            };
        /**
         * Moves the displayed calendar to the previous month.
         */
        /**
         * Moves the displayed calendar to the previous month.
         * @return {?}
         */
        DateNavigationService.prototype.moveToPreviousMonth = /**
         * Moves the displayed calendar to the previous month.
         * @return {?}
         */
            function () {
                this.setDisplayedCalendar(this._displayedCalendar.previousMonth());
            };
        /**
         * Moves the displayed calendar to the current month and year.
         */
        /**
         * Moves the displayed calendar to the current month and year.
         * @return {?}
         */
        DateNavigationService.prototype.moveToCurrentMonth = /**
         * Moves the displayed calendar to the current month and year.
         * @return {?}
         */
            function () {
                if (!this.displayedCalendar.isDayInCalendar(this.today)) {
                    this.setDisplayedCalendar(new CalendarModel(this.today.year, this.today.month));
                }
                this._focusOnCalendarChange.next();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        DateNavigationService.prototype.incrementFocusDay = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.focusedDay = this.focusedDay.incrementBy(value);
                if (this._displayedCalendar.isDayInCalendar(this.focusedDay)) {
                    this._focusedDayChange.next(this.focusedDay);
                }
                else {
                    this.setDisplayedCalendar(this.focusedDay.calendar);
                }
                this._focusOnCalendarChange.next();
            };
        Object.defineProperty(DateNavigationService.prototype, "displayedCalendarChange", {
            /**
             * This observable lets the subscriber know that the displayed calendar has changed.
             */
            get: /**
             * This observable lets the subscriber know that the displayed calendar has changed.
             * @return {?}
             */ function () {
                return this._displayedCalendarChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "focusOnCalendarChange", {
            /**
             * This observable lets the subscriber know that the focus should be applied on the calendar.
             */
            get: /**
             * This observable lets the subscriber know that the focus should be applied on the calendar.
             * @return {?}
             */ function () {
                return this._focusOnCalendarChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateNavigationService.prototype, "focusedDayChange", {
            /**
             * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
             */
            get: /**
             * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
             * @return {?}
             */ function () {
                return this._focusedDayChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        DateNavigationService.decorators = [
            { type: i0.Injectable }
        ];
        return DateNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service focuses the day that is focusable in the calendar.
     */
    var DatepickerFocusService = /** @class */ (function () {
        function DatepickerFocusService(_ngZone, platformId) {
            this._ngZone = _ngZone;
            this.platformId = platformId;
        }
        // Credit: Material: https://github.com/angular/material2/blob/master/src/lib/datepicker/calendar.ts
        // Credit: Material: https://github.com/angular/material2/blob/master/src/lib/datepicker/calendar.ts
        /**
         * @param {?} elRef
         * @return {?}
         */
        DatepickerFocusService.prototype.focusCell =
            // Credit: Material: https://github.com/angular/material2/blob/master/src/lib/datepicker/calendar.ts
            /**
             * @param {?} elRef
             * @return {?}
             */
            function (elRef) {
                var _this = this;
                this._ngZone.runOutsideAngular(function () {
                    _this._ngZone.onStable
                        .asObservable()
                        .pipe(operators.first())
                        .subscribe(function () {
                        if (common.isPlatformBrowser(_this.platformId)) {
                            /** @type {?} */
                            var focusEl = elRef.nativeElement.querySelector('[tabindex="0"]');
                            if (focusEl) {
                                focusEl.focus();
                            }
                        }
                    });
                });
            };
        DatepickerFocusService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DatepickerFocusService.ctorParameters = function () {
            return [
                { type: i0.NgZone },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
            ];
        };
        return DatepickerFocusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service extracts the Angular CLDR data needed by the datepicker.
     */
    var LocaleHelperService = /** @class */ (function () {
        function LocaleHelperService(locale) {
            this.locale = locale;
            this._firstDayOfWeek = 0;
            this.initializeLocaleData();
        }
        Object.defineProperty(LocaleHelperService.prototype, "firstDayOfWeek", {
            get: /**
             * @return {?}
             */ function () {
                return this._firstDayOfWeek;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeDaysNarrow", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeDaysNarrow;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeMonthsAbbreviated", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeMonthsAbbreviated;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeMonthsWide", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeMonthsWide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleHelperService.prototype, "localeDateFormat", {
            get: /**
             * @return {?}
             */ function () {
                return this._localeDateFormat;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the locale data.
         */
        /**
         * Initializes the locale data.
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleData = /**
         * Initializes the locale data.
         * @return {?}
         */
            function () {
                // Order in which these functions is called is very important.
                this.initializeFirstDayOfWeek();
                this.initializeLocaleDateFormat();
                this.initializeLocaleMonthsAbbreviated();
                this.initializeLocaleMonthsWide();
                this.initializeLocaleDaysNarrow();
            };
        /**
         * Initialize day names in the TranslationWidth.Narrow format based on the locale.
         * eg: [S, M, T...] for en-US.
         */
        /**
         * Initialize day names in the TranslationWidth.Narrow format based on the locale.
         * eg: [S, M, T...] for en-US.
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleDaysNarrow = /**
         * Initialize day names in the TranslationWidth.Narrow format based on the locale.
         * eg: [S, M, T...] for en-US.
         * @return {?}
         */
            function () {
                // Get locale day names starting with Sunday
                /** @type {?} */
                var tempArr = common.getLocaleDayNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Narrow).slice();
                // Get first day of the week based on the locale
                /** @type {?} */
                var firstDayOfWeek = this.firstDayOfWeek;
                // Rearrange the tempArr to start with the first day of the week based on the locale.
                if (firstDayOfWeek > 0) {
                    /** @type {?} */
                    var prevDays = tempArr.splice(0, firstDayOfWeek);
                    tempArr.push.apply(tempArr, __spread(prevDays));
                }
                this._localeDaysNarrow = tempArr;
            };
        /**
         * Initializes the array of month names in the TranslationWidth.Abbreviated format.
         * e.g. `[Jan, Feb, ...]` for en-US
         */
        /**
         * Initializes the array of month names in the TranslationWidth.Abbreviated format.
         * e.g. `[Jan, Feb, ...]` for en-US
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleMonthsAbbreviated = /**
         * Initializes the array of month names in the TranslationWidth.Abbreviated format.
         * e.g. `[Jan, Feb, ...]` for en-US
         * @return {?}
         */
            function () {
                this._localeMonthsAbbreviated = common.getLocaleMonthNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Abbreviated).slice();
            };
        /**
         * Initializes the array of month names in the TranslationWidth.Wide format.
         * e.g. `[January, February, ...]` for en-US
         */
        /**
         * Initializes the array of month names in the TranslationWidth.Wide format.
         * e.g. `[January, February, ...]` for en-US
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleMonthsWide = /**
         * Initializes the array of month names in the TranslationWidth.Wide format.
         * e.g. `[January, February, ...]` for en-US
         * @return {?}
         */
            function () {
                this._localeMonthsWide = common.getLocaleMonthNames(this.locale, common.FormStyle.Standalone, common.TranslationWidth.Wide).slice();
            };
        /**
         * Initializes the first day of the week based on the locale.
         */
        /**
         * Initializes the first day of the week based on the locale.
         * @return {?}
         */
        LocaleHelperService.prototype.initializeFirstDayOfWeek = /**
         * Initializes the first day of the week based on the locale.
         * @return {?}
         */
            function () {
                this._firstDayOfWeek = common.getLocaleFirstDayOfWeek(this.locale);
            };
        /**
         * @return {?}
         */
        LocaleHelperService.prototype.initializeLocaleDateFormat = /**
         * @return {?}
         */
            function () {
                this._localeDateFormat = common.getLocaleDateFormat(this.locale, common.FormatWidth.Short);
            };
        LocaleHelperService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        LocaleHelperService.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
            ];
        };
        return LocaleHelperService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrCalendar = /** @class */ (function () {
        function ClrCalendar(_localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
            this._localeHelperService = _localeHelperService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this._subs = [];
            this.generateCalendarView();
            this.initializeSubscriptions();
        }
        Object.defineProperty(ClrCalendar.prototype, "localeDaysNarrow", {
            /**
             * Gets the locale days according to the TranslationWidth.Narrow format.
             */
            get: /**
             * Gets the locale days according to the TranslationWidth.Narrow format.
             * @return {?}
             */ function () {
                return this._localeHelperService.localeDaysNarrow;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "calendar", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "selectedDay", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.selectedDay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "focusedDay", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.focusedDay;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCalendar.prototype, "today", {
            get: /**
             * @return {?}
             */ function () {
                return this._dateNavigationService.today;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initialize subscriptions to:
         * 1. update the calendar view model.
         * 2. update the focusable day in the calendar view model.
         * 3. focus on the focusable day in the calendar.
         */
        /**
         * Initialize subscriptions to:
         * 1. update the calendar view model.
         * 2. update the focusable day in the calendar view model.
         * 3. focus on the focusable day in the calendar.
         * @return {?}
         */
        ClrCalendar.prototype.initializeSubscriptions = /**
         * Initialize subscriptions to:
         * 1. update the calendar view model.
         * 2. update the focusable day in the calendar view model.
         * 3. focus on the focusable day in the calendar.
         * @return {?}
         */
            function () {
                var _this = this;
                this._subs.push(this._dateNavigationService.displayedCalendarChange.subscribe(function () {
                    _this.generateCalendarView();
                }));
                this._subs.push(this._dateNavigationService.focusedDayChange.subscribe(function (focusedDay) {
                    _this.calendarViewModel.updateFocusableDay(focusedDay);
                }));
                this._subs.push(this._dateNavigationService.focusOnCalendarChange.subscribe(function () {
                    _this._datepickerFocusService.focusCell(_this._elRef);
                }));
            };
        /**
         * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
         */
        /**
         * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
         * @return {?}
         */
        ClrCalendar.prototype.generateCalendarView = /**
         * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
         * @return {?}
         */
            function () {
                this.calendarViewModel = new CalendarViewModel(this.calendar, this.selectedDay, this.focusedDay, this.today, this._localeHelperService.firstDayOfWeek);
            };
        /**
         * Delegates Keyboard arrow navigation to the DateNavigationService.
         */
        /**
         * Delegates Keyboard arrow navigation to the DateNavigationService.
         * @param {?} event
         * @return {?}
         */
        ClrCalendar.prototype.onKeyDown = /**
         * Delegates Keyboard arrow navigation to the DateNavigationService.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event && this.focusedDay) {
                    switch (event.keyCode) {
                        case UP_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(-1 * NO_OF_DAYS_IN_A_WEEK);
                            break;
                        case DOWN_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(NO_OF_DAYS_IN_A_WEEK);
                            break;
                        case LEFT_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(-1);
                            break;
                        case RIGHT_ARROW:
                            event.preventDefault();
                            this._dateNavigationService.incrementFocusDay(1);
                            break;
                        default:
                            break; // No default case. TSLint x-(
                    }
                }
            };
        /**
         * Focuses on the focusable day when the Calendar View is initialized.
         */
        /**
         * Focuses on the focusable day when the Calendar View is initialized.
         * @return {?}
         */
        ClrCalendar.prototype.ngAfterViewInit = /**
         * Focuses on the focusable day when the Calendar View is initialized.
         * @return {?}
         */
            function () {
                this._datepickerFocusService.focusCell(this._elRef);
            };
        /**
         * Unsubscribe from subscriptions.
         */
        /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
        ClrCalendar.prototype.ngOnDestroy = /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
            function () {
                this._subs.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrCalendar.decorators = [
            { type: i0.Component, args: [{ selector: 'clr-calendar', template: "<table class=\"calendar-table weekdays\">\n    <tr class=\"calendar-row\">\n        <td *ngFor=\"let day of localeDaysNarrow\" class=\"calendar-cell weekday\">\n            {{day}}\n        </td>\n    </tr>\n</table>\n<table\n    class=\"calendar-table calendar-dates\">\n    <tr class=\"calendar-row\" *ngFor=\"let row of calendarViewModel.calendarView\">\n        <td *ngFor=\"let dayView of row\" class=\"calendar-cell\">\n            <clr-day [clrDayView]=\"dayView\"></clr-day>\n        </td>\n    </tr>\n</table>\n" }] }
        ];
        /** @nocollapse */
        ClrCalendar.ctorParameters = function () {
            return [
                { type: LocaleHelperService },
                { type: DateNavigationService },
                { type: DatepickerFocusService },
                { type: i0.ElementRef }
            ];
        };
        ClrCalendar.propDecorators = {
            onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ClrCalendar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var FocusService = /** @class */ (function () {
        function FocusService() {
            this._focused = new rxjs.BehaviorSubject(false);
        }
        Object.defineProperty(FocusService.prototype, "focusChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._focused.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FocusService.prototype, "focused", {
            set: /**
             * @param {?} state
             * @return {?}
             */ function (state) {
                this._focused.next(state);
            },
            enumerable: true,
            configurable: true
        });
        FocusService.decorators = [
            { type: i0.Injectable }
        ];
        return FocusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DateFormControlService = /** @class */ (function () {
        function DateFormControlService() {
            this._touchedChange = new rxjs.Subject();
            this._dirtyChange = new rxjs.Subject();
        }
        Object.defineProperty(DateFormControlService.prototype, "touchedChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._touchedChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateFormControlService.prototype, "dirtyChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._dirtyChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateFormControlService.prototype.markAsTouched = /**
         * @return {?}
         */
            function () {
                this._touchedChange.next();
            };
        /**
         * @return {?}
         */
        DateFormControlService.prototype.markAsDirty = /**
         * @return {?}
         */
            function () {
                this._dirtyChange.next();
            };
        DateFormControlService.decorators = [
            { type: i0.Injectable }
        ];
        return DateFormControlService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DateIOService = /** @class */ (function () {
        function DateIOService(_localeHelperService) {
            this._localeHelperService = _localeHelperService;
            this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
            this.localeDisplayFormat = LITTLE_ENDIAN;
            this.delimiters = ['/', '/'];
            this.cldrLocaleDateFormat = this._localeHelperService.localeDateFormat;
            this.initializeLocaleDisplayFormat();
        }
        /**
         * @return {?}
         */
        DateIOService.prototype.initializeLocaleDisplayFormat = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var format = this.cldrLocaleDateFormat.toLocaleLowerCase();
                if (LITTLE_ENDIAN_REGEX.test(format)) {
                    this.localeDisplayFormat = LITTLE_ENDIAN;
                }
                else if (MIDDLE_ENDIAN_REGEX.test(format)) {
                    this.localeDisplayFormat = MIDDLE_ENDIAN;
                }
                else {
                    // everything else is set to BIG-ENDIAN FORMAT
                    this.localeDisplayFormat = BIG_ENDIAN;
                }
                this.extractDelimiters();
            };
        /**
         * @return {?}
         */
        DateIOService.prototype.extractDelimiters = /**
         * @return {?}
         */
            function () {
                if (this.cldrLocaleDateFormat) {
                    // Sanitize Date Format. Remove RTL characters.
                    // FIXME: When we support RTL, remove this and handle it correctly.
                    /** @type {?} */
                    var localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, '');
                    /** @type {?} */
                    var delimiters = localeFormat.split(DELIMITER_REGEX);
                    // NOTE: The split from the CLDR date format should always result
                    // in an arary with 4 elements. The 1st and the 2nd values are the delimiters
                    // we will use in order.
                    // Eg: "dd/MM/y".split(/d+|m+|y+/i) results in ["", "/", "/", ""]
                    if (delimiters && delimiters.length === 4) {
                        this.delimiters = [delimiters[1], delimiters[2]];
                    }
                    else {
                        console.error('Unexpected date format received. Delimiters extracted: ', delimiters);
                    }
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.toLocaleDisplayFormatString = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (date) {
                    if (isNaN(date.getTime())) {
                        return '';
                    }
                    /** @type {?} */
                    var dateNo = date.getDate();
                    /** @type {?} */
                    var monthNo = date.getMonth() + 1;
                    /** @type {?} */
                    var dateStr = dateNo > 9 ? dateNo.toString() : '0' + dateNo;
                    /** @type {?} */
                    var monthStr = monthNo > 9 ? monthNo.toString() : '0' + monthNo;
                    if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                        return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
                    }
                    else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                        return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
                    }
                    else {
                        return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
                    }
                }
                return '';
            };
        Object.defineProperty(DateIOService.prototype, "placeholderText", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var format = this.localeDisplayFormat.format;
                return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if the month entered by the user is valid or not.
         * Note: Month is 0 based.
         */
        /**
         * Checks if the month entered by the user is valid or not.
         * Note: Month is 0 based.
         * @param {?} month
         * @return {?}
         */
        DateIOService.prototype.isValidMonth = /**
         * Checks if the month entered by the user is valid or not.
         * Note: Month is 0 based.
         * @param {?} month
         * @return {?}
         */
            function (month) {
                return month > -1 && month < 12;
            };
        /**
         * Checks if the date is valid depending on the year and month provided.
         */
        /**
         * Checks if the date is valid depending on the year and month provided.
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.isValidDate = /**
         * Checks if the date is valid depending on the year and month provided.
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
            function (year, month, date) {
                return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
            };
        /**
         * Validates the parameters provided and returns the date.
         * If the parameters are not
         * valid then return null.
         * NOTE: (Month here is 1 based since the user has provided that as an input)
         */
        /**
         * Validates the parameters provided and returns the date.
         * If the parameters are not
         * valid then return null.
         * NOTE: (Month here is 1 based since the user has provided that as an input)
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.validateAndGetDate = /**
         * Validates the parameters provided and returns the date.
         * If the parameters are not
         * valid then return null.
         * NOTE: (Month here is 1 based since the user has provided that as an input)
         * @param {?} year
         * @param {?} month
         * @param {?} date
         * @return {?}
         */
            function (year, month, date) {
                // I don't know whats wrong with the TS compiler. It throws an error if I write
                // the below if statement. The error is:
                // Operator '!==' cannot be applied to types '2' and '4'
                // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
                /*
                    if (year.length !== 2 || year.length !== 4) {
                        return null;
                    }
                    */
                // I don't know whats wrong with the TS compiler. It throws an error if I write
                // the below if statement. The error is:
                // Operator '!==' cannot be applied to types '2' and '4'
                // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
                /*
                        if (year.length !== 2 || year.length !== 4) {
                            return null;
                        }
                        */
                // Instead I have to write the logic like this x-(
                /** @type {?} */
                var y = +year;
                /** @type {?} */
                var m = +month - 1;
                // month is 0 based
                /** @type {?} */
                var d = +date;
                if (!this.isValidMonth(m) || !this.isValidDate(y, m, d)) {
                    return null;
                }
                /** @type {?} */
                var result = parseToFourDigitYear(y);
                return result !== -1 ? new Date(result, m, d) : null;
            };
        /**
         * Checks if the input provided by the user is valid.
         */
        /**
         * Checks if the input provided by the user is valid.
         * @param {?} date
         * @return {?}
         */
        DateIOService.prototype.isValidInput = /**
         * Checks if the input provided by the user is valid.
         * @param {?} date
         * @return {?}
         */
            function (date) {
                if (!date) {
                    return null;
                }
                /** @type {?} */
                var dateParts = date.match(USER_INPUT_REGEX);
                if (!dateParts || dateParts.length !== 3) {
                    return null;
                }
                var _a = __read(dateParts, 3), firstPart = _a[0], secondPart = _a[1], thirdPart = _a[2];
                if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                    // secondPart is month && firstPart is date
                    return this.validateAndGetDate(thirdPart, secondPart, firstPart);
                }
                else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                    // firstPart is month && secondPart is date
                    return this.validateAndGetDate(thirdPart, firstPart, secondPart);
                }
                else {
                    // secondPart is month && thirdPart is date
                    return this.validateAndGetDate(firstPart, secondPart, thirdPart);
                }
            };
        DateIOService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DateIOService.ctorParameters = function () {
            return [
                { type: LocaleHelperService }
            ];
        };
        return DateIOService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // iPad mini screen width
    // http://stephen.io/mediaqueries/#iPadMini
    /** @type {?} */
    var DATEPICKER_ENABLE_BREAKPOINT = 768;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatepickerEnabledService = /** @class */ (function () {
        function DatepickerEnabledService(_document) {
            this._document = _document;
            this._isUserAgentMobile = false;
            if (this._document) {
                this._isUserAgentMobile = MOBILE_USERAGENT_REGEX.test(_document.defaultView.navigator.userAgent);
                this._innerWidth = _document.defaultView.innerWidth;
            }
        }
        Object.defineProperty(DatepickerEnabledService.prototype, "isEnabled", {
            /**
             * Returns if the calendar should be active or not.
             * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
             * then the calendar is inactive.
             */
            get: /**
             * Returns if the calendar should be active or not.
             * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
             * then the calendar is inactive.
             * @return {?}
             */ function () {
                // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
                // What they recommend is:
                //"In summary, we recommend looking for the string 'Mobi'
                // anywhere in the User Agent to detect a mobile device."
                if (this._document) {
                    if (this._innerWidth < DATEPICKER_ENABLE_BREAKPOINT && this._isUserAgentMobile) {
                        return false;
                    }
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        DatepickerEnabledService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DatepickerEnabledService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        return DatepickerEnabledService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This component contains two template for the old and new forms layouts.
     * When it is time to remove the old forms layouts support, remove the ng-templates
     * and ng-container, and just keep the inner content of the #newLayout as the template
     * and move the ng-content for clrDate.
     */
    var ClrDateContainer = /** @class */ (function () {
        function ClrDateContainer(_ifOpenService, _dateNavigationService, _datepickerEnabledService, dateFormControlService, commonStrings, ifErrorService, focusService, controlClassService, layoutService, newFormsLayout, ngControlService) {
            var _this = this;
            this._ifOpenService = _ifOpenService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerEnabledService = _datepickerEnabledService;
            this.dateFormControlService = dateFormControlService;
            this.commonStrings = commonStrings;
            this.ifErrorService = ifErrorService;
            this.focusService = focusService;
            this.controlClassService = controlClassService;
            this.layoutService = layoutService;
            this.newFormsLayout = newFormsLayout;
            this.ngControlService = ngControlService;
            this._dynamic = false;
            this.invalid = false;
            this.focus = false;
            this.subscriptions = [];
            this.subscriptions.push(this._ifOpenService.openChange.subscribe(function (open) {
                if (open) {
                    _this.initializeCalendar();
                }
            }));
            this.subscriptions.push(this.focusService.focusChange.subscribe(function (state) {
                _this.focus = state;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        /**
         * @return {?}
         */
        ClrDateContainer.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (control) {
                    _this.invalid = control.invalid;
                }));
            };
        /**
         * Returns the classes to apply to the control
         */
        /**
         * Returns the classes to apply to the control
         * @return {?}
         */
        ClrDateContainer.prototype.controlClass = /**
         * Returns the classes to apply to the control
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * Determines if the control needs to add grid classes
         */
        /**
         * Determines if the control needs to add grid classes
         * @return {?}
         */
        ClrDateContainer.prototype.addGrid = /**
         * Determines if the control needs to add grid classes
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        Object.defineProperty(ClrDateContainer.prototype, "isEnabled", {
            /**
             * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
             */
            get: /**
             * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
             * @return {?}
             */ function () {
                return this._datepickerEnabledService.isEnabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
         */
        /**
         * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
         * @return {?}
         */
        ClrDateContainer.prototype.initializeCalendar = /**
         * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
         * @return {?}
         */
            function () {
                this._dateNavigationService.initializeCalendar();
            };
        /**
         * Toggles the Datepicker Popover.
         */
        /**
         * Toggles the Datepicker Popover.
         * @param {?} event
         * @return {?}
         */
        ClrDateContainer.prototype.toggleDatepicker = /**
         * Toggles the Datepicker Popover.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._ifOpenService.toggleWithEvent(event);
                this.dateFormControlService.markAsTouched();
            };
        /**
         * Unsubscribe from subscriptions.
         */
        /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
        ClrDateContainer.prototype.ngOnDestroy = /**
         * Unsubscribe from subscriptions.
         * @return {?}
         */
            function () {
                this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
            };
        ClrDateContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-date-container',
                        template: "\n    <ng-template #oldLayout>\n        <ng-content></ng-content>\n        <ng-container *ngTemplateOutlet=\"clrDate\"></ng-container>\n        <button\n            type=\"button\"\n            class=\"datepicker-trigger\"\n            (click)=\"toggleDatepicker($event)\"\n            *ngIf=\"isEnabled\">\n            <clr-icon shape=\"calendar\" class=\"datepicker-trigger-icon\" [attr.title]=\"commonStrings.open\"></clr-icon>\n        </button>\n        <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>\n    </ng-template>\n    \n    <ng-template #newLayout>\n      <ng-content select=\"label\"></ng-content>\n      <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n        <div class=\"clr-input-wrapper\">\n          <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n            <ng-container *ngTemplateOutlet=\"clrDate\"></ng-container>\n            <button type=\"button\" class=\"datepicker-trigger\" (click)=\"toggleDatepicker($event)\" *ngIf=\"isEnabled\" [attr.title]=\"commonStrings.open\" [disabled]=\"control?.disabled\">\n              <clr-icon shape=\"calendar\" class=\"clr-input-group-icon-action\"></clr-icon>\n            </button>\n            <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>\n          </div>\n          <clr-icon class=\"clr-validate-icon\" shape=\"exclamation-circle\"></clr-icon>\n        </div>\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </ng-template>\n    \n    <ng-template #clrDate>\n      <ng-content select=\"[clrDate]\"></ng-content>\n    </ng-template>\n    \n    <ng-container *ngIf=\"newFormsLayout; then newLayout else oldLayout\"></ng-container>\n    ",
                        providers: [
                            ControlIdService,
                            IfOpenService,
                            LocaleHelperService,
                            IfErrorService,
                            ControlClassService,
                            FocusService,
                            NgControlService,
                            DateIOService,
                            DateNavigationService,
                            DatepickerEnabledService,
                            DateFormControlService,
                        ],
                        host: {
                            '[class.date-container]': '!newFormsLayout',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-form-control]': 'newFormsLayout',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDateContainer.ctorParameters = function () {
            return [
                { type: IfOpenService },
                { type: DateNavigationService },
                { type: DatepickerEnabledService },
                { type: DateFormControlService },
                { type: ClrCommonStrings },
                { type: IfErrorService },
                { type: FocusService },
                { type: ControlClassService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: Boolean, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IS_NEW_FORMS_LAYOUT,] }] },
                { type: NgControlService }
            ];
        };
        return ClrDateContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDateInput = /** @class */ (function (_super) {
        __extends(ClrDateInput, _super);
        function ClrDateInput(container, vcr, elRef, renderer, _ngControl, _dateIOService, _dateNavigationService, _datepickerEnabledService, dateFormControlService, platformId, ngControlService, controlClassService, focusService, ifErrorService, control, newFormsLayout) {
            var _this = _super.call(this, ClrDateContainer, vcr, 4) || this;
            _this.container = container;
            _this.elRef = elRef;
            _this.renderer = renderer;
            _this._ngControl = _ngControl;
            _this._dateIOService = _dateIOService;
            _this._dateNavigationService = _dateNavigationService;
            _this._datepickerEnabledService = _datepickerEnabledService;
            _this.dateFormControlService = dateFormControlService;
            _this.platformId = platformId;
            _this.ngControlService = ngControlService;
            _this.focusService = focusService;
            _this.ifErrorService = ifErrorService;
            _this.control = control;
            _this.newFormsLayout = newFormsLayout;
            /**
             * Subscriptions to all the services and queries changes
             */
            _this._subscriptions = [];
            //We need this variable because if the date input has a value initialized
            //we do not output it. This variable is false during initial load. We make sure that
            //during initial load dayModelOutputted is equal to the value entered by the user so that initialized
            //value isn't emitted back to the user. After initial load,
            //we set this to true and the dayModelOutputted is set only
            //when the Output is emitted to the user.
            _this.previousOutputInitializedFlag = false;
            _this.initialLoad = true;
            //
            // Output Management
            // Note: For now we will not emit both clrDateChange and ngControl outputs
            // at the same time. This requires us to listen to keydown and blur events to figure out
            // exactly when the Output should be emitted.
            // Our recommendation right now is to either use clrDate or use ngModel/FormControl.
            // Do not use both of them together.
            //
            _this._dateUpdated = new i0.EventEmitter(false);
            if (controlClassService) {
                controlClassService.className = _this.elRef.nativeElement.className;
            }
            return _this;
        }
        /**
         * @param {?} dayModel
         * @return {?}
         */
        ClrDateInput.prototype.initializePreviousOutput = /**
         * @param {?} dayModel
         * @return {?}
         */
            function (dayModel) {
                if (!this.previousOutputInitializedFlag) {
                    this.previousOutput = dayModel;
                    this.previousOutputInitializedFlag = true;
                }
            };
        /**
         * 1. Populate services if the date container is not present.
         * 2. Initialize Subscriptions.
         * 3. Process User Input.
         */
        /**
         * 1. Populate services if the date container is not present.
         * 2. Initialize Subscriptions.
         * 3. Process User Input.
         * @return {?}
         */
        ClrDateInput.prototype.ngOnInit = /**
         * 1. Populate services if the date container is not present.
         * 2. Initialize Subscriptions.
         * 3. Process User Input.
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.ngControlService && this.control) {
                    this.ngControlService.setControl(this.control);
                }
                if (!this.container) {
                    this.populateContainerServices();
                }
                this.initializeSubscriptions();
                this.processInitialInputs();
                if (this.clrNewLayout !== undefined) {
                    this.newFormsLayout = !!this.clrNewLayout;
                }
            };
        /**
         * Process the inputs initialized by the user which were missed
         * because of late subscriptions or lifecycle method calls.
         */
        /**
         * Process the inputs initialized by the user which were missed
         * because of late subscriptions or lifecycle method calls.
         * @return {?}
         */
        ClrDateInput.prototype.processInitialInputs = /**
         * Process the inputs initialized by the user which were missed
         * because of late subscriptions or lifecycle method calls.
         * @return {?}
         */
            function () {
                this.processUserDateObject(this.dateValueOnInitialLoad);
                // Handle Inital Value from Reactive Forms
                // TODO: We are repeating this logic at multiple places. This makes me think
                // if this class should have implemented the ControlValueAccessor interface.
                // Will explore that later and see if its a cleaner solution.
                if (this._ngControl && this._ngControl.value) {
                    this.updateInputValue(this._ngControl.value);
                    this.initializePreviousOutput(this._dateNavigationService.selectedDay);
                }
            };
        /**
         * Write the initial input set by the user on to the input field.
         */
        /**
         * Write the initial input set by the user on to the input field.
         * @return {?}
         */
        ClrDateInput.prototype.ngAfterViewInit = /**
         * Write the initial input set by the user on to the input field.
         * @return {?}
         */
            function () {
                // I don't know why I have to do this but after using the new HostWrapping Module I have to delay the processing
                // of the initial Input set by the user to here.  If I do not 2 issues occur:
                // 1. the Input setter is called before ngOnInit. ngOnInit initializes the services without which the setter
                // fails
                // 2. The Renderer doesn't work before ngAfterViewInit
                //(It used to before the new HostWrapping Module for some reason).
                // I need the renderer to set the value property on the input to make sure that if the user has supplied a Date
                // input object,  we reflect it with the right date on the input field using the IO service.  I am not sure if
                // these are major issues or not but just noting them down here.
                if (this._dateNavigationService) {
                    /** @type {?} */
                    var selDay = this._dateNavigationService.selectedDay;
                    if (selDay) {
                        /** @type {?} */
                        var dateStr = this._dateIOService.toLocaleDisplayFormatString(selDay.toDate());
                        this.writeDateStrToInputField(dateStr);
                    }
                }
                this.initialLoad = false;
            };
        /**
         * Unsubscribes from the subscriptions.
         */
        /**
         * Unsubscribes from the subscriptions.
         * @return {?}
         */
        ClrDateInput.prototype.ngOnDestroy = /**
         * Unsubscribes from the subscriptions.
         * @return {?}
         */
            function () {
                this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * Populates the services from the container component.
         */
        /**
         * Populates the services from the container component.
         * @return {?}
         */
        ClrDateInput.prototype.populateContainerServices = /**
         * Populates the services from the container component.
         * @return {?}
         */
            function () {
                this._dateIOService = this.getProviderFromContainer(DateIOService);
                this._dateNavigationService = this.getProviderFromContainer(DateNavigationService);
                this._datepickerEnabledService = this.getProviderFromContainer(DatepickerEnabledService);
                this.dateFormControlService = this.getProviderFromContainer(DateFormControlService);
            };
        /**
         * Writes the date string value to the input field
         */
        /**
         * Writes the date string value to the input field
         * @param {?} value
         * @return {?}
         */
        ClrDateInput.prototype.writeDateStrToInputField = /**
         * Writes the date string value to the input field
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.renderer.setProperty(this.elRef.nativeElement, 'value', value);
            };
        Object.defineProperty(ClrDateInput.prototype, "date", {
            /**
             * Javascript Date object input set by the user.
             */
            set: /**
             * Javascript Date object input set by the user.
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.initialLoad) {
                    // Store date value passed by the user to process after the services have been initialized by
                    // the ngOnInit hook.
                    this.dateValueOnInitialLoad = value;
                }
                else {
                    this.processUserDateObject(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Processes a date object to check if its valid or not.
         */
        /**
         * Processes a date object to check if its valid or not.
         * @param {?} value
         * @return {?}
         */
        ClrDateInput.prototype.processUserDateObject = /**
         * Processes a date object to check if its valid or not.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (this._dateIOService) {
                    // The date object is converted back to string because in Javascript you can create a date object
                    // like this: new Date("Test"). This is a date object but it is invalid. Converting the date object
                    // that the user passed helps us to verify the validity of the date object.
                    /** @type {?} */
                    var dateStr = this._dateIOService.toLocaleDisplayFormatString(value);
                    this.updateInputValue(dateStr);
                }
            };
        /**
         * @param {?} dateStr
         * @return {?}
         */
        ClrDateInput.prototype.updateInputValue = /**
         * @param {?} dateStr
         * @return {?}
         */
            function (dateStr) {
                /** @type {?} */
                var date = this._dateIOService.isValidInput(dateStr);
                if (date) {
                    /** @type {?} */
                    var dayModel = new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
                    if (!dayModel.isEqual(this._dateNavigationService.selectedDay)) {
                        this._dateNavigationService.selectedDay = dayModel;
                        this.writeDateStrToInputField(dateStr);
                    }
                }
                else {
                    this._dateNavigationService.selectedDay = null;
                }
            };
        Object.defineProperty(ClrDateInput.prototype, "placeholderText", {
            /**
             * Returns the date format for the placeholder according to which the input should be entered by the user.
             */
            get: /**
             * Returns the date format for the placeholder according to which the input should be entered by the user.
             * @return {?}
             */ function () {
                return this.placeholder ? this.placeholder : this._dateIOService.placeholderText;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDateInput.prototype, "inputType", {
            /**
             * Sets the input type to text when the datepicker is enabled. Reverts back to the native date input
             * when the datepicker is disabled. Datepicker is disabled on mobiles.
             */
            get: /**
             * Sets the input type to text when the datepicker is enabled. Reverts back to the native date input
             * when the datepicker is disabled. Datepicker is disabled on mobiles.
             * @return {?}
             */ function () {
                return common.isPlatformBrowser(this.platformId) && this._datepickerEnabledService.isEnabled ? 'text' : 'date';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} dayModel
         * @return {?}
         */
        ClrDateInput.prototype.emitDateOutput = /**
         * @param {?} dayModel
         * @return {?}
         */
            function (dayModel) {
                if (dayModel && !dayModel.isEqual(this.previousOutput)) {
                    this._dateUpdated.emit(dayModel.toDate());
                    this.previousOutput = dayModel;
                }
                else if (!dayModel && this.previousOutput) {
                    this._dateUpdated.emit(null);
                    this.previousOutput = null;
                }
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.setFocusStates = /**
         * @return {?}
         */
            function () {
                if (this.focusService) {
                    this.focusService.focused = true;
                }
            };
        /**
         * @return {?}
         */
        ClrDateInput.prototype.setBlurStates = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
                if (this.focusService) {
                    this.focusService.focused = false;
                }
            };
        /**
         * Fires this method when the user changes the input focuses out of the input field.
         */
        /**
         * Fires this method when the user changes the input focuses out of the input field.
         * @param {?} target
         * @return {?}
         */
        ClrDateInput.prototype.onValueChange = /**
         * Fires this method when the user changes the input focuses out of the input field.
         * @param {?} target
         * @return {?}
         */
            function (target) {
                /** @type {?} */
                var value = target.value;
                /** @type {?} */
                var date = this._dateIOService.isValidInput(value);
                if (date) {
                    /** @type {?} */
                    var dayModel = new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
                    this._dateNavigationService.selectedDay = dayModel;
                    this.emitDateOutput(dayModel);
                }
                else {
                    this._dateNavigationService.selectedDay = null;
                    this.emitDateOutput(null);
                }
            };
        /**
         * Initialize DateIO Subscriptions
         */
        /**
         * Initialize DateIO Subscriptions
         * @return {?}
         */
        ClrDateInput.prototype.initializeSubscriptions = /**
         * Initialize DateIO Subscriptions
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._dateNavigationService && this._dateIOService) {
                    // This subscription is fired when the user selects a date from the popover.
                    this._subscriptions.push(this._dateNavigationService.selectedDayChange.subscribe(function (dayModel) {
                        /** @type {?} */
                        var dateStr = _this._dateIOService.toLocaleDisplayFormatString(dayModel.toDate());
                        _this.writeDateStrToInputField(dateStr);
                        // This makes sure that ngModelChange is fired
                        // TODO: Check if there is a better way to do this.
                        // NOTE: Its important to use NgControl and not NgModel because
                        // NgModel only works with template driven forms
                        if (_this._ngControl) {
                            _this._ngControl.control.setValue(dateStr);
                        }
                        _this.emitDateOutput(dayModel);
                    }));
                    // We do not emit an Output from this subscription because
                    // we only emit the Output when the user has focused out of the input.
                    if (this._ngControl) {
                        this._subscriptions.push(this._ngControl.valueChanges.subscribe(function (value) {
                            /** @type {?} */
                            var date = _this._dateIOService.isValidInput(value);
                            if (date) {
                                /** @type {?} */
                                var dayModel = new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
                                _this._dateNavigationService.selectedDay = dayModel;
                                _this.initializePreviousOutput(dayModel);
                            }
                            else {
                                _this.initializePreviousOutput(null);
                            }
                        }));
                    }
                }
                if (this.dateFormControlService) {
                    this._subscriptions.push(this.dateFormControlService.touchedChange.subscribe(function () {
                        if (_this._ngControl) {
                            _this._ngControl.control.markAsTouched();
                        }
                    }));
                    this._subscriptions.push(this.dateFormControlService.dirtyChange.subscribe(function () {
                        if (_this._ngControl) {
                            _this._ngControl.control.markAsDirty();
                        }
                    }));
                }
            };
        ClrDateInput.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDate]',
                        host: {
                            '[class.date-input]': '!newFormsLayout',
                            '[class.clr-input]': 'newFormsLayout',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrDateInput.ctorParameters = function () {
            return [
                { type: ClrDateContainer, decorators: [{ type: i0.Optional }] },
                { type: i0.ViewContainerRef },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: forms.NgControl, decorators: [{ type: i0.Self }, { type: i0.Optional }] },
                { type: DateIOService, decorators: [{ type: i0.Optional }] },
                { type: DateNavigationService, decorators: [{ type: i0.Optional }] },
                { type: DatepickerEnabledService, decorators: [{ type: i0.Optional }] },
                { type: DateFormControlService, decorators: [{ type: i0.Optional }] },
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService, decorators: [{ type: i0.Optional }] },
                { type: FocusService, decorators: [{ type: i0.Optional }] },
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }] },
                { type: Boolean, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [IS_NEW_FORMS_LAYOUT,] }] }
            ];
        };
        ClrDateInput.propDecorators = {
            clrNewLayout: [{ type: i0.Input }],
            date: [{ type: i0.Input, args: ['clrDate',] }],
            placeholder: [{ type: i0.Input }],
            placeholderText: [{ type: i0.HostBinding, args: ['attr.placeholder',] }],
            inputType: [{ type: i0.HostBinding, args: ['attr.type',] }],
            _dateUpdated: [{ type: i0.Output, args: ['clrDateChange',] }],
            setFocusStates: [{ type: i0.HostListener, args: ['focus',] }],
            setBlurStates: [{ type: i0.HostListener, args: ['blur',] }],
            onValueChange: [{ type: i0.HostListener, args: ['change', ['$event.target'],] }]
        };
        return ClrDateInput;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // Literally any annotation would work here, but writing our own @HoneyBadger annotation feels overkill.
    /**
     * @abstract
     */
    var AbstractPopover = /** @class */ (function () {
        function AbstractPopover(injector, parentHost) {
            var _this = this;
            this.parentHost = parentHost;
            this.updateAnchor = false;
            this.popoverOptions = {};
            /*
                 * Until https://github.com/angular/angular/issues/8785 is supported, we don't have any way to instantiate
                 * a separate directive on the host. So let's do dirty but performant for now.
                 */
            this.closeOnOutsideClick = false;
            this.el = injector.get(i0.ElementRef);
            this.ifOpenService = injector.get(IfOpenService);
            this.renderer = injector.get(i0.Renderer2);
            // Default anchor is the parent host
            this.anchorElem = parentHost.nativeElement;
            this.popoverInstance = new Popover(this.el.nativeElement);
            this.subscription = this.ifOpenService.openChange.subscribe(function (change) {
                if (change) {
                    _this.anchor();
                    _this.attachESCListener();
                }
                else {
                    _this.release();
                    _this.detachESCListener();
                }
            });
            if (this.ifOpenService.open) {
                this.anchor();
                this.attachESCListener();
            }
        }
        /**
         * @return {?}
         */
        AbstractPopover.prototype.anchor = /**
         * @return {?}
         */
            function () {
                this.updateAnchor = true;
                // Ugh
                this.ignore = this.ifOpenService.originalEvent;
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.release = /**
         * @return {?}
         */
            function () {
                this.detachOutsideClickListener();
                this.popoverInstance.release();
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.updateAnchor) {
                    this.updateAnchor = false;
                    this.popoverInstance
                        .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                        .subscribe(function () {
                        // if a scroll event is detected, close the popover
                        _this.ifOpenService.open = false;
                    });
                    this.attachOutsideClickListener();
                }
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.release();
                this.detachESCListener();
                this.subscription.unsubscribe();
            };
        Object.defineProperty(AbstractPopover.prototype, "isOffScreen", {
            /*
               * Fallback to hide when *clrIfOpen is not being used
               */
            get: /*
                 * Fallback to hide when *clrIfOpen is not being used
                 */ 
            /**
             * @return {?}
             */
            function () {
                return this.ifOpenService.open ? false : true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        AbstractPopover.prototype.attachESCListener = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.documentESCListener = this.renderer.listen('document', 'keydown', function (event) {
                    if (event && event.keyCode === ESC) {
                        _this.ifOpenService.open = false;
                    }
                });
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.detachESCListener = /**
         * @return {?}
         */
            function () {
                if (this.documentESCListener) {
                    this.documentESCListener();
                    delete this.documentESCListener;
                }
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.attachOutsideClickListener = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.closeOnOutsideClick) {
                    this.hostClickListener = this.renderer.listen(this.el.nativeElement, 'click', function (event) { return (_this.ignore = event); });
                    if (this.ignoredElement) {
                        this.ignoredElementClickListener = this.renderer.listen(this.ignoredElement, 'click', function (event) { return (_this.ignore = event); });
                    }
                    this.documentClickListener = this.renderer.listen('document', 'click', function (event) {
                        if (event === _this.ignore) {
                            delete _this.ignore;
                        }
                        else {
                            _this.ifOpenService.open = false;
                        }
                    });
                }
            };
        /**
         * @return {?}
         */
        AbstractPopover.prototype.detachOutsideClickListener = /**
         * @return {?}
         */
            function () {
                if (this.closeOnOutsideClick) {
                    if (this.hostClickListener) {
                        this.hostClickListener();
                        delete this.hostClickListener;
                    }
                    if (this.ignoredElementClickListener) {
                        this.ignoredElementClickListener();
                        delete this.ignoredElementClickListener;
                    }
                    if (this.documentClickListener) {
                        this.documentClickListener();
                        delete this.documentClickListener;
                    }
                }
            };
        AbstractPopover.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        AbstractPopover.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.SkipSelf }] }
            ];
        };
        AbstractPopover.propDecorators = {
            isOffScreen: [{ type: i0.HostBinding, args: ['class.is-off-screen',] }]
        };
        return AbstractPopover;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This service manages which view is visible in the datepicker popover.
     */
    var ViewManagerService = /** @class */ (function () {
        function ViewManagerService() {
            this._currentView = "DAYVIEW" /* DAYVIEW */;
        }
        Object.defineProperty(ViewManagerService.prototype, "isDayView", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentView === "DAYVIEW" /* DAYVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewManagerService.prototype, "isYearView", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentView === "YEARVIEW" /* YEARVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewManagerService.prototype, "isMonthView", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentView === "MONTHVIEW" /* MONTHVIEW */;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ViewManagerService.prototype.changeToMonthView = /**
         * @return {?}
         */
            function () {
                this._currentView = "MONTHVIEW" /* MONTHVIEW */;
            };
        /**
         * @return {?}
         */
        ViewManagerService.prototype.changeToYearView = /**
         * @return {?}
         */
            function () {
                this._currentView = "YEARVIEW" /* YEARVIEW */;
            };
        /**
         * @return {?}
         */
        ViewManagerService.prototype.changeToDayView = /**
         * @return {?}
         */
            function () {
                this._currentView = "DAYVIEW" /* DAYVIEW */;
            };
        ViewManagerService.decorators = [
            { type: i0.Injectable }
        ];
        return ViewManagerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatepickerViewManager = /** @class */ (function (_super) {
        __extends(ClrDatepickerViewManager, _super);
        function ClrDatepickerViewManager(parent, _injector, _viewManagerService) {
            var _this = _super.call(this, _injector, parent) || this;
            _this._viewManagerService = _viewManagerService;
            _this.configurePopover();
            return _this;
        }
        /**
         * Configure Popover Direction and Close indicators
         */
        /**
         * Configure Popover Direction and Close indicators
         * @return {?}
         */
        ClrDatepickerViewManager.prototype.configurePopover = /**
         * Configure Popover Direction and Close indicators
         * @return {?}
         */
            function () {
                this.anchorPoint = Point.BOTTOM_LEFT;
                this.popoverPoint = Point.LEFT_TOP;
                this.closeOnOutsideClick = true;
            };
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isMonthView", {
            /**
             * Returns if the current view is the monthpicker.
             */
            get: /**
             * Returns if the current view is the monthpicker.
             * @return {?}
             */ function () {
                return this._viewManagerService.isMonthView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isYearView", {
            /**
             * Returns if the current view is the yearpicker.
             */
            get: /**
             * Returns if the current view is the yearpicker.
             * @return {?}
             */ function () {
                return this._viewManagerService.isYearView;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatepickerViewManager.prototype, "isDayView", {
            /**
             * Returns if the current view is the daypicker.
             */
            get: /**
             * Returns if the current view is the daypicker.
             * @return {?}
             */ function () {
                return this._viewManagerService.isDayView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatepickerViewManager.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-datepicker-view-manager',
                        template: "<!--\n* Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n* This software is released under MIT license.\n* The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<clr-monthpicker *ngIf=\"isMonthView\"></clr-monthpicker>\n<clr-yearpicker *ngIf=\"isYearView\"></clr-yearpicker>\n<clr-daypicker *ngIf=\"isDayView\"></clr-daypicker>\n",
                        providers: [ViewManagerService, DatepickerFocusService],
                        host: { '[class.datepicker]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatepickerViewManager.ctorParameters = function () {
            return [
                { type: i0.ElementRef, decorators: [{ type: i0.SkipSelf }] },
                { type: i0.Injector },
                { type: ViewManagerService }
            ];
        };
        return ClrDatepickerViewManager;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDay = /** @class */ (function () {
        function ClrDay(_dateNavigationService, _ifOpenService, dateFormControlService) {
            this._dateNavigationService = _dateNavigationService;
            this._ifOpenService = _ifOpenService;
            this.dateFormControlService = dateFormControlService;
        }
        /**
         * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
         */
        /**
         * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
         * @return {?}
         */
        ClrDay.prototype.onDayViewFocus = /**
         * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
         * @return {?}
         */
            function () {
                this._dateNavigationService.focusedDay = this.dayView.dayModel;
            };
        /**
         * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
         */
        /**
         * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
         * @return {?}
         */
        ClrDay.prototype.selectDay = /**
         * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
         * @return {?}
         */
            function () {
                /** @type {?} */
                var day = this.dayView.dayModel;
                this._dateNavigationService.notifySelectedDayChanged(day);
                this.dateFormControlService.markAsDirty();
                this._ifOpenService.open = false;
            };
        ClrDay.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-day',
                        template: "\n        <button\n            class=\"day-btn\"\n            type=\"button\"\n            [class.is-today]=\"dayView.isTodaysDate\"\n            [class.is-disabled]=\"dayView.isDisabled\"\n            [class.is-selected]=\"dayView.isSelected\"\n            [attr.tabindex]=\"dayView.tabIndex\"\n            (click)=\"selectDay()\"\n            (focus)=\"onDayViewFocus()\">\n            {{dayView.dayModel.date}}\n        </button>\n    ",
                        host: { '[class.day]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDay.ctorParameters = function () {
            return [
                { type: DateNavigationService },
                { type: IfOpenService },
                { type: DateFormControlService }
            ];
        };
        ClrDay.propDecorators = {
            dayView: [{ type: i0.Input, args: ['clrDayView',] }]
        };
        return ClrDay;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDaypicker = /** @class */ (function () {
        function ClrDaypicker(_viewManagerService, _dateNavigationService, _localeHelperService, commonStrings) {
            this._viewManagerService = _viewManagerService;
            this._dateNavigationService = _dateNavigationService;
            this._localeHelperService = _localeHelperService;
            this.commonStrings = commonStrings;
        }
        /**
         * Calls the ViewManagerService to change to the monthpicker view.
         */
        /**
         * Calls the ViewManagerService to change to the monthpicker view.
         * @return {?}
         */
        ClrDaypicker.prototype.changeToMonthView = /**
         * Calls the ViewManagerService to change to the monthpicker view.
         * @return {?}
         */
            function () {
                this._viewManagerService.changeToMonthView();
            };
        /**
         * Calls the ViewManagerService to change to the yearpicker view.
         */
        /**
         * Calls the ViewManagerService to change to the yearpicker view.
         * @return {?}
         */
        ClrDaypicker.prototype.changeToYearView = /**
         * Calls the ViewManagerService to change to the yearpicker view.
         * @return {?}
         */
            function () {
                this._viewManagerService.changeToYearView();
            };
        Object.defineProperty(ClrDaypicker.prototype, "calendarMonth", {
            /**
             * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
             */
            get: /**
             * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
             * @return {?}
             */ function () {
                return this._localeHelperService.localeMonthsAbbreviated[this._dateNavigationService.displayedCalendar.month];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDaypicker.prototype, "calendarYear", {
            /**
             * Returns the year value of the calendar.
             */
            get: /**
             * Returns the year value of the calendar.
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar.year;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the DateNavigationService to move to the next month.
         */
        /**
         * Calls the DateNavigationService to move to the next month.
         * @return {?}
         */
        ClrDaypicker.prototype.nextMonth = /**
         * Calls the DateNavigationService to move to the next month.
         * @return {?}
         */
            function () {
                this._dateNavigationService.moveToNextMonth();
            };
        /**
         * Calls the DateNavigationService to move to the previous month.
         */
        /**
         * Calls the DateNavigationService to move to the previous month.
         * @return {?}
         */
        ClrDaypicker.prototype.previousMonth = /**
         * Calls the DateNavigationService to move to the previous month.
         * @return {?}
         */
            function () {
                this._dateNavigationService.moveToPreviousMonth();
            };
        /**
         * Calls the DateNavigationService to move to the current month.
         */
        /**
         * Calls the DateNavigationService to move to the current month.
         * @return {?}
         */
        ClrDaypicker.prototype.currentMonth = /**
         * Calls the DateNavigationService to move to the current month.
         * @return {?}
         */
            function () {
                this._dateNavigationService.moveToCurrentMonth();
            };
        ClrDaypicker.decorators = [
            { type: i0.Component, args: [{ selector: 'clr-daypicker', template: "<div class=\"calendar-header\">\n    <div class=\"calendar-pickers\">\n        <button class=\"calendar-btn monthpicker-trigger\" type=\"button\" (click)=\"changeToMonthView()\">\n            {{calendarMonth}}\n        </button>\n        <button class=\"calendar-btn yearpicker-trigger\" type=\"button\" (click)=\"changeToYearView()\">\n            {{calendarYear}}\n        </button>\n    </div>\n    <div class=\"calendar-switchers\">\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"previousMonth()\">\n            <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n        </button>\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"currentMonth()\">\n            <clr-icon shape=\"event\" [attr.title]=\"commonStrings.current\"></clr-icon>\n        </button>\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"nextMonth()\">\n            <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n<clr-calendar></clr-calendar>\n", host: { '[class.daypicker]': 'true' } }] }
        ];
        /** @nocollapse */
        ClrDaypicker.ctorParameters = function () {
            return [
                { type: ViewManagerService },
                { type: DateNavigationService },
                { type: LocaleHelperService },
                { type: ClrCommonStrings }
            ];
        };
        return ClrDaypicker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrMonthpicker = /** @class */ (function () {
        function ClrMonthpicker(_viewManagerService, _localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
            this._viewManagerService = _viewManagerService;
            this._localeHelperService = _localeHelperService;
            this._dateNavigationService = _dateNavigationService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this._focusedMonthIndex = this.calendarMonthIndex;
        }
        Object.defineProperty(ClrMonthpicker.prototype, "monthNames", {
            /**
             * Gets the months array which is used to rendered the monthpicker view.
             * Months are in the TranslationWidth.Wide format.
             */
            get: /**
             * Gets the months array which is used to rendered the monthpicker view.
             * Months are in the TranslationWidth.Wide format.
             * @return {?}
             */ function () {
                return this._localeHelperService.localeMonthsWide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrMonthpicker.prototype, "calendarMonthIndex", {
            /**
             * Gets the month value of the Calendar.
             */
            get: /**
             * Gets the month value of the Calendar.
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar.month;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Calls the DateNavigationService to update the month value of the calendar.
         * Also changes the view to the daypicker.
         */
        /**
         * Calls the DateNavigationService to update the month value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} monthIndex
         * @return {?}
         */
        ClrMonthpicker.prototype.changeMonth = /**
         * Calls the DateNavigationService to update the month value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} monthIndex
         * @return {?}
         */
            function (monthIndex) {
                this._dateNavigationService.changeMonth(monthIndex);
                this._viewManagerService.changeToDayView();
            };
        /**
         * Compares the month passed to the focused month and returns the tab index.
         */
        /**
         * Compares the month passed to the focused month and returns the tab index.
         * @param {?} monthIndex
         * @return {?}
         */
        ClrMonthpicker.prototype.getTabIndex = /**
         * Compares the month passed to the focused month and returns the tab index.
         * @param {?} monthIndex
         * @return {?}
         */
            function (monthIndex) {
                return monthIndex === this._focusedMonthIndex ? 0 : -1;
            };
        /**
         * Handles the Keyboard arrow navigation for the monthpicker.
         */
        /**
         * Handles the Keyboard arrow navigation for the monthpicker.
         * @param {?} event
         * @return {?}
         */
        ClrMonthpicker.prototype.onKeyDown = /**
         * Handles the Keyboard arrow navigation for the monthpicker.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // NOTE: Didn't move this to the date navigation service because
                // the logic is fairly simple and it didn't make sense for me
                // to create extra observables just to move this logic to the service.
                if (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    if (keyCode === UP_ARROW && this._focusedMonthIndex > 0) {
                        event.preventDefault();
                        this._focusedMonthIndex--;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                    else if (keyCode === DOWN_ARROW && this._focusedMonthIndex < 11) {
                        event.preventDefault();
                        this._focusedMonthIndex++;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                    else if (keyCode === RIGHT_ARROW && this._focusedMonthIndex < 6) {
                        event.preventDefault();
                        this._focusedMonthIndex = this._focusedMonthIndex + 6;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                    else if (keyCode === LEFT_ARROW && this._focusedMonthIndex > 5) {
                        event.preventDefault();
                        this._focusedMonthIndex = this._focusedMonthIndex - 6;
                        this._datepickerFocusService.focusCell(this._elRef);
                    }
                }
            };
        /**
         * Focuses on the current calendar month when the View is initialized.
         */
        /**
         * Focuses on the current calendar month when the View is initialized.
         * @return {?}
         */
        ClrMonthpicker.prototype.ngAfterViewInit = /**
         * Focuses on the current calendar month when the View is initialized.
         * @return {?}
         */
            function () {
                this._datepickerFocusService.focusCell(this._elRef);
            };
        ClrMonthpicker.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-monthpicker',
                        template: "\n        <button\n            type=\"button\"\n            class=\"calendar-btn month\"\n            *ngFor=\"let month of monthNames; let monthIndex = index\"\n            (click)=\"changeMonth(monthIndex)\"\n            [class.is-selected]=\"monthIndex === calendarMonthIndex\"\n            [attr.tabindex]=\"getTabIndex(monthIndex)\">\n            {{month}}\n        </button>\n    ",
                        host: {
                            '[class.monthpicker]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrMonthpicker.ctorParameters = function () {
            return [
                { type: ViewManagerService },
                { type: LocaleHelperService },
                { type: DateNavigationService },
                { type: DatepickerFocusService },
                { type: i0.ElementRef }
            ];
        };
        ClrMonthpicker.propDecorators = {
            onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ClrMonthpicker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @type {?} */
    var YEARS_TO_DISPLAY = 10;
    var YearRangeModel = /** @class */ (function () {
        function YearRangeModel(year) {
            this.year = year;
            this.yearRange = [];
            this.generateYearRange();
        }
        Object.defineProperty(YearRangeModel.prototype, "middleYear", {
            /**
             * Gets the number in the middle of the range.
             */
            get: /**
             * Gets the number in the middle of the range.
             * @return {?}
             */ function () {
                return this.yearRange[Math.floor(this.yearRange.length / 2)];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Generates the year range based on the year parameter.
         * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
         */
        /**
         * Generates the year range based on the year parameter.
         * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
         * @return {?}
         */
        YearRangeModel.prototype.generateYearRange = /**
         * Generates the year range based on the year parameter.
         * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
         * @return {?}
         */
            function () {
                /** @type {?} */
                var remainder = this.year % YEARS_TO_DISPLAY;
                /** @type {?} */
                var floor = this.year - remainder;
                /** @type {?} */
                var ceil = floor + YEARS_TO_DISPLAY;
                this.yearRange = this.generateRange(floor, ceil);
            };
        /**
         * Function which generate a range of numbers from floor to ceil.
         */
        /**
         * Function which generate a range of numbers from floor to ceil.
         * @param {?} floor
         * @param {?} ceil
         * @return {?}
         */
        YearRangeModel.prototype.generateRange = /**
         * Function which generate a range of numbers from floor to ceil.
         * @param {?} floor
         * @param {?} ceil
         * @return {?}
         */
            function (floor, ceil) {
                return Array.from({ length: ceil - floor }, function (v, k) { return k + floor; });
            };
        /**
         * Generates the YearRangeModel for the next decade.
         */
        /**
         * Generates the YearRangeModel for the next decade.
         * @return {?}
         */
        YearRangeModel.prototype.nextDecade = /**
         * Generates the YearRangeModel for the next decade.
         * @return {?}
         */
            function () {
                return new YearRangeModel(this.year + 10);
            };
        /**
         * Generates the YearRangeModel for the previous decade.
         */
        /**
         * Generates the YearRangeModel for the previous decade.
         * @return {?}
         */
        YearRangeModel.prototype.previousDecade = /**
         * Generates the YearRangeModel for the previous decade.
         * @return {?}
         */
            function () {
                return new YearRangeModel(this.year - 10);
            };
        /**
         * Generates the YearRangeModel for the current decade.
         */
        /**
         * Generates the YearRangeModel for the current decade.
         * @return {?}
         */
        YearRangeModel.prototype.currentDecade = /**
         * Generates the YearRangeModel for the current decade.
         * @return {?}
         */
            function () {
                return new YearRangeModel(new Date().getFullYear());
            };
        /**
         * Checks if the value is in the YearRangeModel.
         */
        /**
         * Checks if the value is in the YearRangeModel.
         * @param {?} value
         * @return {?}
         */
        YearRangeModel.prototype.inRange = /**
         * Checks if the value is in the YearRangeModel.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                return this.yearRange.indexOf(value) > -1;
            };
        return YearRangeModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrYearpicker = /** @class */ (function () {
        function ClrYearpicker(_dateNavigationService, _viewManagerService, _datepickerFocusService, _elRef, commonStrings) {
            this._dateNavigationService = _dateNavigationService;
            this._viewManagerService = _viewManagerService;
            this._datepickerFocusService = _datepickerFocusService;
            this._elRef = _elRef;
            this.commonStrings = commonStrings;
            this.yearRangeModel = new YearRangeModel(this.calendarYear);
            this._focusedYear = this.calendarYear;
        }
        Object.defineProperty(ClrYearpicker.prototype, "calendarYear", {
            /**
             * Gets the year which the user is currently on.
             */
            get: /**
             * Gets the year which the user is currently on.
             * @return {?}
             */ function () {
                return this._dateNavigationService.displayedCalendar.year;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Increments the focus year by the value passed. Updates the YearRangeModel if the
         * new value is not in the current decade.
         */
        /**
         * Increments the focus year by the value passed. Updates the YearRangeModel if the
         * new value is not in the current decade.
         * @param {?} value
         * @return {?}
         */
        ClrYearpicker.prototype.incrementFocusYearBy = /**
         * Increments the focus year by the value passed. Updates the YearRangeModel if the
         * new value is not in the current decade.
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._focusedYear = this._focusedYear + value;
                if (!this.yearRangeModel.inRange(this._focusedYear)) {
                    if (value > 0) {
                        this.yearRangeModel = this.yearRangeModel.nextDecade();
                    }
                    else {
                        this.yearRangeModel = this.yearRangeModel.previousDecade();
                    }
                }
                this._datepickerFocusService.focusCell(this._elRef);
            };
        /**
         * Calls the DateNavigationService to update the year value of the calendar.
         * Also changes the view to the daypicker.
         */
        /**
         * Calls the DateNavigationService to update the year value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} year
         * @return {?}
         */
        ClrYearpicker.prototype.changeYear = /**
         * Calls the DateNavigationService to update the year value of the calendar.
         * Also changes the view to the daypicker.
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this._dateNavigationService.changeYear(year);
                this._viewManagerService.changeToDayView();
            };
        /**
         * Updates the YearRangeModel to the previous decade.
         */
        /**
         * Updates the YearRangeModel to the previous decade.
         * @return {?}
         */
        ClrYearpicker.prototype.previousDecade = /**
         * Updates the YearRangeModel to the previous decade.
         * @return {?}
         */
            function () {
                this.yearRangeModel = this.yearRangeModel.previousDecade();
                // Year in the yearpicker is not focused because while navigating to a different decade,
                // you want the focus to remain on the decade switcher arrows.
            };
        /**
         * Updates the YearRangeModel to the current decade.
         */
        /**
         * Updates the YearRangeModel to the current decade.
         * @return {?}
         */
        ClrYearpicker.prototype.currentDecade = /**
         * Updates the YearRangeModel to the current decade.
         * @return {?}
         */
            function () {
                if (!this.yearRangeModel.inRange(this._dateNavigationService.today.year)) {
                    this.yearRangeModel = this.yearRangeModel.currentDecade();
                }
                this._datepickerFocusService.focusCell(this._elRef);
            };
        /**
         * Updates the YearRangeModel to the next decade.
         */
        /**
         * Updates the YearRangeModel to the next decade.
         * @return {?}
         */
        ClrYearpicker.prototype.nextDecade = /**
         * Updates the YearRangeModel to the next decade.
         * @return {?}
         */
            function () {
                this.yearRangeModel = this.yearRangeModel.nextDecade();
                // Year in the yearpicker is not focused because while navigating to a different decade,
                // you want the focus to remain on the decade switcher arrows.
            };
        /**
         * Compares the year passed to the focused year and returns the tab index.
         */
        /**
         * Compares the year passed to the focused year and returns the tab index.
         * @param {?} year
         * @return {?}
         */
        ClrYearpicker.prototype.getTabIndex = /**
         * Compares the year passed to the focused year and returns the tab index.
         * @param {?} year
         * @return {?}
         */
            function (year) {
                if (!this.yearRangeModel.inRange(this._focusedYear)) {
                    if (this.yearRangeModel.inRange(this.calendarYear)) {
                        this._focusedYear = this.calendarYear;
                    }
                    else {
                        this._focusedYear = this.yearRangeModel.middleYear;
                    }
                }
                return this._focusedYear === year ? 0 : -1;
            };
        /**
         * Handles the Keyboard arrow navigation for the yearpicker.
         */
        /**
         * Handles the Keyboard arrow navigation for the yearpicker.
         * @param {?} event
         * @return {?}
         */
        ClrYearpicker.prototype.onKeyDown = /**
         * Handles the Keyboard arrow navigation for the yearpicker.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // NOTE: Didn't move this to the date navigation service because
                // the logic is fairly simple and it didn't make sense for me
                // to create extra observables just to move this logic to the service.
                if (event) {
                    /** @type {?} */
                    var keyCode = event.keyCode;
                    if (keyCode === UP_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(-1);
                    }
                    else if (keyCode === DOWN_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(1);
                    }
                    else if (keyCode === RIGHT_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(5);
                    }
                    else if (keyCode === LEFT_ARROW) {
                        event.preventDefault();
                        this.incrementFocusYearBy(-5);
                    }
                }
            };
        /**
         * Focuses on the current calendar year when the View is initialized.
         */
        /**
         * Focuses on the current calendar year when the View is initialized.
         * @return {?}
         */
        ClrYearpicker.prototype.ngAfterViewInit = /**
         * Focuses on the current calendar year when the View is initialized.
         * @return {?}
         */
            function () {
                this._datepickerFocusService.focusCell(this._elRef);
            };
        ClrYearpicker.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-yearpicker',
                        template: "\n        <div class=\"year-switchers\">\n            <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"previousDecade()\">\n                <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n            </button>\n            <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"currentDecade()\">\n                <clr-icon shape=\"event\" [attr.title]=\"commonStrings.current\"></clr-icon>\n            </button>\n            <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"nextDecade()\">\n                <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n            </button>\n        </div>\n        <div class=\"years\">\n            <button\n                *ngFor=\"let year of yearRangeModel.yearRange\"\n                type=\"button\"\n                class=\"calendar-btn year\"\n                [attr.tabindex]=\"getTabIndex(year)\"\n                [class.is-selected]=\"year === calendarYear\"\n                (click)=\"changeYear(year)\">\n                {{year}}\n            </button>\n        </div>\n    ",
                        host: {
                            '[class.yearpicker]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrYearpicker.ctorParameters = function () {
            return [
                { type: DateNavigationService },
                { type: ViewManagerService },
                { type: DatepickerFocusService },
                { type: i0.ElementRef },
                { type: ClrCommonStrings }
            ];
        };
        ClrYearpicker.propDecorators = {
            onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ClrYearpicker;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DATEPICKER_DIRECTIVES = [
        ClrDay,
        ClrDateContainer,
        ClrDateInput,
        ClrDatepickerViewManager,
        ClrMonthpicker,
        ClrYearpicker,
        ClrDaypicker,
        ClrCalendar,
    ];
    var ClrDatepickerModule = /** @class */ (function () {
        function ClrDatepickerModule() {
        }
        ClrDatepickerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrHostWrappingModule, ClrConditionalModule, ClrIconModule, ClrFocusTrapModule],
                        declarations: [CLR_DATEPICKER_DIRECTIVES],
                        exports: [CLR_DATEPICKER_DIRECTIVES],
                        entryComponents: [ClrDateContainer],
                    },] }
        ];
        return ClrDatepickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrInputContainer = /** @class */ (function () {
        function ClrInputContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (control) {
                _this.invalid = control.invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        /**
         * @return {?}
         */
        ClrInputContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrInputContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrInputContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrInputContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-input-container',
                        template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-input-wrapper\">\n                <ng-content select=\"[clrInput]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                    }] }
        ];
        /** @nocollapse */
        ClrInputContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrInputContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrInputContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrInput = /** @class */ (function (_super) {
        __extends(ClrInput, _super);
        function ClrInput(vcr, ngControlService, ifErrorService, control, controlClassService, renderer, el) {
            var _this = _super.call(this, ClrInputContainer, vcr, 1) || this;
            _this.ngControlService = ngControlService;
            _this.ifErrorService = ifErrorService;
            _this.control = control;
            if (!control) {
                throw new Error('clrInput can only be used within an Angular form control, add ngModel or formControl to the input');
            }
            if (controlClassService) {
                controlClassService.initControlClass(renderer, el.nativeElement);
            }
            return _this;
        }
        /**
         * @return {?}
         */
        ClrInput.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.ngControlService) {
                    this.ngControlService.setControl(this.control);
                }
            };
        /**
         * @return {?}
         */
        ClrInput.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
            };
        ClrInput.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrInput]', host: { '[class.clr-input]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrInput.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService, decorators: [{ type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        ClrInput.propDecorators = {
            onBlur: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return ClrInput;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrInputModule = /** @class */ (function () {
        function ClrInputModule() {
        }
        ClrInputModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrInput, ClrInputContainer],
                        exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer],
                        entryComponents: [ClrInputContainer],
                    },] }
        ];
        return ClrInputModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /* tslint:disable-next-line:variable-name */
    /** @type {?} */
    var ToggleService = new i0.InjectionToken(undefined);
    /* tslint:disable-next-line:variable-name */
    /**
     * @return {?}
     */
    function ToggleServiceProvider() {
        return new rxjs.BehaviorSubject(false);
    }
    var ClrPasswordContainer = /** @class */ (function () {
        function ClrPasswordContainer(ifErrorService, layoutService, controlClassService, focusService, ngControlService, toggleService, commonStrings) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.focusService = focusService;
            this.ngControlService = ngControlService;
            this.toggleService = toggleService;
            this.commonStrings = commonStrings;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.show = false;
            this.focus = false;
            this._toggle = true;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (control) {
                _this.invalid = control.invalid;
            }));
            this.subscriptions.push(this.focusService.focusChange.subscribe(function (state) {
                _this.focus = state;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        Object.defineProperty(ClrPasswordContainer.prototype, "clrToggle", {
            get: /**
             * @return {?}
             */ function () {
                return this._toggle;
            },
            set: /**
             * @param {?} state
             * @return {?}
             */ function (state) {
                this._toggle = state;
                if (!state) {
                    this.show = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.show = !this.show;
                this.toggleService.next(this.show);
            };
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrPasswordContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrPasswordContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-password-container',
                        template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n      <div class=\"clr-input-wrapper\">\n        <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n          <ng-content select=\"[clrPassword]\"></ng-content>\n          <clr-icon *ngIf=\"!show && clrToggle\"\n            shape=\"eye\" \n            class=\"clr-input-group-icon-action\"\n            [attr.title]=\"commonStrings.show\"\n            (click)=\"toggle()\"></clr-icon>\n          <clr-icon *ngIf=\"show && clrToggle\" \n            shape=\"eye-hide\"\n            class=\"clr-input-group-icon-action\"\n            [attr.title]=\"commonStrings.hide\"\n            (click)=\"toggle()\"></clr-icon>\n        </div>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n      </div>\n      <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n      <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n    </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [
                            IfErrorService,
                            NgControlService,
                            ControlIdService,
                            ControlClassService,
                            FocusService,
                            { provide: ToggleService, useFactory: ToggleServiceProvider },
                        ]
                    }] }
        ];
        /** @nocollapse */
        ClrPasswordContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: FocusService },
                { type: NgControlService },
                { type: rxjs.BehaviorSubject, decorators: [{ type: i0.Inject, args: [ToggleService,] }] },
                { type: ClrCommonStrings }
            ];
        };
        ClrPasswordContainer.propDecorators = {
            clrToggle: [{ type: i0.Input, args: ['clrToggle',] }],
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrPasswordContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrPassword = /** @class */ (function (_super) {
        __extends(ClrPassword, _super);
        function ClrPassword(vcr, ngControlService, ifErrorService, control, focusService, controlClassService, renderer, el, toggleService) {
            var _this = _super.call(this, ClrPasswordContainer, vcr, 1) || this;
            _this.ngControlService = ngControlService;
            _this.ifErrorService = ifErrorService;
            _this.control = control;
            _this.focusService = focusService;
            _this.toggleService = toggleService;
            if (!_this.control) {
                throw new Error('clrPassword can only be used within an Angular form control, add ngModel or formControl to the input');
            }
            if (!_this.focusService) {
                throw new Error('clrPassword requires being wrapped in <clr-password-container>');
            }
            if (controlClassService) {
                controlClassService.initControlClass(renderer, el.nativeElement);
            }
            _this.subscription = _this.toggleService.subscribe(function (toggle) {
                renderer.setProperty(el.nativeElement, 'type', toggle ? 'text' : 'password');
            });
            return _this;
        }
        /**
         * @return {?}
         */
        ClrPassword.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.ngControlService) {
                    this.ngControlService.setControl(this.control);
                }
            };
        /**
         * @return {?}
         */
        ClrPassword.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        ClrPassword.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                if (this.focusService) {
                    this.focusService.focused = true;
                }
            };
        /**
         * @return {?}
         */
        ClrPassword.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
                if (this.focusService) {
                    this.focusService.focused = false;
                }
            };
        ClrPassword.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPassword]', host: { '[class.clr-input]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrPassword.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }] },
                { type: FocusService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: rxjs.BehaviorSubject, decorators: [{ type: i0.Inject, args: [ToggleService,] }] }
            ];
        };
        ClrPassword.propDecorators = {
            onFocus: [{ type: i0.HostListener, args: ['focus',] }],
            onBlur: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return ClrPassword;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrPasswordModule = /** @class */ (function () {
        function ClrPasswordModule() {
        }
        ClrPasswordModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrPassword, ClrPasswordContainer],
                        exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer],
                        entryComponents: [ClrPasswordContainer],
                    },] }
        ];
        return ClrPasswordModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadioWrapper = /** @class */ (function () {
        function ClrRadioWrapper() {
            // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
            // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
            // but we'd still need to insert a label
            this._dynamic = false;
        }
        ClrRadioWrapper.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-radio-wrapper',
                        template: "\n    <ng-content select=\"[clrRadio]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                        host: {
                            '[class.clr-radio-wrapper]': 'true',
                        },
                        providers: [ControlIdService]
                    }] }
        ];
        ClrRadioWrapper.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrRadioWrapper;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadio = /** @class */ (function (_super) {
        __extends(ClrRadio, _super);
        function ClrRadio(vcr, ngControlService, ifErrorService, control, controlClassService, el, renderer) {
            var _this = _super.call(this, ClrRadioWrapper, vcr, 0) || this;
            _this.ngControlService = ngControlService;
            _this.ifErrorService = ifErrorService;
            _this.control = control;
            if (controlClassService) {
                controlClassService.initControlClass(renderer, el.nativeElement);
            }
            return _this;
        }
        /**
         * @return {?}
         */
        ClrRadio.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.ngControlService) {
                    this.ngControlService.setControl(this.control);
                }
            };
        /**
         * @return {?}
         */
        ClrRadio.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
            };
        ClrRadio.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrRadio]' },] }
        ];
        /** @nocollapse */
        ClrRadio.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService, decorators: [{ type: i0.Optional }] },
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        ClrRadio.propDecorators = {
            onBlur: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return ClrRadio;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadioContainer = /** @class */ (function () {
        function ClrRadioContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this.inline = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (control) {
                _this.invalid = control.invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        Object.defineProperty(ClrRadioContainer.prototype, "clrInline", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline;
            },
            /*
             * Here we want to support the following cases
             * clrInline - true by presence
             * clrInline="true|false" - unless it is explicitly false, strings are considered true
             * [clrInline]="true|false" - expect a boolean
             */
            set: /*
               * Here we want to support the following cases
               * clrInline - true by presence
               * clrInline="true|false" - unless it is explicitly false, strings are considered true
               * [clrInline]="true|false" - expect a boolean
               */ 
            /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                if (typeof value === 'string') {
                    this.inline = value === 'false' ? false : true;
                }
                else {
                    this.inline = !!value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrRadioContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
            };
        /**
         * @return {?}
         */
        ClrRadioContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrRadioContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
            };
        ClrRadioContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-radio-container',
                        template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-radio-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [NgControlService, ControlClassService, IfErrorService]
                    }] }
        ];
        /** @nocollapse */
        ClrRadioContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrRadioContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }],
            clrInline: [{ type: i0.Input }]
        };
        return ClrRadioContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrRadioModule = /** @class */ (function () {
        function ClrRadioModule() {
        }
        ClrRadioModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
                        declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                        exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                        entryComponents: [ClrRadioWrapper],
                    },] }
        ];
        return ClrRadioModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSelectContainer = /** @class */ (function () {
        function ClrSelectContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.multi = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (control) {
                _this.invalid = control.invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.multi = control.valueAccessor instanceof forms.SelectMultipleControlValueAccessor;
                _this.control = control;
            }));
        }
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.wrapperClass = /**
         * @return {?}
         */
            function () {
                return this.multi ? 'clr-multiselect-wrapper' : 'clr-select-wrapper';
            };
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrSelectContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrSelectContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-select-container',
                        template: "    \n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div [ngClass]=\"wrapperClass()\">\n                <ng-content select=\"[clrSelect]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                    }] }
        ];
        /** @nocollapse */
        ClrSelectContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrSelectContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }],
            multiple: [{ type: i0.ContentChild, args: [forms.SelectMultipleControlValueAccessor,] }]
        };
        return ClrSelectContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSelect = /** @class */ (function (_super) {
        __extends(ClrSelect, _super);
        function ClrSelect(vcr, ngControlService, ifErrorService, control, controlClassService, el, renderer) {
            var _this = _super.call(this, ClrSelectContainer, vcr, 1) || this;
            _this.ngControlService = ngControlService;
            _this.ifErrorService = ifErrorService;
            _this.control = control;
            if (!control) {
                throw new Error('clrSelect can only be used within an Angular form control, add ngModel or formControl to the select');
            }
            if (controlClassService) {
                controlClassService.initControlClass(renderer, el.nativeElement);
            }
            return _this;
        }
        /**
         * @return {?}
         */
        ClrSelect.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.ngControlService) {
                    this.ngControlService.setControl(this.control);
                }
            };
        /**
         * @return {?}
         */
        ClrSelect.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
            };
        ClrSelect.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrSelect]', host: { '[class.clr-select]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrSelect.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService, decorators: [{ type: i0.Optional }] },
                { type: i0.ElementRef },
                { type: i0.Renderer2 }
            ];
        };
        ClrSelect.propDecorators = {
            onBlur: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return ClrSelect;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSelectModule = /** @class */ (function () {
        function ClrSelectModule() {
        }
        ClrSelectModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrSelect, ClrSelectContainer],
                        exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer],
                        entryComponents: [ClrSelectContainer],
                    },] }
        ];
        return ClrSelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTextareaContainer = /** @class */ (function () {
        function ClrTextareaContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
            var _this = this;
            this.ifErrorService = ifErrorService;
            this.layoutService = layoutService;
            this.controlClassService = controlClassService;
            this.ngControlService = ngControlService;
            this.subscriptions = [];
            this.invalid = false;
            this._dynamic = false;
            this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (control) {
                _this.invalid = control.invalid;
            }));
            this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
                _this.control = control;
            }));
        }
        /**
         * @return {?}
         */
        ClrTextareaContainer.prototype.controlClass = /**
         * @return {?}
         */
            function () {
                return this.controlClassService.controlClass(this.invalid, this.addGrid());
            };
        /**
         * @return {?}
         */
        ClrTextareaContainer.prototype.addGrid = /**
         * @return {?}
         */
            function () {
                if (this.layoutService && !this.layoutService.isVertical()) {
                    return true;
                }
                return false;
            };
        /**
         * @return {?}
         */
        ClrTextareaContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.subscriptions) {
                    this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
                }
            };
        ClrTextareaContainer.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-textarea-container',
                        template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-textarea-wrapper\">\n                <ng-content select=\"[clrTextarea]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                        host: {
                            '[class.clr-form-control]': 'true',
                            '[class.clr-form-control-disabled]': 'control?.disabled',
                            '[class.clr-row]': 'addGrid()',
                        },
                        providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                    }] }
        ];
        /** @nocollapse */
        ClrTextareaContainer.ctorParameters = function () {
            return [
                { type: IfErrorService },
                { type: LayoutService, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService },
                { type: NgControlService }
            ];
        };
        ClrTextareaContainer.propDecorators = {
            label: [{ type: i0.ContentChild, args: [ClrLabel,] }]
        };
        return ClrTextareaContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTextarea = /** @class */ (function (_super) {
        __extends(ClrTextarea, _super);
        function ClrTextarea(vcr, ngControlService, ifErrorService, control, controlClassService, renderer, el) {
            var _this = _super.call(this, ClrTextareaContainer, vcr, 1) || this;
            _this.ngControlService = ngControlService;
            _this.ifErrorService = ifErrorService;
            _this.control = control;
            if (!control) {
                throw new Error('clrTextarea can only be used within an Angular form control, add ngModel or formControl to the textarea');
            }
            if (controlClassService) {
                controlClassService.initControlClass(renderer, el.nativeElement);
            }
            return _this;
        }
        /**
         * @return {?}
         */
        ClrTextarea.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.ngControlService) {
                    this.ngControlService.setControl(this.control);
                }
            };
        /**
         * @return {?}
         */
        ClrTextarea.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                if (this.ifErrorService) {
                    this.ifErrorService.triggerStatusChange();
                }
            };
        ClrTextarea.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrTextarea]', host: { '[class.clr-textarea]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrTextarea.ctorParameters = function () {
            return [
                { type: i0.ViewContainerRef },
                { type: NgControlService, decorators: [{ type: i0.Optional }] },
                { type: IfErrorService, decorators: [{ type: i0.Optional }] },
                { type: forms.NgControl, decorators: [{ type: i0.Optional }] },
                { type: ControlClassService, decorators: [{ type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        ClrTextarea.propDecorators = {
            onBlur: [{ type: i0.HostListener, args: ['blur',] }]
        };
        return ClrTextarea;
    }(WrappedFormControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTextareaModule = /** @class */ (function () {
        function ClrTextareaModule() {
        }
        ClrTextareaModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule, ClrCommonFormsModule],
                        declarations: [ClrTextarea, ClrTextareaContainer],
                        exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer],
                        entryComponents: [ClrTextareaContainer],
                    },] }
        ];
        return ClrTextareaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrFormsModule = /** @class */ (function () {
        function ClrFormsModule() {
        }
        ClrFormsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [
                            ClrCommonFormsModule,
                            ClrCheckboxModule,
                            ClrDatepickerModule,
                            ClrInputModule,
                            ClrPasswordModule,
                            ClrRadioModule,
                            ClrSelectModule,
                            ClrTextareaModule,
                        ],
                    },] }
        ];
        return ClrFormsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Expand = /** @class */ (function () {
        function Expand() {
            this.expandable = 0;
            // private _replace: boolean = false;
            this._replace = new rxjs.BehaviorSubject(false);
            this._loading = false;
            this._expanded = false;
            // TODO: Move this to the datagrid RowExpand.
            // I spent some time doing this but ran into a couple of issues
            // Will take care of this later.
            this._animate = new rxjs.Subject();
            this._expandChange = new rxjs.Subject();
        }
        Object.defineProperty(Expand.prototype, "replace", {
            get: /**
             * @return {?}
             */ function () {
                return this._replace.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} replaceValue
         * @return {?}
         */
        Expand.prototype.setReplace = /**
         * @param {?} replaceValue
         * @return {?}
         */
            function (replaceValue) {
                this._replace.next(replaceValue);
            };
        Object.defineProperty(Expand.prototype, "loading", {
            get: /**
             * @return {?}
             */ function () {
                return this._loading;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (value !== this._loading) {
                    this._loading = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Expand.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (value !== this._expanded) {
                    this._expanded = value;
                    this._animate.next();
                    this._expandChange.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Expand.prototype, "animate", {
            get: /**
             * @return {?}
             */ function () {
                return this._animate.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Expand.prototype, "expandChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._expandChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} state
         * @return {?}
         */
        Expand.prototype.loadingStateChange = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                switch (state) {
                    case ClrLoadingState.LOADING:
                        this.loading = true;
                        break;
                    default:
                        this.loading = false;
                        this._animate.next();
                        break;
                }
            };
        Expand.decorators = [
            { type: i0.Injectable }
        ];
        return Expand;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * TODO: make this a reusable directive outside of Datagrid, like [clrLoading].
     */
    var ClrIfExpanded = /** @class */ (function () {
        function ClrIfExpanded(template, container, expand) {
            var _this = this;
            this.template = template;
            this.container = container;
            this.expand = expand;
            this._expanded = false;
            this.expandedChange = new i0.EventEmitter(true);
            /**
             * Subscriptions to all the services and queries changes
             */
            this._subscriptions = [];
            expand.expandable++;
            this._subscriptions.push(expand.expandChange.subscribe(function () {
                _this.updateView();
                _this.expandedChange.emit(_this.expand.expanded);
            }));
        }
        Object.defineProperty(ClrIfExpanded.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'boolean') {
                    this.expand.expanded = value;
                    this._expanded = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrIfExpanded.prototype.updateView = /**
         * @return {?}
         */
            function () {
                if (this.expand.expanded && this.container.length !== 0) {
                    return;
                }
                if (this.expand.expanded) {
                    // Should we pass a context? I don't see anything useful to pass right now,
                    // but we can come back to it in the future as a solution for additional features.
                    this.container.createEmbeddedView(this.template);
                }
                else {
                    // TODO: Move when we move the animation logic to Datagrid Row Expand
                    // We clear before the animation is over. Not ideal, but doing better would involve a much heavier
                    // process for very little gain. Once Angular animations are dynamic enough, we should be able to
                    // get the optimal behavior.
                    this.container.clear();
                }
            };
        /**
         * @return {?}
         */
        ClrIfExpanded.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.updateView();
            };
        /**
         * @return {?}
         */
        ClrIfExpanded.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.expand.expandable--;
                this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrIfExpanded.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfExpanded]' },] }
        ];
        /** @nocollapse */
        ClrIfExpanded.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef },
                { type: Expand }
            ];
        };
        ClrIfExpanded.propDecorators = {
            expanded: [{ type: i0.Input, args: ['clrIfExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrIfExpandedChange',] }]
        };
        return ClrIfExpanded;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPAND_DIRECTIVES = [ClrIfExpanded];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrIfExpandModule = /** @class */ (function () {
        function ClrIfExpandModule() {
        }
        ClrIfExpandModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [EXPAND_DIRECTIVES], exports: [EXPAND_DIRECTIVES] },] }
        ];
        return ClrIfExpandModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_LOADING_DIRECTIVES = [ClrLoading];
    var ClrLoadingModule = /** @class */ (function () {
        function ClrLoadingModule() {
        }
        ClrLoadingModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CLR_LOADING_DIRECTIVES], exports: [CLR_LOADING_DIRECTIVES] },] }
        ];
        return ClrLoadingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var OutsideClick = /** @class */ (function () {
        function OutsideClick(el) {
            this.el = el;
            this.strict = false;
            this.outsideClick = new i0.EventEmitter(false);
        }
        /**
         * @param {?} event
         * @return {?}
         */
        OutsideClick.prototype.documentClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var target = event.target;
                // Get the element in the DOM on which the mouse was clicked
                /** @type {?} */
                var host = this.el.nativeElement;
                if (target === host) {
                    return;
                }
                if (!this.strict && host.contains(target)) {
                    return;
                }
                this.outsideClick.emit(event);
            };
        OutsideClick.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrOutsideClick]' },] }
        ];
        /** @nocollapse */
        OutsideClick.ctorParameters = function () {
            return [
                { type: i0.ElementRef }
            ];
        };
        OutsideClick.propDecorators = {
            strict: [{ type: i0.Input, args: ['clrStrict',] }],
            outsideClick: [{ type: i0.Output, args: ['clrOutsideClick',] }],
            documentClick: [{ type: i0.HostListener, args: ['document:click', ['$event'],] }]
        };
        return OutsideClick;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var OUSTIDE_CLICK_DIRECTIVES = [OutsideClick];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrOutsideClickModule = /** @class */ (function () {
        function ClrOutsideClickModule() {
        }
        ClrOutsideClickModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [OUSTIDE_CLICK_DIRECTIVES], exports: [OUSTIDE_CLICK_DIRECTIVES] },] }
        ];
        return ClrOutsideClickModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DomAdapter = /** @class */ (function () {
        function DomAdapter() {
        }
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.userDefinedWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                element.classList.add('datagrid-cell-width-zero');
                /** @type {?} */
                var userDefinedWidth = parseInt(getComputedStyle(element).getPropertyValue('width'), 10);
                element.classList.remove('datagrid-cell-width-zero');
                return userDefinedWidth;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.scrollBarWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.offsetWidth - element.clientWidth;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.scrollWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.scrollWidth || 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.computedHeight = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return parseInt(getComputedStyle(element).getPropertyValue('height'), 10);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.clientRect = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                /** @type {?} */
                var elementClientRect = element.getBoundingClientRect();
                return {
                    top: parseInt(elementClientRect.top, 10),
                    bottom: parseInt(elementClientRect.bottom, 10),
                    left: parseInt(elementClientRect.left, 10),
                    right: parseInt(elementClientRect.right, 10),
                    width: parseInt(elementClientRect.width, 10),
                    height: parseInt(elementClientRect.height, 10),
                };
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.minWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return parseInt(getComputedStyle(element).getPropertyValue('min-width'), 10);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        DomAdapter.prototype.focus = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                element.focus();
            };
        DomAdapter.decorators = [
            { type: i0.Injectable }
        ];
        return DomAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridRowExpandAnimation = /** @class */ (function () {
        function DatagridRowExpandAnimation(el, domAdapter, renderer, expand) {
            var _this = this;
            this.el = el;
            this.domAdapter = domAdapter;
            this.renderer = renderer;
            this.expand = expand;
            if (expand && expand.animate) {
                expand.animate.subscribe(function () {
                    // We already had an animation waiting, so we just have to run in, not prepare again
                    if (_this.oldHeight) {
                        setTimeout(function () { return _this.run(); });
                    }
                    else {
                        _this.animate();
                    }
                });
            }
        }
        /*
           * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
           * They're working on it, but have no ETA.
           */
        /*
             * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
             * They're working on it, but have no ETA.
             */
        /**
         * @return {?}
         */
        DatagridRowExpandAnimation.prototype.animate = /*
             * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
             * They're working on it, but have no ETA.
             */
            /**
             * @return {?}
             */
            function () {
                var _this = this;
                // Check if we do have web-animations available. If not, just skip the animation.
                if (!this.el.nativeElement.animate) {
                    return;
                }
                // We had an animation running, we skip to the end
                if (this.running) {
                    this.running.finish();
                }
                this.oldHeight = this.domAdapter.computedHeight(this.el.nativeElement);
                // We set the height of the element immediately to avoid a flicker before the animation starts.
                this.renderer.setStyle(this.el.nativeElement, 'height', this.oldHeight + 'px');
                this.renderer.setStyle(this.el.nativeElement, 'overflow-y', 'hidden');
                setTimeout(function () {
                    if (_this.expand.loading) {
                        return;
                    }
                    _this.run();
                });
            };
        /**
         * @return {?}
         */
        DatagridRowExpandAnimation.prototype.run = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.renderer.setStyle(this.el.nativeElement, 'height', null);
                /** @type {?} */
                var newHeight = this.domAdapter.computedHeight(this.el.nativeElement);
                this.running = this.el.nativeElement.animate({ height: [this.oldHeight + 'px', newHeight + 'px'], easing: 'ease-in-out' }, { duration: 200 });
                this.running.onfinish = function () {
                    _this.renderer.setStyle(_this.el.nativeElement, 'overflow-y', null);
                    delete _this.running;
                };
                delete this.oldHeight;
            };
        DatagridRowExpandAnimation.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-row' },] }
        ];
        /** @nocollapse */
        DatagridRowExpandAnimation.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DomAdapter },
                { type: i0.Renderer2 },
                { type: Expand }
            ];
        };
        return DatagridRowExpandAnimation;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * @abstract
     */
    var  /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */ 
    /**
     * @abstract
     */
    CustomFilter = /** @class */ (function () {
        function CustomFilter() {
        }
        return CustomFilter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * This provider implements some form of synchronous debouncing through a lock pattern
     * to avoid emitting multiple state changes for a single user action.
     */
    var StateDebouncer = /** @class */ (function () {
        function StateDebouncer() {
            /**
             * The Observable that lets other classes subscribe to global state changes
             */
            this._change = new rxjs.Subject();
            /*
                 * This is the lock, to only emit once all the changes have finished processing
                 */
            this.nbChanges = 0;
        }
        Object.defineProperty(StateDebouncer.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        StateDebouncer.prototype.changeStart = /**
         * @return {?}
         */
            function () {
                this.nbChanges++;
            };
        /**
         * @return {?}
         */
        StateDebouncer.prototype.changeDone = /**
         * @return {?}
         */
            function () {
                if (--this.nbChanges === 0) {
                    this._change.next();
                }
            };
        StateDebouncer.decorators = [
            { type: i0.Injectable }
        ];
        return StateDebouncer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Page = /** @class */ (function () {
        function Page(stateDebouncer) {
            this.stateDebouncer = stateDebouncer;
            /**
             * Page size, a value of 0 means no pagination
             */
            this._size = 0;
            /**
             * Total items (needed to guess the last page)
             */
            this._totalItems = 0;
            /**
             * The Observable that lets other classes subscribe to page changes
             */
            this._change = new rxjs.Subject();
            this._sizeChange = new rxjs.Subject();
            /**
             * Current page
             */
            this._current = 1;
        }
        Object.defineProperty(Page.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return this._size;
            },
            set: /**
             * @param {?} size
             * @return {?}
             */ function (size) {
                /** @type {?} */
                var oldSize = this._size;
                if (size !== oldSize) {
                    this._size = size;
                    if (size === 0) {
                        this._current = 1;
                    }
                    else {
                        // Yeap. That's the formula to keep the first item from the old page still
                        // displayed in the new one.
                        this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
                    }
                    // We always emit an event even if the current page index didn't change, because
                    // the size changing means the items inside the page are different
                    this._change.next(this._current);
                    this._sizeChange.next(this._size);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "totalItems", {
            get: /**
             * @return {?}
             */ function () {
                return this._totalItems;
            },
            set: /**
             * @param {?} total
             * @return {?}
             */ function (total) {
                this._totalItems = total;
                // If we have less items than before, we might need to change the current page
                if (this.current > this.last) {
                    this.current = this.last;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "last", {
            get: /**
             * @return {?}
             */ function () {
                if (this._last) {
                    return this._last;
                }
                // If the last page isn't known, we compute it from the last item's index
                if (this.size > 0 && this.totalItems) {
                    return Math.ceil(this.totalItems / this.size);
                }
                return 1;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                this._last = page;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "sizeChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._sizeChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                if (page !== this._current) {
                    this.stateDebouncer.changeStart();
                    this._current = page;
                    this._change.next(page);
                    this.stateDebouncer.changeDone();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Moves to the previous page if it exists
         */
        /**
         * Moves to the previous page if it exists
         * @return {?}
         */
        Page.prototype.previous = /**
         * Moves to the previous page if it exists
         * @return {?}
         */
            function () {
                if (this.current > 1) {
                    this.current--;
                }
            };
        /**
         * Moves to the next page if it exists
         */
        /**
         * Moves to the next page if it exists
         * @return {?}
         */
        Page.prototype.next = /**
         * Moves to the next page if it exists
         * @return {?}
         */
            function () {
                if (this.current < this.last) {
                    this.current++;
                }
            };
        Object.defineProperty(Page.prototype, "firstItem", {
            /**
             * Index of the first item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the first item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                if (this.size === 0) {
                    return 0;
                }
                return (this.current - 1) * this.size;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Page.prototype, "lastItem", {
            /**
             * Index of the last item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the last item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                if (this.size === 0) {
                    return this.totalItems - 1;
                }
                /** @type {?} */
                var lastInPage = this.current * this.size - 1;
                if (this.totalItems) {
                    lastInPage = Math.min(lastInPage, this.totalItems - 1);
                }
                return lastInPage;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Resets the page size to 0
         */
        /**
         * Resets the page size to 0
         * @return {?}
         */
        Page.prototype.resetPageSize = /**
         * Resets the page size to 0
         * @return {?}
         */
            function () {
                this.size = 0;
            };
        Page.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Page.ctorParameters = function () {
            return [
                { type: StateDebouncer }
            ];
        };
        return Page;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var FiltersProvider = /** @class */ (function () {
        function FiltersProvider(_page, stateDebouncer) {
            this._page = _page;
            this.stateDebouncer = stateDebouncer;
            /**
             * This subject is the list of filters that changed last, not the whole list.
             * We emit a list rather than just one filter to allow batch changes to several at once.
             */
            this._change = new rxjs.Subject();
            /**
             * List of all filters, whether they're active or not
             */
            this._all = [];
        }
        Object.defineProperty(FiltersProvider.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Tests if at least one filter is currently active
         */
        /**
         * Tests if at least one filter is currently active
         * @return {?}
         */
        FiltersProvider.prototype.hasActiveFilters = /**
         * Tests if at least one filter is currently active
         * @return {?}
         */
            function () {
                var e_1, _a;
                try {
                    // We do not use getActiveFilters() because this function will be called much more often
                    // and stopping the loop early might be relevant.
                    for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var filter = _c.value.filter;
                        if (filter && filter.isActive()) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return false;
            };
        /**
         * Returns a list of all currently active filters
         */
        /**
         * Returns a list of all currently active filters
         * @return {?}
         */
        FiltersProvider.prototype.getActiveFilters = /**
         * Returns a list of all currently active filters
         * @return {?}
         */
            function () {
                var e_2, _a;
                /** @type {?} */
                var ret = [];
                try {
                    for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var filter = _c.value.filter;
                        if (filter && filter.isActive()) {
                            ret.push(filter);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                return ret;
            };
        /**
         * Registers a filter, and returns a deregistration function
         */
        /**
         * Registers a filter, and returns a deregistration function
         * @template F
         * @param {?} filter
         * @return {?}
         */
        FiltersProvider.prototype.add = /**
         * Registers a filter, and returns a deregistration function
         * @template F
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                var _this = this;
                /** @type {?} */
                var index = this._all.length;
                /** @type {?} */
                var subscription = filter.changes.subscribe(function () { return _this.resetPageAndEmitFilterChange([filter]); });
                /** @type {?} */
                var hasUnregistered = false;
                /** @type {?} */
                var registered = new RegisteredFilter(filter, function () {
                    if (hasUnregistered) {
                        return;
                    }
                    subscription.unsubscribe();
                    _this._all.splice(index, 1);
                    if (filter.isActive()) {
                        _this.resetPageAndEmitFilterChange([]);
                    }
                    hasUnregistered = true;
                });
                this._all.push(registered);
                if (filter.isActive()) {
                    this.resetPageAndEmitFilterChange([filter]);
                }
                return registered;
            };
        /**
         * Accepts an item if it is accepted by all currently active filters
         */
        /**
         * Accepts an item if it is accepted by all currently active filters
         * @param {?} item
         * @return {?}
         */
        FiltersProvider.prototype.accepts = /**
         * Accepts an item if it is accepted by all currently active filters
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var e_3, _a;
                try {
                    for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var filter = _c.value.filter;
                        if (filter && filter.isActive() && !filter.accepts(item)) {
                            return false;
                        }
                    }
                }
                catch (e_3_1) {
                    e_3 = { error: e_3_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_3)
                            throw e_3.error;
                    }
                }
                return true;
            };
        /**
         * @param {?} filters
         * @return {?}
         */
        FiltersProvider.prototype.resetPageAndEmitFilterChange = /**
         * @param {?} filters
         * @return {?}
         */
            function (filters) {
                this.stateDebouncer.changeStart();
                // filtering may change the page number such that current page number doesn't exist in the filtered dataset.
                // So here we always set the current page to 1 so that it'll fetch first page's data with the given filter.
                this._page.current = 1;
                this._change.next(filters);
                this.stateDebouncer.changeDone();
            };
        FiltersProvider.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        FiltersProvider.ctorParameters = function () {
            return [
                { type: Page },
                { type: StateDebouncer }
            ];
        };
        return FiltersProvider;
    }());
    /**
     * @template T, F
     */
    var /**
     * @template T, F
     */ RegisteredFilter = /** @class */ (function () {
        function RegisteredFilter(filter, unregister) {
            this.filter = filter;
            this.unregister = unregister;
        }
        return RegisteredFilter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     * @template T, F
     */
    var /**
     * @abstract
     * @template T, F
     */ DatagridFilterRegistrar = /** @class */ (function () {
        function DatagridFilterRegistrar(filters) {
            this.filters = filters;
        }
        Object.defineProperty(DatagridFilterRegistrar.prototype, "filter", {
            get: /**
             * @return {?}
             */ function () {
                return this.registered && this.registered.filter;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} filter
         * @return {?}
         */
        DatagridFilterRegistrar.prototype.setFilter = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter) {
                // If we previously had another filter, we unregister it
                this.deleteFilter();
                if (filter instanceof RegisteredFilter) {
                    this.registered = filter;
                }
                else if (filter) {
                    this.registered = this.filters.add(filter);
                }
            };
        /**
         * @return {?}
         */
        DatagridFilterRegistrar.prototype.deleteFilter = /**
         * @return {?}
         */
            function () {
                if (this.registered) {
                    this.registered.unregister();
                    delete this.registered;
                }
            };
        /**
         * @return {?}
         */
        DatagridFilterRegistrar.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.deleteFilter();
            };
        return DatagridFilterRegistrar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Custom filter that can be added in any column to override the default object property string filter.
     * The reason this is not just an input on DatagridColumn is because we need the filter's template to be projected,
     * since it can be anything (not just a text input).
     * @template T
     */
    var ClrDatagridFilter = /** @class */ (function (_super) {
        __extends(ClrDatagridFilter, _super);
        function ClrDatagridFilter(_filters, commonStrings) {
            var _this = _super.call(this, _filters) || this;
            _this.commonStrings = commonStrings;
            _this.anchorPoint = Point.RIGHT_BOTTOM;
            _this.popoverPoint = Point.RIGHT_TOP;
            _this.popoverOptions = { allowMultipleOpen: true };
            /**
             * Tracks whether the filter dropdown is open or not
             */
            _this._open = false;
            _this.openChanged = new i0.EventEmitter(false);
            return _this;
        }
        Object.defineProperty(ClrDatagridFilter.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._open;
            },
            set: /**
             * @param {?} open
             * @return {?}
             */ function (open) {
                /** @type {?} */
                var boolOpen = !!open;
                if (boolOpen !== this._open) {
                    this._open = boolOpen;
                    this.openChanged.emit(boolOpen);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridFilter.prototype, "customFilter", {
            set: /**
             * @param {?} filter
             * @return {?}
             */ function (filter) {
                this.setFilter(filter);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridFilter.prototype, "active", {
            /**
             * Indicates if the filter is currently active
             */
            get: /**
             * Indicates if the filter is currently active
             * @return {?}
             */ function () {
                return !!this.filter && this.filter.isActive();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Shows/hides the filter dropdown
         */
        /**
         * Shows/hides the filter dropdown
         * @return {?}
         */
        ClrDatagridFilter.prototype.toggle = /**
         * Shows/hides the filter dropdown
         * @return {?}
         */
            function () {
                this.open = !this.open;
            };
        ClrDatagridFilter.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-filter',
                        // We register this component as a CustomFilter, for the parent column to detect it.
                        providers: [{ provide: CustomFilter, useExisting: ClrDatagridFilter }],
                        template: "\n        <button #anchor class=\"datagrid-filter-toggle\" (click)=\"toggle()\"\n            [class.datagrid-filter-open]=\"open\" [class.datagrid-filtered]=\"active\"\n            type=\"button\"></button>\n\n        <ng-template [(clrPopoverOld)]=\"open\" [clrPopoverOldAnchor]=\"anchor\" [clrPopoverOldAnchorPoint]=\"anchorPoint\"\n             [clrPopoverOldPopoverPoint]=\"popoverPoint\" [clrPopoverOldOptions]=\"popoverOptions\">\n            <div class=\"datagrid-filter\">\n                <!-- FIXME: this whole filter part needs a final design before we can try to have a cleaner DOM -->\n                <div class=\"datagrid-filter-close-wrapper\">\n                    <button type=\"button\" class=\"close\" (click)=\"open = false\">\n                        <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n                    </button>\n                </div>\n    \n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridFilter.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: ClrCommonStrings }
            ];
        };
        ClrDatagridFilter.propDecorators = {
            open: [{ type: i0.Input, args: ['clrDgFilterOpen',] }],
            openChanged: [{ type: i0.Output, args: ['clrDgFilterOpenChange',] }],
            customFilter: [{ type: i0.Input, args: ['clrDgFilter',] }]
        };
        return ClrDatagridFilter;
    }(DatagridFilterRegistrar));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ DatagridStringFilterImpl = /** @class */ (function () {
        function DatagridStringFilterImpl(filterFn) {
            this.filterFn = filterFn;
            /**
             * The Observable required as part of the Filter interface
             */
            this._changes = new rxjs.Subject();
            /**
             * Raw input value
             */
            this._rawValue = '';
            /**
             * Input value converted to lowercase
             */
            this._lowerCaseValue = '';
        }
        Object.defineProperty(DatagridStringFilterImpl.prototype, "changes", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridStringFilterImpl.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._rawValue;
            },
            /**
             * Common setter for the input value
             */
            set: /**
             * Common setter for the input value
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!value) {
                    value = '';
                }
                if (value !== this._rawValue) {
                    this._rawValue = value;
                    this._lowerCaseValue = value.toLowerCase().trim();
                    this._changes.next(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridStringFilterImpl.prototype, "lowerCaseValue", {
            get: /**
             * @return {?}
             */ function () {
                return this._lowerCaseValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Indicates if the filter is currently active, meaning the input is not empty
         */
        /**
         * Indicates if the filter is currently active, meaning the input is not empty
         * @return {?}
         */
        DatagridStringFilterImpl.prototype.isActive = /**
         * Indicates if the filter is currently active, meaning the input is not empty
         * @return {?}
         */
            function () {
                return !!this.value;
            };
        /**
         * Tests if an item matches a search text
         */
        /**
         * Tests if an item matches a search text
         * @param {?} item
         * @return {?}
         */
        DatagridStringFilterImpl.prototype.accepts = /**
         * Tests if an item matches a search text
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // We always test with the lowercase value of the input, to stay case insensitive
                return this.filterFn.accepts(item, this.lowerCaseValue);
            };
        return DatagridStringFilterImpl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DatagridStringFilter = /** @class */ (function (_super) {
        __extends(DatagridStringFilter, _super);
        function DatagridStringFilter(filters, domAdapter) {
            var _this = _super.call(this, filters) || this;
            _this.domAdapter = domAdapter;
            /**
             * Indicates if the filter dropdown is open
             */
            _this.open = false;
            _this.filterValueChange = new i0.EventEmitter();
            return _this;
        }
        Object.defineProperty(DatagridStringFilter.prototype, "customStringFilter", {
            /**
             * Customizable filter logic based on a search text
             */
            set: /**
             * Customizable filter logic based on a search text
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value instanceof RegisteredFilter) {
                    this.setFilter(value);
                }
                else {
                    this.setFilter(new DatagridStringFilterImpl(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DatagridStringFilter.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.filterContainer.openChanged.subscribe(function (open) {
                    if (open) {
                        // We need the timeout because at the time this executes, the input isn't
                        // displayed yet.
                        setTimeout(function () {
                            _this.domAdapter.focus(_this.input.nativeElement);
                        });
                    }
                });
            };
        Object.defineProperty(DatagridStringFilter.prototype, "value", {
            /**
             * Common setter for the input value
             */
            get: /**
             * Common setter for the input value
             * @return {?}
             */ function () {
                return this.filter.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!this.filter) {
                    return;
                }
                if (!value) {
                    value = '';
                }
                if (value !== this.filter.value) {
                    this.filter.value = value;
                    this.filterValueChange.emit(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DatagridStringFilter.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open = false;
            };
        DatagridStringFilter.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-string-filter',
                        providers: [{ provide: CustomFilter, useExisting: DatagridStringFilter }],
                        template: "\n        <clr-dg-filter [clrDgFilter]=\"registered\" [(clrDgFilterOpen)]=\"open\">\n            <!--\n                Even though this *ngIf looks useless because the filter container already has one,\n                it prevents NgControlStatus and other directives automatically added by Angular\n                on inputs with NgModel from freaking out because of their host binding changing\n                mid-change detection when the input is destroyed.\n            -->\n            <input #input type=\"text\" name=\"search\" [(ngModel)]=\"value\" *ngIf=\"open\"\n                (keyup.enter)=\"close()\" (keyup.escape)=\"close()\"/>\n        </clr-dg-filter>\n    "
                    }] }
        ];
        /** @nocollapse */
        DatagridStringFilter.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: DomAdapter }
            ];
        };
        DatagridStringFilter.propDecorators = {
            customStringFilter: [{ type: i0.Input, args: ['clrDgStringFilter',] }],
            input: [{ type: i0.ViewChild, args: ['input',] }],
            filterContainer: [{ type: i0.ViewChild, args: [ClrDatagridFilter,] }],
            value: [{ type: i0.Input, args: ['clrFilterValue',] }],
            filterValueChange: [{ type: i0.Output, args: ['clrFilterValueChange',] }]
        };
        return DatagridStringFilter;
    }(DatagridFilterRegistrar));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ OompaLoompa = /** @class */ (function () {
        // FIXME: Request Injector once we move to Angular 4.2+, it'll allow easier refactors
        function OompaLoompa(cdr, willyWonka) {
            var _this = this;
            this.subscription = willyWonka.chocolate.subscribe(function () {
                if (_this.latestFlavor !== _this.flavor) {
                    cdr.detectChanges();
                }
            });
        }
        /**
         * @return {?}
         */
        OompaLoompa.prototype.ngAfterContentChecked = /**
         * @return {?}
         */
            function () {
                this.latestFlavor = this.flavor;
            };
        /**
         * @return {?}
         */
        OompaLoompa.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscription.unsubscribe();
            };
        return OompaLoompa;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var RowActionService = /** @class */ (function () {
        function RowActionService() {
            this.actionableCount = 0;
        }
        /**
         * @return {?}
         */
        RowActionService.prototype.register = /**
         * @return {?}
         */
            function () {
                this.actionableCount++;
            };
        /**
         * @return {?}
         */
        RowActionService.prototype.unregister = /**
         * @return {?}
         */
            function () {
                this.actionableCount--;
            };
        Object.defineProperty(RowActionService.prototype, "hasActionableRow", {
            /**
             * false means no rows with action
             */
            get: /**
             * false means no rows with action
             * @return {?}
             */ function () {
                return this.actionableCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        RowActionService.decorators = [
            { type: i0.Injectable }
        ];
        return RowActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
     * declarative API, we need to fight against change detection and its one-way flow. This is
     * currently the least dirty solution to do what we want.
     *
     * Do not modify or even use this class unless you know exactly what you're doing.
     * It has the potential to trigger change detection loops or kill app performances.
     */
    var /*
     * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
     * declarative API, we need to fight against change detection and its one-way flow. This is
     * currently the least dirty solution to do what we want.
     *
     * Do not modify or even use this class unless you know exactly what you're doing.
     * It has the potential to trigger change detection loops or kill app performances.
     */ WillyWonka = /** @class */ (function () {
        function WillyWonka() {
            this._chocolate = new rxjs.Subject();
        }
        Object.defineProperty(WillyWonka.prototype, "chocolate", {
            get: /**
             * @return {?}
             */ function () {
                return this._chocolate.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WillyWonka.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this._chocolate.next();
            };
        return WillyWonka;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridWillyWonka = /** @class */ (function (_super) {
        __extends(DatagridWillyWonka, _super);
        function DatagridWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DatagridWillyWonka.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-datagrid' },] }
        ];
        return DatagridWillyWonka;
    }(WillyWonka));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ActionableOompaLoompa = /** @class */ (function (_super) {
        __extends(ActionableOompaLoompa, _super);
        function ActionableOompaLoompa(cdr, willyWonka, rowActions) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.rowActions = rowActions;
            return _this;
        }
        Object.defineProperty(ActionableOompaLoompa.prototype, "flavor", {
            get: /**
             * @return {?}
             */ function () {
                return this.rowActions.hasActionableRow;
            },
            enumerable: true,
            configurable: true
        });
        ActionableOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
        ];
        /** @nocollapse */
        ActionableOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: DatagridWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: RowActionService }
            ];
        };
        return ActionableOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ExpandableRowsCount = /** @class */ (function () {
        function ExpandableRowsCount() {
            this.expandableCount = 0;
        }
        /**
         * @return {?}
         */
        ExpandableRowsCount.prototype.register = /**
         * @return {?}
         */
            function () {
                this.expandableCount++;
            };
        /**
         * @return {?}
         */
        ExpandableRowsCount.prototype.unregister = /**
         * @return {?}
         */
            function () {
                this.expandableCount--;
            };
        Object.defineProperty(ExpandableRowsCount.prototype, "hasExpandableRow", {
            /**
             * false means no rows with action
             */
            get: /**
             * false means no rows with action
             * @return {?}
             */ function () {
                return this.expandableCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        ExpandableRowsCount.decorators = [
            { type: i0.Injectable }
        ];
        return ExpandableRowsCount;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ExpandableOompaLoompa = /** @class */ (function (_super) {
        __extends(ExpandableOompaLoompa, _super);
        function ExpandableOompaLoompa(cdr, willyWonka, expandableCount) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.expandableCount = expandableCount;
            return _this;
        }
        Object.defineProperty(ExpandableOompaLoompa.prototype, "flavor", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandableCount.hasExpandableRow;
            },
            enumerable: true,
            configurable: true
        });
        ExpandableOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
        ];
        /** @nocollapse */
        ExpandableOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: DatagridWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: ExpandableRowsCount }
            ];
        };
        return ExpandableOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * Generic accessor for deep object properties
     * that can be specified as simple dot-separated strings.
     * @template T
     */
    var /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */ 
    /**
     * Generic accessor for deep object properties
     * that can be specified as simple dot-separated strings.
     * @template T
     */
    NestedProperty = /** @class */ (function () {
        function NestedProperty(prop) {
            this.prop = prop;
            if (prop.indexOf('.') >= 0) {
                this.splitProp = prop.split('.');
            }
        }
        // Safe getter for a deep object property, will not throw an error but return
        // undefined if one of the intermediate properties is null or undefined.
        // Safe getter for a deep object property, will not throw an error but return
        // undefined if one of the intermediate properties is null or undefined.
        /**
         * @param {?} item
         * @return {?}
         */
        NestedProperty.prototype.getPropValue =
            // Safe getter for a deep object property, will not throw an error but return
            // undefined if one of the intermediate properties is null or undefined.
            /**
             * @param {?} item
             * @return {?}
             */
            function (item) {
                var e_1, _a;
                if (this.splitProp) {
                    /** @type {?} */
                    var value = item;
                    try {
                        for (var _b = __values(this.splitProp), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var nestedProp = _c.value;
                            if (value == null || typeof value === 'undefined' || typeof value[nestedProp] === 'undefined') {
                                return undefined;
                            }
                            value = value[nestedProp];
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return))
                                _a.call(_b);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    return value;
                }
                else {
                    return item[this.prop];
                }
            };
        return NestedProperty;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ DatagridPropertyComparator = /** @class */ (function () {
        function DatagridPropertyComparator(prop) {
            this.prop = prop;
            this.nestedProp = new NestedProperty(prop);
        }
        /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        DatagridPropertyComparator.prototype.compare = /**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
            function (a, b) {
                /** @type {?} */
                var propA = this.nestedProp.getPropValue(a);
                /** @type {?} */
                var propB = this.nestedProp.getPropValue(b);
                if (typeof propA === 'string') {
                    propA = propA.toLowerCase();
                }
                if (typeof propB === 'string') {
                    propB = propB.toLowerCase();
                }
                if (typeof propA === 'undefined' || propA === null) {
                    if (typeof propB === 'undefined' || propB === null) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else {
                    if (typeof propB === 'undefined' || propB === null) {
                        return -1;
                    }
                    else if (propA < propB) {
                        return -1;
                    }
                    else if (propA > propB) {
                        return 1;
                    }
                    else {
                        return 0;
                    }
                }
            };
        return DatagridPropertyComparator;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var /**
     * @template T
     */ DatagridPropertyStringFilter = /** @class */ (function () {
        function DatagridPropertyStringFilter(prop, exact) {
            if (exact === void 0) {
                exact = false;
            }
            this.prop = prop;
            this.exact = exact;
            this.nestedProp = new NestedProperty(prop);
        }
        /**
         * @param {?} item
         * @param {?} search
         * @return {?}
         */
        DatagridPropertyStringFilter.prototype.accepts = /**
         * @param {?} item
         * @param {?} search
         * @return {?}
         */
            function (item, search) {
                /** @type {?} */
                var propValue = this.nestedProp.getPropValue(item);
                if (typeof propValue === 'undefined') {
                    return false;
                }
                else if (this.exact) {
                    return ('' + propValue).toLowerCase() === search;
                }
                else {
                    return ('' + propValue).toLowerCase().indexOf(search) >= 0;
                }
            };
        return DatagridPropertyStringFilter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {number} */
    var ClrDatagridSortOrder = {
        UNSORTED: 0,
        ASC: 1,
        DESC: -1,
    };
    ClrDatagridSortOrder[ClrDatagridSortOrder.UNSORTED] = 'UNSORTED';
    ClrDatagridSortOrder[ClrDatagridSortOrder.ASC] = 'ASC';
    ClrDatagridSortOrder[ClrDatagridSortOrder.DESC] = 'DESC';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DragDispatcher = /** @class */ (function () {
        function DragDispatcher(_ngZone, _renderer) {
            this._ngZone = _ngZone;
            this._renderer = _renderer;
            this._onDragStart = new rxjs.Subject();
            this._onDragMove = new rxjs.Subject();
            this._onDragEnd = new rxjs.Subject();
        }
        Object.defineProperty(DragDispatcher.prototype, "onDragStart", {
            get: /**
             * @return {?}
             */ function () {
                return this._onDragStart;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragDispatcher.prototype, "onDragMove", {
            get: /**
             * @return {?}
             */ function () {
                return this._onDragMove;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragDispatcher.prototype, "onDragEnd", {
            get: /**
             * @return {?}
             */ function () {
                return this._onDragEnd;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DragDispatcher.prototype.addDragListener = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var handleEl = this.handleRef.nativeElement;
                this._listeners = [
                    this.customDragEvent(handleEl, 'mousedown', 'mousemove', 'mouseup'),
                    this.customDragEvent(handleEl, 'touchstart', 'touchmove', 'touchend'),
                ];
            };
        /**
         * @param {?} element
         * @param {?} startOnEvent
         * @param {?} moveOnEvent
         * @param {?} endOnEvent
         * @return {?}
         */
        DragDispatcher.prototype.customDragEvent = /**
         * @param {?} element
         * @param {?} startOnEvent
         * @param {?} moveOnEvent
         * @param {?} endOnEvent
         * @return {?}
         */
            function (element, startOnEvent, moveOnEvent, endOnEvent) {
                var _this = this;
                /** @type {?} */
                var dragMoveListener;
                /** @type {?} */
                var dragEndListener;
                return this._renderer.listen(element, startOnEvent, function (startEvent) {
                    _this.notifyDragStart(startEvent);
                    dragMoveListener = _this._ngZone.runOutsideAngular(function () {
                        return _this._renderer.listen('document', moveOnEvent, function (moveEvent) {
                            _this.notifyDragMove(moveEvent);
                        });
                    });
                    dragEndListener = _this._renderer.listen('document', endOnEvent, function (endEvent) {
                        // Unsubscribing from mouseMoveListener
                        dragMoveListener();
                        _this.notifyDragEnd(endEvent);
                        // Unsubscribing from itself
                        dragEndListener();
                    });
                });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DragDispatcher.prototype.notifyDragStart = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                return this._onDragStart.next(event);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DragDispatcher.prototype.notifyDragMove = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                return this._onDragMove.next(event);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DragDispatcher.prototype.notifyDragEnd = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                return this._onDragEnd.next(event);
            };
        /**
         * @return {?}
         */
        DragDispatcher.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this._listeners) {
                    this._listeners.map(function (event) { return event(); });
                }
            };
        DragDispatcher.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DragDispatcher.ctorParameters = function () {
            return [
                { type: i0.NgZone },
                { type: i0.Renderer2 }
            ];
        };
        return DragDispatcher;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var Sort = /** @class */ (function () {
        function Sort(stateDebouncer) {
            this.stateDebouncer = stateDebouncer;
            /**
             * Ascending order if false, descending if true
             */
            this._reverse = false;
            /**
             * The Observable that lets other classes subscribe to sort changes
             */
            this._change = new rxjs.Subject();
        }
        Object.defineProperty(Sort.prototype, "comparator", {
            get: /**
             * @return {?}
             */ function () {
                return this._comparator;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.stateDebouncer.changeStart();
                this._comparator = value;
                this.emitChange();
                this.stateDebouncer.changeDone();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Sort.prototype, "reverse", {
            get: /**
             * @return {?}
             */ function () {
                return this._reverse;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.stateDebouncer.changeStart();
                this._reverse = value;
                this.emitChange();
                this.stateDebouncer.changeDone();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Sort.prototype.emitChange = /**
         * @return {?}
         */
            function () {
                this._change.next(this);
            };
        Object.defineProperty(Sort.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
         * optional forceReverse input parameter allows to override that toggling behavior by sorting in
         * reverse order if `true`.
         *
         * @memberof Sort
         */
        /**
         * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
         * optional forceReverse input parameter allows to override that toggling behavior by sorting in
         * reverse order if `true`.
         *
         * \@memberof Sort
         * @param {?} sortBy
         * @param {?=} forceReverse
         * @return {?}
         */
        Sort.prototype.toggle = /**
         * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
         * optional forceReverse input parameter allows to override that toggling behavior by sorting in
         * reverse order if `true`.
         *
         * \@memberof Sort
         * @param {?} sortBy
         * @param {?=} forceReverse
         * @return {?}
         */
            function (sortBy, forceReverse) {
                this.stateDebouncer.changeStart();
                // We modify private properties directly, to batch the change event
                if (this.comparator === sortBy) {
                    this._reverse = typeof forceReverse !== 'undefined' ? forceReverse || !this._reverse : !this._reverse;
                }
                else {
                    this._comparator = sortBy;
                    this._reverse = typeof forceReverse !== 'undefined' ? forceReverse : false;
                }
                this.emitChange();
                this.stateDebouncer.changeDone();
            };
        /**
         * Clears the current sorting order
         */
        /**
         * Clears the current sorting order
         * @return {?}
         */
        Sort.prototype.clear = /**
         * Clears the current sorting order
         * @return {?}
         */
            function () {
                this.comparator = null;
            };
        /**
         * Compares two objects according to the current comparator
         */
        /**
         * Compares two objects according to the current comparator
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        Sort.prototype.compare = /**
         * Compares two objects according to the current comparator
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
            function (a, b) {
                return (this.reverse ? -1 : 1) * this.comparator.compare(a, b);
            };
        Sort.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Sort.ctorParameters = function () {
            return [
                { type: StateDebouncer }
            ];
        };
        return Sort;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WrappedColumn = /** @class */ (function () {
        function WrappedColumn() {
            this._dynamic = false;
        }
        // the columns projected view (in memory)
        /**
         * @return {?}
         */
        WrappedColumn.prototype.ngAfterViewInit =
            // the columns projected view (in memory)
            /**
             * @return {?}
             */
            function () {
                // Create the cells view in memory, not the DOM.
                this.columnView = this.templateRef.createEmbeddedView(null);
            };
        WrappedColumn.decorators = [
            { type: i0.Component, args: [{
                        selector: 'dg-wrapped-column',
                        template: "        \n        <ng-template #columnPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                    }] }
        ];
        WrappedColumn.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['columnPortal',] }]
        };
        return WrappedColumn;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbCount = 0;
    /**
     * @template T
     */
    var ClrDatagridColumn = /** @class */ (function (_super) {
        __extends(ClrDatagridColumn, _super);
        function ClrDatagridColumn(_sort, filters, _dragDispatcher, vcr) {
            var _this = _super.call(this, filters) || this;
            _this._sort = _sort;
            _this._dragDispatcher = _dragDispatcher;
            _this.vcr = vcr;
            // deprecated: to be removed - START
            /**
             * Indicates if the column is currently sorted
             *
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            _this._sorted = false;
            /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            _this.sortedChange = new i0.EventEmitter();
            // deprecated: to be removed - END
            /**
             * Indicates how the column is currently sorted
             */
            _this._sortOrder = ClrDatagridSortOrder.UNSORTED;
            _this.sortOrderChange = new i0.EventEmitter();
            /**
             * A custom filter for this column that can be provided in the projected content
             */
            _this.customFilter = false;
            _this.filterValueChange = new i0.EventEmitter();
            _this._sortSubscription = _sort.change.subscribe(function (sort) {
                // We're only listening to make sure we emit an event when the column goes from sorted to unsorted
                if (_this.sortOrder !== ClrDatagridSortOrder.UNSORTED && sort.comparator !== _this._sortBy) {
                    _this._sortOrder = ClrDatagridSortOrder.UNSORTED;
                    _this.sortOrderChange.emit(_this._sortOrder);
                }
                // deprecated: to be removed - START
                if (_this.sorted && sort.comparator !== _this._sortBy) {
                    _this._sorted = false;
                    _this.sortedChange.emit(false);
                }
                // deprecated: to be removed - END
            });
            _this.columnId = 'dg-col-' + nbCount.toString(); // Approximate a GUID
            nbCount++;
            return _this;
        }
        Object.defineProperty(ClrDatagridColumn.prototype, "hidden", {
            /**
             * @property hidden
             *
             * @description
             * A property that allows the column to be hidden / shown with css
             * Note the default allows the ClrDatagridColumn to have an *ngIf on it. (EHCAIWC - will occur if its not
             * initialized)
             *
             * @default false
             *
             */
            get: /**
             * \@property hidden
             *
             * \@description
             * A property that allows the column to be hidden / shown with css
             * Note the default allows the ClrDatagridColumn to have an *ngIf on it. (EHCAIWC - will occur if its not
             * initialized)
             *
             * \@default false
             *
             * @return {?}
             */ function () {
                return !!this.hideable && this.hideable.hidden;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "handleElRef", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._dragDispatcher.handleRef = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "handleTrackerElRef", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._dragDispatcher.handleTrackerRef = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridColumn.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._sortSubscription.unsubscribe();
            };
        Object.defineProperty(ClrDatagridColumn.prototype, "field", {
            get: /**
             * @return {?}
             */ function () {
                return this._field;
            },
            set: /**
             * @param {?} field
             * @return {?}
             */ function (field) {
                if (typeof field === 'string') {
                    this._field = field;
                    if (!this.customFilter) {
                        this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
                    }
                    if (!this._sortBy) {
                        this._sortBy = new DatagridPropertyComparator(field);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortBy", {
            get: /**
             * @return {?}
             */ function () {
                return this._sortBy;
            },
            set: /**
             * @param {?} comparator
             * @return {?}
             */ function (comparator) {
                if (typeof comparator === 'string') {
                    this._sortBy = new DatagridPropertyComparator(comparator);
                }
                else {
                    if (comparator) {
                        this._sortBy = comparator;
                    }
                    else {
                        if (this._field) {
                            this._sortBy = new DatagridPropertyComparator(this._field);
                        }
                        else {
                            delete this._sortBy;
                        }
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortable", {
            /**
             * Indicates if the column is sortable
             */
            get: /**
             * Indicates if the column is sortable
             * @return {?}
             */ function () {
                return !!this._sortBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sorted", {
            get: /**
             * @return {?}
             */ function () {
                return this._sorted;
            },
            /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             */
            set: /**
             * @deprecated This will be removed soon, in favor of the sortOrder mechanism
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!value && this.sorted) {
                    this._sorted = false;
                    this._sort.clear();
                }
                else if (value && !this.sorted) {
                    this.sort();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "sortOrder", {
            get: /**
             * @return {?}
             */ function () {
                return this._sortOrder;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (typeof value === 'undefined') {
                    return;
                }
                // only if the incoming order is different from the current one
                if (this._sortOrder === value) {
                    return;
                }
                switch (value) {
                    // the Unsorted case happens when the current state is either Asc or Desc
                    default:
                    case ClrDatagridSortOrder.UNSORTED:
                        this._sort.clear();
                        break;
                    case ClrDatagridSortOrder.ASC:
                        this.sort(false);
                        break;
                    case ClrDatagridSortOrder.DESC:
                        this.sort(true);
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "ariaSort", {
            get: /**
             * @return {?}
             */ function () {
                switch (this._sortOrder) {
                    default:
                    case ClrDatagridSortOrder.UNSORTED:
                        return 'none';
                    case ClrDatagridSortOrder.ASC:
                        return 'ascending';
                    case ClrDatagridSortOrder.DESC:
                        return 'descending';
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sorts the datagrid based on this column
         */
        /**
         * Sorts the datagrid based on this column
         * @param {?=} reverse
         * @return {?}
         */
        ClrDatagridColumn.prototype.sort = /**
         * Sorts the datagrid based on this column
         * @param {?=} reverse
         * @return {?}
         */
            function (reverse) {
                if (!this.sortable) {
                    return;
                }
                this._sort.toggle(this._sortBy, reverse);
                // setting the private variable to not retrigger the setter logic
                this._sortOrder = this._sort.reverse ? ClrDatagridSortOrder.DESC : ClrDatagridSortOrder.ASC;
                this.sortOrderChange.emit(this._sortOrder);
                // deprecated: to be removed - START
                this._sorted = true;
                this.sortedChange.emit(true);
                // deprecated: to be removed - END
            };
        Object.defineProperty(ClrDatagridColumn.prototype, "asc", {
            /**
             * Indicates if the column is currently sorted in ascending order
             */
            get: /**
             * Indicates if the column is currently sorted in ascending order
             * @return {?}
             */ function () {
                // deprecated: if condition to be removed - START
                if (typeof this.sortOrder === 'undefined') {
                    return this.sorted && !this._sort.reverse;
                }
                else {
                    return this.sortOrder === ClrDatagridSortOrder.ASC;
                }
                // deprecated: if condition to be removed - END
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "desc", {
            /**
             * Indicates if the column is currently sorted in descending order
             */
            get: /**
             * Indicates if the column is currently sorted in descending order
             * @return {?}
             */ function () {
                // deprecated: if condition to be removed - START
                if (typeof this.sortOrder === 'undefined') {
                    return this.sorted && this._sort.reverse;
                }
                else {
                    return this.sortOrder === ClrDatagridSortOrder.DESC;
                }
                // deprecated: if condition to be removed - END
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "projectedFilter", {
            set: /**
             * @param {?} custom
             * @return {?}
             */ function (custom) {
                if (custom) {
                    this.deleteFilter();
                    this.customFilter = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "filterValue", {
            get: /**
             * @return {?}
             */ function () {
                return this.filter.value;
            },
            set: /**
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                this.updateFilterValue = newValue;
                this.filterValueChange.emit(this.filter.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridColumn.prototype, "updateFilterValue", {
            set: /**
             * @param {?} newValue
             * @return {?}
             */ function (newValue) {
                if (!this.filter) {
                    return;
                }
                if (!newValue) {
                    newValue = '';
                }
                if (newValue !== this.filter.value) {
                    this.filter.value = newValue;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridColumn.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.wrappedInjector = new HostWrapper(WrappedColumn, this.vcr);
            };
        Object.defineProperty(ClrDatagridColumn.prototype, "_view", {
            get: /**
             * @return {?}
             */ function () {
                return this.wrappedInjector.get(WrappedColumn, this.vcr).columnView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridColumn.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column',
                        template: "\n        <div class=\"datagrid-column-flex\">\n            <!-- I'm really not happy with that select since it's not very scalable -->\n            <ng-content select=\"clr-dg-filter, clr-dg-string-filter\"></ng-content>\n\n            <clr-dg-string-filter\n                    *ngIf=\"field && !customFilter\"\n                    [clrDgStringFilter]=\"registered\"\n                    [(clrFilterValue)]=\"filterValue\"></clr-dg-string-filter>\n\n            <ng-template #columnTitle>\n                <ng-content></ng-content>\n            </ng-template>\n\n            <button class=\"datagrid-column-title\" *ngIf=\"sortable\" (click)=\"sort()\" type=\"button\">\n                <ng-container *ngTemplateOutlet=\"columnTitle\"></ng-container>\n            </button>\n\n            <span class=\"datagrid-column-title\" *ngIf=\"!sortable\">\n               <ng-container *ngTemplateOutlet=\"columnTitle\"></ng-container>\n            </span>\n\n            <div class=\"datagrid-column-separator\">\n                <button #columnHandle class=\"datagrid-column-handle\" tabindex=\"-1\" type=\"button\"></button>\n                <div #columnHandleTracker class=\"datagrid-column-handle-tracker\"></div>\n            </div>\n        </div>\n    ",
                        host: {
                            '[class.datagrid-column]': 'true',
                            '[class.datagrid-column--hidden]': 'hidden',
                            '[attr.aria-sort]': 'ariaSort',
                            role: 'columnheader',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridColumn.ctorParameters = function () {
            return [
                { type: Sort },
                { type: FiltersProvider },
                { type: DragDispatcher },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrDatagridColumn.propDecorators = {
            handleElRef: [{ type: i0.ViewChild, args: ['columnHandle',] }],
            handleTrackerElRef: [{ type: i0.ViewChild, args: ['columnHandleTracker',] }],
            field: [{ type: i0.Input, args: ['clrDgField',] }],
            sortBy: [{ type: i0.Input, args: ['clrDgSortBy',] }],
            sorted: [{ type: i0.Input, args: ['clrDgSorted',] }],
            sortedChange: [{ type: i0.Output, args: ['clrDgSortedChange',] }],
            sortOrder: [{ type: i0.Input, args: ['clrDgSortOrder',] }],
            sortOrderChange: [{ type: i0.Output, args: ['clrDgSortOrderChange',] }],
            asc: [{ type: i0.HostBinding, args: ['class.asc',] }],
            desc: [{ type: i0.HostBinding, args: ['class.desc',] }],
            projectedFilter: [{ type: i0.ContentChild, args: [CustomFilter,] }],
            updateFilterValue: [{ type: i0.Input, args: ['clrFilterValue',] }],
            filterValueChange: [{ type: i0.Output, args: ['clrFilterValueChange',] }]
        };
        return ClrDatagridColumn;
    }(DatagridFilterRegistrar));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var Items = /** @class */ (function () {
        function Items(_filters, _sort, _page) {
            this._filters = _filters;
            this._sort = _sort;
            this._page = _page;
            /**
             * Indicates if the data is currently loading
             */
            this.loading = false;
            // TODO: Verify that trackBy is registered for the *ngFor case too
            /**
             * Tracking function to identify objects. Default is reference equality.
             */
            this.trackBy = function (index, item) { return item; };
            /**
             * Whether we should use smart items for this datagrid or let the user handle
             * everything.
             */
            this._smart = false;
            /**
             * List of items currently displayed
             */
            this._displayed = [];
            /**
             * The Observable that lets other classes subscribe to items changes
             */
            this._change = new rxjs.Subject();
            this._allChanges = new rxjs.Subject();
        }
        /**
         * Cleans up our subscriptions to other providers
         */
        /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
        Items.prototype.destroy = /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
            function () {
                if (this._filtersSub) {
                    this._filtersSub.unsubscribe();
                }
                if (this._sortSub) {
                    this._sortSub.unsubscribe();
                }
                if (this._pageSub) {
                    this._pageSub.unsubscribe();
                }
            };
        Object.defineProperty(Items.prototype, "smart", {
            get: /**
             * @return {?}
             */ function () {
                return this._smart;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Items.prototype.smartenUp = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._smart = true;
                /*
                     * These observers trigger a chain of function: filter -> sort -> paginate
                     * An observer up the chain re-triggers all the operations that follow it.
                     */
                this._filtersSub = this._filters.change.subscribe(function () { return _this._filterItems(); });
                this._sortSub = this._sort.change.subscribe(function () {
                    // Special case, if the datagrid went from sorted to unsorted, we have to re-filter
                    // to get the original order back
                    if (!_this._sort.comparator) {
                        _this._filterItems();
                    }
                    else {
                        _this._sortItems();
                    }
                });
                this._pageSub = this._page.change.subscribe(function () { return _this._changePage(); });
            };
        Object.defineProperty(Items.prototype, "all", {
            get: /**
             * @return {?}
             */ function () {
                return this._all;
            },
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._all = items;
                this.emitAllChanges(items);
                if (this.smart) {
                    this._filterItems();
                }
                else {
                    this._displayed = items;
                    this.emitChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Manually recompute the list of displayed items
         */
        /**
         * Manually recompute the list of displayed items
         * @return {?}
         */
        Items.prototype.refresh = /**
         * Manually recompute the list of displayed items
         * @return {?}
         */
            function () {
                if (this.smart) {
                    this._filterItems();
                }
            };
        Object.defineProperty(Items.prototype, "displayed", {
            get: /**
             * @return {?}
             */ function () {
                // Ideally we could return an immutable array, but we don't have it in Clarity yet.
                return this._displayed;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        Items.prototype.emitChange = /**
         * @return {?}
         */
            function () {
                this._change.next(this.displayed);
            };
        Object.defineProperty(Items.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} items
         * @return {?}
         */
        Items.prototype.emitAllChanges = /**
         * @param {?} items
         * @return {?}
         */
            function (items) {
                this._allChanges.next(items);
            };
        Object.defineProperty(Items.prototype, "allChanges", {
            get: /**
             * @return {?}
             */ function () {
                return this._allChanges.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Items.prototype, "uninitialized", {
            /**
             * Checks if we don't have data to process yet, to abort early operations
             */
            get: /**
             * Checks if we don't have data to process yet, to abort early operations
             * @return {?}
             */ function () {
                return !this._all;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * FiltersProvider items from the raw list
         */
        /**
         * FiltersProvider items from the raw list
         * @return {?}
         */
        Items.prototype._filterItems = /**
         * FiltersProvider items from the raw list
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.uninitialized) {
                    return;
                }
                if (this._filters.hasActiveFilters()) {
                    this._filtered = this._all.filter(function (item) { return _this._filters.accepts(item); });
                }
                else {
                    // Work on a shallow copy of the array, to not modify the user's model
                    this._filtered = this._all.slice();
                }
                this._page.totalItems = this._filtered.length;
                this._sortItems();
            };
        /**
         * Sorts items in the filtered list
         */
        /**
         * Sorts items in the filtered list
         * @return {?}
         */
        Items.prototype._sortItems = /**
         * Sorts items in the filtered list
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.uninitialized) {
                    return;
                }
                if (this._sort.comparator) {
                    this._filtered.sort(function (a, b) { return _this._sort.compare(a, b); });
                }
                this._changePage();
            };
        /**
         * Extracts the current page from the sorted list
         */
        /**
         * Extracts the current page from the sorted list
         * @return {?}
         */
        Items.prototype._changePage = /**
         * Extracts the current page from the sorted list
         * @return {?}
         */
            function () {
                if (this.uninitialized) {
                    return;
                }
                if (this._page.size > 0) {
                    this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
                }
                else {
                    this._displayed = this._filtered;
                }
                this.emitChange();
            };
        Items.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Items.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: Sort },
                { type: Page }
            ];
        };
        return Items;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridItems = /** @class */ (function () {
        function ClrDatagridItems(template, differs, items, vcr) {
            var _this = this;
            this.template = template;
            this.differs = differs;
            this.items = items;
            this.vcr = vcr;
            this.differ = null;
            this.subscriptions = [];
            items.smartenUp();
            this.iterableProxy = new common.NgForOf(this.vcr, this.template, this.differs);
            this.subscriptions.push(items.change.subscribe(function (newItems) {
                _this.iterableProxy.ngForOf = newItems;
                _this.iterableProxy.ngDoCheck();
            }));
        }
        Object.defineProperty(ClrDatagridItems.prototype, "rawItems", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._rawItems = items ? items : []; // local copy for ngOnChange diffing
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridItems.prototype, "trackBy", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.iterableProxy.ngForTrackBy = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridItems.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (!this.differ) {
                    this.differ = this.differs.find(this._rawItems).create(this.iterableProxy.ngForTrackBy);
                }
                if (this.differ) {
                    /** @type {?} */
                    var changes = this.differ.diff(this._rawItems);
                    if (changes) {
                        // TODO: not very efficient right now,
                        // but premature optimization is the root of all evil.
                        this.items.all = this._rawItems;
                    }
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridItems.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDatagridItems.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDgItems][clrDgItemsOf]',
                    },] }
        ];
        /** @nocollapse */
        ClrDatagridItems.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.IterableDiffers },
                { type: Items },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrDatagridItems.propDecorators = {
            rawItems: [{ type: i0.Input, args: ['clrDgItemsOf',] }],
            trackBy: [{ type: i0.Input, args: ['clrDgItemsTrackBy',] }]
        };
        return ClrDatagridItems;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridPlaceholder = /** @class */ (function () {
        function ClrDatagridPlaceholder(items) {
            this.items = items;
        }
        Object.defineProperty(ClrDatagridPlaceholder.prototype, "emptyDatagrid", {
            /**
             * Tests if the datagrid is empty, meaning it doesn't contain any items
             */
            get: /**
             * Tests if the datagrid is empty, meaning it doesn't contain any items
             * @return {?}
             */ function () {
                return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridPlaceholder.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-placeholder',
                        template: "\n        <div\n            class=\"datagrid-placeholder\"\n            [class.datagrid-empty]=\"emptyDatagrid\">\n                <div class=\"datagrid-placeholder-image\" *ngIf=\"emptyDatagrid\"></div>\n                <ng-content *ngIf=\"emptyDatagrid\"></ng-content>\n        </div>\n    ",
                        host: { '[class.datagrid-placeholder-container]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridPlaceholder.ctorParameters = function () {
            return [
                { type: Items }
            ];
        };
        return ClrDatagridPlaceholder;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var POPOVER_HOST_ANCHOR = new i0.InjectionToken('POPOVER_HOST_ANCHOR');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSignpostTrigger = /** @class */ (function () {
        function ClrSignpostTrigger(ifOpenService, renderer, el) {
            var _this = this;
            this.ifOpenService = ifOpenService;
            this.renderer = renderer;
            this.el = el;
            this.subscriptions = [];
            this.subscriptions.push(this.ifOpenService.openChange.subscribe(function (isOpen) {
                if (isOpen) {
                    _this.renderer.addClass(_this.el.nativeElement, 'active');
                }
                else {
                    _this.renderer.removeClass(_this.el.nativeElement, 'active');
                }
            }));
        }
        /**
         * @return {?}
         */
        ClrSignpostTrigger.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**********
         *
         * @description
         * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
         */
        /**
         * *******
         *
         * \@description
         * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
         * @param {?} event
         * @return {?}
         */
        ClrSignpostTrigger.prototype.onSignpostTriggerClick = /**
         * *******
         *
         * \@description
         * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.ifOpenService.toggleWithEvent(event);
            };
        ClrSignpostTrigger.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrSignpostTrigger]', host: { class: 'signpost-trigger' } },] }
        ];
        /** @nocollapse */
        ClrSignpostTrigger.ctorParameters = function () {
            return [
                { type: IfOpenService },
                { type: i0.Renderer2 },
                { type: i0.ElementRef }
            ];
        };
        ClrSignpostTrigger.propDecorators = {
            onSignpostTriggerClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
        };
        return ClrSignpostTrigger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrSignpost = /** @class */ (function () {
        function ClrSignpost(commonStrings) {
            this.commonStrings = commonStrings;
            /**
             * *******
             * \@property useCustomTrigger
             *
             * \@description
             * Flag used to determine if we need to use the default trigger or a user supplied trigger element.
             *
             */
            this.useCustomTrigger = false;
        }
        Object.defineProperty(ClrSignpost.prototype, "customTrigger", {
            /**********
             * @property signPostTrigger
             *
             * @description
             * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
             *
             */
            set: /**
             * *******
             * \@property signPostTrigger
             *
             * \@description
             * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
             *
             * @param {?} trigger
             * @return {?}
             */ function (trigger) {
                this.useCustomTrigger = !!trigger;
            },
            enumerable: true,
            configurable: true
        });
        ClrSignpost.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-signpost',
                        template: "\n        <ng-container *ngIf=\"!useCustomTrigger\">\n            <button\n                type=\"button\"\n                class=\"signpost-action btn btn-small btn-link\"\n                clrSignpostTrigger>\n                <clr-icon shape=\"info\" [attr.title]=\"commonStrings.info\"></clr-icon>\n            </button>\n        </ng-container>\n        \n        <ng-content></ng-content>\n    ",
                        host: { '[class.signpost]': 'true' },
                        providers: [IfOpenService, { provide: POPOVER_HOST_ANCHOR, useExisting: i0.ElementRef }]
                    }] }
        ];
        /** @nocollapse */
        ClrSignpost.ctorParameters = function () {
            return [
                { type: ClrCommonStrings }
            ];
        };
        ClrSignpost.propDecorators = {
            customTrigger: [{ type: i0.ContentChild, args: [ClrSignpostTrigger,] }]
        };
        return ClrSignpost;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * \@description
     * An \@Injectable provider class that enables
     *
     * 1. Managing, track hideability of DatagridColumns
     *
     */
    var HideableColumnService = /** @class */ (function () {
        function HideableColumnService() {
            /**
             * *******
             * \@property dgHiddenColumnMap
             *
             * \@description
             * An array of DatagridHideableColumn.
             * NOTE: because we can have columns w/o the *clrDgHideableColumn directive
             * this array will have empty spaces a.k.a nulls. This is needed to be able to map
             * DatagridCells to DatagridColumns in the RowRenderer.
             *
             */
            this._columnList = [];
            /**
             * *******
             *
             * \@property dgHiddenColumnMapChange
             *
             * \@description
             * A behavior subject that can broadcast updates to the column list.
             * NOTE: I am using BehaviorSubject because <clr-dg-column-toggle> is not getting the latest _columnListChange
             * on page load.
             *
             */
            this._columnListChange = new rxjs.BehaviorSubject(this._columnList);
        }
        Object.defineProperty(HideableColumnService.prototype, "canHideNextColumn", {
            /**********
             *
             * @property canHideNextColumn
             *
             * @description
             * Service function that is called by clr-dg-column-toggle component. Use this if you need to ask if you can hide
             * a column. It acts as a guard against hiding all the columns making sure there is at least one column displayed.
             *
             */
            get: /**
             * *******
             *
             * \@property canHideNextColumn
             *
             * \@description
             * Service function that is called by clr-dg-column-toggle component. Use this if you need to ask if you can hide
             * a column. It acts as a guard against hiding all the columns making sure there is at least one column displayed.
             *
             * @return {?}
             */ function () {
                /** @type {?} */
                var hiddenColumns = this._columnList.filter(function (column) { return column !== undefined; }).filter(function (column) { return column.hidden; });
                return this._columnList.length - hiddenColumns.length > 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HideableColumnService.prototype, "checkForAllColumnsVisible", {
            /**********
             *
             * @property checkForAllColumnsVisible
             *
             * @description
             * For when you need to know if the datagrid's columns are all showing.
             *
             */
            get: /**
             * *******
             *
             * \@property checkForAllColumnsVisible
             *
             * \@description
             * For when you need to know if the datagrid's columns are all showing.
             *
             * @return {?}
             */ function () {
                return !this._columnList.some(function (column) { return column && column.hidden; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HideableColumnService.prototype, "columnListChange", {
            /***********
             * @property columnListChange
             *
             * @description
             * A public property that enables subscribers to hear updates to the column map.
             * Use this if you need to do something whenever the Datagrid's column list is changed (i.e *ngIf on a column).
             *
             */
            get: /**
             * ********
             * \@property columnListChange
             *
             * \@description
             * A public property that enables subscribers to hear updates to the column map.
             * Use this if you need to do something whenever the Datagrid's column list is changed (i.e *ngIf on a column).
             *
             * @return {?}
             */ function () {
                return this._columnListChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**********
         *
         * @description
         * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
         * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
         *
         */
        /**
         * *******
         *
         * \@description
         * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
         * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
         *
         * @return {?}
         */
        HideableColumnService.prototype.getColumns = /**
         * *******
         *
         * \@description
         * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
         * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
         *
         * @return {?}
         */
            function () {
                return this._columnList;
            };
        /**********
         *
         * @description
         * Iterate through the current _columnList:
         * - if it has a DatagridHideableColumn and is hidden then show it.
         * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
         *
         */
        /**
         * *******
         *
         * \@description
         * Iterate through the current _columnList:
         * - if it has a DatagridHideableColumn and is hidden then show it.
         * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
         *
         * @return {?}
         */
        HideableColumnService.prototype.showHiddenColumns = /**
         * *******
         *
         * \@description
         * Iterate through the current _columnList:
         * - if it has a DatagridHideableColumn and is hidden then show it.
         * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
         *
         * @return {?}
         */
            function () {
                this._columnList.forEach(function (column) {
                    if (column && column.hidden === true) {
                        column.hidden = false;
                    }
                    if (column && column.lastVisibleColumn) {
                        column.lastVisibleColumn = false;
                    }
                });
            };
        /**
         *
         * @param columns: DatagridColumn[]
         *
         * @description
         * Creates an array of DatagridHideableColumn's || null based column array passed as param.
         * Is dependent on the order in @ContentChildren in Datagrid.
         *
         */
        /**
         *
         * \@description
         * Creates an array of DatagridHideableColumn's || null based column array passed as param.
         * Is dependent on the order in \@ContentChildren in Datagrid.
         *
         * @param {?} columns
         * @return {?}
         */
        HideableColumnService.prototype.updateColumnList = /**
         *
         * \@description
         * Creates an array of DatagridHideableColumn's || null based column array passed as param.
         * Is dependent on the order in \@ContentChildren in Datagrid.
         *
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                this._columnList = columns; // clear the list
                this.updateForLastVisibleColumn(); // Update our visibility state for UI
                this._columnListChange.next(this._columnList); // Broadcast it
            };
        /**********
         *
         * @description
         * Gets the current visible count for all columns.
         * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
         * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
         * lastVisibleColumn.
         *
         */
        /**
         * *******
         *
         * \@description
         * Gets the current visible count for all columns.
         * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
         * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
         * lastVisibleColumn.
         *
         * @return {?}
         */
        HideableColumnService.prototype.updateForLastVisibleColumn = /**
         * *******
         *
         * \@description
         * Gets the current visible count for all columns.
         * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
         * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
         * lastVisibleColumn.
         *
         * @return {?}
         */
            function () {
                // There is more than one column showing, make sure nothing is marked lastVisibleColumn
                if (this.canHideNextColumn) {
                    this._columnList.map(function (column) {
                        if (column && column.lastVisibleColumn) {
                            column.lastVisibleColumn = false;
                        }
                    });
                }
                else {
                    // The visibleCount is down to only one column showing. Find it and flag it as the lastVisibleColumn
                    this._columnList.map(function (column) {
                        if (column && !column.hidden) {
                            column.lastVisibleColumn = true;
                        }
                    });
                }
            };
        /**********
         *
         * @description
         * Return a HideableColumn in this._columnList for the given id.
         *
         *
         */
        /**
         * *******
         *
         * \@description
         * Return a HideableColumn in this._columnList for the given id.
         *
         *
         * @param {?} id
         * @return {?}
         */
        HideableColumnService.prototype.getColumnById = /**
         * *******
         *
         * \@description
         * Return a HideableColumn in this._columnList for the given id.
         *
         *
         * @param {?} id
         * @return {?}
         */
            function (id) {
                if (id) {
                    return this._columnList.find(function (column) { return column && column.id === id; });
                }
                return;
            };
        HideableColumnService.decorators = [
            { type: i0.Injectable }
        ];
        return HideableColumnService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WrappedCell = /** @class */ (function () {
        function WrappedCell() {
            this._dynamic = false;
        }
        // the cells projected view
        /**
         * @return {?}
         */
        WrappedCell.prototype.ngAfterViewInit =
            // the cells projected view
            /**
             * @return {?}
             */
            function () {
                this.cellView = this.templateRef.createEmbeddedView(null);
            };
        WrappedCell.decorators = [
            { type: i0.Component, args: [{
                        selector: 'dg-wrapped-cell',
                        template: "        \n        <ng-template #cellPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                    }] }
        ];
        WrappedCell.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['cellPortal',] }]
        };
        return WrappedCell;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridCell = /** @class */ (function () {
        function ClrDatagridCell(hideableColumnService, _el, _renderer, vcr) {
            this.hideableColumnService = hideableColumnService;
            this._el = _el;
            this._renderer = _renderer;
            this.vcr = vcr;
        }
        Object.defineProperty(ClrDatagridCell.prototype, "id", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._id = value;
                this.mapHideableColumn(this._id);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} columnId
         * @return {?}
         */
        ClrDatagridCell.prototype.mapHideableColumn = /**
         * @param {?} columnId
         * @return {?}
         */
            function (columnId) {
                var _this = this;
                if (!columnId) {
                    return;
                }
                /** @type {?} */
                var hideableColumn = this.hideableColumnService.getColumnById(this._id);
                this.setHiddenClass(hideableColumn.hidden);
                this.hiddenStateSubscription = hideableColumn.hiddenChangeState.subscribe(function () {
                    _this.setHiddenClass(hideableColumn.hidden);
                });
            };
        /**
         * @param {?} hideableColumnValue
         * @return {?}
         */
        ClrDatagridCell.prototype.setHiddenClass = /**
         * @param {?} hideableColumnValue
         * @return {?}
         */
            function (hideableColumnValue) {
                if (hideableColumnValue) {
                    this._renderer.addClass(this._el.nativeElement, 'datagrid-cell--hidden');
                }
                else {
                    this._renderer.removeClass(this._el.nativeElement, 'datagrid-cell--hidden');
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridCell.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.wrappedInjector = new HostWrapper(WrappedCell, this.vcr);
            };
        /**
         * @return {?}
         */
        ClrDatagridCell.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.hiddenStateSubscription) {
                    this.hiddenStateSubscription.unsubscribe();
                }
            };
        Object.defineProperty(ClrDatagridCell.prototype, "_view", {
            get: /**
             * @return {?}
             */ function () {
                return this.wrappedInjector.get(WrappedCell, this.vcr).cellView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridCell.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-cell',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.datagrid-cell]': 'true',
                            '[class.datagrid-signpost-trigger]': 'signpost.length > 0',
                            role: 'cell',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridCell.ctorParameters = function () {
            return [
                { type: HideableColumnService },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: i0.ViewContainerRef }
            ];
        };
        ClrDatagridCell.propDecorators = {
            signpost: [{ type: i0.ContentChildren, args: [ClrSignpost,] }]
        };
        return ClrDatagridCell;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {number} */
    var DatagridDisplayMode = {
        DISPLAY: 0,
        CALCULATE: 1,
    };
    DatagridDisplayMode[DatagridDisplayMode.DISPLAY] = 'DISPLAY';
    DatagridDisplayMode[DatagridDisplayMode.CALCULATE] = 'CALCULATE';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /** @enum {number} */
    var DatagridRenderStep = {
        ALIGN_COLUMNS: 0,
        CALCULATE_MODE_ON: 1,
        CALCULATE_MODE_OFF: 2,
        CLEAR_WIDTHS: 3,
        COMPUTE_COLUMN_WIDTHS: 4,
        DETECT_STRICT_WIDTHS: 5,
        UPDATE_ROW_WIDTH: 6,
    };
    DatagridRenderStep[DatagridRenderStep.ALIGN_COLUMNS] = 'ALIGN_COLUMNS';
    DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_ON] = 'CALCULATE_MODE_ON';
    DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_OFF] = 'CALCULATE_MODE_OFF';
    DatagridRenderStep[DatagridRenderStep.CLEAR_WIDTHS] = 'CLEAR_WIDTHS';
    DatagridRenderStep[DatagridRenderStep.COMPUTE_COLUMN_WIDTHS] = 'COMPUTE_COLUMN_WIDTHS';
    DatagridRenderStep[DatagridRenderStep.DETECT_STRICT_WIDTHS] = 'DETECT_STRICT_WIDTHS';
    DatagridRenderStep[DatagridRenderStep.UPDATE_ROW_WIDTH] = 'UPDATE_ROW_WIDTH';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridRenderOrganizer = /** @class */ (function () {
        function DatagridRenderOrganizer() {
            this._renderStep = new rxjs.Subject();
            this.alreadySized = false;
            this.widths = [];
        }
        Object.defineProperty(DatagridRenderOrganizer.prototype, "renderStep", {
            get: /**
             * @return {?}
             */ function () {
                return this._renderStep.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} step
         * @return {?}
         */
        DatagridRenderOrganizer.prototype.filterRenderSteps = /**
         * @param {?} step
         * @return {?}
         */
            function (step) {
                return this.renderStep.pipe(operators.filter(function (testStep) { return step === testStep; }));
            };
        /**
         * @return {?}
         */
        DatagridRenderOrganizer.prototype.resize = /**
         * @return {?}
         */
            function () {
                this.widths.length = 0;
                this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_ON);
                if (this.alreadySized) {
                    this._renderStep.next(DatagridRenderStep.CLEAR_WIDTHS);
                }
                this._renderStep.next(DatagridRenderStep.DETECT_STRICT_WIDTHS);
                this._renderStep.next(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS);
                this._renderStep.next(DatagridRenderStep.ALIGN_COLUMNS);
                this.alreadySized = true;
                this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_OFF);
                this._renderStep.next(DatagridRenderStep.UPDATE_ROW_WIDTH);
            };
        DatagridRenderOrganizer.decorators = [
            { type: i0.Injectable }
        ];
        return DatagridRenderOrganizer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DisplayModeService = /** @class */ (function () {
        function DisplayModeService(renderOrganizer) {
            var _this = this;
            this.subscriptions = [];
            this._view = new rxjs.BehaviorSubject(DatagridDisplayMode.DISPLAY);
            this.subscriptions.push(renderOrganizer
                .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_ON)
                .subscribe(function () { return _this._view.next(DatagridDisplayMode.CALCULATE); }));
            this.subscriptions.push(renderOrganizer
                .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_OFF)
                .subscribe(function () { return _this._view.next(DatagridDisplayMode.DISPLAY); }));
        }
        Object.defineProperty(DisplayModeService.prototype, "view", {
            get: /**
             * @return {?}
             */ function () {
                return this._view.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DisplayModeService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        DisplayModeService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DisplayModeService.ctorParameters = function () {
            return [
                { type: DatagridRenderOrganizer }
            ];
        };
        return DisplayModeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbSelection = 0;
    /** @enum {number} */
    var SelectionType = {
        None: 0,
        Single: 1,
        Multi: 2,
    };
    SelectionType[SelectionType.None] = 'None';
    SelectionType[SelectionType.Single] = 'Single';
    SelectionType[SelectionType.Multi] = 'Multi';
    /**
     * @template T
     */
    var Selection = /** @class */ (function () {
        function Selection(_items, _filters) {
            var _this = this;
            this._items = _items;
            this._filters = _filters;
            this.prevSelectionRefs = []; // Refs of selected items
            this._selectionType = SelectionType.None;
            this.rowSelectionMode = false;
            /**
             * Ignore items changes in the same change detection cycle.
             */
            // tslint:disable-next-line
            this.debounce = false;
            /**
             * Subscriptions to the other providers changes.
             */
            this.subscriptions = [];
            /**
             * The Observable that lets other classes subscribe to selection changes
             */
            this._change = new rxjs.Subject();
            this.id = 'clr-dg-selection' + nbSelection++;
            this.subscriptions.push(this._filters.change.subscribe(function () {
                if (!_this._selectable) {
                    return;
                }
                _this.clearSelection();
            }));
            this.subscriptions.push(this._items.allChanges.subscribe(function (updatedItems) {
                switch (_this.selectionType) {
                    case SelectionType.None: {
                        break;
                    }
                    case SelectionType.Single: {
                        /** @type {?} */
                        var newSingle_1;
                        /** @type {?} */
                        var trackBy_1 = _this._items.trackBy;
                        /** @type {?} */
                        var selectionUpdated_1 = false;
                        // if the currentSingle has been set before data was loaded, we look up and save the ref from current data set
                        if (_this.currentSingle && !_this.prevSingleSelectionRef) {
                            if (_this._items.all && _this._items.trackBy) {
                                /** @type {?} */
                                var lookup = _this._items.all.findIndex(function (maybe) { return maybe === _this.currentSingle; });
                                _this.prevSingleSelectionRef = _this._items.trackBy(lookup, _this.currentSingle);
                            }
                        }
                        updatedItems.forEach(function (item, index) {
                            /** @type {?} */
                            var ref = trackBy_1(index, item);
                            // If one of the updated items is the previously selectedSingle, set it as the new one
                            if (_this.prevSingleSelectionRef === ref) {
                                newSingle_1 = item;
                                selectionUpdated_1 = true;
                            }
                        });
                        // If we're using smart datagrids, we expect all items to be present in the updatedItems array.
                        // Therefore, we should delete the currentSingle if it used to be defined but doesn't exist anymore.
                        // No explicit "delete" is required, since newSingle would be undefined at this point.
                        // Marking it as selectionUpdated here will set currentSingle to undefined below in the setTimeout.
                        if (_this._items.smart && !newSingle_1) {
                            selectionUpdated_1 = true;
                        }
                        // TODO: Discussed this with Eudes and this is fine for now.
                        // But we need to figure out a different pattern for the
                        // child triggering the parent change detection problem.
                        // Using setTimeout for now to fix this.
                        setTimeout(function () {
                            if (selectionUpdated_1) {
                                _this.currentSingle = newSingle_1;
                            }
                        }, 0);
                        break;
                    }
                    case SelectionType.Multi: {
                        /** @type {?} */
                        var leftOver_1 = _this.current.slice();
                        /** @type {?} */
                        var trackBy_2 = _this._items.trackBy;
                        /** @type {?} */
                        var selectionUpdated_2 = false;
                        // if the current has been set before data was loaded, we look up and save the ref from current data set
                        if (_this.current.length > 0 && _this.prevSelectionRefs.length !== _this.current.length) {
                            if (_this._items.all && _this._items.trackBy) {
                                _this.prevSelectionRefs = [];
                                _this.current.forEach(function (item) {
                                    /** @type {?} */
                                    var lookup = _this._items.all.findIndex(function (maybe) { return maybe === item; });
                                    _this.prevSelectionRefs.push(_this._items.trackBy(lookup, item));
                                });
                            }
                        }
                        // TODO: revisit this when we work on https://github.com/vmware/clarity/issues/2342
                        // currently, the selection is cleared when filter is applied, so the logic inside
                        // the if statement below results in broken behavior.
                        if (leftOver_1.length > 0) {
                            updatedItems.forEach(function (item, index) {
                                /** @type {?} */
                                var ref = trackBy_2(index, item);
                                // Look in current selected refs array if item is selected, and update actual value
                                /** @type {?} */
                                var selectedIndex = _this.prevSelectionRefs.indexOf(ref);
                                if (selectedIndex > -1) {
                                    leftOver_1[selectedIndex] = item;
                                    selectionUpdated_2 = true;
                                }
                            });
                            // Filter out any unmatched items if we're using smart datagrids where we expect all items to be
                            // present
                            if (_this._items.smart) {
                                leftOver_1 = leftOver_1.filter(function (selected) { return updatedItems.indexOf(selected) > -1; });
                                if (_this.current.length !== leftOver_1.length) {
                                    selectionUpdated_2 = true;
                                }
                            }
                            // TODO: Discussed this with Eudes and this is fine for now.
                            // But we need to figure out a different pattern for the
                            // child triggering the parent change detection problem.
                            // Using setTimeout for now to fix this.
                            setTimeout(function () {
                                if (selectionUpdated_2) {
                                    _this.current = leftOver_1;
                                }
                            }, 0);
                        }
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }));
        }
        /**
         * @return {?}
         */
        Selection.prototype.clearSelection = /**
         * @return {?}
         */
            function () {
                this.current.length = 0;
                this.prevSelectionRefs = [];
                this.emitChange();
            };
        Object.defineProperty(Selection.prototype, "selectionType", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectionType;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === this.selectionType) {
                    return;
                }
                this._selectionType = value;
                if (value === SelectionType.None) {
                    delete this.current;
                }
                else {
                    this.updateCurrent([], false);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "_selectable", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectionType === SelectionType.Multi || this._selectionType === SelectionType.Single;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Cleans up our subscriptions to other providers
         */
        /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
        Selection.prototype.destroy = /**
         * Cleans up our subscriptions to other providers
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        Object.defineProperty(Selection.prototype, "currentSingle", {
            get: /**
             * @return {?}
             */ function () {
                return this._currentSingle;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (value === this._currentSingle) {
                    return;
                }
                this._currentSingle = value;
                if (this._items.all && this._items.trackBy && value) {
                    /** @type {?} */
                    var lookup = this._items.all.findIndex(function (maybe) { return maybe === value; });
                    this.prevSingleSelectionRef = this._items.trackBy(lookup, value);
                }
                this.emitChange();
                // Ignore items changes in the same change detection cycle.
                // @TODO This can likely be removed!
                this.debounce = true;
                setTimeout(function () { return (_this.debounce = false); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Selection.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.updateCurrent(value, true);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @param {?} emit
         * @return {?}
         */
        Selection.prototype.updateCurrent = /**
         * @param {?} value
         * @param {?} emit
         * @return {?}
         */
            function (value, emit) {
                var _this = this;
                this._current = value;
                if (emit) {
                    this.emitChange();
                    // Ignore items changes in the same change detection cycle.
                    // @TODO This can likely be removed!
                    this.debounce = true;
                    setTimeout(function () { return (_this.debounce = false); });
                }
            };
        /**
         * @return {?}
         */
        Selection.prototype.emitChange = /**
         * @return {?}
         */
            function () {
                if (this._selectionType === SelectionType.Single) {
                    this._change.next(this.currentSingle);
                }
                else if (this._selectionType === SelectionType.Multi) {
                    this._change.next(this.current);
                }
            };
        Object.defineProperty(Selection.prototype, "change", {
            // We do not want to expose the Subject itself, but the Observable which is read-only
            get: 
            // We do not want to expose the Subject itself, but the Observable which is read-only
            /**
             * @return {?}
             */
            function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks if an item is currently selected
         */
        /**
         * Checks if an item is currently selected
         * @param {?} item
         * @return {?}
         */
        Selection.prototype.isSelected = /**
         * Checks if an item is currently selected
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this._selectionType === SelectionType.Single) {
                    return this.currentSingle === item;
                }
                else if (this._selectionType === SelectionType.Multi) {
                    return this.current.indexOf(item) >= 0;
                }
                return false;
            };
        /**
         * Selects an item
         */
        /**
         * Selects an item
         * @param {?} item
         * @return {?}
         */
        Selection.prototype.selectItem = /**
         * Selects an item
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.current.push(item);
                if (this._items.trackBy) {
                    // Push selected ref onto array
                    /** @type {?} */
                    var lookup = this._items.all.findIndex(function (maybe) { return maybe === item; });
                    this.prevSelectionRefs.push(this._items.trackBy(lookup, item));
                }
            };
        /**
         * Deselects an item
         */
        /**
         * Deselects an item
         * @param {?} indexOfItem
         * @return {?}
         */
        Selection.prototype.deselectItem = /**
         * Deselects an item
         * @param {?} indexOfItem
         * @return {?}
         */
            function (indexOfItem) {
                this.current.splice(indexOfItem, 1);
                if (this._items.trackBy && indexOfItem < this.prevSelectionRefs.length) {
                    // Keep selected refs array in sync
                    this.prevSelectionRefs.splice(indexOfItem, 1);
                }
            };
        /**
         * Selects or deselects an item
         */
        /**
         * Selects or deselects an item
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
        Selection.prototype.setSelected = /**
         * Selects or deselects an item
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
            function (item, selected) {
                switch (this._selectionType) {
                    case SelectionType.None:
                        break;
                    case SelectionType.Single:
                        // in single selection, set currentSingle method should be used
                        break;
                    case SelectionType.Multi:
                        /** @type {?} */
                        var index = this.current.indexOf(item);
                        if (index >= 0 && !selected) {
                            this.deselectItem(index);
                            this.emitChange();
                        }
                        else if (index < 0 && selected) {
                            this.selectItem(item);
                            this.emitChange();
                        }
                        break;
                    default:
                        break;
                }
            };
        /**
         * Checks if all currently displayed items are selected
         */
        /**
         * Checks if all currently displayed items are selected
         * @return {?}
         */
        Selection.prototype.isAllSelected = /**
         * Checks if all currently displayed items are selected
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._selectionType !== SelectionType.Multi || !this._items.displayed) {
                    return false;
                }
                /** @type {?} */
                var displayedItems = this._items.displayed;
                /** @type {?} */
                var nbDisplayed = this._items.displayed.length;
                if (nbDisplayed < 1) {
                    return false;
                }
                /** @type {?} */
                var temp = displayedItems.filter(function (item) { return _this.current.indexOf(item) > -1; });
                return temp.length === displayedItems.length;
            };
        /**
         * Selects or deselects all currently displayed items
         */
        /**
         * Selects or deselects all currently displayed items
         * @return {?}
         */
        Selection.prototype.toggleAll = /**
         * Selects or deselects all currently displayed items
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
                    return;
                }
                /*
                     * If every currently displayed item is already selected, we clear them.
                     * If at least one item isn't selected, we select every currently displayed item.
                     */
                if (this.isAllSelected()) {
                    this._items.displayed.forEach(function (item) {
                        /** @type {?} */
                        var currentIndex = _this.current.indexOf(item);
                        if (currentIndex > -1) {
                            _this.deselectItem(currentIndex);
                        }
                    });
                }
                else {
                    this._items.displayed.forEach(function (item) {
                        if (_this.current.indexOf(item) < 0) {
                            _this.selectItem(item);
                        }
                    });
                }
                this.emitChange();
            };
        Selection.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        Selection.ctorParameters = function () {
            return [
                { type: Items },
                { type: FiltersProvider }
            ];
        };
        return Selection;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var WrappedRow = /** @class */ (function () {
        function WrappedRow() {
            this._dynamic = false;
        }
        // the rows projected view (in memory)
        /**
         * @return {?}
         */
        WrappedRow.prototype.ngAfterViewInit =
            // the rows projected view (in memory)
            /**
             * @return {?}
             */
            function () {
                // Create the cells view in memory, not the DOM.
                this.rowView = this.templateRef.createEmbeddedView(null);
            };
        WrappedRow.decorators = [
            { type: i0.Component, args: [{
                        selector: 'dg-wrapped-row',
                        template: "        \n        <ng-template #rowPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                    }] }
        ];
        WrappedRow.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['rowPortal',] }]
        };
        return WrappedRow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbRow = 0;
    /**
     * @template T
     */
    var ClrDatagridRow = /** @class */ (function () {
        function ClrDatagridRow(selection, rowActionService, globalExpandable, expand, hideableColumnService, displayMode, vcr, renderer, el, commonStrings) {
            var _this = this;
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.globalExpandable = globalExpandable;
            this.expand = expand;
            this.hideableColumnService = hideableColumnService;
            this.displayMode = displayMode;
            this.vcr = vcr;
            this.renderer = renderer;
            this.el = el;
            this.commonStrings = commonStrings;
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
            this._selected = false;
            this.selectedChanged = new i0.EventEmitter(false);
            this.expandedChange = new i0.EventEmitter(false);
            this.subscriptions = [];
            this.displayCells = false;
            nbRow++;
            this.id = 'clr-dg-row' + nbRow;
            this.radioId = 'clr-dg-row-rd' + nbRow;
            this.checkboxId = 'clr-dg-row-cb' + nbRow;
            this.subscriptions.push(rxjs.combineLatest(this.expand.replace, this.expand.expandChange).subscribe(function (_a) {
                var _b = __read(_a, 2), expandReplaceValue = _b[0], expandChangeValue = _b[1];
                if (expandReplaceValue && expandChangeValue) {
                    // replaced and expanding
                    _this.replaced = true;
                    _this.renderer.addClass(_this.el.nativeElement, 'datagrid-row-replaced');
                }
                else {
                    _this.replaced = false;
                    // Handles these cases: not replaced and collapsing & replaced and
                    // collapsing and not replaced and expanding.
                    _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-row-replaced');
                }
            }));
        }
        Object.defineProperty(ClrDatagridRow.prototype, "selected", {
            /**
             * Indicates if the row is selected
             */
            get: /**
             * Indicates if the row is selected
             * @return {?}
             */ function () {
                if (this.selection.selectionType === SelectionType.None) {
                    return this._selected;
                }
                else {
                    return this.selection.isSelected(this.item);
                }
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.selection.selectionType === SelectionType.None) {
                    this._selected = value;
                }
                else {
                    this.selection.setSelected(this.item, value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?=} selected
         * @return {?}
         */
        ClrDatagridRow.prototype.toggle = /**
         * @param {?=} selected
         * @return {?}
         */
            function (selected) {
                if (selected === void 0) {
                    selected = !this.selected;
                }
                if (selected !== this.selected) {
                    this.selected = selected;
                    this.selectedChanged.emit(selected);
                }
            };
        Object.defineProperty(ClrDatagridRow.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this.expand.expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.expand.expanded = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                if (this.expand.expandable) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Make sure things get started
                /** @type {?} */
                var columnsList = this.hideableColumnService.getColumns();
                this.updateCellsForColumns(columnsList);
                // Triggered when the Cells list changes per row-renderer
                this.dgCells.changes.subscribe(function (cellList) {
                    /** @type {?} */
                    var columnList = _this.hideableColumnService.getColumns();
                    if (cellList.length === columnList.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                });
                // Used to set things up the first time but only after all the columns are ready.
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
                    // Prevents cell updates when cols and cells array are not aligned - only seems to run on init / first time.
                    if (columnList.length === _this.dgCells.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                }));
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.displayMode.view.subscribe(function (viewChange) {
                    // Listen for view changes and move cells around depending on the current displayType
                    // remove cell views from display view
                    for (var i = _this._scrollableCells.length; i > 0; i--) {
                        _this._scrollableCells.detach();
                    }
                    // remove cell views from calculated view
                    for (var i = _this._calculatedCells.length; i > 0; i--) {
                        _this._calculatedCells.detach();
                    }
                    if (viewChange === DatagridDisplayMode.CALCULATE) {
                        _this.displayCells = false;
                        _this.dgCells.forEach(function (cell) {
                            _this._calculatedCells.insert(cell._view);
                        });
                    }
                    else {
                        _this.displayCells = true;
                        _this.dgCells.forEach(function (cell) {
                            _this._scrollableCells.insert(cell._view);
                        });
                    }
                }));
            };
        /**********
         *
         * @description
         * 1. Maps the new columnListChange to the dgCells list by index
         * 2. Sets the hidden state on the cell
         * Take a Column list and use index to access the columns for hideable properties.
         *
         */
        /**
         * *******
         *
         * \@description
         * 1. Maps the new columnListChange to the dgCells list by index
         * 2. Sets the hidden state on the cell
         * Take a Column list and use index to access the columns for hideable properties.
         *
         * @param {?} columnList
         * @return {?}
         */
        ClrDatagridRow.prototype.updateCellsForColumns = /**
         * *******
         *
         * \@description
         * 1. Maps the new columnListChange to the dgCells list by index
         * 2. Sets the hidden state on the cell
         * Take a Column list and use index to access the columns for hideable properties.
         *
         * @param {?} columnList
         * @return {?}
         */
            function (columnList) {
                // Map cells to columns with Array.index
                this.dgCells.forEach(function (cell, index) {
                    /** @type {?} */
                    var currentColumn = columnList[index];
                    if (currentColumn) {
                        cell.id = currentColumn.id;
                    }
                });
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        ClrDatagridRow.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.wrappedInjector = new HostWrapper(WrappedRow, this.vcr);
            };
        Object.defineProperty(ClrDatagridRow.prototype, "_view", {
            get: /**
             * @return {?}
             */ function () {
                return this.wrappedInjector.get(WrappedRow, this.vcr).rowView;
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridRow.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-row',
                        template: "<!--\n  We need to wrap the #rowContent in label element if we are in rowSelectionMode.\n  Clicking of that wrapper label will equate to clicking on the whole row, which triggers the checkbox to toggle.\n-->\n<label class=\"datagrid-row-clickable\" *ngIf=\"selection.rowSelectionMode\">\n  <ng-template [ngTemplateOutlet]=\"rowContent\"></ng-template>\n</label>\n\n<ng-template *ngIf=\"!selection.rowSelectionMode\" [ngTemplateOutlet]=\"rowContent\"></ng-template>\n\n<!--\n    We need the \"project into template\" hacks because we need this in 2 different places\n    depending on whether the details replace the row or not.\n-->\n<ng-template #detail>\n  <ng-content select=\"clr-dg-row-detail\"></ng-content>\n</ng-template>\n\n<ng-template #rowContent>\n  <div role=\"row\" [id]=\"id\" class=\"datagrid-row-master datagrid-row-flex\">\n    <div class=\"datagrid-row-sticky\">\n      <!-- Sticky elements here -->\n      <ng-container #stickyCells></ng-container> <!-- placeholder for projecting other sticky cells as pinned-->\n    </div>\n    <div class=\"datagrid-row-scrollable\" [ngClass]=\"{'is-replaced': replaced && expanded}\">\n      <div class=\"datagrid-scrolling-cells\">\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\">\n          <input clrCheckbox type=\"checkbox\" [ngModel]=\"selected\" (ngModelChange)=\"toggle($event)\" [id]=\"checkboxId\"\n                 [attr.aria-label]=\"commonStrings.select\">\n        </div>\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\">\n            <!-- TODO: it would be better if in addition to the generic \"Select\" label, we could add aria-labelledby\n            to label the radio by the first cell in the row (typically an id or name).\n            It's pretty easy to label it with the whole row since we already have an id for it, but in most\n            cases the row is far too long to serve as a label, the screenreader reads every single cell content. -->\n            <input type=\"radio\" clrRadio [id]=\"radioId\" [name]=\"selection.id + '-radio'\" [value]=\"item\"\n                   [(ngModel)]=\"selection.currentSingle\" [checked]=\"selection.currentSingle === item\"\n                   [attr.aria-label]=\"commonStrings.select\">\n        </div>\n        <div *ngIf=\"rowActionService.hasActionableRow\"\n             class=\"datagrid-row-actions datagrid-fixed-column datagrid-cell\">\n          <ng-content select=\"clr-dg-action-overflow\"></ng-content>\n        </div>\n        <div *ngIf=\"globalExpandable.hasExpandableRow\"\n             class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\">\n          <ng-container *ngIf=\"expand.expandable\">\n            <button (click)=\"toggleExpand()\" *ngIf=\"!expand.loading\" type=\"button\" class=\"datagrid-expandable-caret-button\">\n              <clr-icon shape=\"caret\"\n                        class=\"datagrid-expandable-caret-icon\"\n                        [attr.dir]=\"expand.expanded ? 'down' : 'right'\"\n                        [attr.title]=\"expand.expanded ? commonStrings.collapse : commonStrings.expand\"></clr-icon>\n            </button>\n            <div class=\"spinner spinner-sm\" *ngIf=\"expand.loading\"></div>\n          </ng-container>\n        </div>\n        <ng-container #scrollableCells></ng-container>\n      </div>\n      <!-- details here when replace, re-visit when sticky container is used for pinned cells -->\n      <ng-template *ngIf=\"replaced && !expand.loading\"\n                   [ngTemplateOutlet]=\"detail\"></ng-template>\n    </div>\n    <ng-template *ngIf=\"!replaced && !expand.loading\"\n                 [ngTemplateOutlet]=\"detail\"></ng-template>\n  </div>\n</ng-template>\n\n<ng-container #calculatedCells></ng-container>\n",
                        host: {
                            '[class.datagrid-row]': 'true',
                            '[class.datagrid-selected]': 'selected',
                            '[attr.aria-owns]': 'id',
                            role: 'rowgroup',
                        },
                        providers: [Expand, { provide: LoadingListener, useExisting: Expand }]
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridRow.ctorParameters = function () {
            return [
                { type: Selection },
                { type: RowActionService },
                { type: ExpandableRowsCount },
                { type: Expand },
                { type: HideableColumnService },
                { type: DisplayModeService },
                { type: i0.ViewContainerRef },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: ClrCommonStrings }
            ];
        };
        ClrDatagridRow.propDecorators = {
            item: [{ type: i0.Input, args: ['clrDgItem',] }],
            selected: [{ type: i0.Input, args: ['clrDgSelected',] }],
            selectedChanged: [{ type: i0.Output, args: ['clrDgSelectedChange',] }],
            expanded: [{ type: i0.Input, args: ['clrDgExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrDgExpandedChange',] }],
            dgCells: [{ type: i0.ContentChildren, args: [ClrDatagridCell,] }],
            _stickyCells: [{ type: i0.ViewChild, args: ['stickyCells', { read: i0.ViewContainerRef },] }],
            _scrollableCells: [{ type: i0.ViewChild, args: ['scrollableCells', { read: i0.ViewContainerRef },] }],
            _calculatedCells: [{ type: i0.ViewChild, args: ['calculatedCells', { read: i0.ViewContainerRef },] }]
        };
        return ClrDatagridRow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ColumnToggleButtonsService = /** @class */ (function () {
        function ColumnToggleButtonsService() {
            this.buttons = null;
            this.selectAllDisabled = false;
            this._selectAllButtonClicked = new rxjs.Subject();
        }
        Object.defineProperty(ColumnToggleButtonsService.prototype, "selectAllButtonClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._selectAllButtonClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColumnToggleButtonsService.prototype.buttonClicked = /**
         * @return {?}
         */
            function () {
                this._selectAllButtonClicked.next();
            };
        ColumnToggleButtonsService.decorators = [
            { type: i0.Injectable }
        ];
        return ColumnToggleButtonsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * This provider aggregates state changes from the various providers of the Datagrid
     * @template T
     */
    var StateProvider = /** @class */ (function () {
        function StateProvider(filters, sort, page, debouncer) {
            var _this = this;
            this.filters = filters;
            this.sort = sort;
            this.page = page;
            this.debouncer = debouncer;
            /**
             * The Observable that lets other classes subscribe to global state changes
             */
            this.change = this.debouncer.change.pipe(operators.map(function () { return _this.state; }));
        }
        Object.defineProperty(StateProvider.prototype, "state", {
            /*
               * By making this a getter, we open the possibility for a setter in the future.
               * It's been requested a couple times.
               */
            get: /*
                 * By making this a getter, we open the possibility for a setter in the future.
                 * It's been requested a couple times.
                 */ 
            /**
             * @return {?}
             */
            function () {
                var e_1, _a;
                /** @type {?} */
                var state = {};
                if (this.page.size > 0) {
                    state.page = { from: this.page.firstItem, to: this.page.lastItem, size: this.page.size };
                }
                if (this.sort.comparator) {
                    if (this.sort.comparator instanceof DatagridPropertyComparator) {
                        /*
                                 * Special case for the default object property comparator,
                                 * we give the property name instead of the actual comparator.
                                 */
                        state.sort = { by: (( /** @type {?} */(this.sort.comparator))).prop, reverse: this.sort.reverse };
                    }
                    else {
                        state.sort = { by: this.sort.comparator, reverse: this.sort.reverse };
                    }
                }
                /** @type {?} */
                var activeFilters = this.filters.getActiveFilters();
                if (activeFilters.length > 0) {
                    state.filters = [];
                    try {
                        for (var activeFilters_1 = __values(activeFilters), activeFilters_1_1 = activeFilters_1.next(); !activeFilters_1_1.done; activeFilters_1_1 = activeFilters_1.next()) {
                            var filter = activeFilters_1_1.value;
                            if (filter instanceof DatagridStringFilterImpl) {
                                /** @type {?} */
                                var stringFilter = filter.filterFn;
                                if (stringFilter instanceof DatagridPropertyStringFilter) {
                                    /*
                                                 * Special case again for the default object property filter,
                                                 * we give the property name instead of the full filter object.
                                                 */
                                    state.filters.push({
                                        property: stringFilter.prop,
                                        value: filter.value,
                                    });
                                    continue;
                                }
                            }
                            state.filters.push(filter);
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (activeFilters_1_1 && !activeFilters_1_1.done && (_a = activeFilters_1.return))
                                _a.call(activeFilters_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                }
                return state;
            },
            enumerable: true,
            configurable: true
        });
        StateProvider.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        StateProvider.ctorParameters = function () {
            return [
                { type: FiltersProvider },
                { type: Sort },
                { type: Page },
                { type: StateDebouncer }
            ];
        };
        return StateProvider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * \@description
     * Internal datagrid service that holds a reference to the clr-dg-table element and exposes a method to get height.
     */
    var TableSizeService = /** @class */ (function () {
        function TableSizeService(platformId, renderOrganizer, renderer) {
            var _this = this;
            this.platformId = platformId;
            this.renderer = renderer;
            this.subscriptions = [];
            this.subscriptions.push(renderOrganizer.renderStep.subscribe(function (step) {
                if (step === DatagridRenderStep.UPDATE_ROW_WIDTH) {
                    _this.updateRowWidth();
                }
            }));
        }
        Object.defineProperty(TableSizeService.prototype, "tableRef", {
            get: /**
             * @return {?}
             */ function () {
                return this._tableRef;
            },
            set: /**
             * @param {?} element
             * @return {?}
             */ function (element) {
                this._tableRef = element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableSizeService.prototype, "table", {
            set: /**
             * @param {?} table
             * @return {?}
             */ function (table) {
                if (common.isPlatformBrowser(this.platformId) && table.nativeElement) {
                    this.tableRef = table.nativeElement.querySelector('.datagrid-table');
                }
            },
            enumerable: true,
            configurable: true
        });
        // Used when resizing columns to show the column border being dragged.
        // Used when resizing columns to show the column border being dragged.
        /**
         * @return {?}
         */
        TableSizeService.prototype.getColumnDragHeight =
            // Used when resizing columns to show the column border being dragged.
            /**
             * @return {?}
             */
            function () {
                if (!this.tableRef) {
                    return;
                }
                return this.tableRef.clientHeight + "px";
            };
        /**
         * @return {?}
         */
        TableSizeService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        TableSizeService.prototype.updateRowWidth = /**
         * @return {?}
         */
            function () {
                if (!this.tableRef) {
                    return;
                }
                /** @type {?} */
                var newWidth = 0;
                this.renderer.removeStyle(this.tableRef, 'width');
                this.columns = Array.from(this.tableRef.querySelectorAll('.datagrid-column'));
                this.columns.forEach(function (item) {
                    newWidth += item.clientWidth;
                });
                this.renderer.setStyle(this.tableRef, 'width', newWidth + 'px');
            };
        TableSizeService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        TableSizeService.ctorParameters = function () {
            return [
                { type: Object, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
                { type: DatagridRenderOrganizer },
                { type: i0.Renderer2 }
            ];
        };
        return TableSizeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagrid = /** @class */ (function () {
        function ClrDatagrid(columnService, organizer, items, expandableRows, selection, rowActionService, stateProvider, displayMode, renderer, el, commonStrings) {
            this.columnService = columnService;
            this.organizer = organizer;
            this.items = items;
            this.expandableRows = expandableRows;
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.stateProvider = stateProvider;
            this.displayMode = displayMode;
            this.renderer = renderer;
            this.el = el;
            this.commonStrings = commonStrings;
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
            /**
             * Output emitted whenever the data needs to be refreshed, based on user action or external ones
             */
            this.refresh = new i0.EventEmitter(false);
            this.selectedChanged = new i0.EventEmitter(false);
            this.singleSelectedChanged = new i0.EventEmitter(false);
            /**
             * Subscriptions to all the services and queries changes
             */
            this._subscriptions = [];
        }
        Object.defineProperty(ClrDatagrid.prototype, "loading", {
            /**
             * Freezes the datagrid while data is loading
             */
            get: /**
             * Freezes the datagrid while data is loading
             * @return {?}
             */ function () {
                return this.items.loading;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.items.loading = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Public method to re-trigger the computation of displayed items manually
         */
        /**
         * Public method to re-trigger the computation of displayed items manually
         * @return {?}
         */
        ClrDatagrid.prototype.dataChanged = /**
         * Public method to re-trigger the computation of displayed items manually
         * @return {?}
         */
            function () {
                this.items.refresh();
            };
        Object.defineProperty(ClrDatagrid.prototype, "selected", {
            /**
             * Array of all selected items
             */
            set: /**
             * Array of all selected items
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this.selection.selectionType = SelectionType.Multi;
                }
                else {
                    this.selection.selectionType = SelectionType.None;
                }
                this.selection.updateCurrent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "singleSelected", {
            /**
             * Selected item in single-select mode
             */
            set: /**
             * Selected item in single-select mode
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.selection.selectionType = SelectionType.Single;
                // the clrDgSingleSelected is updated in one of two cases:
                // 1. an explicit value is passed
                // 2. is being set to null or undefined, where previously it had a value
                if (value) {
                    this.selection.currentSingle = value;
                }
                else if (this.selection.currentSingle) {
                    this.selection.currentSingle = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "rowSelectionMode", {
            /**
             * Selection/Deselection on row click mode
             */
            set: /**
             * Selection/Deselection on row click mode
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.selection.rowSelectionMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagrid.prototype, "allSelected", {
            /**
             * Indicates if all currently displayed items are selected
             */
            get: /**
             * Indicates if all currently displayed items are selected
             * @return {?}
             */ function () {
                return this.selection.isAllSelected();
            },
            /**
             * Selects/deselects all currently displayed items
             * @param value
             */
            set: /**
             * Selects/deselects all currently displayed items
             * @param {?} value
             * @return {?}
             */ function (value) {
                /*
                     * This is a setter but we ignore the value.
                     * It's strange, but it lets us have an indeterminate state where only
                     * some of the items are selected.
                     */
                this.selection.toggleAll();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagrid.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.items.smart) {
                    this.items.all = this.rows.map(function (row) { return row.item; });
                }
                this._subscriptions.push(this.rows.changes.subscribe(function () {
                    if (!_this.items.smart) {
                        _this.items.all = _this.rows.map(function (row) { return row.item; });
                    }
                    _this.rows.forEach(function (row) {
                        _this._displayedRows.insert(row._view);
                    });
                }));
                this._subscriptions.push(this.columns.changes.subscribe(function (columns) {
                    _this.columnService.updateColumnList(_this.columns.map(function (col) { return col.hideable; }));
                }));
                // Get ColumnService ready for HideableColumns.
                this.columnService.updateColumnList(this.columns.map(function (col) { return col.hideable; }));
            };
        /**
         * Our setup happens in the view of some of our components, so we wait for it to be done before starting
         */
        /**
         * Our setup happens in the view of some of our components, so we wait for it to be done before starting
         * @return {?}
         */
        ClrDatagrid.prototype.ngAfterViewInit = /**
         * Our setup happens in the view of some of our components, so we wait for it to be done before starting
         * @return {?}
         */
            function () {
                var _this = this;
                // TODO: determine if we can get rid of provider wiring in view init so that subscriptions can be done earlier
                this.refresh.emit(this.stateProvider.state);
                this._subscriptions.push(this.stateProvider.change.subscribe(function (state) { return _this.refresh.emit(state); }));
                this._subscriptions.push(this.selection.change.subscribe(function (s) {
                    if (_this.selection.selectionType === SelectionType.Single) {
                        _this.singleSelectedChanged.emit(( /** @type {?} */(s)));
                    }
                    else if (_this.selection.selectionType === SelectionType.Multi) {
                        _this.selectedChanged.emit(( /** @type {?} */(s)));
                    }
                }));
                // A subscription that listens for displayMode changes on the datagrid
                this.displayMode.view.subscribe(function (viewChange) {
                    // Remove any projected columns from the projectedDisplayColumns container
                    for (var i = _this._projectedDisplayColumns.length; i > 0; i--) {
                        _this._projectedDisplayColumns.detach();
                    }
                    // Remove any projected columns from the projectedCalculationColumns container
                    for (var i = _this._projectedCalculationColumns.length; i > 0; i--) {
                        _this._projectedCalculationColumns.detach();
                    }
                    // Remove any projected rows from the calculationRows container
                    for (var i = _this._calculationRows.length; i > 0; i--) {
                        _this._calculationRows.detach();
                    }
                    // Remove any projected rows from the displayedRows container
                    for (var i = _this._displayedRows.length; i > 0; i--) {
                        _this._displayedRows.detach();
                    }
                    if (viewChange === DatagridDisplayMode.DISPLAY) {
                        // Set state, style for the datagrid to DISPLAY and insert row & columns into containers
                        _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                        _this.columns.forEach(function (column) {
                            _this._projectedDisplayColumns.insert(column._view);
                        });
                        _this.rows.forEach(function (row) {
                            _this._displayedRows.insert(row._view);
                        });
                    }
                    else {
                        // Set state, style for the datagrid to CALCULATE and insert row & columns into containers
                        _this.renderer.addClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                        _this.columns.forEach(function (column) {
                            _this._projectedCalculationColumns.insert(column._view);
                        });
                        _this.rows.forEach(function (row) {
                            _this._calculationRows.insert(row._view);
                        });
                    }
                });
            };
        /**
         * @return {?}
         */
        ClrDatagrid.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        ClrDatagrid.prototype.resize = /**
         * @return {?}
         */
            function () {
                this.organizer.resize();
            };
        ClrDatagrid.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-datagrid',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-content select=\"clr-dg-action-bar\"></ng-content>\n<div class=\"datagrid\" #datagrid>\n    <div role=\"grid\" class=\"datagrid-table\">\n        <div role=\"rowgroup\" class=\"datagrid-header\">\n            <div role=\"row\" class=\"datagrid-row\">\n                <div class=\"datagrid-row-master datagrid-row-flex\">\n                    <div class=\"datagrid-row-sticky\">\n                        <!-- Sticky elements here -->\n                    </div>\n                    <div class=\"datagrid-row-scrollable\">\n                        <!--header for datagrid where you can select multiple rows -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                             *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n                            <span class=\"datagrid-column-title\">\n                                <input clrCheckbox type=\"checkbox\" [(ngModel)]=\"allSelected\"\n                                       [attr.aria-label]=\"commonStrings.selectAll\">\n                            </span>\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <!-- header for datagrid where you can select one row only -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                             *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\">\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <!-- header for single row action; only displayType if we have at least one actionable row in datagrid -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-row-actions datagrid-fixed-column\"\n                             *ngIf=\"rowActionService.hasActionableRow\">\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <!-- header for carets; only displayType if we have at least one expandable row in datagrid -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-expandable-caret datagrid-fixed-column\"\n                             *ngIf=\"expandableRows.hasExpandableRow\">\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <ng-container #projectedDisplayColumns></ng-container>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <ng-container #displayedRows></ng-container>\n        <!-- Custom placeholder overrides the default empty one -->\n        <ng-content select=\"clr-dg-placeholder\"></ng-content>\n        <clr-dg-placeholder *ngIf=\"!placeholder\"></clr-dg-placeholder>\n    </div>\n</div>\n<ng-content select=\"clr-dg-footer\"></ng-content>\n<div class=\"datagrid-spinner\" *ngIf=\"loading\">\n    <div class=\"spinner spinner-md\">Loading...</div>\n</div>\n\n<div class=\"datagrid-calculation-table\">\n    <div class=\"datagrid-calculation-header\">\n        <ng-container #projectedCalculationColumns></ng-container>\n    </div>\n    <ng-container #calculationRows></ng-container>\n</div>\n",
                        providers: [
                            Selection,
                            Sort,
                            FiltersProvider,
                            Page,
                            Items,
                            DatagridRenderOrganizer,
                            RowActionService,
                            ExpandableRowsCount,
                            HideableColumnService,
                            StateDebouncer,
                            StateProvider,
                            ColumnToggleButtonsService,
                            TableSizeService,
                            DisplayModeService,
                        ],
                        host: { '[class.datagrid-host]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagrid.ctorParameters = function () {
            return [
                { type: HideableColumnService },
                { type: DatagridRenderOrganizer },
                { type: Items },
                { type: ExpandableRowsCount },
                { type: Selection },
                { type: RowActionService },
                { type: StateProvider },
                { type: DisplayModeService },
                { type: i0.Renderer2 },
                { type: i0.ElementRef },
                { type: ClrCommonStrings }
            ];
        };
        ClrDatagrid.propDecorators = {
            loading: [{ type: i0.Input, args: ['clrDgLoading',] }],
            refresh: [{ type: i0.Output, args: ['clrDgRefresh',] }],
            iterator: [{ type: i0.ContentChild, args: [ClrDatagridItems,] }],
            selected: [{ type: i0.Input, args: ['clrDgSelected',] }],
            selectedChanged: [{ type: i0.Output, args: ['clrDgSelectedChange',] }],
            singleSelected: [{ type: i0.Input, args: ['clrDgSingleSelected',] }],
            singleSelectedChanged: [{ type: i0.Output, args: ['clrDgSingleSelectedChange',] }],
            rowSelectionMode: [{ type: i0.Input, args: ['clrDgRowSelection',] }],
            placeholder: [{ type: i0.ContentChild, args: [ClrDatagridPlaceholder,] }],
            columns: [{ type: i0.ContentChildren, args: [ClrDatagridColumn,] }],
            rows: [{ type: i0.ContentChildren, args: [ClrDatagridRow,] }],
            scrollableColumns: [{ type: i0.ViewChild, args: ['scrollableColumns', { read: i0.ViewContainerRef },] }],
            _projectedDisplayColumns: [{ type: i0.ViewChild, args: ['projectedDisplayColumns', { read: i0.ViewContainerRef },] }],
            _projectedCalculationColumns: [{ type: i0.ViewChild, args: ['projectedCalculationColumns', { read: i0.ViewContainerRef },] }],
            _displayedRows: [{ type: i0.ViewChild, args: ['displayedRows', { read: i0.ViewContainerRef },] }],
            _calculationRows: [{ type: i0.ViewChild, args: ['calculationRows', { read: i0.ViewContainerRef },] }]
        };
        return ClrDatagrid;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridActionBar = /** @class */ (function () {
        function ClrDatagridActionBar() {
        }
        ClrDatagridActionBar.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-action-bar',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: { '[class.datagrid-action-bar]': 'true' }
                    }] }
        ];
        return ClrDatagridActionBar;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridActionOverflow = /** @class */ (function () {
        function ClrDatagridActionOverflow(rowActionService, commonStrings) {
            this.rowActionService = rowActionService;
            this.commonStrings = commonStrings;
            this.anchorPoint = Point.RIGHT_CENTER;
            this.popoverPoint = Point.LEFT_CENTER;
            /**
             * Tracks whether the action overflow menu is open or not
             */
            this._open = false;
            this.openChanged = new i0.EventEmitter(false);
            this.rowActionService.register();
        }
        /**
         * @return {?}
         */
        ClrDatagridActionOverflow.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.rowActionService.unregister();
            };
        Object.defineProperty(ClrDatagridActionOverflow.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._open;
            },
            set: /**
             * @param {?} open
             * @return {?}
             */ function (open) {
                /** @type {?} */
                var boolOpen = !!open;
                if (boolOpen !== this._open) {
                    this._open = boolOpen;
                    this.openChanged.emit(boolOpen);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Shows/hides the action overflow menu
         */
        /**
         * Shows/hides the action overflow menu
         * @param {?} event
         * @return {?}
         */
        ClrDatagridActionOverflow.prototype.toggle = /**
         * Shows/hides the action overflow menu
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.openingEvent = event;
                this.open = !this.open;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ClrDatagridActionOverflow.prototype.close = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /*
                     * Because this listener is added synchonously, before the event finishes bubbling up the DOM,
                     * we end up firing on the very click that just opened the menu, p
                     * otentially closing it immediately every time. So we just ignore it.
                     */
                if (event === this.openingEvent) {
                    delete this.openingEvent;
                    return;
                }
                this.open = false;
            };
        ClrDatagridActionOverflow.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-action-overflow',
                        template: "\n        <button (click)=\"toggle($event)\" type=\"button\" class=\"datagrid-action-toggle\" #anchor>\n            <clr-icon shape=\"ellipsis-vertical\" [attr.title]=\"commonStrings.rowActions\"></clr-icon>\n        </button>\n        <ng-template [(clrPopoverOld)]=\"open\" [clrPopoverOldAnchor]=\"anchor\" [clrPopoverOldAnchorPoint]=\"anchorPoint\"\n                     [clrPopoverOldPopoverPoint]=\"popoverPoint\">\n            <div #menu class=\"datagrid-action-overflow\" (clrOutsideClick)=\"close($event)\" [clrStrict]=\"true\">\n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridActionOverflow.ctorParameters = function () {
            return [
                { type: RowActionService },
                { type: ClrCommonStrings }
            ];
        };
        ClrDatagridActionOverflow.propDecorators = {
            open: [{ type: i0.Input, args: ['clrDgActionOverflowOpen',] }],
            openChanged: [{ type: i0.Output, args: ['clrDgActionOverflowOpenChange',] }]
        };
        return ClrDatagridActionOverflow;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridColumnToggleButton = /** @class */ (function () {
        function ClrDatagridColumnToggleButton(toggleButtons) {
            this.toggleButtons = toggleButtons;
        }
        ClrDatagridColumnToggleButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column-toggle-button',
                        template: "\n        <button class=\"btn btn-sm btn-link\"\n            (click)=\"toggleButtons.buttonClicked()\"\n            [disabled]=\"toggleButtons.selectAllDisabled\"\n            type=\"button\">\n            <ng-content></ng-content>\n        </button>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridColumnToggleButton.ctorParameters = function () {
            return [
                { type: ColumnToggleButtonsService }
            ];
        };
        return ClrDatagridColumnToggleButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridColumnToggleTitle = /** @class */ (function () {
        function ClrDatagridColumnToggleTitle() {
        }
        ClrDatagridColumnToggleTitle.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column-toggle-title',
                        template: "<ng-content></ng-content>"
                    }] }
        ];
        return ClrDatagridColumnToggleTitle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridColumnToggle = /** @class */ (function () {
        function ClrDatagridColumnToggle(hideableColumnService, columnToggleButtons, commonStrings) {
            this.hideableColumnService = hideableColumnService;
            this.columnToggleButtons = columnToggleButtons;
            this.commonStrings = commonStrings;
            this.subscriptions = [];
            /**
             *
             * Popover init
             */
            this.anchorPoint = Point.TOP_LEFT;
            this.popoverPoint = Point.LEFT_BOTTOM;
            this.open = false;
            /**
             * *
             * DatagridHideableColumnModel init
             */
            this.columns = [];
        }
        Object.defineProperty(ClrDatagridColumnToggle.prototype, "allColumnsVisible", {
            get: /**
             * @return {?}
             */ function () {
                return this._allColumnsVisible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._allColumnsVisible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
                    // Reset the list of columns
                    _this.columns.length = 0;
                    _this.hideableColumnService.updateForLastVisibleColumn();
                    _this.allColumnsVisible = _this.hideableColumnService.checkForAllColumnsVisible;
                    _this.columnToggleButtons.selectAllDisabled = _this.allColumnsVisible;
                    // Add only the hidden columns to the toggler.
                    columnList.forEach(function (col) {
                        if (col) {
                            _this.columns.push(col);
                        }
                    });
                }));
                this.subscriptions.push(this.columnToggleButtons.selectAllButtonClicked.subscribe(function () {
                    _this.selectAll();
                }));
            };
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.selectAll = /**
         * @return {?}
         */
            function () {
                this.hideableColumnService.showHiddenColumns();
                this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
                this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
            };
        /**
         * @param {?} event
         * @param {?} column
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.toggleColumn = /**
         * @param {?} event
         * @param {?} column
         * @return {?}
         */
            function (event, column) {
                column.hidden = !event;
                this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
                this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
                this.hideableColumnService.updateForLastVisibleColumn();
            };
        /**
         * @return {?}
         */
        ClrDatagridColumnToggle.prototype.toggleUI = /**
         * @return {?}
         */
            function () {
                this.open = !this.open;
            };
        ClrDatagridColumnToggle.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-column-toggle',
                        template: "\n        <button\n                #anchor\n                (click)=\"toggleUI()\"\n                class=\"btn btn-sm btn-link column-toggle--action\"\n                type=\"button\">\n            <clr-icon shape=\"view-columns\" [attr.title]=\"commonStrings.pickColumns\"></clr-icon>\n        </button>\n        <div class=\"column-switch\"\n             *clrPopoverOld=\"open; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint\">\n            <div class=\"switch-header\">\n                <ng-container *ngIf=\"!title\">Show Columns</ng-container>\n                <ng-content select=\"clr-dg-column-toggle-title\"></ng-content>\n                <button\n                    class=\"btn btn-sm btn-link\"\n                    (click)=\"toggleUI()\"\n                    type=\"button\">\n                    <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n                </button>\n            </div>\n            <ul class=\"switch-content list-unstyled\">\n                <li *ngFor=\"let column of columns\">\n                    <clr-checkbox-wrapper>\n                        <input clrCheckbox type=\"checkbox\"\n                          [disabled]=\"column.lastVisibleColumn\"\n                          [ngModel]=\"!column.hidden\"\n                          (ngModelChange)=\"toggleColumn($event, column)\">\n                        <label><ng-template [ngTemplateOutlet]=\"column.template\"></ng-template></label>\n                    </clr-checkbox-wrapper>\n                </li>\n            </ul>\n            <div class=\"switch-footer\" *ngIf=\"buttons.length > 0\">\n                <ng-content select=\"clr-dg-column-toggle-button\"></ng-content>\n            </div>\n            <div class=\"switch-footer\" *ngIf=\"buttons.length === 0\">\n                <div>\n                    <button\n                            class=\"btn btn-sm btn-link p6 text-uppercase\"\n                            [disabled]=\"allColumnsVisible\"\n                            (click)=\"selectAll()\"\n                            type=\"button\">Select All\n                    </button>\n                </div>\n            </div>\n        </div>\n    ",
                        host: { '[class.column-switch-wrapper]': 'true', '[class.active]': 'open' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridColumnToggle.ctorParameters = function () {
            return [
                { type: HideableColumnService },
                { type: ColumnToggleButtonsService },
                { type: ClrCommonStrings }
            ];
        };
        ClrDatagridColumnToggle.propDecorators = {
            title: [{ type: i0.ContentChild, args: [ClrDatagridColumnToggleTitle,] }],
            buttons: [{ type: i0.ContentChildren, args: [ClrDatagridColumnToggleButton,] }]
        };
        return ClrDatagridColumnToggle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * I don't think this deserves to be in IfExpanded itself,
     * so I'm adding a second directive on the same selector for now just for the datagrid
     */
    var DatagridDetailRegisterer = /** @class */ (function () {
        function DatagridDetailRegisterer(expandableRowsCount) {
            this.expandableRowsCount = expandableRowsCount;
            if (this.expandableRowsCount) {
                this.expandableRowsCount.register();
            }
        }
        /**
         * @return {?}
         */
        DatagridDetailRegisterer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.expandableRowsCount) {
                    this.expandableRowsCount.unregister();
                }
            };
        DatagridDetailRegisterer.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfExpanded]' },] }
        ];
        /** @nocollapse */
        DatagridDetailRegisterer.ctorParameters = function () {
            return [
                { type: ExpandableRowsCount, decorators: [{ type: i0.Optional }] }
            ];
        };
        return DatagridDetailRegisterer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridFooter = /** @class */ (function () {
        function ClrDatagridFooter(selection, hideableColumnService, cdr) {
            this.selection = selection;
            this.hideableColumnService = hideableColumnService;
            this.cdr = cdr;
            this.subscriptions = [];
            /* reference to the enum so that template can access */
            this.SELECTION_TYPE = SelectionType;
        }
        /**
         * @return {?}
         */
        ClrDatagridFooter.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (change) {
                    /** @type {?} */
                    var hiddenColumnsInSub = change.filter(function (col) { return col; });
                    if (hiddenColumnsInSub.length > 0) {
                        _this.activeToggler = true;
                    }
                }));
                /** @type {?} */
                var hiddenColumns = this.hideableColumnService.getColumns().filter(function (col) { return col; });
                if (hiddenColumns.length > 0) {
                    this.activeToggler = true;
                }
            };
        /**
         * @return {?}
         */
        ClrDatagridFooter.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) {
                    sub.unsubscribe();
                });
            };
        ClrDatagridFooter.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-footer',
                        template: "\n        <ng-container\n            *ngIf=\"(selection.selectionType === SELECTION_TYPE.Multi) && (selection.current.length > 0)\">\n          <div class=\"clr-form-control-disabled\">\n              <clr-checkbox-wrapper class=\"datagrid-footer-select\">\n                <input clrCheckbox type=\"checkbox\" checked=\"checked\" disabled>\n                <label>{{selection.current.length}}</label>\n            </clr-checkbox-wrapper>\n          </div>\n        </ng-container>\n        <ng-content select=\"clr-dg-column-toggle\"></ng-content>\n        <clr-dg-column-toggle *ngIf=\"!toggle && activeToggler\"></clr-dg-column-toggle>\n        <div class=\"datagrid-footer-description\">\n            <ng-content></ng-content>\n        </div>\n        <ng-content select=\"clr-dg-pagination\"></ng-content>\n    ",
                        host: {
                            '[class.datagrid-footer]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridFooter.ctorParameters = function () {
            return [
                { type: Selection },
                { type: HideableColumnService },
                { type: i0.ChangeDetectorRef }
            ];
        };
        ClrDatagridFooter.propDecorators = {
            toggle: [{ type: i0.ContentChild, args: [ClrDatagridColumnToggle,] }]
        };
        return ClrDatagridFooter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * \@description
     * A utility class for that adds hide/show functionality to a column, its cells and enables a toggler in the
     * DatagridColumnToggle Component.
     *
     */
    var /**
     *
     * \@description
     * A utility class for that adds hide/show functionality to a column, its cells and enables a toggler in the
     * DatagridColumnToggle Component.
     *
     */ DatagridHideableColumnModel = /** @class */ (function () {
        /**
         *
         * @description
         * The init function for DatagridHideableColumnModel instances that does the following:
         *
         * 1. Set values for the private variables that enable a hideable column
         * 2. Broadcast the next hidden change for anyone (already) subscribed to this DatagridHideableColumnModel
         *
         */
        function DatagridHideableColumnModel(_template, _id, _hidden) {
            if (_hidden === void 0) {
                _hidden = false;
            }
            this._template = _template;
            this._id = _id;
            this._hidden = _hidden;
            /**
             * \@property hiddenChanges
             *
             * \@description
             * A stream of state changes an instance of DatagridHideableColumnModel will broadcast to subscribers.
             *
             */
            this.hiddenChangesState = new rxjs.Subject();
            // Flag this true when the service only has one visible column open.
            this.lastVisibleColumn = false;
        }
        Object.defineProperty(DatagridHideableColumnModel.prototype, "template", {
            /**
             *
             * @description
             * A getter function that returns an TemplateRef of the DatagridColumn that is hideable. This is currently used to
             * populate the DatagridColumnToggle UI with the correct Column name.
             *
             */
            get: /**
             *
             * \@description
             * A getter function that returns an TemplateRef of the DatagridColumn that is hideable. This is currently used to
             * populate the DatagridColumnToggle UI with the correct Column name.
             *
             * @return {?}
             */ function () {
                return this._template;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridHideableColumnModel.prototype, "id", {
            /**
             *
             * @description
             * public function that returns the id of a HideableCOlumn instance. Used by the HideableCOlumnService for passing
             * state and actions between DateGridColumns, DataGridCells & the DatagridColumnToggle Components.
             *
             */
            get: /**
             *
             * \@description
             * public function that returns the id of a HideableCOlumn instance. Used by the HideableCOlumnService for passing
             * state and actions between DateGridColumns, DataGridCells & the DatagridColumnToggle Components.
             *
             * @return {?}
             */ function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridHideableColumnModel.prototype, "hidden", {
            /**
             *
             * @description
             * A getter that returns the hidden value of a DatagridHideableColumnModel instance.
             *
             */
            get: /**
             *
             * \@description
             * A getter that returns the hidden value of a DatagridHideableColumnModel instance.
             *
             * @return {?}
             */ function () {
                return this._hidden;
            },
            /**
             *
             * @description
             * The setter for setting the hidden state of a DatagridHideableColumnModel instance.
             * It also broadcasts the change after its set.
             *
             */
            set: /**
             *
             * \@description
             * The setter for setting the hidden state of a DatagridHideableColumnModel instance.
             * It also broadcasts the change after its set.
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._hidden === value) {
                    return;
                }
                this._hidden = value;
                this.hiddenChangesState.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatagridHideableColumnModel.prototype, "hiddenChangeState", {
            /**
             *
             * @description
             * An Observable for the HideableColumns hidden changes.
             *
             */
            get: /**
             *
             * \@description
             * An Observable for the HideableColumns hidden changes.
             *
             * @return {?}
             */ function () {
                return this.hiddenChangesState.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        return DatagridHideableColumnModel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridHideableColumn = /** @class */ (function () {
        /**
         * @description
         * Used the DatagridColumn to get and set an id for this HiddenColumn
         *
         */
        function ClrDatagridHideableColumn(templateRef, viewContainerRef, dgColumn) {
            var _this = this;
            this.templateRef = templateRef;
            this.viewContainerRef = viewContainerRef;
            this.dgColumn = dgColumn;
            this.hiddenChange = new i0.EventEmitter();
            this.columnId = dgColumn.columnId;
            // Use the templateRef to create this view
            this.viewContainerRef.createEmbeddedView(this.templateRef);
            // Create instance of the utility class DatagridHideableColumn.
            // Note this is on the parent instance of DatagridColumn.
            this.dgColumn.hideable = new DatagridHideableColumnModel(this.templateRef, this.columnId, this._hidden);
            this.dgColumn.hideable.hiddenChangeState.subscribe(function (state) { return _this.hiddenChange.emit(state); });
        }
        Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHideableColumn", {
            /**
             *
             * @description
             * Setter fn for the @Input with the same name as this structural directive.
             * It allows the user to pre-configure the column's hide/show state. { hidden: true }
             * It's more verbose but has more Clarity.
             *
             *
             * @example
             * *clrDgHideableColumn
             * *clrDgHideableColumn={hidden: false}
             * *clrDgHideableColumn={hidden: true}
             *
             */
            set: /**
             *
             * \@description
             * Setter fn for the \@Input with the same name as this structural directive.
             * It allows the user to pre-configure the column's hide/show state. { hidden: true }
             * It's more verbose but has more Clarity.
             *
             *
             * \@example
             * *clrDgHideableColumn
             * *clrDgHideableColumn={hidden: false}
             * *clrDgHideableColumn={hidden: true}
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.clrDgHidden = value && value.hidden ? value.hidden : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHidden", {
            set: /**
             * @param {?} hidden
             * @return {?}
             */ function (hidden) {
                this._hidden = hidden ? hidden : false;
                if (this.dgColumn.hideable) {
                    this.dgColumn.hideable.hidden = this._hidden;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridHideableColumn.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrDgHideableColumn]' },] }
        ];
        /** @nocollapse */
        ClrDatagridHideableColumn.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef },
                { type: ClrDatagridColumn }
            ];
        };
        ClrDatagridHideableColumn.propDecorators = {
            clrDgHideableColumn: [{ type: i0.Input, args: ['clrDgHideableColumn',] }],
            clrDgHidden: [{ type: i0.Input, args: ['clrDgHidden',] }],
            hiddenChange: [{ type: i0.Output, args: ['clrDgHiddenChange',] }]
        };
        return ClrDatagridHideableColumn;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDatagridItemsTrackBy = /** @class */ (function () {
        function ClrDatagridItemsTrackBy(_items) {
            this._items = _items;
        }
        Object.defineProperty(ClrDatagridItemsTrackBy.prototype, "trackBy", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._items) {
                    this._items.trackBy = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDatagridItemsTrackBy.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[ngForTrackBy]',
                    },] }
        ];
        /** @nocollapse */
        ClrDatagridItemsTrackBy.ctorParameters = function () {
            return [
                { type: Items, decorators: [{ type: i0.Optional }] }
            ];
        };
        ClrDatagridItemsTrackBy.propDecorators = {
            trackBy: [{ type: i0.Input, args: ['ngForTrackBy',] }]
        };
        return ClrDatagridItemsTrackBy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridPageSize = /** @class */ (function () {
        function ClrDatagridPageSize(page) {
            this.page = page;
        }
        /**
         * @return {?}
         */
        ClrDatagridPageSize.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.pageSizeOptions || this.pageSizeOptions.length === 0) {
                    this.pageSizeOptions = [this.page.size];
                }
            };
        ClrDatagridPageSize.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-page-size',
                        template: "\n    <ng-content></ng-content>\n    <div class=\"clr-select-wrapper\">\n      <select [class.clr-page-size-select]=\"true\" [(ngModel)]=\"page.size\">\n        <option *ngFor=\"let option of pageSizeOptions\" [ngValue]=\"option\">{{option}}</option>\n      </select>\n    </div>\n  "
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridPageSize.ctorParameters = function () {
            return [
                { type: Page }
            ];
        };
        ClrDatagridPageSize.propDecorators = {
            pageSizeOptions: [{ type: i0.Input, args: ['clrPageSizeOptions',] }]
        };
        return ClrDatagridPageSize;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDatagridPagination = /** @class */ (function () {
        function ClrDatagridPagination(page) {
            this.page = page;
            this.defaultSize = true;
            this.currentChanged = new i0.EventEmitter(false);
        }
        /**********
         * Subscription to the Page service for page changes.
         * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
         */
        /**
         * *******
         * Subscription to the Page service for page changes.
         * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
         * @return {?}
         */
        ClrDatagridPagination.prototype.ngOnInit = /**
         * *******
         * Subscription to the Page service for page changes.
         * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
         * @return {?}
         */
            function () {
                var _this = this;
                /*
                 * Default page size is 10.
                 * The reason we set it in this constructor and not in the provider itself is because
                 * we don't want pagination (page size 0) if this component isn't present in the datagrid.
                 */
                if (this.defaultSize) {
                    this.page.size = 10;
                }
                this._pageSubscription = this.page.change.subscribe(function (current) { return _this.currentChanged.emit(current); });
            };
        /**
         * @return {?}
         */
        ClrDatagridPagination.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.page.resetPageSize();
                if (this._pageSubscription) {
                    this._pageSubscription.unsubscribe();
                }
            };
        Object.defineProperty(ClrDatagridPagination.prototype, "pageSize", {
            /**
             * Page size
             */
            get: /**
             * Page size
             * @return {?}
             */ function () {
                return this.page.size;
            },
            set: /**
             * @param {?} size
             * @return {?}
             */ function (size) {
                if (typeof size === 'number') {
                    this.defaultSize = false;
                    this.page.size = size;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "totalItems", {
            /**
             * Total items (needed to guess the last page)
             */
            get: /**
             * Total items (needed to guess the last page)
             * @return {?}
             */ function () {
                return this.page.totalItems;
            },
            set: /**
             * @param {?} total
             * @return {?}
             */ function (total) {
                if (typeof total === 'number') {
                    this.page.totalItems = total;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "lastPage", {
            /**
             * Last page
             */
            get: /**
             * Last page
             * @return {?}
             */ function () {
                return this.page.last;
            },
            set: /**
             * @param {?} last
             * @return {?}
             */ function (last) {
                if (typeof last === 'number') {
                    this.page.last = last;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "currentPage", {
            /**
             * Current page
             */
            get: /**
             * Current page
             * @return {?}
             */ function () {
                return this.page.current;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                if (typeof page === 'number') {
                    this.page.current = page;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Moves to the previous page if it exists
         */
        /**
         * Moves to the previous page if it exists
         * @return {?}
         */
        ClrDatagridPagination.prototype.previous = /**
         * Moves to the previous page if it exists
         * @return {?}
         */
            function () {
                this.page.previous();
            };
        /**
         * Moves to the next page if it exists
         */
        /**
         * Moves to the next page if it exists
         * @return {?}
         */
        ClrDatagridPagination.prototype.next = /**
         * Moves to the next page if it exists
         * @return {?}
         */
            function () {
                this.page.next();
            };
        Object.defineProperty(ClrDatagridPagination.prototype, "firstItem", {
            /**
             * Index of the first item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the first item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                return this.page.firstItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "lastItem", {
            /**
             * Index of the last item displayed on the current page, starting at 0
             */
            get: /**
             * Index of the last item displayed on the current page, starting at 0
             * @return {?}
             */ function () {
                return this.page.lastItem;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDatagridPagination.prototype, "middlePages", {
            /**
             * Conditionally adds page numbers before and after the current page
             */
            get: /**
             * Conditionally adds page numbers before and after the current page
             * @return {?}
             */ function () {
                /** @type {?} */
                var middlePages = [];
                if (this.page.current > 1) {
                    middlePages.push(this.page.current - 1);
                }
                middlePages.push(this.page.current);
                if (this.page.current < this.page.last) {
                    middlePages.push(this.page.current + 1);
                }
                return middlePages;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * We only update the pagination's current page on blur of the input field, or
         * when they press enter.
         */
        /**
         * We only update the pagination's current page on blur of the input field, or
         * when they press enter.
         * @param {?} event
         * @return {?}
         */
        ClrDatagridPagination.prototype.updateCurrentPage = /**
         * We only update the pagination's current page on blur of the input field, or
         * when they press enter.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                /** @type {?} */
                var parsed = parseInt(event.target.value, 10);
                // if the input value, is not a number, we don't update the page
                if (!isNaN(parsed)) {
                    if (parsed < 1) {
                        this.page.current = 1;
                    }
                    else if (parsed > this.page.last) {
                        this.page.current = this.page.last;
                    }
                    else {
                        this.page.current = parsed;
                    }
                }
                /**
                 * Set the input's value to the new current page. This is needed because the code
                 * above may have changed the value from what the user entered in.
                 */
                this.currentPageInputRef.nativeElement.value = this.page.current;
            };
        ClrDatagridPagination.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-pagination',
                        template: "\n    <div class=\"pagination-size\" *ngIf=\"_pageSizeComponent\">\n      <ng-content select=\"clr-dg-page-size\"></ng-content>\n    </div>\n    <div class=\"pagination-description\">\n      <ng-content></ng-content>\n    </div>\n    <div class=\"pagination-list\" *ngIf=\"page.last > 1\">\n      <button class=\"pagination-first\" [disabled]=\"page.current <= 1\" (click)=\"page.current = 1\">\n        <clr-icon shape=\"step-forward-2 down\"></clr-icon>\n      </button>\n      <button class=\"pagination-previous\" [disabled]=\"page.current <= 1\" (click)=\"page.current = page.current - 1\">\n        <clr-icon shape=\"angle left\"></clr-icon>\n      </button>\n      <input #currentPageInput type=\"text\" class=\"pagination-current\" [size]=\"page.last.toString().length\" [value]=\"page.current\"\n             (keydown.enter)=\"updateCurrentPage($event)\" (blur)=\"updateCurrentPage($event)\"/>&nbsp;/&nbsp;<span>{{page.last}}</span>\n      <button class=\"pagination-next\" [disabled]=\"page.current >= page.last\" (click)=\"page.current = page.current + 1\">\n        <clr-icon shape=\"angle right\"></clr-icon>\n      </button>\n      <button class=\"pagination-last\" [disabled]=\"page.current >= page.last\" (click)=\"page.current = page.last\">\n        <clr-icon shape=\"step-forward-2 up\"></clr-icon>\n      </button>\n    </div>\n    ",
                        host: { '[class.pagination]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridPagination.ctorParameters = function () {
            return [
                { type: Page }
            ];
        };
        ClrDatagridPagination.propDecorators = {
            _pageSizeComponent: [{ type: i0.ContentChild, args: [ClrDatagridPageSize,] }],
            currentPageInputRef: [{ type: i0.ViewChild, args: ['currentPageInput',] }],
            pageSize: [{ type: i0.Input, args: ['clrDgPageSize',] }],
            totalItems: [{ type: i0.Input, args: ['clrDgTotalItems',] }],
            lastPage: [{ type: i0.Input, args: ['clrDgLastPage',] }],
            currentPage: [{ type: i0.Input, args: ['clrDgPage',] }],
            currentChanged: [{ type: i0.Output, args: ['clrDgPageChange',] }]
        };
        return ClrDatagridPagination;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Generic bland container serving various purposes for Datagrid.
     * For instance, it can help span a text over multiple rows in detail view.
     * @template T
     */
    var ClrDatagridRowDetail = /** @class */ (function () {
        function ClrDatagridRowDetail(selection, rowActionService, expand, hideableColumnService, expandableRows) {
            this.selection = selection;
            this.rowActionService = rowActionService;
            this.expand = expand;
            this.hideableColumnService = hideableColumnService;
            this.expandableRows = expandableRows;
            /* reference to the enum so that template can access it */
            this.SELECTION_TYPE = SelectionType;
            this.subscriptions = [];
            this.replacedRow = false;
        }
        Object.defineProperty(ClrDatagridRowDetail.prototype, "replace", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.expand.setReplace(!!value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrDatagridRowDetail.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var columnsList = this.hideableColumnService.getColumns();
                this.updateCellsForColumns(columnsList);
                // Triggered when the Cells list changes per row-renderer
                this.subscriptions.push(this.cells.changes.subscribe(function (cellList) {
                    /** @type {?} */
                    var columnList = _this.hideableColumnService.getColumns();
                    if (cellList.length === columnList.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                }));
                // Used to set things up the first time but only after all the columns are ready.
                this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
                    // Prevents cell updates when cols and cells array are not aligned
                    if (columnList.length === _this.cells.length) {
                        _this.updateCellsForColumns(columnList);
                    }
                }));
                this.subscriptions.push(this.expand.replace.subscribe(function (replaceChange) {
                    _this.replacedRow = replaceChange;
                }));
            };
        /**
         * @param {?} columnList
         * @return {?}
         */
        ClrDatagridRowDetail.prototype.updateCellsForColumns = /**
         * @param {?} columnList
         * @return {?}
         */
            function (columnList) {
                this.cells.forEach(function (cell, index) {
                    /** @type {?} */
                    var currentColumn = columnList[index];
                    if (currentColumn) {
                        cell.id = currentColumn.id;
                    }
                });
            };
        /**
         * @return {?}
         */
        ClrDatagridRowDetail.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDatagridRowDetail.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dg-row-detail',
                        template: "\n        <ng-container *ngIf=\"!replacedRow\">\n            <!-- space for multiselection state -->\n            <div class=\"datagrid-cell datagrid-select datagrid-fixed-column\"\n                *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n            </div>\n            <!-- space for single selection state -->\n            <div class=\"datagrid-cell datagrid-select datagrid-fixed-column\"\n                *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\">\n            </div>\n            <!-- space for single row action; only displayType if we have at least one actionable row in datagrid -->\n            <div class=\"datagrid-cell datagrid-row-actions datagrid-fixed-column\"\n                *ngIf=\"rowActionService.hasActionableRow\">\n            </div>\n            <!-- space for expandable caret action; only displayType if we have at least one expandable row in datagrid -->\n            <div *ngIf=\"expandableRows.hasExpandableRow\"\n                        class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\">\n            </div>\n        </ng-container>\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.datagrid-row-flex]': 'true',
                            '[class.datagrid-row-detail]': 'true',
                            '[class.datagrid-container]': 'cells.length === 0',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDatagridRowDetail.ctorParameters = function () {
            return [
                { type: Selection },
                { type: RowActionService },
                { type: Expand },
                { type: HideableColumnService },
                { type: ExpandableRowsCount }
            ];
        };
        ClrDatagridRowDetail.propDecorators = {
            cells: [{ type: i0.ContentChildren, args: [ClrDatagridCell,] }],
            replace: [{ type: i0.Input, args: ['clrDgReplace',] }]
        };
        return ClrDatagridRowDetail;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var STRICT_WIDTH_CLASS = 'datagrid-fixed-width';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridCellRenderer = /** @class */ (function () {
        function DatagridCellRenderer(el, renderer, organizer) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.subscriptions = [];
            this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
        }
        /**
         * @return {?}
         */
        DatagridCellRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        DatagridCellRenderer.prototype.clearWidth = /**
         * @return {?}
         */
            function () {
                this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                this.renderer.setStyle(this.el.nativeElement, 'width', null);
            };
        /**
         * @param {?} strict
         * @param {?} value
         * @return {?}
         */
        DatagridCellRenderer.prototype.setWidth = /**
         * @param {?} strict
         * @param {?} value
         * @return {?}
         */
            function (strict, value) {
                if (strict) {
                    this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                }
                else {
                    this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                }
                this.renderer.setStyle(this.el.nativeElement, 'width', value + 'px');
            };
        DatagridCellRenderer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-cell' },] }
        ];
        /** @nocollapse */
        DatagridCellRenderer.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: DatagridRenderOrganizer }
            ];
        };
        return DatagridCellRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridColumnResizer = /** @class */ (function () {
        function DatagridColumnResizer(el, renderer, organizer, domAdapter, dragDispatcher, table) {
            this.renderer = renderer;
            this.organizer = organizer;
            this.domAdapter = domAdapter;
            this.dragDispatcher = dragDispatcher;
            this.table = table;
            this.columnResizeBy = 0;
            // relative to pageStartPosition
            this.dragWithinMinWidth = false;
            this.resizeEmitter = new i0.EventEmitter();
            this.subscriptions = [];
            this.columnEl = el.nativeElement;
        }
        /**
         * @return {?}
         */
        DatagridColumnResizer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.dragDispatcher.destroy();
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        DatagridColumnResizer.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.handleTrackerEl = this.dragDispatcher.handleTrackerRef.nativeElement;
                this.dragDispatcher.addDragListener();
                this.subscriptions.push(this.dragDispatcher.onDragStart.subscribe(function () { return _this.dragStartHandler(); }));
                this.subscriptions.push(this.dragDispatcher.onDragMove.subscribe(function ($event) { return _this.dragMoveHandler($event); }));
                this.subscriptions.push(this.dragDispatcher.onDragEnd.subscribe(function () { return _this.dragEndHandler(); }));
            };
        /**
         * @return {?}
         */
        DatagridColumnResizer.prototype.dragStartHandler = /**
         * @return {?}
         */
            function () {
                if (!this.columnMinWidth) {
                    // sets the min width only on the very first drag attempt
                    this.columnMinWidth = this.domAdapter.minWidth(this.columnEl);
                }
                this.renderer.setStyle(this.handleTrackerEl, 'display', 'block');
                this.renderer.setStyle(this.handleTrackerEl, 'height', this.table.getColumnDragHeight());
                this.renderer.setStyle(document.body, 'cursor', 'col-resize');
                this.dragDistancePositionX = 0;
                this.columnRectWidth = this.domAdapter.clientRect(this.columnEl).width;
                this.pageStartPositionX = this.domAdapter.clientRect(this.columnEl).right;
            };
        /**
         * @param {?} moveEvent
         * @return {?}
         */
        DatagridColumnResizer.prototype.dragMoveHandler = /**
         * @param {?} moveEvent
         * @return {?}
         */
            function (moveEvent) {
                /** @type {?} */
                var pageMovePosition = moveEvent.pageX || moveEvent.changedTouches[0].pageX;
                this.dragDistancePositionX = this.getPositionWithinMax(pageMovePosition - this.pageStartPositionX);
                this.renderer.setStyle(this.handleTrackerEl, 'right', -1 * this.dragDistancePositionX + 'px');
            };
        /**
         * @return {?}
         */
        DatagridColumnResizer.prototype.dragEndHandler = /**
         * @return {?}
         */
            function () {
                this.renderer.setStyle(this.handleTrackerEl, 'right', '0px');
                this.renderer.setStyle(this.handleTrackerEl, 'display', 'none');
                this.renderer.setStyle(document.body, 'cursor', 'auto');
                if (this.dragDistancePositionX) {
                    this.columnResizeBy = this.dragDistancePositionX;
                    this.resizeEmitter.emit(this.columnRectWidth + this.columnResizeBy);
                    this.organizer.resize();
                }
            };
        /**
         * @param {?} draggedDistance
         * @return {?}
         */
        DatagridColumnResizer.prototype.getPositionWithinMax = /**
         * @param {?} draggedDistance
         * @return {?}
         */
            function (draggedDistance) {
                if (draggedDistance < 0) {
                    if (Math.abs(draggedDistance) < this.columnRectWidth - this.columnMinWidth) {
                        if (this.dragWithinMinWidth) {
                            this.dragWithinMinWidth = false;
                            this.renderer.removeClass(this.handleTrackerEl, 'exceeded-max');
                        }
                        return draggedDistance;
                    }
                    else {
                        if (!this.dragWithinMinWidth) {
                            this.dragWithinMinWidth = true;
                            this.renderer.addClass(this.handleTrackerEl, 'exceeded-max');
                        }
                        return this.columnMinWidth - this.columnRectWidth;
                    }
                }
                else {
                    if (this.dragWithinMinWidth) {
                        this.dragWithinMinWidth = false;
                        this.renderer.removeClass(this.handleTrackerEl, 'exceeded-max');
                    }
                    return draggedDistance;
                }
            };
        DatagridColumnResizer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-column', providers: [DragDispatcher] },] }
        ];
        /** @nocollapse */
        DatagridColumnResizer.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: DatagridRenderOrganizer },
                { type: DomAdapter },
                { type: DragDispatcher },
                { type: TableSizeService }
            ];
        };
        DatagridColumnResizer.propDecorators = {
            resizeEmitter: [{ type: i0.Output, args: ['clrDgColumnResize',] }]
        };
        return DatagridColumnResizer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridHeaderRenderer = /** @class */ (function () {
        function DatagridHeaderRenderer(el, renderer, organizer, domAdapter, columnResizer) {
            var _this = this;
            this.el = el;
            this.renderer = renderer;
            this.organizer = organizer;
            this.domAdapter = domAdapter;
            this.columnResizer = columnResizer;
            this.widthSet = false;
            this.subscriptions = [];
            this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
            this.subscriptions.push(this.organizer
                .filterRenderSteps(DatagridRenderStep.DETECT_STRICT_WIDTHS)
                .subscribe(function () { return _this.detectStrictWidth(); }));
        }
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.clearWidth = /**
         * @return {?}
         */
            function () {
                // remove the width only if we set it, and it is not changed by dragging.
                if (this.widthSet && !this.columnResizer.columnResizeBy) {
                    this.renderer.setStyle(this.el.nativeElement, 'width', null);
                }
            };
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.detectStrictWidth = /**
         * @return {?}
         */
            function () {
                if (this.columnResizer.columnResizeBy) {
                    this.strictWidth = this.columnResizer.columnRectWidth + this.columnResizer.columnResizeBy;
                }
                else {
                    this.strictWidth = this.domAdapter.userDefinedWidth(this.el.nativeElement);
                }
            };
        /**
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.computeWidth = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var width = this.strictWidth;
                if (!width) {
                    width = this.domAdapter.scrollWidth(this.el.nativeElement);
                }
                return width;
            };
        /**
         * @param {?} width
         * @return {?}
         */
        DatagridHeaderRenderer.prototype.setWidth = /**
         * @param {?} width
         * @return {?}
         */
            function (width) {
                if (this.strictWidth) {
                    if (this.columnResizer.columnResizeBy) {
                        this.renderer.setStyle(this.el.nativeElement, 'width', width + 'px');
                        this.columnResizer.columnResizeBy = 0;
                        this.widthSet = false;
                    }
                    // Don't set width if there is a user-defined one. Just add the strict width class.
                    this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                    return;
                }
                this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
                this.renderer.setStyle(this.el.nativeElement, 'width', width + 'px');
                this.widthSet = true;
            };
        DatagridHeaderRenderer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-column' },] }
        ];
        /** @nocollapse */
        DatagridHeaderRenderer.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: DatagridRenderOrganizer },
                { type: DomAdapter },
                { type: DatagridColumnResizer }
            ];
        };
        return DatagridHeaderRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NoopDomAdapter = /** @class */ (function () {
        function NoopDomAdapter() {
        }
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.userDefinedWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.scrollBarWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.scrollWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.computedHeight = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.clientRect = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    width: 0,
                    height: 0,
                };
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.minWidth = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return 0;
            };
        /**
         * @param {?} element
         * @return {?}
         */
        NoopDomAdapter.prototype.focus = /**
         * @param {?} element
         * @return {?}
         */
            function (element) { };
        NoopDomAdapter.decorators = [
            { type: i0.Injectable }
        ];
        return NoopDomAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // Fixes build error
    // @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
    /** @type {?} */
    var domAdapterFactory = function (platformId) {
        if (common.isPlatformBrowser(platformId)) {
            return new DomAdapter();
        }
        else {
            return new NoopDomAdapter();
        }
    };
    // Fixes build error
    // @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
    /**
     * @template T
     */
    var DatagridMainRenderer = /** @class */ (function () {
        function DatagridMainRenderer(organizer, items, page, domAdapter, el, renderer, tableSizeService) {
            var _this = this;
            this.organizer = organizer;
            this.items = items;
            this.page = page;
            this.domAdapter = domAdapter;
            this.el = el;
            this.renderer = renderer;
            this.tableSizeService = tableSizeService;
            this._heightSet = false;
            this.subscriptions = [];
            /**
             * Indicates if we want to re-compute columns width. This should only happen:
             * 1) When headers change, with columns being added or removed
             * 2) When rows are lazily loaded for the first time
             */
            this.columnsSizesStable = false;
            this.shouldStabilizeColumns = true;
            this.subscriptions.push(this.organizer
                .filterRenderSteps(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS)
                .subscribe(function () { return _this.computeHeadersWidth(); }));
            this.subscriptions.push(this.page.sizeChange.subscribe(function () {
                if (_this._heightSet) {
                    _this.resetDatagridHeight();
                }
            }));
            this.subscriptions.push(this.items.change.subscribe(function () { return (_this.shouldStabilizeColumns = true); }));
        }
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.subscriptions.push(this.headers.changes.subscribe(function () {
                    // TODO: only re-stabilize if a column was added or removed. Reordering is fine.
                    _this.columnsSizesStable = false;
                    _this.stabilizeColumns();
                }));
            };
        // Initialize and set Table width for horizontal scrolling here.
        // Initialize and set Table width for horizontal scrolling here.
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngAfterViewInit =
            // Initialize and set Table width for horizontal scrolling here.
            /**
             * @return {?}
             */
            function () {
                this.tableSizeService.table = this.el;
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.shouldStabilizeColumns) {
                    this.stabilizeColumns();
                }
                if (this.shouldComputeHeight()) {
                    setTimeout(function () {
                        _this.computeDatagridHeight();
                    });
                }
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.shouldComputeHeight = /**
         * @return {?}
         */
            function () {
                if (!this._heightSet && this.page.size > 0) {
                    if (this.items.displayed.length === this.page.size) {
                        return true;
                    }
                }
                return false;
            };
        /**
         * Computes the height of the datagrid.
         *
         * NOTE: We had to choose to set the height instead of the min-height because
         * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
         * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
         * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
         *
         * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
         */
        /**
         * Computes the height of the datagrid.
         *
         * NOTE: We had to choose to set the height instead of the min-height because
         * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
         * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
         * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
         *
         * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
         * @return {?}
         */
        DatagridMainRenderer.prototype.computeDatagridHeight = /**
         * Computes the height of the datagrid.
         *
         * NOTE: We had to choose to set the height instead of the min-height because
         * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
         * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
         * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
         *
         * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
         * @return {?}
         */
            function () {
                // IE doesn't return correct value for getComputedStyle(element).getPropertyValue("height")
                /** @type {?} */
                var value = this.domAdapter.clientRect(this.el.nativeElement).height;
                this.renderer.setStyle(this.el.nativeElement, 'height', value + 'px');
                this._heightSet = true;
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.resetDatagridHeight = /**
         * @return {?}
         */
            function () {
                this.renderer.setStyle(this.el.nativeElement, 'height', '');
                this._heightSet = false;
            };
        /**
         * @return {?}
         */
        DatagridMainRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * Makes each header compute its width.
         */
        /**
         * Makes each header compute its width.
         * @return {?}
         */
        DatagridMainRenderer.prototype.computeHeadersWidth = /**
         * Makes each header compute its width.
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var nbColumns = this.headers.length;
                /** @type {?} */
                var allStrict = true;
                this.headers.forEach(function (header, index) {
                    // On the last header column check whether all columns have strict widths.
                    // If all columns have strict widths, remove the strict width from the last column and make it the column's
                    // minimum width so that when all previous columns shrink, it will get a flexible width and cover the empty
                    // gap in the Datagrid.
                    if (!header.strictWidth) {
                        allStrict = false;
                    }
                    if (nbColumns === index + 1 && allStrict) {
                        delete header.strictWidth;
                    }
                    _this.organizer.widths[index] = { px: header.computeWidth(), strict: !!header.strictWidth };
                });
                this.headers.forEach(function (header, index) { return header.setWidth(_this.organizer.widths[index].px); });
            };
        /**
         * Triggers a whole re-rendring cycle to set column sizes, if needed.
         */
        /**
         * Triggers a whole re-rendring cycle to set column sizes, if needed.
         * @return {?}
         */
        DatagridMainRenderer.prototype.stabilizeColumns = /**
         * Triggers a whole re-rendring cycle to set column sizes, if needed.
         * @return {?}
         */
            function () {
                this.shouldStabilizeColumns = false;
                if (this.columnsSizesStable) {
                    // Nothing to do.
                    return;
                }
                // Resize when the rows are loaded.
                if (this.items.displayed.length > 0) {
                    this.organizer.resize();
                    this.columnsSizesStable = true;
                }
            };
        DatagridMainRenderer.decorators = [
            { type: i0.Directive, args: [{
                        selector: 'clr-datagrid',
                        providers: [{ provide: DomAdapter, useFactory: domAdapterFactory, deps: [i0.PLATFORM_ID] }],
                    },] }
        ];
        /** @nocollapse */
        DatagridMainRenderer.ctorParameters = function () {
            return [
                { type: DatagridRenderOrganizer },
                { type: Items },
                { type: Page },
                { type: DomAdapter },
                { type: i0.ElementRef },
                { type: i0.Renderer2 },
                { type: TableSizeService }
            ];
        };
        DatagridMainRenderer.propDecorators = {
            headers: [{ type: i0.ContentChildren, args: [DatagridHeaderRenderer,] }],
            columns: [{ type: i0.ContentChildren, args: [ClrDatagridColumn,] }]
        };
        return DatagridMainRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var DatagridRowRenderer = /** @class */ (function () {
        function DatagridRowRenderer(organizer) {
            var _this = this;
            this.organizer = organizer;
            this.subscriptions = [];
            this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.ALIGN_COLUMNS).subscribe(function () { return _this.setWidths(); }));
        }
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.setWidths = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.organizer.widths.length !== this.cells.length) {
                    return;
                }
                this.cells.forEach(function (cell, index) {
                    /** @type {?} */
                    var width = _this.organizer.widths[index];
                    cell.setWidth(width.strict, width.px);
                });
            };
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.cells.changes.subscribe(function () {
                    _this.setWidths();
                });
            };
        /**
         * @return {?}
         */
        DatagridRowRenderer.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.setWidths();
            };
        DatagridRowRenderer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-dg-row, clr-dg-row-detail' },] }
        ];
        /** @nocollapse */
        DatagridRowRenderer.ctorParameters = function () {
            return [
                { type: DatagridRenderOrganizer }
            ];
        };
        DatagridRowRenderer.propDecorators = {
            cells: [{ type: i0.ContentChildren, args: [DatagridCellRenderer,] }]
        };
        return DatagridRowRenderer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DATAGRID_DIRECTIVES = [
        // Core
        ClrDatagrid,
        ClrDatagridActionBar,
        ClrDatagridActionOverflow,
        ClrDatagridColumn,
        ClrDatagridColumnToggle,
        ClrDatagridHideableColumn,
        ClrDatagridFilter,
        ClrDatagridItems,
        ClrDatagridItemsTrackBy,
        ClrDatagridRow,
        ClrDatagridRowDetail,
        DatagridDetailRegisterer,
        ClrDatagridCell,
        ClrDatagridFooter,
        ClrDatagridPagination,
        ClrDatagridPageSize,
        ClrDatagridPlaceholder,
        ClrDatagridColumnToggleButton,
        ClrDatagridColumnToggleTitle,
        WrappedCell,
        WrappedColumn,
        WrappedRow,
        // Renderers
        DatagridMainRenderer,
        DatagridHeaderRenderer,
        DatagridColumnResizer,
        DatagridRowRenderer,
        DatagridCellRenderer,
        // Chocolate
        DatagridWillyWonka,
        ActionableOompaLoompa,
        ExpandableOompaLoompa,
        // Animation hack
        DatagridRowExpandAnimation,
        // Built-in shortcuts
        DatagridStringFilter,
    ];
    var ClrDatagridModule = /** @class */ (function () {
        function ClrDatagridModule() {
        }
        ClrDatagridModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ClrIconModule,
                            ClrFormsModule,
                            forms.FormsModule,
                            ClrCommonPopoverModule,
                            ClrLoadingModule,
                            ClrOutsideClickModule,
                        ],
                        declarations: [CLR_DATAGRID_DIRECTIVES],
                        exports: [CLR_DATAGRID_DIRECTIVES, ClrIfExpandModule],
                        entryComponents: [WrappedCell, WrappedColumn, WrappedRow],
                    },] }
        ];
        return ClrDatagridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackBlock = /** @class */ (function () {
        /*
           * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
           * querying for children StackBlocks, but this feature is not available when downgrading
           * the component for Angular 1.
           */
        function ClrStackBlock(parent, commonStrings) {
            this.parent = parent;
            this.commonStrings = commonStrings;
            this.expanded = false;
            this.expandedChange = new i0.EventEmitter(false);
            this.expandable = false;
            this.focused = false;
            this._changedChildren = 0;
            this._fullyInitialized = false;
            this._changed = false;
            if (parent) {
                parent.addChild();
            }
        }
        Object.defineProperty(ClrStackBlock.prototype, "getChangedValue", {
            get: /**
             * @return {?}
             */ function () {
                return this._changed || (this._changedChildren > 0 && !this.expanded);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "setChangedValue", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._changed = value;
                if (this.parent && this._fullyInitialized) {
                    if (value) {
                        this.parent._changedChildren++;
                    }
                    else {
                        this.parent._changedChildren--;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrStackBlock.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // in order to access the parent ClrStackBlock's properties,
                // the child ClrStackBlock  has to be fully initialized at first.
                this._fullyInitialized = true;
            };
        /**
         * @return {?}
         */
        ClrStackBlock.prototype.addChild = /**
         * @return {?}
         */
            function () {
                this.expandable = true;
            };
        /**
         * @return {?}
         */
        ClrStackBlock.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                if (this.expandable) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        Object.defineProperty(ClrStackBlock.prototype, "caretDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.expanded ? 'down' : 'right';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "caretTitle", {
            get: /**
             * @return {?}
             */ function () {
                return this.expanded ? this.commonStrings.collapse : this.commonStrings.expand;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "role", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandable ? 'button' : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "tabIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandable ? '0' : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "onStackLabelFocus", {
            get: /**
             * @return {?}
             */ function () {
                return this.expandable && !this.expanded && this.focused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrStackBlock.prototype, "ariaExpanded", {
            get: /**
             * @return {?}
             */ function () {
                if (!this.expandable) {
                    return null;
                }
                else {
                    return this.expanded ? 'true' : 'false';
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrStackBlock.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-block',
                        template: "\n    <dt class=\"stack-block-label\"\n        (click)=\"toggleExpand()\"\n        (keyup.enter)=\"toggleExpand()\"\n        (keyup.space)=\"toggleExpand()\"\n        (focus)=\"focused = true\"\n        (blur)=\"focused = false\"\n        [attr.role]=\"role\"\n        [attr.tabindex]=\"tabIndex\"\n        [attr.aria-expanded]=\"ariaExpanded\">\n      <clr-icon shape=\"caret\"\n                class=\"stack-block-caret\"\n                *ngIf=\"expandable\"\n                [attr.dir]=\"caretDirection\"\n                [attr.title]=\"caretTitle\"></clr-icon>\n      <ng-content select=\"clr-stack-label\"></ng-content>\n    </dt>\n    <dd class=\"stack-block-content\">\n      <ng-content></ng-content>\n    </dd>\n    <!-- FIXME: remove this string concatenation when boolean states are supported -->\n    <div [@collapse]=\"''+!expanded\" class=\"stack-children\" >\n      <ng-content select=\"clr-stack-block\"></ng-content>\n    </div>\n  ",
                        // Make sure the host has the proper class for styling purposes
                        host: { '[class.stack-block]': 'true' },
                        animations: [
                            animations.trigger('collapse', [
                                animations.state('true', animations.style({ height: 0, display: 'none' })),
                                animations.transition('true => false', [animations.animate('0.2s ease-in-out', animations.style({ height: '*', display: '*' }))]),
                                animations.transition('false => true', [animations.style({ height: '*', display: '*' }), animations.animate('0.2s ease-in-out')]),
                            ]),
                        ],
                        styles: ["\n        :host { display: block; }\n    "]
                    }] }
        ];
        /** @nocollapse */
        ClrStackBlock.ctorParameters = function () {
            return [
                { type: ClrStackBlock, decorators: [{ type: i0.SkipSelf }, { type: i0.Optional }] },
                { type: ClrCommonStrings }
            ];
        };
        ClrStackBlock.propDecorators = {
            expanded: [{ type: i0.HostBinding, args: ['class.stack-block-expanded',] }, { type: i0.Input, args: ['clrSbExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrSbExpandedChange',] }],
            expandable: [{ type: i0.HostBinding, args: ['class.stack-block-expandable',] }, { type: i0.Input, args: ['clrSbExpandable',] }],
            getChangedValue: [{ type: i0.HostBinding, args: ['class.stack-block-changed',] }],
            setChangedValue: [{ type: i0.Input, args: ['clrSbNotifyChange',] }],
            onStackLabelFocus: [{ type: i0.HostBinding, args: ['class.on-focus',] }]
        };
        return ClrStackBlock;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackView = /** @class */ (function () {
        function ClrStackView() {
            /**
             * Undocumented experimental feature: inline editing.
             */
            this.editable = false;
            this.save = new i0.EventEmitter(false);
            this._editMode = false;
            this.editingChange = new i0.EventEmitter(false);
            /**
             * End of undocumented experimental feature.
             */
        }
        Object.defineProperty(ClrStackView.prototype, "editing", {
            get: /**
             * @return {?}
             */ function () {
                return this.editable && this._editMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this.editable) {
                    this._editMode = value;
                    this.editingChange.emit(value);
                    if (!value) {
                        this.save.emit(null);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrStackView.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-view',
                        template: "\n        <ng-content select=\"clr-stack-header\"></ng-content>\n        <dl class=\"stack-view\"><ng-content></ng-content></dl>\n    ",
                        styles: ["\n        :host { display: block; }\n    "]
                    }] }
        ];
        ClrStackView.propDecorators = {
            save: [{ type: i0.Output, args: ['clrStackSave',] }]
        };
        return ClrStackView;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackHeader = /** @class */ (function () {
        function ClrStackHeader(stackView) {
            this.stackView = stackView;
        }
        ClrStackHeader.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-header',
                        template: "\n        <h4 class=\"stack-header\">\n            <span class=\"stack-title\"><ng-content></ng-content></span>\n            \n            <span class=\"stack-actions\">\n                <ng-content select=\".stack-action\"></ng-content>\n                <!-- Undocumented experimental feature: inline editing. -->\n                <button *ngIf=\"stackView.editable\" class=\"stack-action btn btn-sm btn-link\" \n                        (click)=\"stackView.editing = !stackView.editing\" type=\"button\">\n                        Edit\n                </button>\n                <!-- End of undocumented experimental feature. -->\n            </span>\n        </h4>\n    ",
                        styles: ["\n        :host { display: block; }\n    "]
                    }] }
        ];
        /** @nocollapse */
        ClrStackHeader.ctorParameters = function () {
            return [
                { type: ClrStackView }
            ];
        };
        return ClrStackHeader;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var StackControl = /** @class */ (function () {
        function StackControl(stackView) {
            var _this = this;
            this.stackView = stackView;
            this.modelChange = new i0.EventEmitter(false);
            // Make the ClrStackView editable, since it contains a StackControl
            this.stackView.editable = true;
            this.stackView.editingChange.subscribe(function (editing) {
                // Edit mode was closed
                if (!editing) {
                    _this.modelChange.emit(_this.model);
                }
            });
        }
        return StackControl;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackInput = /** @class */ (function (_super) {
        __extends(ClrStackInput, _super);
        function ClrStackInput(stackView) {
            var _this = _super.call(this, stackView) || this;
            _this.stackView = stackView;
            _this.type = 'text';
            return _this;
        }
        ClrStackInput.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-input',
                        inputs: ['model: clrModel', 'type'],
                        outputs: ['modelChange: clrModelChange'],
                        template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <input [type]=\"type\" *ngIf=\"stackView.editing\" [(ngModel)]=\"model\"/>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrStackInput.ctorParameters = function () {
            return [
                { type: ClrStackView }
            ];
        };
        return ClrStackInput;
    }(StackControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackSelect = /** @class */ (function (_super) {
        __extends(ClrStackSelect, _super);
        function ClrStackSelect(stackView) {
            var _this = _super.call(this, stackView) || this;
            _this.stackView = stackView;
            return _this;
        }
        ClrStackSelect.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-stack-select',
                        inputs: ['model: clrModel'],
                        outputs: ['modelChange: clrModelChange'],
                        template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <div class=\"select\" *ngIf=\"stackView.editing\" >\n            <select [(ngModel)]=\"model\">\n                <ng-content></ng-content>\n            </select>\n        </div>\n    "
                    }] }
        ];
        /** @nocollapse */
        ClrStackSelect.ctorParameters = function () {
            return [
                { type: ClrStackView }
            ];
        };
        return ClrStackSelect;
    }(StackControl));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrStackViewCustomTags = /** @class */ (function () {
        function ClrStackViewCustomTags() {
        }
        ClrStackViewCustomTags.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-stack-label, clr-stack-content' },] }
        ];
        return ClrStackViewCustomTags;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_STACK_VIEW_DIRECTIVES = [
        ClrStackView,
        ClrStackHeader,
        ClrStackBlock,
        ClrStackViewCustomTags,
        /**
         * Undocumented experimental feature: inline editing.
         */
        ClrStackInput,
        ClrStackSelect,
    ];
    var ClrStackViewModule = /** @class */ (function () {
        function ClrStackViewModule() {
        }
        ClrStackViewModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, ClrIconModule],
                        declarations: [CLR_STACK_VIEW_DIRECTIVES],
                        exports: [CLR_STACK_VIEW_DIRECTIVES],
                    },] }
        ];
        return ClrStackViewModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var NB_INSTANCES = 0;
    /** @type {?} */
    var UNIQUE_ID = new i0.InjectionToken('UNIQUE_ID');
    /**
     * @return {?}
     */
    function uniqueIdFactory() {
        return 'clr-id-' + NB_INSTANCES++;
    }
    /** @type {?} */
    var UNIQUE_ID_PROVIDER = {
        provide: UNIQUE_ID,
        useFactory: uniqueIdFactory,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ AbstractTreeSelection = /** @class */ (function () {
        function AbstractTreeSelection(parent) {
            this.parent = parent;
            this._selected = false;
            this._indeterminate = false;
        }
        Object.defineProperty(AbstractTreeSelection.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._selected = value;
                this.indeterminate = false;
                this.children.forEach(function (child) { return child.parentChanged(value); });
                if (this.parent) {
                    this.parent.childChanged();
                }
                this.selectedChanged();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractTreeSelection.prototype, "indeterminate", {
            get: /**
             * @return {?}
             */ function () {
                return this._indeterminate;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this._indeterminate !== value) {
                    this._indeterminate = value;
                    this.indeterminateChanged();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        AbstractTreeSelection.prototype.childChanged = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                /** @type {?} */
                var oneSelectedChild = false;
                /** @type {?} */
                var previousSelectedValue = this._selected;
                /** @type {?} */
                var previousIndeterminateValue = this._indeterminate;
                this._selected = true;
                this._indeterminate = false;
                try {
                    for (var _b = __values(this.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        if (child.indeterminate) {
                            this._selected = false;
                            this._indeterminate = true;
                            break;
                        }
                        if (child.selected) {
                            oneSelectedChild = true;
                            if (this._selected === false) {
                                this._indeterminate = true;
                                break;
                            }
                        }
                        else {
                            this._selected = false;
                            if (oneSelectedChild) {
                                this._indeterminate = true;
                                break;
                            }
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                if (this.parent &&
                    (this._selected !== previousSelectedValue || this._indeterminate !== previousIndeterminateValue)) {
                    this.parent.childChanged();
                }
                if (this.selected !== previousSelectedValue) {
                    this.selectedChanged();
                }
                if (this.indeterminate !== previousIndeterminateValue) {
                    this.indeterminateChanged();
                }
            };
        /**
         * @param {?} selected
         * @return {?}
         */
        AbstractTreeSelection.prototype.parentChanged = /**
         * @param {?} selected
         * @return {?}
         */
            function (selected) {
                if (selected && !this.selected) {
                    this._selected = true;
                    this.indeterminate = false;
                    this.children.forEach(function (child) { return child.parentChanged(true); });
                    this.selectedChanged();
                }
                if (!selected && (this.selected || this.indeterminate)) {
                    this._selected = false;
                    this.indeterminate = false;
                    this.children.forEach(function (child) { return child.parentChanged(false); });
                    this.selectedChanged();
                }
            };
        return AbstractTreeSelection;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TreeSelectionService = /** @class */ (function () {
        function TreeSelectionService() {
            this.selectable = false;
        }
        TreeSelectionService.decorators = [
            { type: i0.Injectable }
        ];
        return TreeSelectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} existing
     * @return {?}
     */
    function clrTreeSelectionProviderFactory(existing) {
        return existing || new TreeSelectionService();
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ɵ0 = clrTreeSelectionProviderFactory;
    var ClrTreeNode = /** @class */ (function (_super) {
        __extends(ClrTreeNode, _super);
        function ClrTreeNode(nodeExpand, parent, treeSelectionService, nodeId, commonStrings) {
            var _this = _super.call(this, parent) || this;
            _this.nodeExpand = nodeExpand;
            _this.parent = parent;
            _this.treeSelectionService = treeSelectionService;
            _this.nodeId = nodeId;
            _this.commonStrings = commonStrings;
            _this._children = [];
            _this.nodeSelectedChange = new i0.EventEmitter(true);
            _this.nodeIndeterminateChanged = new i0.EventEmitter(true);
            if (_this.parent) {
                _this.parent.register(_this);
            }
            return _this;
        }
        Object.defineProperty(ClrTreeNode.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        /* Registration */
        /* Registration */
        /**
         * @param {?} node
         * @return {?}
         */
        ClrTreeNode.prototype.checkIfChildNodeRegistered = /* Registration */
            /**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                return this.children.indexOf(node) > -1;
            };
        // TODO: This should ideally be in AbstractTreeSelection
        // Tried doing this but ran into some issues and also ran out of time.
        // Will get this done later.
        // TODO: This should ideally be in AbstractTreeSelection
        // Tried doing this but ran into some issues and also ran out of time.
        // Will get this done later.
        /**
         * @param {?} node
         * @return {?}
         */
        ClrTreeNode.prototype.register =
            // TODO: This should ideally be in AbstractTreeSelection
            // Tried doing this but ran into some issues and also ran out of time.
            // Will get this done later.
            /**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                if (!this.checkIfChildNodeRegistered(node)) {
                    this.children.push(node);
                    if (this.selectable) {
                        if (this.selected) {
                            node.parentChanged(this.selected);
                        }
                    }
                }
            };
        // TODO: This should ideally be in AbstractTreeSelection
        // Tried doing this but ran into some issues and also ran out of time.
        // Will get this done later.
        // TODO: This should ideally be in AbstractTreeSelection
        // Tried doing this but ran into some issues and also ran out of time.
        // Will get this done later.
        /**
         * @param {?} node
         * @return {?}
         */
        ClrTreeNode.prototype.unregister =
            // TODO: This should ideally be in AbstractTreeSelection
            // Tried doing this but ran into some issues and also ran out of time.
            // Will get this done later.
            /**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                /** @type {?} */
                var index = this.children.indexOf(node);
                if (index > -1) {
                    this.children.splice(index, 1);
                }
            };
        /* Selection */
        /* Selection */
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.activateSelection = /* Selection */
            /**
             * @return {?}
             */
            function () {
                if (this.treeSelectionService && !this.treeSelectionService.selectable) {
                    this.treeSelectionService.selectable = true;
                }
            };
        Object.defineProperty(ClrTreeNode.prototype, "nodeSelected", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // required for recursive trees to discard unset inputs.
                this.activateSelection();
                if (value === undefined || value === null) {
                    return;
                }
                if (this.selected !== value) {
                    this.selected = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.selectedChanged = /**
         * @return {?}
         */
            function () {
                this.nodeSelectedChange.emit(this.selected);
            };
        Object.defineProperty(ClrTreeNode.prototype, "selectable", {
            get: /**
             * @return {?}
             */ function () {
                if (this.treeSelectionService) {
                    return this.treeSelectionService.selectable;
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "nodeIndeterminate", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.indeterminate = value;
                this.activateSelection();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.indeterminateChanged = /**
         * @return {?}
         */
            function () {
                this.nodeIndeterminateChanged.emit(this.indeterminate);
            };
        /* Expansion */
        /* Expansion */
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.toggleExpand = /* Expansion */
            /**
             * @return {?}
             */
            function () {
                this.nodeExpand.expanded = !this.nodeExpand.expanded;
            };
        Object.defineProperty(ClrTreeNode.prototype, "caretDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.nodeExpand.expanded ? 'down' : 'right';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "caretTitle", {
            get: /**
             * @return {?}
             */ function () {
                return this.nodeExpand.expanded ? this.commonStrings.collapse : this.commonStrings.expand;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this.nodeExpand.expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this.nodeExpand.expanded !== value) {
                    this.nodeExpand.expanded = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "state", {
            get: /**
             * @return {?}
             */ function () {
                return this.expanded && !this.nodeExpand.loading ? 'expanded' : 'collapsed';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "treeNodeRole", {
            get: /**
             * @return {?}
             */ function () {
                return this.parent ? 'treeitem' : 'tree';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "rootAriaMultiSelectable", {
            get: /**
             * @return {?}
             */ function () {
                if (this.parent || !this.selectable) {
                    return null;
                }
                else {
                    return true;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "ariaSelected", {
            get: /**
             * @return {?}
             */ function () {
                return this.selectable ? this.selected : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTreeNode.prototype, "ariaTreeNodeChildrenRole", {
            get: /**
             * @return {?}
             */ function () {
                return this.children.length > 0 ? 'group' : null;
            },
            enumerable: true,
            configurable: true
        });
        /* Lifecycle */
        /* Lifecycle */
        /**
         * @return {?}
         */
        ClrTreeNode.prototype.ngOnDestroy = /* Lifecycle */
            /**
             * @return {?}
             */
            function () {
                if (this.parent) {
                    this.parent.unregister(this);
                }
            };
        ClrTreeNode.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tree-node',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"clr-tree-node-content-container\">\n    <button\n        type=\"button\"\n        class=\"clr-treenode-caret\"\n        (click)=\"toggleExpand()\"\n        *ngIf=\"nodeExpand.expandable && !nodeExpand.loading\"\n        [attr.aria-expanded]=\"nodeExpand.expanded\">\n        <clr-icon\n            class=\"clr-treenode-caret-icon\"\n            shape=\"caret\"\n            [attr.dir]=\"caretDirection\"\n            [attr.title]=\"caretTitle\"></clr-icon>\n    </button>\n    <div class=\"clr-treenode-spinner-container\" *ngIf=\"nodeExpand.expandable && nodeExpand.loading\">\n        <span class=\"clr-treenode-spinner spinner\">\n            Loading...\n        </span>\n    </div>\n    <input type=\"checkbox\" clrCheckbox *ngIf=\"selectable\" [class.clr-indeterminate]=\"indeterminate\" [(ngModel)]=\"selected\" [attr.aria-labeledby]=\"nodeId\" />\n    <div class=\"clr-treenode-content\" [id]=\"nodeId\">\n        <ng-content></ng-content>\n    </div>\n</div>\n<!-- FIXME: remove this string concatenation when boolean states are supported -->\n<div\n    class=\"clr-treenode-children\"\n    [@childNodesState]=\"state\"\n    [attr.role]=\"ariaTreeNodeChildrenRole\">\n    <ng-content select=\"clr-tree-node\"></ng-content>\n    <ng-content select=\"[clrIfExpanded]\"></ng-content>\n</div>\n",
                        providers: [
                            Expand,
                            { provide: LoadingListener, useExisting: Expand },
                            {
                                provide: TreeSelectionService,
                                useFactory: ɵ0,
                                deps: [[new i0.Optional(), new i0.SkipSelf(), TreeSelectionService]],
                            },
                            UNIQUE_ID_PROVIDER,
                        ],
                        animations: [
                            animations.trigger('childNodesState', [
                                animations.state('expanded', animations.style({ height: '*', 'overflow-y': 'hidden' })),
                                animations.state('collapsed', animations.style({ height: 0, 'overflow-y': 'hidden' })),
                                animations.transition('expanded <=> collapsed', animations.animate('0.2s ease-in-out')),
                            ]),
                        ],
                        host: { '[class.clr-tree-node]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrTreeNode.ctorParameters = function () {
            return [
                { type: Expand },
                { type: ClrTreeNode, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
                { type: TreeSelectionService },
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] },
                { type: ClrCommonStrings }
            ];
        };
        ClrTreeNode.propDecorators = {
            nodeSelected: [{ type: i0.Input, args: ['clrSelected',] }],
            nodeSelectedChange: [{ type: i0.Output, args: ['clrSelectedChange',] }],
            nodeIndeterminate: [{ type: i0.Input, args: ['clrIndeterminate',] }],
            nodeIndeterminateChanged: [{ type: i0.Output, args: ['clrIndeterminateChange',] }],
            treeNodeRole: [{ type: i0.HostBinding, args: ['attr.role',] }],
            rootAriaMultiSelectable: [{ type: i0.HostBinding, args: ['attr.aria-multiselectable',] }],
            ariaSelected: [{ type: i0.HostBinding, args: ['attr.aria-selected',] }]
        };
        return ClrTreeNode;
    }(AbstractTreeSelection));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_TREE_VIEW_DIRECTIVES = [ClrTreeNode];
    var ClrTreeViewModule = /** @class */ (function () {
        function ClrTreeViewModule() {
        }
        ClrTreeViewModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, forms.FormsModule, ClrFormsModule],
                        declarations: [CLR_TREE_VIEW_DIRECTIVES],
                        exports: [CLR_TREE_VIEW_DIRECTIVES, ClrIfExpandModule],
                    },] }
        ];
        return ClrTreeViewModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDataModule = /** @class */ (function () {
        function ClrDataModule() {
        }
        ClrDataModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule] },] }
        ];
        return ClrDataModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This class is used to convert an internal event
    // to an external event to be emitted.
    /**
     * @template T
     */
    var  
    // This class is used to convert an internal event
    // to an external event to be emitted.
    /**
     * @template T
     */
    ClrDragEvent = /** @class */ (function () {
        function ClrDragEvent(dragEvent) {
            this.dragPosition = dragEvent.dragPosition;
            this.group = dragEvent.group;
            this.dragDataTransfer = dragEvent.dragDataTransfer;
            this.dropPointPosition = dragEvent.dropPointPosition;
        }
        return ClrDragEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var DragEventType = {
        DRAG_START: 0,
        DRAG_MOVE: 1,
        DRAG_END: 2,
        DRAG_ENTER: 3,
        DRAG_LEAVE: 4,
        DROP: 5,
    };
    DragEventType[DragEventType.DRAG_START] = 'DRAG_START';
    DragEventType[DragEventType.DRAG_MOVE] = 'DRAG_MOVE';
    DragEventType[DragEventType.DRAG_END] = 'DRAG_END';
    DragEventType[DragEventType.DRAG_ENTER] = 'DRAG_ENTER';
    DragEventType[DragEventType.DRAG_LEAVE] = 'DRAG_LEAVE';
    DragEventType[DragEventType.DROP] = 'DROP';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DragAndDropEventBusService = /** @class */ (function () {
        function DragAndDropEventBusService() {
            this.dragStart = new rxjs.Subject();
            this.dragMove = new rxjs.Subject();
            this.dragEnd = new rxjs.Subject();
            this.drop = new rxjs.Subject();
        }
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragStarted", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragStart.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragMoved", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragMove.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dragEnded", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragEnd.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragAndDropEventBusService.prototype, "dropped", {
            get: /**
             * @return {?}
             */ function () {
                return this.drop.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        DragAndDropEventBusService.prototype.broadcast = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.type) {
                    case DragEventType.DRAG_START:
                        this.dragStart.next(event);
                        break;
                    case DragEventType.DRAG_MOVE:
                        this.dragMove.next(event);
                        break;
                    case DragEventType.DRAG_END:
                        this.dragEnd.next(event);
                        break;
                    case DragEventType.DROP:
                        this.drop.next(event);
                        break;
                    default:
                        break;
                }
            };
        DragAndDropEventBusService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */ DragAndDropEventBusService.ngInjectableDef = i0.defineInjectable({ factory: function DragAndDropEventBusService_Factory() { return new DragAndDropEventBusService(); }, token: DragAndDropEventBusService, providedIn: "root" });
        return DragAndDropEventBusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var DragEventListenerService = /** @class */ (function () {
        function DragEventListenerService(ngZone, renderer, eventBus) {
            this.ngZone = ngZone;
            this.renderer = renderer;
            this.eventBus = eventBus;
            this.dragStart = new rxjs.Subject();
            this.dragMove = new rxjs.Subject();
            this.dragEnd = new rxjs.Subject();
            this.hasDragStarted = false;
        }
        Object.defineProperty(DragEventListenerService.prototype, "dragStarted", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragStart.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragEventListenerService.prototype, "dragMoved", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragMove.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DragEventListenerService.prototype, "dragEnded", {
            get: /**
             * @return {?}
             */ function () {
                return this.dragEnd.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} draggableEl
         * @return {?}
         */
        DragEventListenerService.prototype.attachDragListeners = /**
         * @param {?} draggableEl
         * @return {?}
         */
            function (draggableEl) {
                this.draggableEl = draggableEl;
                this.listeners = [
                    this.customDragEvent(this.draggableEl, 'mousedown', 'mousemove', 'mouseup'),
                    this.customDragEvent(this.draggableEl, 'touchstart', 'touchmove', 'touchend'),
                ];
            };
        /**
         * @return {?}
         */
        DragEventListenerService.prototype.detachDragListeners = /**
         * @return {?}
         */
            function () {
                if (this.listeners) {
                    this.listeners.map(function (event) { return event(); });
                }
                // In most cases, once users start dragging with mousedown/touchstart events,
                // they will end dragging at one point with mouseup/touchend.
                // However, there might be a few cases where mousedown/touchstart events get registered,
                // but the draggable element gets removed before user ends dragging.
                // In that case, we need to remove the attached listeners that happened during the mousedown/touchstart events.
                if (this.nestedListeners) {
                    this.nestedListeners.map(function (event) { return event(); });
                }
            };
        /**
         * @param {?} element
         * @param {?} startOnEvent
         * @param {?} moveOnEvent
         * @param {?} endOnEvent
         * @return {?}
         */
        DragEventListenerService.prototype.customDragEvent = /**
         * @param {?} element
         * @param {?} startOnEvent
         * @param {?} moveOnEvent
         * @param {?} endOnEvent
         * @return {?}
         */
            function (element, startOnEvent, moveOnEvent, endOnEvent) {
                var _this = this;
                return this.renderer.listen(element, startOnEvent, function () {
                    // Initialize nested listeners' property with a new empty array;
                    _this.nestedListeners = [];
                    // This is needed to disable selection during dragging (especially in EDGE/IE11).
                    _this.nestedListeners.push(_this.renderer.listen('document', 'selectstart', function (selectEvent) {
                        selectEvent.preventDefault();
                        selectEvent.stopImmediatePropagation();
                    }));
                    // Listen to mousemove/touchmove events outside of angular zone.
                    _this.nestedListeners.push(_this.ngZone.runOutsideAngular(function () {
                        return _this.renderer.listen('document', moveOnEvent, function (moveEvent) {
                            // Event.stopImmediatePropagation() is needed here to prevent nested draggables from getting dragged
                            // altogether. We shouldn't use Event.stopPropagation() here as we are listening to the events
                            // on the global element level.
                            // With Event.stopImmediatePropagation(), it registers the events sent from the inner most draggable
                            // first. Then immediately after that, it stops listening to the same type of events on the same
                            // element. So this will help us to not register the same events that would come from the parent
                            // level draggables eventually.
                            moveEvent.stopImmediatePropagation();
                            if (!_this.hasDragStarted) {
                                _this.hasDragStarted = true;
                                // Fire "dragstart"
                                _this.broadcast(moveEvent, DragEventType.DRAG_START);
                            }
                            else {
                                // Fire "dragmove"
                                _this.broadcast(moveEvent, DragEventType.DRAG_MOVE);
                            }
                        });
                    }));
                    // Listen to mouseup/touchend events.
                    _this.nestedListeners.push(_this.renderer.listen('document', endOnEvent, function (endEvent) {
                        if (_this.hasDragStarted) {
                            // Fire "dragend" only if dragstart is registered
                            _this.hasDragStarted = false;
                            _this.broadcast(endEvent, DragEventType.DRAG_END);
                        }
                        // We must remove the the nested listeners every time drag completes.
                        if (_this.nestedListeners) {
                            _this.nestedListeners.map(function (event) { return event(); });
                        }
                    }));
                });
            };
        /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
        DragEventListenerService.prototype.broadcast = /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
            function (event, eventType) {
                /** @type {?} */
                var dragEvent = this.generateDragEvent(event, eventType);
                switch (dragEvent.type) {
                    case DragEventType.DRAG_START:
                        this.dragStart.next(dragEvent);
                        break;
                    case DragEventType.DRAG_MOVE:
                        this.dragMove.next(dragEvent);
                        break;
                    case DragEventType.DRAG_END:
                        this.dragEnd.next(dragEvent);
                        break;
                    default:
                        break;
                }
                // The following properties are set after they are broadcasted to the DraggableGhost component.
                dragEvent.ghostElement = this.ghostElement;
                dragEvent.dropPointPosition = this.dropPointPosition;
                this.eventBus.broadcast(dragEvent);
            };
        /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
        DragEventListenerService.prototype.generateDragEvent = /**
         * @param {?} event
         * @param {?} eventType
         * @return {?}
         */
            function (event, eventType) {
                /** @type {?} */
                var nativeEvent;
                if ((( /** @type {?} */(event))).hasOwnProperty('changedTouches')) {
                    nativeEvent = (( /** @type {?} */(event))).changedTouches[0];
                }
                else {
                    nativeEvent = event;
                }
                return {
                    type: eventType,
                    dragPosition: { pageX: nativeEvent.pageX, pageY: nativeEvent.pageY },
                    group: this.group,
                    dragDataTransfer: this.dragDataTransfer,
                    ghostElement: this.ghostElement,
                };
            };
        DragEventListenerService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DragEventListenerService.ctorParameters = function () {
            return [
                { type: i0.NgZone },
                { type: i0.Renderer2 },
                { type: DragAndDropEventBusService }
            ];
        };
        return DragEventListenerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This service is used to capture the state of clrDraggable element
    // at a certain event and passes it to clrDraggableGhost component.
    /**
     * @template T
     */
    var DraggableSnapshotService = /** @class */ (function () {
        function DraggableSnapshotService(domAdapter) {
            this.domAdapter = domAdapter;
        }
        /**
         * @param {?} el
         * @param {?} event
         * @return {?}
         */
        DraggableSnapshotService.prototype.capture = /**
         * @param {?} el
         * @param {?} event
         * @return {?}
         */
            function (el, event) {
                this.draggableElClientRect = this.domAdapter.clientRect(el);
                this.snapshotDragEvent = event;
            };
        /**
         * @return {?}
         */
        DraggableSnapshotService.prototype.discard = /**
         * @return {?}
         */
            function () {
                delete this.draggableElClientRect;
                delete this.snapshotDragEvent;
            };
        Object.defineProperty(DraggableSnapshotService.prototype, "hasDraggableState", {
            get: /**
             * @return {?}
             */ function () {
                return !!this.snapshotDragEvent && !!this.draggableElClientRect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DraggableSnapshotService.prototype, "clientRect", {
            get: /**
             * @return {?}
             */ function () {
                return this.draggableElClientRect;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DraggableSnapshotService.prototype, "dragEvent", {
            get: /**
             * @return {?}
             */ function () {
                return this.snapshotDragEvent;
            },
            enumerable: true,
            configurable: true
        });
        DraggableSnapshotService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DraggableSnapshotService.ctorParameters = function () {
            return [
                { type: DomAdapter }
            ];
        };
        return DraggableSnapshotService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDraggableGhost = /** @class */ (function () {
        function ClrDraggableGhost(el, dragEventListener, draggableSnapshot, renderer, ngZone) {
            var _this = this;
            this.el = el;
            this.dragEventListener = dragEventListener;
            this.draggableSnapshot = draggableSnapshot;
            this.renderer = renderer;
            this.ngZone = ngZone;
            this.subscriptions = [];
            this.leaveAnimConfig = { value: 0, params: { top: '0px', left: '0px' } };
            if (!this.dragEventListener || !this.draggableSnapshot) {
                throw new Error('The clr-draggable-ghost component can only be used inside of a clrDraggable directive.');
            }
            this.draggableGhostEl = this.el.nativeElement;
            // Need to use Renderer2 as it runs outside of NgZone
            this.renderer.addClass(this.draggableGhostEl, 'draggable-ghost');
            // Register the ghost element in DragEventListener to pass in a ClrDragEvent.
            this.dragEventListener.ghostElement = this.draggableGhostEl;
            // Default ghost size gets the size of ClrDraggable element.
            this.setDefaultGhostSize(this.draggableGhostEl);
            /** @type {?} */
            var offset = {
                top: this.draggableSnapshot.hasDraggableState
                    ? this.draggableSnapshot.dragEvent.dragPosition.pageY - this.draggableSnapshot.clientRect.top
                    : 0,
                left: this.draggableSnapshot.hasDraggableState
                    ? this.draggableSnapshot.dragEvent.dragPosition.pageX - this.draggableSnapshot.clientRect.left
                    : 0,
            };
            /** @type {?} */
            var isAnimationConfigured = false;
            this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
                // On the first drag move event, we configure the animation as it's dependent on the first drag event.
                if (!isAnimationConfigured) {
                    if (_this.draggableSnapshot.hasDraggableState) {
                        _this.animateToOnLeave(_this.draggableSnapshot.clientRect.top + "px", _this.draggableSnapshot.clientRect.left + "px");
                    }
                    else {
                        _this.animateToOnLeave(event.dragPosition.pageY + "px", event.dragPosition.pageX + "px");
                    }
                    isAnimationConfigured = true;
                }
                // Position the draggable ghost.
                /** @type {?} */
                var topLeftPosition = _this.findTopLeftPosition(event.dragPosition, offset);
                _this.setPositionStyle(_this.draggableGhostEl, topLeftPosition.pageX, topLeftPosition.pageY);
                _this.dragEventListener.dropPointPosition = _this.findDropPointPosition(topLeftPosition);
            }));
        }
        /**
         * @param {?} el
         * @return {?}
         */
        ClrDraggableGhost.prototype.setDefaultGhostSize = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this.draggableSnapshot.hasDraggableState) {
                    this.setSizeStyle(el, this.draggableSnapshot.clientRect.width, this.draggableSnapshot.clientRect.height);
                }
            };
        /**
         * @param {?} top
         * @param {?} left
         * @return {?}
         */
        ClrDraggableGhost.prototype.animateToOnLeave = /**
         * @param {?} top
         * @param {?} left
         * @return {?}
         */
            function (top, left) {
                var _this = this;
                this.ngZone.run(function () {
                    _this.leaveAnimConfig = { value: 0, params: { top: top, left: left } };
                });
            };
        /**
         * @param {?} dragPosition
         * @param {?} offset
         * @return {?}
         */
        ClrDraggableGhost.prototype.findTopLeftPosition = /**
         * @param {?} dragPosition
         * @param {?} offset
         * @return {?}
         */
            function (dragPosition, offset) {
                return { pageX: dragPosition.pageX - offset.left, pageY: dragPosition.pageY - offset.top };
            };
        /**
         * @param {?} topLeftPosition
         * @return {?}
         */
        ClrDraggableGhost.prototype.findDropPointPosition = /**
         * @param {?} topLeftPosition
         * @return {?}
         */
            function (topLeftPosition) {
                if (this.draggableSnapshot.hasDraggableState) {
                    return {
                        pageX: topLeftPosition.pageX + this.draggableSnapshot.clientRect.width / 2,
                        pageY: topLeftPosition.pageY + this.draggableSnapshot.clientRect.height / 2,
                    };
                }
                else {
                    return topLeftPosition;
                }
            };
        /**
         * @param {?} el
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        ClrDraggableGhost.prototype.setSizeStyle = /**
         * @param {?} el
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (el, width, height) {
                this.renderer.setStyle(el, 'width', width + "px");
                this.renderer.setStyle(el, 'height', height + "px");
            };
        /**
         * @param {?} el
         * @param {?} left
         * @param {?} top
         * @return {?}
         */
        ClrDraggableGhost.prototype.setPositionStyle = /**
         * @param {?} el
         * @param {?} left
         * @param {?} top
         * @return {?}
         */
            function (el, left, top) {
                this.renderer.setStyle(el, 'left', left + "px");
                this.renderer.setStyle(el, 'top', top + "px");
                this.renderer.setStyle(el, 'visibility', 'visible');
            };
        /**
         * @return {?}
         */
        ClrDraggableGhost.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDraggableGhost.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-draggable-ghost',
                        template: "<ng-content></ng-content>",
                        animations: [
                            animations.trigger('leaveAnimation', [
                                animations.transition(':leave', [
                                    animations.style({ left: '*', top: '*' }),
                                    animations.animate('0.2s ease-in-out', animations.style({ top: '{{top}}', left: '{{left}}' })),
                                ]),
                            ]),
                        ]
                    }] }
        ];
        /** @nocollapse */
        ClrDraggableGhost.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragEventListenerService, decorators: [{ type: i0.Optional }] },
                { type: DraggableSnapshotService, decorators: [{ type: i0.Optional }] },
                { type: i0.Renderer2 },
                { type: i0.NgZone }
            ];
        };
        ClrDraggableGhost.propDecorators = {
            leaveAnimConfig: [{ type: i0.HostBinding, args: ['@leaveAnimation',] }]
        };
        return ClrDraggableGhost;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This structural directive will be used mainly together with `clr-draggable-ghost` directive inside of clrDraggable
    // directive. The directive is responsible for instantiating `clr-draggable-ghost` directive only during dragging so
    // that Angular Change Detection is prevented from running if a component or directive is placed inside of the
    // `clr-draggable-ghost` directive.
    /**
     * @template T
     */
    var ClrIfDragged = /** @class */ (function () {
        function ClrIfDragged(template, container, dragEventListener) {
            var _this = this;
            this.template = template;
            this.container = container;
            this.dragEventListener = dragEventListener;
            this.subscriptions = [];
            if (!this.dragEventListener || !this.container) {
                throw new Error('The *clrIfDragged directive can only be used inside of a clrDraggable directive.');
            }
            this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
                _this.container.createEmbeddedView(_this.template);
            }));
            this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
                _this.container.clear();
            }));
        }
        /**
         * @return {?}
         */
        ClrIfDragged.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrIfDragged.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrIfDragged]' },] }
        ];
        /** @nocollapse */
        ClrIfDragged.ctorParameters = function () {
            return [
                { type: i0.TemplateRef },
                { type: i0.ViewContainerRef, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
                { type: DragEventListenerService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return ClrIfDragged;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This provider registers the drag handle element.
    // When it registers a element as a drag handle, it attaches that element to the listeners from ClrDragEventListener.
    // Also, it adds the "drag-handle" css class to the registered element through Renderer.
    /**
     * @template T
     */
    var DragHandleRegistrarService = /** @class */ (function () {
        function DragHandleRegistrarService(dragEventListener, renderer) {
            this.dragEventListener = dragEventListener;
            this.renderer = renderer;
        }
        Object.defineProperty(DragHandleRegistrarService.prototype, "defaultHandleEl", {
            get: /**
             * @return {?}
             */ function () {
                return this._defaultHandleEl;
            },
            set: /**
             * @param {?} el
             * @return {?}
             */ function (el) {
                this._defaultHandleEl = el; // defaultHandleEl will be usually the clrDraggable element.
                // If the customHandleEl has been registered,
                // don't make the defaultHandleEl the drag handle yet until the customHandleEl is unregistered.
                if (!this._customHandleEl) {
                    this.makeElementHandle(this._defaultHandleEl);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} el
         * @return {?}
         */
        DragHandleRegistrarService.prototype.makeElementHandle = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (this._defaultHandleEl && this._defaultHandleEl !== el) {
                    // Before making an element the custom handle element,
                    // we should remove the existing drag-handle class from the draggable element.
                    this.renderer.removeClass(this._defaultHandleEl, 'drag-handle');
                }
                this.dragEventListener.attachDragListeners(el);
                this.renderer.addClass(el, 'drag-handle');
            };
        Object.defineProperty(DragHandleRegistrarService.prototype, "customHandleEl", {
            get: /**
             * @return {?}
             */ function () {
                return this._customHandleEl;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} el
         * @return {?}
         */
        DragHandleRegistrarService.prototype.registerCustomHandle = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                this.dragEventListener.detachDragListeners(); // removes the existing listeners
                this._customHandleEl = el;
                this.makeElementHandle(this._customHandleEl);
            };
        /**
         * @return {?}
         */
        DragHandleRegistrarService.prototype.unregisterCustomHandle = /**
         * @return {?}
         */
            function () {
                this.dragEventListener.detachDragListeners(); // removes the existing listeners
                this.renderer.removeClass(this._customHandleEl, 'drag-handle');
                delete this._customHandleEl;
                // if default handle is set, make that handle
                if (this._defaultHandleEl) {
                    this.makeElementHandle(this._defaultHandleEl);
                }
            };
        DragHandleRegistrarService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        DragHandleRegistrarService.ctorParameters = function () {
            return [
                { type: DragEventListenerService },
                { type: i0.Renderer2 }
            ];
        };
        return DragHandleRegistrarService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // This service class adds and removes the "in-drag" class to the document body element
    // through its public enter() and exit() methods.
    var GlobalDragModeService = /** @class */ (function () {
        function GlobalDragModeService(renderer) {
            this.renderer = renderer;
        }
        /**
         * @return {?}
         */
        GlobalDragModeService.prototype.enter = /**
         * @return {?}
         */
            function () {
                this.renderer.addClass(document.body, 'in-drag');
            };
        /**
         * @return {?}
         */
        GlobalDragModeService.prototype.exit = /**
         * @return {?}
         */
            function () {
                this.renderer.removeClass(document.body, 'in-drag');
            };
        GlobalDragModeService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        GlobalDragModeService.ctorParameters = function () {
            return [
                { type: i0.Renderer2 }
            ];
        };
        return GlobalDragModeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDraggable = /** @class */ (function () {
        function ClrDraggable(el, dragEventListener, dragHandleRegistrar, viewContainerRef, cfr, injector, draggableSnapshot, globalDragMode) {
            this.el = el;
            this.dragEventListener = dragEventListener;
            this.dragHandleRegistrar = dragHandleRegistrar;
            this.viewContainerRef = viewContainerRef;
            this.cfr = cfr;
            this.injector = injector;
            this.draggableSnapshot = draggableSnapshot;
            this.globalDragMode = globalDragMode;
            this.subscriptions = [];
            this.dragOn = false;
            this.dragStartEmitter = new i0.EventEmitter();
            this.dragMoveEmitter = new i0.EventEmitter();
            this.dragEndEmitter = new i0.EventEmitter();
            this.draggableEl = this.el.nativeElement;
            this.componentFactory = this.cfr.resolveComponentFactory(ClrDraggableGhost);
        }
        Object.defineProperty(ClrDraggable.prototype, "dataTransfer", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.dragEventListener.dragDataTransfer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDraggable.prototype, "group", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.dragEventListener.group = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        ClrDraggable.prototype.createDefaultGhost = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.draggableSnapshot.capture(this.draggableEl, event);
                // NOTE: The default ghost element will appear
                // next to the clrDraggable in the DOM as a sibling element.
                this.viewContainerRef.createComponent(this.componentFactory, 0, this.injector, [
                    [this.draggableEl.cloneNode(true)],
                ]);
            };
        /**
         * @return {?}
         */
        ClrDraggable.prototype.destroyDefaultGhost = /**
         * @return {?}
         */
            function () {
                this.viewContainerRef.clear();
                this.draggableSnapshot.discard();
            };
        /**
         * @return {?}
         */
        ClrDraggable.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.dragHandleRegistrar.defaultHandleEl = this.draggableEl;
                this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
                    _this.globalDragMode.enter();
                    _this.dragOn = true;
                    if (!_this.customGhost) {
                        _this.createDefaultGhost(event);
                    }
                    _this.dragStartEmitter.emit(new ClrDragEvent(event));
                }));
                this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
                    _this.dragMoveEmitter.emit(new ClrDragEvent(event));
                }));
                this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
                    _this.globalDragMode.exit();
                    _this.dragOn = false;
                    if (!_this.customGhost) {
                        _this.destroyDefaultGhost();
                    }
                    _this.dragEndEmitter.emit(new ClrDragEvent(event));
                }));
            };
        /**
         * @return {?}
         */
        ClrDraggable.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
                this.dragEventListener.detachDragListeners();
            };
        ClrDraggable.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDraggable]',
                        providers: [
                            DragEventListenerService,
                            DragHandleRegistrarService,
                            DraggableSnapshotService,
                            GlobalDragModeService,
                            DomAdapter,
                        ],
                        host: { '[class.draggable]': 'true', '[class.being-dragged]': 'dragOn' },
                    },] }
        ];
        /** @nocollapse */
        ClrDraggable.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragEventListenerService },
                { type: DragHandleRegistrarService },
                { type: i0.ViewContainerRef },
                { type: i0.ComponentFactoryResolver },
                { type: i0.Injector },
                { type: DraggableSnapshotService },
                { type: GlobalDragModeService }
            ];
        };
        ClrDraggable.propDecorators = {
            customGhost: [{ type: i0.ContentChild, args: [ClrIfDragged,] }],
            dataTransfer: [{ type: i0.Input, args: ['clrDraggable',] }],
            group: [{ type: i0.Input, args: ['clrGroup',] }],
            dragStartEmitter: [{ type: i0.Output, args: ['clrDragStart',] }],
            dragMoveEmitter: [{ type: i0.Output, args: ['clrDragMove',] }],
            dragEndEmitter: [{ type: i0.Output, args: ['clrDragEnd',] }]
        };
        return ClrDraggable;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDroppable = /** @class */ (function () {
        function ClrDroppable(el, eventBus, domAdapter, renderer) {
            this.el = el;
            this.eventBus = eventBus;
            this.domAdapter = domAdapter;
            this.renderer = renderer;
            this.isDraggableMatch = false;
            this._isDraggableOver = false;
            this._dropTolerance = { top: 0, right: 0, bottom: 0, left: 0 };
            this.dragStartEmitter = new i0.EventEmitter();
            this.dragMoveEmitter = new i0.EventEmitter();
            this.dragEndEmitter = new i0.EventEmitter();
            this.dragLeaveEmitter = new i0.EventEmitter();
            this.dragEnterEmitter = new i0.EventEmitter();
            this.dropEmitter = new i0.EventEmitter();
            this.droppableEl = this.el.nativeElement;
        }
        Object.defineProperty(ClrDroppable.prototype, "isDraggableOver", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // We need to add/remove this draggable-over class via Renderer2
                // because isDraggableOver is set outside of NgZone.
                if (value) {
                    this.renderer.addClass(this.droppableEl, 'draggable-over');
                }
                else {
                    this.renderer.removeClass(this.droppableEl, 'draggable-over');
                }
                this._isDraggableOver = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrDroppable.prototype, "group", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._group = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?=} top
         * @param {?=} right
         * @param {?=} bottom
         * @param {?=} left
         * @return {?}
         */
        ClrDroppable.prototype.dropToleranceGenerator = /**
         * @param {?=} top
         * @param {?=} right
         * @param {?=} bottom
         * @param {?=} left
         * @return {?}
         */
            function (top, right, bottom, left) {
                if (top === void 0) {
                    top = 0;
                }
                if (right === void 0) {
                    right = top;
                }
                if (bottom === void 0) {
                    bottom = top;
                }
                if (left === void 0) {
                    left = right;
                }
                return { top: top, right: right, bottom: bottom, left: left };
            };
        Object.defineProperty(ClrDroppable.prototype, "dropTolerance", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // If user provides an object here and wants to manipulate/update properties individually,
                // the object must be immutable as we generate new object based user's given object.
                if (typeof value === 'number') {
                    this._dropTolerance = this.dropToleranceGenerator(value);
                }
                else if (typeof value === 'string') {
                    /** @type {?} */
                    var toleranceValues = value
                        .trim()
                        .split(/\s+/)
                        .map(function (tolerance) { return parseInt(tolerance, 10); });
                    this._dropTolerance = this.dropToleranceGenerator.apply(this, __spread(toleranceValues));
                }
                else if (value) {
                    // The value could be passed in as {left: 20, top: 30 }
                    // In this case, the rest of the direction properties should be 0.
                    // That's why we initialize properties with 0 first, then override with user's given value.
                    this._dropTolerance = __assign({}, this.dropToleranceGenerator(0), value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} subscription
         * @return {?}
         */
        ClrDroppable.prototype.unsubscribeFrom = /**
         * @param {?} subscription
         * @return {?}
         */
            function (subscription) {
                if (subscription) {
                    subscription.unsubscribe();
                }
            };
        /**
         * @param {?} draggableGroup
         * @return {?}
         */
        ClrDroppable.prototype.checkGroupMatch = /**
         * @param {?} draggableGroup
         * @return {?}
         */
            function (draggableGroup) {
                // Both Draggable and Droppable have clrGroup input.
                // The clrGroup input can be both a string key or array of string keys in Draggable and Droppable.
                // It's not match if Draggable has no defined value assigned to clrGroup, but Droppable has a defined clrGroup.
                if (!draggableGroup && this._group) {
                    return false;
                }
                // The same is true the other way round.
                if (!this._group && draggableGroup) {
                    return false;
                }
                // It's match if both Draggable and Droppable have no assigned value for clrGroup.
                if (!this._group && !draggableGroup) {
                    return true;
                }
                // It's match if both Draggable and Droppable have simple string keys that are matching.
                // It's match if Draggable's simple clrGroup key is matching with one of the clrGroup keys of Droppable. The
                // same is true the other way round.
                // it's match if one of the clrGroup keys of Droppable is matching with one of the clrGroup keys of Draggable.
                if (typeof draggableGroup === 'string') {
                    if (typeof this._group === 'string') {
                        return this._group === draggableGroup;
                    }
                    else {
                        return this._group.indexOf(draggableGroup) > -1;
                    }
                }
                else {
                    if (typeof this._group === 'string') {
                        return draggableGroup.indexOf(this._group) > -1;
                    }
                    else {
                        return (( /** @type {?} */(this._group))).some(function (groupKey) { return draggableGroup.indexOf(groupKey) > -1; });
                    }
                }
            };
        /**
         * @param {?} point
         * @return {?}
         */
        ClrDroppable.prototype.isInDropArea = /**
         * @param {?} point
         * @return {?}
         */
            function (point) {
                if (!point) {
                    return false;
                }
                if (!this.clientRect) {
                    this.clientRect = this.domAdapter.clientRect(this.droppableEl);
                }
                if (point.pageX >= this.clientRect.left - this._dropTolerance.left &&
                    point.pageX <= this.clientRect.right + this._dropTolerance.right &&
                    point.pageY >= this.clientRect.top - this._dropTolerance.top &&
                    point.pageY <= this.clientRect.bottom + this._dropTolerance.bottom) {
                    return true;
                }
                else {
                    return false;
                }
            };
        /**
         * @param {?} dragStartEvent
         * @return {?}
         */
        ClrDroppable.prototype.onDragStart = /**
         * @param {?} dragStartEvent
         * @return {?}
         */
            function (dragStartEvent) {
                var _this = this;
                // Check draggable and droppable have a matching group key.
                this.isDraggableMatch = this.checkGroupMatch(dragStartEvent.group);
                // Subscribe to dragMoved and dragEnded only if draggable and droppable have a matching group key.
                if (this.isDraggableMatch) {
                    this.dragStartEmitter.emit(new ClrDragEvent(dragStartEvent));
                    this.dragMoveSubscription = this.eventBus.dragMoved.subscribe(function (dragMoveEvent) {
                        _this.onDragMove(dragMoveEvent);
                    });
                    this.dragEndSubscription = this.eventBus.dragEnded.subscribe(function (dragEndEvent) {
                        _this.onDragEnd(dragEndEvent);
                    });
                }
            };
        /**
         * @param {?} dragMoveEvent
         * @return {?}
         */
        ClrDroppable.prototype.onDragMove = /**
         * @param {?} dragMoveEvent
         * @return {?}
         */
            function (dragMoveEvent) {
                /** @type {?} */
                var isInDropArea = this.isInDropArea(dragMoveEvent.dropPointPosition);
                if (!this._isDraggableOver && isInDropArea) {
                    this.isDraggableOver = true;
                    /** @type {?} */
                    var dragEnterEvent = __assign({}, dragMoveEvent, { type: DragEventType.DRAG_ENTER });
                    this.eventBus.broadcast(dragEnterEvent);
                    this.dragEnterEmitter.emit(new ClrDragEvent(dragEnterEvent));
                }
                else if (this._isDraggableOver && !isInDropArea) {
                    this.isDraggableOver = false;
                    /** @type {?} */
                    var dragLeaveEvent = __assign({}, dragMoveEvent, { type: DragEventType.DRAG_LEAVE });
                    this.eventBus.broadcast(dragLeaveEvent);
                    this.dragLeaveEmitter.emit(new ClrDragEvent(dragLeaveEvent));
                }
                this.dragMoveEmitter.emit(new ClrDragEvent(dragMoveEvent));
            };
        /**
         * @param {?} dragEndEvent
         * @return {?}
         */
        ClrDroppable.prototype.onDragEnd = /**
         * @param {?} dragEndEvent
         * @return {?}
         */
            function (dragEndEvent) {
                if (this._isDraggableOver) {
                    if (dragEndEvent.ghostElement) {
                        // By this point, the draggable ghost component is destroyed,
                        // but the element would be active until its animation completes.
                        // As such, once the ghost is dropped over, we will give it "dropped" class.
                        // This process cannot be done in the ghost component
                        // because any subscription to the drop event is ineffective or invalid
                        // as the component had been already destroyed.
                        this.renderer.addClass(dragEndEvent.ghostElement, 'dropped');
                    }
                    /** @type {?} */
                    var dropEvent = __assign({}, dragEndEvent, { type: DragEventType.DROP });
                    this.eventBus.broadcast(dropEvent);
                    this.dropEmitter.emit(new ClrDragEvent(dropEvent));
                    this.isDraggableOver = false;
                }
                this.dragEndEmitter.emit(new ClrDragEvent(dragEndEvent));
                this.unsubscribeFrom(this.dragMoveSubscription);
                this.unsubscribeFrom(this.dragEndSubscription);
                this.isDraggableMatch = false;
                delete this.clientRect;
            };
        /**
         * @return {?}
         */
        ClrDroppable.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.dragStartSubscription = this.eventBus.dragStarted.subscribe(function (dragStartEvent) {
                    _this.onDragStart(dragStartEvent);
                });
            };
        /**
         * @return {?}
         */
        ClrDroppable.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.unsubscribeFrom(this.dragStartSubscription);
                this.unsubscribeFrom(this.dragMoveSubscription);
                this.unsubscribeFrom(this.dragEndSubscription);
            };
        ClrDroppable.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrDroppable]',
                        providers: [DomAdapter],
                        host: { '[class.droppable]': 'true', '[class.draggable-match]': 'isDraggableMatch' },
                    },] }
        ];
        /** @nocollapse */
        ClrDroppable.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragAndDropEventBusService },
                { type: DomAdapter },
                { type: i0.Renderer2 }
            ];
        };
        ClrDroppable.propDecorators = {
            group: [{ type: i0.Input, args: ['clrGroup',] }],
            dropTolerance: [{ type: i0.Input, args: ['clrDropTolerance',] }],
            dragStartEmitter: [{ type: i0.Output, args: ['clrDragStart',] }],
            dragMoveEmitter: [{ type: i0.Output, args: ['clrDragMove',] }],
            dragEndEmitter: [{ type: i0.Output, args: ['clrDragEnd',] }],
            dragLeaveEmitter: [{ type: i0.Output, args: ['clrDragLeave',] }],
            dragEnterEmitter: [{ type: i0.Output, args: ['clrDragEnter',] }],
            dropEmitter: [{ type: i0.Output, args: ['clrDrop',] }]
        };
        return ClrDroppable;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var ClrDragHandle = /** @class */ (function () {
        function ClrDragHandle(el, dragHandleRegistrar) {
            this.el = el;
            this.dragHandleRegistrar = dragHandleRegistrar;
            if (!this.dragHandleRegistrar) {
                // ClrDragHandleRegistrar is provided in ClrDraggable so we expect it to be present here
                // as clrDragHandle is required to be used only inside of a clrDraggable directive.
                throw new Error('The clrDragHandle directive can only be used inside of a clrDraggable directive.');
            }
            this.dragHandleRegistrar.registerCustomHandle(this.el.nativeElement);
        }
        /**
         * @return {?}
         */
        ClrDragHandle.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.dragHandleRegistrar.unregisterCustomHandle();
            };
        ClrDragHandle.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrDragHandle]', host: { '[class.drag-handle]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrDragHandle.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: DragHandleRegistrarService, decorators: [{ type: i0.Optional }] }
            ];
        };
        return ClrDragHandle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DRAG_AND_DROP_DIRECTIVES = [
        ClrDraggable,
        ClrDroppable,
        ClrIfDragged,
        ClrDragHandle,
        ClrDraggableGhost,
    ];
    var ClrDragAndDropModule = /** @class */ (function () {
        function ClrDragAndDropModule() {
        }
        ClrDragAndDropModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [CLR_DRAG_AND_DROP_DIRECTIVES],
                        entryComponents: [ClrDraggableGhost],
                        exports: [CLR_DRAG_AND_DROP_DIRECTIVES],
                    },] }
        ];
        return ClrDragAndDropModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var RootDropdownService = /** @class */ (function () {
        function RootDropdownService() {
            this._changes = new rxjs.Subject();
        }
        Object.defineProperty(RootDropdownService.prototype, "changes", {
            get: /**
             * @return {?}
             */ function () {
                return this._changes.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RootDropdownService.prototype.closeMenus = /**
         * @return {?}
         */
            function () {
                this._changes.next(false);
            };
        RootDropdownService.decorators = [
            { type: i0.Injectable }
        ];
        return RootDropdownService;
    }());
    /**
     * @param {?} existing
     * @return {?}
     */
    function clrRootDropdownFactory(existing) {
        return existing || new RootDropdownService();
    }
    /** @type {?} */
    var ROOT_DROPDOWN_PROVIDER = {
        provide: RootDropdownService,
        useFactory: clrRootDropdownFactory,
        deps: [[new i0.Optional(), new i0.SkipSelf(), RootDropdownService]],
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdown = /** @class */ (function () {
        function ClrDropdown(parent, ifOpenService, cdr, dropdownService) {
            var _this = this;
            this.parent = parent;
            this.ifOpenService = ifOpenService;
            this.cdr = cdr;
            this.subscriptions = [];
            this.isMenuClosable = true;
            this.subscriptions.push(dropdownService.changes.subscribe(function (value) { return (_this.ifOpenService.open = value); }));
            this.subscriptions.push(ifOpenService.openChange.subscribe(function (value) { return _this.cdr.markForCheck(); }));
        }
        /**
         * @return {?}
         */
        ClrDropdown.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
            };
        ClrDropdown.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dropdown',
                        template: '<ng-content></ng-content>',
                        host: {
                            '[class.dropdown]': 'true',
                            // FIXME: remove this as soon as we stop supporting this old <div class="dropdown-menu"> syntax
                            '[class.open]': 'ifOpenService.open',
                        },
                        providers: [IfOpenService, ROOT_DROPDOWN_PROVIDER, { provide: POPOVER_HOST_ANCHOR, useExisting: i0.ElementRef }]
                    }] }
        ];
        /** @nocollapse */
        ClrDropdown.ctorParameters = function () {
            return [
                { type: ClrDropdown, decorators: [{ type: i0.SkipSelf }, { type: i0.Optional }] },
                { type: IfOpenService },
                { type: i0.ChangeDetectorRef },
                { type: RootDropdownService }
            ];
        };
        ClrDropdown.propDecorators = {
            isMenuClosable: [{ type: i0.Input, args: ['clrCloseMenuOnItemClick',] }]
        };
        return ClrDropdown;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdownItem = /** @class */ (function () {
        function ClrDropdownItem(dropdown, el, _dropdownService, renderer) {
            this.dropdown = dropdown;
            this.el = el;
            this._dropdownService = _dropdownService;
            this.renderer = renderer;
        }
        /**
         * @return {?}
         */
        ClrDropdownItem.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.renderer.listen(this.el.nativeElement, 'click', function () { return _this.onDropdownItemClick(); });
            };
        /**
         * @return {?}
         */
        ClrDropdownItem.prototype.onDropdownItemClick = /**
         * @return {?}
         */
            function () {
                if (this.dropdown.isMenuClosable && !this.el.nativeElement.classList.contains('disabled')) {
                    this._dropdownService.closeMenus();
                }
            };
        ClrDropdownItem.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrDropdownItem]', host: { '[class.dropdown-item]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrDropdownItem.ctorParameters = function () {
            return [
                { type: ClrDropdown },
                { type: i0.ElementRef },
                { type: RootDropdownService },
                { type: i0.Renderer2 }
            ];
        };
        return ClrDropdownItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdownMenu = /** @class */ (function (_super) {
        __extends(ClrDropdownMenu, _super);
        function ClrDropdownMenu(injector, parentHost, nested) {
            var _this = this;
            if (!parentHost) {
                throw new Error('clr-dropdown-menu should only be used inside of a clr-dropdown');
            }
            _this = _super.call(this, injector, parentHost) || this;
            if (!nested) {
                // Default positioning for normal dropdown is bottom-left
                _this.anchorPoint = Point.BOTTOM_LEFT;
                _this.popoverPoint = Point.LEFT_TOP;
            }
            else {
                // Default positioning for nested dropdown is right-top
                _this.anchorPoint = Point.RIGHT_TOP;
                _this.popoverPoint = Point.LEFT_TOP;
            }
            _this.popoverOptions.allowMultipleOpen = true;
            _this.closeOnOutsideClick = true;
            return _this;
        }
        Object.defineProperty(ClrDropdownMenu.prototype, "position", {
            set: /**
             * @param {?} position
             * @return {?}
             */ function (position) {
                // set the popover values based on menu position
                switch (position) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_RIGHT;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_LEFT;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_RIGHT;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-top':
                        this.anchorPoint = Point.RIGHT_TOP;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'right-bottom':
                        this.anchorPoint = Point.RIGHT_BOTTOM;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'left-top':
                        this.anchorPoint = Point.LEFT_TOP;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'left-bottom':
                        this.anchorPoint = Point.LEFT_BOTTOM;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    default:
                        this.anchorPoint = Point.BOTTOM_LEFT;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        ClrDropdownMenu.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-dropdown-menu',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.dropdown-menu]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrDropdownMenu.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
                { type: ClrDropdownMenu, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] }
            ];
        };
        ClrDropdownMenu.propDecorators = {
            position: [{ type: i0.Input, args: ['clrPosition',] }]
        };
        return ClrDropdownMenu;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrDropdownTrigger = /** @class */ (function () {
        function ClrDropdownTrigger(dropdown, ifOpenService) {
            this.ifOpenService = ifOpenService;
            this.isRootLevelToggle = true;
            // if the containing dropdown has a parent, then this is not the root level one
            if (dropdown.parent) {
                this.isRootLevelToggle = false;
            }
        }
        Object.defineProperty(ClrDropdownTrigger.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifOpenService.open;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        ClrDropdownTrigger.prototype.onDropdownTriggerClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.ifOpenService.toggleWithEvent(event);
            };
        ClrDropdownTrigger.decorators = [
            { type: i0.Directive, args: [{
                        // We support both selectors for legacy reasons
                        selector: '[clrDropdownTrigger],[clrDropdownToggle]',
                        host: {
                            '[class.dropdown-toggle]': 'isRootLevelToggle',
                            '[class.dropdown-item]': '!isRootLevelToggle',
                            '[class.expandable]': '!isRootLevelToggle',
                            '[class.active]': 'active',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrDropdownTrigger.ctorParameters = function () {
            return [
                { type: ClrDropdown },
                { type: IfOpenService }
            ];
        };
        ClrDropdownTrigger.propDecorators = {
            onDropdownTriggerClick: [{ type: i0.HostListener, args: ['click', ['$event'],] }]
        };
        return ClrDropdownTrigger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_DROPDOWN_DIRECTIVES = [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem];
    var ClrDropdownModule = /** @class */ (function () {
        function ClrDropdownModule() {
        }
        ClrDropdownModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule],
                        declarations: [CLR_DROPDOWN_DIRECTIVES],
                        exports: [CLR_DROPDOWN_DIRECTIVES, ClrConditionalModule, ClrIconModule],
                    },] }
        ];
        return ClrDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    // @TODO Make this an enum
    /** @type {?} */
    var ALERT_TYPES = ['info', 'warning', 'danger', 'success'];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var AlertIconAndTypesService = /** @class */ (function () {
        function AlertIconAndTypesService(commonStrings) {
            this.commonStrings = commonStrings;
            this.defaultIconShape = 'info-circle';
            this._alertIconShape = '';
            this._alertType = 'info';
        }
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertType", {
            get: /**
             * @return {?}
             */ function () {
                return this._alertType;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (ALERT_TYPES.indexOf(val) > -1) {
                    this._alertType = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconShape", {
            get: /**
             * @return {?}
             */ function () {
                if ('' === this._alertIconShape) {
                    return this.iconInfoFromType(this._alertType).shape;
                }
                return this._alertIconShape;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                if (!val) {
                    this._alertIconShape = '';
                }
                else if (val !== this._alertIconShape) {
                    this._alertIconShape = val;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconTitle", {
            get: /**
             * @return {?}
             */ function () {
                return this.iconInfoFromType(this._alertType).title;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} type
         * @return {?}
         */
        AlertIconAndTypesService.prototype.iconInfoFromType = /**
         * @param {?} type
         * @return {?}
         */
            function (type) {
                /** @type {?} */
                var returnObj = { shape: '', cssClass: '', title: '' };
                switch (type) {
                    case 'warning':
                        returnObj.shape = 'exclamation-triangle';
                        returnObj.cssClass = 'alert-warning';
                        returnObj.title = this.commonStrings.warning;
                        break;
                    case 'danger':
                        returnObj.shape = 'exclamation-circle';
                        returnObj.cssClass = 'alert-danger';
                        returnObj.title = this.commonStrings.danger;
                        break;
                    case 'success':
                        returnObj.shape = 'check-circle';
                        returnObj.cssClass = 'alert-success';
                        returnObj.title = this.commonStrings.success;
                        break;
                    default:
                        returnObj.shape = this.defaultIconShape;
                        returnObj.cssClass = 'alert-info';
                        returnObj.title = this.commonStrings.info;
                        break;
                }
                return returnObj;
            };
        AlertIconAndTypesService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        AlertIconAndTypesService.ctorParameters = function () {
            return [
                { type: ClrCommonStrings }
            ];
        };
        return AlertIconAndTypesService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var MultiAlertService = /** @class */ (function () {
        function MultiAlertService() {
            this.allAlerts = new i0.QueryList();
            this._current = 0;
            /**
             * The Observable that lets other classes subscribe to changes
             */
            this._change = new rxjs.Subject();
        }
        Object.defineProperty(MultiAlertService.prototype, "changes", {
            get: /**
             * @return {?}
             */ function () {
                return this._change.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "current", {
            get: /**
             * @return {?}
             */ function () {
                return this._current;
            },
            set: /**
             * @param {?} index
             * @return {?}
             */ function (index) {
                if (index !== this._current) {
                    this._current = index;
                    this._change.next(index);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "activeAlerts", {
            get: /**
             * @return {?}
             */ function () {
                return this.allAlerts.filter(function (alert) { return !alert._closed; });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "currentAlert", {
            get: /**
             * @return {?}
             */ function () {
                return this.activeAlerts[this.current];
            },
            set: /**
             * @param {?} alert
             * @return {?}
             */ function (alert) {
                this.current = this.activeAlerts.indexOf(alert);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MultiAlertService.prototype, "count", {
            get: /**
             * @return {?}
             */ function () {
                return this.activeAlerts.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} alerts
         * @return {?}
         */
        MultiAlertService.prototype.manage = /**
         * @param {?} alerts
         * @return {?}
         */
            function (alerts) {
                this.allAlerts = alerts;
            };
        /**
         * @return {?}
         */
        MultiAlertService.prototype.next = /**
         * @return {?}
         */
            function () {
                this.current = this.current === this.activeAlerts.length - 1 ? 0 : this.current + 1;
            };
        /**
         * @return {?}
         */
        MultiAlertService.prototype.previous = /**
         * @return {?}
         */
            function () {
                if (this.activeAlerts.length === 0) {
                    return;
                }
                this.current = this.current === 0 ? this.activeAlerts.length - 1 : this.current - 1;
            };
        /**
         * @return {?}
         */
        MultiAlertService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.previous();
            };
        MultiAlertService.decorators = [
            { type: i0.Injectable }
        ];
        return MultiAlertService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlert = /** @class */ (function () {
        function ClrAlert(iconService, cdr, multiAlertService, commonStrings) {
            this.iconService = iconService;
            this.cdr = cdr;
            this.multiAlertService = multiAlertService;
            this.commonStrings = commonStrings;
            this.isSmall = false;
            this.closable = true;
            this.isAppLevel = false;
            this._closed = false;
            this._closedChanged = new i0.EventEmitter(false);
            this.previouslyHidden = false;
            this.hidden = false;
        }
        Object.defineProperty(ClrAlert.prototype, "alertType", {
            get: /**
             * @return {?}
             */ function () {
                return this.iconService.alertType;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this.iconService.alertType = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "alertIconShape", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.iconService.alertIconShape = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlert.prototype, "alertClass", {
            get: /**
             * @return {?}
             */ function () {
                return this.iconService.iconInfoFromType(this.iconService.alertType).cssClass;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlert.prototype.detectChangesIfNeeded = /**
         * @return {?}
         */
            function () {
                if (this.previouslyHidden !== this.hidden) {
                    this.previouslyHidden = this.hidden;
                    this.cdr.detectChanges();
                }
            };
        Object.defineProperty(ClrAlert.prototype, "isHidden", {
            get: /**
             * @return {?}
             */ function () {
                if (this.multiAlertService) {
                    if (this.multiAlertService.currentAlert === this) {
                        if (this.hidden === true) {
                            this.previouslyHidden = true;
                            this.hidden = false;
                        }
                    }
                    else if (this.hidden === false) {
                        this.previouslyHidden = false;
                        this.hidden = true;
                    }
                    this.detectChangesIfNeeded();
                }
                return this.hidden;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlert.prototype.close = /**
         * @return {?}
         */
            function () {
                if (!this.closable) {
                    return;
                }
                this._closed = true;
                if (this.multiAlertService) {
                    this.multiAlertService.close();
                }
                this._closedChanged.emit(true);
            };
        /**
         * @return {?}
         */
        ClrAlert.prototype.open = /**
         * @return {?}
         */
            function () {
                this._closed = false;
                this._closedChanged.emit(false);
            };
        ClrAlert.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alert',
                        providers: [AlertIconAndTypesService],
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n    *ngIf=\"!_closed\"\n    class=\"alert\"\n    [ngClass]=\"alertClass\"\n    [class.alert-hidden]=\"isHidden\"\n    [class.alert-sm]=\"isSmall\"\n    [class.alert-app-level]=\"isAppLevel\"\n    role=\"alert\"\n    aria-live=\"assertive\">\n    <div class=\"alert-items\">\n        <ng-content></ng-content>\n    </div>\n    <button type=\"button\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n        <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n    </button>\n</div>\n",
                        styles: [':host { display: block; }']
                    }] }
        ];
        /** @nocollapse */
        ClrAlert.ctorParameters = function () {
            return [
                { type: AlertIconAndTypesService },
                { type: i0.ChangeDetectorRef },
                { type: MultiAlertService, decorators: [{ type: i0.Optional }] },
                { type: ClrCommonStrings }
            ];
        };
        ClrAlert.propDecorators = {
            isSmall: [{ type: i0.Input, args: ['clrAlertSizeSmall',] }],
            closable: [{ type: i0.Input, args: ['clrAlertClosable',] }],
            isAppLevel: [{ type: i0.Input, args: ['clrAlertAppLevel',] }],
            _closed: [{ type: i0.Input, args: ['clrAlertClosed',] }],
            _closedChanged: [{ type: i0.Output, args: ['clrAlertClosedChange',] }],
            alertType: [{ type: i0.Input, args: ['clrAlertType',] }],
            alertIconShape: [{ type: i0.Input, args: ['clrAlertIcon',] }]
        };
        return ClrAlert;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlertItem = /** @class */ (function () {
        function ClrAlertItem(iconService) {
            this.iconService = iconService;
        }
        ClrAlertItem.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alert-item',
                        template: "\n        <div class=\"alert-icon-wrapper\">\n            <clr-icon class=\"alert-icon\" \n              [attr.shape]=\"iconService.alertIconShape\" \n              [attr.title]=\"iconService.alertIconTitle\"></clr-icon>\n        </div>\n        <ng-content></ng-content>\n    ",
                        host: { class: 'alert-item' }
                    }] }
        ];
        /** @nocollapse */
        ClrAlertItem.ctorParameters = function () {
            return [
                { type: AlertIconAndTypesService }
            ];
        };
        return ClrAlertItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlerts = /** @class */ (function () {
        function ClrAlerts(multiAlertService) {
            this.multiAlertService = multiAlertService;
            this.currentAlertIndexChange = new i0.EventEmitter(false);
            this.currentAlertChange = new i0.EventEmitter(false);
        }
        Object.defineProperty(ClrAlerts.prototype, "_inputCurrentIndex", {
            /**
             * Input/Output to support two way binding on current alert index
             */
            set: /**
             * Input/Output to support two way binding on current alert index
             * @param {?} index
             * @return {?}
             */ function (index) {
                if (Number.isInteger(index) && index >= 0) {
                    this.multiAlertService.current = index;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlertIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.current;
            },
            set: /**
             * @param {?} index
             * @return {?}
             */ function (index) {
                this.multiAlertService.current = index;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlert", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.currentAlert;
            },
            /**
             * Input/Output to support two way binding on current alert instance
             */
            set: /**
             * Input/Output to support two way binding on current alert instance
             * @param {?} alert
             * @return {?}
             */ function (alert) {
                if (alert) {
                    this.multiAlertService.currentAlert = alert;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "alerts", {
            /**
             * Ensure we are only dealing with alerts that have not been closed yet
             */
            get: /**
             * Ensure we are only dealing with alerts that have not been closed yet
             * @return {?}
             */ function () {
                return this.allAlerts.filter(function (alert) {
                    return alert.isHidden === false;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlerts.prototype, "currentAlertType", {
            get: /**
             * @return {?}
             */ function () {
                if (this.multiAlertService.currentAlert) {
                    return this.multiAlertService.currentAlert.alertType;
                }
                return '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlerts.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.multiAlertService.manage(this.allAlerts);
                this.multiAlertService.changes.subscribe(function (index) {
                    _this.currentAlertIndexChange.next(index);
                    _this.currentAlertChange.next(_this.multiAlertService.currentAlert);
                });
            };
        ClrAlerts.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alerts',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-alerts-pager\n        *ngIf=\"multiAlertService.count > 1\"\n        [clrCurrentAlertIndex]=\"currentAlertIndex\">\n</clr-alerts-pager>\n<ng-content select=\"clr-alert\"></ng-content>\n",
                        providers: [MultiAlertService],
                        host: {
                            '[class.alerts]': 'true',
                            '[class.alert-danger]': "this.currentAlertType == 'danger'",
                            '[class.alert-info]': "this.currentAlertType == 'info'",
                            '[class.alert-success]': "this.currentAlertType == 'success'",
                            '[class.alert-warning]': "this.currentAlertType == 'warning'",
                        },
                        styles: [':host { display: block }']
                    }] }
        ];
        /** @nocollapse */
        ClrAlerts.ctorParameters = function () {
            return [
                { type: MultiAlertService }
            ];
        };
        ClrAlerts.propDecorators = {
            allAlerts: [{ type: i0.ContentChildren, args: [ClrAlert,] }],
            _inputCurrentIndex: [{ type: i0.Input, args: ['clrCurrentAlertIndex',] }],
            currentAlertIndexChange: [{ type: i0.Output, args: ['clrCurrentAlertIndexChange',] }],
            currentAlert: [{ type: i0.Input, args: ['clrCurrentAlert',] }],
            currentAlertChange: [{ type: i0.Output, args: ['clrCurrentAlertChange',] }]
        };
        return ClrAlerts;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrAlertsPager = /** @class */ (function () {
        function ClrAlertsPager(multiAlertService, commonStrings) {
            this.multiAlertService = multiAlertService;
            this.commonStrings = commonStrings;
            this.currentAlertChange = new i0.EventEmitter(false);
            this.currentAlertIndexChange = new i0.EventEmitter();
        }
        Object.defineProperty(ClrAlertsPager.prototype, "currentAlert", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.currentAlert;
            },
            /**
             * Input/Output to support two way binding on current alert instance
             */
            set: /**
             * Input/Output to support two way binding on current alert instance
             * @param {?} alert
             * @return {?}
             */ function (alert) {
                if (alert) {
                    this.multiAlertService.currentAlert = alert;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrAlertsPager.prototype, "currentAlertIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this.multiAlertService.current;
            },
            /**
             * Input/Output to support two way binding on current alert index
             */
            set: /**
             * Input/Output to support two way binding on current alert index
             * @param {?} index
             * @return {?}
             */ function (index) {
                this.multiAlertService.current = index;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.multiAlertServiceChanges = this.multiAlertService.changes.subscribe(function (index) {
                    _this.currentAlertIndexChange.emit(index);
                    _this.currentAlertChange.emit(_this.multiAlertService.activeAlerts[index]);
                });
            };
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.pageUp = /**
         * @return {?}
         */
            function () {
                this.multiAlertService.next();
            };
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.pageDown = /**
         * @return {?}
         */
            function () {
                this.multiAlertService.previous();
            };
        /**
         * @return {?}
         */
        ClrAlertsPager.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.multiAlertServiceChanges.unsubscribe();
            };
        ClrAlertsPager.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-alerts-pager',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"alerts-pager-control\">\n    <div class=\"alerts-page-down\">\n        <button class=\"alerts-pager-button\" (click)=\"pageDown()\">\n            <clr-icon shape=\"caret left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n        </button>\n    </div>\n    <div class=\"alerts-pager-text\">\n        {{this.multiAlertService.current+1}} / {{this.multiAlertService.count}}\n    </div>\n    <div class=\"alerts-page-up\">\n        <button class=\"alerts-pager-button\" (click)=\"pageUp()\">\n            <clr-icon shape=\"caret right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n",
                        host: { '[class.alerts-pager]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrAlertsPager.ctorParameters = function () {
            return [
                { type: MultiAlertService },
                { type: ClrCommonStrings }
            ];
        };
        ClrAlertsPager.propDecorators = {
            currentAlert: [{ type: i0.Input, args: ['clrCurrentAlert',] }],
            currentAlertChange: [{ type: i0.Output, args: ['clrCurrentAlertChange',] }],
            currentAlertIndex: [{ type: i0.Input, args: ['clrCurrentAlertIndex',] }],
            currentAlertIndexChange: [{ type: i0.Output, args: ['clrCurrentAlertIndexChange',] }]
        };
        return ClrAlertsPager;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_ALERT_DIRECTIVES = [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager];
    var ClrAlertModule = /** @class */ (function () {
        function ClrAlertModule() {
        }
        ClrAlertModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrDropdownModule],
                        declarations: [CLR_ALERT_DIRECTIVES],
                        exports: [CLR_ALERT_DIRECTIVES],
                    },] }
        ];
        return ClrAlertModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrEmphasisModule = /** @class */ (function () {
        function ClrEmphasisModule() {
        }
        ClrEmphasisModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrAlertModule] },] }
        ];
        return ClrEmphasisModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ResponsiveNavCodes = /** @class */ (function () {
        function ResponsiveNavCodes() {
        }
        ResponsiveNavCodes.NAV_LEVEL_1 = 1;
        ResponsiveNavCodes.NAV_LEVEL_2 = 2;
        ResponsiveNavCodes.NAV_CLOSE_ALL = 'NAV_CLOSE_ALL';
        ResponsiveNavCodes.NAV_OPEN = 'NAV_OPEN';
        ResponsiveNavCodes.NAV_CLOSE = 'NAV_CLOSE';
        ResponsiveNavCodes.NAV_TOGGLE = 'NAV_TOGGLE';
        ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU = 'open-hamburger-menu';
        ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU = 'open-overflow-menu';
        ResponsiveNavCodes.NAV_CLASS_TRIGGER_1 = 'header-hamburger-trigger';
        ResponsiveNavCodes.NAV_CLASS_TRIGGER_2 = 'header-overflow-trigger';
        ResponsiveNavCodes.NAV_CLASS_LEVEL_1 = 'clr-nav-level-1';
        ResponsiveNavCodes.NAV_CLASS_LEVEL_2 = 'clr-nav-level-2';
        return ResponsiveNavCodes;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /*
     * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
     * This software is released under MIT license.
     * The full license information can be found in LICENSE in the root directory of this project.
     */
    var ResponsiveNavControlMessage = /** @class */ (function () {
        function ResponsiveNavControlMessage(_controlCode, _navLevel) {
            this._controlCode = _controlCode;
            this._navLevel = _navLevel;
        }
        Object.defineProperty(ResponsiveNavControlMessage.prototype, "controlCode", {
            get: /**
             * @return {?}
             */ function () {
                return this._controlCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResponsiveNavControlMessage.prototype, "navLevel", {
            get: /**
             * @return {?}
             */ function () {
                return this._navLevel;
            },
            enumerable: true,
            configurable: true
        });
        return ResponsiveNavControlMessage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ResponsiveNavigationService = /** @class */ (function () {
        function ResponsiveNavigationService() {
            this.responsiveNavList = [];
            this.registerNavSubject = new rxjs.Subject();
            this.controlNavSubject = new rxjs.Subject();
            this.closeAllNavs(); // We start with all navs closed
        }
        Object.defineProperty(ResponsiveNavigationService.prototype, "registeredNavs", {
            get: /**
             * @return {?}
             */ function () {
                return this.registerNavSubject.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResponsiveNavigationService.prototype, "navControl", {
            get: /**
             * @return {?}
             */ function () {
                return this.controlNavSubject.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.registerNav = /**
         * @param {?} navLevel
         * @return {?}
         */
            function (navLevel) {
                if (!navLevel || this.isNavRegistered(navLevel)) {
                    return;
                }
                this.responsiveNavList.push(navLevel);
                this.registerNavSubject.next(this.responsiveNavList);
            };
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.isNavRegistered = /**
         * @param {?} navLevel
         * @return {?}
         */
            function (navLevel) {
                if (this.responsiveNavList.indexOf(navLevel) > -1) {
                    console.error('Multiple clr-nav-level ' + navLevel + ' attributes found. Please make sure that only one exists');
                    return true;
                }
                return false;
            };
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.unregisterNav = /**
         * @param {?} navLevel
         * @return {?}
         */
            function (navLevel) {
                /** @type {?} */
                var index = this.responsiveNavList.indexOf(navLevel);
                if (index > -1) {
                    this.responsiveNavList.splice(index, 1);
                    this.registerNavSubject.next(this.responsiveNavList);
                }
            };
        /**
         * @param {?} controlCode
         * @param {?} navLevel
         * @return {?}
         */
        ResponsiveNavigationService.prototype.sendControlMessage = /**
         * @param {?} controlCode
         * @param {?} navLevel
         * @return {?}
         */
            function (controlCode, navLevel) {
                /** @type {?} */
                var message = new ResponsiveNavControlMessage(controlCode, navLevel);
                this.controlNavSubject.next(message);
            };
        /**
         * @return {?}
         */
        ResponsiveNavigationService.prototype.closeAllNavs = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var message = new ResponsiveNavControlMessage(ResponsiveNavCodes.NAV_CLOSE_ALL, -999);
                this.controlNavSubject.next(message);
            };
        ResponsiveNavigationService.decorators = [
            { type: i0.Injectable, args: [{ providedIn: 'root' },] }
        ];
        /** @nocollapse */
        ResponsiveNavigationService.ctorParameters = function () { return []; };
        /** @nocollapse */ ResponsiveNavigationService.ngInjectableDef = i0.defineInjectable({ factory: function ResponsiveNavigationService_Factory() { return new ResponsiveNavigationService(); }, token: ResponsiveNavigationService, providedIn: "root" });
        return ResponsiveNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrMainContainer = /** @class */ (function () {
        function ClrMainContainer(elRef, responsiveNavService) {
            this.elRef = elRef;
            this.responsiveNavService = responsiveNavService;
        }
        /**
         * @return {?}
         */
        ClrMainContainer.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._classList = this.elRef.nativeElement.classList;
                this._subscription = this.responsiveNavService.navControl.subscribe({
                    next: function (message) {
                        _this.processMessage(message);
                    },
                });
            };
        /**
         * @param {?} message
         * @return {?}
         */
        ClrMainContainer.prototype.processMessage = /**
         * @param {?} message
         * @return {?}
         */
            function (message) {
                /** @type {?} */
                var navClass = ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
                if (message.controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL) {
                    this._classList.remove(ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
                    this._classList.remove(ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
                }
                else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                    this.controlNav(message.controlCode, navClass);
                }
                else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                    navClass = ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
                    this.controlNav(message.controlCode, navClass);
                }
            };
        /**
         * @param {?} controlCode
         * @param {?} navClass
         * @return {?}
         */
        ClrMainContainer.prototype.controlNav = /**
         * @param {?} controlCode
         * @param {?} navClass
         * @return {?}
         */
            function (controlCode, navClass) {
                if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
                    this._classList.add(navClass);
                }
                else if (controlCode === ResponsiveNavCodes.NAV_CLOSE) {
                    this._classList.remove(navClass);
                }
                else if (controlCode === ResponsiveNavCodes.NAV_TOGGLE) {
                    this._classList.toggle(navClass);
                }
            };
        /**
         * @return {?}
         */
        ClrMainContainer.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        ClrMainContainer.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-main-container', host: { '[class.main-container]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrMainContainer.ctorParameters = function () {
            return [
                { type: i0.ElementRef },
                { type: ResponsiveNavigationService }
            ];
        };
        return ClrMainContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_LAYOUT_DIRECTIVES = [ClrMainContainer];
    var ClrMainContainerModule = /** @class */ (function () {
        function ClrMainContainerModule() {
        }
        ClrMainContainerModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule],
                        declarations: [CLR_LAYOUT_DIRECTIVES],
                        exports: [CLR_LAYOUT_DIRECTIVES],
                    },] }
        ];
        return ClrMainContainerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var MainContainerWillyWonka = /** @class */ (function (_super) {
        __extends(MainContainerWillyWonka, _super);
        function MainContainerWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MainContainerWillyWonka.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-main-container' },] }
        ];
        return MainContainerWillyWonka;
    }(WillyWonka));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NavDetectionOompaLoompa = /** @class */ (function (_super) {
        __extends(NavDetectionOompaLoompa, _super);
        function NavDetectionOompaLoompa(cdr, willyWonka, responsiveNavService) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clr-header should only be used inside of a clr-main-container');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.responsiveNavService = responsiveNavService;
            return _this;
        }
        Object.defineProperty(NavDetectionOompaLoompa.prototype, "flavor", {
            // NavDetectionOompaLoompa is the addition of the nav levels
            // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
            get: 
            // NavDetectionOompaLoompa is the addition of the nav levels
            // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
            /**
             * @return {?}
             */
            function () {
                return this.responsiveNavService.responsiveNavList.reduce(function (sum, navLevel) { return sum + navLevel; }, 0);
            },
            enumerable: true,
            configurable: true
        });
        NavDetectionOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-header' },] }
        ];
        /** @nocollapse */
        NavDetectionOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: MainContainerWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: ResponsiveNavigationService }
            ];
        };
        return NavDetectionOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrHeader = /** @class */ (function () {
        function ClrHeader(responsiveNavService) {
            var _this = this;
            this.responsiveNavService = responsiveNavService;
            this.isNavLevel1OnPage = false;
            this.isNavLevel2OnPage = false;
            this.responsiveNavCodes = ResponsiveNavCodes;
            this._subscription = this.responsiveNavService.registeredNavs.subscribe({
                next: function (navLevelList) {
                    _this.initializeNavTriggers(navLevelList);
                },
            });
        }
        // reset triggers. handles cases when an application has different nav levels on different pages.
        // reset triggers. handles cases when an application has different nav levels on different pages.
        /**
         * @return {?}
         */
        ClrHeader.prototype.resetNavTriggers =
            // reset triggers. handles cases when an application has different nav levels on different pages.
            /**
             * @return {?}
             */
            function () {
                this.isNavLevel1OnPage = false;
                this.isNavLevel2OnPage = false;
            };
        // decides which triggers to show on the header
        // decides which triggers to show on the header
        /**
         * @param {?} navList
         * @return {?}
         */
        ClrHeader.prototype.initializeNavTriggers =
            // decides which triggers to show on the header
            /**
             * @param {?} navList
             * @return {?}
             */
            function (navList) {
                var _this = this;
                this.resetNavTriggers();
                if (navList.length > 2) {
                    console.error('More than 2 Nav Levels detected.');
                    return;
                }
                navList.forEach(function (navLevel) {
                    if (navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                        _this.isNavLevel1OnPage = true;
                    }
                    else if (navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                        _this.isNavLevel2OnPage = true;
                    }
                });
            };
        // closes the nav that is open
        // closes the nav that is open
        /**
         * @return {?}
         */
        ClrHeader.prototype.closeOpenNav =
            // closes the nav that is open
            /**
             * @return {?}
             */
            function () {
                this.responsiveNavService.closeAllNavs();
            };
        // toggles the nav that is open
        // toggles the nav that is open
        /**
         * @param {?} navLevel
         * @return {?}
         */
        ClrHeader.prototype.toggleNav =
            // toggles the nav that is open
            /**
             * @param {?} navLevel
             * @return {?}
             */
            function (navLevel) {
                this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_TOGGLE, navLevel);
            };
        /**
         * @return {?}
         */
        ClrHeader.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        ClrHeader.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-header',
                        template: "\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel1OnPage\"\n            class=\"header-hamburger-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_1)\">\n            <span></span>\n        </button>\n        <ng-content></ng-content>\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel2OnPage\"\n            class=\"header-overflow-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_2)\">\n            <span></span>\n        </button>\n        <div class=\"header-backdrop\" (click)=\"closeOpenNav()\"></div>\n    ",
                        host: { '[class.header]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrHeader.ctorParameters = function () {
            return [
                { type: ResponsiveNavigationService }
            ];
        };
        return ClrHeader;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrNavLevel = /** @class */ (function () {
        function ClrNavLevel(responsiveNavService, elementRef) {
            this.responsiveNavService = responsiveNavService;
            this.elementRef = elementRef;
        }
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.level !== ResponsiveNavCodes.NAV_LEVEL_1 && this.level !== ResponsiveNavCodes.NAV_LEVEL_2) {
                    console.error('Nav Level can only be 1 or 2');
                    return;
                }
                this.responsiveNavService.registerNav(this.level);
                this.addNavClass(this.level);
            };
        /**
         * @param {?} level
         * @return {?}
         */
        ClrNavLevel.prototype.addNavClass = /**
         * @param {?} level
         * @return {?}
         */
            function (level) {
                /** @type {?} */
                var navHostClassList = this.elementRef.nativeElement.classList;
                if (level === ResponsiveNavCodes.NAV_LEVEL_1) {
                    navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_1);
                }
                else if (level === ResponsiveNavCodes.NAV_LEVEL_2) {
                    navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_2);
                }
            };
        Object.defineProperty(ClrNavLevel.prototype, "level", {
            get: /**
             * @return {?}
             */ function () {
                return this._level;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrNavLevel.prototype, "responsiveNavCodes", {
            // getter to access the responsive navigation codes from the template
            get: 
            // getter to access the responsive navigation codes from the template
            /**
             * @return {?}
             */
            function () {
                return ResponsiveNavCodes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.open = /**
         * @return {?}
         */
            function () {
                this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, this.level);
            };
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.close = /**
         * @return {?}
         */
            function () {
                this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, this.level);
            };
        // TODO: Figure out whats the best way to do this. Possible methods
        // 1. HostListener (current solution)
        // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
        // why
        // TODO: Figure out whats the best way to do this. Possible methods
        // 1. HostListener (current solution)
        // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
        // why
        /**
         * @param {?} target
         * @return {?}
         */
        ClrNavLevel.prototype.onMouseClick =
            // TODO: Figure out whats the best way to do this. Possible methods
            // 1. HostListener (current solution)
            // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
            // why
            /**
             * @param {?} target
             * @return {?}
             */
            function (target) {
                /** @type {?} */
                var current = target;
                // Get the element in the DOM on which the mouse was clicked
                /** @type {?} */
                var navHost = this.elementRef.nativeElement;
                // Start checking if current and navHost are equal.
                // If not traverse to the parentNode and check again.
                while (current) {
                    if (current === navHost) {
                        return;
                    }
                    else if (current.classList.contains('nav-link')) {
                        this.close();
                        return;
                    }
                    current = current.parentNode;
                }
            };
        /**
         * @return {?}
         */
        ClrNavLevel.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.responsiveNavService.unregisterNav(this.level);
            };
        ClrNavLevel.decorators = [
            { type: i0.Directive, args: [{ selector: '[clr-nav-level]' },] }
        ];
        /** @nocollapse */
        ClrNavLevel.ctorParameters = function () {
            return [
                { type: ResponsiveNavigationService },
                { type: i0.ElementRef }
            ];
        };
        ClrNavLevel.propDecorators = {
            _level: [{ type: i0.Input, args: ['clr-nav-level',] }],
            onMouseClick: [{ type: i0.HostListener, args: ['click', ['$event.target'],] }]
        };
        return ClrNavLevel;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_NAVIGATION_DIRECTIVES = [
        ClrHeader,
        ClrNavLevel,
        NavDetectionOompaLoompa,
        MainContainerWillyWonka,
    ];
    var ClrNavigationModule = /** @class */ (function () {
        function ClrNavigationModule() {
        }
        ClrNavigationModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrDropdownModule],
                        declarations: [CLR_NAVIGATION_DIRECTIVES],
                        exports: [CLR_NAVIGATION_DIRECTIVES],
                    },] }
        ];
        return ClrNavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TemplateRefContainer = /** @class */ (function () {
        function TemplateRefContainer() {
        }
        TemplateRefContainer.decorators = [
            { type: i0.Component, args: [{
                        template: "\n      <ng-template>\n        <ng-content></ng-content>\n      </ng-template>\n    "
                    }] }
        ];
        TemplateRefContainer.propDecorators = {
            template: [{ type: i0.ViewChild, args: [i0.TemplateRef,] }]
        };
        return TemplateRefContainer;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var TEMPLATE_REF_DIRECTIVES = [TemplateRefContainer];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTemplateRefModule = /** @class */ (function () {
        function ClrTemplateRefModule() {
        }
        ClrTemplateRefModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [TEMPLATE_REF_DIRECTIVES],
                        entryComponents: [TEMPLATE_REF_DIRECTIVES],
                        exports: [TEMPLATE_REF_DIRECTIVES],
                    },] }
        ];
        return ClrTemplateRefModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TabsWillyWonka = /** @class */ (function (_super) {
        __extends(TabsWillyWonka, _super);
        function TabsWillyWonka() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TabsWillyWonka.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-tabs' },] }
        ];
        return TabsWillyWonka;
    }(WillyWonka));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ActiveOompaLoompa = /** @class */ (function (_super) {
        __extends(ActiveOompaLoompa, _super);
        function ActiveOompaLoompa(cdr, willyWonka, id, ifActive) {
            var _this = this;
            if (!willyWonka) {
                throw new Error('clrTabLink and clr-tab-content should only be used inside of a clr-tabs');
            }
            _this = _super.call(this, cdr, willyWonka) || this;
            _this.ifActive = ifActive;
            _this.id = id;
            return _this;
        }
        Object.defineProperty(ActiveOompaLoompa.prototype, "flavor", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActive.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ActiveOompaLoompa.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrTabLink], clr-tab-content' },] }
        ];
        /** @nocollapse */
        ActiveOompaLoompa.ctorParameters = function () {
            return [
                { type: i0.ChangeDetectorRef },
                { type: TabsWillyWonka, decorators: [{ type: i0.Optional }] },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: IfActiveService }
            ];
        };
        return ActiveOompaLoompa;
    }(OompaLoompa));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // TODO: if we find more components that could use this, consider moving this to utils
    var AriaService = /** @class */ (function () {
        function AriaService() {
        }
        AriaService.decorators = [
            { type: i0.Injectable }
        ];
        return AriaService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TabsService = /** @class */ (function () {
        function TabsService() {
            this._children = [];
        }
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsService.prototype.register = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this._children.push(tab);
            };
        Object.defineProperty(TabsService.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsService.prototype, "activeTab", {
            get: /**
             * @return {?}
             */ function () {
                return this.children.find(function (tab) {
                    return tab.active;
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabsService.prototype, "overflowTabs", {
            get: /**
             * @return {?}
             */ function () {
                return this.children.filter(function (tab) {
                    return tab.tabLink.inOverflow === true;
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsService.prototype.unregister = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                /** @type {?} */
                var index = this.children.indexOf(tab);
                if (index > -1) {
                    this.children.splice(index, 1);
                }
            };
        TabsService.decorators = [
            { type: i0.Injectable }
        ];
        return TabsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbTabContentComponents = 0;
    var ClrTabContent = /** @class */ (function () {
        function ClrTabContent(ifActiveService, id, ariaService) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.ariaService = ariaService;
            if (!this.tabContentId) {
                this.tabContentId = 'clr-tab-content-' + nbTabContentComponents++;
            }
        }
        Object.defineProperty(ClrTabContent.prototype, "ariaLabelledBy", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaLabelledBy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "tabContentId", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaControls;
            },
            set: /**
             * @param {?} id
             * @return {?}
             */ function (id) {
                this.ariaService.ariaControls = id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabContent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTabContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tab-content',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[id]': 'tabContentId',
                            '[attr.aria-labelledby]': 'ariaLabelledBy',
                            '[attr.aria-hidden]': '!active',
                            '[attr.aria-expanded]': 'active',
                            '[attr.data-hidden]': '!active',
                            role: 'tabpanel',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrTabContent.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: AriaService }
            ];
        };
        ClrTabContent.propDecorators = {
            templateRef: [{ type: i0.ViewChild, args: ['tabContentProjectedRef',] }],
            tabContentId: [{ type: i0.Input, args: ['id',] }]
        };
        return ClrTabContent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbTabsComponent = 0;
    /** @type {?} */
    var TABS_ID = new i0.InjectionToken('TABS_ID');
    /**
     * @return {?}
     */
    function tokenFactory$1() {
        return 'clr-tabs-' + nbTabsComponent++;
    }
    /** @type {?} */
    var TABS_ID_PROVIDER = {
        provide: TABS_ID,
        useFactory: tokenFactory$1,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var nbTabLinkComponents = 0;
    var ClrTabLink = /** @class */ (function () {
        function ClrTabLink(ifActiveService, id, ariaService, el, cfr, viewContainerRef, tabsId) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.ariaService = ariaService;
            this.el = el;
            this.cfr = cfr;
            this.viewContainerRef = viewContainerRef;
            this.tabsId = tabsId;
            if (!this.tabLinkId) {
                this.tabLinkId = 'clr-tab-link-' + nbTabLinkComponents++;
            }
            // Tab links can be rendered in one of two places: in the main area or inside the overflow dropdown menu.
            // Here, we create a container so that its template can be used to create embeddedView on the fly.
            // See TabsService's renderView() method and how it's used in Tabs class for an example.
            /** @type {?} */
            var factory = this.cfr.resolveComponentFactory(TemplateRefContainer);
            this.templateRefContainer = this.viewContainerRef.createComponent(factory, 1, undefined, [
                [this.el.nativeElement],
            ]).instance;
        }
        Object.defineProperty(ClrTabLink.prototype, "ariaControls", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaControls;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabLink.prototype, "tabLinkId", {
            get: /**
             * @return {?}
             */ function () {
                return this.ariaService.ariaLabelledBy;
            },
            set: /**
             * @param {?} id
             * @return {?}
             */ function (id) {
                this.ariaService.ariaLabelledBy = id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTabLink.prototype.activate = /**
         * @return {?}
         */
            function () {
                this.ifActiveService.current = this.id;
            };
        Object.defineProperty(ClrTabLink.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTabLink.decorators = [
            { type: i0.Directive, args: [{
                        selector: '[clrTabLink]',
                        host: {
                            '[id]': 'tabLinkId',
                            '[attr.aria-selected]': 'active',
                            '[attr.aria-hidden]': 'false',
                            '[attr.aria-controls]': 'ariaControls',
                            '[class.btn]': 'true',
                            '[class.btn-link]': '!inOverflow',
                            '[class.nav-link]': '!inOverflow',
                            '[class.nav-item]': '!inOverflow',
                            '[class.active]': 'active',
                            role: 'tab',
                            type: 'button',
                        },
                    },] }
        ];
        /** @nocollapse */
        ClrTabLink.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: AriaService },
                { type: i0.ElementRef },
                { type: i0.ComponentFactoryResolver },
                { type: i0.ViewContainerRef },
                { type: Number, decorators: [{ type: i0.Inject, args: [TABS_ID,] }] }
            ];
        };
        ClrTabLink.propDecorators = {
            inOverflow: [{ type: i0.Input, args: ['clrTabLinkInOverflow',] }],
            tabLinkId: [{ type: i0.Input, args: ['id',] }],
            activate: [{ type: i0.HostListener, args: ['click',] }]
        };
        return ClrTabLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTab = /** @class */ (function () {
        function ClrTab(ifActiveService, id, tabsService) {
            this.ifActiveService = ifActiveService;
            this.id = id;
            this.tabsService = tabsService;
            tabsService.register(this);
        }
        /**
         * @return {?}
         */
        ClrTab.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.tabsService.unregister(this);
            };
        Object.defineProperty(ClrTab.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this.ifActiveService.current === this.id;
            },
            enumerable: true,
            configurable: true
        });
        ClrTab.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tab',
                        template: "\n        <ng-content></ng-content>\n    ",
                        providers: [IF_ACTIVE_ID_PROVIDER, AriaService]
                    }] }
        ];
        /** @nocollapse */
        ClrTab.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: Number, decorators: [{ type: i0.Inject, args: [IF_ACTIVE_ID,] }] },
                { type: TabsService }
            ];
        };
        ClrTab.propDecorators = {
            tabLink: [{ type: i0.ContentChild, args: [ClrTabLink,] }],
            tabContent: [{ type: i0.ContentChild, args: [ClrTabContent,] }]
        };
        return ClrTab;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTabOverflowContent = /** @class */ (function (_super) {
        __extends(ClrTabOverflowContent, _super);
        function ClrTabOverflowContent(injector, parentHost) {
            var _this = _super.call(this, injector, parentHost) || this;
            _this.anchorPoint = Point.BOTTOM_RIGHT;
            _this.popoverPoint = Point.RIGHT_TOP;
            _this.closeOnOutsideClick = true;
            return _this;
        }
        ClrTabOverflowContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tab-overflow-content',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.dropdown-menu]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrTabOverflowContent.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.SkipSelf }] }
            ];
        };
        return ClrTabOverflowContent;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTabs = /** @class */ (function () {
        function ClrTabs(ifActiveService, ifOpenService, tabsService, tabsId, commonStrings) {
            this.ifActiveService = ifActiveService;
            this.ifOpenService = ifOpenService;
            this.tabsService = tabsService;
            this.tabsId = tabsId;
            this.commonStrings = commonStrings;
        }
        Object.defineProperty(ClrTabs.prototype, "activeTabInOverflow", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTabs.prototype, "tabIds", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabsService.children.map(function (tab) { return tab.tabLink.tabLinkId; }).join(' ');
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrTabs.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                if (typeof this.ifActiveService.current === 'undefined') {
                    this.tabLinkDirectives.first.activate();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ClrTabs.prototype.toggleOverflow = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.ifOpenService.toggleWithEvent(event);
            };
        ClrTabs.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tabs',
                        template: "\n        <ul class=\"nav\" role=\"tablist\" [attr.aria-owns]=\"tabIds\">\n            <!--tab links-->\n            <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                <ng-container *ngIf=\"link.tabsId === tabsId && !link.inOverflow\"\n                              [ngTemplateOutlet]=\"link.templateRefContainer.template\">\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"tabsService.overflowTabs.length > 0\">\n                <div class=\"tabs-overflow bottom-right\" [class.open]=\"ifOpenService.open\"\n                     (click)=\"toggleOverflow($event)\">\n                    <li role=\"presentation\" class=\"nav-item\">\n                        <button class=\"btn btn-link nav-link dropdown-toggle\" type=\"button\" [class.active]=\"activeTabInOverflow\">\n                            <clr-icon shape=\"ellipsis-horizontal\"\n                              [class.is-info]=\"ifOpenService.open\"\n                              [attr.title]=\"commonStrings.more\"></clr-icon>\n                        </button>\n                    </li>\n                    <!--tab links in overflow menu-->\n                    <clr-tab-overflow-content>\n                        <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                            <ng-container *ngIf=\"link.tabsId === tabsId && link.inOverflow\"\n                                          [ngTemplateOutlet]=\"link.templateRefContainer.template\">\n                            </ng-container>\n                        </ng-container>\n                    </clr-tab-overflow-content>\n                </div>\n            </ng-container>\n        </ul>\n        <!--tab content-->\n        <ng-content></ng-content>\n    ",
                        providers: [IfActiveService, IfOpenService, TabsService, TABS_ID_PROVIDER]
                    }] }
        ];
        /** @nocollapse */
        ClrTabs.ctorParameters = function () {
            return [
                { type: IfActiveService },
                { type: IfOpenService },
                { type: TabsService },
                { type: Number, decorators: [{ type: i0.Inject, args: [TABS_ID,] }] },
                { type: ClrCommonStrings }
            ];
        };
        ClrTabs.propDecorators = {
            tabLinkDirectives: [{ type: i0.ContentChildren, args: [ClrTabLink, { descendants: true },] }]
        };
        return ClrTabs;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_TABS_DIRECTIVES = [
        ClrTabContent,
        ClrTab,
        ClrTabs,
        ClrTabOverflowContent,
        ClrTabLink,
        TabsWillyWonka,
        ActiveOompaLoompa,
    ];
    var ClrTabsModule = /** @class */ (function () {
        function ClrTabsModule() {
        }
        ClrTabsModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule],
                        declarations: [CLR_TABS_DIRECTIVES],
                        exports: [CLR_TABS_DIRECTIVES, ClrConditionalModule],
                    },] }
        ];
        return ClrTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavGroupRegistrationService = /** @class */ (function () {
        function VerticalNavGroupRegistrationService() {
            this.navGroupCount = 0;
        }
        /**
         * @return {?}
         */
        VerticalNavGroupRegistrationService.prototype.registerNavGroup = /**
         * @return {?}
         */
            function () {
                this.navGroupCount++;
            };
        /**
         * @return {?}
         */
        VerticalNavGroupRegistrationService.prototype.unregisterNavGroup = /**
         * @return {?}
         */
            function () {
                this.navGroupCount--;
            };
        VerticalNavGroupRegistrationService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavGroupRegistrationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavIconService = /** @class */ (function () {
        function VerticalNavIconService() {
            this._icons = 0;
        }
        Object.defineProperty(VerticalNavIconService.prototype, "hasIcons", {
            get: /**
             * @return {?}
             */ function () {
                return this._icons > 0;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        VerticalNavIconService.prototype.registerIcon = /**
         * @return {?}
         */
            function () {
                this._icons++;
            };
        /**
         * @return {?}
         */
        VerticalNavIconService.prototype.unregisterIcon = /**
         * @return {?}
         */
            function () {
                this._icons--;
            };
        VerticalNavIconService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavIconService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavService = /** @class */ (function () {
        function VerticalNavService() {
            this._animateOnCollapsed = new rxjs.Subject();
            this._collapsedChanged = new rxjs.Subject();
            this._collapsed = false;
            this._collapsible = false;
        }
        Object.defineProperty(VerticalNavService.prototype, "animateOnCollapsed", {
            get: /**
             * @return {?}
             */ function () {
                return this._animateOnCollapsed.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsedChanged", {
            get: /**
             * @return {?}
             */ function () {
                return this._collapsedChanged.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsed", {
            get: /**
             * @return {?}
             */ function () {
                return this._collapsed;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this.collapsible && this._collapsed !== value) {
                    this.updateCollapseBehavior(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VerticalNavService.prototype, "collapsible", {
            get: /**
             * @return {?}
             */ function () {
                return this._collapsible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this._collapsible !== value) {
                    if (!value && this.collapsed) {
                        this.updateCollapseBehavior(false);
                    }
                    this._collapsible = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        VerticalNavService.prototype.updateCollapseBehavior = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._animateOnCollapsed.next(value);
                this._collapsed = value;
                this._collapsedChanged.next(value);
            };
        VerticalNavService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNav = /** @class */ (function () {
        function ClrVerticalNav(_navService, _navIconService, _navGroupRegistrationService, commonStrings) {
            var _this = this;
            this._navService = _navService;
            this._navIconService = _navIconService;
            this._navGroupRegistrationService = _navGroupRegistrationService;
            this.commonStrings = commonStrings;
            this._collapsedChanged = new i0.EventEmitter(true);
            this._sub = this._navService.collapsedChanged.subscribe(function (value) {
                _this._collapsedChanged.emit(value);
            });
        }
        Object.defineProperty(ClrVerticalNav.prototype, "collapsible", {
            get: /**
             * @return {?}
             */ function () {
                return this._navService.collapsible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._navService.collapsible = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "collapsed", {
            get: /**
             * @return {?}
             */ function () {
                return this._navService.collapsed;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._navService.collapsed = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "hasNavGroups", {
            get: /**
             * @return {?}
             */ function () {
                return this._navGroupRegistrationService.navGroupCount > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNav.prototype, "hasIcons", {
            get: /**
             * @return {?}
             */ function () {
                return this._navIconService.hasIcons;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrVerticalNav.prototype.toggleByButton = /**
         * @return {?}
         */
            function () {
                this.collapsed = !this.collapsed;
            };
        /**
         * @return {?}
         */
        ClrVerticalNav.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._sub.unsubscribe();
            };
        ClrVerticalNav.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-vertical-nav',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<button type=\"button\" class=\"nav-trigger\"\n        [class.on-collapse]=\"collapsed\"\n        (click)=\"toggleByButton()\"\n        *ngIf=\"collapsible\">\n    <clr-icon shape=\"angle-double\"\n              class=\"nav-trigger-icon\"\n              [attr.dir]=\"(this.collapsed) ? 'right' : 'left'\"\n              [attr.title]=\"(this.collapsed) ? commonStrings.expand : commonStrings.collapse\"></clr-icon>\n</button>\n<!-- Click handler on .nav-content is bad but required :-( -->\n<div class=\"nav-content\">\n    <ng-content></ng-content>\n    <button (click)=\"collapsed = false\" class=\"nav-btn\" *ngIf=\"collapsible && collapsed\"></button>\n</div>\n",
                        providers: [VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService],
                        host: {
                            class: 'clr-vertical-nav',
                            '[class.is-collapsed]': 'collapsed',
                            '[class.has-nav-groups]': 'hasNavGroups',
                            '[class.has-icons]': 'hasIcons',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrVerticalNav.ctorParameters = function () {
            return [
                { type: VerticalNavService },
                { type: VerticalNavIconService },
                { type: VerticalNavGroupRegistrationService },
                { type: ClrCommonStrings }
            ];
        };
        ClrVerticalNav.propDecorators = {
            collapsible: [{ type: i0.Input, args: ['clrVerticalNavCollapsible',] }],
            collapsed: [{ type: i0.Input, args: ['clrVerticalNavCollapsed',] }],
            _collapsedChanged: [{ type: i0.Output, args: ['clrVerticalNavCollapsedChange',] }]
        };
        return ClrVerticalNav;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var VerticalNavGroupService = /** @class */ (function () {
        function VerticalNavGroupService() {
            this._expandChange = new rxjs.Subject();
        }
        Object.defineProperty(VerticalNavGroupService.prototype, "expandChange", {
            get: /**
             * @return {?}
             */ function () {
                return this._expandChange.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        VerticalNavGroupService.prototype.expand = /**
         * @return {?}
         */
            function () {
                this._expandChange.next(true);
            };
        VerticalNavGroupService.decorators = [
            { type: i0.Injectable }
        ];
        return VerticalNavGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var EXPANDED_STATE = 'expanded';
    /** @type {?} */
    var COLLAPSED_STATE = 'collapsed';
    var ClrVerticalNavGroup = /** @class */ (function () {
        function ClrVerticalNavGroup(_itemExpand, _navGroupRegistrationService, _navGroupService, _navService, commonStrings) {
            var _this = this;
            this._itemExpand = _itemExpand;
            this._navGroupRegistrationService = _navGroupRegistrationService;
            this._navGroupService = _navGroupService;
            this._navService = _navService;
            this.commonStrings = commonStrings;
            this.wasExpanded = false;
            this.expandedChange = new i0.EventEmitter(true);
            this._subscriptions = [];
            this._expandAnimationState = COLLAPSED_STATE;
            this._navGroupRegistrationService.registerNavGroup();
            // FIXME: This subscription handles a corner case
            // Vertical Nav collapse requires the animation to run first and then
            // remove the nodes from the DOM. If the user directly sets the input
            // on the clrIfExpanded directive, we have no chance to run the animation
            // and wait for it to complete. This subscription makes sure that the
            // animation states are correct for that edge case.
            this._subscriptions.push(this._itemExpand.expandChange.subscribe(function (value) {
                if (value && _this.expandAnimationState === COLLAPSED_STATE) {
                    if (_this._navService.collapsed) {
                        _this._navService.collapsed = false;
                    }
                    _this.expandAnimationState = EXPANDED_STATE;
                }
                else if (!value && _this.expandAnimationState === EXPANDED_STATE) {
                    _this.expandAnimationState = COLLAPSED_STATE;
                }
            }));
            // 1. If the nav is collapsing, close the open nav group + save its state
            // 2. If the nav is expanding, expand the nav group if the previous state was expanded
            this._subscriptions.push(this._navService.animateOnCollapsed.subscribe(function (goingToCollapse) {
                if (goingToCollapse && _this.expanded) {
                    _this.wasExpanded = true;
                    _this.expandAnimationState = COLLAPSED_STATE;
                }
                else if (!goingToCollapse && _this.wasExpanded) {
                    _this.expandGroup();
                    _this.wasExpanded = false;
                }
            }));
            // If a link is clicked, expand the nav group
            this._subscriptions.push(this._navGroupService.expandChange.subscribe(function (expand) {
                if (expand && !_this.expanded) {
                    _this.expandGroup();
                }
            }));
        }
        Object.defineProperty(ClrVerticalNavGroup.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemExpand.expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._itemExpand.expanded !== value) {
                    this._itemExpand.expanded = value;
                    this.expandedChange.emit(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrVerticalNavGroup.prototype, "userExpandedInput", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                value = !!value;
                if (this.expanded !== value) {
                    // We have to call toggleExpand because some cases require animations to occur first
                    // Directly setting the Expand service value skips the animation and can result in
                    // nodes in the DOM but the nav group still being collapsed
                    this.toggleExpand();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.expandGroup = /**
         * @return {?}
         */
            function () {
                this.expanded = true;
                // Expanded animation occurs after Expand.expand is set to true
                this.expandAnimationState = EXPANDED_STATE;
            };
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.collapseGroup = /**
         * @return {?}
         */
            function () {
                // If a Vertical Nav Group toggle button is clicked while the Vertical Nav is in Collapsed state,
                // the Vertical Nav should be expanded first.
                this.expandAnimationState = COLLAPSED_STATE;
            };
        // closes a group after the collapse animation
        // closes a group after the collapse animation
        /**
         * @param {?} $event
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.expandAnimationDone =
            // closes a group after the collapse animation
            /**
             * @param {?} $event
             * @return {?}
             */
            function ($event) {
                if ($event.toState === COLLAPSED_STATE) {
                    this.expanded = false;
                }
            };
        Object.defineProperty(ClrVerticalNavGroup.prototype, "expandAnimationState", {
            get: /**
             * @return {?}
             */ function () {
                return this._expandAnimationState;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._expandAnimationState) {
                    this._expandAnimationState = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                if (this.expanded) {
                    this.collapseGroup();
                }
                else {
                    // If nav is collasped, first open the nav
                    if (this._navService.collapsed) {
                        this._navService.collapsed = false;
                    }
                    // then expand the nav group
                    this.expandGroup();
                }
            };
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // This makes sure that if someone marks a nav group expanded in a collapsed nav
                // the expanded property is switched back to collapsed state.
                if (this._navService.collapsed && this.expanded) {
                    this.wasExpanded = true;
                    this.expandAnimationState = COLLAPSED_STATE;
                }
            };
        /**
         * @return {?}
         */
        ClrVerticalNavGroup.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
                this._navGroupRegistrationService.unregisterNavGroup();
            };
        ClrVerticalNavGroup.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-vertical-nav-group',
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"nav-group-content\">\n    <ng-content select=\"[clrVerticalNavLink]\"></ng-content>\n    <button\n        class=\"nav-group-trigger\"\n        type=\"button\"\n        (click)=\"toggleExpand()\">\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <div class=\"nav-group-text\">\n            <ng-content></ng-content>\n        </div>\n        <clr-icon shape=\"caret\"\n                  class=\"nav-group-trigger-icon\"\n                  [attr.dir]=\"(this.expanded) ? 'down' : 'right'\"\n                  [attr.title]=\"(this.expanded) ? commonStrings.collapse : commonStrings.expand\">\n        </clr-icon>\n    </button>\n</div>\n<!--TODO: This animation needs to be added to the clr-vertical-nav-group-children component-->\n<div class=\"nav-group-children\"\n     [@clrExpand]=\"expandAnimationState\"\n     (@clrExpand.done)=\"expandAnimationDone($event)\">\n    <ng-content select=\"[clrIfExpanded], clr-vertical-nav-group-children\"></ng-content>\n</div>\n",
                        providers: [Expand, VerticalNavGroupService],
                        animations: [
                            animations.trigger('clrExpand', [
                                animations.state(EXPANDED_STATE, animations.style({ height: '*' })),
                                animations.state(COLLAPSED_STATE, animations.style({ height: 0, 'overflow-y': 'hidden', visibility: 'hidden' })),
                                animations.transition(EXPANDED_STATE + " <=> " + COLLAPSED_STATE, animations.animate('0.2s ease-in-out')),
                            ]),
                        ],
                        host: { class: 'nav-group' }
                    }] }
        ];
        /** @nocollapse */
        ClrVerticalNavGroup.ctorParameters = function () {
            return [
                { type: Expand },
                { type: VerticalNavGroupRegistrationService },
                { type: VerticalNavGroupService },
                { type: VerticalNavService },
                { type: ClrCommonStrings }
            ];
        };
        ClrVerticalNavGroup.propDecorators = {
            expanded: [{ type: i0.HostBinding, args: ['class.is-expanded',] }],
            userExpandedInput: [{ type: i0.Input, args: ['clrVerticalNavGroupExpanded',] }],
            expandedChange: [{ type: i0.Output, args: ['clrVerticalNavGroupExpandedChange',] }]
        };
        return ClrVerticalNavGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNavGroupChildren = /** @class */ (function () {
        function ClrVerticalNavGroupChildren() {
        }
        ClrVerticalNavGroupChildren.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-vertical-nav-group-children',
                        template: "\n        <ng-content></ng-content>\n    "
                    }] }
        ];
        return ClrVerticalNavGroupChildren;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNavIcon = /** @class */ (function () {
        function ClrVerticalNavIcon(_verticalNavIconService) {
            this._verticalNavIconService = _verticalNavIconService;
            this._verticalNavIconService.registerIcon();
        }
        /**
         * @return {?}
         */
        ClrVerticalNavIcon.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._verticalNavIconService.unregisterIcon();
            };
        ClrVerticalNavIcon.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrVerticalNavIcon]', host: { class: 'nav-icon' } },] }
        ];
        /** @nocollapse */
        ClrVerticalNavIcon.ctorParameters = function () {
            return [
                { type: VerticalNavIconService }
            ];
        };
        return ClrVerticalNavIcon;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrVerticalNavLink = /** @class */ (function () {
        function ClrVerticalNavLink(_navGroupService) {
            this._navGroupService = _navGroupService;
        }
        /**
         * @return {?}
         */
        ClrVerticalNavLink.prototype.expandParentNavGroup = /**
         * @return {?}
         */
            function () {
                if (this._navGroupService) {
                    this._navGroupService.expand();
                }
            };
        ClrVerticalNavLink.decorators = [
            { type: i0.Component, args: [{
                        selector: '[clrVerticalNavLink]',
                        template: "\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <span class=\"nav-text\">\n            <ng-content></ng-content>    \n        </span>\n    ",
                        host: { class: 'nav-link' }
                    }] }
        ];
        /** @nocollapse */
        ClrVerticalNavLink.ctorParameters = function () {
            return [
                { type: VerticalNavGroupService, decorators: [{ type: i0.Optional }] }
            ];
        };
        ClrVerticalNavLink.propDecorators = {
            expandParentNavGroup: [{ type: i0.HostListener, args: ['click',] }]
        };
        return ClrVerticalNavLink;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_VERTICAL_NAV_DIRECTIVES = [
        ClrVerticalNav,
        ClrVerticalNavLink,
        ClrVerticalNavGroup,
        ClrVerticalNavGroupChildren,
        ClrVerticalNavIcon,
    ];
    var ClrVerticalNavModule = /** @class */ (function () {
        function ClrVerticalNavModule() {
        }
        ClrVerticalNavModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrIfExpandModule],
                        declarations: [CLR_VERTICAL_NAV_DIRECTIVES],
                        exports: [CLR_VERTICAL_NAV_DIRECTIVES, ClrIfExpandModule, ClrIconModule],
                    },] }
        ];
        return ClrVerticalNavModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrLayoutModule = /** @class */ (function () {
        function ClrLayoutModule() {
        }
        ClrLayoutModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule] },] }
        ];
        return ClrLayoutModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ScrollingService = /** @class */ (function () {
        function ScrollingService(_document) {
            this._document = _document;
        }
        /**
         * @return {?}
         */
        ScrollingService.prototype.stopScrolling = /**
         * @return {?}
         */
            function () {
                this._document.body.classList.add('no-scrolling');
            };
        /**
         * @return {?}
         */
        ScrollingService.prototype.resumeScrolling = /**
         * @return {?}
         */
            function () {
                if (this._document.body.classList.contains('no-scrolling')) {
                    this._document.body.classList.remove('no-scrolling');
                }
            };
        ScrollingService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        ScrollingService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        return ScrollingService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrModal = /** @class */ (function () {
        function ClrModal(_scrollingService, commonStrings, modalId) {
            this._scrollingService = _scrollingService;
            this.commonStrings = commonStrings;
            this.modalId = modalId;
            this._open = false;
            this._openChanged = new i0.EventEmitter(false);
            this.closable = true;
            this.staticBackdrop = false;
            this.skipAnimation = 'false';
            // presently this is only used by wizards
            this.bypassScrollService = false;
            this.stopClose = false;
            this.altClose = new i0.EventEmitter(false);
        }
        Object.defineProperty(ClrModal.prototype, "sizeClass", {
            get: /**
             * @return {?}
             */ function () {
                if (this.size) {
                    return 'modal-' + this.size;
                }
                else {
                    return '';
                }
            },
            enumerable: true,
            configurable: true
        });
        // Detect when _open is set to true and set no-scrolling to true
        // Detect when _open is set to true and set no-scrolling to true
        /**
         * @param {?} changes
         * @return {?}
         */
        ClrModal.prototype.ngOnChanges =
            // Detect when _open is set to true and set no-scrolling to true
            /**
             * @param {?} changes
             * @return {?}
             */
            function (changes) {
                if (!this.bypassScrollService && changes && changes.hasOwnProperty('_open')) {
                    if (changes._open.currentValue) {
                        this._scrollingService.stopScrolling();
                    }
                    else {
                        this._scrollingService.resumeScrolling();
                    }
                }
            };
        /**
         * @return {?}
         */
        ClrModal.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._scrollingService.resumeScrolling();
            };
        /**
         * @return {?}
         */
        ClrModal.prototype.open = /**
         * @return {?}
         */
            function () {
                if (this._open) {
                    return;
                }
                this._open = true;
                this._openChanged.emit(true);
            };
        /**
         * @return {?}
         */
        ClrModal.prototype.close = /**
         * @return {?}
         */
            function () {
                if (this.stopClose) {
                    this.altClose.emit(false);
                    return;
                }
                if (!this.closable || !this._open) {
                    return;
                }
                this._open = false;
                // todo: remove this after animation bug is fixed https://github.com/angular/angular/issues/15798
                // this was handled by the fadeDone event below, but that AnimationEvent is not firing in Angular 4.0.
                this._openChanged.emit(false);
                // SPECME
                this.focusTrap.setPreviousFocus(); // Handles moving focus back to the element that had it before.
            };
        /**
         * @param {?} e
         * @return {?}
         */
        ClrModal.prototype.fadeDone = /**
         * @param {?} e
         * @return {?}
         */
            function (e) {
                if (e.toState === 'void') {
                    this._openChanged.emit(false);
                }
            };
        ClrModal.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-modal',
                        viewProviders: [ScrollingService],
                        template: "\n<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div clrFocusTrap class=\"modal\" *ngIf=\"_open\">\n    <!--fixme: revisit when ngClass works with exit animation-->\n    <div [@fadeDown]=\"skipAnimation\" (@fadeDown.done)=\"fadeDone($event)\"\n         class=\"modal-dialog\"\n         [class.modal-sm]=\"size == 'sm'\"\n         [class.modal-lg]=\"size == 'lg'\"\n         [class.modal-xl]=\"size == 'xl'\"\n         role=\"dialog\"\n         [attr.aria-hidden]=\"!_open\"\n         [attr.aria-labelledby]=\"modalId\">\n\n      <div class=\"modal-content-wrapper\">\n        <!-- only used in wizards -->\n        <ng-content select=\".modal-nav\"></ng-content>\n\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <button type=\"button\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n              <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n            </button>\n            <div class=\"modal-title-wrapper\" id=\"{{modalId}}\">\n              <ng-content select=\".modal-title\"></ng-content>\n            </div>\n          </div>\n          <ng-content select=\".modal-body\"></ng-content>\n          <ng-content select=\".modal-footer\"></ng-content>\n        </div>\n      </div>\n    </div>\n\n    <div [@fade] class=\"modal-backdrop\"\n         aria-hidden=\"true\"\n         (click)=\"staticBackdrop || close()\"></div>\n</div>\n\n",
                        animations: [
                            animations.trigger('fadeDown', [
                                animations.transition('* => false', [animations.style({ opacity: 0, transform: 'translate(0, -25%)' }), animations.animate('0.2s ease-in-out')]),
                                animations.transition('false => *', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0, transform: 'translate(0, -25%)' }))]),
                            ]),
                            animations.trigger('fade', [
                                animations.transition('void => *', [animations.style({ opacity: 0 }), animations.animate('0.2s ease-in-out', animations.style({ opacity: 0.85 }))]),
                                animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0 }))]),
                            ]),
                        ],
                        providers: [UNIQUE_ID_PROVIDER],
                        styles: ["\n        :host { display: none; }\n        :host.open { display: inline; }\n    "]
                    }] }
        ];
        /** @nocollapse */
        ClrModal.ctorParameters = function () {
            return [
                { type: ScrollingService },
                { type: ClrCommonStrings },
                { type: String, decorators: [{ type: i0.Inject, args: [UNIQUE_ID,] }] }
            ];
        };
        ClrModal.propDecorators = {
            focusTrap: [{ type: i0.ViewChild, args: [FocusTrapDirective,] }],
            _open: [{ type: i0.HostBinding, args: ['class.open',] }, { type: i0.Input, args: ['clrModalOpen',] }],
            _openChanged: [{ type: i0.Output, args: ['clrModalOpenChange',] }],
            closable: [{ type: i0.Input, args: ['clrModalClosable',] }],
            size: [{ type: i0.Input, args: ['clrModalSize',] }],
            staticBackdrop: [{ type: i0.Input, args: ['clrModalStaticBackdrop',] }],
            skipAnimation: [{ type: i0.Input, args: ['clrModalSkipAnimation',] }],
            bypassScrollService: [{ type: i0.Input, args: ['clrModalOverrideScrollService',] }],
            stopClose: [{ type: i0.Input, args: ['clrModalPreventClose',] }],
            altClose: [{ type: i0.Output, args: ['clrModalAlternateClose',] }],
            close: [{ type: i0.HostListener, args: ['body:keyup.escape',] }]
        };
        return ClrModal;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_MODAL_DIRECTIVES = [ClrModal];
    var ClrModalModule = /** @class */ (function () {
        function ClrModalModule() {
        }
        ClrModalModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrIconModule, ClrFocusTrapModule],
                        declarations: [CLR_MODAL_DIRECTIVES],
                        exports: [CLR_MODAL_DIRECTIVES],
                    },] }
        ];
        return ClrModalModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SIGNPOST_POSITIONS = {
        'top-left': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_RIGHT, offsetY: -10, offsetX: 0 },
        'top-middle': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_CENTER, offsetY: -10, offsetX: 0 },
        'top-right': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_LEFT, offsetY: -10, offsetX: 0 },
        'right-top': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_BOTTOM, offsetY: 2, offsetX: 14 },
        'right-middle': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
        'right-bottom': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_TOP, offsetY: -1, offsetX: 14 },
        'bottom-right': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_LEFT, offsetY: 9, offsetX: -1 },
        'bottom-middle': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_CENTER, offsetY: 9, offsetX: 12 },
        'bottom-left': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_RIGHT, offsetY: 9, offsetX: 0 },
        'left-bottom': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_TOP, offsetY: 0, offsetX: -14 },
        'left-middle': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_CENTER, offsetY: 4, offsetX: -14 },
        'left-top': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_BOTTOM, offsetY: 0, offsetX: -14 },
        default: { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    // aka where the arrow / pointer is at in relation to the anchor
    /** @type {?} */
    var POSITIONS = [
        'top-left',
        'top-middle',
        'top-right',
        'right-top',
        'right-middle',
        'right-bottom',
        'bottom-right',
        'bottom-middle',
        'bottom-left',
        'left-bottom',
        'left-middle',
        'left-top',
    ];
    var ClrSignpostContent = /** @class */ (function (_super) {
        __extends(ClrSignpostContent, _super);
        function ClrSignpostContent(injector, parentHost, commonStrings) {
            var _this = this;
            if (!parentHost) {
                throw new Error('clr-signpost-content should only be used inside of a clr-signpost');
            }
            _this = _super.call(this, injector, parentHost) || this;
            _this.commonStrings = commonStrings;
            // Defaults
            _this.position = 'right-middle';
            _this.closeOnOutsideClick = true;
            return _this;
        }
        /**********
         *
         * @description
         * Close function that uses the signpost instance to toggle the state of the content popover.
         *
         */
        /**
         * *******
         *
         * \@description
         * Close function that uses the signpost instance to toggle the state of the content popover.
         *
         * @return {?}
         */
        ClrSignpostContent.prototype.close = /**
         * *******
         *
         * \@description
         * Close function that uses the signpost instance to toggle the state of the content popover.
         *
         * @return {?}
         */
            function () {
                this.ifOpenService.open = false;
            };
        Object.defineProperty(ClrSignpostContent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this._position;
            },
            /*********
             *
             * @description
             * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
             * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
             * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
             * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
             * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
             * There are 12 possible positions to place a ClrSignpostContent container:
             * - top-left
             * - top-middle
             * - top-right
             * - right-top
             * - right-middle
             * - right-bottom
             * - bottom-right
             * - bottom-middle
             * - bottom-left
             * - left-bottom
             * - left-middle
             * - left-top
             *
             * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
             * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
             * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
             * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
             *
             * @param newPosition
             */
            set: /**
             * ******
             *
             * \@description
             * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
             * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
             * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
             * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
             * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
             * There are 12 possible positions to place a ClrSignpostContent container:
             * - top-left
             * - top-middle
             * - top-right
             * - right-top
             * - right-middle
             * - right-bottom
             * - bottom-right
             * - bottom-middle
             * - bottom-left
             * - left-bottom
             * - left-middle
             * - left-top
             *
             * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
             * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
             * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
             * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
             *
             * @param {?} position
             * @return {?}
             */ function (position) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, this.position);
                if (position && POSITIONS.indexOf(position) > -1) {
                    this._position = position;
                }
                else {
                    this._position = 'right-middle';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, this.position);
                /** @type {?} */
                var setPosition = SIGNPOST_POSITIONS[this.position];
                this.anchorPoint = setPosition.anchorPoint;
                this.popoverPoint = setPosition.popoverPoint;
                this.popoverOptions.offsetY = setPosition.offsetY;
                this.popoverOptions.offsetX = setPosition.offsetX;
            },
            enumerable: true,
            configurable: true
        });
        ClrSignpostContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-signpost-content',
                        template: "\n        <div class=\"signpost-flex-wrap\">\n            <div class=\"popover-pointer\"></div>\n            <div class=\"signpost-content-header\">\n                <button type=\"button\" class=\"signpost-action close\" (click)=\"close()\">\n                    <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n                </button>\n            </div>\n            <div class=\"signpost-content-body\">\n                <ng-content></ng-content>\n            </div>\n        </div>\n    ",
                        host: { '[class.signpost-content]': 'true' }
                    }] }
        ];
        /** @nocollapse */
        ClrSignpostContent.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [POPOVER_HOST_ANCHOR,] }] },
                { type: ClrCommonStrings }
            ];
        };
        ClrSignpostContent.propDecorators = {
            position: [{ type: i0.Input, args: ['clrPosition',] }]
        };
        return ClrSignpostContent;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_SIGNPOST_DIRECTIVES = [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger];
    var ClrSignpostModule = /** @class */ (function () {
        function ClrSignpostModule() {
        }
        ClrSignpostModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule, ClrIconModule],
                        declarations: [CLR_SIGNPOST_DIRECTIVES],
                        exports: [CLR_SIGNPOST_DIRECTIVES, ClrConditionalModule],
                    },] }
        ];
        return ClrSignpostModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTooltip = /** @class */ (function () {
        function ClrTooltip() {
        }
        ClrTooltip.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tooltip',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.tooltip]': 'true',
                        },
                        providers: [IfOpenService, { provide: POPOVER_HOST_ANCHOR, useExisting: i0.ElementRef }]
                    }] }
        ];
        return ClrTooltip;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var POSITIONS$1 = ['bottom-left', 'bottom-right', 'top-left', 'top-right', 'right', 'left'];
    /** @type {?} */
    var SIZES = ['xs', 'sm', 'md', 'lg'];
    var ClrTooltipContent = /** @class */ (function (_super) {
        __extends(ClrTooltipContent, _super);
        function ClrTooltipContent(injector, parentHost) {
            var _this = this;
            if (!parentHost) {
                throw new Error('clr-tooltip-content should only be used inside of a clr-tooltip');
            }
            _this = _super.call(this, injector, parentHost) || this;
            // Defaults
            _this.position = 'right';
            _this.size = 'sm';
            return _this;
        }
        Object.defineProperty(ClrTooltipContent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this._position;
            },
            set: /**
             * @param {?} position
             * @return {?}
             */ function (position) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.position);
                if (position && POSITIONS$1.indexOf(position) > -1) {
                    this._position = position;
                }
                else {
                    this._position = 'right';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.position);
                // set the popover values based on direction
                switch (position) {
                    case 'top-right':
                        this.anchorPoint = Point.TOP_CENTER;
                        this.popoverPoint = Point.LEFT_BOTTOM;
                        break;
                    case 'top-left':
                        this.anchorPoint = Point.TOP_CENTER;
                        this.popoverPoint = Point.RIGHT_BOTTOM;
                        break;
                    case 'bottom-right':
                        this.anchorPoint = Point.BOTTOM_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'bottom-left':
                        this.anchorPoint = Point.BOTTOM_CENTER;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    case 'right':
                        this.anchorPoint = Point.RIGHT_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                    case 'left':
                        this.anchorPoint = Point.LEFT_CENTER;
                        this.popoverPoint = Point.RIGHT_TOP;
                        break;
                    default:
                        this.anchorPoint = Point.RIGHT_CENTER;
                        this.popoverPoint = Point.LEFT_TOP;
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrTooltipContent.prototype, "size", {
            get: /**
             * @return {?}
             */ function () {
                return this._size;
            },
            set: /**
             * @param {?} size
             * @return {?}
             */ function (size) {
                // Ugh
                this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.size);
                if (size && SIZES.indexOf(size) > -1) {
                    this._size = size;
                }
                else {
                    this._size = 'sm';
                }
                // Ugh
                this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.size);
            },
            enumerable: true,
            configurable: true
        });
        ClrTooltipContent.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-tooltip-content',
                        template: "\n        <ng-content></ng-content>\n    ",
                        host: {
                            '[class.tooltip-content]': 'true',
                            // I'm giving up on animation, they did not work before and will not work now.
                            // Too many conflicts with Clarity UI.
                            '[style.opacity]': '1',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrTooltipContent.ctorParameters = function () {
            return [
                { type: i0.Injector },
                { type: i0.ElementRef, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [POPOVER_HOST_ANCHOR,] }] }
            ];
        };
        ClrTooltipContent.propDecorators = {
            position: [{ type: i0.Input, args: ['clrPosition',] }],
            size: [{ type: i0.Input, args: ['clrSize',] }]
        };
        return ClrTooltipContent;
    }(AbstractPopover));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrTooltipTrigger = /** @class */ (function () {
        function ClrTooltipTrigger(ifOpenService) {
            this.ifOpenService = ifOpenService;
        }
        /**
         * @return {?}
         */
        ClrTooltipTrigger.prototype.showTooltip = /**
         * @return {?}
         */
            function () {
                this.ifOpenService.open = true;
            };
        /**
         * @return {?}
         */
        ClrTooltipTrigger.prototype.hideTooltip = /**
         * @return {?}
         */
            function () {
                this.ifOpenService.open = false;
            };
        ClrTooltipTrigger.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrTooltipTrigger]', host: { '[attr.tabindex]': '0', '[class.tooltip-trigger]': 'true' } },] }
        ];
        /** @nocollapse */
        ClrTooltipTrigger.ctorParameters = function () {
            return [
                { type: IfOpenService }
            ];
        };
        ClrTooltipTrigger.propDecorators = {
            showTooltip: [{ type: i0.HostListener, args: ['mouseenter',] }, { type: i0.HostListener, args: ['focus',] }],
            hideTooltip: [{ type: i0.HostListener, args: ['mouseleave',] }, { type: i0.HostListener, args: ['blur',] }]
        };
        return ClrTooltipTrigger;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_TOOLTIP_DIRECTIVES = [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent];
    var ClrTooltipModule = /** @class */ (function () {
        function ClrTooltipModule() {
        }
        ClrTooltipModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrCommonPopoverModule],
                        declarations: [CLR_TOOLTIP_DIRECTIVES],
                        exports: [CLR_TOOLTIP_DIRECTIVES, ClrConditionalModule, ClrIconModule],
                    },] }
        ];
        return ClrTooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrPopoverModule = /** @class */ (function () {
        function ClrPopoverModule() {
        }
        ClrPopoverModule.decorators = [
            { type: i0.NgModule, args: [{ exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule] },] }
        ];
        return ClrPopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ButtonHubService = /** @class */ (function () {
        function ButtonHubService() {
            this.buttonsReady = false;
            this._previousBtnClicked = new rxjs.Subject();
            this._nextBtnClicked = new rxjs.Subject();
            this._dangerBtnClicked = new rxjs.Subject();
            this._cancelBtnClicked = new rxjs.Subject();
            this._finishBtnClicked = new rxjs.Subject();
            this._customBtnClicked = new rxjs.Subject();
        }
        Object.defineProperty(ButtonHubService.prototype, "previousBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._previousBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "nextBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._nextBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "dangerBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._dangerBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "cancelBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._cancelBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "finishBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._finishBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ButtonHubService.prototype, "customBtnClicked", {
            get: /**
             * @return {?}
             */ function () {
                return this._customBtnClicked.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} buttonType
         * @return {?}
         */
        ButtonHubService.prototype.buttonClicked = /**
         * @param {?} buttonType
         * @return {?}
         */
            function (buttonType) {
                if ('previous' === buttonType) {
                    this._previousBtnClicked.next();
                }
                else if ('next' === buttonType) {
                    this._nextBtnClicked.next();
                }
                else if ('finish' === buttonType) {
                    this._finishBtnClicked.next();
                }
                else if ('danger' === buttonType) {
                    this._dangerBtnClicked.next();
                }
                else if ('cancel' === buttonType) {
                    this._cancelBtnClicked.next();
                }
                else {
                    this._customBtnClicked.next(buttonType);
                }
            };
        ButtonHubService.decorators = [
            { type: i0.Injectable }
        ];
        return ButtonHubService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * PageCollectionService manages the collection of pages assigned to the wizard and offers
     * a number of functions useful across the wizards providers and subcomponents -- all related
     * to essentially lookups on the collection of pages.
     *
     * The easiest way to access PageCollectionService is via the wizard. The
     * following example would allow you to access your instance of the wizard from your host
     * component and thereby access the page collection via YourHostComponent.wizard.pageCollection.
     *
     * \@example
     * <clr-wizard #wizard ...>
     *
     * \@example
     * export class YourHostComponent {
     * \@ViewChild("wizard") wizard: Wizard;
     *   ...
     * }
     *
     * The heart of the page collection is the query list of pages, which it is assigned as a
     * reference to the Wizard.pages QueryList when the wizard is created.
     *
     */
    var PageCollectionService = /** @class */ (function () {
        function PageCollectionService() {
            // used by the navService to navigate back to first possible step after
            // pages are reset
            /**
             *
             * \@memberof PageCollectionService
             */
            this._pagesReset = new rxjs.Subject();
        }
        Object.defineProperty(PageCollectionService.prototype, "pagesAsArray", {
            /**
             * Converts the PageCollectionService.pages QueryList to an array and returns it.
             *
             * Useful for many instances when you would prefer a QueryList to act like an array.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Converts the PageCollectionService.pages QueryList to an array and returns it.
             *
             * Useful for many instances when you would prefer a QueryList to act like an array.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                return this.pages ? this.pages.toArray() : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "pagesCount", {
            /**
             * Returns the length of the pages query list.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the length of the pages query list.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                return this.pages ? this.pages.length : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "penultimatePage", {
            /**
             * Returns the next-to-last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the next-to-last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                /** @type {?} */
                var pageCount = this.pagesCount;
                if (pageCount < 2) {
                    return;
                }
                return this.pagesAsArray[pageCount - 2];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "lastPage", {
            /**
             * Returns the last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the last page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                /** @type {?} */
                var pageCount = this.pagesCount;
                if (pageCount < 1) {
                    return;
                }
                return this.pagesAsArray[pageCount - 1];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageCollectionService.prototype, "firstPage", {
            /**
             * Returns the first page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * Returns the first page in the query list of pages. Operates as a getter
             * so that it isn't working with stale data.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                if (!this.pagesCount) {
                    return;
                }
                return this.pagesAsArray[0];
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
         * object that matches the ID passed. Note that IDs here should include the prefix
         * "clr-wizard-page-".
         *
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * @memberof PageCollectionService
         */
        /**
         * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
         * object that matches the ID passed. Note that IDs here should include the prefix
         * "clr-wizard-page-".
         *
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * \@memberof PageCollectionService
         * @param {?} id
         * @return {?}
         */
        PageCollectionService.prototype.getPageById = /**
         * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
         * object that matches the ID passed. Note that IDs here should include the prefix
         * "clr-wizard-page-".
         *
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * \@memberof PageCollectionService
         * @param {?} id
         * @return {?}
         */
            function (id) {
                /** @type {?} */
                var foundPages = this.pages.filter(function (page) { return id === page.id; });
                return this.checkResults(foundPages, id);
            };
        /**
         * Accepts s number as a parameter and treats that number as the index of the page
         * you're looking for in the collection of pages. Returns a  wizard page object.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts s number as a parameter and treats that number as the index of the page
         * you're looking for in the collection of pages. Returns a  wizard page object.
         *
         * \@memberof PageCollectionService
         * @param {?} index
         * @return {?}
         */
        PageCollectionService.prototype.getPageByIndex = /**
         * Accepts s number as a parameter and treats that number as the index of the page
         * you're looking for in the collection of pages. Returns a  wizard page object.
         *
         * \@memberof PageCollectionService
         * @param {?} index
         * @return {?}
         */
            function (index) {
                /** @type {?} */
                var pageCount = this.pagesCount;
                /** @type {?} */
                var pagesLastIndex = pageCount > 1 ? pageCount - 1 : 0;
                if (index < 0) {
                    throw new Error('Cannot retrieve page with index of ' + index);
                }
                if (index > pagesLastIndex) {
                    throw new Error('Page index is greater than length of pages array.');
                }
                return this.pagesAsArray[index];
            };
        /**
         * Takes a wizard page object as a parameter and returns its index in the
         * collection of pages.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and returns its index in the
         * collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getPageIndex = /**
         * Takes a wizard page object as a parameter and returns its index in the
         * collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var index = this.pagesAsArray.indexOf(page);
                if (index < 0) {
                    throw new Error('Requested page cannot be found in collection of pages.');
                }
                return index;
            };
        /**
         * Consolidates guard logic that prevents a couple of unfortunate edge cases with
         * look ups on the collection of pages.
         *
         * @memberof PageCollectionService
         */
        /**
         * Consolidates guard logic that prevents a couple of unfortunate edge cases with
         * look ups on the collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} results
         * @param {?} requestedPageId
         * @return {?}
         */
        PageCollectionService.prototype.checkResults = /**
         * Consolidates guard logic that prevents a couple of unfortunate edge cases with
         * look ups on the collection of pages.
         *
         * \@memberof PageCollectionService
         * @param {?} results
         * @param {?} requestedPageId
         * @return {?}
         */
            function (results, requestedPageId) {
                /** @type {?} */
                var foundPagesCount = results.length || 0;
                if (foundPagesCount > 1) {
                    throw new Error('More than one page has the requested id ' + requestedPageId + '.');
                }
                else if (foundPagesCount < 1) {
                    throw new Error('No page can be found with the id ' + requestedPageId + '.');
                }
                else {
                    return results[0];
                }
            };
        /**
         * Accepts two numeric indexes and returns an array of wizard page objects that include
         * all wizard pages in the page collection from the first index to the second.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts two numeric indexes and returns an array of wizard page objects that include
         * all wizard pages in the page collection from the first index to the second.
         *
         * \@memberof PageCollectionService
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
        PageCollectionService.prototype.pageRange = /**
         * Accepts two numeric indexes and returns an array of wizard page objects that include
         * all wizard pages in the page collection from the first index to the second.
         *
         * \@memberof PageCollectionService
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
            function (start, end) {
                /** @type {?} */
                var pages = [];
                if (start < 0 || end < 0) {
                    return [];
                }
                if (start === null || typeof start === undefined || isNaN(start)) {
                    return [];
                }
                if (end === null || typeof end === undefined || isNaN(end)) {
                    return [];
                }
                if (end > this.pagesCount) {
                    end = this.pagesCount;
                }
                pages = this.pagesAsArray;
                if (end - start === 0) {
                    // just return the one page they want
                    return [this.getPageByIndex(start)];
                }
                // slice end does not include item referenced by end index, which is weird for users
                // incrementing end index here to correct that so users and other methods
                // don't have to think about it
                end = end + 1;
                // slice does not return the last one in the range but it does include the first one
                // does not modify original array
                return pages.slice(start, end);
            };
        /**
         * Accepts two wizard page objects and returns those page objects with all other page
         * objects between them in the page collection. It doesn't care which page is ahead of the
         * other in the parameters. It will be smart enough to figure that out  on its own.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts two wizard page objects and returns those page objects with all other page
         * objects between them in the page collection. It doesn't care which page is ahead of the
         * other in the parameters. It will be smart enough to figure that out  on its own.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @param {?} otherPage
         * @return {?}
         */
        PageCollectionService.prototype.getPageRangeFromPages = /**
         * Accepts two wizard page objects and returns those page objects with all other page
         * objects between them in the page collection. It doesn't care which page is ahead of the
         * other in the parameters. It will be smart enough to figure that out  on its own.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @param {?} otherPage
         * @return {?}
         */
            function (page, otherPage) {
                /** @type {?} */
                var pageIndex = this.getPageIndex(page);
                /** @type {?} */
                var otherPageIndex = this.getPageIndex(otherPage);
                /** @type {?} */
                var startIndex;
                /** @type {?} */
                var endIndex;
                if (pageIndex <= otherPageIndex) {
                    startIndex = pageIndex;
                    endIndex = otherPageIndex;
                }
                else {
                    startIndex = otherPageIndex;
                    endIndex = pageIndex;
                }
                return this.pageRange(startIndex, endIndex);
            };
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately before it in the page collection. Returns null if there is
         * no page before the page it is passed.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately before it in the page collection. Returns null if there is
         * no page before the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getPreviousPage = /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately before it in the page collection. Returns null if there is
         * no page before the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var myPageIndex = this.getPageIndex(page);
                /** @type {?} */
                var previousPageIndex = myPageIndex - 1;
                if (previousPageIndex < 0) {
                    return null;
                }
                return this.getPageByIndex(previousPageIndex);
            };
        /**
         * Accepts a wizard page object as a parameter and returns a Boolean that says if
         * the page you sent it is complete.
         *
         * @memberof PageCollectionService
         */
        /**
         * Accepts a wizard page object as a parameter and returns a Boolean that says if
         * the page you sent it is complete.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.previousPageIsCompleted = /**
         * Accepts a wizard page object as a parameter and returns a Boolean that says if
         * the page you sent it is complete.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var previousPage;
                if (!page) {
                    return false;
                }
                previousPage = this.getPreviousPage(page);
                if (null === previousPage) {
                    // page is the first page. no previous page.
                    return true;
                }
                return previousPage.completed;
            };
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately after it in the page collection. Returns null if there is
         * no page after the page it is passed.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately after it in the page collection. Returns null if there is
         * no page after the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getNextPage = /**
         * Takes a wizard page object as a parameter and returns the wizard page object of
         * the page immediately after it in the page collection. Returns null if there is
         * no page after the page it is passed.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var myPageIndex = this.getPageIndex(page);
                /** @type {?} */
                var nextPageIndex = myPageIndex + 1;
                if (nextPageIndex >= this.pagesAsArray.length) {
                    return null;
                }
                return this.getPageByIndex(nextPageIndex);
            };
        /**
         * Takes a wizard page object as a parameter and generates a step item id from the
         * page ID. Returns the generated step item ID as a string.
         *
         * @memberof PageCollectionService
         */
        /**
         * Takes a wizard page object as a parameter and generates a step item id from the
         * page ID. Returns the generated step item ID as a string.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.getStepItemIdForPage = /**
         * Takes a wizard page object as a parameter and generates a step item id from the
         * page ID. Returns the generated step item ID as a string.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var pageId = page.id;
                /** @type {?} */
                var pageIdParts = pageId.split('-').reverse();
                pageIdParts[1] = 'step';
                return pageIdParts.reverse().join('-');
            };
        /**
         * Generally only used internally to mark that a specific page has been "committed".
         * This involves marking the page complete and firing the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
         * mark completed as a parameter.
         *
         * @memberof PageCollectionService
         */
        /**
         * Generally only used internally to mark that a specific page has been "committed".
         * This involves marking the page complete and firing the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
         * mark completed as a parameter.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
        PageCollectionService.prototype.commitPage = /**
         * Generally only used internally to mark that a specific page has been "committed".
         * This involves marking the page complete and firing the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
         * mark completed as a parameter.
         *
         * \@memberof PageCollectionService
         * @param {?} page
         * @return {?}
         */
            function (page) {
                /** @type {?} */
                var pageHasOverrides = page.stopNext || page.preventDefault;
                page.completed = true;
                if (!pageHasOverrides) {
                    // prevent loop of event emission; alternate flows work off
                    // of event emitters this is how they break that cycle.
                    page.onCommit.emit(page.id);
                }
            };
        Object.defineProperty(PageCollectionService.prototype, "pagesReset", {
            /**
             * An observable that the navigation service listens to in order to know when
             * the page collection completed states have been reset to false so that way it
             * can also reset the navigation to make the first page in the page collection
             * current/active.
             *
             * @memberof PageCollectionService
             */
            get: /**
             * An observable that the navigation service listens to in order to know when
             * the page collection completed states have been reset to false so that way it
             * can also reset the navigation to make the first page in the page collection
             * current/active.
             *
             * \@memberof PageCollectionService
             * @return {?}
             */ function () {
                return this._pagesReset.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets all completed states of the pages in the page collection to false and
         * notifies the navigation service to likewise reset the navigation.
         *
         * @memberof PageCollectionService
         */
        /**
         * Sets all completed states of the pages in the page collection to false and
         * notifies the navigation service to likewise reset the navigation.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        PageCollectionService.prototype.reset = /**
         * Sets all completed states of the pages in the page collection to false and
         * notifies the navigation service to likewise reset the navigation.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
            function () {
                this.pagesAsArray.forEach(function (page) {
                    page.completed = false;
                });
                this._pagesReset.next(true);
            };
        /**
         * Rolls through all the pages in the page collection to make sure there are no
         * incomplete pages sandwiched between completed pages in the workflow. Identifies
         * the first incomplete page index and sets all pages behind it to a completed
         * state of false.
         *
         * @memberof PageCollectionService
         */
        /**
         * Rolls through all the pages in the page collection to make sure there are no
         * incomplete pages sandwiched between completed pages in the workflow. Identifies
         * the first incomplete page index and sets all pages behind it to a completed
         * state of false.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        PageCollectionService.prototype.updateCompletedStates = /**
         * Rolls through all the pages in the page collection to make sure there are no
         * incomplete pages sandwiched between completed pages in the workflow. Identifies
         * the first incomplete page index and sets all pages behind it to a completed
         * state of false.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var firstIncompleteIndex = this.findFirstIncompletePageIndex();
                if (firstIncompleteIndex === this.pagesAsArray.length - 1) {
                    // all complete no need to do anything
                    return;
                }
                this.pagesAsArray.forEach(function (page, index) {
                    if (index > firstIncompleteIndex) {
                        page.completed = false;
                    }
                });
            };
        /**
         * Retrieves the index of the first incomplete page in the page collection.
         *
         * @memberof PageCollectionService
         */
        /**
         * Retrieves the index of the first incomplete page in the page collection.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        PageCollectionService.prototype.findFirstIncompletePageIndex = /**
         * Retrieves the index of the first incomplete page in the page collection.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var returnIndex = null;
                this.pagesAsArray.forEach(function (page, index) {
                    if (null === returnIndex && false === page.completed) {
                        returnIndex = index;
                    }
                });
                // fallthrough, all completed, return last page
                if (null === returnIndex) {
                    returnIndex = this.pagesCount - 1;
                }
                return returnIndex;
            };
        /**
         * @return {?}
         */
        PageCollectionService.prototype.findFirstIncompletePage = /**
         * @return {?}
         */
            function () {
                /** @type {?} */
                var myIncompleteIndex = this.findFirstIncompletePageIndex();
                return this.pagesAsArray[myIncompleteIndex];
            };
        PageCollectionService.decorators = [
            { type: i0.Injectable }
        ];
        return PageCollectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Performs navigation functions for a wizard and manages the current page. Presented as a
     * separate service to encapsulate the behavior of navigating and completing the wizard so
     * that it can be shared across the wizard and its sub-components.
     *
     * The easiest way to access the navigation service is there a reference on your wizard. The
     * Following example would allow you to access your instance of the wizard from your host
     * component and thereby access the navigation service via YourHostComponent.wizard.navService.
     *
     * \@example
     * <clr-wizard #wizard ...>
     *
     * \@example
     * export class YourHostComponent {
     * \@ViewChild("wizard") wizard: Wizard;
     *   ...
     * }
     *
     */
    var WizardNavigationService = /** @class */ (function () {
        /**
         * Creates an instance of WizardNavigationService. Also sets up subscriptions
         * that listen to the button service to determine when a button has been clicked
         * in the wizard. Is also responsible for taking action when the page collection
         * requests that navigation be reset to its pristine state.
         *
         * @memberof WizardNavigationService
         */
        function WizardNavigationService(pageCollection, buttonService) {
            var _this = this;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            /**
             *
             * \@memberof WizardNavigationService
             */
            this._currentChanged = new rxjs.Subject();
            /**
             * A Boolean flag used by the ClrWizardPage to avoid a race condition when pages are
             * loading and there is no current page defined.
             *
             * \@memberof WizardNavigationService
             */
            this.navServiceLoaded = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.forceForward (clrWizardForceForwardNavigation) input. When true,
             * navigating backwards in the stepnav menu will reset any skipped pages' completed
             * state to false.
             *
             * This is useful when a wizard executes validation on a page-by-page basis when
             * the next button is clicked.
             *
             * \@memberof WizardNavigationService
             */
            this.forceForwardNavigation = false;
            /**
             * \@memberof WizardNavigationService
             */
            this._movedToNextPage = new rxjs.Subject();
            /**
             * \@memberof WizardNavigationService
             */
            this._wizardFinished = new rxjs.Subject();
            /**
             * \@memberof WizardNavigationService
             */
            this._movedToPreviousPage = new rxjs.Subject();
            /**
             * \@memberof WizardNavigationService
             */
            this._cancelWizard = new rxjs.Subject();
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopCancel (clrWizardPreventDefaultCancel) input. When true, the cancel
             * routine is subverted and must be reinstated in the host component calling Wizard.close()
             * at some point.
             *
             * \@memberof WizardNavigationService
             */
            this.wizardHasAltCancel = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopNext (clrWizardPreventDefaultNext) input. When true, the next and finish
             * routines are subverted and must be reinstated in the host component calling Wizard.next(),
             * Wizard.forceNext(), Wizard.finish(), or Wizard.forceFinish().
             *
             * \@memberof WizardNavigationService
             */
            this.wizardHasAltNext = false;
            /**
             * A boolean flag shared across the Wizard subcomponents that follows the value
             * of the Wizard.stopNavigation (clrWizardPreventNavigation) input. When true, all
             * navigational elements in the wizard are disabled.
             *
             * This is intended to freeze the wizard in place. Events are not fired so this is
             * not a way to implement alternate functionality for navigation.
             *
             * \@memberof WizardNavigationService
             */
            this.wizardStopNavigation = false;
            /**
             * A boolean flag shared with the stepnav items that prevents user clicks on
             * stepnav items from navigating the wizard.
             *
             * \@memberof WizardNavigationService
             */
            this.wizardDisableStepnav = false;
            this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(function () {
                /** @type {?} */
                var currentPage = _this.currentPage;
                if (_this.currentPageIsFirst || currentPage.previousStepDisabled) {
                    return;
                }
                currentPage.previousButtonClicked.emit(currentPage);
                if (!currentPage.preventDefault) {
                    _this.previous();
                }
            });
            this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('next');
            });
            this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('danger');
            });
            this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(function () {
                _this.checkAndCommitCurrentPage('finish');
            });
            this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe(function (type) {
                if (!_this.wizardStopNavigation) {
                    _this.currentPage.customButtonClicked.emit(type);
                }
            });
            this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(function () {
                if (_this.wizardStopNavigation) {
                    return;
                }
                if (_this.currentPage.preventDefault) {
                    _this.currentPage.pageOnCancel.emit(_this.currentPage);
                }
                else {
                    _this.cancel();
                }
            });
            this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(function () {
                _this.setFirstPageCurrent();
            });
        }
        /**
         *
         * @memberof WizardNavigationService
         */
        /**
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.ngOnDestroy = /**
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this.previousButtonSubscription.unsubscribe();
                this.nextButtonSubscription.unsubscribe();
                this.dangerButtonSubscription.unsubscribe();
                this.finishButtonSubscription.unsubscribe();
                this.customButtonSubscription.unsubscribe();
                this.cancelButtonSubscription.unsubscribe();
                this.pagesResetSubscription.unsubscribe();
            };
        Object.defineProperty(WizardNavigationService.prototype, "currentPageChanged", {
            /**
             * An Observable that is predominantly used amongst the subcomponents and services
             * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
             * (clrWizardPageOnLoad) output instead of this Observable.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * An Observable that is predominantly used amongst the subcomponents and services
             * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
             * (clrWizardPageOnLoad) output instead of this Observable.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                // TODO: MAKE SURE EXTERNAL OUTPUTS SAY 'CHANGE' NOT 'CHANGED'
                // A BREAKING CHANGE SO AWAITING MINOR RELEASE
                return this._currentChanged.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageTitle", {
            /**
             * @memberof WizardNavigationService
             */
            get: /**
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                // when the querylist of pages is empty. this is the first place it fails...
                if (!this.currentPage) {
                    return null;
                }
                return this.currentPage.title;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageIsFirst", {
            /**
             * Returns a Boolean that tells you whether or not the current page is the first
             * page in the Wizard.
             *
             * This is helpful for determining whether a page is navigable.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Returns a Boolean that tells you whether or not the current page is the first
             * page in the Wizard.
             *
             * This is helpful for determining whether a page is navigable.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this.pageCollection.firstPage === this.currentPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPageIsLast", {
            /**
             * Returns a Boolean that tells you whether or not the current page is the
             * last page in the Wizard.
             *
             * This is used to determine which buttons should display in the wizard footer.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Returns a Boolean that tells you whether or not the current page is the
             * last page in the Wizard.
             *
             * This is used to determine which buttons should display in the wizard footer.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this.pageCollection.lastPage === this.currentPage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "currentPage", {
            /**
             * Returns the ClrWizardPage object of the current page or null.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Returns the ClrWizardPage object of the current page or null.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                if (!this._currentPage) {
                    return null;
                }
                return this._currentPage;
            },
            /**
             * Accepts a ClrWizardPage object, since that object to be the current/active
             * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
             * event for that page.
             *
             * Note that all of this work is bypassed if the ClrWizardPage object is already
             * the current page.
             *
             * @memberof WizardNavigationService
             */
            set: /**
             * Accepts a ClrWizardPage object, since that object to be the current/active
             * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
             * event for that page.
             *
             * Note that all of this work is bypassed if the ClrWizardPage object is already
             * the current page.
             *
             * \@memberof WizardNavigationService
             * @param {?} page
             * @return {?}
             */ function (page) {
                if (this._currentPage !== page && !this.wizardStopNavigation) {
                    this._currentPage = page;
                    page.onLoad.emit(page.id);
                    this._currentChanged.next(page);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "movedToNextPage", {
            /**
             * An observable used internally to alert the wizard that forward navigation
             * has occurred. It is recommended that you use the Wizard.onMoveNext
             * (clrWizardOnNext) output instead of this one.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * An observable used internally to alert the wizard that forward navigation
             * has occurred. It is recommended that you use the Wizard.onMoveNext
             * (clrWizardOnNext) output instead of this one.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._movedToNextPage.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardNavigationService.prototype, "wizardFinished", {
            /**
             * An observable used internally to alert the wizard that the nav service
             * has approved completion of the wizard.
             *
             * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
             * output instead of this one.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * An observable used internally to alert the wizard that the nav service
             * has approved completion of the wizard.
             *
             * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
             * output instead of this one.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._wizardFinished.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * This is a public function that can be used to programmatically advance
         * the user to the next page.
         *
         * When invoked, this method will move the wizard to the next page after
         * successful validation. Note that this method goes through all checks
         * and event emissions as if Wizard.next(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.next(false).
         *
         * @memberof WizardNavigationService
         */
        /**
         * This is a public function that can be used to programmatically advance
         * the user to the next page.
         *
         * When invoked, this method will move the wizard to the next page after
         * successful validation. Note that this method goes through all checks
         * and event emissions as if Wizard.next(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.next(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.next = /**
         * This is a public function that can be used to programmatically advance
         * the user to the next page.
         *
         * When invoked, this method will move the wizard to the next page after
         * successful validation. Note that this method goes through all checks
         * and event emissions as if Wizard.next(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.next(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                if (this.currentPageIsLast) {
                    this.checkAndCommitCurrentPage('finish');
                    return;
                }
                this.checkAndCommitCurrentPage('next');
                if (!this.wizardHasAltNext && !this.wizardStopNavigation) {
                    this._movedToNextPage.next(true);
                }
            };
        /**
         * Bypasses checks and most event emissions to force a page to navigate forward.
         *
         * Comparable to calling Wizard.next() or Wizard.forceNext().
         *
         * @memberof WizardNavigationService
         */
        /**
         * Bypasses checks and most event emissions to force a page to navigate forward.
         *
         * Comparable to calling Wizard.next() or Wizard.forceNext().
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.forceNext = /**
         * Bypasses checks and most event emissions to force a page to navigate forward.
         *
         * Comparable to calling Wizard.next() or Wizard.forceNext().
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var currentPage = this.currentPage;
                /** @type {?} */
                var nextPage = this.pageCollection.getNextPage(currentPage);
                // catch errant null or undefineds that creep in
                if (!nextPage) {
                    throw new Error('The wizard has no next page to go to.');
                }
                if (this.wizardStopNavigation) {
                    return;
                }
                if (!currentPage.completed) {
                    // this is a state that alt next flows can get themselves in...
                    this.pageCollection.commitPage(currentPage);
                }
                this.currentPage = nextPage;
            };
        /**
         * Accepts a button/action type as a parameter. Encapsulates all logic for
         * event emissions, state of the current page, and wizard and page level overrides.
         *
         * Avoid calling this function directly unless you really know what you're doing.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Accepts a button/action type as a parameter. Encapsulates all logic for
         * event emissions, state of the current page, and wizard and page level overrides.
         *
         * Avoid calling this function directly unless you really know what you're doing.
         *
         * \@memberof WizardNavigationService
         * @param {?} buttonType
         * @return {?}
         */
        WizardNavigationService.prototype.checkAndCommitCurrentPage = /**
         * Accepts a button/action type as a parameter. Encapsulates all logic for
         * event emissions, state of the current page, and wizard and page level overrides.
         *
         * Avoid calling this function directly unless you really know what you're doing.
         *
         * \@memberof WizardNavigationService
         * @param {?} buttonType
         * @return {?}
         */
            function (buttonType) {
                /** @type {?} */
                var currentPage = this.currentPage;
                /** @type {?} */
                var iAmTheLastPage;
                /** @type {?} */
                var isNext;
                /** @type {?} */
                var isDanger;
                /** @type {?} */
                var isDangerNext;
                /** @type {?} */
                var isDangerFinish;
                /** @type {?} */
                var isFinish;
                if (!currentPage.readyToComplete || this.wizardStopNavigation) {
                    return;
                }
                iAmTheLastPage = this.currentPageIsLast;
                isNext = buttonType === 'next';
                isDanger = buttonType === 'danger';
                isDangerNext = isDanger && !iAmTheLastPage;
                isDangerFinish = isDanger && iAmTheLastPage;
                isFinish = buttonType === 'finish' || isDangerFinish;
                if (isFinish && !iAmTheLastPage) {
                    return;
                }
                currentPage.primaryButtonClicked.emit(buttonType);
                if (isFinish) {
                    currentPage.finishButtonClicked.emit(currentPage);
                }
                else if (isDanger) {
                    currentPage.dangerButtonClicked.emit();
                }
                else if (isNext) {
                    currentPage.nextButtonClicked.emit();
                }
                if (currentPage.stopNext || currentPage.preventDefault) {
                    currentPage.onCommit.emit(currentPage.id);
                    return;
                }
                // order is very important with these emitters!
                if (isFinish) {
                    // mark page as complete
                    if (!this.wizardHasAltNext) {
                        this.pageCollection.commitPage(currentPage);
                    }
                    this._wizardFinished.next();
                }
                if (this.wizardHasAltNext) {
                    this.pageCollection.commitPage(currentPage);
                    if (isNext || isDangerNext) {
                        this._movedToNextPage.next(true);
                    }
                    // jump out here, no matter what type we're looking at
                    return;
                }
                if (isNext || isDangerNext) {
                    this.forceNext();
                }
            };
        /**
         * This is a public function that can be used to programmatically conclude
         * the wizard.
         *
         * When invoked, this method will  initiate the work involved with finalizing
         * and finishing the wizard workflow. Note that this method goes through all
         * checks and event emissions as if Wizard.finish(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.finish(false).
         *
         * @memberof WizardNavigationService
         */
        /**
         * This is a public function that can be used to programmatically conclude
         * the wizard.
         *
         * When invoked, this method will  initiate the work involved with finalizing
         * and finishing the wizard workflow. Note that this method goes through all
         * checks and event emissions as if Wizard.finish(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.finish(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.finish = /**
         * This is a public function that can be used to programmatically conclude
         * the wizard.
         *
         * When invoked, this method will  initiate the work involved with finalizing
         * and finishing the wizard workflow. Note that this method goes through all
         * checks and event emissions as if Wizard.finish(false) had been called.
         *
         * In most cases, it makes more sense to use Wizard.finish(false).
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this.checkAndCommitCurrentPage('finish');
            };
        Object.defineProperty(WizardNavigationService.prototype, "movedToPreviousPage", {
            /**
             * Notifies the wizard when backwards navigation has occurred via the
             * previous button.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Notifies the wizard when backwards navigation has occurred via the
             * previous button.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._movedToPreviousPage.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Programmatically moves the wizard to the page before the current page.
         *
         * In most instances, it makes more sense to call Wizard.previous()
         * which does the same thing.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Programmatically moves the wizard to the page before the current page.
         *
         * In most instances, it makes more sense to call Wizard.previous()
         * which does the same thing.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.previous = /**
         * Programmatically moves the wizard to the page before the current page.
         *
         * In most instances, it makes more sense to call Wizard.previous()
         * which does the same thing.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var previousPage;
                if (this.currentPageIsFirst || this.wizardStopNavigation) {
                    return;
                }
                previousPage = this.pageCollection.getPreviousPage(this.currentPage);
                if (!previousPage) {
                    return;
                }
                this._movedToPreviousPage.next(true);
                if (this.forceForwardNavigation) {
                    this.currentPage.completed = false;
                }
                this.currentPage = previousPage;
            };
        Object.defineProperty(WizardNavigationService.prototype, "notifyWizardCancel", {
            /**
             * Notifies the wizard that a user is trying to cancel it.
             *
             * @memberof WizardNavigationService
             */
            get: /**
             * Notifies the wizard that a user is trying to cancel it.
             *
             * \@memberof WizardNavigationService
             * @return {?}
             */ function () {
                return this._cancelWizard.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
         * this route goes through all checks and event emissions as if a cancel button had
         * been clicked.
         *
         * In most cases, users looking for a hook into the cancel routine are actually looking
         * for a way to close the wizard from their host component because they have prevented
         * the default cancel action.
         *
         * In this instance, it is recommended that you use Wizard.close() to avoid any event
         * emission loop resulting from an event handler calling back into routine that will
         * again evoke the events it handles.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
         * this route goes through all checks and event emissions as if a cancel button had
         * been clicked.
         *
         * In most cases, users looking for a hook into the cancel routine are actually looking
         * for a way to close the wizard from their host component because they have prevented
         * the default cancel action.
         *
         * In this instance, it is recommended that you use Wizard.close() to avoid any event
         * emission loop resulting from an event handler calling back into routine that will
         * again evoke the events it handles.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.cancel = /**
         * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
         * this route goes through all checks and event emissions as if a cancel button had
         * been clicked.
         *
         * In most cases, users looking for a hook into the cancel routine are actually looking
         * for a way to close the wizard from their host component because they have prevented
         * the default cancel action.
         *
         * In this instance, it is recommended that you use Wizard.close() to avoid any event
         * emission loop resulting from an event handler calling back into routine that will
         * again evoke the events it handles.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this._cancelWizard.next();
            };
        /**
         * Performs all required checks to determine if a user can navigate to a page. Checking at each
         * point if a page is navigable -- completed where the page immediately after the last completed
         * page.
         *
         * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
         * ClrWizardPage object that you want to make the current page.
         *
         * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
         * is the Wizard will mark all pages between the current page and the page you want to navigate
         * to as completed. This is useful for informational wizards that do not require user action,
         * allowing an easy means for users to jump ahead.
         *
         * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Performs all required checks to determine if a user can navigate to a page. Checking at each
         * point if a page is navigable -- completed where the page immediately after the last completed
         * page.
         *
         * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
         * ClrWizardPage object that you want to make the current page.
         *
         * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
         * is the Wizard will mark all pages between the current page and the page you want to navigate
         * to as completed. This is useful for informational wizards that do not require user action,
         * allowing an easy means for users to jump ahead.
         *
         * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
         *
         * \@memberof WizardNavigationService
         * @param {?} pageToGoToOrId
         * @param {?=} lazyComplete
         * @return {?}
         */
        WizardNavigationService.prototype.goTo = /**
         * Performs all required checks to determine if a user can navigate to a page. Checking at each
         * point if a page is navigable -- completed where the page immediately after the last completed
         * page.
         *
         * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
         * ClrWizardPage object that you want to make the current page.
         *
         * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
         * is the Wizard will mark all pages between the current page and the page you want to navigate
         * to as completed. This is useful for informational wizards that do not require user action,
         * allowing an easy means for users to jump ahead.
         *
         * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
         *
         * \@memberof WizardNavigationService
         * @param {?} pageToGoToOrId
         * @param {?=} lazyComplete
         * @return {?}
         */
            function (pageToGoToOrId, lazyComplete) {
                if (lazyComplete === void 0) {
                    lazyComplete = false;
                }
                /** @type {?} */
                var pageToGoTo;
                /** @type {?} */
                var currentPage;
                /** @type {?} */
                var myPages;
                /** @type {?} */
                var pagesToCheck;
                /** @type {?} */
                var okayToMove = true;
                /** @type {?} */
                var goingForward;
                /** @type {?} */
                var currentPageIndex;
                /** @type {?} */
                var goToPageIndex;
                myPages = this.pageCollection;
                pageToGoTo = typeof pageToGoToOrId === 'string' ? myPages.getPageById(pageToGoToOrId) : pageToGoToOrId;
                currentPage = this.currentPage;
                // no point in going to the current page. you're there already!
                // also hard block on any navigation when stopNavigation is true
                if (pageToGoTo === currentPage || this.wizardStopNavigation) {
                    return;
                }
                currentPageIndex = myPages.getPageIndex(currentPage);
                goToPageIndex = myPages.getPageIndex(pageToGoTo);
                goingForward = goToPageIndex > currentPageIndex;
                pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
                okayToMove = lazyComplete || this.canGoTo(pagesToCheck);
                if (!okayToMove) {
                    return;
                }
                if (goingForward && lazyComplete) {
                    pagesToCheck.forEach(function (page) {
                        if (page !== pageToGoTo) {
                            page.completed = true;
                        }
                    });
                }
                else if (!goingForward && this.forceForwardNavigation) {
                    pagesToCheck.forEach(function (page) {
                        page.completed = false;
                    });
                }
                this.currentPage = pageToGoTo;
            };
        /**
         * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
         * those objects to determine if navigation can be accomplished.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
         * those objects to determine if navigation can be accomplished.
         *
         * \@memberof WizardNavigationService
         * @param {?} pagesToCheck
         * @return {?}
         */
        WizardNavigationService.prototype.canGoTo = /**
         * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
         * those objects to determine if navigation can be accomplished.
         *
         * \@memberof WizardNavigationService
         * @param {?} pagesToCheck
         * @return {?}
         */
            function (pagesToCheck) {
                /** @type {?} */
                var okayToMove = true;
                /** @type {?} */
                var myPages = this.pageCollection;
                // previous page can be important when moving because if it's completed it
                // allows us to move to the page even if it's incomplete...
                /** @type {?} */
                var previousPagePasses;
                if (!pagesToCheck || pagesToCheck.length < 1) {
                    return false;
                }
                pagesToCheck.forEach(function (page) {
                    /** @type {?} */
                    var previousPage;
                    if (!okayToMove) {
                        return;
                    }
                    if (page.completed) {
                        // default is true. just jump out instead of complicating it.
                        return;
                    }
                    // so we know our page is not completed...
                    previousPage = myPages.getPageIndex(page) > 0 ? myPages.getPreviousPage(page) : null;
                    previousPagePasses = previousPage === null || previousPage.completed === true;
                    // we are false if not the current page AND previous page is not completed
                    // (but must have a previous page)
                    if (!page.current && !previousPagePasses) {
                        okayToMove = false;
                    }
                    // falls through to true as default
                });
                return okayToMove;
            };
        /**
         * Looks through the collection of pages to find the first one that is incomplete
         * and makes that page the current/active page.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Looks through the collection of pages to find the first one that is incomplete
         * and makes that page the current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.setLastEnabledPageCurrent = /**
         * Looks through the collection of pages to find the first one that is incomplete
         * and makes that page the current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var allPages = this.pageCollection.pagesAsArray;
                /** @type {?} */
                var lastCompletedPageIndex = null;
                allPages.forEach(function (page, index) {
                    if (page.completed) {
                        lastCompletedPageIndex = index;
                    }
                });
                if (lastCompletedPageIndex === null) {
                    // always is at least the first item...
                    lastCompletedPageIndex = 0;
                }
                else if (lastCompletedPageIndex + 1 < allPages.length) {
                    lastCompletedPageIndex = lastCompletedPageIndex + 1;
                }
                this.currentPage = allPages[lastCompletedPageIndex];
            };
        /**
         * Finds the first page in the collection of pages and makes that page the
         * current/active page.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Finds the first page in the collection of pages and makes that page the
         * current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.setFirstPageCurrent = /**
         * Finds the first page in the collection of pages and makes that page the
         * current/active page.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                this.currentPage = this.pageCollection.pagesAsArray[0];
            };
        /**
         * Updates the stepnav on the left side of the wizard when pages are dynamically
         * added or removed from the collection of pages.
         *
         * @memberof WizardNavigationService
         */
        /**
         * Updates the stepnav on the left side of the wizard when pages are dynamically
         * added or removed from the collection of pages.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        WizardNavigationService.prototype.updateNavigation = /**
         * Updates the stepnav on the left side of the wizard when pages are dynamically
         * added or removed from the collection of pages.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
            function () {
                /** @type {?} */
                var toSetCurrent;
                /** @type {?} */
                var currentPageRemoved;
                this.pageCollection.updateCompletedStates();
                currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
                if (currentPageRemoved) {
                    toSetCurrent = this.pageCollection.findFirstIncompletePage();
                    this.currentPage = toSetCurrent;
                }
            };
        WizardNavigationService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        WizardNavigationService.ctorParameters = function () {
            return [
                { type: PageCollectionService },
                { type: ButtonHubService }
            ];
        };
        return WizardNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var HeaderActionService = /** @class */ (function () {
        // this service communicates information about the presence/display of header actions
        // across the wizard
        function HeaderActionService(navService) {
            this.navService = navService;
        }
        Object.defineProperty(HeaderActionService.prototype, "wizardHasHeaderActions", {
            get: /**
             * @return {?}
             */ function () {
                /** @type {?} */
                var wizardHdrActions = this.wizardHeaderActions;
                if (!wizardHdrActions) {
                    return false;
                }
                return wizardHdrActions.toArray().length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "currentPageHasHeaderActions", {
            get: /**
             * @return {?}
             */ function () {
                return this.navService.currentPage ? this.navService.currentPage.hasHeaderActions : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "showWizardHeaderActions", {
            get: /**
             * @return {?}
             */ function () {
                return !this.currentPageHasHeaderActions && this.wizardHasHeaderActions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HeaderActionService.prototype, "displayHeaderActionsWrapper", {
            get: /**
             * @return {?}
             */ function () {
                return this.currentPageHasHeaderActions || this.wizardHasHeaderActions;
            },
            enumerable: true,
            configurable: true
        });
        HeaderActionService.decorators = [
            { type: i0.Injectable }
        ];
        /** @nocollapse */
        HeaderActionService.ctorParameters = function () {
            return [
                { type: WizardNavigationService }
            ];
        };
        return HeaderActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var wizardHeaderActionIndex = 0;
    var ClrWizardHeaderAction = /** @class */ (function () {
        function ClrWizardHeaderAction() {
            // title is explanatory text added to the header action
            this.title = '';
            // If our host has an ID attribute, we use this instead of our index.
            this._id = (wizardHeaderActionIndex++).toString();
            this.disabled = false;
            this.headerActionClicked = new i0.EventEmitter(false);
        }
        Object.defineProperty(ClrWizardHeaderAction.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "clr-wizard-header-action-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizardHeaderAction.prototype.click = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                // passing the header action id allows users to have one method that
                // routes to many different actions based on the type of header action
                // clicked. this is further aided by users being able to specify ids
                // for their header actions.
                this.headerActionClicked.emit(this._id);
            };
        ClrWizardHeaderAction.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-header-action',
                        template: "\n        <button \n            type=\"button\"\n            class=\"btn clr-wizard-header-action btn-link\"\n            [id]=\"id\"\n            [class.disabled]=\"disabled\"\n            (click)=\"click()\"\n            [title]=\"title\">\n            <ng-content></ng-content>\n        </button>\n    ",
                        host: { class: 'clr-wizard-header-action-wrapper' }
                    }] }
        ];
        ClrWizardHeaderAction.propDecorators = {
            title: [{ type: i0.Input, args: ['title',] }],
            _id: [{ type: i0.Input, args: ['id',] }],
            disabled: [{ type: i0.Input, args: ['clrWizardHeaderActionDisabled',] }],
            headerActionClicked: [{ type: i0.Output, args: ['actionClicked',] }]
        };
        return ClrWizardHeaderAction;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageButtons = /** @class */ (function () {
        function ClrWizardPageButtons(pageButtonsTemplateRef) {
            this.pageButtonsTemplateRef = pageButtonsTemplateRef;
        }
        ClrWizardPageButtons.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageButtons]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageButtons.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageButtons;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageHeaderActions = /** @class */ (function () {
        function ClrWizardPageHeaderActions(pageHeaderActionsTemplateRef) {
            this.pageHeaderActionsTemplateRef = pageHeaderActionsTemplateRef;
        }
        ClrWizardPageHeaderActions.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageHeaderActions]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageHeaderActions.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageHeaderActions;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageNavTitle = /** @class */ (function () {
        function ClrWizardPageNavTitle(pageNavTitleTemplateRef) {
            this.pageNavTitleTemplateRef = pageNavTitleTemplateRef;
        }
        ClrWizardPageNavTitle.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageNavTitle]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageNavTitle.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageNavTitle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardPageTitle = /** @class */ (function () {
        function ClrWizardPageTitle(pageTitleTemplateRef) {
            this.pageTitleTemplateRef = pageTitleTemplateRef;
        }
        ClrWizardPageTitle.decorators = [
            { type: i0.Directive, args: [{ selector: '[clrPageTitle]' },] }
        ];
        /** @nocollapse */
        ClrWizardPageTitle.ctorParameters = function () {
            return [
                { type: i0.TemplateRef }
            ];
        };
        return ClrWizardPageTitle;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var wizardPageIndex = 0;
    /**
     * The ClrWizardPage component is responsible for displaying the content of each step
     * in the wizard workflow.
     *
     * ClrWizardPage component has hooks into the navigation service (ClrWizardPage.navService),
     * page collection (ClrWizardPage.pageCollection), and button service
     * (ClrWizardPage.buttonService). These three providers are shared across the components
     * within each instance of a Wizard.
     *
     */
    var ClrWizardPage = /** @class */ (function () {
        /**
         * Creates an instance of ClrWizardPage.
         *
         * @memberof WizardPage
         */
        function ClrWizardPage(navService, pageCollection, buttonService) {
            this.navService = navService;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._nextStepDisabled = false;
            /**
             * Emits when the value of ClrWizardPage.nextStepDisabled changes.
             * Should emit the new value of nextStepDisabled.
             *
             * \@memberof WizardPage
             *
             */
            this.nextStepDisabledChange = new i0.EventEmitter();
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._previousStepDisabled = false;
            /**
             * Emits when the value of ClrWizardPage.previousStepDisabled changes.
             * Should emit the new value of previousStepDisabled.
             *
             * \@memberof WizardPage
             *
             */
            this.previousStepDisabledChange = new i0.EventEmitter();
            /**
             * Overrides all actions from the page level, so you can use an alternate function for
             * validation or data-munging with a ClrWizardPage.onCommit (clrWizardPageOnCommit output),
             * ClrWizardPage.onCancel (clrWizardPageOnCancel output), or one
             * of the granular page-level button click event emitters.
             *
             * \@memberof WizardPage
             *
             */
            this.preventDefault = false;
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._stopCancel = false;
            /**
             *
             * \@memberof WizardPage
             *
             */
            this.stopCancelChange = new i0.EventEmitter();
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._stopNext = false;
            /**
             * An event emitter carried over from a legacy version of ClrWizardPage.
             * Fires an event on ClrWizardPage whenever the next or finish buttons
             * are clicked and the page is the current page of the Wizard.
             *
             * Note that this does not automatically emit an event when a custom
             * button is used in place of a next or finish button.
             *
             * \@memberof WizardPage
             *
             */
            this.onCommit = new i0.EventEmitter(false);
            /**
             * Emits an event when ClrWizardPage becomes the current page of the
             * Wizard.
             *
             * \@memberof WizardPage
             *
             */
            this.onLoad = new i0.EventEmitter();
            /**
             * Emits an event when the ClrWizardPage invokes the cancel routine for the wizard.
             *
             * Can be used in conjunction with the ClrWizardPage.stopCancel
             * (clrWizardPagePreventDefaultCancel) or ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) inputs to implement custom cancel
             * functionality at the page level. This is useful if you would like to do
             * validation, save data, or warn users before cancelling the wizard.
             *
             * Note that this requires you to call Wizard.close() from the host component.
             * This constitues a full replacement of the cancel functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.pageOnCancel = new i0.EventEmitter();
            /**
             * Emits an event when the finish button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom finish
             * functionality at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to complete
             * the wizard.
             *
             * Note that this requires you to call Wizard.finish() or Wizard.forceFinish()
             * from the host component. This combination creates a full replacement of
             * the finish functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.finishButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when the previous button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom backwards
             * navigation at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to go
             * backwards in the wizard.
             *
             * Note that this requires you to call Wizard.previous()
             * from the host component. This combination creates a full replacement of
             * the backwards navigation functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.previousButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when the next button is clicked and the ClrWizardPage is
             * the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * navigation at the page level. This is useful if you would like to do
             * validation, save data, or warn users before allowing them to go
             * to the next page in the wizard.
             *
             * Note that this requires you to call Wizard.forceNext() or Wizard.next()
             * from the host component. This combination creates a full replacement of
             * the forward navigation functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.nextButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when a danger button is clicked and the ClrWizardPage is
             * the wizard's current page. By default, a danger button will act as
             * either a "next" or "finish" button depending on if the ClrWizardPage is the
             * last page or not.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * or finish navigation at the page level when the danger button is clicked.
             * This is useful if you would like to do validation, save data, or warn
             * users before allowing them to go to the next page in the wizard or
             * finish the wizard.
             *
             * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
             * Wizard.forceNext() or Wizard.next() from the host component. This
             * combination creates a full replacement of the forward navigation and
             * finish functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.dangerButtonClicked = new i0.EventEmitter();
            /**
             * Emits an event when a next, finish, or danger button is clicked and the
             * ClrWizardPage is the wizard's current page.
             *
             * Can be used in conjunction with the ClrWizardPage.preventDefault
             * (clrWizardPagePagePreventDefault) input to implement custom forwards
             * or finish navigation at the page level, regardless of the type of
             * primary button.
             *
             * This is useful if you would like to do validation, save data, or warn
             * users before allowing them to go to the next page in the wizard or
             * finish the wizard.
             *
             * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
             * Wizard.forceNext() or Wizard.next() from the host component. This
             * combination creates a full replacement of the forward navigation and
             * finish functionality.
             *
             * \@memberof WizardPage
             *
             */
            this.primaryButtonClicked = new i0.EventEmitter();
            this.customButtonClicked = new i0.EventEmitter();
            /**
             * An input value that is used internally to generate the ClrWizardPage ID as
             * well as the step nav item ID.
             *
             * Typed as any because it should be able to accept numbers as well as
             * strings. Passing an index for wizard whose pages are created with an
             * ngFor loop is a common use case.
             *
             * \@memberof WizardPage
             *
             */
            this._id = (wizardPageIndex++).toString();
            /**
             *
             * \@memberof WizardPage
             *
             */
            this._complete = false;
        }
        Object.defineProperty(ClrWizardPage.prototype, "nextStepDisabled", {
            /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the next page.
             *
             * Useful for in-page validation because it prevents forward navigation
             * and visibly disables the next button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the next page.
             *
             * Useful for in-page validation because it prevents forward navigation
             * and visibly disables the next button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._nextStepDisabled;
            },
            /**
             * Sets whether the page should allow forward navigation.
             *
             * @memberof WizardPage
             *
             */
            set: /**
             * Sets whether the page should allow forward navigation.
             *
             * \@memberof WizardPage
             *
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._nextStepDisabled) {
                    this._nextStepDisabled = valBool;
                    this.nextStepDisabledChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "previousStepDisabled", {
            /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the previous page.
             *
             * Useful for in-page validation because it prevents backward navigation
             * and visibly disables the previous button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that tells whether or not the wizard should be allowed
             * to move to the previous page.
             *
             * Useful for in-page validation because it prevents backward navigation
             * and visibly disables the previous button.
             *
             * Does not require that you re-implement navigation routines like you
             * would if you were using ClrWizardPage.preventDefault or
             * Wizard.preventDefault.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._previousStepDisabled;
            },
            /**
             * Sets whether the page should allow backward navigation.
             *
             * @memberof WizardPage
             *
             */
            set: /**
             * Sets whether the page should allow backward navigation.
             *
             * \@memberof WizardPage
             *
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._previousStepDisabled) {
                    this._previousStepDisabled = valBool;
                    this.previousStepDisabledChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "stopCancel", {
            /**
             * A getter that retrieves whether the page is preventing the cancel action.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that retrieves whether the page is preventing the cancel action.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._stopCancel;
            },
            /**
             * Overrides the cancel action from the page level. Allows you to use an
             * alternate function for validation or data-munging before cancelling the
             * wizard when combined with the ClrWizardPage.onCancel
             * (the clrWizardPageOnCancel output).
             *
             * Requires that you manually close the wizard from your host component,
             * usually with a call to Wizard.forceNext() or wizard.next();
             *
             * @memberof ClrWizardPage
             */
            set: /**
             * Overrides the cancel action from the page level. Allows you to use an
             * alternate function for validation or data-munging before cancelling the
             * wizard when combined with the ClrWizardPage.onCancel
             * (the clrWizardPageOnCancel output).
             *
             * Requires that you manually close the wizard from your host component,
             * usually with a call to Wizard.forceNext() or wizard.next();
             *
             * \@memberof ClrWizardPage
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._stopCancel) {
                    this._stopCancel = valBool;
                    this.stopCancelChange.emit(valBool);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "stopNext", {
            /**
             * A getter that tells you whether the page is preventing the next action.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A getter that tells you whether the page is preventing the next action.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._stopNext;
            },
            /**
             * Overrides forward navigation from the page level. Allows you to use an
             * alternate function for validation or data-munging before moving the
             * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
             * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
             * (clrWizardPageNext) outputs.
             *
             * Requires that you manually tell the wizard to navigate forward from
             * the hostComponent, usually with a call to Wizard.forceNext() or
             * wizard.next();
             *
             * @memberof ClrWizardPage
             */
            set: /**
             * Overrides forward navigation from the page level. Allows you to use an
             * alternate function for validation or data-munging before moving the
             * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
             * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
             * (clrWizardPageNext) outputs.
             *
             * Requires that you manually tell the wizard to navigate forward from
             * the hostComponent, usually with a call to Wizard.forceNext() or
             * wizard.next();
             *
             * \@memberof ClrWizardPage
             * @param {?} val
             * @return {?}
             */ function (val) {
                /** @type {?} */
                var valBool = !!val;
                if (valBool !== this._stopNext) {
                    this._stopNext = valBool;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "id", {
            /**
             * A read-only getter that generates an ID string for the wizard page from
             * either the value passed to the ClrWizardPage "id" input or a wizard page
             * counter shared across all wizard pages in the application.
             *
             * Note that the value passed into the ID input Will be prefixed with
             * "clr-wizard-page-".
             *
             * @readonly
             *
             * @memberof ClrWizardPage
             */
            get: /**
             * A read-only getter that generates an ID string for the wizard page from
             * either the value passed to the ClrWizardPage "id" input or a wizard page
             * counter shared across all wizard pages in the application.
             *
             * Note that the value passed into the ID input Will be prefixed with
             * "clr-wizard-page-".
             *
             * \@readonly
             *
             * \@memberof ClrWizardPage
             * @return {?}
             */ function () {
                // covers things like null, undefined, false, and empty string
                // while allowing zero to pass
                /** @type {?} */
                var idIsNonZeroFalsy = !this._id && this._id !== 0;
                // in addition to non-zero falsy we also want to make sure _id is not a negative
                // number.
                if (idIsNonZeroFalsy || this._id < 0) {
                    // guard here in the event that input becomes undefined or null by accident
                    this._id = (wizardPageIndex++).toString();
                }
                return "clr-wizard-page-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "readyToComplete", {
            /**
             * A read-only getter that serves as a convenience for those who would rather
             * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
             * ClrWizardPage.readyToComplete is more logical and declarative.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that serves as a convenience for those who would rather
             * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
             * ClrWizardPage.readyToComplete is more logical and declarative.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return !this.nextStepDisabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "completed", {
            /**
             * A page is marked as completed if it is both readyToComplete and completed,
             * as in the next or finish action has been executed while this page was current.
             *
             * Note there is and open question about how to handle pages that are marked
             * complete but who are no longer readyToComplete. This might indicate an error
             * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
             * and only returns that the page is incomplete.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A page is marked as completed if it is both readyToComplete and completed,
             * as in the next or finish action has been executed while this page was current.
             *
             * Note there is and open question about how to handle pages that are marked
             * complete but who are no longer readyToComplete. This might indicate an error
             * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
             * and only returns that the page is incomplete.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this._complete && this.readyToComplete;
                // FOR V2: UNWIND COMPLETED, READYTOCOMPLETE, AND ERRORS
                // SUCH THAT ERRORS IS ITS OWN INPUT. IF A STEP IS
                // INCOMPLETE AND ERRORED, ERRORED WILL NOT SHOW.
                // FIRST QUESTION: AM I GREY OR COLORED?
                // SECOND QUESTION: AM I GREEN OR RED?
            },
            /**
             * A ClrWizardPage can be manually set to completed using this boolean setter.
             * It is recommended that users rely on the convenience functions in the wizard
             * and navigation service instead of manually setting pages’ completion state.
             *
             * @memberof ClrWizardPage
             */
            set: /**
             * A ClrWizardPage can be manually set to completed using this boolean setter.
             * It is recommended that users rely on the convenience functions in the wizard
             * and navigation service instead of manually setting pages’ completion state.
             *
             * \@memberof ClrWizardPage
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._complete = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "current", {
            /**
             * Checks with the navigation service to see if it is the current page.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * Checks with the navigation service to see if it is the current page.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.navService.currentPage === this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return !this.enabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "enabled", {
            /**
             * A read-only getter that returns whether or not the page is navigable
             * in the wizard. A wizard page can be navigated to if it is completed
             * or the page before it is completed.
             *
             * This getter handles the logic for enabling or disabling the links in
             * the step nav on the left Side of the wizard.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns whether or not the page is navigable
             * in the wizard. A wizard page can be navigated to if it is completed
             * or the page before it is completed.
             *
             * This getter handles the logic for enabling or disabling the links in
             * the step nav on the left Side of the wizard.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.current || this.completed || this.previousCompleted;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "previousCompleted", {
            /**
             * A read-only getter that returns whether or not the page before this
             * ClrWizardPage is completed. This is useful for determining whether or not
             * a page is navigable if it is not current or already completed.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns whether or not the page before this
             * ClrWizardPage is completed. This is useful for determining whether or not
             * a page is navigable if it is not current or already completed.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                /** @type {?} */
                var previousPage = this.pageCollection.getPreviousPage(this);
                if (!previousPage) {
                    return true;
                }
                return previousPage.completed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "title", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.pageTitle.pageTitleTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "navTitle", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                if (this.pageNavTitle) {
                    return this.pageNavTitle.pageNavTitleTemplateRef;
                }
                return this.pageTitle.pageTitleTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "headerActions", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                if (!this._headerActions) {
                    return;
                }
                return this._headerActions.pageHeaderActionsTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "hasHeaderActions", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return !!this._headerActions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "buttons", {
            /**
             *
             * @memberof WizardPage
             *
             */
            get: /**
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                if (!this._buttons) {
                    return;
                }
                return this._buttons.pageButtonsTemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardPage.prototype, "hasButtons", {
            /**
             * A read-only getter that returns a boolean that says whether or
             * not the ClrWizardPage includes buttons. Used to determine if the
             * Wizard should override the default button set defined as
             * its direct children.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns a boolean that says whether or
             * not the ClrWizardPage includes buttons. Used to determine if the
             * Wizard should override the default button set defined as
             * its direct children.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return !!this._buttons;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Uses the nav service to make the ClrWizardPage the current page in the
         * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output.
         *
         * In most cases, it is better to use the default navigation functions
         * in Wizard.
         *
         * @memberof WizardPage
         *
         */
        /**
         * Uses the nav service to make the ClrWizardPage the current page in the
         * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output.
         *
         * In most cases, it is better to use the default navigation functions
         * in Wizard.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        ClrWizardPage.prototype.makeCurrent = /**
         * Uses the nav service to make the ClrWizardPage the current page in the
         * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output.
         *
         * In most cases, it is better to use the default navigation functions
         * in Wizard.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
            function () {
                this.navService.currentPage = this;
            };
        /**
         * Links the nav service and establishes the current page if one is not defined.
         *
         * @memberof WizardPage
         *
         */
        /**
         * Links the nav service and establishes the current page if one is not defined.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        ClrWizardPage.prototype.ngOnInit = /**
         * Links the nav service and establishes the current page if one is not defined.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
            function () {
                /** @type {?} */
                var navService = this.navService;
                if (!navService.currentPage && !navService.navServiceLoaded) {
                    this.makeCurrent();
                    this.navService.navServiceLoaded = true;
                }
            };
        Object.defineProperty(ClrWizardPage.prototype, "stepItemId", {
            /**
             * A read-only getter that returns the id used by the step nav item associated with the page.
             *
             * ClrWizardPage needs this ID string for aria information.
             *
             * @memberof WizardPage
             *
             */
            get: /**
             * A read-only getter that returns the id used by the step nav item associated with the page.
             *
             * ClrWizardPage needs this ID string for aria information.
             *
             * \@memberof WizardPage
             *
             * @return {?}
             */ function () {
                return this.pageCollection.getStepItemIdForPage(this);
            },
            enumerable: true,
            configurable: true
        });
        ClrWizardPage.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-page',
                        template: '<ng-content></ng-content>',
                        host: {
                            '[id]': 'id',
                            role: 'tabpanel',
                            '[attr.aria-hidden]': '!current',
                            '[attr.aria-labelledby]': 'stepItemId',
                            '[class.active]': 'current',
                            '[class.clr-wizard-page]': 'true',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrWizardPage.ctorParameters = function () {
            return [
                { type: WizardNavigationService },
                { type: PageCollectionService },
                { type: ButtonHubService }
            ];
        };
        ClrWizardPage.propDecorators = {
            pageTitle: [{ type: i0.ContentChild, args: [ClrWizardPageTitle,] }],
            pageNavTitle: [{ type: i0.ContentChild, args: [ClrWizardPageNavTitle,] }],
            _buttons: [{ type: i0.ContentChild, args: [ClrWizardPageButtons,] }],
            _headerActions: [{ type: i0.ContentChild, args: [ClrWizardPageHeaderActions,] }],
            nextStepDisabled: [{ type: i0.Input, args: ['clrWizardPageNextDisabled',] }],
            nextStepDisabledChange: [{ type: i0.Output, args: ['clrWizardPageNextDisabledChange',] }],
            previousStepDisabled: [{ type: i0.Input, args: ['clrWizardPagePreviousDisabled',] }],
            previousStepDisabledChange: [{ type: i0.Output, args: ['clrWizardPagePreviousDisabledChange',] }],
            preventDefault: [{ type: i0.Input, args: ['clrWizardPagePreventDefault',] }],
            stopCancel: [{ type: i0.Input, args: ['clrWizardPagePreventDefaultCancel',] }],
            stopCancelChange: [{ type: i0.Output, args: ['clrWizardPagePreventDefaultCancelChange',] }],
            stopNext: [{ type: i0.Input, args: ['clrWizardPagePreventDefaultNext',] }],
            onCommit: [{ type: i0.Output, args: ['clrWizardPageOnCommit',] }],
            onLoad: [{ type: i0.Output, args: ['clrWizardPageOnLoad',] }],
            pageOnCancel: [{ type: i0.Output, args: ['clrWizardPageOnCancel',] }],
            finishButtonClicked: [{ type: i0.Output, args: ['clrWizardPageFinish',] }],
            previousButtonClicked: [{ type: i0.Output, args: ['clrWizardPagePrevious',] }],
            nextButtonClicked: [{ type: i0.Output, args: ['clrWizardPageNext',] }],
            dangerButtonClicked: [{ type: i0.Output, args: ['clrWizardPageDanger',] }],
            primaryButtonClicked: [{ type: i0.Output, args: ['clrWizardPagePrimary',] }],
            customButtonClicked: [{ type: i0.Output, args: ['clrWizardPageCustomButton',] }],
            _id: [{ type: i0.Input, args: ['id',] }]
        };
        return ClrWizardPage;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     *
     * The Wizard component
     *
     */
    var ClrWizard = /** @class */ (function () {
        /**
         * Creates an instance of Wizard.
         *
         * @memberof Wizard
         *
         */
        function ClrWizard(navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
            var _this = this;
            this.navService = navService;
            this.pageCollection = pageCollection;
            this.buttonService = buttonService;
            this.headerActionService = headerActionService;
            this.elementRef = elementRef;
            /**
             * Contains the size defined by the clrWizardSize input
             *
             * \@memberof Wizard
             *
             */
            this.size = 'xl';
            this._forceForward = false;
            /**
             * Tells the modal part of the wizard whether it should have a close "X"
             * in the top right corner. Set with the clrWizardClosable input.
             *
             * \@memberof Wizard
             *
             */
            this.closable = true;
            /**
             * Toggles open/close of the wizard component. Set using the clrWizardOpen
             * input.
             *
             * \@memberof Wizard
             *
             */
            this._open = false;
            /**
             * Emits when the wizard is opened or closed. Emits through the
             * clrWizardOpenChange output. Works in conjunction with the
             * clrWizardOpen binding so you can use...
             *
             * <clr-wizard [(clrWizardOpen)]="blah"
             * ...or...
             * <clr-wizard [clrWizardOpen]="something" (clrWizardOpenChange)="doSomethign($event)">
             *
             * ...for two-way binding.
             *
             * \@memberof Wizard
             *
             */
            this._openChanged = new i0.EventEmitter(false);
            /**
             * Emits when the wizard is canceled. Can be observed through the clrWizardOnCancel
             * output.
             *
             * Can be combined with the clrWizardPreventDefaultCancel input to create
             * wizard-level custom cancel routines.
             *
             * \@memberof Wizard
             *
             */
            this.onCancel = new i0.EventEmitter(false);
            /**
             * Emits when the wizard is completed. Can be observed through the clrWizardOnFinish
             * output.
             *
             * Can be combined with the clrWizardPreventDefaultNext input to create
             * wizard-level custom completion routines.
             *
             * \@memberof Wizard
             *
             */
            this.wizardFinished = new i0.EventEmitter(false);
            /**
             * Emits when the wizard is reset. See .reset(). Can be observed through
             * the clrWizardOnReset output.
             *
             * \@memberof Wizard
             *
             */
            this.onReset = new i0.EventEmitter(false);
            /**
             * Emits when the current page has changed. Can be observed through the clrWizardCurrentPageChanged
             * output. This can happen on .next() or .previous().
             * Useful for non-blocking validation.
             *
             * \@memberof Wizard
             *
             */
            this.currentPageChanged = new i0.EventEmitter(false);
            /**
             * Emits when the wizard moves to the next page. Can be observed through the clrWizardOnNext
             * output.
             *
             * Can be combined with the clrWizardPreventDefaultNext input to create
             * wizard-level custom navigation routines, which are useful for validation.
             *
             * \@memberof Wizard
             *
             */
            this.onMoveNext = new i0.EventEmitter(false);
            /**
             * Emits when the wizard moves to the previous page. Can be observed through the
             * clrWizardOnPrevious output.
             *
             * Can be useful for validation.
             *
             * \@memberof Wizard
             *
             */
            this.onMovePrevious = new i0.EventEmitter(false);
            this._stopNext = false;
            this._stopCancel = false;
            this._stopNavigation = false;
            this._disableStepnav = false;
            /**
             * Used only to communicate to the underlying modal that animations are not
             * wanted. Primary use is for the display of static/inline wizards.
             *
             * Set using clrWizardPreventModalAnimation input. But you should never set it.
             *
             * \@memberof Wizard
             *
             */
            this._stopModalAnimations = false;
            this.goNextSubscription = this.navService.movedToNextPage.subscribe(function () {
                _this.onMoveNext.emit();
            });
            this.goPreviousSubscription = this.navService.movedToPreviousPage.subscribe(function () {
                _this.onMovePrevious.emit();
            });
            this.cancelSubscription = this.navService.notifyWizardCancel.subscribe(function () {
                _this.checkAndCancel();
            });
            this.wizardFinishedSubscription = this.navService.wizardFinished.subscribe(function () {
                if (!_this.stopNext) {
                    _this.forceFinish();
                }
                _this.wizardFinished.emit();
            });
            this.differ = differs.find([]).create(null);
        }
        Object.defineProperty(ClrWizard.prototype, "forceForward", {
            get: /**
             * @return {?}
             */ function () {
                return this._forceForward;
            },
            /**
             * Resets page completed states when navigating backwards. Can be set using
             * the clrWizardForceForwardNavigation input.
             *
             * @memberof Wizard
             *
             */
            set: /**
             * Resets page completed states when navigating backwards. Can be set using
             * the clrWizardForceForwardNavigation input.
             *
             * \@memberof Wizard
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._forceForward = !!value;
                this.navService.forceForwardNavigation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "clrWizardOpen", {
            set: /**
             * @param {?} open
             * @return {?}
             */ function (open) {
                if (open) {
                    this.buttonService.buttonsReady = true;
                }
                this._open = open;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopNext", {
            get: /**
             * @return {?}
             */ function () {
                return this._stopNext;
            },
            /**
             * Prevents ClrWizard from moving to the next page or closing itself on finishing.
             * Set using the clrWizardPreventDefaultNext input.
             *
             * Note that using stopNext will require you to create your own calls to
             * .next() and .finish() in your host component to make the ClrWizard work as
             * expected.
             *
             * Primarily used for validation.
             *
             * @memberof Wizard
             *
             */
            set: /**
             * Prevents ClrWizard from moving to the next page or closing itself on finishing.
             * Set using the clrWizardPreventDefaultNext input.
             *
             * Note that using stopNext will require you to create your own calls to
             * .next() and .finish() in your host component to make the ClrWizard work as
             * expected.
             *
             * Primarily used for validation.
             *
             * \@memberof Wizard
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._stopNext = !!value;
                this.navService.wizardHasAltNext = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopCancel", {
            get: /**
             * @return {?}
             */ function () {
                return this._stopCancel;
            },
            /**
             * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
             * Set using the clrWizardPreventDefaultCancel input.
             *
             * Note that using stopCancel will require you to create your own calls to
             * .close() in your host component to make the ClrWizard work as expected.
             *
             * Useful for doing checks or prompts before closing a ClrWizard.
             *
             * @memberof Wizard
             *
             */
            set: /**
             * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
             * Set using the clrWizardPreventDefaultCancel input.
             *
             * Note that using stopCancel will require you to create your own calls to
             * .close() in your host component to make the ClrWizard work as expected.
             *
             * Useful for doing checks or prompts before closing a ClrWizard.
             *
             * \@memberof Wizard
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._stopCancel = !!value;
                this.navService.wizardHasAltCancel = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopNavigation", {
            get: /**
             * @return {?}
             */ function () {
                return this._stopNavigation;
            },
            /**
             * Prevents ClrWizard from performing any form of navigation away from the current
             * page. Set using the clrWizardPreventNavigation input.
             *
             * Note that stopNavigation is meant to freeze the wizard in place, typically
             * during a long validation or background action where you want the wizard to
             * display loading content but not allow the user to execute navigation in
             * the stepnav, close X, or the  back, finish, or next buttons.
             *
             * @memberof Wizard
             *
             */
            set: /**
             * Prevents ClrWizard from performing any form of navigation away from the current
             * page. Set using the clrWizardPreventNavigation input.
             *
             * Note that stopNavigation is meant to freeze the wizard in place, typically
             * during a long validation or background action where you want the wizard to
             * display loading content but not allow the user to execute navigation in
             * the stepnav, close X, or the  back, finish, or next buttons.
             *
             * \@memberof Wizard
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._stopNavigation = !!value;
                this.navService.wizardStopNavigation = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "disableStepnav", {
            get: /**
             * @return {?}
             */ function () {
                return this._disableStepnav;
            },
            /**
             * Prevents clicks on the links in the stepnav from working.
             *
             * A more granular bypassing of navigation which can be useful when your
             * ClrWizard is in a state of completion and you don't want users to be
             * able to jump backwards and change things.
             *
             * @memberof Wizard
             *
             */
            set: /**
             * Prevents clicks on the links in the stepnav from working.
             *
             * A more granular bypassing of navigation which can be useful when your
             * ClrWizard is in a state of completion and you don't want users to be
             * able to jump backwards and change things.
             *
             * \@memberof Wizard
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disableStepnav = !!value;
                this.navService.wizardDisableStepnav = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "stopModalAnimations", {
            get: /**
             * @return {?}
             */ function () {
                if (this._stopModalAnimations) {
                    return 'true';
                }
                return 'false';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizard.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.currentPageSubscription = this.navService.currentPageChanged.subscribe(function (page) {
                    _this.currentPageChanged.emit();
                });
            };
        /**
         * @return {?}
         */
        ClrWizard.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.goNextSubscription) {
                    this.goNextSubscription.unsubscribe();
                }
                if (this.goPreviousSubscription) {
                    this.goPreviousSubscription.unsubscribe();
                }
                if (this.cancelSubscription) {
                    this.cancelSubscription.unsubscribe();
                }
                if (this.currentPageSubscription) {
                    this.currentPageSubscription.unsubscribe();
                }
                if (this.wizardFinishedSubscription) {
                    this.wizardFinishedSubscription.unsubscribe();
                }
            };
        /**
         * Sets up references that are needed by the providers.
         *
         * @name ngAfterContentInit
         * @memberof Wizard
         *
         */
        /**
         * Sets up references that are needed by the providers.
         *
         * \@name ngAfterContentInit
         * \@memberof Wizard
         *
         * @return {?}
         */
        ClrWizard.prototype.ngAfterContentInit = /**
         * Sets up references that are needed by the providers.
         *
         * \@name ngAfterContentInit
         * \@memberof Wizard
         *
         * @return {?}
         */
            function () {
                this.pageCollection.pages = this.pages;
                this.headerActionService.wizardHeaderActions = this.headerActions;
                // Only trigger buttons ready if default is open (inlined)
                if (this._open) {
                    this.buttonService.buttonsReady = true;
                }
            };
        /**
         * Used for keeping track of when pages are added or removed from this.pages
         *
         * @name ngDoCheck
         * @memberof Wizard
         *
         */
        /**
         * Used for keeping track of when pages are added or removed from this.pages
         *
         * \@name ngDoCheck
         * \@memberof Wizard
         *
         * @return {?}
         */
        ClrWizard.prototype.ngDoCheck = /**
         * Used for keeping track of when pages are added or removed from this.pages
         *
         * \@name ngDoCheck
         * \@memberof Wizard
         *
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var changes = this.differ.diff(this.pages);
                if (changes) {
                    changes.forEachAddedItem(function (r) {
                        _this.navService.updateNavigation();
                    });
                    changes.forEachRemovedItem(function (r) {
                        _this.navService.updateNavigation();
                    });
                }
            };
        Object.defineProperty(ClrWizard.prototype, "isStatic", {
            /**
             * Convenient property for determining whether a wizard is static/in-line or not.
             *
             * @name isStatic
             *
             * @memberof Wizard
             *
             */
            get: /**
             * Convenient property for determining whether a wizard is static/in-line or not.
             *
             * \@name isStatic
             *
             * \@memberof Wizard
             *
             * @return {?}
             */ function () {
                return this.elementRef.nativeElement.classList.contains('clr-wizard--inline');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "currentPage", {
            /**
             * As a getter, current page is a convenient way to retrieve the current page from
             * the WizardNavigationService.
             *
             * As a setter, current page accepts a ClrWizardPage and passes it to WizardNavigationService
             * to be made the current page. currentPage performs checks to make sure it can navigate
             * to the designated page.
             *
             * @name currentPage
             *
             * @memberof Wizard
             *
             */
            get: /**
             * As a getter, current page is a convenient way to retrieve the current page from
             * the WizardNavigationService.
             *
             * As a setter, current page accepts a ClrWizardPage and passes it to WizardNavigationService
             * to be made the current page. currentPage performs checks to make sure it can navigate
             * to the designated page.
             *
             * \@name currentPage
             *
             * \@memberof Wizard
             *
             * @return {?}
             */ function () {
                return this.navService.currentPage;
            },
            set: /**
             * @param {?} page
             * @return {?}
             */ function (page) {
                this.navService.goTo(page, true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isLast", {
            /**
             * Convenient property for determining if the current page is the last page of
             * the wizard.
             *
             * @name isLast
             *
             * @memberof Wizard
             *
             */
            get: /**
             * Convenient property for determining if the current page is the last page of
             * the wizard.
             *
             * \@name isLast
             *
             * \@memberof Wizard
             *
             * @return {?}
             */ function () {
                return this.navService.currentPageIsLast;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizard.prototype, "isFirst", {
            /**
             * Convenient property for determining if the current page is the first page of
             * the wizard.
             *
             * @name isFirst
             *
             * @memberof Wizard
             *
             */
            get: /**
             * Convenient property for determining if the current page is the first page of
             * the wizard.
             *
             * \@name isFirst
             *
             * \@memberof Wizard
             *
             * @return {?}
             */ function () {
                return this.navService.currentPageIsFirst;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Performs the actions needed to open the wizard. If there is no current
         * page defined, sets the first page in the wizard to be current.
         *
         * @name open
         * @memberof ClrWizard
         */
        /**
         * Performs the actions needed to open the wizard. If there is no current
         * page defined, sets the first page in the wizard to be current.
         *
         * \@name open
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.open = /**
         * Performs the actions needed to open the wizard. If there is no current
         * page defined, sets the first page in the wizard to be current.
         *
         * \@name open
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                this._open = true;
                if (!this.currentPage) {
                    this.navService.setFirstPageCurrent();
                }
                // Only render buttons when wizard is opened, to avoid chocolate errors
                this.buttonService.buttonsReady = true;
                this._openChanged.emit(true);
            };
        /**
         * Does the work involved with closing the wizard. Call this directly instead
         * of cancel() to implement alternative cancel functionality.
         *
         * @name close
         * @memberof ClrWizard
         */
        /**
         * Does the work involved with closing the wizard. Call this directly instead
         * of cancel() to implement alternative cancel functionality.
         *
         * \@name close
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.close = /**
         * Does the work involved with closing the wizard. Call this directly instead
         * of cancel() to implement alternative cancel functionality.
         *
         * \@name close
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                if (this.stopNavigation) {
                    return;
                }
                this._open = false;
                this._openChanged.emit(false);
            };
        /**
         * Convenient function that can be used to open and close the wizard. It operates
         * by checking a Boolean parameter. If true, the wizard is opened. If false,
         * it is closed.
         *
         * There is no default value for this parameter, so by default the wizard will
         * close if invoked with no parameter.
         *
         * @name toggle
         *
         * @memberof ClrWizard
         */
        /**
         * Convenient function that can be used to open and close the wizard. It operates
         * by checking a Boolean parameter. If true, the wizard is opened. If false,
         * it is closed.
         *
         * There is no default value for this parameter, so by default the wizard will
         * close if invoked with no parameter.
         *
         * \@name toggle
         *
         * \@memberof ClrWizard
         * @param {?} value
         * @return {?}
         */
        ClrWizard.prototype.toggle = /**
         * Convenient function that can be used to open and close the wizard. It operates
         * by checking a Boolean parameter. If true, the wizard is opened. If false,
         * it is closed.
         *
         * There is no default value for this parameter, so by default the wizard will
         * close if invoked with no parameter.
         *
         * \@name toggle
         *
         * \@memberof ClrWizard
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.open();
                }
                else {
                    this.close();
                }
            };
        /**
         * Moves the wizard to the previous page.
         *
         * @name previous
         * @memberof ClrWizard
         */
        /**
         * Moves the wizard to the previous page.
         *
         * \@name previous
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.previous = /**
         * Moves the wizard to the previous page.
         *
         * \@name previous
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                this.navService.previous();
            };
        /**
         * Includes a Boolean parameter that will skip checks and event emissions.
         * If true, the wizard will move to the next page regardless of the state of
         * its current page. This is useful for alternative navigation where event
         * emissions have already been done and firing them again may cause an event loop.
         *
         * Generally, with alternative navigation, users are supplying their own checks
         * and validation. So there is no point in superseding their business logic
         * with our default behavior.
         *
         * If false, the wizard will execute default checks and emit events as normal.
         * This is useful for custom buttons or programmatic workflows that are not
         * executing the wizards default checks and emissions. It is another way to
         * navigate without having to rewrite the wizard’s default functionality
         * from scratch.
         *
         * By default, next() does not execute event emissions or checks because the
         * 80% case is that this method will be called as part of an alternative
         * navigation with clrWizardPreventDefaultNext.
         *
         * @name next
         * @memberof ClrWizard
         */
        /**
         * Includes a Boolean parameter that will skip checks and event emissions.
         * If true, the wizard will move to the next page regardless of the state of
         * its current page. This is useful for alternative navigation where event
         * emissions have already been done and firing them again may cause an event loop.
         *
         * Generally, with alternative navigation, users are supplying their own checks
         * and validation. So there is no point in superseding their business logic
         * with our default behavior.
         *
         * If false, the wizard will execute default checks and emit events as normal.
         * This is useful for custom buttons or programmatic workflows that are not
         * executing the wizards default checks and emissions. It is another way to
         * navigate without having to rewrite the wizard’s default functionality
         * from scratch.
         *
         * By default, next() does not execute event emissions or checks because the
         * 80% case is that this method will be called as part of an alternative
         * navigation with clrWizardPreventDefaultNext.
         *
         * \@name next
         * \@memberof ClrWizard
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
        ClrWizard.prototype.next = /**
         * Includes a Boolean parameter that will skip checks and event emissions.
         * If true, the wizard will move to the next page regardless of the state of
         * its current page. This is useful for alternative navigation where event
         * emissions have already been done and firing them again may cause an event loop.
         *
         * Generally, with alternative navigation, users are supplying their own checks
         * and validation. So there is no point in superseding their business logic
         * with our default behavior.
         *
         * If false, the wizard will execute default checks and emit events as normal.
         * This is useful for custom buttons or programmatic workflows that are not
         * executing the wizards default checks and emissions. It is another way to
         * navigate without having to rewrite the wizard’s default functionality
         * from scratch.
         *
         * By default, next() does not execute event emissions or checks because the
         * 80% case is that this method will be called as part of an alternative
         * navigation with clrWizardPreventDefaultNext.
         *
         * \@name next
         * \@memberof ClrWizard
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
            function (skipChecksAndEmits) {
                if (skipChecksAndEmits === void 0) {
                    skipChecksAndEmits = true;
                }
                if (skipChecksAndEmits) {
                    this.forceNext();
                }
                else {
                    this.navService.next();
                }
            };
        /**
         * Includes a Boolean parameter that will skip checks and event emissions.
         * If true, the wizard will  complete and close regardless of the state of
         * its current page. This is useful for alternative navigation where event
         * emissions have already been done and firing them again may cause an event loop.
         *
         * If false, the wizard will execute default checks and emit events before
         * completing and closing.
         *
         * By default, finish() does not execute event emissions or checks because the
         * 80% case is that this method will be called as part of an alternative
         * navigation with clrWizardPreventDefaultNext.
         *
         * @name finish
         * @memberof ClrWizard
         */
        /**
         * Includes a Boolean parameter that will skip checks and event emissions.
         * If true, the wizard will  complete and close regardless of the state of
         * its current page. This is useful for alternative navigation where event
         * emissions have already been done and firing them again may cause an event loop.
         *
         * If false, the wizard will execute default checks and emit events before
         * completing and closing.
         *
         * By default, finish() does not execute event emissions or checks because the
         * 80% case is that this method will be called as part of an alternative
         * navigation with clrWizardPreventDefaultNext.
         *
         * \@name finish
         * \@memberof ClrWizard
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
        ClrWizard.prototype.finish = /**
         * Includes a Boolean parameter that will skip checks and event emissions.
         * If true, the wizard will  complete and close regardless of the state of
         * its current page. This is useful for alternative navigation where event
         * emissions have already been done and firing them again may cause an event loop.
         *
         * If false, the wizard will execute default checks and emit events before
         * completing and closing.
         *
         * By default, finish() does not execute event emissions or checks because the
         * 80% case is that this method will be called as part of an alternative
         * navigation with clrWizardPreventDefaultNext.
         *
         * \@name finish
         * \@memberof ClrWizard
         * @param {?=} skipChecksAndEmits
         * @return {?}
         */
            function (skipChecksAndEmits) {
                if (skipChecksAndEmits === void 0) {
                    skipChecksAndEmits = true;
                }
                if (skipChecksAndEmits) {
                    this.forceFinish();
                }
                else {
                    this.navService.finish();
                }
            };
        /**
         * Does the work of finishing up the wizard and closing it but doesn't do the
         * checks and emissions that other paths do. Good for a last step in an
         * alternate workflow.
         *
         * Does the same thing as calling ClrWizard.finish(true) or ClrWizard.finish()
         * without a parameter.
         *
         * @name forceFinish
         * @memberof ClrWizard
         */
        /**
         * Does the work of finishing up the wizard and closing it but doesn't do the
         * checks and emissions that other paths do. Good for a last step in an
         * alternate workflow.
         *
         * Does the same thing as calling ClrWizard.finish(true) or ClrWizard.finish()
         * without a parameter.
         *
         * \@name forceFinish
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.forceFinish = /**
         * Does the work of finishing up the wizard and closing it but doesn't do the
         * checks and emissions that other paths do. Good for a last step in an
         * alternate workflow.
         *
         * Does the same thing as calling ClrWizard.finish(true) or ClrWizard.finish()
         * without a parameter.
         *
         * \@name forceFinish
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                if (this.stopNavigation) {
                    return;
                }
                this.close();
            };
        /**
         * Does the work of moving the wizard to the next page without the
         * checks and emissions that other paths do. Good for a last step in an
         * alternate workflow.
         *
         * Does the same thing as calling ClrWizard.next(true) or ClrWizard.next()
         * without a parameter.
         *
         * @name forceNext
         * @memberof ClrWizard
         */
        /**
         * Does the work of moving the wizard to the next page without the
         * checks and emissions that other paths do. Good for a last step in an
         * alternate workflow.
         *
         * Does the same thing as calling ClrWizard.next(true) or ClrWizard.next()
         * without a parameter.
         *
         * \@name forceNext
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.forceNext = /**
         * Does the work of moving the wizard to the next page without the
         * checks and emissions that other paths do. Good for a last step in an
         * alternate workflow.
         *
         * Does the same thing as calling ClrWizard.next(true) or ClrWizard.next()
         * without a parameter.
         *
         * \@name forceNext
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                this.navService.forceNext();
            };
        /**
         * Initiates the functionality that cancels and closes the wizard.
         *
         * Do not use this for an override of the cancel the functionality
         * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
         * or clrWizardPagePreventDefault because it will initiate the same checks
         * and event emissions that invoked your event handler.
         *
         * Use ClrWizard.close() instead.
         *
         * @name cancel
         * @memberof ClrWizard
         */
        /**
         * Initiates the functionality that cancels and closes the wizard.
         *
         * Do not use this for an override of the cancel the functionality
         * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
         * or clrWizardPagePreventDefault because it will initiate the same checks
         * and event emissions that invoked your event handler.
         *
         * Use ClrWizard.close() instead.
         *
         * \@name cancel
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.cancel = /**
         * Initiates the functionality that cancels and closes the wizard.
         *
         * Do not use this for an override of the cancel the functionality
         * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
         * or clrWizardPagePreventDefault because it will initiate the same checks
         * and event emissions that invoked your event handler.
         *
         * Use ClrWizard.close() instead.
         *
         * \@name cancel
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                this.navService.cancel();
            };
        /**
         * Overrides behavior of the underlying modal to avoid collisions with
         * alternative cancel functionality.
         *
         * In most cases, use ClrWizard.cancel() instead.
         *
         * @name modalCancel
         * @memberof ClrWizard
         */
        /**
         * Overrides behavior of the underlying modal to avoid collisions with
         * alternative cancel functionality.
         *
         * In most cases, use ClrWizard.cancel() instead.
         *
         * \@name modalCancel
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.modalCancel = /**
         * Overrides behavior of the underlying modal to avoid collisions with
         * alternative cancel functionality.
         *
         * In most cases, use ClrWizard.cancel() instead.
         *
         * \@name modalCancel
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                this.checkAndCancel();
            };
        /**
         * Checks for alternative cancel flows defined at the current page or
         * wizard level. Performs a canceled if not. Emits events that initiate
         * the alternative cancel outputs (clrWizardPageOnCancel and
         * clrWizardOnCancel) if so.
         *
         * @name checkAndCancel
         * @memberof ClrWizard
         */
        /**
         * Checks for alternative cancel flows defined at the current page or
         * wizard level. Performs a canceled if not. Emits events that initiate
         * the alternative cancel outputs (clrWizardPageOnCancel and
         * clrWizardOnCancel) if so.
         *
         * \@name checkAndCancel
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.checkAndCancel = /**
         * Checks for alternative cancel flows defined at the current page or
         * wizard level. Performs a canceled if not. Emits events that initiate
         * the alternative cancel outputs (clrWizardPageOnCancel and
         * clrWizardOnCancel) if so.
         *
         * \@name checkAndCancel
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                /** @type {?} */
                var currentPage = this.currentPage;
                /** @type {?} */
                var currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
                if (this.stopNavigation) {
                    return;
                }
                currentPage.pageOnCancel.emit();
                if (!currentPageHasOverrides) {
                    this.onCancel.emit();
                }
                if (!this.stopCancel && !currentPageHasOverrides) {
                    this.close();
                }
            };
        /**
         * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
         * to navigate to the page with that ID. Navigation will invoke the wizard’s default
         * checks and event emissions.
         *
         * Probably less useful than calling directly to ClrWizard.navService.goTo() because the
         * nav service method can accept either a string ID or a page object.
         *
         * The format of the expected ID parameter can be found in the return of the
         * ClrWizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
         * numeric ID or the ID specified for the ClrWizardPage component’s “id” input.
         *
         * @name goTo
         *
         * @memberof ClrWizard
         */
        /**
         * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
         * to navigate to the page with that ID. Navigation will invoke the wizard’s default
         * checks and event emissions.
         *
         * Probably less useful than calling directly to ClrWizard.navService.goTo() because the
         * nav service method can accept either a string ID or a page object.
         *
         * The format of the expected ID parameter can be found in the return of the
         * ClrWizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
         * numeric ID or the ID specified for the ClrWizardPage component’s “id” input.
         *
         * \@name goTo
         *
         * \@memberof ClrWizard
         * @param {?} pageId
         * @return {?}
         */
        ClrWizard.prototype.goTo = /**
         * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
         * to navigate to the page with that ID. Navigation will invoke the wizard’s default
         * checks and event emissions.
         *
         * Probably less useful than calling directly to ClrWizard.navService.goTo() because the
         * nav service method can accept either a string ID or a page object.
         *
         * The format of the expected ID parameter can be found in the return of the
         * ClrWizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
         * numeric ID or the ID specified for the ClrWizardPage component’s “id” input.
         *
         * \@name goTo
         *
         * \@memberof ClrWizard
         * @param {?} pageId
         * @return {?}
         */
            function (pageId) {
                if (!pageId) {
                    return;
                }
                this.navService.goTo(pageId);
            };
        /**
         * A convenience function that calls to PageCollectionService.reset() and emits the
         * ClrWizard.onReset event.
         *
         * Reset sets all WizardPages to incomplete and sets the first page in the ClrWizard to
         * be the current page, essentially resetting the wizard navigation.
         *
         * Users would then use the onReset event to reset the data or model in their
         * host component.
         *
         * It could be useful to call a reset without firing the onReset event. To do this,
         * just call ClrWizard.pageCollection.reset() directly.
         *
         * @name reset
         * @memberof ClrWizard
         */
        /**
         * A convenience function that calls to PageCollectionService.reset() and emits the
         * ClrWizard.onReset event.
         *
         * Reset sets all WizardPages to incomplete and sets the first page in the ClrWizard to
         * be the current page, essentially resetting the wizard navigation.
         *
         * Users would then use the onReset event to reset the data or model in their
         * host component.
         *
         * It could be useful to call a reset without firing the onReset event. To do this,
         * just call ClrWizard.pageCollection.reset() directly.
         *
         * \@name reset
         * \@memberof ClrWizard
         * @return {?}
         */
        ClrWizard.prototype.reset = /**
         * A convenience function that calls to PageCollectionService.reset() and emits the
         * ClrWizard.onReset event.
         *
         * Reset sets all WizardPages to incomplete and sets the first page in the ClrWizard to
         * be the current page, essentially resetting the wizard navigation.
         *
         * Users would then use the onReset event to reset the data or model in their
         * host component.
         *
         * It could be useful to call a reset without firing the onReset event. To do this,
         * just call ClrWizard.pageCollection.reset() directly.
         *
         * \@name reset
         * \@memberof ClrWizard
         * @return {?}
         */
            function () {
                this.pageCollection.reset();
                this.onReset.next();
            };
        ClrWizard.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard',
                        providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
                        template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-modal\n    [clrModalOpen]=\"_open\"\n    [clrModalSize]=\"size\"\n    [clrModalClosable]=\"closable\"\n    [clrModalStaticBackdrop]=\"true\"\n    [clrModalSkipAnimation]=\"stopModalAnimations\"\n    [clrModalOverrideScrollService]=\"isStatic\"\n    [clrModalPreventClose]=\"true\"\n    (clrModalAlternateClose)=\"modalCancel()\">\n\n    <nav class=\"modal-nav clr-wizard-stepnav-wrapper\">\n        <h3 class=\"clr-wizard-title\"><ng-content select=\"clr-wizard-title\"></ng-content></h3>\n        <clr-wizard-stepnav></clr-wizard-stepnav>\n    </nav>\n\n    <h3 class=\"modal-title\">\n        <span class=\"modal-title-text\">\n            <ng-template [ngTemplateOutlet]=\"navService.currentPageTitle\"></ng-template>\n        </span>\n\n        <div class=\"modal-header-actions-wrapper\" *ngIf=\"headerActionService.displayHeaderActionsWrapper\">\n            <div *ngIf=\"headerActionService.showWizardHeaderActions\">\n                <ng-content select=\"clr-wizard-header-action\"></ng-content>\n            </div>\n            <div *ngIf=\"headerActionService.currentPageHasHeaderActions\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.headerActions\"></ng-template>\n            </div>\n        </div>\n    </h3>\n\n    <div class=\"modal-body\">\n        <main clr-wizard-pages-wrapper class=\"clr-wizard-content\">\n            <ng-content></ng-content>\n        </main>\n    </div>\n    <div class=\"modal-footer clr-wizard-footer\">\n        <div class=\"clr-wizard-footer-buttons\">\n            <div *ngIf=\"navService.currentPage && !navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-content select=\"clr-wizard-button\"></ng-content>\n            </div>\n            <div *ngIf=\"navService.currentPage && navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.buttons\"></ng-template>\n            </div>\n        </div>\n    </div>\n</clr-modal>\n",
                        host: {
                            '[class.clr-wizard]': 'true',
                            '[class.wizard-md]': "size == 'md'",
                            '[class.wizard-lg]': "size == 'lg'",
                            '[class.wizard-xl]': "size == 'xl'",
                            '[class.lastPage]': 'navService.currentPageIsLast',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrWizard.ctorParameters = function () {
            return [
                { type: WizardNavigationService },
                { type: PageCollectionService },
                { type: ButtonHubService },
                { type: HeaderActionService },
                { type: i0.ElementRef },
                { type: i0.IterableDiffers }
            ];
        };
        ClrWizard.propDecorators = {
            size: [{ type: i0.Input, args: ['clrWizardSize',] }],
            forceForward: [{ type: i0.Input, args: ['clrWizardForceForwardNavigation',] }],
            closable: [{ type: i0.Input, args: ['clrWizardClosable',] }],
            clrWizardOpen: [{ type: i0.Input, args: ['clrWizardOpen',] }],
            _openChanged: [{ type: i0.Output, args: ['clrWizardOpenChange',] }],
            onCancel: [{ type: i0.Output, args: ['clrWizardOnCancel',] }],
            wizardFinished: [{ type: i0.Output, args: ['clrWizardOnFinish',] }],
            onReset: [{ type: i0.Output, args: ['clrWizardOnReset',] }],
            pages: [{ type: i0.ContentChildren, args: [ClrWizardPage,] }],
            headerActions: [{ type: i0.ContentChildren, args: [ClrWizardHeaderAction,] }],
            currentPageChanged: [{ type: i0.Output, args: ['clrWizardCurrentPageChanged',] }],
            onMoveNext: [{ type: i0.Output, args: ['clrWizardOnNext',] }],
            onMovePrevious: [{ type: i0.Output, args: ['clrWizardOnPrevious',] }],
            stopNext: [{ type: i0.Input, args: ['clrWizardPreventDefaultNext',] }],
            stopCancel: [{ type: i0.Input, args: ['clrWizardPreventDefaultCancel',] }],
            stopNavigation: [{ type: i0.Input, args: ['clrWizardPreventNavigation',] }],
            disableStepnav: [{ type: i0.Input, args: ['clrWizardDisableStepnav',] }],
            _stopModalAnimations: [{ type: i0.Input, args: ['clrWizardPreventModalAnimation',] }]
        };
        return ClrWizard;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEFAULT_BUTTON_TYPES = {
        cancel: 'cancel',
        previous: 'previous',
        next: 'next',
        finish: 'finish',
        danger: 'danger',
    };
    /** @type {?} */
    var CUSTOM_BUTTON_TYPES = {
        cancel: 'custom-cancel',
        previous: 'custom-previous',
        next: 'custom-next',
        finish: 'custom-finish',
        danger: 'custom-danger',
    };
    var ClrWizardButton = /** @class */ (function () {
        function ClrWizardButton(navService, buttonService) {
            this.navService = navService;
            this.buttonService = buttonService;
            this.type = '';
            this.disabled = false;
            this.hidden = false;
            // EventEmitter which is emitted when a button is clicked.
            this.wasClicked = new i0.EventEmitter(false);
        }
        /**
         * @param {?=} valueToCheck
         * @param {?=} typeToLookUp
         * @return {?}
         */
        ClrWizardButton.prototype.checkDefaultAndCustomType = /**
         * @param {?=} valueToCheck
         * @param {?=} typeToLookUp
         * @return {?}
         */
            function (valueToCheck, typeToLookUp) {
                if (valueToCheck === void 0) {
                    valueToCheck = '';
                }
                if (DEFAULT_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
                    return true;
                }
                if (CUSTOM_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
                    return true;
                }
                return false;
            };
        Object.defineProperty(ClrWizardButton.prototype, "isCancel", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'cancel');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isNext", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'next');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isPrevious", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'previous');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isFinish", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'finish');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isDanger", {
            get: /**
             * @return {?}
             */ function () {
                return this.checkDefaultAndCustomType(this.type, 'danger');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isPrimaryAction", {
            get: /**
             * @return {?}
             */ function () {
                return this.isNext || this.isDanger || this.isFinish;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "_disabledAttribute", {
            get: /**
             * @return {?}
             */ function () {
                if (this.isDisabled) {
                    return '';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isDisabled", {
            get: /**
             * @return {?}
             */ function () {
                // dealing with negatives here. cognitively easier to think of it like this...
                /** @type {?} */
                var disabled = true;
                /** @type {?} */
                var nav = this.navService;
                /** @type {?} */
                var page = this.navService.currentPage;
                // Ensure we don't change the response until buttons are ready to avoid chocolate
                if (!this.buttonService.buttonsReady) {
                    return !disabled;
                }
                if (this.disabled || nav.wizardStopNavigation || !page) {
                    return true;
                }
                if (this.isCancel) {
                    return !disabled;
                }
                if (this.isPrevious && (nav.currentPageIsFirst || page.previousStepDisabled)) {
                    return disabled;
                }
                if (this.isDanger && !page.readyToComplete) {
                    return disabled;
                }
                if (this.isNext && (nav.currentPageIsLast || !page.readyToComplete)) {
                    return disabled;
                }
                if (this.isFinish && (!nav.currentPageIsLast || !page.readyToComplete)) {
                    return disabled;
                }
                return !disabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardButton.prototype, "isHidden", {
            get: /**
             * @return {?}
             */ function () {
                // dealing with negatives here. cognitively easier to think of it like this...
                /** @type {?} */
                var hidden = true;
                /** @type {?} */
                var nav = this.navService;
                // Ensure we don't change the response until buttons are ready to avoid chocolate
                if (!this.buttonService.buttonsReady) {
                    return !hidden;
                }
                if (this.hidden) {
                    return true;
                }
                if (this.isCancel) {
                    return !hidden;
                }
                if (this.isPrevious && nav.currentPageIsFirst) {
                    return hidden;
                }
                if (this.isNext && nav.currentPageIsLast) {
                    return hidden;
                }
                if (this.isFinish && !nav.currentPageIsLast) {
                    return hidden;
                }
                return !hidden;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizardButton.prototype.click = /**
         * @return {?}
         */
            function () {
                if (this.isDisabled) {
                    return;
                }
                this.wasClicked.emit(this.type);
                this.buttonService.buttonClicked(this.type);
            };
        ClrWizardButton.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-button',
                        template: "\n        <button\n            type=\"button\"\n            class=\"btn clr-wizard-btn\"\n            [class.btn-link]=\"isCancel\"\n            [class.clr-wizard-btn--tertiary]=\"isCancel\"\n            [class.btn-outline]=\"isPrevious\"\n            [class.clr-wizard-btn--secondary]=\"isPrevious\"\n            [class.btn-primary]=\"isPrimaryAction\"\n            [class.clr-wizard-btn--primary]=\"isPrimaryAction\"\n            [class.btn-success]=\"isFinish\"\n            [class.btn-danger]=\"isDanger\"\n            [class.disabled]=\"isDisabled\"\n            [attr.disabled]=\"_disabledAttribute\"\n            (click)=\"click()\">\n            <ng-content></ng-content>\n        </button>\n    ",
                        host: { class: 'clr-wizard-btn-wrapper', '[attr.aria-hidden]': 'isHidden' },
                        styles: ['[aria-hidden="true"] { display: none; }']
                    }] }
        ];
        /** @nocollapse */
        ClrWizardButton.ctorParameters = function () {
            return [
                { type: WizardNavigationService },
                { type: ButtonHubService }
            ];
        };
        ClrWizardButton.propDecorators = {
            type: [{ type: i0.Input, args: ['type',] }],
            disabled: [{ type: i0.Input, args: ['clrWizardButtonDisabled',] }],
            hidden: [{ type: i0.Input, args: ['clrWizardButtonHidden',] }],
            wasClicked: [{ type: i0.Output, args: ['clrWizardButtonClicked',] }]
        };
        return ClrWizardButton;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardCustomTags = /** @class */ (function () {
        function ClrWizardCustomTags() {
        }
        ClrWizardCustomTags.decorators = [
            { type: i0.Directive, args: [{ selector: 'clr-wizard-title, clr-wizard-pagetitle' },] }
        ];
        return ClrWizardCustomTags;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardStepnav = /** @class */ (function () {
        function ClrWizardStepnav(pageService) {
            this.pageService = pageService;
        }
        ClrWizardStepnav.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-wizard-stepnav',
                        template: "\n        <ol class=\"clr-wizard-stepnav-list\" role=\"tablist\">\n            <li *ngFor=\"let page of pageService.pages\" clr-wizard-stepnav-item \n            [page]=\"page\" class=\"clr-wizard-stepnav-item\"></li>\n        </ol>\n    ",
                        host: { class: 'clr-wizard-stepnav' }
                    }] }
        ];
        /** @nocollapse */
        ClrWizardStepnav.ctorParameters = function () {
            return [
                { type: PageCollectionService }
            ];
        };
        return ClrWizardStepnav;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrWizardStepnavItem = /** @class */ (function () {
        function ClrWizardStepnavItem(navService, pageCollection) {
            this.navService = navService;
            this.pageCollection = pageCollection;
        }
        /**
         * @return {?}
         */
        ClrWizardStepnavItem.prototype.pageGuard = /**
         * @return {?}
         */
            function () {
                if (!this.page) {
                    throw new Error('Wizard stepnav item is not associated with a wizard page.');
                }
            };
        Object.defineProperty(ClrWizardStepnavItem.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.pageCollection.getStepItemIdForPage(this.page);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isDisabled", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.page.disabled || this.navService.wizardStopNavigation || this.navService.wizardDisableStepnav;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isCurrent", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.page.current;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "isComplete", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.page.completed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrWizardStepnavItem.prototype, "canNavigate", {
            get: /**
             * @return {?}
             */ function () {
                this.pageGuard();
                return this.pageCollection.previousPageIsCompleted(this.page);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ClrWizardStepnavItem.prototype.click = /**
         * @return {?}
         */
            function () {
                this.pageGuard();
                // if we click on our own stepnav or a disabled stepnav, we don't want to do anything
                if (this.isDisabled || this.isCurrent) {
                    return;
                }
                this.navService.goTo(this.page);
            };
        ClrWizardStepnavItem.decorators = [
            { type: i0.Component, args: [{
                        selector: '[clr-wizard-stepnav-item]',
                        template: "\n        <button type=\"button\" class=\"btn btn-link clr-wizard-stepnav-link\" (click)=\"click()\">\n            <ng-template [ngTemplateOutlet]=\"page.navTitle\"></ng-template>\n        </button>\n    ",
                        host: {
                            '[id]': 'id',
                            '[attr.aria-selected]': 'isCurrent',
                            '[attr.aria-controls]': 'id',
                            role: 'tab',
                            '[class.clr-nav-link]': 'true',
                            '[class.nav-item]': 'true',
                            '[class.active]': 'isCurrent',
                            '[class.disabled]': 'isDisabled',
                            '[class.no-click]': '!canNavigate',
                            '[class.complete]': 'isComplete',
                        }
                    }] }
        ];
        /** @nocollapse */
        ClrWizardStepnavItem.ctorParameters = function () {
            return [
                { type: WizardNavigationService },
                { type: PageCollectionService }
            ];
        };
        ClrWizardStepnavItem.propDecorators = {
            page: [{ type: i0.Input, args: ['page',] }]
        };
        return ClrWizardStepnavItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_WIZARD_DIRECTIVES = [
        ClrWizard,
        ClrWizardPage,
        ClrWizardStepnav,
        ClrWizardStepnavItem,
        ClrWizardButton,
        ClrWizardHeaderAction,
        ClrWizardCustomTags,
        ClrWizardPageTitle,
        ClrWizardPageNavTitle,
        ClrWizardPageButtons,
        ClrWizardPageHeaderActions,
    ];
    var ClrWizardModule = /** @class */ (function () {
        function ClrWizardModule() {
        }
        ClrWizardModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule, ClrModalModule, ClrAlertModule],
                        declarations: [CLR_WIZARD_DIRECTIVES],
                        exports: [CLR_WIZARD_DIRECTIVES],
                    },] }
        ];
        return ClrWizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClarityModule = /** @class */ (function () {
        function ClarityModule() {
        }
        ClarityModule.decorators = [
            { type: i0.NgModule, args: [{
                        exports: [
                            ClrEmphasisModule,
                            ClrDataModule,
                            ClrIconModule,
                            ClrModalModule,
                            ClrLoadingModule,
                            ClrIfExpandModule,
                            ClrConditionalModule,
                            ClrFocusTrapModule,
                            ClrButtonModule,
                            ClrFormsModule,
                            ClrLayoutModule,
                            ClrPopoverModule,
                            ClrWizardModule,
                            ClrDragAndDropModule,
                        ],
                    },] }
        ];
        return ClarityModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * Private counter to generate unique IDs for the checkboxes, to bind the labels to them.
     * @type {?}
     */
    var latestId = 0;
    /**
     * @deprecated ClrCheckbox will be renamed to ClrCheckboxDeprecated in 0.12, and will be replaced with a new
     * implementation in 0.13, so if you import it you will need to update your references.
     */
    var ClrCheckboxDeprecated = /** @class */ (function () {
        function ClrCheckboxDeprecated() {
            // If our host has an ID attribute, we use this instead of our index.
            this._id = (latestId++).toString();
            // If host provides an clrAriaLabeledBy input, we apply it to the checkbox
            this.clrAriaLabeledBy = null;
            // If our host has a name attribute, we apply it to the checkbox.
            this.name = null;
            // If the host is disabled we apply it to the checkbox
            this.disabled = false;
            // Support for inline checkboxes, adds the necessary class to the host
            this.inline = false;
            this._checked = false;
            this._indeterminate = false;
            this.indeterminateChange = new i0.EventEmitter(false);
            this.change = new i0.EventEmitter(false);
            /*
                 * These callbacks will be given to us through the ControlValueAccessor interface,
                 * and we need to call them when the user interacts with the checkbox.
                 */
            this.onChangeCallback = function (_) { };
            this.onTouchedCallback = function () { };
        }
        Object.defineProperty(ClrCheckboxDeprecated.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "clr-checkbox-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCheckboxDeprecated.prototype, "checked", {
            get: /**
             * @return {?}
             */ function () {
                return this._checked;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._checked) {
                    if (this._indeterminate) {
                        this.setIndeterminate(false);
                    }
                    this.setChecked(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ClrCheckboxDeprecated.prototype, "indeterminate", {
            get: /**
             * @return {?}
             */ function () {
                return this._indeterminate;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._indeterminate !== value) {
                    if (this._checked) {
                        this.setChecked(false);
                    }
                    this.setIndeterminate(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.setIndeterminate = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._indeterminate = value;
                this.indeterminateChange.emit(this._indeterminate);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.setChecked = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this._checked = value;
                this.change.emit(this._checked);
            };
        /**
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.checked = !this.checked;
                this.onChangeCallback(this.checked);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value === null) {
                    value = false;
                }
                if (value !== this.checked) {
                    this.checked = value;
                }
            };
        /**
         * @param {?} onChange
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.registerOnChange = /**
         * @param {?} onChange
         * @return {?}
         */
            function (onChange) {
                this.onChangeCallback = onChange;
            };
        /**
         * @param {?} onTouched
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.registerOnTouched = /**
         * @param {?} onTouched
         * @return {?}
         */
            function (onTouched) {
                this.onTouchedCallback = onTouched;
            };
        /**
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.touch = /**
         * @return {?}
         */
            function () {
                this.onTouchedCallback();
            };
        /**
         * @return {?}
         */
        ClrCheckboxDeprecated.prototype.checkIndeterminateState = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.toggle();
                }
            };
        ClrCheckboxDeprecated.decorators = [
            { type: i0.Component, args: [{
                        selector: 'clr-checkbox',
                        template: "\n        <!--\n            FIXME: We are not subscribed to the change event but the click event here.\n            The reason for that is because checkboxes behave differently on IE & Edge.\n            https://stackoverflow.com/a/19447939\n            \n            To fix that, we listen to every click event and then toggle the checkbox manually\n            to make it behave the same way across the browsers we support.\n            \n            This works for cases when users toggle the checkbox using the keyboard too:\n            https://stackoverflow.com/questions/27878940/spacebar-triggering-click-event-on-checkbox\n        -->\n        <input type=\"checkbox\" [attr.aria-labelledby]=\"clrAriaLabeledBy\"\n               [id]=\"id\" [name]=\"name\" [checked]=\"checked\"\n               [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n               (blur)=\"touch()\" (click)=\"checkIndeterminateState()\">\n        <label [attr.for]=\"id\">\n            <ng-content></ng-content>\n        </label>\n    ",
                        host: { '[class.checkbox]': '!inline', '[class.checkbox-inline]': 'inline', '[class.disabled]': 'disabled' },
                        /*
                             * This provider lets us declare our checkbox as a ControlValueAccessor,
                             * which allows us to use [(ngModel)] directly on our component,
                             * with all the automatic features wiring that come with it.
                             */
                        providers: [{ provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return ClrCheckboxDeprecated; }), multi: true }]
                    }] }
        ];
        ClrCheckboxDeprecated.propDecorators = {
            _id: [{ type: i0.Input, args: ['id',] }],
            clrAriaLabeledBy: [{ type: i0.Input, args: ['clrAriaLabeledBy',] }],
            name: [{ type: i0.Input, args: ['name',] }],
            disabled: [{ type: i0.Input, args: ['clrDisabled',] }],
            inline: [{ type: i0.Input, args: ['clrInline',] }],
            checked: [{ type: i0.Input, args: ['clrChecked',] }],
            indeterminate: [{ type: i0.Input, args: ['clrIndeterminate',] }],
            indeterminateChange: [{ type: i0.Output, args: ['clrIndeterminateChange',] }],
            change: [{ type: i0.Output, args: ['clrCheckedChange',] }]
        };
        return ClrCheckboxDeprecated;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CLR_CHECKBOX_DIRECTIVES = [ClrCheckboxDeprecated];
    var ClrCheckboxDeprecatedModule = /** @class */ (function () {
        function ClrCheckboxDeprecatedModule() {
        }
        ClrCheckboxDeprecatedModule.decorators = [
            { type: i0.NgModule, args: [{ imports: [common.CommonModule], declarations: [CLR_CHECKBOX_DIRECTIVES], exports: [CLR_CHECKBOX_DIRECTIVES] },] }
        ];
        return ClrCheckboxDeprecatedModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ClrFormsDeprecatedModule = /** @class */ (function () {
        function ClrFormsDeprecatedModule() {
        }
        ClrFormsDeprecatedModule.decorators = [
            { type: i0.NgModule, args: [{
                        imports: [common.CommonModule],
                        exports: [ClrCheckboxDeprecatedModule, ClrDatepickerModule],
                    },] }
        ];
        return ClrFormsDeprecatedModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function collapse() {
        return [
            animations.state('true', animations.style({ height: 0, 'overflow-y': 'hidden' })),
            animations.transition('true => false', [animations.animate('0.2s ease-in-out', animations.style({ height: '*', 'overflow-y': 'hidden' }))]),
            animations.transition('false => true', [animations.style({ height: '*', 'overflow-y': 'hidden' }), animations.animate('0.2s ease-in-out')]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?=} opacity
     * @return {?}
     */
    function fade(opacity) {
        if (opacity === void 0) {
            opacity = 1;
        }
        return [
            animations.transition('void => *', [animations.style({ opacity: 0 }), animations.animate('0.2s ease-in-out', animations.style({ opacity: opacity }))]),
            animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0 }))]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} direction
     * @return {?}
     */
    function fadeSlide(direction) {
        /** @type {?} */
        var transform = null;
        if (direction === 'up') {
            transform = 'translate(0, 25%)';
        }
        else if (direction === 'down') {
            transform = 'translate(0, -25%)';
        }
        else if (direction === 'left') {
            transform = 'translate(25%, 0)';
        }
        else if (direction === 'right') {
            transform = 'translate(-25%, 0)';
        }
        else {
            throw new Error('Unknown direction ' + direction + ' for slide animation.');
        }
        return [
            animations.transition('void => *', [animations.style({ opacity: 0, transform: transform }), animations.animate('0.2s ease-in-out')]),
            animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ opacity: 0, transform: transform }))]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @param {?} direction
     * @return {?}
     */
    function slide(direction) {
        /** @type {?} */
        var transform = null;
        if (direction === 'up') {
            transform = 'translate(0, 25%)';
        }
        else if (direction === 'down') {
            transform = 'translate(0, -25%)';
        }
        else if (direction === 'left') {
            transform = 'translate(25%, 0)';
        }
        else if (direction === 'right') {
            transform = 'translate(-25%, 0)';
        }
        else {
            throw new Error('Unknown direction ' + direction + ' for slide animation.');
        }
        return [
            animations.transition('void => *', [animations.style({ transform: transform }), animations.animate('0.2s ease-in-out')]),
            animations.transition('* => void', [animations.animate('0.2s ease-in-out', animations.style({ transform: transform }))]),
        ];
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.ÇlrFocusTrapTracker = FocusTrapTracker;
    exports.ClarityModule = ClarityModule;
    exports.ClrButtonModule = ClrButtonModule;
    exports.ClrButton = ClrButton;
    exports.ClrButtonGroup = ClrButtonGroup;
    exports.CLR_BUTTON_GROUP_DIRECTIVES = CLR_BUTTON_GROUP_DIRECTIVES;
    exports.ClrButtonGroupModule = ClrButtonGroupModule;
    exports.ClrLoadingButton = ClrLoadingButton;
    exports.CLR_LOADING_BUTTON_DIRECTIVES = CLR_LOADING_BUTTON_DIRECTIVES;
    exports.ClrLoadingButtonModule = ClrLoadingButtonModule;
    exports.ClrDataModule = ClrDataModule;
    exports.ClrDatagrid = ClrDatagrid;
    exports.ClrDatagridActionBar = ClrDatagridActionBar;
    exports.ClrDatagridActionOverflow = ClrDatagridActionOverflow;
    exports.ClrDatagridColumn = ClrDatagridColumn;
    exports.ClrDatagridColumnToggle = ClrDatagridColumnToggle;
    exports.ClrDatagridHideableColumn = ClrDatagridHideableColumn;
    exports.ClrDatagridFilter = ClrDatagridFilter;
    exports.ClrDatagridItems = ClrDatagridItems;
    exports.ClrDatagridRow = ClrDatagridRow;
    exports.ClrDatagridRowDetail = ClrDatagridRowDetail;
    exports.ClrDatagridCell = ClrDatagridCell;
    exports.ClrDatagridFooter = ClrDatagridFooter;
    exports.ClrDatagridPagination = ClrDatagridPagination;
    exports.ClrDatagridPlaceholder = ClrDatagridPlaceholder;
    exports.ClrDatagridSortOrder = ClrDatagridSortOrder;
    exports.DatagridStringFilter = DatagridStringFilter;
    exports.DatagridPropertyStringFilter = DatagridPropertyStringFilter;
    exports.DatagridPropertyComparator = DatagridPropertyComparator;
    exports.CLR_DATAGRID_DIRECTIVES = CLR_DATAGRID_DIRECTIVES;
    exports.ClrDatagridModule = ClrDatagridModule;
    exports.ClrTreeNode = ClrTreeNode;
    exports.CLR_TREE_VIEW_DIRECTIVES = CLR_TREE_VIEW_DIRECTIVES;
    exports.ClrTreeViewModule = ClrTreeViewModule;
    exports.ClrStackView = ClrStackView;
    exports.ClrStackHeader = ClrStackHeader;
    exports.ClrStackBlock = ClrStackBlock;
    exports.ClrStackInput = ClrStackInput;
    exports.ClrStackSelect = ClrStackSelect;
    exports.CLR_STACK_VIEW_DIRECTIVES = CLR_STACK_VIEW_DIRECTIVES;
    exports.ClrStackViewModule = ClrStackViewModule;
    exports.ClrStackViewCustomTags = ClrStackViewCustomTags;
    exports.ClrEmphasisModule = ClrEmphasisModule;
    exports.ClrAlert = ClrAlert;
    exports.ClrAlertItem = ClrAlertItem;
    exports.ClrAlerts = ClrAlerts;
    exports.ClrAlertsPager = ClrAlertsPager;
    exports.CLR_ALERT_DIRECTIVES = CLR_ALERT_DIRECTIVES;
    exports.ClrAlertModule = ClrAlertModule;
    exports.ClrIfError = ClrIfError;
    exports.ClrControlError = ClrControlError;
    exports.ClrForm = ClrForm;
    exports.ClrControlHelper = ClrControlHelper;
    exports.ClrLabel = ClrLabel;
    exports.ClrLayout = ClrLayout;
    exports.ClrCommonFormsModule = ClrCommonFormsModule;
    exports.ClrCheckbox = ClrCheckbox;
    exports.ClrCheckboxContainer = ClrCheckboxContainer;
    exports.ClrCheckboxWrapper = ClrCheckboxWrapper;
    exports.ClrCheckboxModule = ClrCheckboxModule;
    exports.ClrDateContainer = ClrDateContainer;
    exports.ClrDateInput = ClrDateInput;
    exports.ClrDatepickerViewManager = ClrDatepickerViewManager;
    exports.ClrDaypicker = ClrDaypicker;
    exports.ClrMonthpicker = ClrMonthpicker;
    exports.ClrYearpicker = ClrYearpicker;
    exports.ClrCalendar = ClrCalendar;
    exports.ClrDay = ClrDay;
    exports.CLR_DATEPICKER_DIRECTIVES = CLR_DATEPICKER_DIRECTIVES;
    exports.ClrDatepickerModule = ClrDatepickerModule;
    exports.ClrInput = ClrInput;
    exports.ClrInputContainer = ClrInputContainer;
    exports.ClrInputModule = ClrInputModule;
    exports.ClrPassword = ClrPassword;
    exports.ToggleServiceProvider = ToggleServiceProvider;
    exports.ToggleService = ToggleService;
    exports.ClrPasswordContainer = ClrPasswordContainer;
    exports.ClrPasswordModule = ClrPasswordModule;
    exports.ClrRadio = ClrRadio;
    exports.ClrRadioContainer = ClrRadioContainer;
    exports.ClrRadioWrapper = ClrRadioWrapper;
    exports.ClrRadioModule = ClrRadioModule;
    exports.ClrSelect = ClrSelect;
    exports.ClrSelectContainer = ClrSelectContainer;
    exports.ClrSelectModule = ClrSelectModule;
    exports.ClrTextarea = ClrTextarea;
    exports.ClrTextareaContainer = ClrTextareaContainer;
    exports.ClrTextareaModule = ClrTextareaModule;
    exports.ClrFormsModule = ClrFormsModule;
    exports.ClrCheckboxDeprecated = ClrCheckboxDeprecated;
    exports.CLR_CHECKBOX_DIRECTIVES = CLR_CHECKBOX_DIRECTIVES;
    exports.ClrCheckboxDeprecatedModule = ClrCheckboxDeprecatedModule;
    exports.ClrFormsDeprecatedModule = ClrFormsDeprecatedModule;
    exports.ClrIconCustomTag = ClrIconCustomTag;
    exports.CLR_ICON_DIRECTIVES = CLR_ICON_DIRECTIVES;
    exports.ClrIconModule = ClrIconModule;
    exports.ClrLayoutModule = ClrLayoutModule;
    exports.ClrMainContainer = ClrMainContainer;
    exports.CLR_LAYOUT_DIRECTIVES = CLR_LAYOUT_DIRECTIVES;
    exports.ClrMainContainerModule = ClrMainContainerModule;
    exports.MainContainerWillyWonka = MainContainerWillyWonka;
    exports.NavDetectionOompaLoompa = NavDetectionOompaLoompa;
    exports.ClrHeader = ClrHeader;
    exports.ClrNavLevel = ClrNavLevel;
    exports.CLR_NAVIGATION_DIRECTIVES = CLR_NAVIGATION_DIRECTIVES;
    exports.ClrNavigationModule = ClrNavigationModule;
    exports.ClrTabs = ClrTabs;
    exports.ClrTab = ClrTab;
    exports.ClrTabContent = ClrTabContent;
    exports.ClrTabOverflowContent = ClrTabOverflowContent;
    exports.ClrTabLink = ClrTabLink;
    exports.CLR_TABS_DIRECTIVES = CLR_TABS_DIRECTIVES;
    exports.ClrTabsModule = ClrTabsModule;
    exports.ClrVerticalNavGroupChildren = ClrVerticalNavGroupChildren;
    exports.ClrVerticalNavGroup = ClrVerticalNavGroup;
    exports.ClrVerticalNav = ClrVerticalNav;
    exports.ClrVerticalNavLink = ClrVerticalNavLink;
    exports.ClrVerticalNavIcon = ClrVerticalNavIcon;
    exports.CLR_VERTICAL_NAV_DIRECTIVES = CLR_VERTICAL_NAV_DIRECTIVES;
    exports.ClrVerticalNavModule = ClrVerticalNavModule;
    exports.ClrModal = ClrModal;
    exports.CLR_MODAL_DIRECTIVES = CLR_MODAL_DIRECTIVES;
    exports.ClrModalModule = ClrModalModule;
    exports.ClrDropdown = ClrDropdown;
    exports.ClrDropdownMenu = ClrDropdownMenu;
    exports.ClrDropdownTrigger = ClrDropdownTrigger;
    exports.ClrDropdownItem = ClrDropdownItem;
    exports.CLR_MENU_POSITIONS = CLR_MENU_POSITIONS;
    exports.CLR_DROPDOWN_DIRECTIVES = CLR_DROPDOWN_DIRECTIVES;
    exports.ClrDropdownModule = ClrDropdownModule;
    exports.ClrPopoverModule = ClrPopoverModule;
    exports.ClrSignpost = ClrSignpost;
    exports.ClrSignpostContent = ClrSignpostContent;
    exports.ClrSignpostTrigger = ClrSignpostTrigger;
    exports.CLR_SIGNPOST_DIRECTIVES = CLR_SIGNPOST_DIRECTIVES;
    exports.ClrSignpostModule = ClrSignpostModule;
    exports.ClrTooltip = ClrTooltip;
    exports.ClrTooltipTrigger = ClrTooltipTrigger;
    exports.ClrTooltipContent = ClrTooltipContent;
    exports.CLR_TOOLTIP_DIRECTIVES = CLR_TOOLTIP_DIRECTIVES;
    exports.ClrTooltipModule = ClrTooltipModule;
    exports.collapse = collapse;
    exports.fade = fade;
    exports.fadeSlide = fadeSlide;
    exports.slide = slide;
    exports.ClrLoadingState = ClrLoadingState;
    exports.ClrLoading = ClrLoading;
    exports.LoadingListener = LoadingListener;
    exports.CLR_LOADING_DIRECTIVES = CLR_LOADING_DIRECTIVES;
    exports.ClrLoadingModule = ClrLoadingModule;
    exports.CONDITIONAL_DIRECTIVES = CONDITIONAL_DIRECTIVES;
    exports.ClrIfActive = ClrIfActive;
    exports.ClrIfOpen = ClrIfOpen;
    exports.EXPAND_DIRECTIVES = EXPAND_DIRECTIVES;
    exports.ClrIfExpanded = ClrIfExpanded;
    exports.ClrCommonStrings = ClrCommonStrings;
    exports.ClrDraggable = ClrDraggable;
    exports.ClrDroppable = ClrDroppable;
    exports.ClrIfDragged = ClrIfDragged;
    exports.ClrDragHandle = ClrDragHandle;
    exports.ClrDraggableGhost = ClrDraggableGhost;
    exports.ClrDragEvent = ClrDragEvent;
    exports.CLR_DRAG_AND_DROP_DIRECTIVES = CLR_DRAG_AND_DROP_DIRECTIVES;
    exports.ClrDragAndDropModule = ClrDragAndDropModule;
    exports.ClrWizard = ClrWizard;
    exports.ClrWizardPage = ClrWizardPage;
    exports.ClrWizardStepnav = ClrWizardStepnav;
    exports.ClrWizardStepnavItem = ClrWizardStepnavItem;
    exports.DEFAULT_BUTTON_TYPES = DEFAULT_BUTTON_TYPES;
    exports.CUSTOM_BUTTON_TYPES = CUSTOM_BUTTON_TYPES;
    exports.ClrWizardButton = ClrWizardButton;
    exports.ClrWizardHeaderAction = ClrWizardHeaderAction;
    exports.ClrWizardCustomTags = ClrWizardCustomTags;
    exports.ClrWizardPageTitle = ClrWizardPageTitle;
    exports.ClrWizardPageNavTitle = ClrWizardPageNavTitle;
    exports.ClrWizardPageButtons = ClrWizardPageButtons;
    exports.ClrWizardPageHeaderActions = ClrWizardPageHeaderActions;
    exports.CLR_WIZARD_DIRECTIVES = CLR_WIZARD_DIRECTIVES;
    exports.ClrWizardModule = ClrWizardModule;
    exports.ɵdk = ButtonInGroupService;
    exports.ɵda = DatagridRowExpandAnimation;
    exports.ɵcx = ActionableOompaLoompa;
    exports.ɵcv = DatagridWillyWonka;
    exports.ɵcz = ExpandableOompaLoompa;
    exports.ɵch = ClrDatagridColumnToggleButton;
    exports.ɵcg = ClrDatagridColumnToggleTitle;
    exports.ɵcj = DatagridDetailRegisterer;
    exports.ɵci = ClrDatagridItemsTrackBy;
    exports.ɵck = ClrDatagridPageSize;
    exports.ɵbz = ColumnToggleButtonsService;
    exports.ɵce = CustomFilter;
    exports.ɵcb = DisplayModeService;
    exports.ɵcd = DragDispatcher;
    exports.ɵbq = FiltersProvider;
    exports.ɵbw = ExpandableRowsCount;
    exports.ɵbx = HideableColumnService;
    exports.ɵbp = Items;
    exports.ɵbr = Page;
    exports.ɵbv = RowActionService;
    exports.ɵbo = Selection;
    exports.ɵbt = Sort;
    exports.ɵbs = StateDebouncer;
    exports.ɵby = StateProvider;
    exports.ɵca = TableSizeService;
    exports.ɵcu = DatagridCellRenderer;
    exports.ɵcs = DatagridColumnResizer;
    exports.ɵcr = DatagridHeaderRenderer;
    exports.ɵcp = DatagridMainRenderer;
    exports.ɵco = domAdapterFactory;
    exports.ɵbu = DatagridRenderOrganizer;
    exports.ɵct = DatagridRowRenderer;
    exports.ɵcc = DatagridFilterRegistrar;
    exports.ɵcl = WrappedCell;
    exports.ɵcm = WrappedColumn;
    exports.ɵcn = WrappedRow;
    exports.ɵdc = StackControl;
    exports.ɵdd = AbstractTreeSelection;
    exports.ɵdf = clrTreeSelectionProviderFactory;
    exports.ɵde = TreeSelectionService;
    exports.ɵo = AlertIconAndTypesService;
    exports.ɵp = MultiAlertService;
    exports.ɵt = IfErrorService;
    exports.ɵz = ControlClassService;
    exports.ɵq = ControlIdService;
    exports.ɵbg = FocusService;
    exports.ɵr = LayoutService;
    exports.ɵu = IS_NEW_FORMS_LAYOUT;
    exports.ɵv = IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER;
    exports.ɵs = NgControlService;
    exports.ɵy = WrappedFormControl;
    exports.ɵbe = DateFormControlService;
    exports.ɵbh = DateIOService;
    exports.ɵbd = DateNavigationService;
    exports.ɵbi = DatepickerEnabledService;
    exports.ɵbk = DatepickerFocusService;
    exports.ɵbf = LocaleHelperService;
    exports.ɵbj = ViewManagerService;
    exports.ɵdl = ResponsiveNavigationService;
    exports.ɵdv = ActiveOompaLoompa;
    exports.ɵdu = TabsWillyWonka;
    exports.ɵdp = AriaService;
    exports.ɵdt = TabsService;
    exports.ɵdq = TABS_ID;
    exports.ɵds = TABS_ID_PROVIDER;
    exports.ɵdr = tokenFactory$1;
    exports.ɵdy = VerticalNavGroupRegistrationService;
    exports.ɵdz = VerticalNavGroupService;
    exports.ɵdx = VerticalNavIconService;
    exports.ɵdw = VerticalNavService;
    exports.ɵi = AbstractPopover;
    exports.ɵb = POPOVER_DIRECTIVES;
    exports.ɵh = POPOVER_HOST_ANCHOR;
    exports.ɵc = PopoverDirectiveOld;
    exports.ɵa = ClrCommonPopoverModule;
    exports.ɵg = ROOT_DROPDOWN_PROVIDER;
    exports.ɵe = RootDropdownService;
    exports.ɵf = clrRootDropdownFactory;
    exports.ɵcy = OompaLoompa;
    exports.ɵcw = WillyWonka;
    exports.ɵj = ClrConditionalModule;
    exports.ɵk = IF_ACTIVE_ID;
    exports.ɵm = IF_ACTIVE_ID_PROVIDER;
    exports.ɵn = IfActiveService;
    exports.ɵl = tokenFactory;
    exports.ɵd = IfOpenService;
    exports.ɵcq = DomAdapter;
    exports.ɵef = DragAndDropEventBusService;
    exports.ɵee = DragEventListenerService;
    exports.ɵeg = DragHandleRegistrarService;
    exports.ɵeh = DraggableSnapshotService;
    exports.ɵei = GlobalDragModeService;
    exports.ɵdb = ClrIfExpandModule;
    exports.ɵcf = Expand;
    exports.ɵbc = FocusTrapDirective;
    exports.ɵba = ClrFocusTrapModule;
    exports.ɵbb = FOCUS_TRAP_DIRECTIVES;
    exports.ɵx = EmptyAnchor;
    exports.ɵw = ClrHostWrappingModule;
    exports.ɵdg = UNIQUE_ID;
    exports.ɵdi = UNIQUE_ID_PROVIDER;
    exports.ɵdh = uniqueIdFactory;
    exports.ɵbm = OUSTIDE_CLICK_DIRECTIVES;
    exports.ɵbn = OutsideClick;
    exports.ɵbl = ClrOutsideClickModule;
    exports.ɵdj = ScrollingService;
    exports.ɵdn = TEMPLATE_REF_DIRECTIVES;
    exports.ɵdo = TemplateRefContainer;
    exports.ɵdm = ClrTemplateRefModule;
    exports.ɵec = ButtonHubService;
    exports.ɵed = HeaderActionService;
    exports.ɵeb = PageCollectionService;
    exports.ɵea = WizardNavigationService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xyLWFuZ3VsYXIudW1kLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AY2xyL2FuZ3VsYXIvaWNvbi9pY29uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvaWNvbi9pY29uLm1vZHVsZS50cyIsIm5vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vcG9wb3Zlci1vbGQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2xvYWRpbmcvbG9hZGluZy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9wcm92aWRlcnMvYnV0dG9uLWluLWdyb3VwLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLWdyb3VwL2J1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vbWVudS1wb3NpdGlvbnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvYnV0dG9uL2J1dHRvbi1ncm91cC9idXR0b24tZ3JvdXAubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvYnV0dG9uL2J1dHRvbi1sb2FkaW5nL2xvYWRpbmctYnV0dG9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvYnV0dG9uL2J1dHRvbi1sb2FkaW5nL2xvYWRpbmctYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaG9zdC13cmFwcGluZy9lbXB0eS1hbmNob3IudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBpbmcubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2Vycm9yLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2hlbHBlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3IudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vbGFiZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL25ldy1mb3Jtcy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2Zvcm0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vbGF5b3V0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2NvbW1vbi5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jaGVja2JveC9jaGVja2JveC13cmFwcGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jaGVja2JveC9jaGVja2JveC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAtdHJhY2tlci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZm9jdXMtdHJhcC9mb2N1cy10cmFwLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzLXRyYXAvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMva2V5LWNvZGVzL2tleS1jb2Rlcy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvdXRpbHMvY29uc3RhbnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci91dGlscy9kYXRlLXV0aWxzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC9kYXktdmlldy5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvbW9kZWwvY2FsZW5kYXIubW9kZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL21vZGVsL2RheS5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvbW9kZWwvY2FsZW5kYXItdmlldy5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZXBpY2tlci1mb2N1cy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvbG9jYWxlLWhlbHBlci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9jYWxlbmRhci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvZm9jdXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL2RhdGUtZm9ybS1jb250cm9sLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy9kYXRlLWlvLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9icmVha3BvaW50cy9icmVha3BvaW50cy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL2RhdGVwaWNrZXItZW5hYmxlZC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlLWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvZGF0ZS1pbnB1dC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvY29tbW9uL2Fic3RyYWN0LXBvcG92ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy92aWV3LW1hbmFnZXIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci12aWV3LW1hbmFnZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL2RheS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvZGF5cGlja2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb250aHBpY2tlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvbW9kZWwveWVhci1yYW5nZS5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIveWVhcnBpY2tlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9pbnB1dC9pbnB1dC1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9pbnB1dC9pbnB1dC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2lucHV0L2lucHV0Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3Bhc3N3b3JkL3Bhc3N3b3JkLWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3Bhc3N3b3JkL3Bhc3N3b3JkLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcGFzc3dvcmQvcGFzc3dvcmQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcmFkaW8vcmFkaW8td3JhcHBlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3JhZGlvL3JhZGlvLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcmFkaW8vcmFkaW8tY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcmFkaW8vcmFkaW8ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvc2VsZWN0L3NlbGVjdC1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9zZWxlY3Qvc2VsZWN0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvc2VsZWN0L3NlbGVjdC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy90ZXh0YXJlYS90ZXh0YXJlYS1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy90ZXh0YXJlYS90ZXh0YXJlYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3RleHRhcmVhL3RleHRhcmVhLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2Zvcm1zLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZXhwYW5kL2lmLWV4cGFuZGVkLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZXhwYW5kL2luZGV4LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9sb2FkaW5nL2xvYWRpbmcubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvb3V0c2lkZS1jbGljay9vdXRzaWRlLWNsaWNrLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvb3V0c2lkZS1jbGljay9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL291dHNpZGUtY2xpY2svb3V0c2lkZS1jbGljay5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kb20tYWRhcHRlci9kb20tYWRhcHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYW5pbWF0aW9uLWhhY2svcm93LWV4cGFuZC1hbmltYXRpb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9jdXN0b20tZmlsdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvc3RhdGUtZGVib3VuY2VyLnByb3ZpZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvcGFnZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2ZpbHRlcnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3V0aWxzL2RhdGFncmlkLWZpbHRlci1yZWdpc3RyYXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWZpbHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLWltcGwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtc3RyaW5nLWZpbHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2Nob2NvbGF0ZS9vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jaG9jb2xhdGUvd2lsbHktd29ua2EudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2Nob2NvbGF0ZS9kYXRhZ3JpZC13aWxseS13b25rYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvY2hvY29sYXRlL2FjdGlvbmFibGUtb29tcGEtbG9vbXBhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZ2xvYmFsLWV4cGFuZGFibGUtcm93cy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvY2hvY29sYXRlL2V4cGFuZGFibGUtb29tcGEtbG9vbXBhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9idWlsdC1pbi9uZXN0ZWQtcHJvcGVydHkudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL2NvbXBhcmF0b3JzL2RhdGFncmlkLXByb3BlcnR5LWNvbXBhcmF0b3IudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtcHJvcGVydHktc3RyaW5nLWZpbHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZW51bXMvc29ydC1vcmRlci5lbnVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZHJhZy1kaXNwYXRjaGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvc29ydC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvd3JhcHBlZC1jb2x1bW4udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNvbHVtbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2l0ZW1zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1pdGVtcy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtcGxhY2Vob2xkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9zaWducG9zdC9zaWducG9zdC10cmlnZ2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9zaWducG9zdC9zaWducG9zdC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC93cmFwcGVkLWNlbGwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNlbGwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2VudW1zL2Rpc3BsYXktbW9kZS5lbnVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9lbnVtcy9yZW5kZXItc3RlcC5lbnVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvcmVuZGVyLW9yZ2FuaXplci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2Rpc3BsYXktbW9kZS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvc2VsZWN0aW9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC93cmFwcGVkLXJvdy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtcm93LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvY29sdW1uLXRvZ2dsZS1idXR0b25zLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zdGF0ZS5wcm92aWRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3RhYmxlLXNpemUuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWFjdGlvbi1iYXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWFjdGlvbi1vdmVyZmxvdy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS1idXR0b24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtdGl0bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNvbHVtbi10b2dnbGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWRldGFpbC1yZWdpc3RlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1mb290ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1pdGVtcy10cmFja2J5LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1wYWdlLXNpemUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLXBhZ2luYXRpb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLXJvdy1kZXRhaWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9jb25zdGFudHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9jZWxsLXJlbmRlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvY29sdW1uLXJlc2l6ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9oZWFkZXItcmVuZGVyZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9ub29wLWRvbS1hZGFwdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvbWFpbi1yZW5kZXJlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL3Jvdy1yZW5kZXJlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLWJsb2NrLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLXZpZXcudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2staGVhZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLWNvbnRyb2wudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2staW5wdXQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stc2VsZWN0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9zdGFjay12aWV3L3N0YWNrLXZpZXctY3VzdG9tLXRhZ3MudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stdmlldy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy9hYnN0cmFjdC10cmVlLXNlbGVjdGlvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L3Byb3ZpZGVycy90cmVlLXNlbGVjdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvcHJvdmlkZXJzL3RyZWUtc2VsZWN0aW9uLnByb3ZpZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvdHJlZS1ub2RlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvdHJlZS12aWV3Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YS5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWctZXZlbnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL3Byb3ZpZGVycy9kcmFnLWFuZC1kcm9wLWV2ZW50LWJ1cy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9wcm92aWRlcnMvZHJhZy1ldmVudC1saXN0ZW5lci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9wcm92aWRlcnMvZHJhZ2dhYmxlLXNuYXBzaG90LnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWdnYWJsZS1naG9zdC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvaWYtZHJhZ2dlZC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2RyYWctaGFuZGxlLXJlZ2lzdHJhci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9wcm92aWRlcnMvZ2xvYmFsLWRyYWctbW9kZS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnZ2FibGUvZHJhZ2dhYmxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcm9wcGFibGUvZHJvcHBhYmxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnLWhhbmRsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1hbmQtZHJvcC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2Ryb3Bkb3duL3Byb3ZpZGVycy9kcm9wZG93bi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24taXRlbS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24tbWVudS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24tdHJpZ2dlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvdXRpbHMvYWxlcnQtdHlwZXMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9wcm92aWRlcnMvaWNvbi1hbmQtdHlwZXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2VtcGhhc2lzL2FsZXJ0L3Byb3ZpZGVycy9tdWx0aS1hbGVydC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9hbGVydC1pdGVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnRzLXBhZ2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvZW1waGFzaXMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9yZXNwb25zaXZlLW5hdi1jb2Rlcy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvcmVzcG9uc2l2ZS1uYXYtY29udHJvbC1tZXNzYWdlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9wcm92aWRlcnMvcmVzcG9uc2l2ZS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbWFpbi1jb250YWluZXIvbWFpbi1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbWFpbi1jb250YWluZXIvbWFpbi1jb250YWluZXIubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9jaG9jb2xhdGUvbWFpbi1jb250YWluZXItd2lsbHktd29ua2EudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L2Nob2NvbGF0ZS9uYXYtZGV0ZWN0aW9uLW9vbXBhLWxvb21wYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvaGVhZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9uYXYtbGV2ZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L25hdmlnYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy90ZW1wbGF0ZS1yZWYvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy90ZW1wbGF0ZS1yZWYvdGVtcGxhdGUtcmVmLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL2Nob2NvbGF0ZS90YWJzLXdpbGx5LXdvbmthLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvY2hvY29sYXRlL2FjdGl2ZS1vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy9wcm92aWRlcnMvYXJpYS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvcHJvdmlkZXJzL3RhYnMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi1jb250ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFicy1pZC5wcm92aWRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi1saW5rLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYi1vdmVyZmxvdy1jb250ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFicy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYnMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLXJlZ2lzdHJhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWljb24uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtZ3JvdXAuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2LWdyb3VwLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYtZ3JvdXAtY2hpbGRyZW4udHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi1pY29uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYtbGluay50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9sYXlvdXQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvc2Nyb2xsaW5nL3Njcm9sbGluZy1zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbW9kYWwvbW9kYWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9tb2RhbC9tb2RhbC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LXBvc2l0aW9ucy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvc2lnbnBvc3Qvc2lnbnBvc3QtY29udGVudC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvc2lnbnBvc3Qvc2lnbnBvc3QubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci90b29sdGlwL3Rvb2x0aXAudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3Rvb2x0aXAvdG9vbHRpcC1jb250ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci90b29sdGlwL3Rvb2x0aXAtdHJpZ2dlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvdG9vbHRpcC90b29sdGlwLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvcG9wb3Zlci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvcHJvdmlkZXJzL2J1dHRvbi1odWIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC9wcm92aWRlcnMvcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvcHJvdmlkZXJzL2hlYWRlci1hY3Rpb25zLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLWhlYWRlci1hY3Rpb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXBhZ2UtYnV0dG9ucy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS1oZWFkZXItYWN0aW9ucy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS1uYXZ0aXRsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS10aXRsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLWJ1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtY3VzdG9tLXRhZ3MudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXN0ZXBuYXYudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXN0ZXBuYXYtaXRlbS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvY2xyLWFuZ3VsYXIubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMtZGVwcmVjYXRlZC9jaGVja2JveC9jaGVja2JveC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zLWRlcHJlY2F0ZWQvY2hlY2tib3gvY2hlY2tib3gubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMtZGVwcmVjYXRlZC9mb3Jtcy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9hbmltYXRpb25zL2NvbGxhcHNlL2NvbGxhcHNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvYW5pbWF0aW9ucy9mYWRlL2ZhZGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9hbmltYXRpb25zL2ZhZGUtc2xpZGUvZmFkZS1zbGlkZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2FuaW1hdGlvbnMvc2xpZGUvc2xpZGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1pY29uJyB9KVxuZXhwb3J0IGNsYXNzIENsckljb25DdXN0b21UYWcge1xuICAvLyBObyBiZWhhdmlvclxuICAvLyBUaGUgb25seSBwdXJwb3NlIGlzIHRvIFwiZGVjbGFyZVwiIHRoZSB0YWcgaW4gQW5ndWxhclxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckljb25DdXN0b21UYWcgfSBmcm9tICcuL2ljb24nO1xuXG5leHBvcnQgY29uc3QgQ0xSX0lDT05fRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xySWNvbkN1c3RvbVRhZ107XG5cbkBOZ01vZHVsZSh7IGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBkZWNsYXJhdGlvbnM6IFtDTFJfSUNPTl9ESVJFQ1RJVkVTXSwgZXhwb3J0czogW0NMUl9JQ09OX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xySWNvbk1vZHVsZSB7fVxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChvW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9OyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLypcbiAqIERvIE5PVCBBbmd1bGFyIHRoaXMgdXAuIEl0IGFzc3VtZXMgd2UncmUgaW4gdGhlIERPTSwgcGxheXMgd2l0aCBuYXRpdmUgZWxlbWVudHMsIC4uLlxuICogSXQgY291bGQgcG90ZW50aWFsbHkgYmUgdXNlZCBhcyBwYXJ0IG9mIEBjbHIvdWkgYXMgYSB2YW5pbGxhIEphdmFzY3JpcHQgaGVscGVyLlxuICovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFBvcG92ZXJPcHRpb25zIH0gZnJvbSAnLi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcbmV4cG9ydCBlbnVtIFBvaW50IHtcbiAgUklHSFRfQ0VOVEVSLFxuICBSSUdIVF9UT1AsXG4gIFJJR0hUX0JPVFRPTSxcbiAgVE9QX0NFTlRFUixcbiAgVE9QX1JJR0hULFxuICBUT1BfTEVGVCxcbiAgQk9UVE9NX0NFTlRFUixcbiAgQk9UVE9NX1JJR0hULFxuICBCT1RUT01fTEVGVCxcbiAgTEVGVF9DRU5URVIsXG4gIExFRlRfVE9QLFxuICBMRUZUX0JPVFRPTSxcbn1cblxuY29uc3QgUE9TSVRJT05fUkVMQVRJVkUgPSAncmVsYXRpdmUnO1xuY29uc3QgUE9TSVRJT05fQUJTT0xVVEUgPSAnYWJzb2x1dGUnO1xuY29uc3QgUE9TSVRJT05fRklYRUQgPSAnZml4ZWQnO1xuXG5jb25zdCBPVkVSRkxPV19TQ1JPTEwgPSAnc2Nyb2xsJztcbmNvbnN0IE9WRVJGTE9XX0FVVE8gPSAnYXV0byc7XG5cbmV4cG9ydCBjbGFzcyBQb3BvdmVyIHtcbiAgcHJpdmF0ZSBfc2Nyb2xsOiBTdWJqZWN0PHZvaWQ+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogYW55KSB7XG4gICAgLy8gQnJvd3NlcnMgZG9uJ3QgYWdyZWUgd2l0aCB3aGF0IHRvIGRvIGlmIHNvbWUgb2YgdGhlc2UgYXJlIG5vdCBzcGVjaWZpZWQsIHNvIHdlIHNldCB0aGVtIGFsbCB0byBiZSBzYWZlLlxuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBQT1NJVElPTl9BQlNPTFVURTtcbiAgICBlbGVtZW50LnN0eWxlLnRvcCA9IDA7XG4gICAgZWxlbWVudC5zdHlsZS5ib3R0b20gPSAnYXV0byc7XG4gICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgICBlbGVtZW50LnN0eWxlLnJpZ2h0ID0gJ2F1dG8nO1xuICB9XG5cbiAgLy8gVE9ETzogbmVlZCBhIHdheSB0byBhY2NvdW50IGZvciBwYXJhbWV0ZXJzIHRoYXQgY2hhbmdlIGR5bmFtaWNhbGx5IChwb3NpdGlvbmluZykuXG4gIHB1YmxpYyBhbmNob3IoXG4gICAgYW5jaG9yOiBhbnksXG4gICAgYW5jaG9yQWxpZ246IFBvaW50LFxuICAgIHBvcG92ZXJBbGlnbjogUG9pbnQsXG4gICAgeyBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDAsIHVzZUFuY2hvclBhcmVudCA9IGZhbHNlIH06IFBvcG92ZXJPcHRpb25zID0ge31cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAvLyBUT0RPOiB3ZSBhcmUgYXNzdW1pbmcgaGVyZSB0aGF0IHRoZSBwb3BvdmVyIGlzIGluc2lkZSBvciBuZXh0IHRvIHRoZSBhbmNob3IuXG4gICAgLy8gV2UnZCBuZWVkIHRvIGdvIHVwIHRoZSBwb3BvdmVyIHRyZWUgdG9vIG90aGVyd2lzZVxuXG4gICAgdGhpcy5hZGRTY3JvbGxFdmVudExpc3RlbmVycyhhbmNob3IpO1xuICAgIGlmICh1c2VBbmNob3JQYXJlbnQpIHtcbiAgICAgIGFuY2hvciA9IGFuY2hvci5wYXJlbnROb2RlO1xuICAgIH1cbiAgICAvLyBleHBsaWNpdGx5IG92ZXJyaWRlIGFuY2hvcidzIHN0eWxlIHRvIHN0YXRpY1xuICAgIGFuY2hvci5zdHlsZS5wb3NpdGlvbiA9ICdzdGF0aWMnO1xuXG4gICAgY29uc3QgYW5jaG9yUmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwb3BvdmVyUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIC8vIHBvc2l0aW9uIG9mIGxlZnQgdG9wIGNvcm5lciBvZiBhbmNob3IgKyB0aGUgb2Zmc2V0XG4gICAgbGV0IGxlZnREaWZmOiBudW1iZXIgPSBhbmNob3JSZWN0LmxlZnQgLSBwb3BvdmVyUmVjdC5sZWZ0ICsgb2Zmc2V0WDtcbiAgICBsZXQgdG9wRGlmZjogbnVtYmVyID0gYW5jaG9yUmVjdC50b3AgLSBwb3BvdmVyUmVjdC50b3AgKyBvZmZzZXRZO1xuXG4gICAgLy8gZmlyc3QsIGFkanVzdCBwb3NpdGlvbmluZyBiYXNlZCBvbiBhbmNob3IncyBhbGlnbiBwb2ludFxuICAgIHN3aXRjaCAoYW5jaG9yQWxpZ24pIHtcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9UT1A6XG4gICAgICBjYXNlIFBvaW50LlRPUF9MRUZUOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0NFTlRFUjpcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5UT1BfUklHSFQ6XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9UT1A6XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0JPVFRPTTpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9MRUZUOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fUklHSFQ6XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9CT1RUT006XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuXG4gICAgLy8gc2Vjb25kLCBhZGp1c3QgcG9zaXRpb25pbmcgYmFzZWQgb24gcG9wb3ZlcidzIGFsaWduIHBvaW50XG4gICAgc3dpdGNoIChwb3BvdmVyQWxpZ24pIHtcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9UT1A6XG4gICAgICBjYXNlIFBvaW50LlRPUF9MRUZUOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0NFTlRFUjpcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX1JJR0hUOlxuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX1RPUDpcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0JPVFRPTTpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fTEVGVDpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX1JJR0hUOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9CT1RUT006XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0O1xuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICAvLyBUaGlyZCwgYWRqdXN0IHdpdGggcG9wb3ZlcidzIG1hcmdpbnMgYmFzZWQgb24gdGhlIHR3byBhbGlnbiBwb2ludHMuXG4gICAgLy8gSGVyZSwgd2UgbWFrZSBhbiBhc3N1bXB0aW9uIHRoYXQgcG9wb3ZlciBpcyBwcmltYXJpbHkgcG9zaXRpb25lZCBvdXRzaWRlIHRoZVxuICAgIC8vIGFuY2hvciB3aXRoIG1pbm9yIG9mZnNldC4gV2l0aG91dCB0aGlzIGFzc3VtcHRpb24sIGl0J3MgaW1wb3NzaWJsZSB0byBhcHBseVxuICAgIC8vIHRoZSBwb3BvdmVyJ3MgbWFyZ2lucyBpbiBhIHByZWRpY3RhYmxlIHdheS4gRm9yIGV4YW1wbGUsIGFzc3VtZSB0aGF0IGEgcG9wb3ZlclxuICAgIC8vIGFuZCBpdHMgYW5jaG9yIGFyZSBleGFjdGx5IHRoZSBzYW1lIHNpemUuIGlmIGEgcG9wb3ZlciBpcyBwb3NpdGlvbmVkIGluc2lkZSB0aGVcbiAgICAvLyBhbmNob3IgKHdoaWNoIGlzIHRlY2huaWNhbGx5IHBvc3NpYmxlKSwgdGhlbiBpdCBiZWNvbWVzIGltcG9zc2libGUgdG8ga25vdyB3aGF0IHRvIGRvXG4gICAgLy8gaWYgdGhlIHBvcG92ZXIgaGFzIGEgbm9uLXplcm8gbWFyZ2luIHZhbHVlIGFsbCBhcm91bmQgKGJlY2F1c2UgYXBwbHlpbmcgdGhlIG1hcmdpbiBpblxuICAgIC8vIGFsbCBmb3VyIGRpcmVjdGlvbnMgd2lsbCByZXN1bHQgaW4gbm8gbWFyZ2luIHZpc3VhbGx5LCB3aGljaCBpc24ndCB3aGF0IHdlIHdhbnQpLlxuICAgIC8vIFRoZXJlZm9yZSwgb3VyIGxvZ2ljIG1ha2VzIGFzc3VtcHRpb25zIGFib3V0IG1hcmdpbnMgb2YgaW50ZXJlc3QgZ2l2ZW4gdGhlIHBvaW50cyxcbiAgICAvLyBhbmQgb25seSBjb3ZlcnMgdGhlIGNhc2VzIHdoZXJlIHBvcG92ZXIgaXMgb3V0c2lkZSB0aGUgYW5jaG9yLlxuXG4gICAgY29uc3QgcG9wb3ZlckNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XG4gICAgY29uc3QgbWFyZ2luTGVmdCA9IHBhcnNlSW50KHBvcG92ZXJDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQsIDEwKTtcbiAgICBjb25zdCBtYXJnaW5SaWdodCA9IHBhcnNlSW50KHBvcG92ZXJDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LCAxMCk7XG4gICAgY29uc3QgbWFyZ2luVG9wID0gcGFyc2VJbnQocG9wb3ZlckNvbXB1dGVkU3R5bGUubWFyZ2luVG9wLCAxMCk7XG4gICAgY29uc3QgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQocG9wb3ZlckNvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLCAxMCk7XG5cbiAgICBzd2l0Y2ggKGFuY2hvckFsaWduKSB7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfVE9QOlxuICAgICAgY2FzZSBQb2ludC5UT1BfTEVGVDpcbiAgICAgIGNhc2UgUG9pbnQuVE9QX1JJR0hUOlxuICAgICAgY2FzZSBQb2ludC5SSUdIVF9UT1A6XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LkJPVFRPTV9SSUdIVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LlJJR0hUX0JPVFRPTSkge1xuICAgICAgICAgIHRvcERpZmYgLT0gbWFyZ2luQm90dG9tO1xuICAgICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LkJPVFRPTV9MRUZUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuTEVGVF9CT1RUT00pIHtcbiAgICAgICAgICB0b3BEaWZmIC09IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LlRPUF9MRUZUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuTEVGVF9UT1ApIHtcbiAgICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LlRPUF9SSUdIVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LlJJR0hUX1RPUCkge1xuICAgICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0JPVFRPTTpcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0xFRlQ6XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9SSUdIVDpcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfQk9UVE9NOlxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5CT1RUT01fTEVGVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LkxFRlRfQk9UVE9NKSB7XG4gICAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5CT1RUT01fUklHSFQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5SSUdIVF9CT1RUT00pIHtcbiAgICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5UT1BfTEVGVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LkxFRlRfVE9QKSB7XG4gICAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5UT1BfUklHSFQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5SSUdIVF9UT1ApIHtcbiAgICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke01hdGgucm91bmQobGVmdERpZmYpfXB4KSB0cmFuc2xhdGVZKCR7TWF0aC5yb3VuZCh0b3BEaWZmKX1weClgO1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGwuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgcmVsZWFzZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgdGhpcy5yZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1Bvc2l0aW9uZWQoY29udGFpbmVyOiBhbnkpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09IFBPU0lUSU9OX1JFTEFUSVZFIHx8IHBvc2l0aW9uID09PSBQT1NJVElPTl9BQlNPTFVURSB8fCBwb3NpdGlvbiA9PT0gUE9TSVRJT05fRklYRUQ7XG4gIH1cblxuICAvKlxuICAgICAqIENvbnRhaW5lcnMgdXAgdG8gdGhlIGZpcnN0IHBvc2l0aW9uZWQgb25lIHdpbGwgaGF2ZSBhbiBldmVudCBvbiBzY3JvbGxcbiAgICAgKi9cblxuICBwcml2YXRlIHNjcm9sbGFibGVFbGVtZW50czogSFRNTEVsZW1lbnRbXSA9IFtdO1xuXG4gIHByaXZhdGUgZW1pdFNjcm9sbEV2ZW50KCkge1xuICAgIHRoaXMuX3Njcm9sbC5uZXh0KCk7XG4gIH1cblxuICBwcml2YXRlIGJvdW5kT25TY3JvbGxMaXN0ZW5lcjogYW55ID0gdGhpcy5lbWl0U2Nyb2xsRXZlbnQuYmluZCh0aGlzKTtcblxuICBwcml2YXRlIGFkZFNjcm9sbEV2ZW50TGlzdGVuZXJzKGU6IGFueSkge1xuICAgIHRoaXMuX3Njcm9sbCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgY29uc3QgYW5jaG9yOiBhbnkgPSBlO1xuICAgIGxldCBjdXJyZW50OiBhbnkgPSBlO1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxzKGN1cnJlbnQpKSB7XG4gICAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5ib3VuZE9uU2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgIT09IGFuY2hvciAmJiB0aGlzLmlzUG9zaXRpb25lZChjdXJyZW50KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdGhpcy5zY3JvbGxhYmxlRWxlbWVudHMpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5ib3VuZE9uU2Nyb2xsTGlzdGVuZXIpO1xuICAgIH1cbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9zY3JvbGwpIHtcbiAgICAgIHRoaXMuX3Njcm9sbC5jb21wbGV0ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX3Njcm9sbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNjcm9sbHMoY29udGFpbmVyOiBhbnkpOiBib29sZWFuIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICByZXR1cm4gKFxuICAgICAgY29tcHV0ZWRTdHlsZXMub3ZlcmZsb3dYID09PSBPVkVSRkxPV19TQ1JPTEwgfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzLm92ZXJmbG93WCA9PT0gT1ZFUkZMT1dfQVVUTyB8fFxuICAgICAgY29tcHV0ZWRTdHlsZXMub3ZlcmZsb3dZID09PSBPVkVSRkxPV19TQ1JPTEwgfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzLm92ZXJmbG93WSA9PT0gT1ZFUkZMT1dfQVVUT1xuICAgICk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRW1iZWRkZWRWaWV3UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUG9pbnQsIFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXInO1xuaW1wb3J0IHsgUG9wb3Zlck9wdGlvbnMgfSBmcm9tICcuL3BvcG92ZXItb3B0aW9ucy5pbnRlcmZhY2UnO1xuXG5sZXQgb3BlbkNvdW50OiBudW1iZXIgPSAwO1xuY29uc3Qgd2FpdGluZzogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTsgLy8gcGVuZGluZyBjcmVhdGUgZnVuY3Rpb25zXG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQb3BvdmVyT2xkXScgfSlcbmV4cG9ydCBjbGFzcyBQb3BvdmVyRGlyZWN0aXZlT2xkIHtcbiAgcHJpdmF0ZSBfcG9wb3Zlckluc3RhbmNlOiBQb3BvdmVyO1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBASW5wdXQoJ2NsclBvcG92ZXJPbGRBbmNob3InKSBhbmNob3JFbGVtOiBhbnk7XG4gIEBJbnB1dCgnY2xyUG9wb3Zlck9sZEFuY2hvclBvaW50JykgYW5jaG9yUG9pbnQ6IFBvaW50O1xuICBASW5wdXQoJ2NsclBvcG92ZXJPbGRQb3BvdmVyUG9pbnQnKSBwb3BvdmVyUG9pbnQ6IFBvaW50O1xuICBASW5wdXQoJ2NsclBvcG92ZXJPbGRPcHRpb25zJykgcG9wb3Zlck9wdGlvbnM6IFBvcG92ZXJPcHRpb25zID0ge307XG4gIEBPdXRwdXQoJ2NsclBvcG92ZXJPbGRDaGFuZ2UnKSBjbHJQb3BvdmVyT2xkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PiwgcHJpdmF0ZSB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmKSB7fVxuXG4gIEBJbnB1dCgpXG4gIHNldCBjbHJQb3BvdmVyT2xkKG9wZW46IGJvb2xlYW4pIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgaWYgKHRoaXMucG9wb3Zlck9wdGlvbnMuYWxsb3dNdWx0aXBsZU9wZW4pIHtcbiAgICAgICAgdGhpcy5jcmVhdGVQb3BvdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BlbkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVQb3BvdmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FpdGluZy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9wb3ZlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgdGhpcy5kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgICBpZiAoIXRoaXMucG9wb3Zlck9wdGlvbnMuYWxsb3dNdWx0aXBsZU9wZW4pIHtcbiAgICAgICAgaWYgKHdhaXRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZVBvcG92ZXJGbiA9IHdhaXRpbmcuc2hpZnQoKTtcbiAgICAgICAgICBjcmVhdGVQb3BvdmVyRm4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVBvcG92ZXIoKSB7XG4gICAgY29uc3QgZW1iZWRkZWRWaWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8YW55PiA9IDxFbWJlZGRlZFZpZXdSZWY8YW55Pj50aGlzLnZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgdGhpcy50ZW1wbGF0ZVJlZlxuICAgICk7XG5cbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSBvZiB0aGUgcmlza3MgYXNzb2NpYXRlZCB3aXRoIHVzaW5nIHRoaXMuIEZpbmQgYW4gYWx0ZXJuYXRpdmUuXG4gICAgLy8gTmVlZGVkIGZvciBmaW5kIHRoZSBjb3JyZWN0IGhlaWdodCBhbmQgd2lkdGggb2YgZHluYW1pY2FsbHkgY3JlYXRlZCB2aWV3c1xuICAgIC8vIGluc2lkZSBvZiB0aGUgcG9wb3Zlci4gRm9yIEVnOiBCdXR0b24gR3JvdXBzXG4gICAgZW1iZWRkZWRWaWV3UmVmLmRldGVjdENoYW5nZXMoKTtcblxuICAgIC8vIGZpbHRlciBvdXQgb3RoZXIgbm9kZXMgaW4gdGhlIHZpZXcgcmVmIHNvIHdlIGFyZSBvbmx5IGxlZnQgd2l0aCBlbGVtZW50IG5vZGVzXG4gICAgY29uc3QgZWxlbWVudE5vZGVzOiBIVE1MRWxlbWVudFtdID0gZW1iZWRkZWRWaWV3UmVmLnJvb3ROb2Rlcy5maWx0ZXIoKG5vZGU6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDE7XG4gICAgfSk7XG5cbiAgICAvLyB3ZSB0YWtlIHRoZSBmaXJzdCBlbGVtZW50IG5vZGUgaW4gdGhlIGVtYmVkZGVkIHZpZXc7IHVzdWFsbHkgdGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIGFueXdheXNcbiAgICB0aGlzLl9wb3BvdmVySW5zdGFuY2UgPSBuZXcgUG9wb3ZlcihlbGVtZW50Tm9kZXNbMF0pO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3BvcG92ZXJJbnN0YW5jZVxuICAgICAgLmFuY2hvcih0aGlzLmFuY2hvckVsZW0sIHRoaXMuYW5jaG9yUG9pbnQsIHRoaXMucG9wb3ZlclBvaW50LCB0aGlzLnBvcG92ZXJPcHRpb25zKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xyUG9wb3Zlck9sZENoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIG9wZW5Db3VudCsrO1xuICB9XG5cbiAgZGVzdHJveVBvcG92ZXIoKSB7XG4gICAgaWYgKHRoaXMuX3BvcG92ZXJJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLl9wb3BvdmVySW5zdGFuY2UucmVsZWFzZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX3BvcG92ZXJJbnN0YW5jZTtcbiAgICAgIG9wZW5Db3VudC0tO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveVBvcG92ZXIoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUG9wb3ZlckRpcmVjdGl2ZU9sZCB9IGZyb20gJy4vcG9wb3Zlci1vbGQuZGlyZWN0aXZlJztcblxuZXhwb3J0ICogZnJvbSAnLi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vcG9wb3Zlci1vbGQuZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IFBPUE9WRVJfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbUG9wb3ZlckRpcmVjdGl2ZU9sZF07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQT1BPVkVSX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW1BPUE9WRVJfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtQT1BPVkVSX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDbHJMb2FkaW5nU3RhdGUgfSBmcm9tICcuL2xvYWRpbmcnO1xuXG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYmVjYXVzZSB3ZSBuZWVkIGl0IHRvIHN0aWxsIGJlIGEgdmFsaWQgdG9rZW4gZm9yIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGFmdGVyIHRyYW5zcGlsaW5nLlxuICogVGhpcyBkb2VzIG5vdCBtZWFuIHlvdSBzaG91bGQgZXh0ZW5kIGl0LCBzaW1wbHkgaW1wbGVtZW50aW5nIGl0IGlzIGZpbmUuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMb2FkaW5nTGlzdGVuZXIge1xuICBhYnN0cmFjdCBsb2FkaW5nU3RhdGVDaGFuZ2Uoc3RhdGU6IENsckxvYWRpbmdTdGF0ZSk6IHZvaWQ7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4vbG9hZGluZy1saXN0ZW5lcic7XG5cbmV4cG9ydCBlbnVtIENsckxvYWRpbmdTdGF0ZSB7XG4gIERFRkFVTFQsXG4gIExPQURJTkcsXG4gIFNVQ0NFU1MsXG4gIEVSUk9SLFxufVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyTG9hZGluZ10nIH0pXG5leHBvcnQgY2xhc3MgQ2xyTG9hZGluZyBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIC8vIFdlIGZpbmQgdGhlIGZpcnN0IHBhcmVudCB0aGF0IGhhbmRsZXMgc29tZXRoaW5nIGxvYWRpbmdcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSBsaXN0ZW5lcjogTG9hZGluZ0xpc3RlbmVyKSB7fVxuXG4gIHByaXZhdGUgX2xvYWRpbmdTdGF0ZTogQ2xyTG9hZGluZ1N0YXRlID0gQ2xyTG9hZGluZ1N0YXRlLkRFRkFVTFQ7XG5cbiAgcHVibGljIGdldCBsb2FkaW5nU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRpbmdTdGF0ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyTG9hZGluZycpXG4gIHB1YmxpYyBzZXQgbG9hZGluZ1N0YXRlKHZhbHVlOiBib29sZWFuIHwgQ2xyTG9hZGluZ1N0YXRlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB2YWx1ZSA9IENsckxvYWRpbmdTdGF0ZS5MT0FESU5HO1xuICAgIH0gZWxzZSBpZiAoIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fbG9hZGluZ1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbG9hZGluZ1N0YXRlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMubGlzdGVuZXIpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIubG9hZGluZ1N0YXRlQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmxvYWRpbmdTdGF0ZSA9IENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyQnV0dG9uIH0gZnJvbSAnLi4vYnV0dG9uLWdyb3VwL2J1dHRvbic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCdXR0b25Jbkdyb3VwU2VydmljZSB7XG4gIHByaXZhdGUgX2NoYW5nZXM6IFN1YmplY3Q8Q2xyQnV0dG9uPiA9IG5ldyBTdWJqZWN0PENsckJ1dHRvbj4oKTtcblxuICBnZXQgY2hhbmdlcygpOiBPYnNlcnZhYmxlPENsckJ1dHRvbj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgdXBkYXRlQnV0dG9uR3JvdXAoYnV0dG9uOiBDbHJCdXR0b24pOiB2b2lkIHtcbiAgICB0aGlzLl9jaGFuZ2VzLm5leHQoYnV0dG9uKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9wdGlvbmFsLCBPdXRwdXQsIFNraXBTZWxmLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckxvYWRpbmdTdGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZyc7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuaW1wb3J0IHsgQnV0dG9uSW5Hcm91cFNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvYnV0dG9uLWluLWdyb3VwLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYnV0dG9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNidXR0b25Qcm9qZWN0ZWRSZWY+XG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIFtjbGFzc109XCJjbGFzc05hbWVzXCIgXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImVtaXRDbGljaygpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50eXBlXT1cInR5cGVcIlxuICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNwaW5uZXIgc3Bpbm5lci1pbmxpbmVcIiAqbmdJZj1cImxvYWRpbmdcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBDbHJCdXR0b24gfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckJ1dHRvbiBpbXBsZW1lbnRzIExvYWRpbmdMaXN0ZW5lciB7XG4gIHByaXZhdGUgX2VuYWJsZVNlcnZpY2U6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBAVmlld0NoaWxkKCdidXR0b25Qcm9qZWN0ZWRSZWYnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8Q2xyQnV0dG9uPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBAU2tpcFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHVibGljIGJ1dHRvbkluR3JvdXBTZXJ2aWNlOiBCdXR0b25Jbkdyb3VwU2VydmljZVxuICApIHt9XG5cbiAgcHJpdmF0ZSBfaW5NZW51OiBib29sZWFuID0gZmFsc2U7XG5cbiAgZ2V0IGluTWVudSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faW5NZW51O1xuICB9XG5cbiAgQElucHV0KCdjbHJJbk1lbnUnKVxuICBzZXQgaW5NZW51KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh0aGlzLl9pbk1lbnUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pbk1lbnUgPSB2YWx1ZTtcbiAgICAgIC8vIFdlIGNoZWNrIGlmIHRoZSBzZXJ2aWNlIGZsYWcgaXMgZW5hYmxlZFxuICAgICAgLy8gYW5kIGlmIHRoZSBzZXJ2aWNlIGV4aXN0cyBiZWNhdXNlIHRoZSBzZXJ2aWNlIGlzIG9wdGlvbmFsXG4gICAgICBpZiAodGhpcy5fZW5hYmxlU2VydmljZSAmJiB0aGlzLmJ1dHRvbkluR3JvdXBTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuYnV0dG9uSW5Hcm91cFNlcnZpY2UudXBkYXRlQnV0dG9uR3JvdXAodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY2xhc3NOYW1lczogc3RyaW5nID0gJ2J0bic7XG5cbiAgZ2V0IGNsYXNzTmFtZXMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY2xhc3NOYW1lcztcbiAgfVxuXG4gIEBJbnB1dCgnY2xhc3MnKVxuICBzZXQgY2xhc3NOYW1lcyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGNsYXNzTmFtZXM6IHN0cmluZ1tdID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgIGlmIChjbGFzc05hbWVzLmluZGV4T2YoJ2J0bicpID09PSAtMSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2J0bicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX25hbWU6IHN0cmluZyA9IG51bGw7XG5cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuXG4gIEBJbnB1dCgnbmFtZScpXG4gIHNldCBuYW1lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3R5cGU6IHN0cmluZyA9IG51bGw7XG5cbiAgZ2V0IHR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgfVxuXG4gIEBJbnB1dCgndHlwZScpXG4gIHNldCB0eXBlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fdHlwZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2Rpc2FibGVkOiBhbnkgPSBudWxsO1xuXG4gIGdldCBkaXNhYmxlZCgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIEBJbnB1dCgnZGlzYWJsZWQnKVxuICBzZXQgZGlzYWJsZWQodmFsdWU6IGFueSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVkID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbG9hZGluZzogYm9vbGVhbjtcblxuICBsb2FkaW5nU3RhdGVDaGFuZ2Uoc3RhdGU6IENsckxvYWRpbmdTdGF0ZSk6IHZvaWQge1xuICAgIHRoaXMubG9hZGluZyA9IHN0YXRlID09PSBDbHJMb2FkaW5nU3RhdGUuTE9BRElORztcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsaWNrJykgX2NsaWNrOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBlbWl0Q2xpY2soKTogdm9pZCB7XG4gICAgdGhpcy5fY2xpY2suZW1pdCh0cnVlKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLl9lbmFibGVTZXJ2aWNlID0gdHJ1ZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IENMUl9NRU5VX1BPU0lUSU9OUzogc3RyaW5nW10gPSBbXG4gICdib3R0b20tbGVmdCcsXG4gICdib3R0b20tcmlnaHQnLFxuICAndG9wLWxlZnQnLFxuICAndG9wLXJpZ2h0JyxcbiAgJ2xlZnQtYm90dG9tJyxcbiAgJ2xlZnQtdG9wJyxcbiAgJ3JpZ2h0LWJvdHRvbScsXG4gICdyaWdodC10b3AnLFxuXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFNraXBTZWxmLCBPcHRpb25hbCwgSW5qZWN0YWJsZVByb3ZpZGVyLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbi8vIEBUT0RPIFB1dCB0aGUgUmVxdWlyZWQgdHlwZSBiYWNrIGluIHdoZW4gb3VyIG1pbmltdW1seSBzdXBwb3J0ZWQgdmVyc2lvbiBvZiBBbmd1bGFyIHVzZXNcbi8vIFRTIDIuOCBvciBncmVhdGVyIChzaG91bGQgYmUgQW5ndWxhciA3KVxuLy8gZXhwb3J0IGNsYXNzIENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIGltcGxlbWVudHMgUmVxdWlyZWQ8Q2xyQ29tbW9uU3RyaW5ncz4ge1xuZXhwb3J0IGNsYXNzIENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIGltcGxlbWVudHMgQ2xyQ29tbW9uU3RyaW5ncyB7XG4gIG9wZW4gPSAnT3Blbic7XG4gIGNsb3NlID0gJ0Nsb3NlJztcbiAgc2hvdyA9ICdTaG93JztcbiAgaGlkZSA9ICdIaWRlJztcbiAgZXhwYW5kID0gJ0V4cGFuZCc7XG4gIGNvbGxhcHNlID0gJ0NvbGxhcHNlJztcbiAgbW9yZSA9ICdNb3JlJztcbiAgc2VsZWN0ID0gJ1NlbGVjdCc7XG4gIHNlbGVjdEFsbCA9ICdTZWxlY3QgQWxsJztcbiAgcHJldmlvdXMgPSAnUHJldmlvdXMnO1xuICBuZXh0ID0gJ05leHQnO1xuICBjdXJyZW50ID0gJ0p1bXAgdG8gY3VycmVudCc7XG4gIGluZm8gPSAnSW5mbyc7XG4gIHN1Y2Nlc3MgPSAnU3VjY2Vzcyc7XG4gIHdhcm5pbmcgPSAnV2FybmluZyc7XG4gIGRhbmdlciA9ICdFcnJvcic7XG4gIHJvd0FjdGlvbnMgPSAnQXZhaWxhYmxlIGFjdGlvbnMnO1xuICBwaWNrQ29sdW1ucyA9ICdTaG93IG9yIGhpZGUgY29sdW1ucyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21tb25TdHJpbmdzRmFjdG9yeShleGlzdGluZz86IENsckNvbW1vblN0cmluZ3MpOiBDbHJDb21tb25TdHJpbmdzIHtcbiAgY29uc3QgZGVmYXVsdHMgPSBuZXcgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UoKTtcbiAgaWYgKGV4aXN0aW5nKSB7XG4gICAgcmV0dXJuIHsgLi4uZGVmYXVsdHMsIC4uLmV4aXN0aW5nIH07XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRzO1xufVxuXG5leHBvcnQgY29uc3QgQ09NTU9OX1NUUklOR1NfUFJPVklERVI6IEluamVjdGFibGVQcm92aWRlciA9IHtcbiAgdXNlRmFjdG9yeTogY29tbW9uU3RyaW5nc0ZhY3RvcnksXG4gIC8vIFdlIGhhdmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGZvciBub3csIHdlIGNhbiBhZGRyZXNzIGl0IGxhdGVyIG9uY2UgdGhlc2VcbiAgLy8gdHJlZS1zaGFrZWFibGUgcHJvdmlkZXJzIGhhdmUgcHJvcGVyIGRvY3VtZW50YXRpb24uXG4gIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBmb3J3YXJkUmVmKCgpID0+IENsckNvbW1vblN0cmluZ3MpXV0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENPTU1PTl9TVFJJTkdTX1BST1ZJREVSIH0gZnJvbSAnLi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG4gIC4uLkNPTU1PTl9TVFJJTkdTX1BST1ZJREVSLFxufSlcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDbHJDb21tb25TdHJpbmdzIHtcbiAgLyoqXG4gICAqIE9wZW4gYnV0dG9uXG4gICAqL1xuICBvcGVuPzogc3RyaW5nO1xuICAvKipcbiAgICogQ2xvc2UgYnV0dG9uXG4gICAqL1xuICBjbG9zZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFNob3cgYnV0dG9uXG4gICAqL1xuICBzaG93Pzogc3RyaW5nO1xuICAvKipcbiAgICogSGlkZSBidXR0b25cbiAgICovXG4gIGhpZGU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBFeHBhbmRhYmxlIGNvbXBvbmVudHM6IGV4cGFuZCBjYXJldFxuICAgKi9cbiAgZXhwYW5kPzogc3RyaW5nO1xuICAvKipcbiAgICogRXhwYW5kYWJsZSBjb21wb25lbnRzOiBjb2xsYXBzZSBjYXJldFxuICAgKi9cbiAgY29sbGFwc2U/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBPdmVyZmxvdyBtZW51czogZWxsaXBzaXMgYnV0dG9uXG4gICAqL1xuICBtb3JlPzogc3RyaW5nO1xuICAvKipcbiAgICogU2VsZWN0YWJsZSBjb21wb25lbnRzOiBjaGVja2JveCBvciByYWRpb1xuICAgKi9cbiAgc2VsZWN0Pzogc3RyaW5nO1xuICAvKipcbiAgICogU2VsZWN0YWJsZSBjb21wb25lbnRzOiBjaGVja2JveCB0byBzZWxlY3QgYWxsXG4gICAqL1xuICBzZWxlY3RBbGw/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBQYWdpbmF0aW9uOiBwcmV2aW91cyBidXR0b25cbiAgICovXG4gIHByZXZpb3VzPzogc3RyaW5nO1xuICAvKipcbiAgICogUGFnaW5hdGlvbjogbmV4dCBidXR0b25cbiAgICovXG4gIG5leHQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBQYWdpbmF0aW9uOiBnbyB0byBjdXJyZW50XG4gICAqL1xuICBjdXJyZW50Pzogc3RyaW5nO1xuICAvKipcbiAgICogQWxlcnQgbGV2ZWxzOiBpbmZvXG4gICAqL1xuICBpbmZvPzogc3RyaW5nO1xuICAvKipcbiAgICogQWxlcnQgbGV2ZWxzOiBzdWNjZXNzXG4gICAqL1xuICBzdWNjZXNzPzogc3RyaW5nO1xuICAvKipcbiAgICogQWxlcnQgbGV2ZWxzOiB3YXJuaW5nXG4gICAqL1xuICB3YXJuaW5nPzogc3RyaW5nO1xuICAvKipcbiAgICogQWxlcnQgbGV2ZWxzOiBkYW5nZXJcbiAgICovXG4gIGRhbmdlcj86IHN0cmluZztcbiAgLyoqXG4gICAqIERhdGFncmlkOiByb3cgYWN0aW9uc1xuICAgKi9cbiAgcm93QWN0aW9ucz86IHN0cmluZztcbiAgLyoqXG4gICAqIERhdGFncmlkOiBwaWNrIGNvbHVtbnNcbiAgICovXG4gIHBpY2tDb2x1bW5zPzogc3RyaW5nO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlcic7XG5pbXBvcnQgeyBDTFJfTUVOVV9QT1NJVElPTlMgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2Ryb3Bkb3duL21lbnUtcG9zaXRpb25zJztcbmltcG9ydCB7IEJ1dHRvbkluR3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2J1dHRvbi1pbi1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbmltcG9ydCB7IENsckJ1dHRvbiB9IGZyb20gJy4vYnV0dG9uJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWJ1dHRvbi1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAnYnV0dG9uLWdyb3VwLmh0bWwnLFxuICBwcm92aWRlcnM6IFtCdXR0b25Jbkdyb3VwU2VydmljZV0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5idG4tZ3JvdXBdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckJ1dHRvbkdyb3VwIHtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJCdXR0b24pIGJ1dHRvbnM6IFF1ZXJ5TGlzdDxDbHJCdXR0b24+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBidXR0b25Hcm91cE5ld1NlcnZpY2U6IEJ1dHRvbkluR3JvdXBTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHt9XG5cbiAgaW5saW5lQnV0dG9uczogQ2xyQnV0dG9uW10gPSBbXTtcbiAgbWVudUJ1dHRvbnM6IENsckJ1dHRvbltdID0gW107XG5cbiAgLyoqXG4gICAqIDEuIEluaXRpYWxpemVzIHRoZSBpbml0aWFsIEJ1dHRvbiBHcm91cCBWaWV3XG4gICAqIDIuIFN1YnNjcmliZXMgdG8gY2hhbmdlcyBvbiB0aGUgQ29udGVudENoaWxkcmVuXG4gICAqICAgIGluIGNhc2UgdGhlIHVzZXIgY29udGVudCBwcm9qZWN0aW9uIGNoYW5nZXNcbiAgICovXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVCdXR0b25zKCk7XG4gICAgdGhpcy5idXR0b25Hcm91cE5ld1NlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoYnV0dG9uID0+IHRoaXMucmVhcnJhbmdlQnV0dG9uKGJ1dHRvbikpO1xuICAgIHRoaXMuYnV0dG9ucy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmluaXRpYWxpemVCdXR0b25zKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGJ1dHRvbiBpbnRvIHRoZSBvdGhlciBWaWV3Q29udGFpbmVyXG4gICAqIHdoZW4gYW4gdXBkYXRlIGlzIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAcGFyYW0gYnV0dG9uXG4gICAqL1xuICByZWFycmFuZ2VCdXR0b24oYnV0dG9uOiBDbHJCdXR0b24pOiB2b2lkIHtcbiAgICBsZXQgZnJvbVZpZXc6IENsckJ1dHRvbltdO1xuICAgIGxldCB0b1ZpZXc6IENsckJ1dHRvbltdO1xuICAgIGlmIChidXR0b24uaW5NZW51KSB7XG4gICAgICBmcm9tVmlldyA9IHRoaXMuaW5saW5lQnV0dG9ucztcbiAgICAgIHRvVmlldyA9IHRoaXMubWVudUJ1dHRvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb21WaWV3ID0gdGhpcy5tZW51QnV0dG9ucztcbiAgICAgIHRvVmlldyA9IHRoaXMuaW5saW5lQnV0dG9ucztcbiAgICB9XG4gICAgY29uc3QgaW5kZXg6IG51bWJlciA9IGZyb21WaWV3LmluZGV4T2YoYnV0dG9uKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgZnJvbVZpZXcuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGNvbnN0IG1vdmVJbmRleCA9IHRoaXMuZ2V0TW92ZUluZGV4KGJ1dHRvbik7XG4gICAgICBpZiAobW92ZUluZGV4IDw9IHRvVmlldy5sZW5ndGgpIHtcbiAgICAgICAgdG9WaWV3LnNwbGljZShtb3ZlSW5kZXgsIDAsIGJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF1dGhvcjogRXVkZXNcbiAgICpcbiAgICogRmluZHMgdGhlIG9yZGVyIG9mIGEgYnV0dG9uIHcuci50IG90aGVyIGJ1dHRvbnNcbiAgICpcbiAgICogQHBhcmFtIGJ1dHRvblRvTW92ZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0TW92ZUluZGV4KGJ1dHRvblRvTW92ZTogQ2xyQnV0dG9uKTogbnVtYmVyIHtcbiAgICBjb25zdCB0ZW1wQXJyOiBDbHJCdXR0b25bXSA9IHRoaXMuYnV0dG9ucy5maWx0ZXIoYnV0dG9uID0+IGJ1dHRvbi5pbk1lbnUgPT09IGJ1dHRvblRvTW92ZS5pbk1lbnUpO1xuICAgIHJldHVybiB0ZW1wQXJyLmluZGV4T2YoYnV0dG9uVG9Nb3ZlKTtcbiAgfVxuXG4gIGluaXRpYWxpemVCdXR0b25zKCk6IHZvaWQge1xuICAgIGNvbnN0IHRlbXBJbmxpbmVCdXR0b25zOiBDbHJCdXR0b25bXSA9IFtdO1xuICAgIGNvbnN0IHRlbXBJbk1lbnVCdXR0b25zOiBDbHJCdXR0b25bXSA9IFtdO1xuICAgIHRoaXMuYnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICBpZiAoYnV0dG9uLmluTWVudSkge1xuICAgICAgICB0ZW1wSW5NZW51QnV0dG9ucy5wdXNoKGJ1dHRvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wSW5saW5lQnV0dG9ucy5wdXNoKGJ1dHRvbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5pbmxpbmVCdXR0b25zID0gdGVtcElubGluZUJ1dHRvbnM7XG4gICAgdGhpcy5tZW51QnV0dG9ucyA9IHRlbXBJbk1lbnVCdXR0b25zO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJmbG93IE1lbnVcbiAgICpcbiAgICovXG5cbiAgLy8gSW5kaWNhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmZsb3cgbWVudVxuICBwcml2YXRlIF9tZW51UG9zaXRpb246IHN0cmluZztcblxuICBnZXQgbWVudVBvc2l0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX21lbnVQb3NpdGlvbjtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyTWVudVBvc2l0aW9uJylcbiAgc2V0IG1lbnVQb3NpdGlvbihwb3M6IHN0cmluZykge1xuICAgIGlmIChwb3MgJiYgQ0xSX01FTlVfUE9TSVRJT05TLmluZGV4T2YocG9zKSA+IC0xKSB7XG4gICAgICB0aGlzLl9tZW51UG9zaXRpb24gPSBwb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21lbnVQb3NpdGlvbiA9ICdib3R0b20tbGVmdCc7XG4gICAgfVxuICAgIC8vIHNldCB0aGUgcG9wb3ZlciB2YWx1ZXMgYmFzZWQgb24gbWVudSBwb3NpdGlvblxuICAgIHN3aXRjaCAodGhpcy5fbWVudVBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuVE9QX1JJR0hUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfTEVGVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX1JJR0hUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodC10b3AnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0LWJvdHRvbSc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdC10b3AnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQtYm90dG9tJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX29wZW5NZW51OiBib29sZWFuID0gZmFsc2U7XG5cbiAgZ2V0IG9wZW5NZW51KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9vcGVuTWVudTtcbiAgfVxuXG4gIHNldCBvcGVuTWVudSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX29wZW5NZW51ID0gdmFsdWU7XG4gIH1cblxuICBwdWJsaWMgYW5jaG9yUG9pbnQ6IFBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7IC8vIGRlZmF1bHQgaWYgbWVudVBvc2l0aW9uIGlzbid0IHNldFxuICBwdWJsaWMgcG9wb3ZlclBvaW50OiBQb2ludCA9IFBvaW50LkxFRlRfVE9QOyAvLyBkZWZhdWx0IGlmIG1lbnVQb3NpdGlvbiBpc24ndCBzZXRcblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBDbHJEcm9wZG93biBNZW51IHdoZW4gdGhlIENsckRyb3Bkb3duIFRvZ2dsZSBpc1xuICAgKiBjbGlja2VkLiBBbHNvIHNldCBhIGZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCB0aGUgdG9nZ2xlXG4gICAqIHdhcyBjbGlja2VkIHNvIHRoYXQgd2UgZG9uJ3QgdHJhdmVyc2UgdGhlIERPTSB0byBmaW5kIHRoZVxuICAgKiBsb2NhdGlvbiBvZiB0aGUgY2xpY2suXG4gICAqL1xuICB0b2dnbGVNZW51KCk6IHZvaWQge1xuICAgIHRoaXMub3Blbk1lbnUgPSAhdGhpcy5vcGVuTWVudTtcbiAgICB0aGlzLl9vdmVyZmxvd01lbnVUb2dnbGVDbGlja2VkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIHdpdGggaW5kaWNhdGVzIGlmIHRoZSBvdmVyZmxvdyBtZW51IHRvZ2dsZSB3YXMgY2xpY2tlZC5cbiAgICogSWYgdHJ1ZSwgdGhpcyBjYW4gc2F2ZSB1cyB0cmF2ZXJzaW5nIHRoZSBET00gdG8gZmluZFxuICAgKiB3aGV0aGVyIHRoZSBjbGljayB3YXMgd2l0aGluZyB0aGUgYnV0dG9uIGdyb3VwIHRvZ2dsZVxuICAgKiBvciBtZW51IGluIHRoZSBvbk1vdXNlQ2xpY2sgbWV0aG9kXG4gICAqL1xuICBwcml2YXRlIF9vdmVyZmxvd01lbnVUb2dnbGVDbGlja2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gVE9ETzogR2VuZXJpYyBEaXJlY3RpdmUgdG8gaGFuZGxlIHRoaXNcbiAgLyoqXG4gICAqIENhbGxlZCBvbiBtb3VzZSBjbGlja3MgYW55d2hlcmUgaW4gdGhlIERPTS5cbiAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbW91c2VjbGljayBoYXBwZW5lZCBvbiB0aGUgaG9zdCBvciBvdXRzaWRlXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50LnRhcmdldCddKVxuICBvbk1vdXNlQ2xpY2sodGFyZ2V0OiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5vcGVuTWVudSAmJiAhdGhpcy5fb3ZlcmZsb3dNZW51VG9nZ2xlQ2xpY2tlZCkge1xuICAgICAgLy8gUmVzZXQgdGhlIG92ZXJmbG93IG1lbnUgdG9nZ2xlIGNsaWNrZWQgZmxhZ1xuICAgICAgdGhpcy5fb3ZlcmZsb3dNZW51VG9nZ2xlQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgbGV0IGN1cnJlbnQ6IGFueSA9IHRhcmdldDsgLy8gR2V0IHRoZSBlbGVtZW50IGluIHRoZSBET00gb24gd2hpY2ggdGhlIG1vdXNlIHdhcyBjbGlja2VkXG4gICAgICBjb25zdCBob3N0OiBhbnkgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDsgLy8gQ3VycmVudCBCdXR0b24gR3JvdXBcblxuICAgICAgaWYgKGN1cnJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkcm9wZG93bi1tZW51JykpIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMub3Blbk1lbnUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBjbGlja2VkIG9uIGRyb3Bkb3duIG1lbnUgYW5kIG1lbnUgaXMgaW4gaG9zdFxuICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gaG9zdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9wZW5NZW51ID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX292ZXJmbG93TWVudVRvZ2dsZUNsaWNrZWQgPSBmYWxzZTsgLy8gUmVzZXQgdGhlIG92ZXJmbG93IG1lbnUgdG9nZ2xlIGNsaWNrZWQgZmxhZ1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlci5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJCdXR0b24gfSBmcm9tICcuL2J1dHRvbic7XG5pbXBvcnQgeyBDbHJCdXR0b25Hcm91cCB9IGZyb20gJy4vYnV0dG9uLWdyb3VwJztcblxuZXhwb3J0IGNvbnN0IENMUl9CVVRUT05fR1JPVVBfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyQnV0dG9uLCBDbHJCdXR0b25Hcm91cF07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGUsIENsckNvbW1vblBvcG92ZXJNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfQlVUVE9OX0dST1VQX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX0JVVFRPTl9HUk9VUF9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQnV0dG9uR3JvdXBNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgYW5pbWF0ZSwga2V5ZnJhbWVzLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ1N0YXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nJztcbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2J1dHRvbltjbHJMb2FkaW5nXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cInN0YXRlXCI+XG4gICAgICAgICAgICA8c3BhbiAqbmdTd2l0Y2hDYXNlPVwiYnV0dG9uU3RhdGUuTE9BRElOR1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIEBzcGlubmVyIGNsYXNzPVwic3Bpbm5lciBzcGlubmVyLWlubGluZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuICpuZ1N3aXRjaENhc2U9XCJidXR0b25TdGF0ZS5TVUNDRVNTXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gQHZhbGlkYXRlZCAoQHZhbGlkYXRlZC5kb25lKT1cInRoaXMubG9hZGluZ1N0YXRlQ2hhbmdlKHRoaXMuYnV0dG9uU3RhdGUuREVGQVVMVClcIiBjbGFzcz1cInNwaW5uZXIgc3Bpbm5lci1pbmxpbmUgc3Bpbm5lci1jaGVja1wiPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuICpuZ1N3aXRjaENhc2U9XCJidXR0b25TdGF0ZS5ERUZBVUxUXCIgQGRlZmF1bHRCdXR0b24+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IExvYWRpbmdMaXN0ZW5lciwgdXNlRXhpc3Rpbmc6IENsckxvYWRpbmdCdXR0b24gfV0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdkZWZhdWx0QnV0dG9uJywgW1xuICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW3N0eWxlKHsgb3BhY2l0eTogMCB9KSwgYW5pbWF0ZSgnMjAwbXMgMTAwbXMgZWFzZS1pbicsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSldKSxcbiAgICAgIC8vIFRPRE86IHNlZSBpZiB3ZSBjYW4gZ2V0IGxlYXZlIGFuaW1hdGlvbiB0byB3b3JrIGJlZm9yZSBzcGlubmVyJ3MgZW50ZXIgYW5pbWF0aW9uXG4gICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbc3R5bGUoeyBvcGFjaXR5OiAwIH0pXSksXG4gICAgXSksXG4gICAgdHJpZ2dlcignc3Bpbm5lcicsIFtcbiAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSksIGFuaW1hdGUoJzIwMG1zIDEwMG1zIGVhc2UtaW4nLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXSksXG4gICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbc3R5bGUoeyBvcGFjaXR5OiAxIH0pLCBhbmltYXRlKCcxMDBtcyBlYXNlLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSldKSxcbiAgICBdKSxcbiAgICB0cmlnZ2VyKCd2YWxpZGF0ZWQnLCBbXG4gICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgICAgIGFuaW1hdGUoXG4gICAgICAgICAgJzYwMG1zJyxcbiAgICAgICAgICBrZXlmcmFtZXMoW1xuICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgwLDApJywgb2Zmc2V0OiAwIH0pLFxuICAgICAgICAgICAgc3R5bGUoeyBvcGFjaXR5OiAxLCBvZmZzZXQ6IDAuMiB9KSxcbiAgICAgICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMS4yLDEuMiknLCBvZmZzZXQ6IDAuNCB9KSxcbiAgICAgICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoLjksLjkpJywgb2Zmc2V0OiAwLjYgfSksXG4gICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDEsMSknLCBvZmZzZXQ6IDEgfSksXG4gICAgICAgICAgXSlcbiAgICAgICAgKSxcbiAgICAgIF0pLFxuICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW3N0eWxlKHsgb3BhY2l0eTogMSB9KSwgYW5pbWF0ZSgnMTAwbXMgZWFzZS1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXSksXG4gICAgXSksXG4gIF0sXG4gIGhvc3Q6IHsgJ1thdHRyLmRpc2FibGVkXSc6IFwiZGlzYWJsZWQ/ICcnIDogbnVsbFwiIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckxvYWRpbmdCdXR0b24gaW1wbGVtZW50cyBMb2FkaW5nTGlzdGVuZXIge1xuICBwdWJsaWMgYnV0dG9uU3RhdGUgPSBDbHJMb2FkaW5nU3RhdGU7XG4gIHB1YmxpYyBzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlID0gQ2xyTG9hZGluZ1N0YXRlLkRFRkFVTFQ7XG5cbiAgQElucHV0KCdkaXNhYmxlZCcpIHB1YmxpYyBkaXNhYmxlZDogYm9vbGVhbjtcblxuICBAT3V0cHV0KCdjbHJMb2FkaW5nQ2hhbmdlJylcbiAgcHVibGljIGNsckxvYWRpbmdDaGFuZ2U6IEV2ZW50RW1pdHRlcjxDbHJMb2FkaW5nU3RhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJMb2FkaW5nU3RhdGU+KGZhbHNlKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZWw6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBsb2FkaW5nU3RhdGVDaGFuZ2Uoc3RhdGU6IENsckxvYWRpbmdTdGF0ZSk6IHZvaWQge1xuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUOlxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3dpZHRoJyk7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsckxvYWRpbmdTdGF0ZS5MT0FESU5HOlxuICAgICAgICB0aGlzLnNldEV4cGxpY2l0QnV0dG9uV2lkdGgoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgdGhpcy5zZXRFeHBsaWNpdEJ1dHRvbldpZHRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuRVJST1I6XG4gICAgICAgIHRoaXMubG9hZGluZ1N0YXRlQ2hhbmdlKENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5jbHJMb2FkaW5nQ2hhbmdlLmVtaXQoc3RhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRFeHBsaWNpdEJ1dHRvbldpZHRoKCkge1xuICAgIGlmICh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQgJiYgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCkge1xuICAgICAgY29uc3QgYm91bmRpbmdDbGllbnRSZWN0ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIGAke2JvdW5kaW5nQ2xpZW50UmVjdC53aWR0aH1weGApO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyTG9hZGluZ0J1dHRvbiB9IGZyb20gJy4vbG9hZGluZy1idXR0b24nO1xuXG5leHBvcnQgY29uc3QgQ0xSX0xPQURJTkdfQlVUVE9OX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsckxvYWRpbmdCdXR0b25dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0xPQURJTkdfQlVUVE9OX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX0xPQURJTkdfQlVUVE9OX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJMb2FkaW5nQnV0dG9uTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckJ1dHRvbkdyb3VwTW9kdWxlIH0gZnJvbSAnLi9idXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJMb2FkaW5nQnV0dG9uTW9kdWxlIH0gZnJvbSAnLi9idXR0b24tbG9hZGluZy9sb2FkaW5nLWJ1dHRvbi5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBleHBvcnRzOiBbQ2xyTG9hZGluZ0J1dHRvbk1vZHVsZSwgQ2xyQnV0dG9uR3JvdXBNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJCdXR0b25Nb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGU6ICcnLFxufSlcbmV4cG9ydCBjbGFzcyBFbXB0eUFuY2hvciB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRW1wdHlBbmNob3IgfSBmcm9tICcuL2VtcHR5LWFuY2hvcic7XG5cbi8qKlxuICogSW50ZXJuYWwgbW9kdWxlLCBwbGVhc2UgZG8gbm90IGV4cG9ydCFcbiAqL1xuQE5nTW9kdWxlKHsgZGVjbGFyYXRpb25zOiBbRW1wdHlBbmNob3JdLCBleHBvcnRzOiBbRW1wdHlBbmNob3JdLCBlbnRyeUNvbXBvbmVudHM6IFtFbXB0eUFuY2hvcl0gfSlcbmV4cG9ydCBjbGFzcyBDbHJIb3N0V3JhcHBpbmdNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItY29udHJvbC1lcnJvcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5jbHItc3VidGV4dF0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ29udHJvbEVycm9yIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNvbnRyb2wtaGVscGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmNsci1zdWJ0ZXh0XSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDb250cm9sSGVscGVyIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5nQ29udHJvbFNlcnZpY2Uge1xuICAvLyBPYnNlcnZhYmxlIHRvIHN1YnNjcmliZSB0byB0aGUgY29udHJvbCwgc2luY2UgaXRzIG5vdCBhdmFpbGFibGUgaW1tZWRpYXRlbHkgZm9yIHByb2plY3RlZCBjb250ZW50XG4gIHByaXZhdGUgX2NvbnRyb2xDaGFuZ2VzOiBTdWJqZWN0PE5nQ29udHJvbD4gPSBuZXcgU3ViamVjdDxOZ0NvbnRyb2w+KCk7XG4gIGdldCBjb250cm9sQ2hhbmdlcygpOiBPYnNlcnZhYmxlPE5nQ29udHJvbD4ge1xuICAgIHJldHVybiB0aGlzLl9jb250cm9sQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHNldENvbnRyb2woY29udHJvbDogTmdDb250cm9sKSB7XG4gICAgdGhpcy5fY29udHJvbENoYW5nZXMubmV4dChjb250cm9sKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZkVycm9yU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIC8vIEltcGxlbWVudCBvdXIgb3duIHN0YXR1cyBjaGFuZ2VzIG9ic2VydmFibGUsIHNpbmNlIEFuZ3VsYXIgY29udHJvbHMgZG9uJ3RcbiAgLy8gZmlyZSBvbiBldmVudHMgbGlrZSBibHVyLCBhbmQgd2Ugd2FudCB0byByZXR1cm4gdGhlIGNvbnRyb2wgaW5zdGVhZCBvZiBhIHN0cmluZ1xuICBwcml2YXRlIF9zdGF0dXNDaGFuZ2VzOiBTdWJqZWN0PE5nQ29udHJvbD4gPSBuZXcgU3ViamVjdCgpO1xuICBnZXQgc3RhdHVzQ2hhbmdlcygpOiBPYnNlcnZhYmxlPE5nQ29udHJvbD4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXNDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgY29udHJvbCB0byBiZSBhdmFpbGFibGVcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgICAgICB0aGlzLmxpc3RlbkZvckNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdGF0dXMgY2hhbmdlIGV2ZW50cywgb25seSBhZnRlciB0b3VjaGVkIGFuZCBlbWl0IHRoZSBjb250cm9sXG4gIHByaXZhdGUgbGlzdGVuRm9yQ2hhbmdlcygpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMuY29udHJvbC50b3VjaGVkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5uZXh0KHRoaXMuY29udHJvbCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvLyBBbGxvd3MgYSBjb250cm9sIHRvIHB1c2ggYSBzdGF0dXMgY2hlY2sgdXBzdHJlYW0sIHN1Y2ggYXMgb24gYmx1clxuICB0cmlnZ2VyU3RhdHVzQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMubmV4dCh0aGlzLmNvbnRyb2wpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIHN1YnNjcmlwdGlvbnNcbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT3B0aW9uYWwsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuL2lmLWVycm9yLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xySWZFcnJvcl0nIH0pXG5leHBvcnQgY2xhc3MgQ2xySWZFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgc2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZlxuICApIHtcbiAgICBpZiAoIXRoaXMuc2VydmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHJJZkVycm9yIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIGEgZm9ybSBjb250cm9sIGNvbnRhaW5lciBlbGVtZW50IGxpa2UgY2xyLWlucHV0LWNvbnRhaW5lcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BsYXlFcnJvcihmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCdjbHJJZkVycm9yJykgZXJyb3I6IHN0cmluZztcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGRpc3BsYXllZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBzcGVjaWZpYyBlcnJvciB0byB0cmFjaywgY2hlY2sgaXQsIG90aGVyd2lzZSBjaGVjayBvdmVyYWxsIHZhbGlkaXR5XG4gICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcihjb250cm9sLmhhc0Vycm9yKHRoaXMuZXJyb3IpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheUVycm9yKGNvbnRyb2wuaW52YWxpZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBkaXNwbGF5RXJyb3IoaW52YWxpZDogYm9vbGVhbikge1xuICAgIGlmIChpbnZhbGlkICYmICF0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWludmFsaWQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmxldCBjb3VudGVyID0gMDtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbnRyb2xJZFNlcnZpY2Uge1xuICBwcml2YXRlIF9pZCA9ICdjbHItZm9ybS1jb250cm9sLScgKyArK2NvdW50ZXI7XG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuICBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgdGhpcy5faWRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9pZENoYW5nZTogQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuX2lkKTtcbiAgcHVibGljIGdldCBpZENoYW5nZSgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9pZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBlbnVtIExheW91dHMge1xuICBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCcsXG4gIEhPUklaT05UQUwgPSAnaG9yaXpvbnRhbCcsXG4gIENPTVBBQ1QgPSAnY29tcGFjdCcsXG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMYXlvdXRTZXJ2aWNlIHtcbiAgbGF5b3V0OiBMYXlvdXRzID0gTGF5b3V0cy5WRVJUSUNBTDtcbiAgLy8gVGhpcyBpcyBiYXNpY2FsbHkgYSByZXBsYWNlbWVudCBmb3IgT2JqZWN0LnZhbHVlcygpLCB3aGljaCBJRTExIGFuZCBOb2RlIDw5IGRvbid0IHN1cHBvcnQgOihcbiAgLy8gU3RyaW5nIGVudW1zIGNhbm5vdCBiZSByZXZlcnNlLW1hcHBlZCwgbWVhbmluZyBMYXlvdXRzWydDT01QQUNUJ10gZG9lcyBub3QgcmV0dXJuICdjb21wYWN0JyBzb1xuICAvLyB0aGlzIGV4aXN0cyB0byBkZWFsIHdpdGggdGhpcyBsaXR0bGUgY2F2ZWF0IHRvIGdldCB0aGUgbGlzdCBvZiB0aGUgdmFsdWVzIGFzIGFuIGFycmF5LlxuICBwcml2YXRlIGxheW91dFZhbHVlczogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhMYXlvdXRzKS5tYXAoa2V5ID0+IExheW91dHNba2V5XSk7XG5cbiAgaXNWZXJ0aWNhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09IExheW91dHMuVkVSVElDQUw7XG4gIH1cblxuICBnZXQgbGF5b3V0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNsci1mb3JtLSR7dGhpcy5sYXlvdXR9YDtcbiAgfVxuXG4gIGlzVmFsaWQobGF5b3V0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXRWYWx1ZXMuaW5kZXhPZihsYXlvdXQpID4gLTE7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3B0aW9uYWwsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdsYWJlbCcgfSlcbmV4cG9ydCBjbGFzcyBDbHJMYWJlbCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sSWRTZXJ2aWNlOiBDb250cm9sSWRTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWZcbiAgKSB7fVxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5mb3InKVxuICBASW5wdXQoJ2ZvcicpXG4gIGZvckF0dHI6IHN0cmluZztcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLy8gT25seSBhZGQgdGhlIGNsci1jb250cm9sLWxhYmVsIGlmIGl0IGlzIGluc2lkZSBhIGNvbnRyb2wgY29udGFpbmVyXG4gICAgaWYgKHRoaXMuY29udHJvbElkU2VydmljZSB8fCB0aGlzLm5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xyLWNvbnRyb2wtbGFiZWwnKTtcbiAgICB9XG4gICAgLy8gT25seSBzZXQgdGhlIGdyaWQgY29sdW1uIGNsYXNzZXMgaWYgd2UgYXJlIGluIHRoZSByaWdodCBjb250ZXh0IGFuZCBpZiB0aGV5IGFyZW4ndCBhbHJlYWR5IHNldFxuICAgIGlmIChcbiAgICAgIHRoaXMubGF5b3V0U2VydmljZSAmJlxuICAgICAgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkgJiZcbiAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudCAmJlxuICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKCdjbHItY29sJykgPCAwXG4gICAgKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2Nsci1jb2wteHMtMTInKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xyLWNvbC1tZC0yJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRyb2xJZFNlcnZpY2UgJiYgIXRoaXMuZm9yQXR0cikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkQ2hhbmdlLnN1YnNjcmliZShpZCA9PiAodGhpcy5mb3JBdHRyID0gaWQpKSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgSVNfTkVXX0ZPUk1TX0xBWU9VVCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxib29sZWFuPignSVNfTkVXX0ZPUk1TX0xBWU9VVCcpO1xuZXhwb3J0IGNvbnN0IElTX05FV19GT1JNU19MQVlPVVRfVFJVRV9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogSVNfTkVXX0ZPUk1TX0xBWU9VVCxcbiAgdXNlVmFsdWU6IHRydWUsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgSVNfTkVXX0ZPUk1TX0xBWU9VVF9UUlVFX1BST1ZJREVSIH0gZnJvbSAnLi9wcm92aWRlcnMvbmV3LWZvcm1zLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRm9ybV0nLFxuICBwcm92aWRlcnM6IFtMYXlvdXRTZXJ2aWNlLCBJU19ORVdfRk9STVNfTEFZT1VUX1RSVUVfUFJPVklERVJdLFxuICBob3N0OiB7ICdbY2xhc3MuY2xyLWZvcm1dJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckZvcm0ge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTGF5b3V0cywgTGF5b3V0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsckxheW91dF0nLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzc10nOiAnbGF5b3V0U2VydmljZS5sYXlvdXRDbGFzcycsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckxheW91dCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgnY2xyTGF5b3V0JykgbGF5b3V0OiBMYXlvdXRzO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8vIE9ubHkgc2V0IHRoZSBsYXlvdXQgaWYgaXQgaXMgYSB2YWxpZCBvcHRpb25cbiAgICBpZiAodGhpcy5sYXlvdXQgJiYgdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmFsaWQodGhpcy5sYXlvdXQpKSB7XG4gICAgICB0aGlzLmxheW91dFNlcnZpY2UubGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQ29udHJvbEVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBDbHJDb250cm9sSGVscGVyIH0gZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgQ2xySWZFcnJvciB9IGZyb20gJy4vaWYtZXJyb3IvaWYtZXJyb3InO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuL2xhYmVsJztcbmltcG9ydCB7IENsckZvcm0gfSBmcm9tICcuL2Zvcm0nO1xuaW1wb3J0IHsgQ2xyTGF5b3V0IH0gZnJvbSAnLi9sYXlvdXQnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xyTGFiZWwsIENsckNvbnRyb2xFcnJvciwgQ2xyQ29udHJvbEhlbHBlciwgQ2xySWZFcnJvciwgQ2xyRm9ybSwgQ2xyTGF5b3V0XSxcbiAgZXhwb3J0czogW0NsckxhYmVsLCBDbHJDb250cm9sRXJyb3IsIENsckNvbnRyb2xIZWxwZXIsIENscklmRXJyb3IsIENsckZvcm0sIENsckxheW91dF0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNvbW1vbkZvcm1zTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jaGVja2JveC13cmFwcGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyQ2hlY2tib3hdXCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbFwiPjwvbGFiZWw+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1jaGVja2JveC13cmFwcGVyXSc6ICd0cnVlJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbQ29udHJvbElkU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94V3JhcHBlciBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyIHtcbiAgLy8gV2UgbmVlZCBib3RoIF9keW5hbWljIGZvciBIb3N0V3JhcHBlciBhbmQgQ29udGVudENoaWxkKENsckxhYmVsKSBpbiBjYXNlcyB3aGVyZVxuICAvLyB0aGUgdXNlciBwdXRzIGEgcmFkaW8gaW5zaWRlIGEgd3JhcHBlciB3aXRob3V0IGEgbGFiZWwsIGhvc3Qgd3JhcHBpbmcgZG9lc24ndCBhcHBseVxuICAvLyBidXQgd2UnZCBzdGlsbCBuZWVkIHRvIGluc2VydCBhIGxhYmVsXG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29udHJvbENsYXNzU2VydmljZSB7XG4gIGNsYXNzTmFtZSA9ICcnO1xuXG4gIGNvbnRyb2xDbGFzcyhpbnZhbGlkID0gZmFsc2UsIGdyaWQgPSBmYWxzZSwgYWRkaXRpb25hbCA9ICcnKSB7XG4gICAgY29uc3QgY29udHJvbENsYXNzZXMgPSBbdGhpcy5jbGFzc05hbWUsIGFkZGl0aW9uYWxdO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICBjb250cm9sQ2xhc3Nlcy5wdXNoKCdjbHItZXJyb3InKTtcbiAgICB9XG4gICAgaWYgKGdyaWQgJiYgdGhpcy5jbGFzc05hbWUuaW5kZXhPZignY2xyLWNvbCcpID09PSAtMSkge1xuICAgICAgY29udHJvbENsYXNzZXMucHVzaCgnY2xyLWNvbC1tZC0xMCBjbHItY29sLXhzLTEyJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250cm9sQ2xhc3Nlcy5qb2luKCcgJykudHJpbSgpO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byByZW1vdmUgdGhlIGNvbHVtbiBjbGFzc2VzIGZyb20gdGhlIGlucHV0IHVwIHRvIHRoZSBjb250YWluZXJcbiAgaW5pdENvbnRyb2xDbGFzcyhyZW5kZXJlciwgZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmNsYXNzTmFtZSkge1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZTtcbiAgICAgIGNvbnN0IGtsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgICAga2xhc3Nlcy5mb3JFYWNoKGtsYXNzID0+IHtcbiAgICAgICAgaWYgKGtsYXNzLnN0YXJ0c1dpdGgoJ2Nsci1jb2wnKSkge1xuICAgICAgICAgIHJlbmRlcmVyLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGtsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBDb21wb25lbnRGYWN0b3J5LFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdGlvblRva2VuLFxuICBJbmplY3RvcixcbiAgVHlwZSxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgRW1wdHlBbmNob3IgfSBmcm9tICcuL2VtcHR5LWFuY2hvcic7XG5cbi8qKlxuICogSG9zdFdyYXBwZXIgbXVzdCBiZSBjYWxsZWQgaW4gT25Jbml0IHRvIGVuc3VyZSB0aGF0IHRoZSBWaWV3cyBhcmUgcmVhZHkuIElmIGl0cyBjYWxsZWQgaW4gYSBjb25zdHJ1Y3RvciB0aGUgdmlldyBpc1xuICogc3RpbGwgdW5kZWZpbmVkLlxuICogVE9ETyAtIG1ha2Ugc3VyZSB0aGVzZSBjb21tZW50IGFubm90YXRpb25zIGRvIG5vdCBicmVhayBuZy1wYWNrZ3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb3N0V3JhcHBlcjxXIGV4dGVuZHMgRHluYW1pY1dyYXBwZXI+IGltcGxlbWVudHMgSW5qZWN0b3Ige1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJUeXBlOiBUeXBlPFc+LCB2Y3I6IFZpZXdDb250YWluZXJSZWYsIGluZGV4OiBudW1iZXIgPSAwKSB7XG4gICAgdGhpcy5pbmplY3RvciA9IHZjci5pbmplY3RvcjtcbiAgICAvLyBJZiB0aGUgaG9zdCBpcyBhbHJlYWR5IHdyYXBwZWQsIHdlIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKCF0aGlzLmluamVjdG9yLmdldChjb250YWluZXJUeXBlLCBudWxsKSkge1xuICAgICAgY29uc3QgY2ZyID0gdGhpcy5pbmplY3Rvci5nZXQoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKTtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5pbmplY3Rvci5nZXQoRWxlbWVudFJlZik7XG5cbiAgICAgIC8vIFdlIG5lZWQgYSBuZXcgYW5jaG9yLCBzaW5jZSB3ZSdyZSBwcm9qZWN0aW5nIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgIHZjci5jcmVhdGVDb21wb25lbnQoY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KEVtcHR5QW5jaG9yKSk7XG4gICAgICBjb25zdCBmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PFc+ID0gY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbnRhaW5lclR5cGUpO1xuICAgICAgLy8gQ3JhZnQgdGhlIGVsZW1lbnQgYXJyYXkgYmFzZWQgb24gd2hhdCBzbG90IHRvIHVzZS4gQW5ndWxhciBvbmx5IHVzZXMgdGhlIGluZGV4IHRvIGRldGVybWluZVxuICAgICAgLy8gd2hpY2ggbmctY29udGVudCB0byBwcm9qZWN0IGludG8sIHNvIGlmIHlvdSBoYXZlIG1vcmUgdGhhbiBvbmUgbmctY29udGVudCB5b3UnbGwgbmVlZCB0byBzZXRcbiAgICAgIC8vIHRoZSBpbmRleCBpbiB0aGUgY29uc3RydWN0b3IgYXBwcm9wcmlhdGVseVxuICAgICAgY29uc3QgZWxlbWVudCA9IFtdO1xuICAgICAgZWxlbWVudFtpbmRleF0gPSBbZWwubmF0aXZlRWxlbWVudF07XG4gICAgICAvLyBXZSdyZSBhc3N1bWluZyBvbmx5IG9uZSBwcm9qZWN0aW9uIHNsb3QsIGJ1dCBpbiBtb3JlIGNvbXBsZXggY2FzZXMgd2UgbWlnaHQgd2FudCB0byBwcm92aWRlXG4gICAgICAvLyBhIGRpZmZlcmVudCBhcnJheSBvZiBwcm9qZWN0ZWQgZWxlbWVudHMuXG4gICAgICBjb25zdCBjb250YWluZXJSZWYgPSB2Y3IuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBlbGVtZW50KTtcbiAgICAgIC8vIFdlIGNhbiBub3cgcmVtb3ZlIHRoZSB1c2VsZXNzIGFuY2hvclxuICAgICAgdmNyLnJlbW92ZSgwKTtcblxuICAgICAgLy8gV2Ugbm90ZSB0aGF0IHRoZSBjb250YWluZXIgd2FzIGR5bmFtaWNhbGx5IGNyZWF0ZWRcbiAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5fZHluYW1pYyA9IHRydWU7XG5cbiAgICAgIC8vIFdlIGtlZXAgdGhlIHdyYXBwZXIncyBpbmplY3RvciB0byBhY2Nlc3MgdGhlIGRlcGVuZGVuY2llcyB0aGF0IHdlcmVuJ3QgYXZhaWxhYmxlIGJlZm9yZS5cbiAgICAgIHRoaXMuaW5qZWN0b3IgPSBjb250YWluZXJSZWYuaW5qZWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgZ2V0PFQ+KHRva2VuOiBUeXBlPFQ+IHwgSW5qZWN0aW9uVG9rZW48VD4sIG5vdEZvdW5kVmFsdWU/OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEhvc3RCaW5kaW5nLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IsIElucHV0LCBPbkluaXQsIFR5cGUsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5cbmV4cG9ydCBjbGFzcyBXcmFwcGVkRm9ybUNvbnRyb2w8VyBleHRlbmRzIER5bmFtaWNXcmFwcGVyPiBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8vIEkgbG9zdCB3YXkgdG9vIG11Y2ggdGltZSB0cnlpbmcgdG8gbWFrZSB0aGlzIHdvcmsgd2l0aG91dCBpbmplY3RpbmcgdGhlIFZpZXdDb250YWluZXJSZWYgYW5kIHRoZSBJbmplY3RvcixcbiAgLy8gSSdtIGdpdmluZyB1cC4gU28gd2UgaGF2ZSB0byBpbmplY3QgdGhlc2UgdHdvIG1hbnVhbGx5IGZvciBub3cuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB3cmFwcGVyVHlwZTogVHlwZTxXPiwgcHJvdGVjdGVkIHZjcjogVmlld0NvbnRhaW5lclJlZiwgcHJvdGVjdGVkIGluZGV4OiBudW1iZXIgPSAwKSB7fVxuXG4gIHByb3RlY3RlZCBjb250cm9sSWRTZXJ2aWNlOiBDb250cm9sSWRTZXJ2aWNlO1xuXG4gIF9pZDogc3RyaW5nO1xuXG4gIEBIb3N0QmluZGluZygpXG4gIEBJbnB1dCgpXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmNvbnRyb2xJZFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuY29udHJvbElkU2VydmljZS5pZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NvbnRhaW5lckluamVjdG9yOiBJbmplY3RvcjtcblxuICBwcm90ZWN0ZWQgZ2V0UHJvdmlkZXJGcm9tQ29udGFpbmVyPFQ+KHRva2VuOiBUeXBlPFQ+IHwgSW5qZWN0aW9uVG9rZW48VD4sIG5vdEZvdW5kVmFsdWU/OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lckluamVjdG9yLmdldCh0b2tlbiwgbm90Rm91bmRWYWx1ZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9jb250YWluZXJJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcih0aGlzLndyYXBwZXJUeXBlLCB0aGlzLnZjciwgdGhpcy5pbmRleCk7XG4gICAgdGhpcy5jb250cm9sSWRTZXJ2aWNlID0gdGhpcy5fY29udGFpbmVySW5qZWN0b3IuZ2V0KENvbnRyb2xJZFNlcnZpY2UpO1xuICAgIGlmICh0aGlzLl9pZCkge1xuICAgICAgdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkID0gdGhpcy5faWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lkID0gdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkO1xuICAgIH1cbiAgICAvLyBObyBuZWVkIHRvIHN1YnNjcmliZSB0byBjb250cm9sSWRTZXJ2aWNlLmlkQ2hhbmdlIGJlY2F1c2UgdGhlIGlucHV0IGlzIHRoZSBvbmx5IG9uZSB0aGF0IGNhbiB1cGRhdGUgdGhlIGlkLlxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkluaXQsIE9wdGlvbmFsLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBDbHJDaGVja2JveFdyYXBwZXIgfSBmcm9tICcuL2NoZWNrYm94LXdyYXBwZXInO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJDaGVja2JveF0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3ggZXh0ZW5kcyBXcmFwcGVkRm9ybUNvbnRyb2w8Q2xyQ2hlY2tib3hXcmFwcGVyPiBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBlbDogRWxlbWVudFJlZixcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyXG4gICkge1xuICAgIHN1cGVyKENsckNoZWNrYm94V3JhcHBlciwgdmNyLCAwKTtcbiAgICBpZiAoY29udHJvbENsYXNzU2VydmljZSkge1xuICAgICAgY29udHJvbENsYXNzU2VydmljZS5pbml0Q29udHJvbENsYXNzKHJlbmRlcmVyLCBlbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIGlmICh0aGlzLm5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5zZXRDb250cm9sKHRoaXMuY29udHJvbCk7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignYmx1cicpXG4gIG9uQmx1cigpIHtcbiAgICBpZiAodGhpcy5pZkVycm9yU2VydmljZSkge1xuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS50cmlnZ2VyU3RhdHVzQ2hhbmdlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5wdXQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IENsckxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItY2hlY2tib3gtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW2NsYXNzLmNsci1jb250cm9sLWlubGluZV09XCJjbHJJbmxpbmVcIiBbbmdDbGFzc109XCJjb250cm9sQ2xhc3MoKVwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNoZWNrYm94LXdyYXBwZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2xyLXN1YnRleHQtd3JhcHBlclwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlLCBJZkVycm9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94Q29udGFpbmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgcHJpdmF0ZSBpbmxpbmUgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuICAvLyBwcml2YXRlIGZvcm1Hcm91cDogQWJzdHJhY3RDb250cm9sO1xuXG4gIC8qXG4gICAqIEhlcmUgd2Ugd2FudCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmcgY2FzZXNcbiAgICogY2xySW5saW5lIC0gdHJ1ZSBieSBwcmVzZW5jZVxuICAgKiBjbHJJbmxpbmU9XCJ0cnVlfGZhbHNlXCIgLSB1bmxlc3MgaXQgaXMgZXhwbGljaXRseSBmYWxzZSwgc3RyaW5ncyBhcmUgY29uc2lkZXJlZCB0cnVlXG4gICAqIFtjbHJJbmxpbmVdPVwidHJ1ZXxmYWxzZVwiIC0gZXhwZWN0IGEgYm9vbGVhblxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGNscklubGluZSh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmlubGluZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlubGluZSA9ICEhdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjbHJJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5saW5lO1xuICB9XG5cbiAgLy8gQFRPRE8gU29sdmUgZm9yIGdyb3VwIHZhbGlkYXRpb24sIHdoaWNoIGRvZXNuJ3Qgd29yayBub3cgd2l0aCBuZ01vZGVsR3JvdXBcbiAgLy8gQmxvY2tlZCBieSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8yMDI2OFxuICAvLyBASW5wdXQoKVxuICAvLyBzZXQgY2xyRm9ybUdyb3VwKHZhbHVlOiBGb3JtR3JvdXApIHtcbiAgLy8gICB0aGlzLmZvcm1Hcm91cCA9IHZhbHVlO1xuICAvLyB9XG5cbiAgLy8gQElucHV0KClcbiAgLy8gc2V0IGNsckZvcm1BcnJheSh2YWx1ZTogRm9ybUFycmF5KSB7XG4gIC8vICAgdGhpcy5mb3JtR3JvdXAgPSB2YWx1ZTtcbiAgLy8gfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8vIEBUT0RPIHB1dCBhIHNvbHV0aW9uIGluIGZvciBmb3JtIGdyb3VwIHZhbGlkYXRpb25cbiAgICAvLyBpZiAoIXRoaXMuZm9ybUdyb3VwKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBjb250cm9sLmludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIC8vIEJlY2F1c2UgbmdNb2RlbCBkb2VzIHRoaXMsIHdlIGhhdmUgdG8gZGVsYXkgYSB0aWNrIHRvIGdldCB0aGUgcmVzdWx0XG4gICAgLy8gICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAvLyAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgLy8gICAgICAgdGhpcy5mb3JtR3JvdXAuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIC8vICAgICAgICAgdGhpcy5pbnZhbGlkID0gdGhpcy5mb3JtR3JvdXAuaW52YWxpZDtcbiAgICAvLyAgICAgICB9KVxuICAgIC8vICAgICApO1xuICAgIC8vICAgfSk7XG4gICAgLy8gfVxuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCksIHRoaXMuaW5saW5lID8gJ2Nsci1jb250cm9sLWlubGluZScgOiAnJyk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJIb3N0V3JhcHBpbmdNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBpbmcubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgQ2xyQ2hlY2tib3hDb250YWluZXIgfSBmcm9tICcuL2NoZWNrYm94LWNvbnRhaW5lcic7XG5pbXBvcnQgeyBDbHJDaGVja2JveFdyYXBwZXIgfSBmcm9tICcuL2NoZWNrYm94LXdyYXBwZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xySG9zdFdyYXBwaW5nTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xyQ2hlY2tib3gsIENsckNoZWNrYm94Q29udGFpbmVyLCBDbHJDaGVja2JveFdyYXBwZXJdLFxuICBleHBvcnRzOiBbQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsckNoZWNrYm94LCBDbHJDaGVja2JveENvbnRhaW5lciwgQ2xyQ2hlY2tib3hXcmFwcGVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyQ2hlY2tib3hXcmFwcGVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmxldCBhY3RpdmVDb3VudGVyID0gMDtcblxuZXhwb3J0IGNvbnN0IElGX0FDVElWRV9JRCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxudW1iZXI+KCdJRl9BQ1RJVkVfSUQnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuRmFjdG9yeSgpIHtcbiAgcmV0dXJuICsrYWN0aXZlQ291bnRlcjtcbn1cblxuZXhwb3J0IGNvbnN0IElGX0FDVElWRV9JRF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogSUZfQUNUSVZFX0lELFxuICB1c2VGYWN0b3J5OiB0b2tlbkZhY3RvcnksXG59O1xuXG5ASW5qZWN0YWJsZSgpXG5cbi8qKioqKioqKipcbiAqIEBjbGFzcyBJZkFjdGl2ZVNlcnZpY2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuIGluamVjdGFibGUgc2VydmljZSB1c2VkIGJ5IElmQWN0aXZlIHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBhbmQgdGhlIGNvbXBvbmVudHMgdGhhdCBpbXBsZW1lbnQgSWZBY3RpdmUgaW4gdGhlaXJcbiAqIHRlbXBsYXRlcy4gSXQgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBwcm92aWRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgYm90aCB0aGUgZGlyZWN0aXZlIGFuZCB0aGVcbiAqIGltcGxlbWVudGluZyBjb21wb25lbnQgY2FuIHN1YnNjcmliZSB0byBpbiBvcmRlciB0byB0YWtlIGFjdGlvbiBvbiBjdXJyZW50IHZhbHVlIGNoYW5nZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgSWZBY3RpdmVTZXJ2aWNlIHtcbiAgLyoqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBfY3VycmVudENoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBSWEpTIFN1YmplY3QgdGhhdCB1cGRhdGVzIGFuZCBwcm92aWRlcyBzdWJzY3JpcHRpb25zIHRvIGZvciB0aGUgY3VycmVudCBjdXJyZW50IHN0YXRlIG9mIGEgY29tcG9uZW50IHRlbXBsYXRlXG4gICAqIGltcGxlbXRpbmcgdGhlIElmQWN0aXZlIHN0cnVjdHVyYWwgZGlyZWN0aXZlLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudENoYW5nZTogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuXG4gIC8qKioqKioqKipcbiAgICogQHByb3BlcnR5IF9jdXJyZW50XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHByb3BlcnR5IGhvbGRpbmcgdGhlIGN1cnJlbnQgdmFsdWUgZm9yIGN1cnJlbnQvY2xvc2VkIHN0YXRlIG9mIGFuIElmQWN0aXZlIHN0cnVjdHVyYWwgZGlyZWN0aXZlLlxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudDogbnVtYmVyO1xuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBmb3IgdGhlIF9jdXJyZW50IFN1YmplY3QuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBfY3VycmVudCBmb3IgdGhpcyBpbnN0YW5jZSBvZiBJZkFjdGl2ZSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICogQW5kLCBicm9hZGNhc3RzIHRoZSBuZXcgdmFsdWUgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgY3VycmVudCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG4gICAgICB0aGlzLl9jdXJyZW50Q2hhbmdlLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzIElmQWN0aXZlIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElGX0FDVElWRV9JRCwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi9pZi1hY3RpdmUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkFjdGl2ZV0nIH0pXG5cbi8qKioqKioqKioqXG4gKlxuICogQGNsYXNzIENscklmQWN0aXZlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRoYXQgY29udHJvbHMgd2hldGhlciBvciBub3QgdGhlIGFzc29jaWF0ZWQgVGVtcGxhdGVSZWYgaXMgaW5zdGFudGlhdGVkIG9yIG5vdC5cbiAqIEl0IG1ha2VzIHVzZSBvZiBhIENvbXBvbmVudCBpbnN0YW5jZSBsZXZlbCBzZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UgdG8gbWFpbnRhaW4gc3RhdGUgYmV0d2VlbiBpdHNlbGYgYW5kXG4gKiB0aGUgY29tcG9uZW50IHVzaW5nIGl0IGluIHRoZSBjb21wb25lbnQgdGVtcGxhdGUuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xySWZBY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIHdhc0FjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgQEluamVjdChJRl9BQ1RJVkVfSUQpIHByaXZhdGUgaWQ6IG51bWJlcixcbiAgICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIHRoaXMuY2hlY2tBbmRVcGRhdGVWaWV3KGlmQWN0aXZlU2VydmljZS5jdXJyZW50KTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudENoYW5nZS5zdWJzY3JpYmUobmV3Q3VycmVudElkID0+IHtcbiAgICAgIHRoaXMuY2hlY2tBbmRVcGRhdGVWaWV3KG5ld0N1cnJlbnRJZCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrQW5kVXBkYXRlVmlldyhjdXJyZW50SWQ6IG51bWJlcikge1xuICAgIGNvbnN0IGlzTm93QWN0aXZlID0gY3VycmVudElkID09PSB0aGlzLmlkO1xuICAgIC8vIG9ubHkgZW1pdCBpZiB0aGUgbmV3IGFjdGl2ZSBzdGF0ZSBpcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdGltZS5cbiAgICBpZiAoaXNOb3dBY3RpdmUgIT09IHRoaXMud2FzQWN0aXZlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXcoaXNOb3dBY3RpdmUpO1xuICAgICAgdGhpcy5hY3RpdmVDaGFuZ2UuZW1pdChpc05vd0FjdGl2ZSk7XG4gICAgICB0aGlzLndhc0FjdGl2ZSA9IGlzTm93QWN0aXZlO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgc2V0dGVyIHRoYXQgdXBkYXRlcyBJZkFjdGl2ZVNlcnZpY2UuYWN0aXZlIHdpdGggdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgQElucHV0KCdjbHJJZkFjdGl2ZScpXG4gIHB1YmxpYyBzZXQgYWN0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50ID0gdGhpcy5pZDtcbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKiBAcHJvcGVydHkgYWN0aXZlQ2hhbmdlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBldmVudCBlbWl0dGVyIHRoYXQgZW1pdHMgd2hlbiB0aGUgYWN0aXZlIHByb3BlcnR5IGlzIHNldCB0byBhbGxvdyBmb3IgMndheSBiaW5kaW5nIHdoZW4gdGhlIGRpcmVjdGl2ZSBpc1xuICAgKiB1c2VkIHdpdGggZGUtc3RydWN0dXJlZCAvIGRlLXN1Z2FyZWQgc3ludGF4LlxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xySWZBY3RpdmVDaGFuZ2UnKSBhY3RpdmVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8qKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IElmQWN0aXZlU2VydmljZS5hY3RpdmUgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBhbnkgdmFsdWUgYW5kIGVpdGhlciBjcmVhdGVkIGFuIGVtYmVkZGVkIHZpZXcgZm9yIHRoZSBhc3NvY2lhdGVkIFZpZXdDb250YWluZXJSZWYgb3IsXG4gICAqIENsZWFycyBhbGwgdmlld3MgZnJvbSB0aGUgVmlld0NvbnRhaW5lclJlZlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVWaWV3KHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5cbi8qKioqKioqKipcbiAqIEBjbGFzcyBJZk9wZW5TZXJ2aWNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgdXNlZCBieSBJZk9wZW4gc3RydWN0dXJhbCBkaXJlY3RpdmVzIGFuZCB0aGUgY29tcG9uZW50cyB0aGF0IGltcGxlbW50IElmT3BlbiBpbiB0aGVpclxuICogdGVtcGxhdGVzLiBJdCBob2xkcyB0aGUgdmFsdWUgb2YgdGhlIG9wZW4gc3RhdGUgYW5kIHByb3ZpZGVzIGFuIE9ic2VydmFibGUgdGhhdCBib3RoIHRoZSBkaXJlY3RpdmUgYW5kIHRoZVxuICogaW1wbGVtZW50aW5nIGNvbXBvbmVudCBjYW4gc3Vic2NyaWJlIHRvIGluIG9yZGVyIHRvIHRha2UgYWN0aW9uIG9uIG9wZW4gdmFsdWUgY2hhbmdlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBJZk9wZW5TZXJ2aWNlIHtcbiAgLyoqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBfb3BlbkNoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBSWEpTIFN1YmplY3QgdGhhdCB1cGRhdGVzIGFuZCBwcm92aWRlcyBzdWJzY3JpcHRpb25zIHRvIGZvciB0aGUgY3VycmVudCBvcGVuIHN0YXRlIG9mIGEgY29tcG9uZW50IHRlbXBsYXRlXG4gICAqIGltcGxlbXRpbmcgdGhlIElmT3BlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICovXG4gIHByaXZhdGUgX29wZW5DaGFuZ2U6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKioqKioqKipcbiAgICogQHByb3BlcnR5IF9vcGVuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHByb3BlcnR5IGhvbGRpbmcgdGhlIGN1cnJlbnQgdmFsdWUgZm9yIG9wZW4vY2xvc2VkIHN0YXRlIG9mIGFuIElmT3BlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX29wZW46IGJvb2xlYW47XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBhbiBvYnNlcnZhYmxlIGZvciB0aGUgX29wZW5lZCBTdWJqZWN0LlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBvcGVuQ2hhbmdlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9vcGVuQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIF9vcGVuIGZvciB0aGlzIGluc3RhbmNlIG9mIElmT3BlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS4gQW5kLFxuICAgKiBicm9hZGNhc3RzIHRoZSBuZXcgdmFsdWUgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgb3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5fb3BlbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX29wZW4gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX29wZW5DaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoaXMgSWZPcGVuIGluc3RhbmNlLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBvcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvbWV0aW1lcywgd2UgbmVlZCB0byByZW1lbWJlciB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHRvZ2dsaW5nIHRvIGF2b2lkIGxvb3BzLlxuICAgKiBUaGlzIGlzIGZvciBpbnN0YW5jZSB0aGUgY2FzZSBvZiBjb21wb25lbnRzIHRoYXQgb3BlbiBvbiBhIGNsaWNrLCBidXQgY2xvc2Ugb24gYSBjbGljayBvdXRzaWRlLlxuICAgKi9cbiAgcHVibGljIG9yaWdpbmFsRXZlbnQ6IGFueTtcbiAgcHVibGljIHRvZ2dsZVdpdGhFdmVudChldmVudDogYW55KSB7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcbiAgICBkZWxldGUgdGhpcy5vcmlnaW5hbEV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqICBQb3BvdmVycyBtaWdodCBuZWVkIHRvIGlnbm9yZSBjbGljayBldmVudHMgb24gYW4gZWxlbWVudFxuICAgKiAgKGVnOiBwb3BvdmVyIG9wZW5zIG9uIGZvY3VzIG9uIGFuIGlucHV0IGZpZWxkLiBDbGlja3Mgc2hvdWxkIGJlIGlnbm9yZWQgaW4gdGhpcyBjYXNlKVxuICAgKi9cbiAgcHJpdmF0ZSBfaWdub3JlZEVsZW1lbnRDaGFuZ2U6IFN1YmplY3Q8RWxlbWVudFJlZj4gPSBuZXcgU3ViamVjdDxFbGVtZW50UmVmPigpO1xuXG4gIGdldCBpZ25vcmVkRWxlbWVudENoYW5nZSgpOiBPYnNlcnZhYmxlPEVsZW1lbnRSZWY+IHtcbiAgICByZXR1cm4gdGhpcy5faWdub3JlZEVsZW1lbnRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICByZWdpc3Rlcklnbm9yZWRFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLl9pZ25vcmVkRWxlbWVudENoYW5nZS5uZXh0KGVsZW1lbnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuL2lmLW9wZW4uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZk9wZW5dJyB9KVxuXG4vKioqKioqKioqKlxuICpcbiAqIEBjbGFzcyBDbHJJZk9wZW5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RydWN0dXJhbCBkaXJlY3RpdmUgdGhhdCBjb250cm9scyB3aGV0aGVyIG9yIG5vdCB0aGUgYXNzb2NpYXRlZCBUZW1wbGF0ZVJlZiBpcyBpbnN0YW50aWF0ZWQgb3Igbm90LlxuICogSXQgbWFrZXMgdXNlIG9mIGEgQ29tcG9uZW50IGluc3RhbmNlIGxldmVsIHNlcnZpY2U6IElmT3BlblNlcnZpY2UgdG8gbWFpbnRhaW4gc3RhdGUgYmV0d2VlbiBpdHNlbGYgYW5kIHRoZSBjb21wb25lbnRcbiAqIHVzaW5nIGl0IGluIHRoZSBjb21wb25lbnQgdGVtcGxhdGUuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xySWZPcGVuIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHNldHRlciB0aGF0IHVwZGF0ZXMgSWZPcGVuU2VydmljZS5vcGVuIHdpdGggdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgQElucHV0KCdjbHJJZk9wZW4nKVxuICBwdWJsaWMgc2V0IG9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IG9wZW5DaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBlbWl0cyB3aGVuIHRoZSBvcGVuIHByb3BlcnR5IGlzIHNldCB0byBhbGxvdyBmb3IgMndheSBiaW5kaW5nIHdoZW4gdGhlIGRpcmVjdGl2ZSBpc1xuICAgKiB1c2VkIHdpdGggZGUtc3RydWN0dXJlZCAvIGRlLXN1Z2FyZWQgc3ludGF4LlxuICAgKi9cbiAgQE91dHB1dCgnY2xySWZPcGVuQ2hhbmdlJykgb3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgLyoqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgSWZPcGVuU2VydmljZS5vcGVuIHZhbHVlLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBvcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSxcbiAgICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXcoY2hhbmdlKTtcbiAgICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KGNoYW5nZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGdW5jdGlvbiB0aGF0IHRha2VzIGEgYm9vbGVhbiB2YWx1ZSBhbmQgZWl0aGVyIGNyZWF0ZWQgYW4gZW1iZWRkZWQgdmlldyBmb3IgdGhlIGFzc29jaWF0ZWQgVmlld0NvbnRhaW5lclJlZiBvcixcbiAgICogQ2xlYXJzIGFsbCB2aWV3cyBmcm9tIHRoZSBWaWV3Q29udGFpbmVyUmVmXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHVwZGF0ZVZpZXcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJJZkFjdGl2ZSB9IGZyb20gJy4vaWYtYWN0aXZlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJJZk9wZW4gfSBmcm9tICcuL2lmLW9wZW4uZGlyZWN0aXZlJztcblxuZXhwb3J0ICogZnJvbSAnLi9pZi1hY3RpdmUuZGlyZWN0aXZlJztcbmV4cG9ydCAqIGZyb20gJy4vaWYtb3Blbi5kaXJlY3RpdmUnO1xuXG5leHBvcnQgY29uc3QgQ09ORElUSU9OQUxfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xySWZBY3RpdmUsIENscklmT3Blbl07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ09ORElUSU9OQUxfRElSRUNUSVZFUyB9IGZyb20gJy4vaW5kZXgnO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbQ09ORElUSU9OQUxfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtDT05ESVRJT05BTF9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsckNvbmRpdGlvbmFsTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c1RyYXBEaXJlY3RpdmUgfSBmcm9tICcuL2ZvY3VzLXRyYXAuZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBGb2N1c1RyYXBUcmFja2VyIHtcbiAgcHJpdmF0ZSBfcHJldmlvdXNGb2N1c1RyYXBzOiBGb2N1c1RyYXBEaXJlY3RpdmVbXSA9IFtdO1xuICBwcml2YXRlIF9jdXJyZW50OiBGb2N1c1RyYXBEaXJlY3RpdmU7XG5cbiAgZ2V0IGN1cnJlbnQoKTogRm9jdXNUcmFwRGlyZWN0aXZlIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuXG4gIHNldCBjdXJyZW50KHZhbHVlOiBGb2N1c1RyYXBEaXJlY3RpdmUpIHtcbiAgICB0aGlzLl9wcmV2aW91c0ZvY3VzVHJhcHMucHVzaCh0aGlzLl9jdXJyZW50KTtcbiAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG4gIH1cblxuICBnZXQgbmJGb2N1c1RyYXBwZXJzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRm9jdXNUcmFwcy5sZW5ndGg7XG4gIH1cblxuICBhY3RpdmF0ZVByZXZpb3VzVHJhcHBlcigpIHtcbiAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fcHJldmlvdXNGb2N1c1RyYXBzLnBvcCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBET0NVTUVOVCwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdCxcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgUExBVEZPUk1fSUQsXG4gIFJlbmRlcmVyMixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZvY3VzVHJhcFRyYWNrZXIgfSBmcm9tICcuL2ZvY3VzLXRyYXAtdHJhY2tlci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckZvY3VzVHJhcF0nIH0pXG5leHBvcnQgY2xhc3MgRm9jdXNUcmFwRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBwcmV2aW91c0FjdGl2ZUVsZW1lbnQ6IGFueTtcbiAgcHJpdmF0ZSBkb2N1bWVudDogRG9jdW1lbnQ7XG5cbiAgcHJpdmF0ZSB0b3BSZWJvdW5kRWw6IGFueTtcbiAgcHJpdmF0ZSBib3R0b21SZWJvdW5kRWw6IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgZm9jdXNUcmFwc1RyYWNrZXI6IEZvY3VzVHJhcFRyYWNrZXIsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0XG4gICkge1xuICAgIHRoaXMuZG9jdW1lbnQgPSB0aGlzLmluamVjdG9yLmdldChET0NVTUVOVCk7XG4gICAgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5jdXJyZW50ID0gdGhpcztcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3RhYmluZGV4JywgJzAnKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmZvY3VzaW4nLCBbJyRldmVudCddKVxuICBvbkZvY3VzSW4oZXZlbnQ6IGFueSkge1xuICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuXG4gICAgaWYgKHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIuY3VycmVudCA9PT0gdGhpcyAmJiBldmVudC50YXJnZXQgJiYgIW5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgbmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRm9jdXNhYmxlT2ZmU2NyZWVuRWwoKTogYW55IHtcbiAgICBjb25zdCBvZmZTY3JlZW5TcGFuID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUob2ZmU2NyZWVuU3BhbiwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKG9mZlNjcmVlblNwYW4sICdvZmZzY3JlZW4tZm9jdXMtcmVib3VuZGVyJyk7XG5cbiAgICByZXR1cm4gb2ZmU2NyZWVuU3BhbjtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUmVib3VuZEVscygpIHtcbiAgICAvLyBXZSB3aWxsIGFkZCB0aGVzZSBmb2N1cyByZWJvdW5kaW5nIGVsZW1lbnRzIG9ubHkgaW4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgIC8vIDEuIEl0IHNob3VsZCBiZSBydW5uaW5nIGluc2lkZSBicm93c2VyIHBsYXRmb3JtIGFzIGl0IGFjY2Vzc2VzIGRvY3VtZW50LmJvZHkgZWxlbWVudFxuICAgIC8vIDIuIFdlIHNob3VsZCBOT1QgYWRkIHRoZW0gbW9yZSB0aGFuIG9uY2UuIEhlbmNlLCB3ZSBhcmUgY291bnRpbmcgYSBudW1iZXIgb2YgZm9jdXMgdHJhcHBlcnNcbiAgICAvLyAgICBhbmQgb25seSBhZGQgb24gdGhlIGZpcnN0IGZvY3VzIHRyYXBwZXIuXG5cbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLmZvY3VzVHJhcHNUcmFja2VyLm5iRm9jdXNUcmFwcGVycyA9PT0gMSkge1xuICAgICAgdGhpcy50b3BSZWJvdW5kRWwgPSB0aGlzLmNyZWF0ZUZvY3VzYWJsZU9mZlNjcmVlbkVsKCk7XG4gICAgICB0aGlzLmJvdHRvbVJlYm91bmRFbCA9IHRoaXMuY3JlYXRlRm9jdXNhYmxlT2ZmU2NyZWVuRWwoKTtcbiAgICAgIC8vIEFkZCByZWJvdW5kQmVmb3JlVHJhcEVsIHRvIHRoZSBkb2N1bWVudCBib2R5IGFzIHRoZSBmaXJzdCBjaGlsZFxuICAgICAgdGhpcy5yZW5kZXJlci5pbnNlcnRCZWZvcmUodGhpcy5kb2N1bWVudC5ib2R5LCB0aGlzLnRvcFJlYm91bmRFbCwgdGhpcy5kb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgLy8gQWRkIHJlYm91bmRBZnRlclRyYXBFbCB0byB0aGUgZG9jdW1lbnQgYm9keSBhcyB0aGUgbGFzdCBjaGlsZFxuICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLmRvY3VtZW50LmJvZHksIHRoaXMuYm90dG9tUmVib3VuZEVsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVJlYm91bmRFbHMoKSB7XG4gICAgaWYgKFxuICAgICAgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJlxuICAgICAgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5uYkZvY3VzVHJhcHBlcnMgPT09IDEgJiZcbiAgICAgIHRoaXMudG9wUmVib3VuZEVsICYmXG4gICAgICB0aGlzLmJvdHRvbVJlYm91bmRFbFxuICAgICkge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDaGlsZCh0aGlzLmRvY3VtZW50LmJvZHksIHRoaXMudG9wUmVib3VuZEVsKTtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQodGhpcy5kb2N1bWVudC5ib2R5LCB0aGlzLmJvdHRvbVJlYm91bmRFbCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldFByZXZpb3VzRm9jdXMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50ICYmIHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50LmZvY3VzKSB7XG4gICAgICB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgdGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+dGhpcy5kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIHRoaXMuYWRkUmVib3VuZEVscygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVSZWJvdW5kRWxzKCk7XG4gICAgdGhpcy5zZXRQcmV2aW91c0ZvY3VzKCk7XG4gICAgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5hY3RpdmF0ZVByZXZpb3VzVHJhcHBlcigpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c1RyYXBEaXJlY3RpdmUgfSBmcm9tICcuL2ZvY3VzLXRyYXAuZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IEZPQ1VTX1RSQVBfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbRm9jdXNUcmFwRGlyZWN0aXZlXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGT0NVU19UUkFQX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0ZPQ1VTX1RSQVBfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtGT0NVU19UUkFQX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJGb2N1c1RyYXBNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBjb25zdCBVUF9BUlJPVzogbnVtYmVyID0gMzg7XG5leHBvcnQgY29uc3QgRE9XTl9BUlJPVzogbnVtYmVyID0gNDA7XG5leHBvcnQgY29uc3QgUklHSFRfQVJST1c6IG51bWJlciA9IDM5O1xuZXhwb3J0IGNvbnN0IExFRlRfQVJST1c6IG51bWJlciA9IDM3O1xuZXhwb3J0IGNvbnN0IEVOVEVSOiBudW1iZXIgPSAxMztcbmV4cG9ydCBjb25zdCBTUEFDRTogbnVtYmVyID0gMzI7XG5leHBvcnQgY29uc3QgVEFCOiBudW1iZXIgPSA5O1xuZXhwb3J0IGNvbnN0IEVTQzogbnVtYmVyID0gMjc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZW4tMDAxIHNob3J0IGxvY2FsZSBkYXRlIGZvcm1hdC4gU2V0dGluZyBhcyBkZWZhdWx0LlxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9MT0NBTEVfRk9STUFUOiBzdHJpbmcgPSAnZGQvTU0veSc7XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhdGVfZm9ybWF0X2J5X2NvdW50cnlcbmV4cG9ydCBjb25zdCBMSVRUTEVfRU5ESUFOX1JFR0VYOiBSZWdFeHAgPSAvZCsuK20rLit5Ky9pO1xuZXhwb3J0IGNvbnN0IE1JRERMRV9FTkRJQU5fUkVHRVg6IFJlZ0V4cCA9IC9tKy4rZCsuK3krL2k7XG4vLyBObyBuZWVkIGZvciBCSUdfRU5ESUFOX1JFR0VYIGJlY2F1c2UgYW55dGhpbmcgdGhhdCBkb2Vzbid0IHNhdGlzZnkgdGhlIGFib3ZlIDJcbi8vIGlzIGF1dG9tYXRpY2FsbHkgQklHX0VORElBTlxuXG5leHBvcnQgY29uc3QgREVMSU1JVEVSX1JFR0VYOiBSZWdFeHAgPSAvZCt8bSt8eSsvaTtcblxuZXhwb3J0IGNvbnN0IFVTRVJfSU5QVVRfUkVHRVg6IFJlZ0V4cCA9IC9cXGQrL2c7XG5cbmV4cG9ydCBjb25zdCBNT0JJTEVfVVNFUkFHRU5UX1JFR0VYOiBSZWdFeHAgPSAvTW9iaS9pO1xuXG5leHBvcnQgY29uc3QgUlRMX1JFR0VYOiBSZWdFeHAgPSAvXFx1MjAwZi9nO1xuXG5leHBvcnQgY29uc3QgWUVBUjogc3RyaW5nID0gJ1lZWVknO1xuZXhwb3J0IGNvbnN0IE1PTlRIOiBzdHJpbmcgPSAnTU0nO1xuZXhwb3J0IGNvbnN0IERBVEU6IHN0cmluZyA9ICdERCc7XG5cbmV4cG9ydCB0eXBlIEZvcm1hdFR5cGUgPSAnTElUVExFX0VORElBTicgfCAnTUlERExFX0VORElBTicgfCAnQklHX0VORElBTic7XG5cbmV4cG9ydCB0eXBlIElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIHJlYWRvbmx5IG5hbWU6IEZvcm1hdFR5cGU7XG4gIHJlYWRvbmx5IGZvcm1hdDogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddO1xufTtcblxuZXhwb3J0IGNvbnN0IExJVFRMRV9FTkRJQU46IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIG5hbWU6ICdMSVRUTEVfRU5ESUFOJyxcbiAgZm9ybWF0OiBbREFURSwgTU9OVEgsIFlFQVJdLFxufTtcblxuZXhwb3J0IGNvbnN0IE1JRERMRV9FTkRJQU46IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIG5hbWU6ICdNSURETEVfRU5ESUFOJyxcbiAgZm9ybWF0OiBbTU9OVEgsIERBVEUsIFlFQVJdLFxufTtcblxuZXhwb3J0IGNvbnN0IEJJR19FTkRJQU46IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSB7XG4gIG5hbWU6ICdCSUdfRU5ESUFOJyxcbiAgZm9ybWF0OiBbWUVBUiwgTU9OVEgsIERBVEVdLFxufTtcblxuZXhwb3J0IGNvbnN0IE5PX09GX0RBWVNfSU5fQV9XRUVLOiBudW1iZXIgPSA3O1xuZXhwb3J0IGNvbnN0IE5PX09GX1JPV1NfSU5fQ0FMRU5EQVJfVklFVzogbnVtYmVyID0gNjtcbmV4cG9ydCBjb25zdCBUT1RBTF9EQVlTX0lOX0RBWVNfVklFVzogbnVtYmVyID0gTk9fT0ZfREFZU19JTl9BX1dFRUsgKiBOT19PRl9ST1dTX0lOX0NBTEVOREFSX1ZJRVc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IFdlZWtEYXkgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gIC8vIElmIHdlIGdvIHRvIHRoZSBuZXh0IG1vbnRoLCBidXQgdXNlIGEgZGF5IG9mIDAsIGl0IHJldHVybnMgdGhlIGxhc3QgZGF5IGZyb20gdGhlIHByZXZpb3VzIG1vbnRoXG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCArIDEsIDApLmdldERhdGUoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXkgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGRhdGUgd2hlcmUgMCByZXByZXNlbnRzIFN1bmRheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERheSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlcik6IFdlZWtEYXkge1xuICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUpLmdldERheSgpO1xufVxuXG4vKipcbiAqIFRha2VzIGluIGEgeWVhciBhbmQgaWYgaXQgaXMgYSAyIGRpZ2l0IHllYXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgNCBkaWdpdCB5ZWFyLlxuICogV2luZG93IG9mIDgwIHllYXJzIGJlZm9yZSBhbmQgMjAgeWVhcnMgYWZ0ZXIgdGhlIHByZXNlbnQgeWVhci5cbiAqIENyZWRpdDogaHR0cHM6Ly9naXRodWIuY29tL2dsb2JhbGl6ZWpzL2dsb2JhbGl6ZS9ibG9iL2UxYjMxY2Q2YTRmMWNmZjc1YjE4NWI2OGI3YTMyMjIwYWFjNTE5NmYvc3JjL2RhdGUvcGFyc2UuanNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVG9Gb3VyRGlnaXRZZWFyKHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gIGlmICh5ZWFyID4gOTk5OSB8fCAoeWVhciA+IDEwMCAmJiB5ZWFyIDwgOTk5KSB8fCB5ZWFyIDwgMTApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHllYXIgPiA5OTkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfVxuICBjb25zdCBjdXJyWWVhcjogbnVtYmVyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuICBjb25zdCBjZW50dXJ5OiBudW1iZXIgPSBNYXRoLmZsb29yKGN1cnJZZWFyIC8gMTAwKSAqIDEwMDtcbiAgbGV0IHJlc3VsdDogbnVtYmVyID0geWVhciArIGNlbnR1cnk7XG4gIGlmIChyZXN1bHQgPiBjdXJyWWVhciArIDIwKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IC0gMTAwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi9kYXkubW9kZWwnO1xuXG5leHBvcnQgY2xhc3MgRGF5Vmlld01vZGVsIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGRheU1vZGVsOiBEYXlNb2RlbCxcbiAgICBwdWJsaWMgaXNUb2RheXNEYXRlOiBib29sZWFuID0gZmFsc2UsXG4gICAgcHVibGljIGlzRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBwdWJsaWMgaXNTZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlLFxuICAgIHB1YmxpYyBpc0ZvY3VzYWJsZTogYm9vbGVhbiA9IGZhbHNlXG4gICkge31cblxuICAvKipcbiAgICogR2V0cyB0aGUgdGFiIGluZGV4IGJhc2VkIG9uIHRoZSBpc0ZvY3VzYWJsZSBmbGFnLlxuICAgKi9cbiAgZ2V0IHRhYkluZGV4KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaXNGb2N1c2FibGUgPyAwIDogLTE7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCB9IGZyb20gJy4uL3V0aWxzL2RhdGUtdXRpbHMnO1xuXG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vZGF5Lm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyTW9kZWwge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgeWVhcjogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgbW9udGg6IG51bWJlcikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZURheXNJbkNhbGVuZGFyKCk7XG4gIH1cblxuICBkYXlzOiBEYXlNb2RlbFtdO1xuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZXMgdGhlIGRheXMgYXJyYXkgd2l0aCB0aGUgRGF5TW9kZWxzIGluIHRoZSBjdXJyZW50IENhbGVuZGFyLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplRGF5c0luQ2FsZW5kYXIoKTogdm9pZCB7XG4gICAgY29uc3Qgbm9PZkRheXNJbkNhbGVuZGFyOiBudW1iZXIgPSBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gICAgdGhpcy5kYXlzID0gQXJyYXkobm9PZkRheXNJbkNhbGVuZGFyKVxuICAgICAgLmZpbGwobnVsbClcbiAgICAgIC5tYXAoKGRhdGUsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgRGF5TW9kZWwodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCBpbmRleCArIDEpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjYWxlbmRhciBwYXNzZWQgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgY2FsZW5kYXIuXG4gICAqL1xuICBpc0VxdWFsKGNhbGVuZGFyOiBDYWxlbmRhck1vZGVsKSB7XG4gICAgaWYgKGNhbGVuZGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy55ZWFyID09PSBjYWxlbmRhci55ZWFyICYmIHRoaXMubW9udGggPT09IGNhbGVuZGFyLm1vbnRoO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgRGF5TW9kZWwgaXMgaW4gdGhlIENhbGVuZGFyXG4gICAqL1xuICBpc0RheUluQ2FsZW5kYXIoZGF5OiBEYXlNb2RlbCk6IGJvb2xlYW4ge1xuICAgIGlmIChkYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnllYXIgPT09IGRheS55ZWFyICYmIHRoaXMubW9udGggPT09IGRheS5tb250aDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgQ2FsZW5kYXJNb2RlbCBvZiB0aGUgcHJldmlvdXMgbW9udGguXG4gICAqL1xuICBwcmV2aW91c01vbnRoKCk6IENhbGVuZGFyTW9kZWwge1xuICAgIGlmICh0aGlzLm1vbnRoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IENhbGVuZGFyTW9kZWwodGhpcy55ZWFyIC0gMSwgMTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IENhbGVuZGFyTW9kZWwodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgQ2FsZW5kYXJNb2RlbCBvZiB0aGUgbmV4dCBtb250aC5cbiAgICovXG4gIG5leHRNb250aCgpOiBDYWxlbmRhck1vZGVsIHtcbiAgICBpZiAodGhpcy5tb250aCA9PT0gMTEpIHtcbiAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnllYXIgKyAxLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhck1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCArIDEpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDYWxlbmRhck1vZGVsIH0gZnJvbSAnLi9jYWxlbmRhci5tb2RlbCc7XG5cbmV4cG9ydCBjbGFzcyBEYXlNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB5ZWFyOiBudW1iZXIsIHB1YmxpYyByZWFkb25seSBtb250aDogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgZGF0ZTogbnVtYmVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDYWxlbmRhciBmb3IgdGhlIGN1cnJlbnQgRGF5TW9kZWwuXG4gICAqL1xuICBnZXQgY2FsZW5kYXIoKTogQ2FsZW5kYXJNb2RlbCB7XG4gICAgcmV0dXJuIG5ldyBDYWxlbmRhck1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwYXNzZWQgQ2FsZW5kYXJEYXRlIGlzIGVxdWFsIHRvIGl0c2VsZi5cbiAgICovXG4gIGlzRXF1YWwoZGF5OiBEYXlNb2RlbCkge1xuICAgIGlmIChkYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnllYXIgPT09IGRheS55ZWFyICYmIHRoaXMubW9udGggPT09IGRheS5tb250aCAmJiB0aGlzLmRhdGUgPT09IGRheS5kYXRlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIENhbGVuZGFyRGF0ZSBpbnRvIHRoZSBKYXZhc2NyaXB0IERhdGUgb2JqZWN0LlxuICAgKi9cbiAgdG9EYXRlKCk6IERhdGUge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBEYXlNb2RlbCB3aGljaCBpcyBpbmNyZW1lbnRlZCBiYXNlZCBvbiB0aGUgdmFsdWUgcGFzc2VkLlxuICAgKi9cbiAgaW5jcmVtZW50QnkodmFsdWU6IG51bWJlcik6IERheU1vZGVsIHtcbiAgICAvLyBDcmVhdGluZyBuZXcgSmF2YXNjcmlwdCBEYXRlIG9iamVjdCB0byBpbmNyZW1lbnQgYmVjYXVzZVxuICAgIC8vIGl0IHdpbGwgYXV0b21hdGljYWxseSB0YWtlIGNhcmUgb2Ygc3dpdGNoaW5nIHRvIG5leHQgb3IgcHJldmlvdXNcbiAgICAvLyBtb250aHMgJiB5ZWFycyB3aXRob3V0IHdlIGhhdmluZyB0byB3b3JyeSBhYm91dCBpdC5cbiAgICBjb25zdCBkYXRlOiBEYXRlID0gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRhdGUgKyB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBEYXlNb2RlbChkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGUgY3VycmVudCBkYXkgbW9kZWwuXG4gICAqL1xuICBjbG9uZSgpOiBEYXlNb2RlbCB7XG4gICAgcmV0dXJuIG5ldyBEYXlNb2RlbCh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF0ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgTk9fT0ZfREFZU19JTl9BX1dFRUssIE5PX09GX1JPV1NfSU5fQ0FMRU5EQVJfVklFVywgVE9UQUxfREFZU19JTl9EQVlTX1ZJRVcgfSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0RGF5IH0gZnJvbSAnLi4vdXRpbHMvZGF0ZS11dGlscyc7XG5cbmltcG9ydCB7IENhbGVuZGFyTW9kZWwgfSBmcm9tICcuL2NhbGVuZGFyLm1vZGVsJztcbmltcG9ydCB7IERheVZpZXdNb2RlbCB9IGZyb20gJy4vZGF5LXZpZXcubW9kZWwnO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL2RheS5tb2RlbCc7XG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhclZpZXdNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjYWxlbmRhcjogQ2FsZW5kYXJNb2RlbCxcbiAgICBwcml2YXRlIHNlbGVjdGVkRGF5OiBEYXlNb2RlbCxcbiAgICBwcml2YXRlIGZvY3VzYWJsZURheTogRGF5TW9kZWwsXG4gICAgcHJpdmF0ZSB0b2RheTogRGF5TW9kZWwsXG4gICAgcHVibGljIGZpcnN0RGF5T2ZXZWVrOiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5pbml0aWFsaXplQ2FsZW5kYXJWaWV3KCk7XG4gIH1cblxuICBwcml2YXRlIGN1cnJNb250aERheVZpZXdzOiBEYXlWaWV3TW9kZWxbXSA9IFtdO1xuXG4gIHByaXZhdGUgX2NhbGVuZGFyVmlldzogRGF5Vmlld01vZGVsW11bXTtcblxuICAvKipcbiAgICogRGF5Vmlld01vZGVsIG1hdHJpeC4gU2l6ZSA2eDdcbiAgICovXG4gIGdldCBjYWxlbmRhclZpZXcoKTogRGF5Vmlld01vZGVsW11bXSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbGVuZGFyVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSA2eDcgbWF0cml4IG9mIERheVZpZXdNb2RlbCBiYXNlZCBvbiB0aGUgQ2FsZW5kYXIuXG4gICAqIFRoZSA2eDcgbWF0cml4IGlzIHN0cnVjdHVyZWQgYWNjb3JkaW5nIHRvIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIDYgcm93cyB0byBhY2NvbW1vZGF0ZSBtb250aHMgd2hpY2ggbWlnaHQgaGF2ZSBkYXRlcyBzcGFubmluZyBvdmVyIDYgd2Vla3MuXG4gICAqIDcgY29sdW1ucyBiZWNhdXNlIHRoZXJlIGFyZSA3IGRheXMgaW4gYSB3ZWVrIDpQIDpEXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVDYWxlbmRhclZpZXcoKTogdm9pZCB7XG4gICAgLy8gR2VuZXJhdGUgcHJldiBhbmQgbmV4dCBtb250aCBjYWxlbmRhciBtb2RlbHMuXG4gICAgY29uc3QgcHJldk1vbnRoQ2FsZW5kYXI6IENhbGVuZGFyTW9kZWwgPSB0aGlzLmNhbGVuZGFyLnByZXZpb3VzTW9udGgoKTtcbiAgICBjb25zdCBuZXh0TW9udGhDYWxlbmRhcjogQ2FsZW5kYXJNb2RlbCA9IHRoaXMuY2FsZW5kYXIubmV4dE1vbnRoKCk7XG5cbiAgICAvLyBHZXQgbm8gb2YgZGF5cyBmcm9tIHByZXYgYW5kIG5leHQgbW9udGhzLlxuICAgIGNvbnN0IGRheXNGcm9tUHJldk1vbnRoSW5DYWxWaWV3OiBudW1iZXIgPSB0aGlzLm51bURheXNGcm9tUHJldk1vbnRoSW5DYWxWaWV3KFxuICAgICAgdGhpcy5jYWxlbmRhci55ZWFyLFxuICAgICAgdGhpcy5jYWxlbmRhci5tb250aFxuICAgICk7XG4gICAgY29uc3QgZGF5c0Zyb21OZXh0TW9udGhJbkNhbFZpZXc6IG51bWJlciA9XG4gICAgICBUT1RBTF9EQVlTX0lOX0RBWVNfVklFVyAtICh0aGlzLmNhbGVuZGFyLmRheXMubGVuZ3RoICsgZGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcpO1xuXG4gICAgLy8gR2VuZXJhdGUgcHJldiwgY3VyciBhbmQgbmV4dCBkYXkgdmlldyBtb2RlbHNcbiAgICBsZXQgcHJldk1vbnRoRGF5Vmlld3M6IERheVZpZXdNb2RlbFtdID0gW107XG4gICAgbGV0IG5leHRNb250aERheVZpZXdzOiBEYXlWaWV3TW9kZWxbXSA9IFtdO1xuXG4gICAgaWYgKGRheXNGcm9tUHJldk1vbnRoSW5DYWxWaWV3ID4gMCkge1xuICAgICAgcHJldk1vbnRoRGF5Vmlld3MgPSB0aGlzLmdlbmVyYXRlRGF5Vmlld01vZGVscyhcbiAgICAgICAgcHJldk1vbnRoQ2FsZW5kYXIuZGF5cy5zbGljZSgtMSAqIGRheXNGcm9tUHJldk1vbnRoSW5DYWxWaWV3KSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyTW9udGhEYXlWaWV3cyA9IHRoaXMuZ2VuZXJhdGVEYXlWaWV3TW9kZWxzKHRoaXMuY2FsZW5kYXIuZGF5cywgZmFsc2UsIHRydWUpO1xuXG4gICAgaWYgKGRheXNGcm9tTmV4dE1vbnRoSW5DYWxWaWV3ID4gMCkge1xuICAgICAgbmV4dE1vbnRoRGF5Vmlld3MgPSB0aGlzLmdlbmVyYXRlRGF5Vmlld01vZGVscyhcbiAgICAgICAgbmV4dE1vbnRoQ2FsZW5kYXIuZGF5cy5zbGljZSgwLCBkYXlzRnJvbU5leHRNb250aEluQ2FsVmlldyksXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGNhbGVuZGFyIHZpZXcgYW5kIGluaXRpYWxpemUgZmxhZ3NcbiAgICB0aGlzLl9jYWxlbmRhclZpZXcgPSB0aGlzLmdlbmVyYXRlQ2FsZW5kYXJWaWV3KHByZXZNb250aERheVZpZXdzLCB0aGlzLmN1cnJNb250aERheVZpZXdzLCBuZXh0TW9udGhEYXlWaWV3cyk7XG4gICAgdGhpcy5pbml0aWFsaXplU2VsZWN0ZWREYXkoKTtcbiAgICB0aGlzLmluaXRpYWxpemVGb2N1c2FibGVEYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBEYXlWaWV3TW9kZWwgYXJyYXkgYmFzZWQgb24gdGhlIERheU1vZGVsIHBhc3NlZFxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZURheVZpZXdNb2RlbHMoZGF5czogRGF5TW9kZWxbXSwgaXNEaXNhYmxlZDogYm9vbGVhbiwgaXNDdXJyZW50Q2FsZW5kYXI6IGJvb2xlYW4pOiBEYXlWaWV3TW9kZWxbXSB7XG4gICAgY29uc3QgZGF5Vmlld3M6IERheVZpZXdNb2RlbFtdID0gZGF5cy5tYXAoZGF5ID0+IHtcbiAgICAgIHJldHVybiBuZXcgRGF5Vmlld01vZGVsKGRheSwgZmFsc2UsIGlzRGlzYWJsZWQsIGZhbHNlLCBmYWxzZSk7XG4gICAgfSk7XG4gICAgaWYgKGlzQ3VycmVudENhbGVuZGFyICYmIHRoaXMuY2FsZW5kYXIuaXNEYXlJbkNhbGVuZGFyKHRoaXMudG9kYXkpKSB7XG4gICAgICBkYXlWaWV3c1t0aGlzLnRvZGF5LmRhdGUgLSAxXS5pc1RvZGF5c0RhdGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZGF5Vmlld3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlyc3QgZGF5IG9mIHRoZSBjdXJyZW50IG1vbnRoIHRvIGZpZ3VyZSBvdXQgaG93IG1hbnkgZGF0ZXMgb2YgcHJldmlvdXMgbW9udGhcbiAgICogYXJlIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgQ2FsZW5kYXIgVmlldyBiYXNlZCBvbiB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiBlZzogQXNzdW1pbmcgbG9jYWxlIGVuLVVTLCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGlzIFN1bmRheSxcbiAgICogaWYgZmlyc3QgZGF5IG9mIHRoZSBjdXJyZW50IG1vbnRoIGxhbmRzIG9uIFdlZG5lc2RheSwgdGhlblxuICAgKiAodGhpcy5nZXREYXkgZnVuY3Rpb24gd291bGQgcmV0dXJuIDMgc2luY2VcbiAgICogZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGlzIDApLCB3ZSBuZWVkIHRoZSAzIGRheXMgZnJvbSB0aGUgcHJldmlvdXMgbW9udGguXG4gICAqL1xuICBwcml2YXRlIG51bURheXNGcm9tUHJldk1vbnRoSW5DYWxWaWV3KGN1cnJlbnRZZWFyOiBudW1iZXIsIGN1cnJlbnRNb250aDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBmaXJzdERheU9mQ3Vyck1vbnRoOiBudW1iZXIgPSBnZXREYXkoY3VycmVudFllYXIsIGN1cnJlbnRNb250aCwgMSk7XG5cbiAgICBpZiAoZmlyc3REYXlPZkN1cnJNb250aCA+PSB0aGlzLmZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICByZXR1cm4gZmlyc3REYXlPZkN1cnJNb250aCAtIHRoaXMuZmlyc3REYXlPZldlZWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBOT19PRl9EQVlTX0lOX0FfV0VFSyArIGZpcnN0RGF5T2ZDdXJyTW9udGggLSB0aGlzLmZpcnN0RGF5T2ZXZWVrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIERheSBwYXNzZWQgaXMgaW4gdGhlIENhbGVuZGFyVmlldy5cbiAgICovXG4gIHByaXZhdGUgaXNEYXlJbkNhbGVuZGFyVmlldyhkYXk6IERheU1vZGVsKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmNhbGVuZGFyLmlzRGF5SW5DYWxlbmRhcihkYXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzaW5nIHRoZSBEYXlWaWV3TW9kZWxzIGZyb20gdGhlIHByZXZpb3VzLCBjdXJyZW50IGFuZCBuZXh0IG1vbnRoLCB0aGlzIGZ1bmN0aW9uXG4gICAqIGdlbmVyYXRlcyB0aGUgQ2FsZW5kYXJWaWV3LlxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZUNhbGVuZGFyVmlldyhwcmV2OiBEYXlWaWV3TW9kZWxbXSwgY3VycjogRGF5Vmlld01vZGVsW10sIG5leHQ6IERheVZpZXdNb2RlbFtdKTogRGF5Vmlld01vZGVsW11bXSB7XG4gICAgY29uc3QgY29tYmluYXRpb25BcnI6IERheVZpZXdNb2RlbFtdID0gWy4uLnByZXYsIC4uLmN1cnIsIC4uLm5leHRdO1xuXG4gICAgY29uc3QgY2FsZW5kYXJWaWV3OiBEYXlWaWV3TW9kZWxbXVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOT19PRl9ST1dTX0lOX0NBTEVOREFSX1ZJRVc7IGkrKykge1xuICAgICAgY2FsZW5kYXJWaWV3W2ldID0gY29tYmluYXRpb25BcnIuc2xpY2UoaSAqIE5PX09GX0RBWVNfSU5fQV9XRUVLLCAoaSArIDEpICogTk9fT0ZfREFZU19JTl9BX1dFRUspO1xuICAgIH1cbiAgICByZXR1cm4gY2FsZW5kYXJWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIHNlbGVjdGVkIGRheSBpZiB0aGUgZGF5IGlzIGluIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVNlbGVjdGVkRGF5KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkRGF5ICYmIHRoaXMuaXNEYXlJbkNhbGVuZGFyVmlldyh0aGlzLnNlbGVjdGVkRGF5KSkge1xuICAgICAgdGhpcy5jdXJyTW9udGhEYXlWaWV3c1t0aGlzLnNlbGVjdGVkRGF5LmRhdGUgLSAxXS5pc1NlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGZvY3VzYWJsZSBkYXkgaWYgdGhlIGRheSBpcyBpbiB0aGUgY2FsZW5kYXIuIElmIGZvY3VzYWJsZSBkYXkgaXMgbm90IHNldCwgdGhlblxuICAgKiB3ZSBjaGVjayBmb3IgdGhlIHNlbGVjdGVkIGRheS4gSWYgc2VsZWN0ZWQgZGF5IGlzIG5vdCBzZXQgdGhlbiBjaGVjayBpZiB0b2RheSBpcyBpbiB0aGUgY3VycmVudFxuICAgKiBjYWxlbmRhci4gSWYgbm90IHRoZW4ganVzdCBzZXQgdGhlIDE1dGggb2YgdGhlIGN1cnJlbnQgY2FsZW5kYXIgbW9udGguXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVGb2N1c2FibGVEYXkoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZm9jdXNhYmxlRGF5ICYmIHRoaXMuaXNEYXlJbkNhbGVuZGFyVmlldyh0aGlzLmZvY3VzYWJsZURheSkpIHtcbiAgICAgIHRoaXMuc2V0Rm9jdXNhYmxlRmxhZyh0aGlzLmZvY3VzYWJsZURheSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkRGF5ICYmIHRoaXMuaXNEYXlJbkNhbGVuZGFyVmlldyh0aGlzLnNlbGVjdGVkRGF5KSkge1xuICAgICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMuc2VsZWN0ZWREYXksIHRydWUpO1xuICAgICAgdGhpcy5mb2N1c2FibGVEYXkgPSB0aGlzLnNlbGVjdGVkRGF5LmNsb25lKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRGF5SW5DYWxlbmRhclZpZXcodGhpcy50b2RheSkpIHtcbiAgICAgIHRoaXMuc2V0Rm9jdXNhYmxlRmxhZyh0aGlzLnRvZGF5LCB0cnVlKTtcbiAgICAgIHRoaXMuZm9jdXNhYmxlRGF5ID0gdGhpcy50b2RheS5jbG9uZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvY3VzYWJsZURheSA9IG5ldyBEYXlNb2RlbCh0aGlzLmNhbGVuZGFyLnllYXIsIHRoaXMuY2FsZW5kYXIubW9udGgsIDE1KTtcbiAgICAgIHRoaXMuc2V0Rm9jdXNhYmxlRmxhZyh0aGlzLmZvY3VzYWJsZURheSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRGb2N1c2FibGVGbGFnKGRheTogRGF5TW9kZWwsIGZsYWc6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoZGF5KSB7XG4gICAgICB0aGlzLmN1cnJNb250aERheVZpZXdzW2RheS5kYXRlIC0gMV0uaXNGb2N1c2FibGUgPSBmbGFnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmb2N1c2FibGUgZGF5IGluIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIHVwZGF0ZUZvY3VzYWJsZURheShkYXk6IERheU1vZGVsKTogdm9pZCB7XG4gICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMuZm9jdXNhYmxlRGF5LCBmYWxzZSk7XG4gICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKGRheSwgdHJ1ZSk7XG4gICAgdGhpcy5mb2N1c2FibGVEYXkgPSBkYXk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ2FsZW5kYXJNb2RlbCB9IGZyb20gJy4uL21vZGVsL2NhbGVuZGFyLm1vZGVsJztcbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvZGF5Lm1vZGVsJztcblxuLyoqXG4gKiBUaGlzIHNlcnZpY2UgaXMgcmVzcG9uc2libGUgZm9yOlxuICogMS4gSW5pdGlhbGl6aW5nIHRoZSBkaXNwbGF5ZWQgY2FsZW5kYXIuXG4gKiAyLiBNb3ZpbmcgdGhlIGNhbGVuZGFyIHRvIHRoZSBuZXh0LCBwcmV2aW91cyBvciBjdXJyZW50IG1vbnRoc1xuICogMy4gTWFuYWdpbmcgdGhlIGZvY3VzZWQgYW5kIHNlbGVjdGVkIGRheSBtb2RlbHMuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlTmF2aWdhdGlvblNlcnZpY2Uge1xuICBwcml2YXRlIF9kaXNwbGF5ZWRDYWxlbmRhcjogQ2FsZW5kYXJNb2RlbDtcblxuICBnZXQgZGlzcGxheWVkQ2FsZW5kYXIoKTogQ2FsZW5kYXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyO1xuICB9XG5cbiAgLy8gbm90IGEgc2V0dGVyIGJlY2F1c2UgaSB3YW50IHRoaXMgdG8gcmVtYWluIHByaXZhdGVcbiAgcHJpdmF0ZSBzZXREaXNwbGF5ZWRDYWxlbmRhcih2YWx1ZTogQ2FsZW5kYXJNb2RlbCkge1xuICAgIGlmICghdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIuaXNFcXVhbCh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyID0gdmFsdWU7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhckNoYW5nZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFZhcmlhYmxlIHRvIHN0b3JlIHRvZGF5J3MgZGF0ZS5cbiAgICovXG4gIHByaXZhdGUgX3RvZGF5c0Z1bGxEYXRlOiBEYXRlID0gbmV3IERhdGUoKTtcbiAgcHJpdmF0ZSBfdG9kYXk6IERheU1vZGVsO1xuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVRvZGF5c0RhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5fdG9kYXlzRnVsbERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuX3RvZGF5ID0gbmV3IERheU1vZGVsKFxuICAgICAgdGhpcy5fdG9kYXlzRnVsbERhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgIHRoaXMuX3RvZGF5c0Z1bGxEYXRlLmdldE1vbnRoKCksXG4gICAgICB0aGlzLl90b2RheXNGdWxsRGF0ZS5nZXREYXRlKClcbiAgICApO1xuICB9XG5cbiAgZ2V0IHRvZGF5KCk6IERheU1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fdG9kYXk7XG4gIH1cblxuICBwdWJsaWMgc2VsZWN0ZWREYXk6IERheU1vZGVsO1xuXG4gIHByaXZhdGUgX3NlbGVjdGVkRGF5Q2hhbmdlOiBTdWJqZWN0PERheU1vZGVsPiA9IG5ldyBTdWJqZWN0PERheU1vZGVsPigpO1xuXG4gIGdldCBzZWxlY3RlZERheUNoYW5nZSgpOiBPYnNlcnZhYmxlPERheU1vZGVsPiB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkRGF5Q2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoYXQgdGhlIHNlbGVjdGVkIGRheSBoYXMgY2hhbmdlZCBzbyB0aGF0IHRoZSBkYXRlIGNhbiBiZSBlbWl0dGVkIHRvIHRoZSB1c2VyLlxuICAgKiBOb3RlOiBPbmx5IHRvIGJlIGNhbGxlZCBmcm9tIGRheS50c1xuICAgKi9cbiAgbm90aWZ5U2VsZWN0ZWREYXlDaGFuZ2VkKGRheU1vZGVsOiBEYXlNb2RlbCkge1xuICAgIGlmIChkYXlNb2RlbC5pc0VxdWFsKHRoaXMuc2VsZWN0ZWREYXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0ZWREYXkgPSBkYXlNb2RlbDtcbiAgICB0aGlzLl9zZWxlY3RlZERheUNoYW5nZS5uZXh0KGRheU1vZGVsKTtcbiAgfVxuXG4gIHB1YmxpYyBmb2N1c2VkRGF5OiBEYXlNb2RlbDtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNhbGVuZGFyIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBkYXkuXG4gICAqL1xuICBpbml0aWFsaXplQ2FsZW5kYXIoKTogdm9pZCB7XG4gICAgdGhpcy5mb2N1c2VkRGF5ID0gbnVsbDsgLy8gQ2FuIGJlIHJlbW92ZWQgbGF0ZXIgb24gdGhlIHN0b3JlIGZvY3VzXG4gICAgdGhpcy5pbml0aWFsaXplVG9kYXlzRGF0ZSgpO1xuICAgIGlmICh0aGlzLnNlbGVjdGVkRGF5KSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhciA9IG5ldyBDYWxlbmRhck1vZGVsKHRoaXMuc2VsZWN0ZWREYXkueWVhciwgdGhpcy5zZWxlY3RlZERheS5tb250aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyID0gbmV3IENhbGVuZGFyTW9kZWwodGhpcy50b2RheS55ZWFyLCB0aGlzLnRvZGF5Lm1vbnRoKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VNb250aChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zZXREaXNwbGF5ZWRDYWxlbmRhcihuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhci55ZWFyLCBtb250aCkpO1xuICB9XG5cbiAgY2hhbmdlWWVhcih5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKG5ldyBDYWxlbmRhck1vZGVsKHllYXIsIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLm1vbnRoKSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGRpc3BsYXllZCBjYWxlbmRhciB0byB0aGUgbmV4dCBtb250aC5cbiAgICovXG4gIG1vdmVUb05leHRNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLm5leHRNb250aCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgZGlzcGxheWVkIGNhbGVuZGFyIHRvIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICovXG4gIG1vdmVUb1ByZXZpb3VzTW9udGgoKTogdm9pZCB7XG4gICAgdGhpcy5zZXREaXNwbGF5ZWRDYWxlbmRhcih0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhci5wcmV2aW91c01vbnRoKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBkaXNwbGF5ZWQgY2FsZW5kYXIgdG8gdGhlIGN1cnJlbnQgbW9udGggYW5kIHllYXIuXG4gICAqL1xuICBtb3ZlVG9DdXJyZW50TW9udGgoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmRpc3BsYXllZENhbGVuZGFyLmlzRGF5SW5DYWxlbmRhcih0aGlzLnRvZGF5KSkge1xuICAgICAgdGhpcy5zZXREaXNwbGF5ZWRDYWxlbmRhcihuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnRvZGF5LnllYXIsIHRoaXMudG9kYXkubW9udGgpKTtcbiAgICB9XG4gICAgdGhpcy5fZm9jdXNPbkNhbGVuZGFyQ2hhbmdlLm5leHQoKTtcbiAgfVxuXG4gIGluY3JlbWVudEZvY3VzRGF5KHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmZvY3VzZWREYXkgPSB0aGlzLmZvY3VzZWREYXkuaW5jcmVtZW50QnkodmFsdWUpO1xuICAgIGlmICh0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhci5pc0RheUluQ2FsZW5kYXIodGhpcy5mb2N1c2VkRGF5KSkge1xuICAgICAgdGhpcy5fZm9jdXNlZERheUNoYW5nZS5uZXh0KHRoaXMuZm9jdXNlZERheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIodGhpcy5mb2N1c2VkRGF5LmNhbGVuZGFyKTtcbiAgICB9XG4gICAgdGhpcy5fZm9jdXNPbkNhbGVuZGFyQ2hhbmdlLm5leHQoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2Rpc3BsYXllZENhbGVuZGFyQ2hhbmdlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKipcbiAgICogVGhpcyBvYnNlcnZhYmxlIGxldHMgdGhlIHN1YnNjcmliZXIga25vdyB0aGF0IHRoZSBkaXNwbGF5ZWQgY2FsZW5kYXIgaGFzIGNoYW5nZWQuXG4gICAqL1xuICBnZXQgZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZm9jdXNPbkNhbGVuZGFyQ2hhbmdlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKipcbiAgICogVGhpcyBvYnNlcnZhYmxlIGxldHMgdGhlIHN1YnNjcmliZXIga25vdyB0aGF0IHRoZSBmb2N1cyBzaG91bGQgYmUgYXBwbGllZCBvbiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBnZXQgZm9jdXNPbkNhbGVuZGFyQ2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c09uQ2FsZW5kYXJDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9mb2N1c2VkRGF5Q2hhbmdlOiBTdWJqZWN0PERheU1vZGVsPiA9IG5ldyBTdWJqZWN0PERheU1vZGVsPigpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG9ic2VydmFibGUgbGV0cyB0aGUgc3Vic2NyaWJlciBrbm93IHRoYXQgdGhlIGZvY3VzZWQgZGF5IGluIHRoZSBkaXNwbGF5ZWQgY2FsZW5kYXIgaGFzIGNoYW5nZWQuXG4gICAqL1xuICBnZXQgZm9jdXNlZERheUNoYW5nZSgpOiBPYnNlcnZhYmxlPERheU1vZGVsPiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWREYXlDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlLCBOZ1pvbmUsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBUaGlzIHNlcnZpY2UgZm9jdXNlcyB0aGUgZGF5IHRoYXQgaXMgZm9jdXNhYmxlIGluIHRoZSBjYWxlbmRhci5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVwaWNrZXJGb2N1c1NlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSwgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QpIHt9XG5cbiAgLy8gQ3JlZGl0OiBNYXRlcmlhbDogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvbWF0ZXJpYWwyL2Jsb2IvbWFzdGVyL3NyYy9saWIvZGF0ZXBpY2tlci9jYWxlbmRhci50c1xuICBmb2N1c0NlbGwoZWxSZWY6IEVsZW1lbnRSZWYpOiB2b2lkIHtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgdGhpcy5fbmdab25lLm9uU3RhYmxlXG4gICAgICAgIC5hc09ic2VydmFibGUoKVxuICAgICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgY29uc3QgZm9jdXNFbCA9IGVsUmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignW3RhYmluZGV4PVwiMFwiXScpO1xuICAgICAgICAgICAgaWYgKGZvY3VzRWwpIHtcbiAgICAgICAgICAgICAgZm9jdXNFbC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgRm9ybWF0V2lkdGgsXG4gIEZvcm1TdHlsZSxcbiAgZ2V0TG9jYWxlRGF0ZUZvcm1hdCxcbiAgZ2V0TG9jYWxlRGF5TmFtZXMsXG4gIGdldExvY2FsZUZpcnN0RGF5T2ZXZWVrLFxuICBnZXRMb2NhbGVNb250aE5hbWVzLFxuICBUcmFuc2xhdGlvbldpZHRoLFxufSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBMT0NBTEVfSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBUaGlzIHNlcnZpY2UgZXh0cmFjdHMgdGhlIEFuZ3VsYXIgQ0xEUiBkYXRhIG5lZWRlZCBieSB0aGUgZGF0ZXBpY2tlci5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIExvY2FsZUhlbHBlclNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihASW5qZWN0KExPQ0FMRV9JRCkgcHVibGljIGxvY2FsZTogc3RyaW5nKSB7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlRGF0YSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZmlyc3REYXlPZldlZWs6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX2xvY2FsZURheXNOYXJyb3c6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPjtcbiAgcHJpdmF0ZSBfbG9jYWxlTW9udGhzQWJicmV2aWF0ZWQ6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPjtcbiAgcHJpdmF0ZSBfbG9jYWxlTW9udGhzV2lkZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+O1xuICBwcml2YXRlIF9sb2NhbGVEYXRlRm9ybWF0OiBzdHJpbmc7XG5cbiAgZ2V0IGZpcnN0RGF5T2ZXZWVrKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0RGF5T2ZXZWVrO1xuICB9XG5cbiAgZ2V0IGxvY2FsZURheXNOYXJyb3coKTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlRGF5c05hcnJvdztcbiAgfVxuXG4gIGdldCBsb2NhbGVNb250aHNBYmJyZXZpYXRlZCgpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVNb250aHNBYmJyZXZpYXRlZDtcbiAgfVxuXG4gIGdldCBsb2NhbGVNb250aHNXaWRlKCk6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZU1vbnRoc1dpZGU7XG4gIH1cblxuICBnZXQgbG9jYWxlRGF0ZUZvcm1hdCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVEYXRlRm9ybWF0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBsb2NhbGUgZGF0YS5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZURhdGEoKTogdm9pZCB7XG4gICAgLy8gT3JkZXIgaW4gd2hpY2ggdGhlc2UgZnVuY3Rpb25zIGlzIGNhbGxlZCBpcyB2ZXJ5IGltcG9ydGFudC5cbiAgICB0aGlzLmluaXRpYWxpemVGaXJzdERheU9mV2VlaygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZURhdGVGb3JtYXQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMb2NhbGVNb250aHNBYmJyZXZpYXRlZCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZU1vbnRoc1dpZGUoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMb2NhbGVEYXlzTmFycm93KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBkYXkgbmFtZXMgaW4gdGhlIFRyYW5zbGF0aW9uV2lkdGguTmFycm93IGZvcm1hdCBiYXNlZCBvbiB0aGUgbG9jYWxlLlxuICAgKiBlZzogW1MsIE0sIFQuLi5dIGZvciBlbi1VUy5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZURheXNOYXJyb3coKTogdm9pZCB7XG4gICAgLy8gR2V0IGxvY2FsZSBkYXkgbmFtZXMgc3RhcnRpbmcgd2l0aCBTdW5kYXlcbiAgICBjb25zdCB0ZW1wQXJyOiBzdHJpbmdbXSA9IGdldExvY2FsZURheU5hbWVzKHRoaXMubG9jYWxlLCBGb3JtU3R5bGUuU3RhbmRhbG9uZSwgVHJhbnNsYXRpb25XaWR0aC5OYXJyb3cpLnNsaWNlKCk7XG4gICAgLy8gR2V0IGZpcnN0IGRheSBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgbG9jYWxlXG4gICAgY29uc3QgZmlyc3REYXlPZldlZWs6IG51bWJlciA9IHRoaXMuZmlyc3REYXlPZldlZWs7XG4gICAgLy8gUmVhcnJhbmdlIHRoZSB0ZW1wQXJyIHRvIHN0YXJ0IHdpdGggdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgbG9jYWxlLlxuICAgIGlmIChmaXJzdERheU9mV2VlayA+IDApIHtcbiAgICAgIGNvbnN0IHByZXZEYXlzOiBzdHJpbmdbXSA9IHRlbXBBcnIuc3BsaWNlKDAsIGZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgIHRlbXBBcnIucHVzaCguLi5wcmV2RGF5cyk7XG4gICAgfVxuICAgIHRoaXMuX2xvY2FsZURheXNOYXJyb3cgPSB0ZW1wQXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBhcnJheSBvZiBtb250aCBuYW1lcyBpbiB0aGUgVHJhbnNsYXRpb25XaWR0aC5BYmJyZXZpYXRlZCBmb3JtYXQuXG4gICAqIGUuZy4gYFtKYW4sIEZlYiwgLi4uXWAgZm9yIGVuLVVTXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVMb2NhbGVNb250aHNBYmJyZXZpYXRlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9sb2NhbGVNb250aHNBYmJyZXZpYXRlZCA9IGdldExvY2FsZU1vbnRoTmFtZXMoXG4gICAgICB0aGlzLmxvY2FsZSxcbiAgICAgIEZvcm1TdHlsZS5TdGFuZGFsb25lLFxuICAgICAgVHJhbnNsYXRpb25XaWR0aC5BYmJyZXZpYXRlZFxuICAgICkuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYXJyYXkgb2YgbW9udGggbmFtZXMgaW4gdGhlIFRyYW5zbGF0aW9uV2lkdGguV2lkZSBmb3JtYXQuXG4gICAqIGUuZy4gYFtKYW51YXJ5LCBGZWJydWFyeSwgLi4uXWAgZm9yIGVuLVVTXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVMb2NhbGVNb250aHNXaWRlKCk6IHZvaWQge1xuICAgIHRoaXMuX2xvY2FsZU1vbnRoc1dpZGUgPSBnZXRMb2NhbGVNb250aE5hbWVzKHRoaXMubG9jYWxlLCBGb3JtU3R5bGUuU3RhbmRhbG9uZSwgVHJhbnNsYXRpb25XaWR0aC5XaWRlKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIGxvY2FsZS5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUZpcnN0RGF5T2ZXZWVrKCk6IHZvaWQge1xuICAgIHRoaXMuX2ZpcnN0RGF5T2ZXZWVrID0gZ2V0TG9jYWxlRmlyc3REYXlPZldlZWsodGhpcy5sb2NhbGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlRGF0ZUZvcm1hdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9sb2NhbGVEYXRlRm9ybWF0ID0gZ2V0TG9jYWxlRGF0ZUZvcm1hdCh0aGlzLmxvY2FsZSwgRm9ybWF0V2lkdGguU2hvcnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRE9XTl9BUlJPVywgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFVQX0FSUk9XIH0gZnJvbSAnLi4vLi4vdXRpbHMva2V5LWNvZGVzL2tleS1jb2Rlcyc7XG5cbmltcG9ydCB7IENhbGVuZGFyVmlld01vZGVsIH0gZnJvbSAnLi9tb2RlbC9jYWxlbmRhci12aWV3Lm1vZGVsJztcbmltcG9ydCB7IENhbGVuZGFyTW9kZWwgfSBmcm9tICcuL21vZGVsL2NhbGVuZGFyLm1vZGVsJztcbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi9tb2RlbC9kYXkubW9kZWwnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckZvY3VzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBMb2NhbGVIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbG9jYWxlLWhlbHBlci5zZXJ2aWNlJztcbmltcG9ydCB7IE5PX09GX0RBWVNfSU5fQV9XRUVLIH0gZnJvbSAnLi91dGlscy9jb25zdGFudHMnO1xuXG5AQ29tcG9uZW50KHsgc2VsZWN0b3I6ICdjbHItY2FsZW5kYXInLCB0ZW1wbGF0ZVVybDogJy4vY2FsZW5kYXIuaHRtbCcgfSlcbmV4cG9ydCBjbGFzcyBDbHJDYWxlbmRhciBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX3N1YnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfbG9jYWxlSGVscGVyU2VydmljZTogTG9jYWxlSGVscGVyU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlOiBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2VsUmVmOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHRoaXMuZ2VuZXJhdGVDYWxlbmRhclZpZXcoKTtcbiAgICB0aGlzLmluaXRpYWxpemVTdWJzY3JpcHRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsZW5kYXIgVmlldyBNb2RlbCB0byBnZW5lcmF0ZSB0aGUgQ2FsZW5kYXIuXG4gICAqL1xuICBjYWxlbmRhclZpZXdNb2RlbDogQ2FsZW5kYXJWaWV3TW9kZWw7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvY2FsZSBkYXlzIGFjY29yZGluZyB0byB0aGUgVHJhbnNsYXRpb25XaWR0aC5OYXJyb3cgZm9ybWF0LlxuICAgKi9cbiAgZ2V0IGxvY2FsZURheXNOYXJyb3coKTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlSGVscGVyU2VydmljZS5sb2NhbGVEYXlzTmFycm93O1xuICB9XG5cbiAgZ2V0IGNhbGVuZGFyKCk6IENhbGVuZGFyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZGlzcGxheWVkQ2FsZW5kYXI7XG4gIH1cblxuICBnZXQgc2VsZWN0ZWREYXkoKTogRGF5TW9kZWwge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXk7XG4gIH1cblxuICBnZXQgZm9jdXNlZERheSgpOiBEYXlNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5mb2N1c2VkRGF5O1xuICB9XG5cbiAgZ2V0IHRvZGF5KCk6IERheU1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnRvZGF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgc3Vic2NyaXB0aW9ucyB0bzpcbiAgICogMS4gdXBkYXRlIHRoZSBjYWxlbmRhciB2aWV3IG1vZGVsLlxuICAgKiAyLiB1cGRhdGUgdGhlIGZvY3VzYWJsZSBkYXkgaW4gdGhlIGNhbGVuZGFyIHZpZXcgbW9kZWwuXG4gICAqIDMuIGZvY3VzIG9uIHRoZSBmb2N1c2FibGUgZGF5IGluIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vicy5wdXNoKFxuICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDYWxlbmRhclZpZXcoKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX3N1YnMucHVzaChcbiAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5mb2N1c2VkRGF5Q2hhbmdlLnN1YnNjcmliZSgoZm9jdXNlZERheTogRGF5TW9kZWwpID0+IHtcbiAgICAgICAgdGhpcy5jYWxlbmRhclZpZXdNb2RlbC51cGRhdGVGb2N1c2FibGVEYXkoZm9jdXNlZERheSk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLl9zdWJzLnB1c2goXG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZm9jdXNPbkNhbGVuZGFyQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIENhbGVuZGFyIFZpZXcgYmFzZWQgb24gdGhlIGNhbGVuZGFyIHJldHJpZXZlZCBmcm9tIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlQ2FsZW5kYXJWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuY2FsZW5kYXJWaWV3TW9kZWwgPSBuZXcgQ2FsZW5kYXJWaWV3TW9kZWwoXG4gICAgICB0aGlzLmNhbGVuZGFyLFxuICAgICAgdGhpcy5zZWxlY3RlZERheSxcbiAgICAgIHRoaXMuZm9jdXNlZERheSxcbiAgICAgIHRoaXMudG9kYXksXG4gICAgICB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmZpcnN0RGF5T2ZXZWVrXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxlZ2F0ZXMgS2V5Ym9hcmQgYXJyb3cgbmF2aWdhdGlvbiB0byB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChldmVudCAmJiB0aGlzLmZvY3VzZWREYXkpIHtcbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmluY3JlbWVudEZvY3VzRGF5KC0xICogTk9fT0ZfREFZU19JTl9BX1dFRUspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5jcmVtZW50Rm9jdXNEYXkoTk9fT0ZfREFZU19JTl9BX1dFRUspO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5jcmVtZW50Rm9jdXNEYXkoLTEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmluY3JlbWVudEZvY3VzRGF5KDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrOyAvLyBObyBkZWZhdWx0IGNhc2UuIFRTTGludCB4LShcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyBvbiB0aGUgZm9jdXNhYmxlIGRheSB3aGVuIHRoZSBDYWxlbmRhciBWaWV3IGlzIGluaXRpYWxpemVkLlxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIHN1YnNjcmlwdGlvbnMuXG4gICAqL1xuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGb2N1c1NlcnZpY2Uge1xuICBwcml2YXRlIF9mb2N1c2VkOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgZ2V0IGZvY3VzQ2hhbmdlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG4gIHNldCBmb2N1c2VkKHN0YXRlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZm9jdXNlZC5uZXh0KHN0YXRlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfdG91Y2hlZENoYW5nZTogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgZ2V0IHRvdWNoZWRDaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdWNoZWRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9kaXJ0eUNoYW5nZTogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgZ2V0IGRpcnR5Q2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eUNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIG1hcmtBc1RvdWNoZWQoKTogdm9pZCB7XG4gICAgdGhpcy5fdG91Y2hlZENoYW5nZS5uZXh0KCk7XG4gIH1cblxuICBtYXJrQXNEaXJ0eSgpOiB2b2lkIHtcbiAgICB0aGlzLl9kaXJ0eUNoYW5nZS5uZXh0KCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1xuICBCSUdfRU5ESUFOLFxuICBERUZBVUxUX0xPQ0FMRV9GT1JNQVQsXG4gIERFTElNSVRFUl9SRUdFWCxcbiAgSW5wdXREYXRlRGlzcGxheUZvcm1hdCxcbiAgTElUVExFX0VORElBTixcbiAgTElUVExFX0VORElBTl9SRUdFWCxcbiAgTUlERExFX0VORElBTixcbiAgTUlERExFX0VORElBTl9SRUdFWCxcbiAgUlRMX1JFR0VYLFxuICBVU0VSX0lOUFVUX1JFR0VYLFxufSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCwgcGFyc2VUb0ZvdXJEaWdpdFllYXIgfSBmcm9tICcuLi91dGlscy9kYXRlLXV0aWxzJztcblxuaW1wb3J0IHsgTG9jYWxlSGVscGVyU2VydmljZSB9IGZyb20gJy4vbG9jYWxlLWhlbHBlci5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVJT1NlcnZpY2Uge1xuICBwdWJsaWMgY2xkckxvY2FsZURhdGVGb3JtYXQ6IHN0cmluZyA9IERFRkFVTFRfTE9DQUxFX0ZPUk1BVDtcbiAgcHJpdmF0ZSBsb2NhbGVEaXNwbGF5Rm9ybWF0OiBJbnB1dERhdGVEaXNwbGF5Rm9ybWF0ID0gTElUVExFX0VORElBTjtcbiAgcHJpdmF0ZSBkZWxpbWl0ZXJzOiBbc3RyaW5nLCBzdHJpbmddID0gWycvJywgJy8nXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9sb2NhbGVIZWxwZXJTZXJ2aWNlOiBMb2NhbGVIZWxwZXJTZXJ2aWNlKSB7XG4gICAgdGhpcy5jbGRyTG9jYWxlRGF0ZUZvcm1hdCA9IHRoaXMuX2xvY2FsZUhlbHBlclNlcnZpY2UubG9jYWxlRGF0ZUZvcm1hdDtcbiAgICB0aGlzLmluaXRpYWxpemVMb2NhbGVEaXNwbGF5Rm9ybWF0KCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVMb2NhbGVEaXNwbGF5Rm9ybWF0KCk6IHZvaWQge1xuICAgIGNvbnN0IGZvcm1hdDogc3RyaW5nID0gdGhpcy5jbGRyTG9jYWxlRGF0ZUZvcm1hdC50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmIChMSVRUTEVfRU5ESUFOX1JFR0VYLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID0gTElUVExFX0VORElBTjtcbiAgICB9IGVsc2UgaWYgKE1JRERMRV9FTkRJQU5fUkVHRVgudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPSBNSURETEVfRU5ESUFOO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBldmVyeXRoaW5nIGVsc2UgaXMgc2V0IHRvIEJJRy1FTkRJQU4gRk9STUFUXG4gICAgICB0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPSBCSUdfRU5ESUFOO1xuICAgIH1cbiAgICB0aGlzLmV4dHJhY3REZWxpbWl0ZXJzKCk7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3REZWxpbWl0ZXJzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsZHJMb2NhbGVEYXRlRm9ybWF0KSB7XG4gICAgICAvLyBTYW5pdGl6ZSBEYXRlIEZvcm1hdC4gUmVtb3ZlIFJUTCBjaGFyYWN0ZXJzLlxuICAgICAgLy8gRklYTUU6IFdoZW4gd2Ugc3VwcG9ydCBSVEwsIHJlbW92ZSB0aGlzIGFuZCBoYW5kbGUgaXQgY29ycmVjdGx5LlxuICAgICAgY29uc3QgbG9jYWxlRm9ybWF0OiBzdHJpbmcgPSB0aGlzLmNsZHJMb2NhbGVEYXRlRm9ybWF0LnJlcGxhY2UoUlRMX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCBkZWxpbWl0ZXJzOiBzdHJpbmdbXSA9IGxvY2FsZUZvcm1hdC5zcGxpdChERUxJTUlURVJfUkVHRVgpO1xuXG4gICAgICAvLyBOT1RFOiBUaGUgc3BsaXQgZnJvbSB0aGUgQ0xEUiBkYXRlIGZvcm1hdCBzaG91bGQgYWx3YXlzIHJlc3VsdFxuICAgICAgLy8gaW4gYW4gYXJhcnkgd2l0aCA0IGVsZW1lbnRzLiBUaGUgMXN0IGFuZCB0aGUgMm5kIHZhbHVlcyBhcmUgdGhlIGRlbGltaXRlcnNcbiAgICAgIC8vIHdlIHdpbGwgdXNlIGluIG9yZGVyLlxuICAgICAgLy8gRWc6IFwiZGQvTU0veVwiLnNwbGl0KC9kK3xtK3x5Ky9pKSByZXN1bHRzIGluIFtcIlwiLCBcIi9cIiwgXCIvXCIsIFwiXCJdXG4gICAgICBpZiAoZGVsaW1pdGVycyAmJiBkZWxpbWl0ZXJzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB0aGlzLmRlbGltaXRlcnMgPSBbZGVsaW1pdGVyc1sxXSwgZGVsaW1pdGVyc1syXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIGRhdGUgZm9ybWF0IHJlY2VpdmVkLiBEZWxpbWl0ZXJzIGV4dHJhY3RlZDogJywgZGVsaW1pdGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG9Mb2NhbGVEaXNwbGF5Rm9ybWF0U3RyaW5nKGRhdGU6IERhdGUpOiBzdHJpbmcge1xuICAgIGlmIChkYXRlKSB7XG4gICAgICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGVObzogbnVtYmVyID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICBjb25zdCBtb250aE5vOiBudW1iZXIgPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgY29uc3QgZGF0ZVN0cjogc3RyaW5nID0gZGF0ZU5vID4gOSA/IGRhdGVOby50b1N0cmluZygpIDogJzAnICsgZGF0ZU5vO1xuICAgICAgY29uc3QgbW9udGhTdHI6IHN0cmluZyA9IG1vbnRoTm8gPiA5ID8gbW9udGhOby50b1N0cmluZygpIDogJzAnICsgbW9udGhObztcbiAgICAgIGlmICh0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPT09IExJVFRMRV9FTkRJQU4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGVTdHIgKyB0aGlzLmRlbGltaXRlcnNbMF0gKyBtb250aFN0ciArIHRoaXMuZGVsaW1pdGVyc1sxXSArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID09PSBNSURETEVfRU5ESUFOKSB7XG4gICAgICAgIHJldHVybiBtb250aFN0ciArIHRoaXMuZGVsaW1pdGVyc1swXSArIGRhdGVTdHIgKyB0aGlzLmRlbGltaXRlcnNbMV0gKyBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpICsgdGhpcy5kZWxpbWl0ZXJzWzBdICsgbW9udGhTdHIgKyB0aGlzLmRlbGltaXRlcnNbMV0gKyBkYXRlU3RyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXJUZXh0KCk6IHN0cmluZyB7XG4gICAgY29uc3QgZm9ybWF0OiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10gPSB0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQuZm9ybWF0O1xuICAgIHJldHVybiBmb3JtYXRbMF0gKyB0aGlzLmRlbGltaXRlcnNbMF0gKyBmb3JtYXRbMV0gKyB0aGlzLmRlbGltaXRlcnNbMV0gKyBmb3JtYXRbMl07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBtb250aCBlbnRlcmVkIGJ5IHRoZSB1c2VyIGlzIHZhbGlkIG9yIG5vdC5cbiAgICogTm90ZTogTW9udGggaXMgMCBiYXNlZC5cbiAgICovXG4gIHByaXZhdGUgaXNWYWxpZE1vbnRoKG1vbnRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gbW9udGggPiAtMSAmJiBtb250aCA8IDEyO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZGF0ZSBpcyB2YWxpZCBkZXBlbmRpbmcgb24gdGhlIHllYXIgYW5kIG1vbnRoIHByb3ZpZGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBpc1ZhbGlkRGF0ZSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkYXRlID4gMCAmJiBkYXRlIDw9IGdldE51bWJlck9mRGF5c0luVGhlTW9udGgoeWVhciwgbW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgcGFyYW1ldGVycyBwcm92aWRlZCBhbmQgcmV0dXJucyB0aGUgZGF0ZS5cbiAgICogSWYgdGhlIHBhcmFtZXRlcnMgYXJlIG5vdFxuICAgKiB2YWxpZCB0aGVuIHJldHVybiBudWxsLlxuICAgKiBOT1RFOiAoTW9udGggaGVyZSBpcyAxIGJhc2VkIHNpbmNlIHRoZSB1c2VyIGhhcyBwcm92aWRlZCB0aGF0IGFzIGFuIGlucHV0KVxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZUFuZEdldERhdGUoeWVhcjogc3RyaW5nLCBtb250aDogc3RyaW5nLCBkYXRlOiBzdHJpbmcpOiBEYXRlIHtcbiAgICAvLyBJIGRvbid0IGtub3cgd2hhdHMgd3Jvbmcgd2l0aCB0aGUgVFMgY29tcGlsZXIuIEl0IHRocm93cyBhbiBlcnJvciBpZiBJIHdyaXRlXG4gICAgLy8gdGhlIGJlbG93IGlmIHN0YXRlbWVudC4gVGhlIGVycm9yIGlzOlxuICAgIC8vIE9wZXJhdG9yICchPT0nIGNhbm5vdCBiZSBhcHBsaWVkIHRvIHR5cGVzICcyJyBhbmQgJzQnXG4gICAgLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTI3OTQjaXNzdWVjb21tZW50LTI3MDM0MjkzNlxuICAgIC8qXG4gICAgICAgIGlmICh5ZWFyLmxlbmd0aCAhPT0gMiB8fCB5ZWFyLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIC8vIEluc3RlYWQgSSBoYXZlIHRvIHdyaXRlIHRoZSBsb2dpYyBsaWtlIHRoaXMgeC0oXG4gICAgY29uc3QgeTogbnVtYmVyID0gK3llYXI7XG4gICAgY29uc3QgbTogbnVtYmVyID0gK21vbnRoIC0gMTsgLy8gbW9udGggaXMgMCBiYXNlZFxuICAgIGNvbnN0IGQ6IG51bWJlciA9ICtkYXRlO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkTW9udGgobSkgfHwgIXRoaXMuaXNWYWxpZERhdGUoeSwgbSwgZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQ6IG51bWJlciA9IHBhcnNlVG9Gb3VyRGlnaXRZZWFyKHkpO1xuICAgIHJldHVybiByZXN1bHQgIT09IC0xID8gbmV3IERhdGUocmVzdWx0LCBtLCBkKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBpbnB1dCBwcm92aWRlZCBieSB0aGUgdXNlciBpcyB2YWxpZC5cbiAgICovXG4gIGlzVmFsaWRJbnB1dChkYXRlOiBzdHJpbmcpOiBEYXRlIHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBkYXRlUGFydHM6IHN0cmluZ1tdID0gZGF0ZS5tYXRjaChVU0VSX0lOUFVUX1JFR0VYKTtcbiAgICBpZiAoIWRhdGVQYXJ0cyB8fCBkYXRlUGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgW2ZpcnN0UGFydCwgc2Vjb25kUGFydCwgdGhpcmRQYXJ0XSA9IGRhdGVQYXJ0cztcbiAgICBpZiAodGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID09PSBMSVRUTEVfRU5ESUFOKSB7XG4gICAgICAvLyBzZWNvbmRQYXJ0IGlzIG1vbnRoICYmIGZpcnN0UGFydCBpcyBkYXRlXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUFuZEdldERhdGUodGhpcmRQYXJ0LCBzZWNvbmRQYXJ0LCBmaXJzdFBhcnQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID09PSBNSURETEVfRU5ESUFOKSB7XG4gICAgICAvLyBmaXJzdFBhcnQgaXMgbW9udGggJiYgc2Vjb25kUGFydCBpcyBkYXRlXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUFuZEdldERhdGUodGhpcmRQYXJ0LCBmaXJzdFBhcnQsIHNlY29uZFBhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZWNvbmRQYXJ0IGlzIG1vbnRoICYmIHRoaXJkUGFydCBpcyBkYXRlXG4gICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUFuZEdldERhdGUoZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0LCB0aGlyZFBhcnQpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vLyBpUGFkIG1pbmkgc2NyZWVuIHdpZHRoXG4vLyBodHRwOi8vc3RlcGhlbi5pby9tZWRpYXF1ZXJpZXMvI2lQYWRNaW5pXG5leHBvcnQgY29uc3QgREFURVBJQ0tFUl9FTkFCTEVfQlJFQUtQT0lOVDogbnVtYmVyID0gNzY4O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgREFURVBJQ0tFUl9FTkFCTEVfQlJFQUtQT0lOVCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzJztcbmltcG9ydCB7IE1PQklMRV9VU0VSQUdFTlRfUkVHRVggfSBmcm9tICcuLi91dGlscy9jb25zdGFudHMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSkge1xuICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgdGhpcy5faXNVc2VyQWdlbnRNb2JpbGUgPSBNT0JJTEVfVVNFUkFHRU5UX1JFR0VYLnRlc3QoX2RvY3VtZW50LmRlZmF1bHRWaWV3Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdGhpcy5faW5uZXJXaWR0aCA9IF9kb2N1bWVudC5kZWZhdWx0Vmlldy5pbm5lcldpZHRoO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2lzVXNlckFnZW50TW9iaWxlOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2lubmVyV2lkdGg6IG51bWJlcjtcblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY2FsZW5kYXIgc2hvdWxkIGJlIGFjdGl2ZSBvciBub3QuXG4gICAqIElmIHRoZSB1c2VyIGFnZW50IGlzIG1vYmlsZSBhbmQgdGhlIHNjcmVlbiB3aWR0aCBpcyBsZXNzIHRoYW4gREFURVBJQ0tFUl9BQ1RJVkVfQlJFQUtQT0lOVFxuICAgKiB0aGVuIHRoZSBjYWxlbmRhciBpcyBpbmFjdGl2ZS5cbiAgICovXG4gIGdldCBpc0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudFxuICAgIC8vIFdoYXQgdGhleSByZWNvbW1lbmQgaXM6XG4gICAgLy9cIkluIHN1bW1hcnksIHdlIHJlY29tbWVuZCBsb29raW5nIGZvciB0aGUgc3RyaW5nICdNb2JpJ1xuICAgIC8vIGFueXdoZXJlIGluIHRoZSBVc2VyIEFnZW50IHRvIGRldGVjdCBhIG1vYmlsZSBkZXZpY2UuXCJcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLl9pbm5lcldpZHRoIDwgREFURVBJQ0tFUl9FTkFCTEVfQlJFQUtQT0lOVCAmJiB0aGlzLl9pc1VzZXJBZ2VudE1vYmlsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEluamVjdCwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IExheW91dFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5cbmltcG9ydCB7IERhdGVGb3JtQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWZvcm0tY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVJT1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWlvLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1lbmFibGVkLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9jYWxlSGVscGVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xvY2FsZS1oZWxwZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSVNfTkVXX0ZPUk1TX0xBWU9VVCB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmV3LWZvcm1zLnNlcnZpY2UnO1xuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGNvbnRhaW5zIHR3byB0ZW1wbGF0ZSBmb3IgdGhlIG9sZCBhbmQgbmV3IGZvcm1zIGxheW91dHMuXG4gKiBXaGVuIGl0IGlzIHRpbWUgdG8gcmVtb3ZlIHRoZSBvbGQgZm9ybXMgbGF5b3V0cyBzdXBwb3J0LCByZW1vdmUgdGhlIG5nLXRlbXBsYXRlc1xuICogYW5kIG5nLWNvbnRhaW5lciwgYW5kIGp1c3Qga2VlcCB0aGUgaW5uZXIgY29udGVudCBvZiB0aGUgI25ld0xheW91dCBhcyB0aGUgdGVtcGxhdGVcbiAqIGFuZCBtb3ZlIHRoZSBuZy1jb250ZW50IGZvciBjbHJEYXRlLlxuICovXG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kYXRlLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLXRlbXBsYXRlICNvbGRMYXlvdXQ+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNsckRhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImRhdGVwaWNrZXItdHJpZ2dlclwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlRGF0ZXBpY2tlcigkZXZlbnQpXCJcbiAgICAgICAgICAgICpuZ0lmPVwiaXNFbmFibGVkXCI+XG4gICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJjYWxlbmRhclwiIGNsYXNzPVwiZGF0ZXBpY2tlci10cmlnZ2VyLWljb25cIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLm9wZW5cIj48L2Nsci1pY29uPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGNsci1kYXRlcGlja2VyLXZpZXctbWFuYWdlciAqY2xySWZPcGVuIGNsckZvY3VzVHJhcD48L2Nsci1kYXRlcGlja2VyLXZpZXctbWFuYWdlcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIFxuICAgIDxuZy10ZW1wbGF0ZSAjbmV3TGF5b3V0PlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1pbnB1dC13cmFwcGVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNsci1pbnB1dC1ncm91cFwiIFtjbGFzcy5jbHItZm9jdXNdPVwiZm9jdXNcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjbHJEYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImRhdGVwaWNrZXItdHJpZ2dlclwiIChjbGljayk9XCJ0b2dnbGVEYXRlcGlja2VyKCRldmVudClcIiAqbmdJZj1cImlzRW5hYmxlZFwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mub3BlblwiIFtkaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZFwiPlxuICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJjYWxlbmRhclwiIGNsYXNzPVwiY2xyLWlucHV0LWdyb3VwLWljb24tYWN0aW9uXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGNsci1kYXRlcGlja2VyLXZpZXctbWFuYWdlciAqY2xySWZPcGVuIGNsckZvY3VzVHJhcD48L2Nsci1kYXRlcGlja2VyLXZpZXctbWFuYWdlcj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8Y2xyLWljb24gY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBcbiAgICA8bmctdGVtcGxhdGUgI2NsckRhdGU+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyRGF0ZV1cIj48L25nLWNvbnRlbnQ+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibmV3Rm9ybXNMYXlvdXQ7IHRoZW4gbmV3TGF5b3V0IGVsc2Ugb2xkTGF5b3V0XCI+PC9uZy1jb250YWluZXI+XG4gICAgYCxcbiAgcHJvdmlkZXJzOiBbXG4gICAgQ29udHJvbElkU2VydmljZSxcbiAgICBJZk9wZW5TZXJ2aWNlLFxuICAgIExvY2FsZUhlbHBlclNlcnZpY2UsXG4gICAgSWZFcnJvclNlcnZpY2UsXG4gICAgQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBGb2N1c1NlcnZpY2UsXG4gICAgTmdDb250cm9sU2VydmljZSxcbiAgICBEYXRlSU9TZXJ2aWNlLFxuICAgIERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBEYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UsXG4gICAgRGF0ZUZvcm1Db250cm9sU2VydmljZSxcbiAgXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0ZS1jb250YWluZXJdJzogJyFuZXdGb3Jtc0xheW91dCcsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICduZXdGb3Jtc0xheW91dCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVDb250YWluZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25EZXN0cm95IHtcbiAgX2R5bmFtaWM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBmb2N1cyA9IGZhbHNlO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2lmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZGF0ZU5hdmlnYXRpb25TZXJ2aWNlOiBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlOiBEYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBkYXRlRm9ybUNvbnRyb2xTZXJ2aWNlOiBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzLFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIHByaXZhdGUgZm9jdXNTZXJ2aWNlOiBGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSVNfTkVXX0ZPUk1TX0xBWU9VVClcbiAgICBwdWJsaWMgbmV3Rm9ybXNMYXlvdXQ6IGJvb2xlYW4sXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5faWZPcGVuU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZShvcGVuID0+IHtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVDYWxlbmRhcigpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmZvY3VzU2VydmljZS5mb2N1c0NoYW5nZS5zdWJzY3JpYmUoc3RhdGUgPT4ge1xuICAgICAgICB0aGlzLmZvY3VzID0gc3RhdGU7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBjb250cm9sLmludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xhc3NlcyB0byBhcHBseSB0byB0aGUgY29udHJvbFxuICAgKi9cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGNvbnRyb2wgbmVlZHMgdG8gYWRkIGdyaWQgY2xhc3Nlc1xuICAgKi9cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIERhdGVwaWNrZXIgaXMgZW5hYmxlZCBvciBub3QuIElmIGRpc2FibGVkLCBoaWRlcyB0aGUgZGF0ZXBpY2tlciB0cmlnZ2VyLlxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlLmlzRW5hYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgdGhlIHVzZXIgaW5wdXQgYW5kIEluaXRpYWxpemVzIHRoZSBDYWxlbmRhciBldmVyeXRpbWUgdGhlIGRhdGVwaWNrZXIgcG9wb3ZlciBpcyBvcGVuLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplQ2FsZW5kYXIoKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmluaXRpYWxpemVDYWxlbmRhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIERhdGVwaWNrZXIgUG9wb3Zlci5cbiAgICovXG4gIHRvZ2dsZURhdGVwaWNrZXIoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICB0aGlzLl9pZk9wZW5TZXJ2aWNlLnRvZ2dsZVdpdGhFdmVudChldmVudCk7XG4gICAgdGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLm1hcmtBc1RvdWNoZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnN1YnNjcmliZSBmcm9tIHN1YnNjcmlwdGlvbnMuXG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBQTEFURk9STV9JRCxcbiAgUmVuZGVyZXIyLFxuICBTZWxmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5cbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuXG5pbXBvcnQgeyBDbHJEYXRlQ29udGFpbmVyIH0gZnJvbSAnLi9kYXRlLWNvbnRhaW5lcic7XG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vbW9kZWwvZGF5Lm1vZGVsJztcbmltcG9ydCB7IERhdGVGb3JtQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWZvcm0tY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVJT1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWlvLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1lbmFibGVkLnNlcnZpY2UnO1xuaW1wb3J0IHsgSVNfTkVXX0ZPUk1TX0xBWU9VVCB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmV3LWZvcm1zLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRGF0ZV0nLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRlLWlucHV0XSc6ICchbmV3Rm9ybXNMYXlvdXQnLFxuICAgICdbY2xhc3MuY2xyLWlucHV0XSc6ICduZXdGb3Jtc0xheW91dCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVJbnB1dCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJEYXRlQ29udGFpbmVyPiBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gYWxsIHRoZSBzZXJ2aWNlcyBhbmQgcXVlcmllcyBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIC8vV2UgbmVlZCB0aGlzIHZhcmlhYmxlIGJlY2F1c2UgaWYgdGhlIGRhdGUgaW5wdXQgaGFzIGEgdmFsdWUgaW5pdGlhbGl6ZWRcbiAgLy93ZSBkbyBub3Qgb3V0cHV0IGl0LiBUaGlzIHZhcmlhYmxlIGlzIGZhbHNlIGR1cmluZyBpbml0aWFsIGxvYWQuIFdlIG1ha2Ugc3VyZSB0aGF0XG4gIC8vZHVyaW5nIGluaXRpYWwgbG9hZCBkYXlNb2RlbE91dHB1dHRlZCBpcyBlcXVhbCB0byB0aGUgdmFsdWUgZW50ZXJlZCBieSB0aGUgdXNlciBzbyB0aGF0IGluaXRpYWxpemVkXG4gIC8vdmFsdWUgaXNuJ3QgZW1pdHRlZCBiYWNrIHRvIHRoZSB1c2VyLiBBZnRlciBpbml0aWFsIGxvYWQsXG4gIC8vd2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhbmQgdGhlIGRheU1vZGVsT3V0cHV0dGVkIGlzIHNldCBvbmx5XG4gIC8vd2hlbiB0aGUgT3V0cHV0IGlzIGVtaXR0ZWQgdG8gdGhlIHVzZXIuXG4gIHByaXZhdGUgcHJldmlvdXNPdXRwdXRJbml0aWFsaXplZEZsYWc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBwcmV2aW91c091dHB1dDogRGF5TW9kZWw7XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplUHJldmlvdXNPdXRwdXQoZGF5TW9kZWw6IERheU1vZGVsKSB7XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzT3V0cHV0SW5pdGlhbGl6ZWRGbGFnKSB7XG4gICAgICB0aGlzLnByZXZpb3VzT3V0cHV0ID0gZGF5TW9kZWw7XG4gICAgICB0aGlzLnByZXZpb3VzT3V0cHV0SW5pdGlhbGl6ZWRGbGFnID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKSBjbHJOZXdMYXlvdXQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250YWluZXI6IENsckRhdGVDb250YWluZXIsXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgZWxSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByaXZhdGUgX25nQ29udHJvbDogTmdDb250cm9sLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RhdGVJT1NlcnZpY2U6IERhdGVJT1NlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGF0ZU5hdmlnYXRpb25TZXJ2aWNlOiBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlOiBEYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkYXRlRm9ybUNvbnRyb2xTZXJ2aWNlOiBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZm9jdXNTZXJ2aWNlOiBGb2N1c1NlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KElTX05FV19GT1JNU19MQVlPVVQpXG4gICAgcHVibGljIG5ld0Zvcm1zTGF5b3V0OiBib29sZWFuXG4gICkge1xuICAgIHN1cGVyKENsckRhdGVDb250YWluZXIsIHZjciwgNCk7XG5cbiAgICBpZiAoY29udHJvbENsYXNzU2VydmljZSkge1xuICAgICAgY29udHJvbENsYXNzU2VydmljZS5jbGFzc05hbWUgPSB0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAxLiBQb3B1bGF0ZSBzZXJ2aWNlcyBpZiB0aGUgZGF0ZSBjb250YWluZXIgaXMgbm90IHByZXNlbnQuXG4gICAqIDIuIEluaXRpYWxpemUgU3Vic2NyaXB0aW9ucy5cbiAgICogMy4gUHJvY2VzcyBVc2VyIElucHV0LlxuICAgKi9cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICBpZiAodGhpcy5uZ0NvbnRyb2xTZXJ2aWNlICYmIHRoaXMuY29udHJvbCkge1xuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLnNldENvbnRyb2wodGhpcy5jb250cm9sKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5wb3B1bGF0ZUNvbnRhaW5lclNlcnZpY2VzKCk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB0aGlzLnByb2Nlc3NJbml0aWFsSW5wdXRzKCk7XG4gICAgaWYgKHRoaXMuY2xyTmV3TGF5b3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubmV3Rm9ybXNMYXlvdXQgPSAhIXRoaXMuY2xyTmV3TGF5b3V0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBpbnB1dHMgaW5pdGlhbGl6ZWQgYnkgdGhlIHVzZXIgd2hpY2ggd2VyZSBtaXNzZWRcbiAgICogYmVjYXVzZSBvZiBsYXRlIHN1YnNjcmlwdGlvbnMgb3IgbGlmZWN5Y2xlIG1ldGhvZCBjYWxscy5cbiAgICovXG4gIHByaXZhdGUgcHJvY2Vzc0luaXRpYWxJbnB1dHMoKTogdm9pZCB7XG4gICAgdGhpcy5wcm9jZXNzVXNlckRhdGVPYmplY3QodGhpcy5kYXRlVmFsdWVPbkluaXRpYWxMb2FkKTtcblxuICAgIC8vIEhhbmRsZSBJbml0YWwgVmFsdWUgZnJvbSBSZWFjdGl2ZSBGb3Jtc1xuICAgIC8vIFRPRE86IFdlIGFyZSByZXBlYXRpbmcgdGhpcyBsb2dpYyBhdCBtdWx0aXBsZSBwbGFjZXMuIFRoaXMgbWFrZXMgbWUgdGhpbmtcbiAgICAvLyBpZiB0aGlzIGNsYXNzIHNob3VsZCBoYXZlIGltcGxlbWVudGVkIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UuXG4gICAgLy8gV2lsbCBleHBsb3JlIHRoYXQgbGF0ZXIgYW5kIHNlZSBpZiBpdHMgYSBjbGVhbmVyIHNvbHV0aW9uLlxuICAgIGlmICh0aGlzLl9uZ0NvbnRyb2wgJiYgdGhpcy5fbmdDb250cm9sLnZhbHVlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUlucHV0VmFsdWUodGhpcy5fbmdDb250cm9sLnZhbHVlKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVByZXZpb3VzT3V0cHV0KHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIHRoZSBpbml0aWFsIGlucHV0IHNldCBieSB0aGUgdXNlciBvbiB0byB0aGUgaW5wdXQgZmllbGQuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gSSBkb24ndCBrbm93IHdoeSBJIGhhdmUgdG8gZG8gdGhpcyBidXQgYWZ0ZXIgdXNpbmcgdGhlIG5ldyBIb3N0V3JhcHBpbmcgTW9kdWxlIEkgaGF2ZSB0byBkZWxheSB0aGUgcHJvY2Vzc2luZ1xuICAgIC8vIG9mIHRoZSBpbml0aWFsIElucHV0IHNldCBieSB0aGUgdXNlciB0byBoZXJlLiAgSWYgSSBkbyBub3QgMiBpc3N1ZXMgb2NjdXI6XG4gICAgLy8gMS4gdGhlIElucHV0IHNldHRlciBpcyBjYWxsZWQgYmVmb3JlIG5nT25Jbml0LiBuZ09uSW5pdCBpbml0aWFsaXplcyB0aGUgc2VydmljZXMgd2l0aG91dCB3aGljaCB0aGUgc2V0dGVyXG4gICAgLy8gZmFpbHNcbiAgICAvLyAyLiBUaGUgUmVuZGVyZXIgZG9lc24ndCB3b3JrIGJlZm9yZSBuZ0FmdGVyVmlld0luaXRcbiAgICAvLyhJdCB1c2VkIHRvIGJlZm9yZSB0aGUgbmV3IEhvc3RXcmFwcGluZyBNb2R1bGUgZm9yIHNvbWUgcmVhc29uKS5cbiAgICAvLyBJIG5lZWQgdGhlIHJlbmRlcmVyIHRvIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgb24gdGhlIGlucHV0IHRvIG1ha2Ugc3VyZSB0aGF0IGlmIHRoZSB1c2VyIGhhcyBzdXBwbGllZCBhIERhdGVcbiAgICAvLyBpbnB1dCBvYmplY3QsICB3ZSByZWZsZWN0IGl0IHdpdGggdGhlIHJpZ2h0IGRhdGUgb24gdGhlIGlucHV0IGZpZWxkIHVzaW5nIHRoZSBJTyBzZXJ2aWNlLiAgSSBhbSBub3Qgc3VyZSBpZlxuICAgIC8vIHRoZXNlIGFyZSBtYWpvciBpc3N1ZXMgb3Igbm90IGJ1dCBqdXN0IG5vdGluZyB0aGVtIGRvd24gaGVyZS5cbiAgICBpZiAodGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgICBjb25zdCBzZWxEYXk6IERheU1vZGVsID0gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdGVkRGF5O1xuICAgICAgaWYgKHNlbERheSkge1xuICAgICAgICBjb25zdCBkYXRlU3RyOiBzdHJpbmcgPSB0aGlzLl9kYXRlSU9TZXJ2aWNlLnRvTG9jYWxlRGlzcGxheUZvcm1hdFN0cmluZyhzZWxEYXkudG9EYXRlKCkpO1xuICAgICAgICB0aGlzLndyaXRlRGF0ZVN0clRvSW5wdXRGaWVsZChkYXRlU3RyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5pbml0aWFsTG9hZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBmcm9tIHRoZSBzdWJzY3JpcHRpb25zLlxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyB0aGUgc2VydmljZXMgZnJvbSB0aGUgY29udGFpbmVyIGNvbXBvbmVudC5cbiAgICovXG4gIHByaXZhdGUgcG9wdWxhdGVDb250YWluZXJTZXJ2aWNlcygpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlSU9TZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXIoRGF0ZUlPU2VydmljZSk7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXIoRGF0ZU5hdmlnYXRpb25TZXJ2aWNlKTtcbiAgICB0aGlzLl9kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UgPSB0aGlzLmdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcihEYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UpO1xuICAgIHRoaXMuZGF0ZUZvcm1Db250cm9sU2VydmljZSA9IHRoaXMuZ2V0UHJvdmlkZXJGcm9tQ29udGFpbmVyKERhdGVGb3JtQ29udHJvbFNlcnZpY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyB0aGUgZGF0ZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGlucHV0IGZpZWxkXG4gICAqL1xuICBwcml2YXRlIHdyaXRlRGF0ZVN0clRvSW5wdXRGaWVsZCh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbExvYWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBwcml2YXRlIGRhdGVWYWx1ZU9uSW5pdGlhbExvYWQ6IERhdGU7XG5cbiAgLyoqXG4gICAqIEphdmFzY3JpcHQgRGF0ZSBvYmplY3QgaW5wdXQgc2V0IGJ5IHRoZSB1c2VyLlxuICAgKi9cbiAgQElucHV0KCdjbHJEYXRlJylcbiAgc2V0IGRhdGUodmFsdWU6IERhdGUpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsTG9hZCkge1xuICAgICAgLy8gU3RvcmUgZGF0ZSB2YWx1ZSBwYXNzZWQgYnkgdGhlIHVzZXIgdG8gcHJvY2VzcyBhZnRlciB0aGUgc2VydmljZXMgaGF2ZSBiZWVuIGluaXRpYWxpemVkIGJ5XG4gICAgICAvLyB0aGUgbmdPbkluaXQgaG9vay5cbiAgICAgIHRoaXMuZGF0ZVZhbHVlT25Jbml0aWFsTG9hZCA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb2Nlc3NVc2VyRGF0ZU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIGRhdGUgb2JqZWN0IHRvIGNoZWNrIGlmIGl0cyB2YWxpZCBvciBub3QuXG4gICAqL1xuICBwcml2YXRlIHByb2Nlc3NVc2VyRGF0ZU9iamVjdCh2YWx1ZTogRGF0ZSkge1xuICAgIGlmICh0aGlzLl9kYXRlSU9TZXJ2aWNlKSB7XG4gICAgICAvLyBUaGUgZGF0ZSBvYmplY3QgaXMgY29udmVydGVkIGJhY2sgdG8gc3RyaW5nIGJlY2F1c2UgaW4gSmF2YXNjcmlwdCB5b3UgY2FuIGNyZWF0ZSBhIGRhdGUgb2JqZWN0XG4gICAgICAvLyBsaWtlIHRoaXM6IG5ldyBEYXRlKFwiVGVzdFwiKS4gVGhpcyBpcyBhIGRhdGUgb2JqZWN0IGJ1dCBpdCBpcyBpbnZhbGlkLiBDb252ZXJ0aW5nIHRoZSBkYXRlIG9iamVjdFxuICAgICAgLy8gdGhhdCB0aGUgdXNlciBwYXNzZWQgaGVscHMgdXMgdG8gdmVyaWZ5IHRoZSB2YWxpZGl0eSBvZiB0aGUgZGF0ZSBvYmplY3QuXG4gICAgICBjb25zdCBkYXRlU3RyOiBzdHJpbmcgPSB0aGlzLl9kYXRlSU9TZXJ2aWNlLnRvTG9jYWxlRGlzcGxheUZvcm1hdFN0cmluZyh2YWx1ZSk7XG4gICAgICB0aGlzLnVwZGF0ZUlucHV0VmFsdWUoZGF0ZVN0cik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVJbnB1dFZhbHVlKGRhdGVTdHI6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGRhdGU6IERhdGUgPSB0aGlzLl9kYXRlSU9TZXJ2aWNlLmlzVmFsaWRJbnB1dChkYXRlU3RyKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgY29uc3QgZGF5TW9kZWw6IERheU1vZGVsID0gbmV3IERheU1vZGVsKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgICBpZiAoIWRheU1vZGVsLmlzRXF1YWwodGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdGVkRGF5KSkge1xuICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBkYXlNb2RlbDtcbiAgICAgICAgdGhpcy53cml0ZURhdGVTdHJUb0lucHV0RmllbGQoZGF0ZVN0cik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZztcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0ZSBmb3JtYXQgZm9yIHRoZSBwbGFjZWhvbGRlciBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIGlucHV0IHNob3VsZCBiZSBlbnRlcmVkIGJ5IHRoZSB1c2VyLlxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnBsYWNlaG9sZGVyJylcbiAgZ2V0IHBsYWNlaG9sZGVyVGV4dCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBsYWNlaG9sZGVyID8gdGhpcy5wbGFjZWhvbGRlciA6IHRoaXMuX2RhdGVJT1NlcnZpY2UucGxhY2Vob2xkZXJUZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlucHV0IHR5cGUgdG8gdGV4dCB3aGVuIHRoZSBkYXRlcGlja2VyIGlzIGVuYWJsZWQuIFJldmVydHMgYmFjayB0byB0aGUgbmF0aXZlIGRhdGUgaW5wdXRcbiAgICogd2hlbiB0aGUgZGF0ZXBpY2tlciBpcyBkaXNhYmxlZC4gRGF0ZXBpY2tlciBpcyBkaXNhYmxlZCBvbiBtb2JpbGVzLlxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnR5cGUnKVxuICBnZXQgaW5wdXRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgdGhpcy5fZGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlLmlzRW5hYmxlZCA/ICd0ZXh0JyA6ICdkYXRlJztcbiAgfVxuXG4gIC8vXG4gIC8vIE91dHB1dCBNYW5hZ2VtZW50XG4gIC8vIE5vdGU6IEZvciBub3cgd2Ugd2lsbCBub3QgZW1pdCBib3RoIGNsckRhdGVDaGFuZ2UgYW5kIG5nQ29udHJvbCBvdXRwdXRzXG4gIC8vIGF0IHRoZSBzYW1lIHRpbWUuIFRoaXMgcmVxdWlyZXMgdXMgdG8gbGlzdGVuIHRvIGtleWRvd24gYW5kIGJsdXIgZXZlbnRzIHRvIGZpZ3VyZSBvdXRcbiAgLy8gZXhhY3RseSB3aGVuIHRoZSBPdXRwdXQgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gIC8vIE91ciByZWNvbW1lbmRhdGlvbiByaWdodCBub3cgaXMgdG8gZWl0aGVyIHVzZSBjbHJEYXRlIG9yIHVzZSBuZ01vZGVsL0Zvcm1Db250cm9sLlxuICAvLyBEbyBub3QgdXNlIGJvdGggb2YgdGhlbSB0b2dldGhlci5cbiAgLy9cblxuICBAT3V0cHV0KCdjbHJEYXRlQ2hhbmdlJykgX2RhdGVVcGRhdGVkOiBFdmVudEVtaXR0ZXI8RGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KGZhbHNlKTtcblxuICBwcml2YXRlIGVtaXREYXRlT3V0cHV0KGRheU1vZGVsOiBEYXlNb2RlbCk6IHZvaWQge1xuICAgIGlmIChkYXlNb2RlbCAmJiAhZGF5TW9kZWwuaXNFcXVhbCh0aGlzLnByZXZpb3VzT3V0cHV0KSkge1xuICAgICAgdGhpcy5fZGF0ZVVwZGF0ZWQuZW1pdChkYXlNb2RlbC50b0RhdGUoKSk7XG4gICAgICB0aGlzLnByZXZpb3VzT3V0cHV0ID0gZGF5TW9kZWw7XG4gICAgfSBlbHNlIGlmICghZGF5TW9kZWwgJiYgdGhpcy5wcmV2aW91c091dHB1dCkge1xuICAgICAgdGhpcy5fZGF0ZVVwZGF0ZWQuZW1pdChudWxsKTtcbiAgICAgIHRoaXMucHJldmlvdXNPdXRwdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgc2V0Rm9jdXNTdGF0ZXMoKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmZvY3VzU2VydmljZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgc2V0Qmx1clN0YXRlcygpIHtcbiAgICBpZiAodGhpcy5pZkVycm9yU2VydmljZSkge1xuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS50cmlnZ2VyU3RhdHVzQ2hhbmdlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvY3VzU2VydmljZSkge1xuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB0aGlzIG1ldGhvZCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIGlucHV0IGZvY3VzZXMgb3V0IG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2NoYW5nZScsIFsnJGV2ZW50LnRhcmdldCddKVxuICBvblZhbHVlQ2hhbmdlKHRhcmdldDogSFRNTElucHV0RWxlbWVudCkge1xuICAgIGNvbnN0IHZhbHVlOiBzdHJpbmcgPSB0YXJnZXQudmFsdWU7XG4gICAgY29uc3QgZGF0ZTogRGF0ZSA9IHRoaXMuX2RhdGVJT1NlcnZpY2UuaXNWYWxpZElucHV0KHZhbHVlKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgY29uc3QgZGF5TW9kZWw6IERheU1vZGVsID0gbmV3IERheU1vZGVsKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBkYXlNb2RlbDtcbiAgICAgIHRoaXMuZW1pdERhdGVPdXRwdXQoZGF5TW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBudWxsO1xuICAgICAgdGhpcy5lbWl0RGF0ZU91dHB1dChudWxsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBEYXRlSU8gU3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlICYmIHRoaXMuX2RhdGVJT1NlcnZpY2UpIHtcbiAgICAgIC8vIFRoaXMgc3Vic2NyaXB0aW9uIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGRhdGUgZnJvbSB0aGUgcG9wb3Zlci5cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdGVkRGF5Q2hhbmdlLnN1YnNjcmliZSgoZGF5TW9kZWw6IERheU1vZGVsKSA9PiB7XG4gICAgICAgICAgY29uc3QgZGF0ZVN0cjogc3RyaW5nID0gdGhpcy5fZGF0ZUlPU2VydmljZS50b0xvY2FsZURpc3BsYXlGb3JtYXRTdHJpbmcoZGF5TW9kZWwudG9EYXRlKCkpO1xuICAgICAgICAgIHRoaXMud3JpdGVEYXRlU3RyVG9JbnB1dEZpZWxkKGRhdGVTdHIpO1xuICAgICAgICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG5nTW9kZWxDaGFuZ2UgaXMgZmlyZWRcbiAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGVyZSBpcyBhIGJldHRlciB3YXkgdG8gZG8gdGhpcy5cbiAgICAgICAgICAvLyBOT1RFOiBJdHMgaW1wb3J0YW50IHRvIHVzZSBOZ0NvbnRyb2wgYW5kIG5vdCBOZ01vZGVsIGJlY2F1c2VcbiAgICAgICAgICAvLyBOZ01vZGVsIG9ubHkgd29ya3Mgd2l0aCB0ZW1wbGF0ZSBkcml2ZW4gZm9ybXNcbiAgICAgICAgICBpZiAodGhpcy5fbmdDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLl9uZ0NvbnRyb2wuY29udHJvbC5zZXRWYWx1ZShkYXRlU3RyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0RGF0ZU91dHB1dChkYXlNb2RlbCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBXZSBkbyBub3QgZW1pdCBhbiBPdXRwdXQgZnJvbSB0aGlzIHN1YnNjcmlwdGlvbiBiZWNhdXNlXG4gICAgICAvLyB3ZSBvbmx5IGVtaXQgdGhlIE91dHB1dCB3aGVuIHRoZSB1c2VyIGhhcyBmb2N1c2VkIG91dCBvZiB0aGUgaW5wdXQuXG4gICAgICBpZiAodGhpcy5fbmdDb250cm9sKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgICB0aGlzLl9uZ0NvbnRyb2wudmFsdWVDaGFuZ2VzLnN1YnNjcmliZSgodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF0ZTogRGF0ZSA9IHRoaXMuX2RhdGVJT1NlcnZpY2UuaXNWYWxpZElucHV0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRheU1vZGVsOiBEYXlNb2RlbCA9IG5ldyBEYXlNb2RlbChkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBkYXlNb2RlbDtcbiAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplUHJldmlvdXNPdXRwdXQoZGF5TW9kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplUHJldmlvdXNPdXRwdXQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgIHRoaXMuZGF0ZUZvcm1Db250cm9sU2VydmljZS50b3VjaGVkQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX25nQ29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5fbmdDb250cm9sLmNvbnRyb2wubWFya0FzVG91Y2hlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLmRpcnR5Q2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX25nQ29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5fbmdDb250cm9sLmNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgRWxlbWVudFJlZixcbiAgSG9zdEJpbmRpbmcsXG4gIEluamVjdGFibGUsXG4gIEluamVjdG9yLFxuICBPbkRlc3Ryb3ksXG4gIFJlbmRlcmVyMixcbiAgU2tpcFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuaW1wb3J0IHsgRVNDIH0gZnJvbSAnLi4vLi4vdXRpbHMva2V5LWNvZGVzL2tleS1jb2Rlcyc7XG5cbmltcG9ydCB7IFBvaW50LCBQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyJztcbmltcG9ydCB7IFBvcG92ZXJPcHRpb25zIH0gZnJvbSAnLi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcblxuLy8gTGl0ZXJhbGx5IGFueSBhbm5vdGF0aW9uIHdvdWxkIHdvcmsgaGVyZSwgYnV0IHdyaXRpbmcgb3VyIG93biBASG9uZXlCYWRnZXIgYW5ub3RhdGlvbiBmZWVscyBvdmVya2lsbC5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFBvcG92ZXIgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkLCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihpbmplY3RvcjogSW5qZWN0b3IsIEBTa2lwU2VsZigpIHByb3RlY3RlZCBwYXJlbnRIb3N0OiBFbGVtZW50UmVmKSB7XG4gICAgdGhpcy5lbCA9IGluamVjdG9yLmdldChFbGVtZW50UmVmKTtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2UgPSBpbmplY3Rvci5nZXQoSWZPcGVuU2VydmljZSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IGluamVjdG9yLmdldChSZW5kZXJlcjIpO1xuICAgIC8vIERlZmF1bHQgYW5jaG9yIGlzIHRoZSBwYXJlbnQgaG9zdFxuICAgIHRoaXMuYW5jaG9yRWxlbSA9IHBhcmVudEhvc3QubmF0aXZlRWxlbWVudDtcblxuICAgIHRoaXMucG9wb3Zlckluc3RhbmNlID0gbmV3IFBvcG92ZXIodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuaWZPcGVuU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICB0aGlzLmFuY2hvcigpO1xuICAgICAgICB0aGlzLmF0dGFjaEVTQ0xpc3RlbmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5kZXRhY2hFU0NMaXN0ZW5lcigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmlmT3BlblNlcnZpY2Uub3Blbikge1xuICAgICAgdGhpcy5hbmNob3IoKTtcbiAgICAgIHRoaXMuYXR0YWNoRVNDTGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZWw6IEVsZW1lbnRSZWY7XG4gIHByb3RlY3RlZCBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlO1xuICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyMjtcblxuICBwcml2YXRlIHBvcG92ZXJJbnN0YW5jZTogUG9wb3ZlcjtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIHVwZGF0ZUFuY2hvciA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBhbmNob3JFbGVtOiBhbnk7XG4gIHByb3RlY3RlZCBhbmNob3JQb2ludDogUG9pbnQ7XG4gIHByb3RlY3RlZCBwb3BvdmVyUG9pbnQ6IFBvaW50O1xuICBwcm90ZWN0ZWQgcG9wb3Zlck9wdGlvbnM6IFBvcG92ZXJPcHRpb25zID0ge307XG5cbiAgcHJvdGVjdGVkIGlnbm9yZWRFbGVtZW50OiBhbnk7XG5cbiAgcHJvdGVjdGVkIGFuY2hvcigpIHtcbiAgICB0aGlzLnVwZGF0ZUFuY2hvciA9IHRydWU7XG4gICAgLy8gVWdoXG4gICAgdGhpcy5pZ25vcmUgPSB0aGlzLmlmT3BlblNlcnZpY2Uub3JpZ2luYWxFdmVudDtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWxlYXNlKCkge1xuICAgIHRoaXMuZGV0YWNoT3V0c2lkZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB0aGlzLnBvcG92ZXJJbnN0YW5jZS5yZWxlYXNlKCk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlQW5jaG9yKSB7XG4gICAgICB0aGlzLnVwZGF0ZUFuY2hvciA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3BvdmVySW5zdGFuY2VcbiAgICAgICAgLmFuY2hvcih0aGlzLmFuY2hvckVsZW0sIHRoaXMuYW5jaG9yUG9pbnQsIHRoaXMucG9wb3ZlclBvaW50LCB0aGlzLnBvcG92ZXJPcHRpb25zKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAvLyBpZiBhIHNjcm9sbCBldmVudCBpcyBkZXRlY3RlZCwgY2xvc2UgdGhlIHBvcG92ZXJcbiAgICAgICAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIHRoaXMuYXR0YWNoT3V0c2lkZUNsaWNrTGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbGVhc2UoKTtcbiAgICB0aGlzLmRldGFjaEVTQ0xpc3RlbmVyKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qXG4gICAgICogRmFsbGJhY2sgdG8gaGlkZSB3aGVuICpjbHJJZk9wZW4gaXMgbm90IGJlaW5nIHVzZWRcbiAgICAgKi9cblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlzLW9mZi1zY3JlZW4nKVxuICBnZXQgaXNPZmZTY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID8gZmFsc2UgOiB0cnVlO1xuICB9XG5cbiAgLypcbiAgICAgKiBVbnRpbCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy84Nzg1IGlzIHN1cHBvcnRlZCwgd2UgZG9uJ3QgaGF2ZSBhbnkgd2F5IHRvIGluc3RhbnRpYXRlXG4gICAgICogYSBzZXBhcmF0ZSBkaXJlY3RpdmUgb24gdGhlIGhvc3QuIFNvIGxldCdzIGRvIGRpcnR5IGJ1dCBwZXJmb3JtYW50IGZvciBub3cuXG4gICAgICovXG4gIHB1YmxpYyBjbG9zZU9uT3V0c2lkZUNsaWNrID0gZmFsc2U7XG4gIHByaXZhdGUgaG9zdENsaWNrTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgZG9jdW1lbnRDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIGRvY3VtZW50RVNDTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG4gIHByaXZhdGUgaWdub3JlZEVsZW1lbnRDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIGlnbm9yZTogYW55O1xuXG4gIHByaXZhdGUgYXR0YWNoRVNDTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgdGhpcy5kb2N1bWVudEVTQ0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2tleWRvd24nLCBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5Q29kZSA9PT0gRVNDKSB7XG4gICAgICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRldGFjaEVTQ0xpc3RlbmVyKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRvY3VtZW50RVNDTGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuZG9jdW1lbnRFU0NMaXN0ZW5lcigpO1xuICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRFU0NMaXN0ZW5lcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGF0dGFjaE91dHNpZGVDbGlja0xpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2spIHtcbiAgICAgIHRoaXMuaG9zdENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbih0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbGljaycsIGV2ZW50ID0+ICh0aGlzLmlnbm9yZSA9IGV2ZW50KSk7XG4gICAgICBpZiAodGhpcy5pZ25vcmVkRWxlbWVudCkge1xuICAgICAgICB0aGlzLmlnbm9yZWRFbGVtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKFxuICAgICAgICAgIHRoaXMuaWdub3JlZEVsZW1lbnQsXG4gICAgICAgICAgJ2NsaWNrJyxcbiAgICAgICAgICBldmVudCA9PiAodGhpcy5pZ25vcmUgPSBldmVudClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZXZlbnQgPT09IHRoaXMuaWdub3JlKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuaWdub3JlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGV0YWNoT3V0c2lkZUNsaWNrTGlzdGVuZXIoKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VPbk91dHNpZGVDbGljaykge1xuICAgICAgaWYgKHRoaXMuaG9zdENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5ob3N0Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICBkZWxldGUgdGhpcy5ob3N0Q2xpY2tMaXN0ZW5lcjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlnbm9yZWRFbGVtZW50Q2xpY2tMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmlnbm9yZWRFbGVtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICBkZWxldGUgdGhpcy5pZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmNvbnN0IGVudW0gRGF0ZXBpY2tlclZpZXdFbnVtIHtcbiAgTU9OVEhWSUVXID0gJ01PTlRIVklFVycsXG4gIFlFQVJWSUVXID0gJ1lFQVJWSUVXJyxcbiAgREFZVklFVyA9ICdEQVlWSUVXJyxcbn1cblxuLyoqXG4gKiBUaGlzIHNlcnZpY2UgbWFuYWdlcyB3aGljaCB2aWV3IGlzIHZpc2libGUgaW4gdGhlIGRhdGVwaWNrZXIgcG9wb3Zlci5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFZpZXdNYW5hZ2VyU2VydmljZSB7XG4gIHByaXZhdGUgX2N1cnJlbnRWaWV3OiBEYXRlcGlja2VyVmlld0VudW0gPSBEYXRlcGlja2VyVmlld0VudW0uREFZVklFVztcblxuICBnZXQgaXNEYXlWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmlldyA9PT0gRGF0ZXBpY2tlclZpZXdFbnVtLkRBWVZJRVc7XG4gIH1cblxuICBnZXQgaXNZZWFyVmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFZpZXcgPT09IERhdGVwaWNrZXJWaWV3RW51bS5ZRUFSVklFVztcbiAgfVxuXG4gIGdldCBpc01vbnRoVmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFZpZXcgPT09IERhdGVwaWNrZXJWaWV3RW51bS5NT05USFZJRVc7XG4gIH1cblxuICBjaGFuZ2VUb01vbnRoVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IERhdGVwaWNrZXJWaWV3RW51bS5NT05USFZJRVc7XG4gIH1cblxuICBjaGFuZ2VUb1llYXJWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gRGF0ZXBpY2tlclZpZXdFbnVtLllFQVJWSUVXO1xuICB9XG5cbiAgY2hhbmdlVG9EYXlWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJlbnRWaWV3ID0gRGF0ZXBpY2tlclZpZXdFbnVtLkRBWVZJRVc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3RvciwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuXG5pbXBvcnQgeyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IFZpZXdNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZpZXctbWFuYWdlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRhdGVwaWNrZXItdmlldy1tYW5hZ2VyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGVwaWNrZXItdmlldy1tYW5hZ2VyLmh0bWwnLFxuICBwcm92aWRlcnM6IFtWaWV3TWFuYWdlclNlcnZpY2UsIERhdGVwaWNrZXJGb2N1c1NlcnZpY2VdLFxuICBob3N0OiB7ICdbY2xhc3MuZGF0ZXBpY2tlcl0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0ZXBpY2tlclZpZXdNYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RQb3BvdmVyIHtcbiAgY29uc3RydWN0b3IoQFNraXBTZWxmKCkgcGFyZW50OiBFbGVtZW50UmVmLCBfaW5qZWN0b3I6IEluamVjdG9yLCBwcml2YXRlIF92aWV3TWFuYWdlclNlcnZpY2U6IFZpZXdNYW5hZ2VyU2VydmljZSkge1xuICAgIHN1cGVyKF9pbmplY3RvciwgcGFyZW50KTtcbiAgICB0aGlzLmNvbmZpZ3VyZVBvcG92ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmUgUG9wb3ZlciBEaXJlY3Rpb24gYW5kIENsb3NlIGluZGljYXRvcnNcbiAgICovXG4gIHByaXZhdGUgY29uZmlndXJlUG9wb3ZlcigpOiB2b2lkIHtcbiAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICB0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGN1cnJlbnQgdmlldyBpcyB0aGUgbW9udGhwaWNrZXIuXG4gICAqL1xuICBnZXQgaXNNb250aFZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5pc01vbnRoVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjdXJyZW50IHZpZXcgaXMgdGhlIHllYXJwaWNrZXIuXG4gICAqL1xuICBnZXQgaXNZZWFyVmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld01hbmFnZXJTZXJ2aWNlLmlzWWVhclZpZXc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudCB2aWV3IGlzIHRoZSBkYXlwaWNrZXIuXG4gICAqL1xuICBnZXQgaXNEYXlWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuaXNEYXlWaWV3O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5cbmltcG9ydCB7IERheVZpZXdNb2RlbCB9IGZyb20gJy4vbW9kZWwvZGF5LXZpZXcubW9kZWwnO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL21vZGVsL2RheS5tb2RlbCc7XG5pbXBvcnQgeyBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLW5hdmlnYXRpb24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kYXknLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzcz1cImRheS1idG5cIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBbY2xhc3MuaXMtdG9kYXldPVwiZGF5Vmlldy5pc1RvZGF5c0RhdGVcIlxuICAgICAgICAgICAgW2NsYXNzLmlzLWRpc2FibGVkXT1cImRheVZpZXcuaXNEaXNhYmxlZFwiXG4gICAgICAgICAgICBbY2xhc3MuaXMtc2VsZWN0ZWRdPVwiZGF5Vmlldy5pc1NlbGVjdGVkXCJcbiAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cImRheVZpZXcudGFiSW5kZXhcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInNlbGVjdERheSgpXCJcbiAgICAgICAgICAgIChmb2N1cyk9XCJvbkRheVZpZXdGb2N1cygpXCI+XG4gICAgICAgICAgICB7e2RheVZpZXcuZGF5TW9kZWwuZGF0ZX19XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kYXldJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRheSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2lmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBkYXRlRm9ybUNvbnRyb2xTZXJ2aWNlOiBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogRGF5Vmlld01vZGVsIGlucHV0IHdoaWNoIGlzIHVzZWQgdG8gYnVpbGQgdGhlIERheSBWaWV3LlxuICAgKi9cbiAgQElucHV0KCdjbHJEYXlWaWV3JykgZGF5VmlldzogRGF5Vmlld01vZGVsO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBmb2N1c2VkRGF5IGluIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2Ugd2hlbiB0aGUgQ2xyRGF5IGlzIGZvY3VzZWQuXG4gICAqL1xuICBvbkRheVZpZXdGb2N1cygpIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZm9jdXNlZERheSA9IHRoaXMuZGF5Vmlldy5kYXlNb2RlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzZWxlY3RlZERheSB3aGVuIHRoZSBDbHJEYXkgaXMgc2VsZWN0ZWQgYW5kIGNsb3NlcyB0aGUgZGF0ZXBpY2tlciBwb3BvdmVyLlxuICAgKi9cbiAgc2VsZWN0RGF5KCk6IHZvaWQge1xuICAgIGNvbnN0IGRheTogRGF5TW9kZWwgPSB0aGlzLmRheVZpZXcuZGF5TW9kZWw7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLm5vdGlmeVNlbGVjdGVkRGF5Q2hhbmdlZChkYXkpO1xuICAgIHRoaXMuZGF0ZUZvcm1Db250cm9sU2VydmljZS5tYXJrQXNEaXJ0eSgpO1xuICAgIHRoaXMuX2lmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9jYWxlSGVscGVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xvY2FsZS1oZWxwZXIuc2VydmljZSc7XG5pbXBvcnQgeyBWaWV3TWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92aWV3LW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHsgc2VsZWN0b3I6ICdjbHItZGF5cGlja2VyJywgdGVtcGxhdGVVcmw6ICcuL2RheXBpY2tlci5odG1sJywgaG9zdDogeyAnW2NsYXNzLmRheXBpY2tlcl0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsckRheXBpY2tlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3ZpZXdNYW5hZ2VyU2VydmljZTogVmlld01hbmFnZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2xvY2FsZUhlbHBlclNlcnZpY2U6IExvY2FsZUhlbHBlclNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgVmlld01hbmFnZXJTZXJ2aWNlIHRvIGNoYW5nZSB0byB0aGUgbW9udGhwaWNrZXIgdmlldy5cbiAgICovXG4gIGNoYW5nZVRvTW9udGhWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb01vbnRoVmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBWaWV3TWFuYWdlclNlcnZpY2UgdG8gY2hhbmdlIHRvIHRoZSB5ZWFycGlja2VyIHZpZXcuXG4gICAqL1xuICBjaGFuZ2VUb1llYXJWaWV3KCk6IHZvaWQge1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb1llYXJWaWV3KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbW9udGggdmFsdWUgb2YgdGhlIGNhbGVuZGFyIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkIGZvcm1hdC5cbiAgICovXG4gIGdldCBjYWxlbmRhck1vbnRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZUhlbHBlclNlcnZpY2UubG9jYWxlTW9udGhzQWJicmV2aWF0ZWRbdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyLm1vbnRoXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB5ZWFyIHZhbHVlIG9mIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIGdldCBjYWxlbmRhclllYXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyLnllYXI7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZSB0byBtb3ZlIHRvIHRoZSBuZXh0IG1vbnRoLlxuICAgKi9cbiAgbmV4dE1vbnRoKCk6IHZvaWQge1xuICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5tb3ZlVG9OZXh0TW9udGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHRvIG1vdmUgdG8gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgcHJldmlvdXNNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UubW92ZVRvUHJldmlvdXNNb250aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gbW92ZSB0byB0aGUgY3VycmVudCBtb250aC5cbiAgICovXG4gIGN1cnJlbnRNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UubW92ZVRvQ3VycmVudE1vbnRoKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERPV05fQVJST1csIExFRlRfQVJST1csIFJJR0hUX0FSUk9XLCBVUF9BUlJPVyB9IGZyb20gJy4uLy4uL3V0aWxzL2tleS1jb2Rlcy9rZXktY29kZXMnO1xuXG5pbXBvcnQgeyBEYXRlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItbW9udGhwaWNrZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiY2FsZW5kYXItYnRuIG1vbnRoXCJcbiAgICAgICAgICAgICpuZ0Zvcj1cImxldCBtb250aCBvZiBtb250aE5hbWVzOyBsZXQgbW9udGhJbmRleCA9IGluZGV4XCJcbiAgICAgICAgICAgIChjbGljayk9XCJjaGFuZ2VNb250aChtb250aEluZGV4KVwiXG4gICAgICAgICAgICBbY2xhc3MuaXMtc2VsZWN0ZWRdPVwibW9udGhJbmRleCA9PT0gY2FsZW5kYXJNb250aEluZGV4XCJcbiAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cImdldFRhYkluZGV4KG1vbnRoSW5kZXgpXCI+XG4gICAgICAgICAgICB7e21vbnRofX1cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MubW9udGhwaWNrZXJdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJNb250aHBpY2tlciBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF92aWV3TWFuYWdlclNlcnZpY2U6IFZpZXdNYW5hZ2VyU2VydmljZSxcbiAgICBwcml2YXRlIF9sb2NhbGVIZWxwZXJTZXJ2aWNlOiBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2U6IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZWxSZWY6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPSB0aGlzLmNhbGVuZGFyTW9udGhJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBmb2N1c2VkIG1vbnRoLlxuICAgKi9cbiAgcHJpdmF0ZSBfZm9jdXNlZE1vbnRoSW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9udGhzIGFycmF5IHdoaWNoIGlzIHVzZWQgdG8gcmVuZGVyZWQgdGhlIG1vbnRocGlja2VyIHZpZXcuXG4gICAqIE1vbnRocyBhcmUgaW4gdGhlIFRyYW5zbGF0aW9uV2lkdGguV2lkZSBmb3JtYXQuXG4gICAqL1xuICBnZXQgbW9udGhOYW1lcygpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZU1vbnRoc1dpZGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9udGggdmFsdWUgb2YgdGhlIENhbGVuZGFyLlxuICAgKi9cbiAgZ2V0IGNhbGVuZGFyTW9udGhJbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZGlzcGxheWVkQ2FsZW5kYXIubW9udGg7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZSB0byB1cGRhdGUgdGhlIG1vbnRoIHZhbHVlIG9mIHRoZSBjYWxlbmRhci5cbiAgICogQWxzbyBjaGFuZ2VzIHRoZSB2aWV3IHRvIHRoZSBkYXlwaWNrZXIuXG4gICAqL1xuICBjaGFuZ2VNb250aChtb250aEluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuY2hhbmdlTW9udGgobW9udGhJbmRleCk7XG4gICAgdGhpcy5fdmlld01hbmFnZXJTZXJ2aWNlLmNoYW5nZVRvRGF5VmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoZSBtb250aCBwYXNzZWQgdG8gdGhlIGZvY3VzZWQgbW9udGggYW5kIHJldHVybnMgdGhlIHRhYiBpbmRleC5cbiAgICovXG4gIGdldFRhYkluZGV4KG1vbnRoSW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIG1vbnRoSW5kZXggPT09IHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID8gMCA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIEtleWJvYXJkIGFycm93IG5hdmlnYXRpb24gZm9yIHRoZSBtb250aHBpY2tlci5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBOT1RFOiBEaWRuJ3QgbW92ZSB0aGlzIHRvIHRoZSBkYXRlIG5hdmlnYXRpb24gc2VydmljZSBiZWNhdXNlXG4gICAgLy8gdGhlIGxvZ2ljIGlzIGZhaXJseSBzaW1wbGUgYW5kIGl0IGRpZG4ndCBtYWtlIHNlbnNlIGZvciBtZVxuICAgIC8vIHRvIGNyZWF0ZSBleHRyYSBvYnNlcnZhYmxlcyBqdXN0IHRvIG1vdmUgdGhpcyBsb2dpYyB0byB0aGUgc2VydmljZS5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGtleUNvZGU6IG51bWJlciA9IGV2ZW50LmtleUNvZGU7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gVVBfQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4LS07XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gRE9XTl9BUlJPVyAmJiB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA8IDExKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4Kys7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gUklHSFRfQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPCA2KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID0gdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggKyA2O1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IExFRlRfQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPiA1KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID0gdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggLSA2O1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgb24gdGhlIGN1cnJlbnQgY2FsZW5kYXIgbW9udGggd2hlbiB0aGUgVmlldyBpcyBpbml0aWFsaXplZC5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuY29uc3QgWUVBUlNfVE9fRElTUExBWTogbnVtYmVyID0gMTA7XG5cbmV4cG9ydCBjbGFzcyBZZWFyUmFuZ2VNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgeWVhcjogbnVtYmVyKSB7XG4gICAgdGhpcy5nZW5lcmF0ZVllYXJSYW5nZSgpO1xuICB9XG5cbiAgeWVhclJhbmdlOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgcmFuZ2UuXG4gICAqL1xuICBnZXQgbWlkZGxlWWVhcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnllYXJSYW5nZVtNYXRoLmZsb29yKHRoaXMueWVhclJhbmdlLmxlbmd0aCAvIDIpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHllYXIgcmFuZ2UgYmFzZWQgb24gdGhlIHllYXIgcGFyYW1ldGVyLlxuICAgKiBlZzogSWYgMjAxOCBpcyBwYXNzZWQgdGhlIG91dHB1dCB3aWxsIGJlIFsyMDEwLCAyMDExLCAuLi4sIDIwMTldXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlWWVhclJhbmdlKCkge1xuICAgIGNvbnN0IHJlbWFpbmRlcjogbnVtYmVyID0gdGhpcy55ZWFyICUgWUVBUlNfVE9fRElTUExBWTtcbiAgICBjb25zdCBmbG9vcjogbnVtYmVyID0gdGhpcy55ZWFyIC0gcmVtYWluZGVyO1xuICAgIGNvbnN0IGNlaWw6IG51bWJlciA9IGZsb29yICsgWUVBUlNfVE9fRElTUExBWTtcbiAgICB0aGlzLnllYXJSYW5nZSA9IHRoaXMuZ2VuZXJhdGVSYW5nZShmbG9vciwgY2VpbCk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gd2hpY2ggZ2VuZXJhdGUgYSByYW5nZSBvZiBudW1iZXJzIGZyb20gZmxvb3IgdG8gY2VpbC5cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVSYW5nZShmbG9vcjogbnVtYmVyLCBjZWlsOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IGNlaWwgLSBmbG9vciB9LCAodiwgaykgPT4gayArIGZsb29yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGZvciB0aGUgbmV4dCBkZWNhZGUuXG4gICAqL1xuICBuZXh0RGVjYWRlKCk6IFllYXJSYW5nZU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IFllYXJSYW5nZU1vZGVsKHRoaXMueWVhciArIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGZvciB0aGUgcHJldmlvdXMgZGVjYWRlLlxuICAgKi9cbiAgcHJldmlvdXNEZWNhZGUoKTogWWVhclJhbmdlTW9kZWwge1xuICAgIHJldHVybiBuZXcgWWVhclJhbmdlTW9kZWwodGhpcy55ZWFyIC0gMTApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgZm9yIHRoZSBjdXJyZW50IGRlY2FkZS5cbiAgICovXG4gIGN1cnJlbnREZWNhZGUoKTogWWVhclJhbmdlTW9kZWwge1xuICAgIHJldHVybiBuZXcgWWVhclJhbmdlTW9kZWwobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGluIHRoZSBZZWFyUmFuZ2VNb2RlbC5cbiAgICovXG4gIGluUmFuZ2UodmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnllYXJSYW5nZS5pbmRleE9mKHZhbHVlKSA+IC0xO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBET1dOX0FSUk9XLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICcuLi8uLi91dGlscy9rZXktY29kZXMva2V5LWNvZGVzJztcblxuaW1wb3J0IHsgWWVhclJhbmdlTW9kZWwgfSBmcm9tICcuL21vZGVsL3llYXItcmFuZ2UubW9kZWwnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckZvY3VzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBWaWV3TWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92aWV3LW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHIteWVhcnBpY2tlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ5ZWFyLXN3aXRjaGVyc1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNhbGVuZGFyLWJ0biBzd2l0Y2hlclwiIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwicHJldmlvdXNEZWNhZGUoKVwiPlxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImFuZ2xlXCIgZGlyPVwibGVmdFwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MucHJldmlvdXNcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY2FsZW5kYXItYnRuIHN3aXRjaGVyXCIgdHlwZT1cImJ1dHRvblwiIChjbGljayk9XCJjdXJyZW50RGVjYWRlKClcIj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJldmVudFwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MuY3VycmVudFwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJjYWxlbmRhci1idG4gc3dpdGNoZXJcIiB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cIm5leHREZWNhZGUoKVwiPlxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImFuZ2xlXCIgZGlyPVwicmlnaHRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLm5leHRcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwieWVhcnNcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAqbmdGb3I9XCJsZXQgeWVhciBvZiB5ZWFyUmFuZ2VNb2RlbC55ZWFyUmFuZ2VcIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiY2FsZW5kYXItYnRuIHllYXJcIlxuICAgICAgICAgICAgICAgIFthdHRyLnRhYmluZGV4XT1cImdldFRhYkluZGV4KHllYXIpXCJcbiAgICAgICAgICAgICAgICBbY2xhc3MuaXMtc2VsZWN0ZWRdPVwieWVhciA9PT0gY2FsZW5kYXJZZWFyXCJcbiAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2hhbmdlWWVhcih5ZWFyKVwiPlxuICAgICAgICAgICAgICAgIHt7eWVhcn19XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MueWVhcnBpY2tlcl0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclllYXJwaWNrZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfZGF0ZU5hdmlnYXRpb25TZXJ2aWNlOiBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfdmlld01hbmFnZXJTZXJ2aWNlOiBWaWV3TWFuYWdlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZGF0ZXBpY2tlckZvY3VzU2VydmljZTogRGF0ZXBpY2tlckZvY3VzU2VydmljZSxcbiAgICBwcml2YXRlIF9lbFJlZjogRWxlbWVudFJlZixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICB0aGlzLnllYXJSYW5nZU1vZGVsID0gbmV3IFllYXJSYW5nZU1vZGVsKHRoaXMuY2FsZW5kYXJZZWFyKTtcbiAgICB0aGlzLl9mb2N1c2VkWWVhciA9IHRoaXMuY2FsZW5kYXJZZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIFllYXJSYW5nZU1vZGVsIHdoaWNoIGlzIHVzZWQgdG8gYnVpbGQgdGhlIFllYXJQaWNrZXIgdmlldy5cbiAgICovXG4gIHllYXJSYW5nZU1vZGVsOiBZZWFyUmFuZ2VNb2RlbDtcblxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZm9jdXNlZCB5ZWFyLlxuICAgKi9cbiAgcHJpdmF0ZSBfZm9jdXNlZFllYXI6IG51bWJlcjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgeWVhciB3aGljaCB0aGUgdXNlciBpcyBjdXJyZW50bHkgb24uXG4gICAqL1xuICBnZXQgY2FsZW5kYXJZZWFyKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhci55ZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgdGhlIGZvY3VzIHllYXIgYnkgdGhlIHZhbHVlIHBhc3NlZC4gVXBkYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgaWYgdGhlXG4gICAqIG5ldyB2YWx1ZSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgZGVjYWRlLlxuICAgKi9cbiAgcHJpdmF0ZSBpbmNyZW1lbnRGb2N1c1llYXJCeSh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5fZm9jdXNlZFllYXIgPSB0aGlzLl9mb2N1c2VkWWVhciArIHZhbHVlO1xuICAgIGlmICghdGhpcy55ZWFyUmFuZ2VNb2RlbC5pblJhbmdlKHRoaXMuX2ZvY3VzZWRZZWFyKSkge1xuICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICB0aGlzLnllYXJSYW5nZU1vZGVsID0gdGhpcy55ZWFyUmFuZ2VNb2RlbC5uZXh0RGVjYWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnllYXJSYW5nZU1vZGVsID0gdGhpcy55ZWFyUmFuZ2VNb2RlbC5wcmV2aW91c0RlY2FkZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZSB0byB1cGRhdGUgdGhlIHllYXIgdmFsdWUgb2YgdGhlIGNhbGVuZGFyLlxuICAgKiBBbHNvIGNoYW5nZXMgdGhlIHZpZXcgdG8gdGhlIGRheXBpY2tlci5cbiAgICovXG4gIGNoYW5nZVllYXIoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmNoYW5nZVllYXIoeWVhcik7XG4gICAgdGhpcy5fdmlld01hbmFnZXJTZXJ2aWNlLmNoYW5nZVRvRGF5VmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIHRvIHRoZSBwcmV2aW91cyBkZWNhZGUuXG4gICAqL1xuICBwcmV2aW91c0RlY2FkZSgpOiB2b2lkIHtcbiAgICB0aGlzLnllYXJSYW5nZU1vZGVsID0gdGhpcy55ZWFyUmFuZ2VNb2RlbC5wcmV2aW91c0RlY2FkZSgpO1xuICAgIC8vIFllYXIgaW4gdGhlIHllYXJwaWNrZXIgaXMgbm90IGZvY3VzZWQgYmVjYXVzZSB3aGlsZSBuYXZpZ2F0aW5nIHRvIGEgZGlmZmVyZW50IGRlY2FkZSxcbiAgICAvLyB5b3Ugd2FudCB0aGUgZm9jdXMgdG8gcmVtYWluIG9uIHRoZSBkZWNhZGUgc3dpdGNoZXIgYXJyb3dzLlxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIHRvIHRoZSBjdXJyZW50IGRlY2FkZS5cbiAgICovXG4gIGN1cnJlbnREZWNhZGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnllYXJSYW5nZU1vZGVsLmluUmFuZ2UodGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnRvZGF5LnllYXIpKSB7XG4gICAgICB0aGlzLnllYXJSYW5nZU1vZGVsID0gdGhpcy55ZWFyUmFuZ2VNb2RlbC5jdXJyZW50RGVjYWRlKCk7XG4gICAgfVxuICAgIHRoaXMuX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2UuZm9jdXNDZWxsKHRoaXMuX2VsUmVmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCB0byB0aGUgbmV4dCBkZWNhZGUuXG4gICAqL1xuICBuZXh0RGVjYWRlKCk6IHZvaWQge1xuICAgIHRoaXMueWVhclJhbmdlTW9kZWwgPSB0aGlzLnllYXJSYW5nZU1vZGVsLm5leHREZWNhZGUoKTtcbiAgICAvLyBZZWFyIGluIHRoZSB5ZWFycGlja2VyIGlzIG5vdCBmb2N1c2VkIGJlY2F1c2Ugd2hpbGUgbmF2aWdhdGluZyB0byBhIGRpZmZlcmVudCBkZWNhZGUsXG4gICAgLy8geW91IHdhbnQgdGhlIGZvY3VzIHRvIHJlbWFpbiBvbiB0aGUgZGVjYWRlIHN3aXRjaGVyIGFycm93cy5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGUgeWVhciBwYXNzZWQgdG8gdGhlIGZvY3VzZWQgeWVhciBhbmQgcmV0dXJucyB0aGUgdGFiIGluZGV4LlxuICAgKi9cbiAgZ2V0VGFiSW5kZXgoeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMueWVhclJhbmdlTW9kZWwuaW5SYW5nZSh0aGlzLl9mb2N1c2VkWWVhcikpIHtcbiAgICAgIGlmICh0aGlzLnllYXJSYW5nZU1vZGVsLmluUmFuZ2UodGhpcy5jYWxlbmRhclllYXIpKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWRZZWFyID0gdGhpcy5jYWxlbmRhclllYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9mb2N1c2VkWWVhciA9IHRoaXMueWVhclJhbmdlTW9kZWwubWlkZGxlWWVhcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWRZZWFyID09PSB5ZWFyID8gMCA6IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIEtleWJvYXJkIGFycm93IG5hdmlnYXRpb24gZm9yIHRoZSB5ZWFycGlja2VyLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgIC8vIE5PVEU6IERpZG4ndCBtb3ZlIHRoaXMgdG8gdGhlIGRhdGUgbmF2aWdhdGlvbiBzZXJ2aWNlIGJlY2F1c2VcbiAgICAvLyB0aGUgbG9naWMgaXMgZmFpcmx5IHNpbXBsZSBhbmQgaXQgZGlkbid0IG1ha2Ugc2Vuc2UgZm9yIG1lXG4gICAgLy8gdG8gY3JlYXRlIGV4dHJhIG9ic2VydmFibGVzIGp1c3QgdG8gbW92ZSB0aGlzIGxvZ2ljIHRvIHRoZSBzZXJ2aWNlLlxuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3Qga2V5Q29kZTogbnVtYmVyID0gZXZlbnQua2V5Q29kZTtcbiAgICAgIGlmIChrZXlDb2RlID09PSBVUF9BUlJPVykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmluY3JlbWVudEZvY3VzWWVhckJ5KC0xKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gRE9XTl9BUlJPVykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmluY3JlbWVudEZvY3VzWWVhckJ5KDEpO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBSSUdIVF9BUlJPVykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmluY3JlbWVudEZvY3VzWWVhckJ5KDUpO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBMRUZUX0FSUk9XKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50Rm9jdXNZZWFyQnkoLTUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIG9uIHRoZSBjdXJyZW50IGNhbGVuZGFyIHllYXIgd2hlbiB0aGUgVmlldyBpcyBpbml0aWFsaXplZC5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENsckZvY3VzVHJhcE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySG9zdFdyYXBwaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckNhbGVuZGFyIH0gZnJvbSAnLi9jYWxlbmRhcic7XG5pbXBvcnQgeyBDbHJEYXRlQ29udGFpbmVyIH0gZnJvbSAnLi9kYXRlLWNvbnRhaW5lcic7XG5pbXBvcnQgeyBDbHJEYXRlSW5wdXQgfSBmcm9tICcuL2RhdGUtaW5wdXQnO1xuaW1wb3J0IHsgQ2xyRGF0ZXBpY2tlclZpZXdNYW5hZ2VyIH0gZnJvbSAnLi9kYXRlcGlja2VyLXZpZXctbWFuYWdlcic7XG5pbXBvcnQgeyBDbHJEYXkgfSBmcm9tICcuL2RheSc7XG5pbXBvcnQgeyBDbHJEYXlwaWNrZXIgfSBmcm9tICcuL2RheXBpY2tlcic7XG5pbXBvcnQgeyBDbHJNb250aHBpY2tlciB9IGZyb20gJy4vbW9udGhwaWNrZXInO1xuaW1wb3J0IHsgQ2xyWWVhcnBpY2tlciB9IGZyb20gJy4veWVhcnBpY2tlcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfREFURVBJQ0tFUl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyRGF5LFxuICBDbHJEYXRlQ29udGFpbmVyLFxuICBDbHJEYXRlSW5wdXQsXG4gIENsckRhdGVwaWNrZXJWaWV3TWFuYWdlcixcbiAgQ2xyTW9udGhwaWNrZXIsXG4gIENsclllYXJwaWNrZXIsXG4gIENsckRheXBpY2tlcixcbiAgQ2xyQ2FsZW5kYXIsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJIb3N0V3JhcHBpbmdNb2R1bGUsIENsckNvbmRpdGlvbmFsTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJGb2N1c1RyYXBNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfREFURVBJQ0tFUl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9EQVRFUElDS0VSX0RJUkVDVElWRVNdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJEYXRlQ29udGFpbmVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0ZXBpY2tlck1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItaW5wdXQtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtd3JhcHBlclwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJJbnB1dF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtJZkVycm9yU2VydmljZSwgTmdDb250cm9sU2VydmljZSwgQ29udHJvbElkU2VydmljZSwgQ29udHJvbENsYXNzU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENscklucHV0Q29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2Uuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IGNvbnRyb2wuaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYsIE9uSW5pdCwgUmVuZGVyZXIyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IENscklucHV0Q29udGFpbmVyIH0gZnJvbSAnLi9pbnB1dC1jb250YWluZXInO1xuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xySW5wdXRdJywgaG9zdDogeyAnW2NsYXNzLmNsci1pbnB1dF0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENscklucHV0IGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENscklucHV0Q29udGFpbmVyPiBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHN1cGVyKENscklucHV0Q29udGFpbmVyLCB2Y3IsIDEpO1xuICAgIGlmICghY29udHJvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnY2xySW5wdXQgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gYW4gQW5ndWxhciBmb3JtIGNvbnRyb2wsIGFkZCBuZ01vZGVsIG9yIGZvcm1Db250cm9sIHRvIHRoZSBpbnB1dCdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb250cm9sQ2xhc3NTZXJ2aWNlKSB7XG4gICAgICBjb250cm9sQ2xhc3NTZXJ2aWNlLmluaXRDb250cm9sQ2xhc3MocmVuZGVyZXIsIGVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgaWYgKHRoaXMubmdDb250cm9sU2VydmljZSkge1xuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLnNldENvbnRyb2wodGhpcy5jb250cm9sKTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgb25CbHVyKCkge1xuICAgIGlmICh0aGlzLmlmRXJyb3JTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnRyaWdnZXJTdGF0dXNDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgQ2xySW5wdXRDb250YWluZXIgfSBmcm9tICcuL2lucHV0LWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NscklucHV0LCBDbHJJbnB1dENvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xySW5wdXQsIENscklucHV0Q29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xySW5wdXRDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJJbnB1dE1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBGb2N1c1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2ZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbi8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lICovXG5leHBvcnQgY29uc3QgVG9nZ2xlU2VydmljZSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KHVuZGVmaW5lZCk7XG4vKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRvZ2dsZVNlcnZpY2VQcm92aWRlcigpIHtcbiAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcGFzc3dvcmQtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtd3JhcHBlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWlucHV0LWdyb3VwXCIgW2NsYXNzLmNsci1mb2N1c109XCJmb2N1c1wiPlxuICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJQYXNzd29yZF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiIXNob3cgJiYgY2xyVG9nZ2xlXCJcbiAgICAgICAgICAgIHNoYXBlPVwiZXllXCIgXG4gICAgICAgICAgICBjbGFzcz1cImNsci1pbnB1dC1ncm91cC1pY29uLWFjdGlvblwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLnNob3dcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSgpXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJzaG93ICYmIGNsclRvZ2dsZVwiIFxuICAgICAgICAgICAgc2hhcGU9XCJleWUtaGlkZVwiXG4gICAgICAgICAgICBjbGFzcz1cImNsci1pbnB1dC1ncm91cC1pY29uLWFjdGlvblwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmhpZGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSgpXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgPC9kaXY+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICBJZkVycm9yU2VydmljZSxcbiAgICBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIENvbnRyb2xJZFNlcnZpY2UsXG4gICAgQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBGb2N1c1NlcnZpY2UsXG4gICAgeyBwcm92aWRlOiBUb2dnbGVTZXJ2aWNlLCB1c2VGYWN0b3J5OiBUb2dnbGVTZXJ2aWNlUHJvdmlkZXIgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUGFzc3dvcmRDb250YWluZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcbiAgc2hvdyA9IGZhbHNlO1xuICBmb2N1cyA9IGZhbHNlO1xuICBwcml2YXRlIF90b2dnbGUgPSB0cnVlO1xuXG4gIEBJbnB1dCgnY2xyVG9nZ2xlJylcbiAgc2V0IGNsclRvZ2dsZShzdGF0ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3RvZ2dsZSA9IHN0YXRlO1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXQgY2xyVG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl90b2dnbGU7XG4gIH1cbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgcHVibGljIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBASW5qZWN0KFRvZ2dsZVNlcnZpY2UpIHByaXZhdGUgdG9nZ2xlU2VydmljZTogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+LFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gY29udHJvbC5pbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHN0YXRlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnNob3cgPSAhdGhpcy5zaG93O1xuICAgIHRoaXMudG9nZ2xlU2VydmljZS5uZXh0KHRoaXMuc2hvdyk7XG4gIH1cblxuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIE9uSW5pdCxcbiAgSG9zdExpc3RlbmVyLFxuICBPcHRpb25hbCxcbiAgVmlld0NvbnRhaW5lclJlZixcbiAgUmVuZGVyZXIyLFxuICBJbmplY3QsXG4gIEVsZW1lbnRSZWYsXG4gIE9uRGVzdHJveSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IENsclBhc3N3b3JkQ29udGFpbmVyLCBUb2dnbGVTZXJ2aWNlIH0gZnJvbSAnLi9wYXNzd29yZC1jb250YWluZXInO1xuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5pbXBvcnQgeyBGb2N1c1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2ZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQYXNzd29yZF0nLCBob3N0OiB7ICdbY2xhc3MuY2xyLWlucHV0XSc6ICd0cnVlJyB9IH0pXG5leHBvcnQgY2xhc3MgQ2xyUGFzc3dvcmQgZXh0ZW5kcyBXcmFwcGVkRm9ybUNvbnRyb2w8Q2xyUGFzc3dvcmRDb250YWluZXI+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgY29udHJvbDogTmdDb250cm9sLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZm9jdXNTZXJ2aWNlOiBGb2N1c1NlcnZpY2UsXG4gICAgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmLFxuICAgIEBJbmplY3QoVG9nZ2xlU2VydmljZSkgcHJpdmF0ZSB0b2dnbGVTZXJ2aWNlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj5cbiAgKSB7XG4gICAgc3VwZXIoQ2xyUGFzc3dvcmRDb250YWluZXIsIHZjciwgMSk7XG4gICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2NsclBhc3N3b3JkIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIGFuIEFuZ3VsYXIgZm9ybSBjb250cm9sLCBhZGQgbmdNb2RlbCBvciBmb3JtQ29udHJvbCB0byB0aGUgaW5wdXQnXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZm9jdXNTZXJ2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsclBhc3N3b3JkIHJlcXVpcmVzIGJlaW5nIHdyYXBwZWQgaW4gPGNsci1wYXNzd29yZC1jb250YWluZXI+Jyk7XG4gICAgfVxuICAgIGlmIChjb250cm9sQ2xhc3NTZXJ2aWNlKSB7XG4gICAgICBjb250cm9sQ2xhc3NTZXJ2aWNlLmluaXRDb250cm9sQ2xhc3MocmVuZGVyZXIsIGVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMudG9nZ2xlU2VydmljZS5zdWJzY3JpYmUodG9nZ2xlID0+IHtcbiAgICAgIHJlbmRlcmVyLnNldFByb3BlcnR5KGVsLm5hdGl2ZUVsZW1lbnQsICd0eXBlJywgdG9nZ2xlID8gJ3RleHQnIDogJ3Bhc3N3b3JkJyk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIGlmICh0aGlzLm5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5zZXRDb250cm9sKHRoaXMuY29udHJvbCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgb25Gb2N1cygpIHtcbiAgICBpZiAodGhpcy5mb2N1c1NlcnZpY2UpIHtcbiAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLmZvY3VzZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICBvbkJsdXIoKSB7XG4gICAgaWYgKHRoaXMuaWZFcnJvclNlcnZpY2UpIHtcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2UudHJpZ2dlclN0YXR1c0NoYW5nZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mb2N1c1NlcnZpY2UpIHtcbiAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJQYXNzd29yZCB9IGZyb20gJy4vcGFzc3dvcmQnO1xuaW1wb3J0IHsgQ2xyUGFzc3dvcmRDb250YWluZXIgfSBmcm9tICcuL3Bhc3N3b3JkLWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclBhc3N3b3JkLCBDbHJQYXNzd29yZENvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyUGFzc3dvcmQsIENsclBhc3N3b3JkQ29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyUGFzc3dvcmRDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJQYXNzd29yZE1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmFkaW8td3JhcHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclJhZGlvXVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWxcIj48L2xhYmVsPlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItcmFkaW8td3JhcHBlcl0nOiAndHJ1ZScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0NvbnRyb2xJZFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJSYWRpb1dyYXBwZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciB7XG4gIC8vIFdlIG5lZWQgYm90aCBfZHluYW1pYyBmb3IgSG9zdFdyYXBwZXIgYW5kIENvbnRlbnRDaGlsZChDbHJMYWJlbCkgaW4gY2FzZXMgd2hlcmVcbiAgLy8gdGhlIHVzZXIgcHV0cyBhIHJhZGlvIGluc2lkZSBhIHdyYXBwZXIgd2l0aG91dCBhIGxhYmVsLCBob3N0IHdyYXBwaW5nIGRvZXNuJ3QgYXBwbHlcbiAgLy8gYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0byBpbnNlcnQgYSBsYWJlbFxuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkluaXQsIE9wdGlvbmFsLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcbmltcG9ydCB7IENsclJhZGlvV3JhcHBlciB9IGZyb20gJy4uL3JhZGlvL3JhZGlvLXdyYXBwZXInO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUmFkaW9dJyB9KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvIGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsclJhZGlvV3JhcHBlcj4gaW1wbGVtZW50cyBPbkluaXQge1xuICBjb25zdHJ1Y3RvcihcbiAgICB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgY29udHJvbDogTmdDb250cm9sLFxuICAgIEBPcHRpb25hbCgpIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgZWw6IEVsZW1lbnRSZWYsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHtcbiAgICBzdXBlcihDbHJSYWRpb1dyYXBwZXIsIHZjciwgMCk7XG4gICAgaWYgKGNvbnRyb2xDbGFzc1NlcnZpY2UpIHtcbiAgICAgIGNvbnRyb2xDbGFzc1NlcnZpY2UuaW5pdENvbnRyb2xDbGFzcyhyZW5kZXJlciwgZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICBpZiAodGhpcy5uZ0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2Uuc2V0Q29udHJvbCh0aGlzLmNvbnRyb2wpO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICBvbkJsdXIoKSB7XG4gICAgaWYgKHRoaXMuaWZFcnJvclNlcnZpY2UpIHtcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2UudHJpZ2dlclN0YXR1c0NoYW5nZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXJhZGlvLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgPGxhYmVsICpuZ0lmPVwiIWxhYmVsICYmIGFkZEdyaWQoKVwiPjwvbGFiZWw+XG4gICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtjbGFzcy5jbHItY29udHJvbC1pbmxpbmVdPVwiY2xySW5saW5lXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1yYWRpby13cmFwcGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGRpdiBjbGFzcz1cImNsci1zdWJ0ZXh0LXdyYXBwZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlLCBJZkVycm9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvQ29udGFpbmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgcHJpdmF0ZSBpbmxpbmUgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuXG4gIC8qXG4gICAqIEhlcmUgd2Ugd2FudCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmcgY2FzZXNcbiAgICogY2xySW5saW5lIC0gdHJ1ZSBieSBwcmVzZW5jZVxuICAgKiBjbHJJbmxpbmU9XCJ0cnVlfGZhbHNlXCIgLSB1bmxlc3MgaXQgaXMgZXhwbGljaXRseSBmYWxzZSwgc3RyaW5ncyBhcmUgY29uc2lkZXJlZCB0cnVlXG4gICAqIFtjbHJJbmxpbmVdPVwidHJ1ZXxmYWxzZVwiIC0gZXhwZWN0IGEgYm9vbGVhblxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGNscklubGluZSh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmlubGluZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlubGluZSA9ICEhdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjbHJJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5saW5lO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBjb250cm9sLmludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCksIHRoaXMuaW5saW5lID8gJ2Nsci1jb250cm9sLWlubGluZScgOiAnJyk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJIb3N0V3JhcHBpbmdNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBpbmcubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJSYWRpbyB9IGZyb20gJy4vcmFkaW8nO1xuaW1wb3J0IHsgQ2xyUmFkaW9Db250YWluZXIgfSBmcm9tICcuL3JhZGlvLWNvbnRhaW5lcic7XG5pbXBvcnQgeyBDbHJSYWRpb1dyYXBwZXIgfSBmcm9tICcuL3JhZGlvLXdyYXBwZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xySG9zdFdyYXBwaW5nTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xyUmFkaW8sIENsclJhZGlvQ29udGFpbmVyLCBDbHJSYWRpb1dyYXBwZXJdLFxuICBleHBvcnRzOiBbQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsclJhZGlvLCBDbHJSYWRpb0NvbnRhaW5lciwgQ2xyUmFkaW9XcmFwcGVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyUmFkaW9XcmFwcGVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUmFkaW9Nb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXNlbGVjdC1jb250YWluZXInLFxuICB0ZW1wbGF0ZTogYCAgICBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgW25nQ2xhc3NdPVwid3JhcHBlckNsYXNzKClcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyU2VsZWN0XVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcblxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbSWZFcnJvclNlcnZpY2UsIE5nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xJZFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTZWxlY3RDb250YWluZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgQENvbnRlbnRDaGlsZChTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yKSBtdWx0aXBsZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgcHJpdmF0ZSBtdWx0aSA9IGZhbHNlO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBjb250cm9sLmludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLm11bHRpID0gY29udHJvbC52YWx1ZUFjY2Vzc29yIGluc3RhbmNlb2YgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHdyYXBwZXJDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aSA/ICdjbHItbXVsdGlzZWxlY3Qtd3JhcHBlcicgOiAnY2xyLXNlbGVjdC13cmFwcGVyJztcbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpKTtcbiAgfVxuXG4gIGFkZEdyaWQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0U2VydmljZSAmJiAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgUmVuZGVyZXIyLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIE9uSW5pdCwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyU2VsZWN0Q29udGFpbmVyIH0gZnJvbSAnLi9zZWxlY3QtY29udGFpbmVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclNlbGVjdF0nLCBob3N0OiB7ICdbY2xhc3MuY2xyLXNlbGVjdF0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsclNlbGVjdCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJTZWxlY3RDb250YWluZXI+IGltcGxlbWVudHMgT25Jbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgICBAT3B0aW9uYWwoKSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIGVsOiBFbGVtZW50UmVmLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7XG4gICAgc3VwZXIoQ2xyU2VsZWN0Q29udGFpbmVyLCB2Y3IsIDEpO1xuICAgIGlmICghY29udHJvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnY2xyU2VsZWN0IGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIGFuIEFuZ3VsYXIgZm9ybSBjb250cm9sLCBhZGQgbmdNb2RlbCBvciBmb3JtQ29udHJvbCB0byB0aGUgc2VsZWN0J1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbnRyb2xDbGFzc1NlcnZpY2UpIHtcbiAgICAgIGNvbnRyb2xDbGFzc1NlcnZpY2UuaW5pdENvbnRyb2xDbGFzcyhyZW5kZXJlciwgZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICBpZiAodGhpcy5uZ0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2Uuc2V0Q29udHJvbCh0aGlzLmNvbnRyb2wpO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICBvbkJsdXIoKSB7XG4gICAgaWYgKHRoaXMuaWZFcnJvclNlcnZpY2UpIHtcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2UudHJpZ2dlclN0YXR1c0NoYW5nZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uRm9ybXNNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vY29tbW9uLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsclNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IENsclNlbGVjdENvbnRhaW5lciB9IGZyb20gJy4vc2VsZWN0LWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclNlbGVjdCwgQ2xyU2VsZWN0Q29udGFpbmVyXSxcbiAgZXhwb3J0czogW0NsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJTZWxlY3QsIENsclNlbGVjdENvbnRhaW5lcl0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsclNlbGVjdENvbnRhaW5lcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclNlbGVjdE1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGV4dGFyZWEtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItdGV4dGFyZWEtd3JhcHBlclwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJUZXh0YXJlYV1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtJZkVycm9yU2VydmljZSwgTmdDb250cm9sU2VydmljZSwgQ29udHJvbElkU2VydmljZSwgQ29udHJvbENsYXNzU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRleHRhcmVhQ29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2Uuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IGNvbnRyb2wuaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRleHRhcmVhQ29udGFpbmVyIH0gZnJvbSAnLi90ZXh0YXJlYS1jb250YWluZXInO1xuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyVGV4dGFyZWFdJywgaG9zdDogeyAnW2NsYXNzLmNsci10ZXh0YXJlYV0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsclRleHRhcmVhIGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsclRleHRhcmVhQ29udGFpbmVyPiBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHN1cGVyKENsclRleHRhcmVhQ29udGFpbmVyLCB2Y3IsIDEpO1xuICAgIGlmICghY29udHJvbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnY2xyVGV4dGFyZWEgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gYW4gQW5ndWxhciBmb3JtIGNvbnRyb2wsIGFkZCBuZ01vZGVsIG9yIGZvcm1Db250cm9sIHRvIHRoZSB0ZXh0YXJlYSdcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb250cm9sQ2xhc3NTZXJ2aWNlKSB7XG4gICAgICBjb250cm9sQ2xhc3NTZXJ2aWNlLmluaXRDb250cm9sQ2xhc3MocmVuZGVyZXIsIGVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgaWYgKHRoaXMubmdDb250cm9sU2VydmljZSkge1xuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLnNldENvbnRyb2wodGhpcy5jb250cm9sKTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgb25CbHVyKCkge1xuICAgIGlmICh0aGlzLmlmRXJyb3JTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnRyaWdnZXJTdGF0dXNDaGFuZ2UoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJUZXh0YXJlYSB9IGZyb20gJy4vdGV4dGFyZWEnO1xuaW1wb3J0IHsgQ2xyVGV4dGFyZWFDb250YWluZXIgfSBmcm9tICcuL3RleHRhcmVhLWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclRleHRhcmVhLCBDbHJUZXh0YXJlYUNvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyVGV4dGFyZWEsIENsclRleHRhcmVhQ29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyVGV4dGFyZWFDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUZXh0YXJlYU1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQ2hlY2tib3hNb2R1bGUgfSBmcm9tICcuL2NoZWNrYm94L2NoZWNrYm94Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRGF0ZXBpY2tlck1vZHVsZSB9IGZyb20gJy4vZGF0ZXBpY2tlci9kYXRlcGlja2VyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJbnB1dE1vZHVsZSB9IGZyb20gJy4vaW5wdXQvaW5wdXQubW9kdWxlJztcbmltcG9ydCB7IENsclBhc3N3b3JkTW9kdWxlIH0gZnJvbSAnLi9wYXNzd29yZC9wYXNzd29yZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyUmFkaW9Nb2R1bGUgfSBmcm9tICcuL3JhZGlvL3JhZGlvLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTZWxlY3RNb2R1bGUgfSBmcm9tICcuL3NlbGVjdC9zZWxlY3QubW9kdWxlJztcbmltcG9ydCB7IENsclRleHRhcmVhTW9kdWxlIH0gZnJvbSAnLi90ZXh0YXJlYS90ZXh0YXJlYS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW1xuICAgIENsckNvbW1vbkZvcm1zTW9kdWxlLFxuICAgIENsckNoZWNrYm94TW9kdWxlLFxuICAgIENsckRhdGVwaWNrZXJNb2R1bGUsXG4gICAgQ2xySW5wdXRNb2R1bGUsXG4gICAgQ2xyUGFzc3dvcmRNb2R1bGUsXG4gICAgQ2xyUmFkaW9Nb2R1bGUsXG4gICAgQ2xyU2VsZWN0TW9kdWxlLFxuICAgIENsclRleHRhcmVhTW9kdWxlLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJGb3Jtc01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBDbHJMb2FkaW5nU3RhdGUgfSBmcm9tICcuLi8uLi9sb2FkaW5nL2xvYWRpbmcnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXhwYW5kIGltcGxlbWVudHMgTG9hZGluZ0xpc3RlbmVyIHtcbiAgcHVibGljIGV4cGFuZGFibGU6IG51bWJlciA9IDA7XG5cbiAgLy8gcHJpdmF0ZSBfcmVwbGFjZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9yZXBsYWNlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgcHVibGljIGdldCByZXBsYWNlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9yZXBsYWNlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG4gIHNldFJlcGxhY2UocmVwbGFjZVZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVwbGFjZS5uZXh0KHJlcGxhY2VWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9sb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBsb2FkaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICB9XG5cbiAgc2V0IGxvYWRpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9sb2FkaW5nKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgfVxuXG4gIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2V4cGFuZGVkKSB7XG4gICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuICAgICAgdGhpcy5fYW5pbWF0ZS5uZXh0KCk7XG4gICAgICB0aGlzLl9leHBhbmRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIHRoZSBkYXRhZ3JpZCBSb3dFeHBhbmQuXG4gIC8vIEkgc3BlbnQgc29tZSB0aW1lIGRvaW5nIHRoaXMgYnV0IHJhbiBpbnRvIGEgY291cGxlIG9mIGlzc3Vlc1xuICAvLyBXaWxsIHRha2UgY2FyZSBvZiB0aGlzIGxhdGVyLlxuICBwcml2YXRlIF9hbmltYXRlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgcHVibGljIGdldCBhbmltYXRlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZXhwYW5kQ2hhbmdlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgcHVibGljIGdldCBleHBhbmRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGFuZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGxvYWRpbmdTdGF0ZUNoYW5nZShzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlKTogdm9pZCB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuTE9BRElORzpcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZS5uZXh0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi9wcm92aWRlcnMvZXhwYW5kJztcblxuLyoqXG4gKiBUT0RPOiBtYWtlIHRoaXMgYSByZXVzYWJsZSBkaXJlY3RpdmUgb3V0c2lkZSBvZiBEYXRhZ3JpZCwgbGlrZSBbY2xyTG9hZGluZ10uXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkV4cGFuZGVkXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJJZkV4cGFuZGVkIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9leHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWQ7XG4gIH1cblxuICBASW5wdXQoJ2NscklmRXhwYW5kZWQnKVxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuZXhwYW5kLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NscklmRXhwYW5kZWRDaGFuZ2UnKSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LCBwcml2YXRlIGNvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZiwgcHJpdmF0ZSBleHBhbmQ6IEV4cGFuZCkge1xuICAgIGV4cGFuZC5leHBhbmRhYmxlKys7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgZXhwYW5kLmV4cGFuZENoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KHRoaXMuZXhwYW5kLmV4cGFuZGVkKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpcHRpb25zIHRvIGFsbCB0aGUgc2VydmljZXMgYW5kIHF1ZXJpZXMgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBwcml2YXRlIHVwZGF0ZVZpZXcoKSB7XG4gICAgaWYgKHRoaXMuZXhwYW5kLmV4cGFuZGVkICYmIHRoaXMuY29udGFpbmVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5leHBhbmQuZXhwYW5kZWQpIHtcbiAgICAgIC8vIFNob3VsZCB3ZSBwYXNzIGEgY29udGV4dD8gSSBkb24ndCBzZWUgYW55dGhpbmcgdXNlZnVsIHRvIHBhc3MgcmlnaHQgbm93LFxuICAgICAgLy8gYnV0IHdlIGNhbiBjb21lIGJhY2sgdG8gaXQgaW4gdGhlIGZ1dHVyZSBhcyBhIHNvbHV0aW9uIGZvciBhZGRpdGlvbmFsIGZlYXR1cmVzLlxuICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBNb3ZlIHdoZW4gd2UgbW92ZSB0aGUgYW5pbWF0aW9uIGxvZ2ljIHRvIERhdGFncmlkIFJvdyBFeHBhbmRcbiAgICAgIC8vIFdlIGNsZWFyIGJlZm9yZSB0aGUgYW5pbWF0aW9uIGlzIG92ZXIuIE5vdCBpZGVhbCwgYnV0IGRvaW5nIGJldHRlciB3b3VsZCBpbnZvbHZlIGEgbXVjaCBoZWF2aWVyXG4gICAgICAvLyBwcm9jZXNzIGZvciB2ZXJ5IGxpdHRsZSBnYWluLiBPbmNlIEFuZ3VsYXIgYW5pbWF0aW9ucyBhcmUgZHluYW1pYyBlbm91Z2gsIHdlIHNob3VsZCBiZSBhYmxlIHRvXG4gICAgICAvLyBnZXQgdGhlIG9wdGltYWwgYmVoYXZpb3IuXG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMudXBkYXRlVmlldygpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5leHBhbmQuZXhwYW5kYWJsZS0tO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWZFeHBhbmRlZCB9IGZyb20gJy4vaWYtZXhwYW5kZWQnO1xuXG5leHBvcnQgKiBmcm9tICcuL2lmLWV4cGFuZGVkJztcblxuZXhwb3J0IGNvbnN0IEVYUEFORF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJJZkV4cGFuZGVkXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBFWFBBTkRfRElSRUNUSVZFUyB9IGZyb20gJy4vaW5kZXgnO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbRVhQQU5EX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbRVhQQU5EX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xySWZFeHBhbmRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJMb2FkaW5nIH0gZnJvbSAnLi9sb2FkaW5nJztcblxuZXhwb3J0IGNvbnN0IENMUl9MT0FESU5HX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsckxvYWRpbmddO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbQ0xSX0xPQURJTkdfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtDTFJfTE9BRElOR19ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsckxvYWRpbmdNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2Nsck91dHNpZGVDbGlja10nIH0pXG5leHBvcnQgY2xhc3MgT3V0c2lkZUNsaWNrIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZikge31cblxuICBASW5wdXQoJ2NsclN0cmljdCcpIHN0cmljdCA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoJ2Nsck91dHNpZGVDbGljaycpIG91dHNpZGVDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudCddKVxuICBkb2N1bWVudENsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0OyAvLyBHZXQgdGhlIGVsZW1lbnQgaW4gdGhlIERPTSBvbiB3aGljaCB0aGUgbW91c2Ugd2FzIGNsaWNrZWRcbiAgICBjb25zdCBob3N0ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50OyAvLyBHZXQgdGhlIGN1cnJlbnQgYWN0aW9uTWVudSBuYXRpdmUgSFRNTCBlbGVtZW50XG5cbiAgICBpZiAodGFyZ2V0ID09PSBob3N0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5zdHJpY3QgJiYgaG9zdC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3V0c2lkZUNsaWNrLmVtaXQoZXZlbnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPdXRzaWRlQ2xpY2sgfSBmcm9tICcuL291dHNpZGUtY2xpY2snO1xuXG5leHBvcnQgKiBmcm9tICcuL291dHNpZGUtY2xpY2snO1xuXG5leHBvcnQgY29uc3QgT1VTVElERV9DTElDS19ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtPdXRzaWRlQ2xpY2tdO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE9VU1RJREVfQ0xJQ0tfRElSRUNUSVZFUyB9IGZyb20gJy4vaW5kZXgnO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbT1VTVElERV9DTElDS19ESVJFQ1RJVkVTXSwgZXhwb3J0czogW09VU1RJREVfQ0xJQ0tfRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJPdXRzaWRlQ2xpY2tNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLypcbiAqIElmIHdlIHNvbWVkYXkgd2FudCB0byBiZSBhYmxlIHRvIHJlbmRlciB0aGUgZGF0YWdyaWQgaW4gYSB3ZWJ3b3JrZXIsXG4gKiB0aGlzIGlzIHdoZXJlIHdlIHdvdWxkIHRlc3QgaWYgd2UncmUgaW4gaGVhZGxlc3MgbW9kZS4gUmlnaHQgbm93IGl0J3Mgbm90IHRlc3RpbmcgYW55dGhpbmcsIGJ1dCBhbnkgYWNjZXNzXG4gKiB0byBuYXRpdmUgRE9NIGVsZW1lbnRzJyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGluIHRoZSBEYXRhZ3JpZCBoYXBwZW5zIGhlcmUuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRG9tQWRhcHRlciB7XG4gIHVzZXJEZWZpbmVkV2lkdGgoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBudW1iZXIge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGF0YWdyaWQtY2VsbC13aWR0aC16ZXJvJyk7XG4gICAgY29uc3QgdXNlckRlZmluZWRXaWR0aCA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSwgMTApO1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGF0YWdyaWQtY2VsbC13aWR0aC16ZXJvJyk7XG4gICAgcmV0dXJuIHVzZXJEZWZpbmVkV2lkdGg7XG4gIH1cblxuICBzY3JvbGxCYXJXaWR0aChlbGVtZW50OiBhbnkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIH1cblxuICBzY3JvbGxXaWR0aChlbGVtZW50OiBhbnkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxXaWR0aCB8fCAwO1xuICB9XG5cbiAgY29tcHV0ZWRIZWlnaHQoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKSwgMTApO1xuICB9XG5cbiAgY2xpZW50UmVjdChlbGVtZW50OiBhbnkpOiBDbGllbnRSZWN0IHtcbiAgICBjb25zdCBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QudG9wLCAxMCksXG4gICAgICBib3R0b206IHBhcnNlSW50KGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSwgMTApLFxuICAgICAgbGVmdDogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QubGVmdCwgMTApLFxuICAgICAgcmlnaHQ6IHBhcnNlSW50KGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0LCAxMCksXG4gICAgICB3aWR0aDogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3Qud2lkdGgsIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QuaGVpZ2h0LCAxMCksXG4gICAgfTtcbiAgfVxuXG4gIG1pbldpZHRoKGVsZW1lbnQ6IGFueSk6IG51bWJlciB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnbWluLXdpZHRoJyksIDEwKTtcbiAgfVxuXG4gIGZvY3VzKGVsZW1lbnQ6IGFueSk6IHZvaWQge1xuICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vKlxuICogVGhpcyBpcyBhIGhhY2sgdGhhdCB3ZSBoYXZlIHRvIHdyaXRlIGZvciBub3cgYmVjYXVzZSBvZiBidWdzIGFuZCBsaW1pdGF0aW9ucyBpbiBBbmd1bGFyLFxuICogcGxlYXNlIGRvIG5vdCB1c2UgdGhpcyBhcyBhbiBleGFtcGxlLlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kJztcbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1yb3cnIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRSb3dFeHBhbmRBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBleHBhbmQ6IEV4cGFuZFxuICApIHtcbiAgICBpZiAoZXhwYW5kICYmIGV4cGFuZC5hbmltYXRlKSB7XG4gICAgICBleHBhbmQuYW5pbWF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhZCBhbiBhbmltYXRpb24gd2FpdGluZywgc28gd2UganVzdCBoYXZlIHRvIHJ1biBpbiwgbm90IHByZXBhcmUgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMub2xkSGVpZ2h0KSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJ1bigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBydW5uaW5nOiBhbnk7XG4gIHByaXZhdGUgb2xkSGVpZ2h0OiBudW1iZXI7XG5cbiAgLypcbiAgICAgKiBEaXJ0eSBtYW51YWwgYW5pbWF0aW9uIGhhbmRsaW5nLCBidXQgd2UgaGF2ZSBubyB3YXkgdG8gdXNlIGR5bmFtaWMgaGVpZ2h0cyBpbiBBbmd1bGFyJ3MgY3VycmVudCBBUEkuXG4gICAgICogVGhleSdyZSB3b3JraW5nIG9uIGl0LCBidXQgaGF2ZSBubyBFVEEuXG4gICAgICovXG4gIHByaXZhdGUgYW5pbWF0ZSgpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBkbyBoYXZlIHdlYi1hbmltYXRpb25zIGF2YWlsYWJsZS4gSWYgbm90LCBqdXN0IHNraXAgdGhlIGFuaW1hdGlvbi5cbiAgICBpZiAoIXRoaXMuZWwubmF0aXZlRWxlbWVudC5hbmltYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgaGFkIGFuIGFuaW1hdGlvbiBydW5uaW5nLCB3ZSBza2lwIHRvIHRoZSBlbmRcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcuZmluaXNoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5vbGRIZWlnaHQgPSB0aGlzLmRvbUFkYXB0ZXIuY29tcHV0ZWRIZWlnaHQodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICAvLyBXZSBzZXQgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBpbW1lZGlhdGVseSB0byBhdm9pZCBhIGZsaWNrZXIgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzLlxuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdGhpcy5vbGRIZWlnaHQgKyAncHgnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ292ZXJmbG93LXknLCAnaGlkZGVuJyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5leHBhbmQubG9hZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJ1bigpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBydW4oKSB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCBudWxsKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmRvbUFkYXB0ZXIuY29tcHV0ZWRIZWlnaHQodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuYW5pbWF0ZShcbiAgICAgIHsgaGVpZ2h0OiBbdGhpcy5vbGRIZWlnaHQgKyAncHgnLCBuZXdIZWlnaHQgKyAncHgnXSwgZWFzaW5nOiAnZWFzZS1pbi1vdXQnIH0sXG4gICAgICB7IGR1cmF0aW9uOiAyMDAgfVxuICAgICk7XG4gICAgdGhpcy5ydW5uaW5nLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvdy15JywgbnVsbCk7XG4gICAgICBkZWxldGUgdGhpcy5ydW5uaW5nO1xuICAgIH07XG4gICAgZGVsZXRlIHRoaXMub2xkSGVpZ2h0O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ3VzdG9tRmlsdGVyIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuLypcbiAqIFRoaXMgcHJvdmlkZXIgaW1wbGVtZW50cyBzb21lIGZvcm0gb2Ygc3luY2hyb25vdXMgZGVib3VuY2luZyB0aHJvdWdoIGEgbG9jayBwYXR0ZXJuXG4gKiB0byBhdm9pZCBlbWl0dGluZyBtdWx0aXBsZSBzdGF0ZSBjaGFuZ2VzIGZvciBhIHNpbmdsZSB1c2VyIGFjdGlvbi5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0YXRlRGVib3VuY2VyIHtcbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBnbG9iYWwgc3RhdGUgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgLy8gV2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoZSBTdWJqZWN0IGl0c2VsZiwgYnV0IHRoZSBPYnNlcnZhYmxlIHdoaWNoIGlzIHJlYWQtb25seVxuICBwdWJsaWMgZ2V0IGNoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLypcbiAgICAgKiBUaGlzIGlzIHRoZSBsb2NrLCB0byBvbmx5IGVtaXQgb25jZSBhbGwgdGhlIGNoYW5nZXMgaGF2ZSBmaW5pc2hlZCBwcm9jZXNzaW5nXG4gICAgICovXG4gIHByaXZhdGUgbmJDaGFuZ2VzID0gMDtcblxuICBwdWJsaWMgY2hhbmdlU3RhcnQoKSB7XG4gICAgdGhpcy5uYkNoYW5nZXMrKztcbiAgfVxuXG4gIHB1YmxpYyBjaGFuZ2VEb25lKCkge1xuICAgIGlmICgtLXRoaXMubmJDaGFuZ2VzID09PSAwKSB7XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQYWdlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGF0ZURlYm91bmNlcjogU3RhdGVEZWJvdW5jZXIpIHt9XG5cbiAgLyoqXG4gICAqIFBhZ2Ugc2l6ZSwgYSB2YWx1ZSBvZiAwIG1lYW5zIG5vIHBhZ2luYXRpb25cbiAgICovXG4gIHByaXZhdGUgX3NpemUgPSAwO1xuICBwdWJsaWMgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuICBwdWJsaWMgc2V0IHNpemUoc2l6ZTogbnVtYmVyKSB7XG4gICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMuX3NpemU7XG4gICAgaWYgKHNpemUgIT09IG9sZFNpemUpIHtcbiAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBZZWFwLiBUaGF0J3MgdGhlIGZvcm11bGEgdG8ga2VlcCB0aGUgZmlyc3QgaXRlbSBmcm9tIHRoZSBvbGQgcGFnZSBzdGlsbFxuICAgICAgICAvLyBkaXNwbGF5ZWQgaW4gdGhlIG5ldyBvbmUuXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBNYXRoLmZsb29yKG9sZFNpemUgLyBzaXplICogKHRoaXMuX2N1cnJlbnQgLSAxKSkgKyAxO1xuICAgICAgfVxuICAgICAgLy8gV2UgYWx3YXlzIGVtaXQgYW4gZXZlbnQgZXZlbiBpZiB0aGUgY3VycmVudCBwYWdlIGluZGV4IGRpZG4ndCBjaGFuZ2UsIGJlY2F1c2VcbiAgICAgIC8vIHRoZSBzaXplIGNoYW5naW5nIG1lYW5zIHRoZSBpdGVtcyBpbnNpZGUgdGhlIHBhZ2UgYXJlIGRpZmZlcmVudFxuICAgICAgdGhpcy5fY2hhbmdlLm5leHQodGhpcy5fY3VycmVudCk7XG4gICAgICB0aGlzLl9zaXplQ2hhbmdlLm5leHQodGhpcy5fc2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvdGFsIGl0ZW1zIChuZWVkZWQgdG8gZ3Vlc3MgdGhlIGxhc3QgcGFnZSlcbiAgICovXG4gIHByaXZhdGUgX3RvdGFsSXRlbXMgPSAwO1xuICBwdWJsaWMgZ2V0IHRvdGFsSXRlbXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdG90YWxJdGVtcztcbiAgfVxuICBwdWJsaWMgc2V0IHRvdGFsSXRlbXModG90YWw6IG51bWJlcikge1xuICAgIHRoaXMuX3RvdGFsSXRlbXMgPSB0b3RhbDtcbiAgICAvLyBJZiB3ZSBoYXZlIGxlc3MgaXRlbXMgdGhhbiBiZWZvcmUsIHdlIG1pZ2h0IG5lZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IHBhZ2VcbiAgICBpZiAodGhpcy5jdXJyZW50ID4gdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmxhc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExhc3QgcGFnZVxuICAgKi9cbiAgcHJpdmF0ZSBfbGFzdDogbnVtYmVyO1xuICBwdWJsaWMgZ2V0IGxhc3QoKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5fbGFzdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xhc3Q7XG4gICAgfVxuICAgIC8vIElmIHRoZSBsYXN0IHBhZ2UgaXNuJ3Qga25vd24sIHdlIGNvbXB1dGUgaXQgZnJvbSB0aGUgbGFzdCBpdGVtJ3MgaW5kZXhcbiAgICBpZiAodGhpcy5zaXplID4gMCAmJiB0aGlzLnRvdGFsSXRlbXMpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy50b3RhbEl0ZW1zIC8gdGhpcy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcHVibGljIHNldCBsYXN0KHBhZ2U6IG51bWJlcikge1xuICAgIHRoaXMuX2xhc3QgPSBwYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBwYWdlIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgLy8gV2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoZSBTdWJqZWN0IGl0c2VsZiwgYnV0IHRoZSBPYnNlcnZhYmxlIHdoaWNoIGlzIHJlYWQtb25seVxuICBwdWJsaWMgZ2V0IGNoYW5nZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9zaXplQ2hhbmdlID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuXG4gIHB1YmxpYyBnZXQgc2l6ZUNoYW5nZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9zaXplQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgcGFnZVxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudCA9IDE7XG4gIHB1YmxpYyBnZXQgY3VycmVudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICB9XG4gIHB1YmxpYyBzZXQgY3VycmVudChwYWdlOiBudW1iZXIpIHtcbiAgICBpZiAocGFnZSAhPT0gdGhpcy5fY3VycmVudCkge1xuICAgICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgICAgdGhpcy5fY3VycmVudCA9IHBhZ2U7XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dChwYWdlKTtcbiAgICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0byB0aGUgcHJldmlvdXMgcGFnZSBpZiBpdCBleGlzdHNcbiAgICovXG4gIHB1YmxpYyBwcmV2aW91cygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50ID4gMSkge1xuICAgICAgdGhpcy5jdXJyZW50LS07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRvIHRoZSBuZXh0IHBhZ2UgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50IDwgdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmN1cnJlbnQrKztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHBhZ2UsIHN0YXJ0aW5nIGF0IDBcbiAgICovXG4gIHB1YmxpYyBnZXQgZmlyc3RJdGVtKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5jdXJyZW50IC0gMSkgKiB0aGlzLnNpemU7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgaXRlbSBkaXNwbGF5ZWQgb24gdGhlIGN1cnJlbnQgcGFnZSwgc3RhcnRpbmcgYXQgMFxuICAgKi9cbiAgcHVibGljIGdldCBsYXN0SXRlbSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsSXRlbXMgLSAxO1xuICAgIH1cbiAgICBsZXQgbGFzdEluUGFnZSA9IHRoaXMuY3VycmVudCAqIHRoaXMuc2l6ZSAtIDE7XG4gICAgaWYgKHRoaXMudG90YWxJdGVtcykge1xuICAgICAgbGFzdEluUGFnZSA9IE1hdGgubWluKGxhc3RJblBhZ2UsIHRoaXMudG90YWxJdGVtcyAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluUGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHBhZ2Ugc2l6ZSB0byAwXG4gICAqL1xuICBwdWJsaWMgcmVzZXRQYWdlU2l6ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnNpemUgPSAwO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuL3BhZ2UnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGaWx0ZXJzUHJvdmlkZXI8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlOiBQYWdlLCBwcml2YXRlIHN0YXRlRGVib3VuY2VyOiBTdGF0ZURlYm91bmNlcikge31cbiAgLyoqXG4gICAqIFRoaXMgc3ViamVjdCBpcyB0aGUgbGlzdCBvZiBmaWx0ZXJzIHRoYXQgY2hhbmdlZCBsYXN0LCBub3QgdGhlIHdob2xlIGxpc3QuXG4gICAqIFdlIGVtaXQgYSBsaXN0IHJhdGhlciB0aGFuIGp1c3Qgb25lIGZpbHRlciB0byBhbGxvdyBiYXRjaCBjaGFuZ2VzIHRvIHNldmVyYWwgYXQgb25jZS5cbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+W10+KCk7XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFsbCBmaWx0ZXJzLCB3aGV0aGVyIHRoZXkncmUgYWN0aXZlIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBfYWxsOiBSZWdpc3RlcmVkRmlsdGVyPFQsIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PltdID0gW107XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIGF0IGxlYXN0IG9uZSBmaWx0ZXIgaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgcHVibGljIGhhc0FjdGl2ZUZpbHRlcnMoKTogYm9vbGVhbiB7XG4gICAgLy8gV2UgZG8gbm90IHVzZSBnZXRBY3RpdmVGaWx0ZXJzKCkgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG11Y2ggbW9yZSBvZnRlblxuICAgIC8vIGFuZCBzdG9wcGluZyB0aGUgbG9vcCBlYXJseSBtaWdodCBiZSByZWxldmFudC5cbiAgICBmb3IgKGNvbnN0IHsgZmlsdGVyIH0gb2YgdGhpcy5fYWxsKSB7XG4gICAgICBpZiAoZmlsdGVyICYmIGZpbHRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyc1xuICAgKi9cbiAgcHVibGljIGdldEFjdGl2ZUZpbHRlcnMoKTogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSB7XG4gICAgY29uc3QgcmV0OiBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdID0gW107XG4gICAgZm9yIChjb25zdCB7IGZpbHRlciB9IG9mIHRoaXMuX2FsbCkge1xuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICByZXQucHVzaChmaWx0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGZpbHRlciwgYW5kIHJldHVybnMgYSBkZXJlZ2lzdHJhdGlvbiBmdW5jdGlvblxuICAgKi9cbiAgcHVibGljIGFkZDxGIGV4dGVuZHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+KGZpbHRlcjogRik6IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRj4ge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYWxsLmxlbmd0aDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBmaWx0ZXIuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZXNldFBhZ2VBbmRFbWl0RmlsdGVyQ2hhbmdlKFtmaWx0ZXJdKSk7XG4gICAgbGV0IGhhc1VucmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWQgPSBuZXcgUmVnaXN0ZXJlZEZpbHRlcihmaWx0ZXIsICgpID0+IHtcbiAgICAgIGlmIChoYXNVbnJlZ2lzdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLl9hbGwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGlmIChmaWx0ZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLnJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoW10pO1xuICAgICAgfVxuICAgICAgaGFzVW5yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICB0aGlzLl9hbGwucHVzaChyZWdpc3RlcmVkKTtcbiAgICBpZiAoZmlsdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMucmVzZXRQYWdlQW5kRW1pdEZpbHRlckNoYW5nZShbZmlsdGVyXSk7XG4gICAgfVxuICAgIHJldHVybiByZWdpc3RlcmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYW4gaXRlbSBpZiBpdCBpcyBhY2NlcHRlZCBieSBhbGwgY3VycmVudGx5IGFjdGl2ZSBmaWx0ZXJzXG4gICAqL1xuICBwdWJsaWMgYWNjZXB0cyhpdGVtOiBUKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCB7IGZpbHRlciB9IG9mIHRoaXMuX2FsbCkge1xuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUoKSAmJiAhZmlsdGVyLmFjY2VwdHMoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRQYWdlQW5kRW1pdEZpbHRlckNoYW5nZShmaWx0ZXJzOiBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdKSB7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgIC8vIGZpbHRlcmluZyBtYXkgY2hhbmdlIHRoZSBwYWdlIG51bWJlciBzdWNoIHRoYXQgY3VycmVudCBwYWdlIG51bWJlciBkb2Vzbid0IGV4aXN0IGluIHRoZSBmaWx0ZXJlZCBkYXRhc2V0LlxuICAgIC8vIFNvIGhlcmUgd2UgYWx3YXlzIHNldCB0aGUgY3VycmVudCBwYWdlIHRvIDEgc28gdGhhdCBpdCdsbCBmZXRjaCBmaXJzdCBwYWdlJ3MgZGF0YSB3aXRoIHRoZSBnaXZlbiBmaWx0ZXIuXG4gICAgdGhpcy5fcGFnZS5jdXJyZW50ID0gMTtcbiAgICB0aGlzLl9jaGFuZ2UubmV4dChmaWx0ZXJzKTtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZURvbmUoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVnaXN0ZXJlZEZpbHRlcjxULCBGIGV4dGVuZHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+IHtcbiAgY29uc3RydWN0b3IocHVibGljIGZpbHRlcjogRiwgcHVibGljIHVucmVnaXN0ZXI6ICgpID0+IHZvaWQpIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciwgUmVnaXN0ZXJlZEZpbHRlciB9IGZyb20gJy4uL3Byb3ZpZGVycy9maWx0ZXJzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGFncmlkRmlsdGVyUmVnaXN0cmFyPFQsIEYgZXh0ZW5kcyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPikge31cblxuICBwdWJsaWMgcmVnaXN0ZXJlZDogUmVnaXN0ZXJlZEZpbHRlcjxULCBGPjtcblxuICBwdWJsaWMgZ2V0IGZpbHRlcigpOiBGIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkICYmIHRoaXMucmVnaXN0ZXJlZC5maWx0ZXI7XG4gIH1cblxuICBwdWJsaWMgc2V0RmlsdGVyKGZpbHRlcjogRiB8IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRj4pIHtcbiAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGhhZCBhbm90aGVyIGZpbHRlciwgd2UgdW5yZWdpc3RlciBpdFxuICAgIHRoaXMuZGVsZXRlRmlsdGVyKCk7XG4gICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIFJlZ2lzdGVyZWRGaWx0ZXIpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IGZpbHRlcjtcbiAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkID0gdGhpcy5maWx0ZXJzLmFkZChmaWx0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZWxldGVGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZCkge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkLnVucmVnaXN0ZXIoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdGVyZWQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZGVsZXRlRmlsdGVyKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlcic7XG5pbXBvcnQgeyBQb3BvdmVyT3B0aW9ucyB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXItb3B0aW9ucy5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IEN1c3RvbUZpbHRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2N1c3RvbS1maWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyLCBSZWdpc3RlcmVkRmlsdGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZmlsdGVycyc7XG5pbXBvcnQgeyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhciB9IGZyb20gJy4vdXRpbHMvZGF0YWdyaWQtZmlsdGVyLXJlZ2lzdHJhcic7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG4vKipcbiAqIEN1c3RvbSBmaWx0ZXIgdGhhdCBjYW4gYmUgYWRkZWQgaW4gYW55IGNvbHVtbiB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvYmplY3QgcHJvcGVydHkgc3RyaW5nIGZpbHRlci5cbiAqIFRoZSByZWFzb24gdGhpcyBpcyBub3QganVzdCBhbiBpbnB1dCBvbiBEYXRhZ3JpZENvbHVtbiBpcyBiZWNhdXNlIHdlIG5lZWQgdGhlIGZpbHRlcidzIHRlbXBsYXRlIHRvIGJlIHByb2plY3RlZCxcbiAqIHNpbmNlIGl0IGNhbiBiZSBhbnl0aGluZyAobm90IGp1c3QgYSB0ZXh0IGlucHV0KS5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWZpbHRlcicsXG4gIC8vIFdlIHJlZ2lzdGVyIHRoaXMgY29tcG9uZW50IGFzIGEgQ3VzdG9tRmlsdGVyLCBmb3IgdGhlIHBhcmVudCBjb2x1bW4gdG8gZGV0ZWN0IGl0LlxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IEN1c3RvbUZpbHRlciwgdXNlRXhpc3Rpbmc6IENsckRhdGFncmlkRmlsdGVyIH1dLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uICNhbmNob3IgY2xhc3M9XCJkYXRhZ3JpZC1maWx0ZXItdG9nZ2xlXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCJcbiAgICAgICAgICAgIFtjbGFzcy5kYXRhZ3JpZC1maWx0ZXItb3Blbl09XCJvcGVuXCIgW2NsYXNzLmRhdGFncmlkLWZpbHRlcmVkXT1cImFjdGl2ZVwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+PC9idXR0b24+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFsoY2xyUG9wb3Zlck9sZCldPVwib3BlblwiIFtjbHJQb3BvdmVyT2xkQW5jaG9yXT1cImFuY2hvclwiIFtjbHJQb3BvdmVyT2xkQW5jaG9yUG9pbnRdPVwiYW5jaG9yUG9pbnRcIlxuICAgICAgICAgICAgIFtjbHJQb3BvdmVyT2xkUG9wb3ZlclBvaW50XT1cInBvcG92ZXJQb2ludFwiIFtjbHJQb3BvdmVyT2xkT3B0aW9uc109XCJwb3BvdmVyT3B0aW9uc1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWZpbHRlclwiPlxuICAgICAgICAgICAgICAgIDwhLS0gRklYTUU6IHRoaXMgd2hvbGUgZmlsdGVyIHBhcnQgbmVlZHMgYSBmaW5hbCBkZXNpZ24gYmVmb3JlIHdlIGNhbiB0cnkgdG8gaGF2ZSBhIGNsZWFuZXIgRE9NIC0tPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1maWx0ZXItY2xvc2Utd3JhcHBlclwiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgKGNsaWNrKT1cIm9wZW4gPSBmYWxzZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2xvc2VcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmNsb3NlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRGaWx0ZXI8VCA9IGFueT4gZXh0ZW5kcyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhcjxULCBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj5cbiAgaW1wbGVtZW50cyBDdXN0b21GaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihfZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LCBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncykge1xuICAgIHN1cGVyKF9maWx0ZXJzKTtcbiAgfVxuXG4gIHB1YmxpYyBhbmNob3JQb2ludDogUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gIHB1YmxpYyBwb3BvdmVyUG9pbnQ6IFBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICBwdWJsaWMgcG9wb3Zlck9wdGlvbnM6IFBvcG92ZXJPcHRpb25zID0geyBhbGxvd011bHRpcGxlT3BlbjogdHJ1ZSB9O1xuICAvKipcbiAgICogVHJhY2tzIHdoZXRoZXIgdGhlIGZpbHRlciBkcm9wZG93biBpcyBvcGVuIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBfb3BlbiA9IGZhbHNlO1xuICBwdWJsaWMgZ2V0IG9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICBASW5wdXQoJ2NsckRnRmlsdGVyT3BlbicpXG4gIHB1YmxpYyBzZXQgb3BlbihvcGVuOiBib29sZWFuKSB7XG4gICAgY29uc3QgYm9vbE9wZW4gPSAhIW9wZW47XG4gICAgaWYgKGJvb2xPcGVuICE9PSB0aGlzLl9vcGVuKSB7XG4gICAgICB0aGlzLl9vcGVuID0gYm9vbE9wZW47XG4gICAgICB0aGlzLm9wZW5DaGFuZ2VkLmVtaXQoYm9vbE9wZW4pO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnRmlsdGVyT3BlbkNoYW5nZScpIHB1YmxpYyBvcGVuQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIEBJbnB1dCgnY2xyRGdGaWx0ZXInKVxuICBwdWJsaWMgc2V0IGN1c3RvbUZpbHRlcihmaWx0ZXI6IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+IHwgUmVnaXN0ZXJlZEZpbHRlcjxULCBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj4pIHtcbiAgICB0aGlzLnNldEZpbHRlcihmaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZmlsdGVyIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICovXG4gIHB1YmxpYyBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiAhIXRoaXMuZmlsdGVyICYmIHRoaXMuZmlsdGVyLmlzQWN0aXZlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MvaGlkZXMgdGhlIGZpbHRlciBkcm9wZG93blxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFN0cmluZ0ZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvc3RyaW5nLWZpbHRlci5pbnRlcmZhY2UnO1xuXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsPFQgPSBhbnk+IGltcGxlbWVudHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZmlsdGVyRm46IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlPFQ+KSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSByZXF1aXJlZCBhcyBwYXJ0IG9mIHRoZSBGaWx0ZXIgaW50ZXJmYWNlXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2VzID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlcygpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJhdyBpbnB1dCB2YWx1ZVxuICAgKi9cbiAgcHJpdmF0ZSBfcmF3VmFsdWU6IHN0cmluZyA9ICcnO1xuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd1ZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbnB1dCB2YWx1ZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAqL1xuICBwcml2YXRlIF9sb3dlckNhc2VWYWx1ZTogc3RyaW5nID0gJyc7XG4gIHB1YmxpYyBnZXQgbG93ZXJDYXNlVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvd2VyQ2FzZVZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb21tb24gc2V0dGVyIGZvciB0aGUgaW5wdXQgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcmF3VmFsdWUpIHtcbiAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLl9sb3dlckNhc2VWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgdGhpcy5fY2hhbmdlcy5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBmaWx0ZXIgaXMgY3VycmVudGx5IGFjdGl2ZSwgbWVhbmluZyB0aGUgaW5wdXQgaXMgbm90IGVtcHR5XG4gICAqL1xuICBwdWJsaWMgaXNBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhbiBpdGVtIG1hdGNoZXMgYSBzZWFyY2ggdGV4dFxuICAgKi9cbiAgcHVibGljIGFjY2VwdHMoaXRlbTogVCk6IGJvb2xlYW4ge1xuICAgIC8vIFdlIGFsd2F5cyB0ZXN0IHdpdGggdGhlIGxvd2VyY2FzZSB2YWx1ZSBvZiB0aGUgaW5wdXQsIHRvIHN0YXkgY2FzZSBpbnNlbnNpdGl2ZVxuICAgIHJldHVybiB0aGlzLmZpbHRlckZuLmFjY2VwdHMoaXRlbSwgdGhpcy5sb3dlckNhc2VWYWx1ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRGaWx0ZXIgfSBmcm9tICcuLi8uLi9kYXRhZ3JpZC1maWx0ZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3N0cmluZy1maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IEN1c3RvbUZpbHRlciB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9jdXN0b20tZmlsdGVyJztcbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciwgUmVnaXN0ZXJlZEZpbHRlciB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9maWx0ZXJzJztcbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscy9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhciB9IGZyb20gJy4uLy4uL3V0aWxzL2RhdGFncmlkLWZpbHRlci1yZWdpc3RyYXInO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGwgfSBmcm9tICcuL2RhdGFncmlkLXN0cmluZy1maWx0ZXItaW1wbCc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1zdHJpbmctZmlsdGVyJyxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDdXN0b21GaWx0ZXIsIHVzZUV4aXN0aW5nOiBEYXRhZ3JpZFN0cmluZ0ZpbHRlciB9XSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGNsci1kZy1maWx0ZXIgW2NsckRnRmlsdGVyXT1cInJlZ2lzdGVyZWRcIiBbKGNsckRnRmlsdGVyT3BlbildPVwib3BlblwiPlxuICAgICAgICAgICAgPCEtLVxuICAgICAgICAgICAgICAgIEV2ZW4gdGhvdWdoIHRoaXMgKm5nSWYgbG9va3MgdXNlbGVzcyBiZWNhdXNlIHRoZSBmaWx0ZXIgY29udGFpbmVyIGFscmVhZHkgaGFzIG9uZSxcbiAgICAgICAgICAgICAgICBpdCBwcmV2ZW50cyBOZ0NvbnRyb2xTdGF0dXMgYW5kIG90aGVyIGRpcmVjdGl2ZXMgYXV0b21hdGljYWxseSBhZGRlZCBieSBBbmd1bGFyXG4gICAgICAgICAgICAgICAgb24gaW5wdXRzIHdpdGggTmdNb2RlbCBmcm9tIGZyZWFraW5nIG91dCBiZWNhdXNlIG9mIHRoZWlyIGhvc3QgYmluZGluZyBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIG1pZC1jaGFuZ2UgZGV0ZWN0aW9uIHdoZW4gdGhlIGlucHV0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICAgIC0tPlxuICAgICAgICAgICAgPGlucHV0ICNpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJzZWFyY2hcIiBbKG5nTW9kZWwpXT1cInZhbHVlXCIgKm5nSWY9XCJvcGVuXCJcbiAgICAgICAgICAgICAgICAoa2V5dXAuZW50ZXIpPVwiY2xvc2UoKVwiIChrZXl1cC5lc2NhcGUpPVwiY2xvc2UoKVwiLz5cbiAgICAgICAgPC9jbHItZGctZmlsdGVyPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkU3RyaW5nRmlsdGVyPFQgPSBhbnk+IGV4dGVuZHMgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXI8VCwgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsPFQ+PlxuICBpbXBsZW1lbnRzIEN1c3RvbUZpbHRlciwgQWZ0ZXJWaWV3SW5pdCB7XG4gIGNvbnN0cnVjdG9yKGZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPiwgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyKSB7XG4gICAgc3VwZXIoZmlsdGVycyk7XG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9taXphYmxlIGZpbHRlciBsb2dpYyBiYXNlZCBvbiBhIHNlYXJjaCB0ZXh0XG4gICAqL1xuICBASW5wdXQoJ2NsckRnU3RyaW5nRmlsdGVyJylcbiAgc2V0IGN1c3RvbVN0cmluZ0ZpbHRlcihcbiAgICB2YWx1ZTogQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2U8VD4gfCBSZWdpc3RlcmVkRmlsdGVyPFQsIERhdGFncmlkU3RyaW5nRmlsdGVySW1wbDxUPj5cbiAgKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnaXN0ZXJlZEZpbHRlcikge1xuICAgICAgdGhpcy5zZXRGaWx0ZXIodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEZpbHRlcihuZXcgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsKHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZmlsdGVyIGRyb3Bkb3duIGlzIG9wZW5cbiAgICovXG4gIHB1YmxpYyBvcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFdlIG5lZWQgdGhlIGFjdHVhbCBpbnB1dCBlbGVtZW50IHRvIGF1dG9tYXRpY2FsbHkgZm9jdXMgb24gaXRcbiAgICovXG4gIEBWaWV3Q2hpbGQoJ2lucHV0JykgcHVibGljIGlucHV0OiBFbGVtZW50UmVmO1xuXG4gIC8qKlxuICAgKiBXZSBncmFiIHRoZSBDbHJEYXRhZ3JpZEZpbHRlciB3ZSB3cmFwIHRvIHJlZ2lzdGVyIHRoaXMgU3RyaW5nRmlsdGVyIHRvIGl0LlxuICAgKi9cbiAgQFZpZXdDaGlsZChDbHJEYXRhZ3JpZEZpbHRlcikgcHVibGljIGZpbHRlckNvbnRhaW5lcjogQ2xyRGF0YWdyaWRGaWx0ZXI8VD47XG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLmZpbHRlckNvbnRhaW5lci5vcGVuQ2hhbmdlZC5zdWJzY3JpYmUoKG9wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdGhlIHRpbWVvdXQgYmVjYXVzZSBhdCB0aGUgdGltZSB0aGlzIGV4ZWN1dGVzLCB0aGUgaW5wdXQgaXNuJ3RcbiAgICAgICAgLy8gZGlzcGxheWVkIHlldC5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5kb21BZGFwdGVyLmZvY3VzKHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbW1vbiBzZXR0ZXIgZm9yIHRoZSBpbnB1dCB2YWx1ZVxuICAgKi9cbiAgcHVibGljIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIudmFsdWU7XG4gIH1cbiAgQElucHV0KCdjbHJGaWx0ZXJWYWx1ZScpXG4gIHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5maWx0ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLmZpbHRlci52YWx1ZSkge1xuICAgICAgdGhpcy5maWx0ZXIudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZmlsdGVyVmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRmlsdGVyVmFsdWVDaGFuZ2UnKSBmaWx0ZXJWYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudENoZWNrZWQsIENoYW5nZURldGVjdG9yUmVmLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgV2lsbHlXb25rYSB9IGZyb20gJy4vd2lsbHktd29ua2EnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgT29tcGFMb29tcGEgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRDaGVja2VkLCBPbkRlc3Ryb3kge1xuICAvLyBGSVhNRTogUmVxdWVzdCBJbmplY3RvciBvbmNlIHdlIG1vdmUgdG8gQW5ndWxhciA0LjIrLCBpdCdsbCBhbGxvdyBlYXNpZXIgcmVmYWN0b3JzXG4gIGNvbnN0cnVjdG9yKGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHdpbGx5V29ua2E6IFdpbGx5V29ua2EpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHdpbGx5V29ua2EuY2hvY29sYXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5sYXRlc3RGbGF2b3IgIT09IHRoaXMuZmxhdm9yKSB7XG4gICAgICAgIGNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIHByaXZhdGUgbGF0ZXN0Rmxhdm9yOiBhbnk7XG5cbiAgYWJzdHJhY3QgZ2V0IGZsYXZvcigpOiBhbnk7XG5cbiAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgIHRoaXMubGF0ZXN0Rmxhdm9yID0gdGhpcy5mbGF2b3I7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFJvd0FjdGlvblNlcnZpY2Uge1xuICBwcml2YXRlIGFjdGlvbmFibGVDb3VudCA9IDA7XG5cbiAgcHVibGljIHJlZ2lzdGVyKCkge1xuICAgIHRoaXMuYWN0aW9uYWJsZUNvdW50Kys7XG4gIH1cblxuICBwdWJsaWMgdW5yZWdpc3RlcigpIHtcbiAgICB0aGlzLmFjdGlvbmFibGVDb3VudC0tO1xuICB9XG5cbiAgLyoqXG4gICAqIGZhbHNlIG1lYW5zIG5vIHJvd3Mgd2l0aCBhY3Rpb25cbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzQWN0aW9uYWJsZVJvdygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25hYmxlQ291bnQgPiAwO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdDaGVja2VkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qXG4gKiBBZnRlciBhIGNvbnZlcnNhdGlvbiB3aXRoIHRoZSBBbmd1bGFyIGNvcmUgdGVhbSwgaXQgdHVybnMgb3V0IHdlIGRvbid0IGhhdmUgbXVjaCBvZiBhIGNob2ljZSBmb3Igb3VyXG4gKiBkZWNsYXJhdGl2ZSBBUEksIHdlIG5lZWQgdG8gZmlnaHQgYWdhaW5zdCBjaGFuZ2UgZGV0ZWN0aW9uIGFuZCBpdHMgb25lLXdheSBmbG93LiBUaGlzIGlzXG4gKiBjdXJyZW50bHkgdGhlIGxlYXN0IGRpcnR5IHNvbHV0aW9uIHRvIGRvIHdoYXQgd2Ugd2FudC5cbiAqXG4gKiBEbyBub3QgbW9kaWZ5IG9yIGV2ZW4gdXNlIHRoaXMgY2xhc3MgdW5sZXNzIHlvdSBrbm93IGV4YWN0bHkgd2hhdCB5b3UncmUgZG9pbmcuXG4gKiBJdCBoYXMgdGhlIHBvdGVudGlhbCB0byB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gbG9vcHMgb3Iga2lsbCBhcHAgcGVyZm9ybWFuY2VzLlxuICovXG5leHBvcnQgY2xhc3MgV2lsbHlXb25rYSBpbXBsZW1lbnRzIEFmdGVyVmlld0NoZWNrZWQge1xuICBwcml2YXRlIF9jaG9jb2xhdGUgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIHB1YmxpYyBnZXQgY2hvY29sYXRlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9jaG9jb2xhdGUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgdGhpcy5fY2hvY29sYXRlLm5leHQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaWxseVdvbmthIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL3dpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRhdGFncmlkJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkV2lsbHlXb25rYSBleHRlbmRzIFdpbGx5V29ua2Ege31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPb21wYUxvb21wYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS9vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRXaWxseVdvbmthIH0gZnJvbSAnLi9kYXRhZ3JpZC13aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kYXRhZ3JpZCwgY2xyLWRnLXJvdycgfSlcbmV4cG9ydCBjbGFzcyBBY3Rpb25hYmxlT29tcGFMb29tcGEgZXh0ZW5kcyBPb21wYUxvb21wYSB7XG4gIHByaXZhdGUgcm93QWN0aW9uczogUm93QWN0aW9uU2VydmljZTtcblxuICBjb25zdHJ1Y3RvcihjZHI6IENoYW5nZURldGVjdG9yUmVmLCBAT3B0aW9uYWwoKSB3aWxseVdvbmthOiBEYXRhZ3JpZFdpbGx5V29ua2EsIHJvd0FjdGlvbnM6IFJvd0FjdGlvblNlcnZpY2UpIHtcbiAgICBpZiAoIXdpbGx5V29ua2EpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyLWRnLXJvdyBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsci1kYXRhZ3JpZCcpO1xuICAgIH1cbiAgICBzdXBlcihjZHIsIHdpbGx5V29ua2EpO1xuICAgIHRoaXMucm93QWN0aW9ucyA9IHJvd0FjdGlvbnM7XG4gIH1cblxuICBnZXQgZmxhdm9yKCkge1xuICAgIHJldHVybiB0aGlzLnJvd0FjdGlvbnMuaGFzQWN0aW9uYWJsZVJvdztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXhwYW5kYWJsZVJvd3NDb3VudCB7XG4gIHByaXZhdGUgZXhwYW5kYWJsZUNvdW50ID0gMDtcblxuICBwdWJsaWMgcmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5leHBhbmRhYmxlQ291bnQrKztcbiAgfVxuXG4gIHB1YmxpYyB1bnJlZ2lzdGVyKCkge1xuICAgIHRoaXMuZXhwYW5kYWJsZUNvdW50LS07XG4gIH1cblxuICAvKipcbiAgICogZmFsc2UgbWVhbnMgbm8gcm93cyB3aXRoIGFjdGlvblxuICAgKi9cbiAgcHVibGljIGdldCBoYXNFeHBhbmRhYmxlUm93KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGVDb3VudCA+IDA7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPb21wYUxvb21wYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS9vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4uL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzJztcbmltcG9ydCB7IERhdGFncmlkV2lsbHlXb25rYSB9IGZyb20gJy4vZGF0YWdyaWQtd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGF0YWdyaWQsIGNsci1kZy1yb3cnIH0pXG5leHBvcnQgY2xhc3MgRXhwYW5kYWJsZU9vbXBhTG9vbXBhIGV4dGVuZHMgT29tcGFMb29tcGEge1xuICBwcml2YXRlIGV4cGFuZGFibGVDb3VudDogRXhwYW5kYWJsZVJvd3NDb3VudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIEBPcHRpb25hbCgpIHdpbGx5V29ua2E6IERhdGFncmlkV2lsbHlXb25rYSxcbiAgICBleHBhbmRhYmxlQ291bnQ6IEV4cGFuZGFibGVSb3dzQ291bnRcbiAgKSB7XG4gICAgaWYgKCF3aWxseVdvbmthKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1kZy1yb3cgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItZGF0YWdyaWQnKTtcbiAgICB9XG4gICAgc3VwZXIoY2RyLCB3aWxseVdvbmthKTtcbiAgICB0aGlzLmV4cGFuZGFibGVDb3VudCA9IGV4cGFuZGFibGVDb3VudDtcbiAgfVxuXG4gIGdldCBmbGF2b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZUNvdW50Lmhhc0V4cGFuZGFibGVSb3c7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbi8qKlxuICogR2VuZXJpYyBhY2Nlc3NvciBmb3IgZGVlcCBvYmplY3QgcHJvcGVydGllc1xuICogdGhhdCBjYW4gYmUgc3BlY2lmaWVkIGFzIHNpbXBsZSBkb3Qtc2VwYXJhdGVkIHN0cmluZ3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBOZXN0ZWRQcm9wZXJ0eTxUID0gYW55PiB7XG4gIHByaXZhdGUgc3BsaXRQcm9wOiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHByb3A6IHN0cmluZykge1xuICAgIGlmIChwcm9wLmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICB0aGlzLnNwbGl0UHJvcCA9IHByb3Auc3BsaXQoJy4nKTtcbiAgICB9XG4gIH1cblxuICAvLyBTYWZlIGdldHRlciBmb3IgYSBkZWVwIG9iamVjdCBwcm9wZXJ0eSwgd2lsbCBub3QgdGhyb3cgYW4gZXJyb3IgYnV0IHJldHVyblxuICAvLyB1bmRlZmluZWQgaWYgb25lIG9mIHRoZSBpbnRlcm1lZGlhdGUgcHJvcGVydGllcyBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAgcHVibGljIGdldFByb3BWYWx1ZShpdGVtOiBUKTogYW55IHtcbiAgICBpZiAodGhpcy5zcGxpdFByb3ApIHtcbiAgICAgIGxldCB2YWx1ZSA9IGl0ZW07XG4gICAgICBmb3IgKGNvbnN0IG5lc3RlZFByb3Agb2YgdGhpcy5zcGxpdFByb3ApIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWVbbmVzdGVkUHJvcF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHZhbHVlW25lc3RlZFByb3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXRlbVt0aGlzLnByb3BdO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9jb21wYXJhdG9yLmludGVyZmFjZSc7XG5pbXBvcnQgeyBOZXN0ZWRQcm9wZXJ0eSB9IGZyb20gJy4uL25lc3RlZC1wcm9wZXJ0eSc7XG5cbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcjxUID0gYW55PiBpbXBsZW1lbnRzIENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiB7XG4gIHByaXZhdGUgbmVzdGVkUHJvcDogTmVzdGVkUHJvcGVydHk8VD47XG5cbiAgY29uc3RydWN0b3IocHVibGljIHByb3A6IHN0cmluZykge1xuICAgIHRoaXMubmVzdGVkUHJvcCA9IG5ldyBOZXN0ZWRQcm9wZXJ0eShwcm9wKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wYXJlKGE6IFQsIGI6IFQpOiBudW1iZXIge1xuICAgIGxldCBwcm9wQSA9IHRoaXMubmVzdGVkUHJvcC5nZXRQcm9wVmFsdWUoYSk7XG4gICAgbGV0IHByb3BCID0gdGhpcy5uZXN0ZWRQcm9wLmdldFByb3BWYWx1ZShiKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcEEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm9wQSA9IHByb3BBLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9wQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3BCID0gcHJvcEIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3BBID09PSAndW5kZWZpbmVkJyB8fCBwcm9wQSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wQiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcEIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wQiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcEIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChwcm9wQSA8IHByb3BCKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcEEgPiBwcm9wQikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3N0cmluZy1maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IE5lc3RlZFByb3BlcnR5IH0gZnJvbSAnLi4vbmVzdGVkLXByb3BlcnR5JztcblxuZXhwb3J0IGNsYXNzIERhdGFncmlkUHJvcGVydHlTdHJpbmdGaWx0ZXI8VCA9IGFueT4gaW1wbGVtZW50cyBDbHJEYXRhZ3JpZFN0cmluZ0ZpbHRlckludGVyZmFjZTxUPiB7XG4gIHByaXZhdGUgbmVzdGVkUHJvcDogTmVzdGVkUHJvcGVydHk8VD47XG5cbiAgY29uc3RydWN0b3IocHVibGljIHByb3A6IHN0cmluZywgcHVibGljIGV4YWN0ID0gZmFsc2UpIHtcbiAgICB0aGlzLm5lc3RlZFByb3AgPSBuZXcgTmVzdGVkUHJvcGVydHkocHJvcCk7XG4gIH1cblxuICBhY2NlcHRzKGl0ZW06IFQsIHNlYXJjaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJvcFZhbHVlID0gdGhpcy5uZXN0ZWRQcm9wLmdldFByb3BWYWx1ZShpdGVtKTtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZXhhY3QpIHtcbiAgICAgIHJldHVybiAoJycgKyBwcm9wVmFsdWUpLnRvTG93ZXJDYXNlKCkgPT09IHNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICgnJyArIHByb3BWYWx1ZSkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHNlYXJjaCkgPj0gMDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLyoqXG4gKiBFbnVtZXJhdGlvbiByZXByZXNlbnRpbmcgdGhlIHNvcnRpbmcgb3JkZXIgb2YgYSBkYXRhZ3JpZCBjb2x1bW4uIEl0IGlzIGEgY29uc3RhbnQgRW51bSxcbiAqIGkuZS4gZWFjaCB2YWx1ZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzIGEgYG51bWJlcmAsIHN0YXJ0aW5nIGF0IGluZGV4IDAuXG4gKlxuICogQGV4cG9ydFxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGVudW0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIge1xuICBVTlNPUlRFRCA9IDAsXG4gIEFTQyA9IDEsXG4gIERFU0MgPSAtMSxcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0YWJsZSwgTmdab25lLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERyYWdEaXNwYXRjaGVyIHtcbiAgcHJpdmF0ZSBfbGlzdGVuZXJzOiBGdW5jdGlvbltdO1xuXG4gIC8vIFdpbGwgYmUgbGlzdGVuaW5nIHRvIERyYWcgZXZlbnRzIG9uIHRoZSBmb2xsb3dpbmcgZWxlbWVudFxuICBoYW5kbGVSZWY6IEVsZW1lbnRSZWY7XG5cbiAgLy8gRXh0cmEgZWxlbWVudCB0byBiZSB1c2VkIGZvciB0cmFja2luZyBkcmFnIG1vdmVtZW50cy5cbiAgaGFuZGxlVHJhY2tlclJlZjogRWxlbWVudFJlZjtcblxuICBwcml2YXRlIF9vbkRyYWdTdGFydDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwcml2YXRlIF9vbkRyYWdNb3ZlOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHByaXZhdGUgX29uRHJhZ0VuZDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gIGdldCBvbkRyYWdTdGFydCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9vbkRyYWdTdGFydDtcbiAgfVxuXG4gIGdldCBvbkRyYWdNb3ZlKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX29uRHJhZ01vdmU7XG4gIH1cblxuICBnZXQgb25EcmFnRW5kKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX29uRHJhZ0VuZDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX25nWm9uZTogTmdab25lLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIGFkZERyYWdMaXN0ZW5lcigpIHtcbiAgICBjb25zdCBoYW5kbGVFbCA9IHRoaXMuaGFuZGxlUmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW1xuICAgICAgdGhpcy5jdXN0b21EcmFnRXZlbnQoaGFuZGxlRWwsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnKSxcbiAgICAgIHRoaXMuY3VzdG9tRHJhZ0V2ZW50KGhhbmRsZUVsLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnKSxcbiAgICBdO1xuICB9XG5cbiAgY3VzdG9tRHJhZ0V2ZW50KGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBzdGFydE9uRXZlbnQ6IHN0cmluZywgbW92ZU9uRXZlbnQ6IHN0cmluZywgZW5kT25FdmVudDogc3RyaW5nKTogRnVuY3Rpb24ge1xuICAgIGxldCBkcmFnTW92ZUxpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICAgIGxldCBkcmFnRW5kTGlzdGVuZXI6ICgpID0+IHZvaWQ7XG5cbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsIHN0YXJ0T25FdmVudCwgKHN0YXJ0RXZlbnQ6IGFueSkgPT4ge1xuICAgICAgdGhpcy5ub3RpZnlEcmFnU3RhcnQoc3RhcnRFdmVudCk7XG5cbiAgICAgIGRyYWdNb3ZlTGlzdGVuZXIgPSB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsIG1vdmVPbkV2ZW50LCAobW92ZUV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgICB0aGlzLm5vdGlmeURyYWdNb3ZlKG1vdmVFdmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRyYWdFbmRMaXN0ZW5lciA9IHRoaXMuX3JlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCBlbmRPbkV2ZW50LCAoZW5kRXZlbnQ6IGFueSkgPT4ge1xuICAgICAgICAvLyBVbnN1YnNjcmliaW5nIGZyb20gbW91c2VNb3ZlTGlzdGVuZXJcbiAgICAgICAgZHJhZ01vdmVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLm5vdGlmeURyYWdFbmQoZW5kRXZlbnQpO1xuICAgICAgICAvLyBVbnN1YnNjcmliaW5nIGZyb20gaXRzZWxmXG4gICAgICAgIGRyYWdFbmRMaXN0ZW5lcigpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBub3RpZnlEcmFnU3RhcnQoZXZlbnQ6IGFueSkge1xuICAgIHJldHVybiB0aGlzLl9vbkRyYWdTdGFydC5uZXh0KGV2ZW50KTtcbiAgfVxuXG4gIG5vdGlmeURyYWdNb3ZlKGV2ZW50OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5fb25EcmFnTW92ZS5uZXh0KGV2ZW50KTtcbiAgfVxuXG4gIG5vdGlmeURyYWdFbmQoZXZlbnQ6IGFueSkge1xuICAgIHJldHVybiB0aGlzLl9vbkRyYWdFbmQubmV4dChldmVudCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5tYXAoZXZlbnQgPT4gZXZlbnQoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29tcGFyYXRvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTb3J0PFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGF0ZURlYm91bmNlcjogU3RhdGVEZWJvdW5jZXIpIHt9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnRseSBhY3RpdmUgY29tcGFyYXRvclxuICAgKi9cbiAgcHJpdmF0ZSBfY29tcGFyYXRvcjogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+O1xuICBwdWJsaWMgZ2V0IGNvbXBhcmF0b3IoKTogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGFyYXRvcjtcbiAgfVxuICBwdWJsaWMgc2V0IGNvbXBhcmF0b3IodmFsdWU6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPikge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICB0aGlzLl9jb21wYXJhdG9yID0gdmFsdWU7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQXNjZW5kaW5nIG9yZGVyIGlmIGZhbHNlLCBkZXNjZW5kaW5nIGlmIHRydWVcbiAgICovXG4gIHByaXZhdGUgX3JldmVyc2U6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGdldCByZXZlcnNlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlO1xuICB9XG4gIHB1YmxpYyBzZXQgcmV2ZXJzZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICB0aGlzLl9yZXZlcnNlID0gdmFsdWU7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIHNvcnQgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8U29ydDxUPj4oKTtcbiAgcHJpdmF0ZSBlbWl0Q2hhbmdlKCkge1xuICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMpO1xuICB9XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxTb3J0PFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY29tcGFyYXRvciBhcyB0aGUgY3VycmVudCBvbmUsIG9yIHRvZ2dsZXMgcmV2ZXJzZSBpZiB0aGUgY29tcGFyYXRvciBpcyBhbHJlYWR5IHVzZWQuIFRoZVxuICAgKiBvcHRpb25hbCBmb3JjZVJldmVyc2UgaW5wdXQgcGFyYW1ldGVyIGFsbG93cyB0byBvdmVycmlkZSB0aGF0IHRvZ2dsaW5nIGJlaGF2aW9yIGJ5IHNvcnRpbmcgaW5cbiAgICogcmV2ZXJzZSBvcmRlciBpZiBgdHJ1ZWAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBTb3J0XG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKHNvcnRCeTogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+LCBmb3JjZVJldmVyc2U/OiBib29sZWFuKSB7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgIC8vIFdlIG1vZGlmeSBwcml2YXRlIHByb3BlcnRpZXMgZGlyZWN0bHksIHRvIGJhdGNoIHRoZSBjaGFuZ2UgZXZlbnRcbiAgICBpZiAodGhpcy5jb21wYXJhdG9yID09PSBzb3J0QnkpIHtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSB0eXBlb2YgZm9yY2VSZXZlcnNlICE9PSAndW5kZWZpbmVkJyA/IGZvcmNlUmV2ZXJzZSB8fCAhdGhpcy5fcmV2ZXJzZSA6ICF0aGlzLl9yZXZlcnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb21wYXJhdG9yID0gc29ydEJ5O1xuICAgICAgdGhpcy5fcmV2ZXJzZSA9IHR5cGVvZiBmb3JjZVJldmVyc2UgIT09ICd1bmRlZmluZWQnID8gZm9yY2VSZXZlcnNlIDogZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgY3VycmVudCBzb3J0aW5nIG9yZGVyXG4gICAqL1xuICBwdWJsaWMgY2xlYXIoKSB7XG4gICAgdGhpcy5jb21wYXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gb2JqZWN0cyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgY29tcGFyYXRvclxuICAgKi9cbiAgcHVibGljIGNvbXBhcmUoYTogVCwgYjogVCk6IG51bWJlciB7XG4gICAgcmV0dXJuICh0aGlzLnJldmVyc2UgPyAtMSA6IDEpICogdGhpcy5jb21wYXJhdG9yLmNvbXBhcmUoYSwgYik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRW1iZWRkZWRWaWV3UmVmLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkZy13cmFwcGVkLWNvbHVtbicsXG4gIHRlbXBsYXRlOiBgICAgICAgICBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNjb2x1bW5Qb3J0YWw+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgV3JhcHBlZENvbHVtbiBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBBZnRlclZpZXdJbml0IHtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcblxuICBAVmlld0NoaWxkKCdjb2x1bW5Qb3J0YWwnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8dm9pZD47XG4gIGNvbHVtblZpZXc6IEVtYmVkZGVkVmlld1JlZjx2b2lkPjsgLy8gdGhlIGNvbHVtbnMgcHJvamVjdGVkIHZpZXcgKGluIG1lbW9yeSlcblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBjZWxscyB2aWV3IGluIG1lbW9yeSwgbm90IHRoZSBET00uXG4gICAgdGhpcy5jb2x1bW5WaWV3ID0gdGhpcy50ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcobnVsbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5cbmltcG9ydCB7IERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yIH0gZnJvbSAnLi9idWlsdC1pbi9jb21wYXJhdG9ycy9kYXRhZ3JpZC1wcm9wZXJ0eS1jb21wYXJhdG9yJztcbmltcG9ydCB7IERhdGFncmlkUHJvcGVydHlTdHJpbmdGaWx0ZXIgfSBmcm9tICcuL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtcHJvcGVydHktc3RyaW5nLWZpbHRlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGwgfSBmcm9tICcuL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtc3RyaW5nLWZpbHRlci1pbXBsJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcbmltcG9ydCB7IENsckRhdGFncmlkU29ydE9yZGVyIH0gZnJvbSAnLi9lbnVtcy9zb3J0LW9yZGVyLmVudW0nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbXBhcmF0b3IuaW50ZXJmYWNlJztcbmltcG9ydCB7IEN1c3RvbUZpbHRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2N1c3RvbS1maWx0ZXInO1xuaW1wb3J0IHsgRHJhZ0Rpc3BhdGNoZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9kcmFnLWRpc3BhdGNoZXInO1xuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZmlsdGVycyc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9wcm92aWRlcnMvc29ydCc7XG5pbXBvcnQgeyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhciB9IGZyb20gJy4vdXRpbHMvZGF0YWdyaWQtZmlsdGVyLXJlZ2lzdHJhcic7XG5pbXBvcnQgeyBXcmFwcGVkQ29sdW1uIH0gZnJvbSAnLi93cmFwcGVkLWNvbHVtbic7XG5cbmxldCBuYkNvdW50OiBudW1iZXIgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi1mbGV4XCI+XG4gICAgICAgICAgICA8IS0tIEknbSByZWFsbHkgbm90IGhhcHB5IHdpdGggdGhhdCBzZWxlY3Qgc2luY2UgaXQncyBub3QgdmVyeSBzY2FsYWJsZSAtLT5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1maWx0ZXIsIGNsci1kZy1zdHJpbmctZmlsdGVyXCI+PC9uZy1jb250ZW50PlxuXG4gICAgICAgICAgICA8Y2xyLWRnLXN0cmluZy1maWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJmaWVsZCAmJiAhY3VzdG9tRmlsdGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsckRnU3RyaW5nRmlsdGVyXT1cInJlZ2lzdGVyZWRcIlxuICAgICAgICAgICAgICAgICAgICBbKGNsckZpbHRlclZhbHVlKV09XCJmaWx0ZXJWYWx1ZVwiPjwvY2xyLWRnLXN0cmluZy1maWx0ZXI+XG5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjY29sdW1uVGl0bGU+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi10aXRsZVwiICpuZ0lmPVwic29ydGFibGVcIiAoY2xpY2spPVwic29ydCgpXCIgdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2x1bW5UaXRsZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZGF0YWdyaWQtY29sdW1uLXRpdGxlXCIgKm5nSWY9XCIhc29ydGFibGVcIj5cbiAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2x1bW5UaXRsZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtY29sdW1uLXNlcGFyYXRvclwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gI2NvbHVtbkhhbmRsZSBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi1oYW5kbGVcIiB0YWJpbmRleD1cIi0xXCIgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxkaXYgI2NvbHVtbkhhbmRsZVRyYWNrZXIgY2xhc3M9XCJkYXRhZ3JpZC1jb2x1bW4taGFuZGxlLXRyYWNrZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1jb2x1bW5dJzogJ3RydWUnLFxuICAgICdbY2xhc3MuZGF0YWdyaWQtY29sdW1uLS1oaWRkZW5dJzogJ2hpZGRlbicsXG4gICAgJ1thdHRyLmFyaWEtc29ydF0nOiAnYXJpYVNvcnQnLFxuICAgIHJvbGU6ICdjb2x1bW5oZWFkZXInLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZENvbHVtbjxUID0gYW55PiBleHRlbmRzIERhdGFncmlkRmlsdGVyUmVnaXN0cmFyPFQsIERhdGFncmlkU3RyaW5nRmlsdGVySW1wbDxUPj5cbiAgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3NvcnQ6IFNvcnQ8VD4sXG4gICAgZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LFxuICAgIHByaXZhdGUgX2RyYWdEaXNwYXRjaGVyOiBEcmFnRGlzcGF0Y2hlcixcbiAgICBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZlxuICApIHtcbiAgICBzdXBlcihmaWx0ZXJzKTtcbiAgICB0aGlzLl9zb3J0U3Vic2NyaXB0aW9uID0gX3NvcnQuY2hhbmdlLnN1YnNjcmliZShzb3J0ID0+IHtcbiAgICAgIC8vIFdlJ3JlIG9ubHkgbGlzdGVuaW5nIHRvIG1ha2Ugc3VyZSB3ZSBlbWl0IGFuIGV2ZW50IHdoZW4gdGhlIGNvbHVtbiBnb2VzIGZyb20gc29ydGVkIHRvIHVuc29ydGVkXG4gICAgICBpZiAodGhpcy5zb3J0T3JkZXIgIT09IENsckRhdGFncmlkU29ydE9yZGVyLlVOU09SVEVEICYmIHNvcnQuY29tcGFyYXRvciAhPT0gdGhpcy5fc29ydEJ5KSB7XG4gICAgICAgIHRoaXMuX3NvcnRPcmRlciA9IENsckRhdGFncmlkU29ydE9yZGVyLlVOU09SVEVEO1xuICAgICAgICB0aGlzLnNvcnRPcmRlckNoYW5nZS5lbWl0KHRoaXMuX3NvcnRPcmRlcik7XG4gICAgICB9XG4gICAgICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgICAgIGlmICh0aGlzLnNvcnRlZCAmJiBzb3J0LmNvbXBhcmF0b3IgIT09IHRoaXMuX3NvcnRCeSkge1xuICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zb3J0ZWRDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgICB9XG4gICAgICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gRU5EXG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbHVtbklkID0gJ2RnLWNvbC0nICsgbmJDb3VudC50b1N0cmluZygpOyAvLyBBcHByb3hpbWF0ZSBhIEdVSURcbiAgICBuYkNvdW50Kys7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNvbHVtbklkXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIENsckRhdGFncmlkQ29sdW1uIGNsYXNzIHZhcmlhYmxlIHRoYXQgaG9sZHMgdGhlIG51bWJlciBvZiBDbHJEYXRhZ3JpZENvbHVtbiBpbnN0YW5jZXMgZm9yIGEgRGF0YWdyaWQuXG4gICAqIEl0IGlzIHVzZWQgdG8gZ2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIHRoZSBDbHJEYXRhZ3JpZENvbHVtbiBpbnN0YW5jZS5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBjb2x1bW5JZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaGlkZGVuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHByb3BlcnR5IHRoYXQgYWxsb3dzIHRoZSBjb2x1bW4gdG8gYmUgaGlkZGVuIC8gc2hvd24gd2l0aCBjc3NcbiAgICogTm90ZSB0aGUgZGVmYXVsdCBhbGxvd3MgdGhlIENsckRhdGFncmlkQ29sdW1uIHRvIGhhdmUgYW4gKm5nSWYgb24gaXQuIChFSENBSVdDIC0gd2lsbCBvY2N1ciBpZiBpdHMgbm90XG4gICAqIGluaXRpYWxpemVkKVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBoaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5oaWRlYWJsZSAmJiB0aGlzLmhpZGVhYmxlLmhpZGRlbjtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ2NvbHVtbkhhbmRsZScpXG4gIHNldCBoYW5kbGVFbFJlZih2YWx1ZTogRWxlbWVudFJlZikge1xuICAgIHRoaXMuX2RyYWdEaXNwYXRjaGVyLmhhbmRsZVJlZiA9IHZhbHVlO1xuICB9XG5cbiAgQFZpZXdDaGlsZCgnY29sdW1uSGFuZGxlVHJhY2tlcicpXG4gIHNldCBoYW5kbGVUcmFja2VyRWxSZWYodmFsdWU6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLl9kcmFnRGlzcGF0Y2hlci5oYW5kbGVUcmFja2VyUmVmID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9uIHRvIHRoZSBzb3J0IHNlcnZpY2UgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfc29ydFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3NvcnRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qXG4gICAgICogU2ltcGxlIG9iamVjdCBwcm9wZXJ0eSBzaG9ydGN1dCwgYWN0aXZhdGVzIGJvdGggc29ydGluZyBhbmQgZmlsdGVyaW5nXG4gICAgICogYmFzZWQgb24gbmF0aXZlIGNvbXBhcmlzb24gb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBvbiB0aGUgaXRlbXMuXG4gICAgICovXG4gIHByaXZhdGUgX2ZpZWxkOiBzdHJpbmc7XG4gIHB1YmxpYyBnZXQgZmllbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpZWxkO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0ZpZWxkJylcbiAgcHVibGljIHNldCBmaWVsZChmaWVsZDogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2ZpZWxkID0gZmllbGQ7XG4gICAgICBpZiAoIXRoaXMuY3VzdG9tRmlsdGVyKSB7XG4gICAgICAgIHRoaXMuc2V0RmlsdGVyKG5ldyBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGwobmV3IERhdGFncmlkUHJvcGVydHlTdHJpbmdGaWx0ZXIoZmllbGQpKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX3NvcnRCeSkge1xuICAgICAgICB0aGlzLl9zb3J0QnkgPSBuZXcgRGF0YWdyaWRQcm9wZXJ0eUNvbXBhcmF0b3IoZmllbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgdG8gdXNlIHdoZW4gc29ydGluZyB0aGUgY29sdW1uXG4gICAqL1xuXG4gIHByaXZhdGUgX3NvcnRCeTogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+O1xuXG4gIHB1YmxpYyBnZXQgc29ydEJ5KCkge1xuICAgIHJldHVybiB0aGlzLl9zb3J0Qnk7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnU29ydEJ5JylcbiAgcHVibGljIHNldCBzb3J0QnkoY29tcGFyYXRvcjogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlPFQ+IHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fc29ydEJ5ID0gbmV3IERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yKGNvbXBhcmF0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICB0aGlzLl9zb3J0QnkgPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkKSB7XG4gICAgICAgICAgdGhpcy5fc29ydEJ5ID0gbmV3IERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yKHRoaXMuX2ZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc29ydEJ5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGlzIHNvcnRhYmxlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNvcnRhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuX3NvcnRCeTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWQ6IHRvIGJlIHJlbW92ZWQgLSBTVEFSVFxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHNvcnRlZFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBzb29uLCBpbiBmYXZvciBvZiB0aGUgc29ydE9yZGVyIG1lY2hhbmlzbVxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydGVkID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgc29ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3J0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgc29vbiwgaW4gZmF2b3Igb2YgdGhlIHNvcnRPcmRlciBtZWNoYW5pc21cbiAgICovXG4gIEBJbnB1dCgnY2xyRGdTb3J0ZWQnKVxuICBwdWJsaWMgc2V0IHNvcnRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICghdmFsdWUgJiYgdGhpcy5zb3J0ZWQpIHtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fc29ydC5jbGVhcigpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgIXRoaXMuc29ydGVkKSB7XG4gICAgICB0aGlzLnNvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgc29vbiwgaW4gZmF2b3Igb2YgdGhlIHNvcnRPcmRlciBtZWNoYW5pc21cbiAgICovXG4gIEBPdXRwdXQoJ2NsckRnU29ydGVkQ2hhbmdlJykgcHVibGljIHNvcnRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gRU5EXG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBob3cgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgc29ydGVkXG4gICAqL1xuICBwcml2YXRlIF9zb3J0T3JkZXI6IENsckRhdGFncmlkU29ydE9yZGVyID0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuVU5TT1JURUQ7XG4gIHB1YmxpYyBnZXQgc29ydE9yZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3J0T3JkZXI7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnU29ydE9yZGVyJylcbiAgcHVibGljIHNldCBzb3J0T3JkZXIodmFsdWU6IENsckRhdGFncmlkU29ydE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGlmIHRoZSBpbmNvbWluZyBvcmRlciBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBvbmVcbiAgICBpZiAodGhpcy5fc29ydE9yZGVyID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIC8vIHRoZSBVbnNvcnRlZCBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgY3VycmVudCBzdGF0ZSBpcyBlaXRoZXIgQXNjIG9yIERlc2NcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlIENsckRhdGFncmlkU29ydE9yZGVyLlVOU09SVEVEOlxuICAgICAgICB0aGlzLl9zb3J0LmNsZWFyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5BU0M6XG4gICAgICAgIHRoaXMuc29ydChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5ERVNDOlxuICAgICAgICB0aGlzLnNvcnQodHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgYXJpYVNvcnQoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9zb3J0T3JkZXIpIHtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlIENsckRhdGFncmlkU29ydE9yZGVyLlVOU09SVEVEOlxuICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5BU0M6XG4gICAgICAgIHJldHVybiAnYXNjZW5kaW5nJztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuREVTQzpcbiAgICAgICAgcmV0dXJuICdkZXNjZW5kaW5nJztcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ1NvcnRPcmRlckNoYW5nZScpIHB1YmxpYyBzb3J0T3JkZXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENsckRhdGFncmlkU29ydE9yZGVyPigpO1xuXG4gIC8qKlxuICAgKiBTb3J0cyB0aGUgZGF0YWdyaWQgYmFzZWQgb24gdGhpcyBjb2x1bW5cbiAgICovXG4gIHB1YmxpYyBzb3J0KHJldmVyc2U/OiBib29sZWFuKSB7XG4gICAgaWYgKCF0aGlzLnNvcnRhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc29ydC50b2dnbGUodGhpcy5fc29ydEJ5LCByZXZlcnNlKTtcblxuICAgIC8vIHNldHRpbmcgdGhlIHByaXZhdGUgdmFyaWFibGUgdG8gbm90IHJldHJpZ2dlciB0aGUgc2V0dGVyIGxvZ2ljXG4gICAgdGhpcy5fc29ydE9yZGVyID0gdGhpcy5fc29ydC5yZXZlcnNlID8gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuREVTQyA6IENsckRhdGFncmlkU29ydE9yZGVyLkFTQztcbiAgICB0aGlzLnNvcnRPcmRlckNoYW5nZS5lbWl0KHRoaXMuX3NvcnRPcmRlcik7XG5cbiAgICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMuc29ydGVkQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIEVORFxuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAqL1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmFzYycpXG4gIHB1YmxpYyBnZXQgYXNjKCkge1xuICAgIC8vIGRlcHJlY2F0ZWQ6IGlmIGNvbmRpdGlvbiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgICBpZiAodHlwZW9mIHRoaXMuc29ydE9yZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuc29ydGVkICYmICF0aGlzLl9zb3J0LnJldmVyc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRPcmRlciA9PT0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuQVNDO1xuICAgIH1cbiAgICAvLyBkZXByZWNhdGVkOiBpZiBjb25kaXRpb24gdG8gYmUgcmVtb3ZlZCAtIEVORFxuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBzb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kZXNjJylcbiAgcHVibGljIGdldCBkZXNjKCkge1xuICAgIC8vIGRlcHJlY2F0ZWQ6IGlmIGNvbmRpdGlvbiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgICBpZiAodHlwZW9mIHRoaXMuc29ydE9yZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRoaXMuc29ydGVkICYmIHRoaXMuX3NvcnQucmV2ZXJzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc29ydE9yZGVyID09PSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5ERVNDO1xuICAgIH1cbiAgICAvLyBkZXByZWNhdGVkOiBpZiBjb25kaXRpb24gdG8gYmUgcmVtb3ZlZCAtIEVORFxuICB9XG5cbiAgLyoqXG4gICAqIEEgY3VzdG9tIGZpbHRlciBmb3IgdGhpcyBjb2x1bW4gdGhhdCBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIHByb2plY3RlZCBjb250ZW50XG4gICAqL1xuICBwdWJsaWMgY3VzdG9tRmlsdGVyID0gZmFsc2U7XG5cbiAgQENvbnRlbnRDaGlsZChDdXN0b21GaWx0ZXIpXG4gIHB1YmxpYyBzZXQgcHJvamVjdGVkRmlsdGVyKGN1c3RvbTogYW55KSB7XG4gICAgaWYgKGN1c3RvbSkge1xuICAgICAgdGhpcy5kZWxldGVGaWx0ZXIoKTtcbiAgICAgIHRoaXMuY3VzdG9tRmlsdGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGZpbHRlclZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlci52YWx1ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRmlsdGVyVmFsdWUnKVxuICBwdWJsaWMgc2V0IHVwZGF0ZUZpbHRlclZhbHVlKG5ld1ZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmlsdGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbmV3VmFsdWUpIHtcbiAgICAgIG5ld1ZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5maWx0ZXIudmFsdWUpIHtcbiAgICAgIHRoaXMuZmlsdGVyLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHNldCBmaWx0ZXJWYWx1ZShuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy51cGRhdGVGaWx0ZXJWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMuZmlsdGVyVmFsdWVDaGFuZ2UuZW1pdCh0aGlzLmZpbHRlci52YWx1ZSk7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJGaWx0ZXJWYWx1ZUNoYW5nZScpIGZpbHRlclZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKioqKioqKioqKlxuICAgKlxuICAgKiBAcHJvcGVydHkgaGlkZWFibGVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFdoZW4gYSBjb2x1bW4gaXMgaGlkZWFibGUgdGhpcyBpcyBkZWZpbmVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsLlxuICAgKiBXaGVuIGl0cyBub3QgaGlkZWFibGUgc2hvdWxkIGJlIHVuZGVmaW5lZC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBoaWRlYWJsZTogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsO1xuXG4gIHByaXZhdGUgd3JhcHBlZEluamVjdG9yOiBJbmplY3RvcjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLndyYXBwZWRJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcihXcmFwcGVkQ29sdW1uLCB0aGlzLnZjcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0IF92aWV3KCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZWRJbmplY3Rvci5nZXQoV3JhcHBlZENvbHVtbiwgdGhpcy52Y3IpLmNvbHVtblZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFRyYWNrQnlGdW5jdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciB9IGZyb20gJy4vZmlsdGVycyc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wYWdlJztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL3NvcnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSXRlbXM8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9maWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4sIHByaXZhdGUgX3NvcnQ6IFNvcnQ8VD4sIHByaXZhdGUgX3BhZ2U6IFBhZ2UpIHt9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZGF0YSBpcyBjdXJyZW50bHkgbG9hZGluZ1xuICAgKi9cbiAgcHVibGljIGxvYWRpbmcgPSBmYWxzZTtcblxuICAvLyBUT0RPOiBWZXJpZnkgdGhhdCB0cmFja0J5IGlzIHJlZ2lzdGVyZWQgZm9yIHRoZSAqbmdGb3IgY2FzZSB0b29cbiAgLyoqXG4gICAqIFRyYWNraW5nIGZ1bmN0aW9uIHRvIGlkZW50aWZ5IG9iamVjdHMuIERlZmF1bHQgaXMgcmVmZXJlbmNlIGVxdWFsaXR5LlxuICAgKi9cbiAgcHVibGljIHRyYWNrQnk6IFRyYWNrQnlGdW5jdGlvbjxUPiA9IChpbmRleDogbnVtYmVyLCBpdGVtOiBUKSA9PiBpdGVtO1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpcHRpb25zIHRvIHRoZSBvdGhlciBwcm92aWRlcnMgY2hhbmdlcy5cbiAgICovXG4gIHByaXZhdGUgX2ZpbHRlcnNTdWI6IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfc29ydFN1YjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIF9wYWdlU3ViOiBTdWJzY3JpcHRpb247XG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgb3VyIHN1YnNjcmlwdGlvbnMgdG8gb3RoZXIgcHJvdmlkZXJzXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyc1N1Yikge1xuICAgICAgdGhpcy5fZmlsdGVyc1N1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc29ydFN1Yikge1xuICAgICAgdGhpcy5fc29ydFN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFnZVN1Yikge1xuICAgICAgdGhpcy5fcGFnZVN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHNob3VsZCB1c2Ugc21hcnQgaXRlbXMgZm9yIHRoaXMgZGF0YWdyaWQgb3IgbGV0IHRoZSB1c2VyIGhhbmRsZVxuICAgKiBldmVyeXRoaW5nLlxuICAgKi9cbiAgcHJpdmF0ZSBfc21hcnQgPSBmYWxzZTtcbiAgcHVibGljIGdldCBzbWFydCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc21hcnQ7XG4gIH1cbiAgcHVibGljIHNtYXJ0ZW5VcCgpIHtcbiAgICB0aGlzLl9zbWFydCA9IHRydWU7XG4gICAgLypcbiAgICAgICAgICogVGhlc2Ugb2JzZXJ2ZXJzIHRyaWdnZXIgYSBjaGFpbiBvZiBmdW5jdGlvbjogZmlsdGVyIC0+IHNvcnQgLT4gcGFnaW5hdGVcbiAgICAgICAgICogQW4gb2JzZXJ2ZXIgdXAgdGhlIGNoYWluIHJlLXRyaWdnZXJzIGFsbCB0aGUgb3BlcmF0aW9ucyB0aGF0IGZvbGxvdyBpdC5cbiAgICAgICAgICovXG4gICAgdGhpcy5fZmlsdGVyc1N1YiA9IHRoaXMuX2ZpbHRlcnMuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9maWx0ZXJJdGVtcygpKTtcbiAgICB0aGlzLl9zb3J0U3ViID0gdGhpcy5fc29ydC5jaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSwgaWYgdGhlIGRhdGFncmlkIHdlbnQgZnJvbSBzb3J0ZWQgdG8gdW5zb3J0ZWQsIHdlIGhhdmUgdG8gcmUtZmlsdGVyXG4gICAgICAvLyB0byBnZXQgdGhlIG9yaWdpbmFsIG9yZGVyIGJhY2tcbiAgICAgIGlmICghdGhpcy5fc29ydC5jb21wYXJhdG9yKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlckl0ZW1zKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9wYWdlU3ViID0gdGhpcy5fcGFnZS5jaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2NoYW5nZVBhZ2UoKSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBvZiBhbGwgaXRlbXMgaW4gdGhlIGRhdGFncmlkXG4gICAqL1xuICBwcml2YXRlIF9hbGw6IFRbXTtcbiAgcHVibGljIGdldCBhbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbDtcbiAgfVxuICBwdWJsaWMgc2V0IGFsbChpdGVtczogVFtdKSB7XG4gICAgdGhpcy5fYWxsID0gaXRlbXM7XG4gICAgdGhpcy5lbWl0QWxsQ2hhbmdlcyhpdGVtcyk7XG4gICAgaWYgKHRoaXMuc21hcnQpIHtcbiAgICAgIHRoaXMuX2ZpbHRlckl0ZW1zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Rpc3BsYXllZCA9IGl0ZW1zO1xuICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IHJlY29tcHV0ZSB0aGUgbGlzdCBvZiBkaXNwbGF5ZWQgaXRlbXNcbiAgICovXG4gIHB1YmxpYyByZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLnNtYXJ0KSB7XG4gICAgICB0aGlzLl9maWx0ZXJJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCB0ZW1wb3Jhcnkgc3RlcCwgd2hpY2ggd2UgcHJlc2VydmUgdG8gYXZvaWQgcmUtZmlsdGVyaW5nIG9yIHJlLXNvcnRpbmcgaWYgbm90IG5lY2Vzc2FyeVxuICAgKi9cbiAgcHJpdmF0ZSBfZmlsdGVyZWQ6IFRbXTtcblxuICAvKipcbiAgICogTGlzdCBvZiBpdGVtcyBjdXJyZW50bHkgZGlzcGxheWVkXG4gICAqL1xuICBwcml2YXRlIF9kaXNwbGF5ZWQ6IFRbXSA9IFtdO1xuICBwdWJsaWMgZ2V0IGRpc3BsYXllZCgpOiBUW10ge1xuICAgIC8vIElkZWFsbHkgd2UgY291bGQgcmV0dXJuIGFuIGltbXV0YWJsZSBhcnJheSwgYnV0IHdlIGRvbid0IGhhdmUgaXQgaW4gQ2xhcml0eSB5ZXQuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXllZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gaXRlbXMgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8VFtdPigpO1xuICBwcml2YXRlIGVtaXRDaGFuZ2UoKSB7XG4gICAgdGhpcy5fY2hhbmdlLm5leHQodGhpcy5kaXNwbGF5ZWQpO1xuICB9XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfYWxsQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PFRbXT4oKTtcbiAgcHJpdmF0ZSBlbWl0QWxsQ2hhbmdlcyhpdGVtczogVFtdKTogdm9pZCB7XG4gICAgdGhpcy5fYWxsQ2hhbmdlcy5uZXh0KGl0ZW1zKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYWxsQ2hhbmdlcygpOiBPYnNlcnZhYmxlPFRbXT4ge1xuICAgIHJldHVybiB0aGlzLl9hbGxDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB3ZSBkb24ndCBoYXZlIGRhdGEgdG8gcHJvY2VzcyB5ZXQsIHRvIGFib3J0IGVhcmx5IG9wZXJhdGlvbnNcbiAgICovXG4gIHByaXZhdGUgZ2V0IHVuaW5pdGlhbGl6ZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLl9hbGw7XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVyc1Byb3ZpZGVyIGl0ZW1zIGZyb20gdGhlIHJhdyBsaXN0XG4gICAqL1xuICBwcml2YXRlIF9maWx0ZXJJdGVtcygpIHtcbiAgICBpZiAodGhpcy51bmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9maWx0ZXJzLmhhc0FjdGl2ZUZpbHRlcnMoKSkge1xuICAgICAgdGhpcy5fZmlsdGVyZWQgPSB0aGlzLl9hbGwuZmlsdGVyKGl0ZW0gPT4gdGhpcy5fZmlsdGVycy5hY2NlcHRzKGl0ZW0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV29yayBvbiBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJyYXksIHRvIG5vdCBtb2RpZnkgdGhlIHVzZXIncyBtb2RlbFxuICAgICAgdGhpcy5fZmlsdGVyZWQgPSB0aGlzLl9hbGwuc2xpY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZS50b3RhbEl0ZW1zID0gdGhpcy5fZmlsdGVyZWQubGVuZ3RoO1xuICAgIHRoaXMuX3NvcnRJdGVtcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvcnRzIGl0ZW1zIGluIHRoZSBmaWx0ZXJlZCBsaXN0XG4gICAqL1xuICBwcml2YXRlIF9zb3J0SXRlbXMoKSB7XG4gICAgaWYgKHRoaXMudW5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc29ydC5jb21wYXJhdG9yKSB7XG4gICAgICB0aGlzLl9maWx0ZXJlZC5zb3J0KChhLCBiKSA9PiB0aGlzLl9zb3J0LmNvbXBhcmUoYSwgYikpO1xuICAgIH1cbiAgICB0aGlzLl9jaGFuZ2VQYWdlKCk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBzb3J0ZWQgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlUGFnZSgpIHtcbiAgICBpZiAodGhpcy51bmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9wYWdlLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWQgPSB0aGlzLl9maWx0ZXJlZC5zbGljZSh0aGlzLl9wYWdlLmZpcnN0SXRlbSwgdGhpcy5fcGFnZS5sYXN0SXRlbSArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWQgPSB0aGlzLl9maWx0ZXJlZDtcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IE5nRm9yT2YsIE5nRm9yT2ZDb250ZXh0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRG9DaGVjayxcbiAgSW5wdXQsXG4gIEl0ZXJhYmxlRGlmZmVyLFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIFRlbXBsYXRlUmVmLFxuICBUcmFja0J5RnVuY3Rpb24sXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIE9uRGVzdHJveSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEl0ZW1zIH0gZnJvbSAnLi9wcm92aWRlcnMvaXRlbXMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJEZ0l0ZW1zXVtjbHJEZ0l0ZW1zT2ZdJyxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRJdGVtczxUPiBpbXBsZW1lbnRzIERvQ2hlY2ssIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgaXRlcmFibGVQcm94eTogTmdGb3JPZjxUPjtcbiAgcHJpdmF0ZSBfcmF3SXRlbXM6IFRbXTtcbiAgcHJpdmF0ZSBkaWZmZXI6IEl0ZXJhYmxlRGlmZmVyPFQ+IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBASW5wdXQoJ2NsckRnSXRlbXNPZicpXG4gIHB1YmxpYyBzZXQgcmF3SXRlbXMoaXRlbXM6IFRbXSkge1xuICAgIHRoaXMuX3Jhd0l0ZW1zID0gaXRlbXMgPyBpdGVtcyA6IFtdOyAvLyBsb2NhbCBjb3B5IGZvciBuZ09uQ2hhbmdlIGRpZmZpbmdcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdJdGVtc1RyYWNrQnknKVxuICBzZXQgdHJhY2tCeSh2YWx1ZTogVHJhY2tCeUZ1bmN0aW9uPFQ+KSB7XG4gICAgdGhpcy5pdGVyYWJsZVByb3h5Lm5nRm9yVHJhY2tCeSA9IHZhbHVlO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxOZ0Zvck9mQ29udGV4dDxUPj4sXG4gICAgcHJpdmF0ZSBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgcHJpdmF0ZSBpdGVtczogSXRlbXMsXG4gICAgcHJpdmF0ZSB2Y3I6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7XG4gICAgaXRlbXMuc21hcnRlblVwKCk7XG4gICAgdGhpcy5pdGVyYWJsZVByb3h5ID0gbmV3IE5nRm9yT2Y8VD4odGhpcy52Y3IsIHRoaXMudGVtcGxhdGUsIHRoaXMuZGlmZmVycyk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBpdGVtcy5jaGFuZ2Uuc3Vic2NyaWJlKG5ld0l0ZW1zID0+IHtcbiAgICAgICAgdGhpcy5pdGVyYWJsZVByb3h5Lm5nRm9yT2YgPSBuZXdJdGVtcztcbiAgICAgICAgdGhpcy5pdGVyYWJsZVByb3h5Lm5nRG9DaGVjaygpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdEb0NoZWNrKCkge1xuICAgIGlmICghdGhpcy5kaWZmZXIpIHtcbiAgICAgIHRoaXMuZGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQodGhpcy5fcmF3SXRlbXMpLmNyZWF0ZSh0aGlzLml0ZXJhYmxlUHJveHkubmdGb3JUcmFja0J5KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlmZmVyKSB7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kaWZmZXIuZGlmZih0aGlzLl9yYXdJdGVtcyk7XG4gICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAvLyBUT0RPOiBub3QgdmVyeSBlZmZpY2llbnQgcmlnaHQgbm93LFxuICAgICAgICAvLyBidXQgcHJlbWF0dXJlIG9wdGltaXphdGlvbiBpcyB0aGUgcm9vdCBvZiBhbGwgZXZpbC5cbiAgICAgICAgdGhpcy5pdGVtcy5hbGwgPSB0aGlzLl9yYXdJdGVtcztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEl0ZW1zIH0gZnJvbSAnLi9wcm92aWRlcnMvaXRlbXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcGxhY2Vob2xkZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzcz1cImRhdGFncmlkLXBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFtjbGFzcy5kYXRhZ3JpZC1lbXB0eV09XCJlbXB0eURhdGFncmlkXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLXBsYWNlaG9sZGVyLWltYWdlXCIgKm5nSWY9XCJlbXB0eURhdGFncmlkXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgKm5nSWY9XCJlbXB0eURhdGFncmlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuZGF0YWdyaWQtcGxhY2Vob2xkZXItY29udGFpbmVyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyPFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpdGVtczogSXRlbXM8VD4pIHt9XG5cbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoZSBkYXRhZ3JpZCBpcyBlbXB0eSwgbWVhbmluZyBpdCBkb2Vzbid0IGNvbnRhaW4gYW55IGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgZ2V0IGVtcHR5RGF0YWdyaWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLml0ZW1zLmxvYWRpbmcgJiYgKCF0aGlzLml0ZW1zLmRpc3BsYXllZCB8fCB0aGlzLml0ZW1zLmRpc3BsYXllZC5sZW5ndGggPT09IDApO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBjb25zdCBQT1BPVkVSX0hPU1RfQU5DSE9SID0gbmV3IEluamVjdGlvblRva2VuPEVsZW1lbnRSZWY+KCdQT1BPVkVSX0hPU1RfQU5DSE9SJyk7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgT25EZXN0cm95LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclNpZ25wb3N0VHJpZ2dlcl0nLCBob3N0OiB7IGNsYXNzOiAnc2lnbnBvc3QtdHJpZ2dlcicgfSB9KVxuXG4vKioqKioqKioqXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIERpcmVjdGl2ZSBhZGRlZCB0byB0aGUgQ2xyU2lnbnBvc3QgVHJpZ2dlciBidXR0b24gdGhhdCB3aWxsIGNhbGwgdGhlIENsclNpZ25wb3N0LnRvZ2dsZSgpIGZ1bmN0aW9uIHRvIGhpZGUvc2hvdyB0aGVcbiAqIENsclNpZ25wb3N0Q29udGVudC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJTaWducG9zdFRyaWdnZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZSgoaXNPcGVuOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2FjdGl2ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIGNsaWNrIGhhbmRsZXIgZm9yIHRoZSBDbHJTaWducG9zdCB0cmlnZ2VyIGJ1dHRvbiB1c2VkIHRvIGhpZGUvc2hvdyBDbHJTaWducG9zdENvbnRlbnQuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gIG9uU2lnbnBvc3RUcmlnZ2VyQ2xpY2soZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLnRvZ2dsZVdpdGhFdmVudChldmVudCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuaW1wb3J0IHsgUE9QT1ZFUl9IT1NUX0FOQ0hPUiB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuJztcblxuaW1wb3J0IHsgQ2xyU2lnbnBvc3RUcmlnZ2VyIH0gZnJvbSAnLi9zaWducG9zdC10cmlnZ2VyJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zaWducG9zdCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhdXNlQ3VzdG9tVHJpZ2dlclwiPlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwic2lnbnBvc3QtYWN0aW9uIGJ0biBidG4tc21hbGwgYnRuLWxpbmtcIlxuICAgICAgICAgICAgICAgIGNsclNpZ25wb3N0VHJpZ2dlcj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJpbmZvXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5pbmZvXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3Muc2lnbnBvc3RdJzogJ3RydWUnIH0sXG4gIHByb3ZpZGVyczogW0lmT3BlblNlcnZpY2UsIHsgcHJvdmlkZTogUE9QT1ZFUl9IT1NUX0FOQ0hPUiwgdXNlRXhpc3Rpbmc6IEVsZW1lbnRSZWYgfV0sXG59KVxuXG4vKioqKioqKioqXG4gKlxuICogQGNsYXNzIENsclNpZ25wb3N0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDbGFzcyB1c2VkIHRvIGNvbmZpZ3VyZSBhbmQgY29udHJvbCB0aGUgc3RhdGUgb2YgYSBDbHJTaWducG9zdCBhbmQgaXRzIGFzc29jaWF0ZWQgQ2xyU2lnbnBvc3RDb250ZW50LlxuICogSXQgc3VwcG9ydHMgdGhlIGNsclBvc2l0aW9uIHdpdGggYSAncmlnaHQtbWlkZGxlJyBkZWZhdWx0LlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENsclNpZ25wb3N0IHtcbiAgY29uc3RydWN0b3IocHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MpIHt9XG5cbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IHVzZUN1c3RvbVRyaWdnZXJcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEZsYWcgdXNlZCB0byBkZXRlcm1pbmUgaWYgd2UgbmVlZCB0byB1c2UgdGhlIGRlZmF1bHQgdHJpZ2dlciBvciBhIHVzZXIgc3VwcGxpZWQgdHJpZ2dlciBlbGVtZW50LlxuICAgKlxuICAgKi9cbiAgcHVibGljIHVzZUN1c3RvbVRyaWdnZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKioqKioqKioqKlxuICAgKiBAcHJvcGVydHkgc2lnblBvc3RUcmlnZ2VyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVc2VzIENvbnRlbnRDaGlsZCB0byBjaGVjayBmb3IgYSB1c2VyIHN1cHBsaWVkIGVsZW1lbnQgd2l0aCB0aGUgQ2xyU2lnbnBvc3RUcmlnZ2VyIG9uIGl0LlxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJTaWducG9zdFRyaWdnZXIpXG4gIHNldCBjdXN0b21UcmlnZ2VyKHRyaWdnZXI6IENsclNpZ25wb3N0VHJpZ2dlcikge1xuICAgIHRoaXMudXNlQ3VzdG9tVHJpZ2dlciA9ICEhdHJpZ2dlcjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBASW5qZWN0YWJsZSBwcm92aWRlciBjbGFzcyB0aGF0IGVuYWJsZXNcbiAqXG4gKiAxLiBNYW5hZ2luZywgdHJhY2sgaGlkZWFiaWxpdHkgb2YgRGF0YWdyaWRDb2x1bW5zXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIHtcbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IGRnSGlkZGVuQ29sdW1uTWFwXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBhcnJheSBvZiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uLlxuICAgKiBOT1RFOiBiZWNhdXNlIHdlIGNhbiBoYXZlIGNvbHVtbnMgdy9vIHRoZSAqY2xyRGdIaWRlYWJsZUNvbHVtbiBkaXJlY3RpdmVcbiAgICogdGhpcyBhcnJheSB3aWxsIGhhdmUgZW1wdHkgc3BhY2VzIGEuay5hIG51bGxzLiBUaGlzIGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIG1hcFxuICAgKiBEYXRhZ3JpZENlbGxzIHRvIERhdGFncmlkQ29sdW1ucyBpbiB0aGUgUm93UmVuZGVyZXIuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9jb2x1bW5MaXN0OiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSA9IFtdO1xuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBkZ0hpZGRlbkNvbHVtbk1hcENoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBiZWhhdmlvciBzdWJqZWN0IHRoYXQgY2FuIGJyb2FkY2FzdCB1cGRhdGVzIHRvIHRoZSBjb2x1bW4gbGlzdC5cbiAgICogTk9URTogSSBhbSB1c2luZyBCZWhhdmlvclN1YmplY3QgYmVjYXVzZSA8Y2xyLWRnLWNvbHVtbi10b2dnbGU+IGlzIG5vdCBnZXR0aW5nIHRoZSBsYXRlc3QgX2NvbHVtbkxpc3RDaGFuZ2VcbiAgICogb24gcGFnZSBsb2FkLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfY29sdW1uTGlzdENoYW5nZTogQmVoYXZpb3JTdWJqZWN0PERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8XG4gICAgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW11cbiAgPih0aGlzLl9jb2x1bW5MaXN0KTtcblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAcHJvcGVydHkgY2FuSGlkZU5leHRDb2x1bW5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNlcnZpY2UgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgYnkgY2xyLWRnLWNvbHVtbi10b2dnbGUgY29tcG9uZW50LiBVc2UgdGhpcyBpZiB5b3UgbmVlZCB0byBhc2sgaWYgeW91IGNhbiBoaWRlXG4gICAqIGEgY29sdW1uLiBJdCBhY3RzIGFzIGEgZ3VhcmQgYWdhaW5zdCBoaWRpbmcgYWxsIHRoZSBjb2x1bW5zIG1ha2luZyBzdXJlIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjb2x1bW4gZGlzcGxheWVkLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjYW5IaWRlTmV4dENvbHVtbigpOiBib29sZWFuIHtcbiAgICBjb25zdCBoaWRkZW5Db2x1bW5zID0gdGhpcy5fY29sdW1uTGlzdC5maWx0ZXIoY29sdW1uID0+IGNvbHVtbiAhPT0gdW5kZWZpbmVkKS5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5oaWRkZW4pO1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5MaXN0Lmxlbmd0aCAtIGhpZGRlbkNvbHVtbnMubGVuZ3RoID4gMTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBwcm9wZXJ0eSBjaGVja0ZvckFsbENvbHVtbnNWaXNpYmxlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGb3Igd2hlbiB5b3UgbmVlZCB0byBrbm93IGlmIHRoZSBkYXRhZ3JpZCdzIGNvbHVtbnMgYXJlIGFsbCBzaG93aW5nLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjaGVja0ZvckFsbENvbHVtbnNWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5fY29sdW1uTGlzdC5zb21lKGNvbHVtbiA9PiBjb2x1bW4gJiYgY29sdW1uLmhpZGRlbik7XG4gIH1cblxuICAvKioqKioqKioqKipcbiAgICogQHByb3BlcnR5IGNvbHVtbkxpc3RDaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgcHVibGljIHByb3BlcnR5IHRoYXQgZW5hYmxlcyBzdWJzY3JpYmVycyB0byBoZWFyIHVwZGF0ZXMgdG8gdGhlIGNvbHVtbiBtYXAuXG4gICAqIFVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIGRvIHNvbWV0aGluZyB3aGVuZXZlciB0aGUgRGF0YWdyaWQncyBjb2x1bW4gbGlzdCBpcyBjaGFuZ2VkIChpLmUgKm5nSWYgb24gYSBjb2x1bW4pLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjb2x1bW5MaXN0Q2hhbmdlKCk6IE9ic2VydmFibGU8RGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10+IHtcbiAgICByZXR1cm4gdGhpcy5fY29sdW1uTGlzdENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGxpc3Qgb2YgY29sdW1ucy4gSSBuZWVkZWQgYW4gYXJyYXkgb2YgdG8gaXRlcmF0ZSBvbiBpbiB0aGUgUm93UmVuZGVyZXJcbiAgICogYnV0IHN1YnNjcmliaW5nIHRvIHRoZSBfY29sdW1uTGlzdENoYW5nZSBjaGFuZ2VzIGRpZCBub3Qgc2VlbSBsaWtlIHRoZSBjb3JyZWN0IHdheSB0byBnZXQgaXQuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29sdW1ucygpOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkxpc3Q7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjdXJyZW50IF9jb2x1bW5MaXN0OlxuICAgKiAtIGlmIGl0IGhhcyBhIERhdGFncmlkSGlkZWFibGVDb2x1bW4gYW5kIGlzIGhpZGRlbiB0aGVuIHNob3cgaXQuXG4gICAqIC0gaWYgaXQncyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIHdhcyBwcmV2aW91c2x5IHRoZSBsYXN0IGNvbHVtbiB2aXNpYmxlLCB0dXJuIHRoYXQgZmxhZyBvZmYuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgc2hvd0hpZGRlbkNvbHVtbnMoKSB7XG4gICAgdGhpcy5fY29sdW1uTGlzdC5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5oaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgY29sdW1uLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbikge1xuICAgICAgICBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gY29sdW1uczogRGF0YWdyaWRDb2x1bW5bXVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uJ3MgfHwgbnVsbCBiYXNlZCBjb2x1bW4gYXJyYXkgcGFzc2VkIGFzIHBhcmFtLlxuICAgKiBJcyBkZXBlbmRlbnQgb24gdGhlIG9yZGVyIGluIEBDb250ZW50Q2hpbGRyZW4gaW4gRGF0YWdyaWQuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29sdW1uTGlzdChjb2x1bW5zOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSkge1xuICAgIHRoaXMuX2NvbHVtbkxpc3QgPSBjb2x1bW5zOyAvLyBjbGVhciB0aGUgbGlzdFxuICAgIHRoaXMudXBkYXRlRm9yTGFzdFZpc2libGVDb2x1bW4oKTsgLy8gVXBkYXRlIG91ciB2aXNpYmlsaXR5IHN0YXRlIGZvciBVSVxuICAgIHRoaXMuX2NvbHVtbkxpc3RDaGFuZ2UubmV4dCh0aGlzLl9jb2x1bW5MaXN0KTsgLy8gQnJvYWRjYXN0IGl0XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2V0cyB0aGUgY3VycmVudCB2aXNpYmxlIGNvdW50IGZvciBhbGwgY29sdW1ucy5cbiAgICogV2hlbiBpdCBpcyBncmVhdGVyIHRoYW4gMSBpdCBtYXJrcyBldmVyeXRoaW5nIGFzIGZhbHNlIGZvciB0aGUgbGFzdFZpc2libGVDb2x1bW4uXG4gICAqIFdoZW4gdmlzaWJsZSBjb3VudCBpcyBub3QgPiAxIChpLmUpIDEuICwgaXQgZmluZHMgdGhlIG9ubHkgY29sdW1uIHRoYXQgaXMgbm90IGhpZGRlbiBhbmQgbWFya3MgaXQgYXMgdGhlXG4gICAqIGxhc3RWaXNpYmxlQ29sdW1uLlxuICAgKlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUZvckxhc3RWaXNpYmxlQ29sdW1uKCk6IHZvaWQge1xuICAgIC8vIFRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgY29sdW1uIHNob3dpbmcsIG1ha2Ugc3VyZSBub3RoaW5nIGlzIG1hcmtlZCBsYXN0VmlzaWJsZUNvbHVtblxuICAgIGlmICh0aGlzLmNhbkhpZGVOZXh0Q29sdW1uKSB7XG4gICAgICB0aGlzLl9jb2x1bW5MaXN0Lm1hcChjb2x1bW4gPT4ge1xuICAgICAgICBpZiAoY29sdW1uICYmIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbikge1xuICAgICAgICAgIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHZpc2libGVDb3VudCBpcyBkb3duIHRvIG9ubHkgb25lIGNvbHVtbiBzaG93aW5nLiBGaW5kIGl0IGFuZCBmbGFnIGl0IGFzIHRoZSBsYXN0VmlzaWJsZUNvbHVtblxuICAgICAgdGhpcy5fY29sdW1uTGlzdC5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbiAmJiAhY29sdW1uLmhpZGRlbikge1xuICAgICAgICAgIGNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm4gYSBIaWRlYWJsZUNvbHVtbiBpbiB0aGlzLl9jb2x1bW5MaXN0IGZvciB0aGUgZ2l2ZW4gaWQuXG4gICAqXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29sdW1uQnlJZChpZDogc3RyaW5nKTogdW5kZWZpbmVkIHwgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5MaXN0LmZpbmQoY29sdW1uID0+IGNvbHVtbiAmJiBjb2x1bW4uaWQgPT09IGlkKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVtYmVkZGVkVmlld1JlZiwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGctd3JhcHBlZC1jZWxsJyxcbiAgdGVtcGxhdGU6IGAgICAgICAgIFxuICAgICAgICA8bmctdGVtcGxhdGUgI2NlbGxQb3J0YWw+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgV3JhcHBlZENlbGwgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgQWZ0ZXJWaWV3SW5pdCB7XG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBWaWV3Q2hpbGQoJ2NlbGxQb3J0YWwnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8dm9pZD47XG4gIGNlbGxWaWV3OiBFbWJlZGRlZFZpZXdSZWY8dm9pZD47IC8vIHRoZSBjZWxscyBwcm9qZWN0ZWQgdmlld1xuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLmNlbGxWaWV3ID0gdGhpcy50ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcobnVsbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJTaWducG9zdCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvc2lnbnBvc3Qvc2lnbnBvc3QnO1xuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5cbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFdyYXBwZWRDZWxsIH0gZnJvbSAnLi93cmFwcGVkLWNlbGwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctY2VsbCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1jZWxsXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLXNpZ25wb3N0LXRyaWdnZXJdJzogJ3NpZ25wb3N0Lmxlbmd0aCA+IDAnLFxuICAgIHJvbGU6ICdjZWxsJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDZWxsIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAvKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBzaWducG9zdFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQENvbnRlbnRDaGlsZCBpcyB1c2VkIHRvIGRldGVjdCB0aGUgcHJlc2VuY2Ugb2YgYSBTaWducG9zdCBpbiB0aGUgcHJvamVjdGVkIGNvbnRlbnQuXG4gICAqIE9uIHRoZSBob3N0LCB3ZSBzZXQgdGhlIC5kYXRhZ3JpZC1zaWducG9zdC10cmlnZ2VyIGNsYXNzIG9uIHRoZSBjZWxsIHdoZW4gc2lnbnBvc3QubGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJTaWducG9zdCkgc2lnbnBvc3Q6IFF1ZXJ5TGlzdDxDbHJTaWducG9zdD47XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpZFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQW4gaWRlbnRpZmllciBmb3IgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjZWxsIHRoYXQgbWFwcyBpdCB0byBhIHNwZWNpZmljIGNvbHVtblxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfaWQ6IHN0cmluZztcblxuICBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgdGhpcy5tYXBIaWRlYWJsZUNvbHVtbih0aGlzLl9pZCk7XG4gIH1cblxuICBwcml2YXRlIGhpZGRlblN0YXRlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGhpZGVhYmxlQ29sdW1uU2VydmljZTogSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2VsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSB2Y3I6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7fVxuXG4gIHByaXZhdGUgbWFwSGlkZWFibGVDb2x1bW4oY29sdW1uSWQ6IHN0cmluZykge1xuICAgIGlmICghY29sdW1uSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoaWRlYWJsZUNvbHVtbiA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbkJ5SWQodGhpcy5faWQpO1xuXG4gICAgdGhpcy5zZXRIaWRkZW5DbGFzcyhoaWRlYWJsZUNvbHVtbi5oaWRkZW4pO1xuICAgIHRoaXMuaGlkZGVuU3RhdGVTdWJzY3JpcHRpb24gPSBoaWRlYWJsZUNvbHVtbi5oaWRkZW5DaGFuZ2VTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRIaWRkZW5DbGFzcyhoaWRlYWJsZUNvbHVtbi5oaWRkZW4pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRIaWRkZW5DbGFzcyhoaWRlYWJsZUNvbHVtblZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKGhpZGVhYmxlQ29sdW1uVmFsdWUpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1jZWxsLS1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWwubmF0aXZlRWxlbWVudCwgJ2RhdGFncmlkLWNlbGwtLWhpZGRlbicpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgd3JhcHBlZEluamVjdG9yOiBJbmplY3RvcjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLndyYXBwZWRJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcihXcmFwcGVkQ2VsbCwgdGhpcy52Y3IpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaGlkZGVuU3RhdGVTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuaGlkZGVuU3RhdGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IF92aWV3KCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZWRJbmplY3Rvci5nZXQoV3JhcHBlZENlbGwsIHRoaXMudmNyKS5jZWxsVmlldztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgZW51bSBEYXRhZ3JpZERpc3BsYXlNb2RlIHtcbiAgRElTUExBWSxcbiAgQ0FMQ1VMQVRFLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgZW51bSBEYXRhZ3JpZFJlbmRlclN0ZXAge1xuICBBTElHTl9DT0xVTU5TLFxuICBDQUxDVUxBVEVfTU9ERV9PTixcbiAgQ0FMQ1VMQVRFX01PREVfT0ZGLFxuICBDTEVBUl9XSURUSFMsIC8vIE5vdGUgdGhpcyBpcyBsaXN0ZW5lZCB0byBieSBib3RoIGNlbGxzIGFuZCBjb2x1bW5zXG4gIENPTVBVVEVfQ09MVU1OX1dJRFRIUyxcbiAgREVURUNUX1NUUklDVF9XSURUSFMsXG4gIFVQREFURV9ST1dfV0lEVEgsXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB7XG4gIHByb3RlY3RlZCBfcmVuZGVyU3RlcDogU3ViamVjdDxEYXRhZ3JpZFJlbmRlclN0ZXA+ID0gbmV3IFN1YmplY3Q8RGF0YWdyaWRSZW5kZXJTdGVwPigpO1xuICBwdWJsaWMgZ2V0IHJlbmRlclN0ZXAoKTogT2JzZXJ2YWJsZTxEYXRhZ3JpZFJlbmRlclN0ZXA+IHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyU3RlcC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBmaWx0ZXJSZW5kZXJTdGVwcyhzdGVwOiBEYXRhZ3JpZFJlbmRlclN0ZXApIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJTdGVwLnBpcGUoZmlsdGVyKHRlc3RTdGVwID0+IHN0ZXAgPT09IHRlc3RTdGVwKSk7XG4gIH1cblxuICBwcml2YXRlIGFscmVhZHlTaXplZCA9IGZhbHNlO1xuXG4gIHB1YmxpYyB3aWR0aHM6IHsgcHg6IG51bWJlcjsgc3RyaWN0OiBib29sZWFuIH1bXSA9IFtdO1xuXG4gIHB1YmxpYyByZXNpemUoKSB7XG4gICAgdGhpcy53aWR0aHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkNBTENVTEFURV9NT0RFX09OKTtcbiAgICBpZiAodGhpcy5hbHJlYWR5U2l6ZWQpIHtcbiAgICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuQ0xFQVJfV0lEVEhTKTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5ERVRFQ1RfU1RSSUNUX1dJRFRIUyk7XG4gICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5DT01QVVRFX0NPTFVNTl9XSURUSFMpO1xuICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuQUxJR05fQ09MVU1OUyk7XG4gICAgdGhpcy5hbHJlYWR5U2l6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuQ0FMQ1VMQVRFX01PREVfT0ZGKTtcbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLlVQREFURV9ST1dfV0lEVEgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWREaXNwbGF5TW9kZSB9IGZyb20gJy4uL2VudW1zL2Rpc3BsYXktbW9kZS5lbnVtJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuLi9yZW5kZXIvcmVuZGVyLW9yZ2FuaXplcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEaXNwbGF5TW9kZVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHByb3RlY3RlZCBfdmlldzogQmVoYXZpb3JTdWJqZWN0PERhdGFncmlkRGlzcGxheU1vZGU+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXRhZ3JpZERpc3BsYXlNb2RlPihcbiAgICBEYXRhZ3JpZERpc3BsYXlNb2RlLkRJU1BMQVlcbiAgKTtcblxuICBjb25zdHJ1Y3RvcihyZW5kZXJPcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICByZW5kZXJPcmdhbml6ZXJcbiAgICAgICAgLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5DQUxDVUxBVEVfTU9ERV9PTilcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLl92aWV3Lm5leHQoRGF0YWdyaWREaXNwbGF5TW9kZS5DQUxDVUxBVEUpKVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHJlbmRlck9yZ2FuaXplclxuICAgICAgICAuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkNBTENVTEFURV9NT0RFX09GRilcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLl92aWV3Lm5leHQoRGF0YWdyaWREaXNwbGF5TW9kZS5ESVNQTEFZKSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCB2aWV3KCk6IE9ic2VydmFibGU8RGF0YWdyaWREaXNwbGF5TW9kZT4ge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgVHJhY2tCeUZ1bmN0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyIH0gZnJvbSAnLi9maWx0ZXJzJztcbmltcG9ydCB7IEl0ZW1zIH0gZnJvbSAnLi9pdGVtcyc7XG5cbmxldCBuYlNlbGVjdGlvbjogbnVtYmVyID0gMDtcblxuZXhwb3J0IGVudW0gU2VsZWN0aW9uVHlwZSB7XG4gIE5vbmUsXG4gIFNpbmdsZSxcbiAgTXVsdGksXG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb248VCA9IGFueT4ge1xuICBwdWJsaWMgaWQ6IHN0cmluZztcbiAgcHJpdmF0ZSBwcmV2U2VsZWN0aW9uUmVmczogVFtdID0gW107IC8vIFJlZnMgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgcHJpdmF0ZSBwcmV2U2luZ2xlU2VsZWN0aW9uUmVmOiBUOyAvLyBSZWYgb2Ygc2luZ2xlIHNlbGVjdGVkIGl0ZW1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9pdGVtczogSXRlbXM8VD4sIHByaXZhdGUgX2ZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPikge1xuICAgIHRoaXMuaWQgPSAnY2xyLWRnLXNlbGVjdGlvbicgKyBuYlNlbGVjdGlvbisrO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9maWx0ZXJzLmNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX3NlbGVjdGFibGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9pdGVtcy5hbGxDaGFuZ2VzLnN1YnNjcmliZSh1cGRhdGVkSXRlbXMgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2VsZWN0aW9uVHlwZSkge1xuICAgICAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5Ob25lOiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFNlbGVjdGlvblR5cGUuU2luZ2xlOiB7XG4gICAgICAgICAgICBsZXQgbmV3U2luZ2xlOiBhbnk7XG4gICAgICAgICAgICBjb25zdCB0cmFja0J5OiBUcmFja0J5RnVuY3Rpb248VD4gPSB0aGlzLl9pdGVtcy50cmFja0J5O1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvblVwZGF0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnRTaW5nbGUgaGFzIGJlZW4gc2V0IGJlZm9yZSBkYXRhIHdhcyBsb2FkZWQsIHdlIGxvb2sgdXAgYW5kIHNhdmUgdGhlIHJlZiBmcm9tIGN1cnJlbnQgZGF0YSBzZXRcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTaW5nbGUgJiYgIXRoaXMucHJldlNpbmdsZVNlbGVjdGlvblJlZikge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faXRlbXMuYWxsICYmIHRoaXMuX2l0ZW1zLnRyYWNrQnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLl9pdGVtcy5hbGwuZmluZEluZGV4KG1heWJlID0+IG1heWJlID09PSB0aGlzLmN1cnJlbnRTaW5nbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldlNpbmdsZVNlbGVjdGlvblJlZiA9IHRoaXMuX2l0ZW1zLnRyYWNrQnkobG9va3VwLCB0aGlzLmN1cnJlbnRTaW5nbGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZWYgPSB0cmFja0J5KGluZGV4LCBpdGVtKTtcbiAgICAgICAgICAgICAgLy8gSWYgb25lIG9mIHRoZSB1cGRhdGVkIGl0ZW1zIGlzIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkU2luZ2xlLCBzZXQgaXQgYXMgdGhlIG5ldyBvbmVcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJldlNpbmdsZVNlbGVjdGlvblJlZiA9PT0gcmVmKSB7XG4gICAgICAgICAgICAgICAgbmV3U2luZ2xlID0gaXRlbTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25VcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHNtYXJ0IGRhdGFncmlkcywgd2UgZXhwZWN0IGFsbCBpdGVtcyB0byBiZSBwcmVzZW50IGluIHRoZSB1cGRhdGVkSXRlbXMgYXJyYXkuXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIHNob3VsZCBkZWxldGUgdGhlIGN1cnJlbnRTaW5nbGUgaWYgaXQgdXNlZCB0byBiZSBkZWZpbmVkIGJ1dCBkb2Vzbid0IGV4aXN0IGFueW1vcmUuXG4gICAgICAgICAgICAvLyBObyBleHBsaWNpdCBcImRlbGV0ZVwiIGlzIHJlcXVpcmVkLCBzaW5jZSBuZXdTaW5nbGUgd291bGQgYmUgdW5kZWZpbmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAvLyBNYXJraW5nIGl0IGFzIHNlbGVjdGlvblVwZGF0ZWQgaGVyZSB3aWxsIHNldCBjdXJyZW50U2luZ2xlIHRvIHVuZGVmaW5lZCBiZWxvdyBpbiB0aGUgc2V0VGltZW91dC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtcy5zbWFydCAmJiAhbmV3U2luZ2xlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvblVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiBEaXNjdXNzZWQgdGhpcyB3aXRoIEV1ZGVzIGFuZCB0aGlzIGlzIGZpbmUgZm9yIG5vdy5cbiAgICAgICAgICAgIC8vIEJ1dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgYSBkaWZmZXJlbnQgcGF0dGVybiBmb3IgdGhlXG4gICAgICAgICAgICAvLyBjaGlsZCB0cmlnZ2VyaW5nIHRoZSBwYXJlbnQgY2hhbmdlIGRldGVjdGlvbiBwcm9ibGVtLlxuICAgICAgICAgICAgLy8gVXNpbmcgc2V0VGltZW91dCBmb3Igbm93IHRvIGZpeCB0aGlzLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25VcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2luZ2xlID0gbmV3U2luZ2xlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5NdWx0aToge1xuICAgICAgICAgICAgbGV0IGxlZnRPdmVyOiBhbnlbXSA9IHRoaXMuY3VycmVudC5zbGljZSgpO1xuICAgICAgICAgICAgY29uc3QgdHJhY2tCeTogVHJhY2tCeUZ1bmN0aW9uPGFueT4gPSB0aGlzLl9pdGVtcy50cmFja0J5O1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvblVwZGF0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgaGFzIGJlZW4gc2V0IGJlZm9yZSBkYXRhIHdhcyBsb2FkZWQsIHdlIGxvb2sgdXAgYW5kIHNhdmUgdGhlIHJlZiBmcm9tIGN1cnJlbnQgZGF0YSBzZXRcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQubGVuZ3RoID4gMCAmJiB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLmxlbmd0aCAhPT0gdGhpcy5jdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faXRlbXMuYWxsICYmIHRoaXMuX2l0ZW1zLnRyYWNrQnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTZWxlY3Rpb25SZWZzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsb29rdXAgPSB0aGlzLl9pdGVtcy5hbGwuZmluZEluZGV4KG1heWJlID0+IG1heWJlID09PSBpdGVtKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMucHJldlNlbGVjdGlvblJlZnMucHVzaCh0aGlzLl9pdGVtcy50cmFja0J5KGxvb2t1cCwgaXRlbSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIHdvcmsgb24gaHR0cHM6Ly9naXRodWIuY29tL3Ztd2FyZS9jbGFyaXR5L2lzc3Vlcy8yMzQyXG4gICAgICAgICAgICAvLyBjdXJyZW50bHksIHRoZSBzZWxlY3Rpb24gaXMgY2xlYXJlZCB3aGVuIGZpbHRlciBpcyBhcHBsaWVkLCBzbyB0aGUgbG9naWMgaW5zaWRlXG4gICAgICAgICAgICAvLyB0aGUgaWYgc3RhdGVtZW50IGJlbG93IHJlc3VsdHMgaW4gYnJva2VuIGJlaGF2aW9yLlxuICAgICAgICAgICAgaWYgKGxlZnRPdmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdXBkYXRlZEl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gdHJhY2tCeShpbmRleCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgLy8gTG9vayBpbiBjdXJyZW50IHNlbGVjdGVkIHJlZnMgYXJyYXkgaWYgaXRlbSBpcyBzZWxlY3RlZCwgYW5kIHVwZGF0ZSBhY3R1YWwgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5pbmRleE9mKHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgbGVmdE92ZXJbc2VsZWN0ZWRJbmRleF0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSB1bm1hdGNoZWQgaXRlbXMgaWYgd2UncmUgdXNpbmcgc21hcnQgZGF0YWdyaWRzIHdoZXJlIHdlIGV4cGVjdCBhbGwgaXRlbXMgdG8gYmVcbiAgICAgICAgICAgICAgLy8gcHJlc2VudFxuICAgICAgICAgICAgICBpZiAodGhpcy5faXRlbXMuc21hcnQpIHtcbiAgICAgICAgICAgICAgICBsZWZ0T3ZlciA9IGxlZnRPdmVyLmZpbHRlcihzZWxlY3RlZCA9PiB1cGRhdGVkSXRlbXMuaW5kZXhPZihzZWxlY3RlZCkgPiAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5sZW5ndGggIT09IGxlZnRPdmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVE9ETzogRGlzY3Vzc2VkIHRoaXMgd2l0aCBFdWRlcyBhbmQgdGhpcyBpcyBmaW5lIGZvciBub3cuXG4gICAgICAgICAgICAgIC8vIEJ1dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgYSBkaWZmZXJlbnQgcGF0dGVybiBmb3IgdGhlXG4gICAgICAgICAgICAgIC8vIGNoaWxkIHRyaWdnZXJpbmcgdGhlIHBhcmVudCBjaGFuZ2UgZGV0ZWN0aW9uIHByb2JsZW0uXG4gICAgICAgICAgICAgIC8vIFVzaW5nIHNldFRpbWVvdXQgZm9yIG5vdyB0byBmaXggdGhpcy5cbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGxlZnRPdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBjbGVhclNlbGVjdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnQubGVuZ3RoID0gMDtcbiAgICB0aGlzLnByZXZTZWxlY3Rpb25SZWZzID0gW107XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gIH1cblxuICBwcml2YXRlIF9zZWxlY3Rpb25UeXBlOiBTZWxlY3Rpb25UeXBlID0gU2VsZWN0aW9uVHlwZS5Ob25lO1xuICBwdWJsaWMgZ2V0IHNlbGVjdGlvblR5cGUoKTogU2VsZWN0aW9uVHlwZSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvblR5cGU7XG4gIH1cbiAgcHVibGljIHNldCBzZWxlY3Rpb25UeXBlKHZhbHVlOiBTZWxlY3Rpb25UeXBlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLnNlbGVjdGlvblR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2VsZWN0aW9uVHlwZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gU2VsZWN0aW9uVHlwZS5Ob25lKSB7XG4gICAgICBkZWxldGUgdGhpcy5jdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUN1cnJlbnQoW10sIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcm93U2VsZWN0aW9uTW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZ2V0IF9zZWxlY3RhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk11bHRpIHx8IHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuU2luZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBJZ25vcmUgaXRlbXMgY2hhbmdlcyBpbiB0aGUgc2FtZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgKi9cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gIHByaXZhdGUgZGVib3VuY2U6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9ucyB0byB0aGUgb3RoZXIgcHJvdmlkZXJzIGNoYW5nZXMuXG4gICAqL1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCBvdXIgc3Vic2NyaXB0aW9ucyB0byBvdGhlciBwcm92aWRlcnNcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHNpbmdsZSBzZWxlY3Rpb24gdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudFNpbmdsZTogVDtcbiAgcHVibGljIGdldCBjdXJyZW50U2luZ2xlKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U2luZ2xlO1xuICB9XG4gIHB1YmxpYyBzZXQgY3VycmVudFNpbmdsZSh2YWx1ZTogVCkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fY3VycmVudFNpbmdsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50U2luZ2xlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLmFsbCAmJiB0aGlzLl9pdGVtcy50cmFja0J5ICYmIHZhbHVlKSB7XG4gICAgICBjb25zdCBsb29rdXAgPSB0aGlzLl9pdGVtcy5hbGwuZmluZEluZGV4KG1heWJlID0+IG1heWJlID09PSB2YWx1ZSk7XG4gICAgICB0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYgPSB0aGlzLl9pdGVtcy50cmFja0J5KGxvb2t1cCwgdmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAvLyBJZ25vcmUgaXRlbXMgY2hhbmdlcyBpbiB0aGUgc2FtZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgIC8vIEBUT0RPIFRoaXMgY2FuIGxpa2VseSBiZSByZW1vdmVkIVxuICAgIHRoaXMuZGVib3VuY2UgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gKHRoaXMuZGVib3VuY2UgPSBmYWxzZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudDogVFtdO1xuICBwdWJsaWMgZ2V0IGN1cnJlbnQoKTogVFtdIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuICBwdWJsaWMgc2V0IGN1cnJlbnQodmFsdWU6IFRbXSkge1xuICAgIHRoaXMudXBkYXRlQ3VycmVudCh2YWx1ZSwgdHJ1ZSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlQ3VycmVudCh2YWx1ZTogVFtdLCBlbWl0OiBib29sZWFuKSB7XG4gICAgdGhpcy5fY3VycmVudCA9IHZhbHVlO1xuICAgIGlmIChlbWl0KSB7XG4gICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAgIC8vIElnbm9yZSBpdGVtcyBjaGFuZ2VzIGluIHRoZSBzYW1lIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUuXG4gICAgICAvLyBAVE9ETyBUaGlzIGNhbiBsaWtlbHkgYmUgcmVtb3ZlZCFcbiAgICAgIHRoaXMuZGVib3VuY2UgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiAodGhpcy5kZWJvdW5jZSA9IGZhbHNlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBzZWxlY3Rpb24gY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8VFtdIHwgVD4oKTtcbiAgcHJpdmF0ZSBlbWl0Q2hhbmdlKCkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZSkge1xuICAgICAgdGhpcy5fY2hhbmdlLm5leHQodGhpcy5jdXJyZW50U2luZ2xlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuTXVsdGkpIHtcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuY3VycmVudCk7XG4gICAgfVxuICB9XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxUW10gfCBUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NlbGVjdGVkKGl0ZW06IFQpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5TaW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaW5nbGUgPT09IGl0ZW07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk11bHRpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSkgPj0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYW4gaXRlbVxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RJdGVtKGl0ZW06IFQpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnQucHVzaChpdGVtKTtcbiAgICBpZiAodGhpcy5faXRlbXMudHJhY2tCeSkge1xuICAgICAgLy8gUHVzaCBzZWxlY3RlZCByZWYgb250byBhcnJheVxuICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gaXRlbSk7XG4gICAgICB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLnB1c2godGhpcy5faXRlbXMudHJhY2tCeShsb29rdXAsIGl0ZW0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzZWxlY3RzIGFuIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgZGVzZWxlY3RJdGVtKGluZGV4T2ZJdGVtOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnQuc3BsaWNlKGluZGV4T2ZJdGVtLCAxKTtcbiAgICBpZiAodGhpcy5faXRlbXMudHJhY2tCeSAmJiBpbmRleE9mSXRlbSA8IHRoaXMucHJldlNlbGVjdGlvblJlZnMubGVuZ3RoKSB7XG4gICAgICAvLyBLZWVwIHNlbGVjdGVkIHJlZnMgYXJyYXkgaW4gc3luY1xuICAgICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5zcGxpY2UoaW5kZXhPZkl0ZW0sIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIG9yIGRlc2VsZWN0cyBhbiBpdGVtXG4gICAqL1xuICBwdWJsaWMgc2V0U2VsZWN0ZWQoaXRlbTogVCwgc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3NlbGVjdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5Ob25lOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5TaW5nbGU6XG4gICAgICAgIC8vIGluIHNpbmdsZSBzZWxlY3Rpb24sIHNldCBjdXJyZW50U2luZ2xlIG1ldGhvZCBzaG91bGQgYmUgdXNlZFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5NdWx0aTpcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmN1cnJlbnQuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5kZXNlbGVjdEl0ZW0oaW5kZXgpO1xuICAgICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgMCAmJiBzZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0SXRlbShpdGVtKTtcbiAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYWxsIGN1cnJlbnRseSBkaXNwbGF5ZWQgaXRlbXMgYXJlIHNlbGVjdGVkXG4gICAqL1xuICBwdWJsaWMgaXNBbGxTZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSAhPT0gU2VsZWN0aW9uVHlwZS5NdWx0aSB8fCAhdGhpcy5faXRlbXMuZGlzcGxheWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXllZEl0ZW1zOiBUW10gPSB0aGlzLl9pdGVtcy5kaXNwbGF5ZWQ7XG4gICAgY29uc3QgbmJEaXNwbGF5ZWQgPSB0aGlzLl9pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoO1xuICAgIGlmIChuYkRpc3BsYXllZCA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGVtcDogVFtdID0gZGlzcGxheWVkSXRlbXMuZmlsdGVyKGl0ZW0gPT4gdGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSkgPiAtMSk7XG4gICAgcmV0dXJuIHRlbXAubGVuZ3RoID09PSBkaXNwbGF5ZWRJdGVtcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyBvciBkZXNlbGVjdHMgYWxsIGN1cnJlbnRseSBkaXNwbGF5ZWQgaXRlbXNcbiAgICovXG4gIHB1YmxpYyB0b2dnbGVBbGwoKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuTm9uZSB8fCB0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKlxuICAgICAgICAgKiBJZiBldmVyeSBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW0gaXMgYWxyZWFkeSBzZWxlY3RlZCwgd2UgY2xlYXIgdGhlbS5cbiAgICAgICAgICogSWYgYXQgbGVhc3Qgb25lIGl0ZW0gaXNuJ3Qgc2VsZWN0ZWQsIHdlIHNlbGVjdCBldmVyeSBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW0uXG4gICAgICAgICAqL1xuICAgIGlmICh0aGlzLmlzQWxsU2VsZWN0ZWQoKSkge1xuICAgICAgdGhpcy5faXRlbXMuZGlzcGxheWVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuY3VycmVudC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmRlc2VsZWN0SXRlbShjdXJyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXRlbXMuZGlzcGxheWVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaW5kZXhPZihpdGVtKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbWJlZGRlZFZpZXdSZWYsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2RnLXdyYXBwZWQtcm93JyxcbiAgdGVtcGxhdGU6IGAgICAgICAgIFxuICAgICAgICA8bmctdGVtcGxhdGUgI3Jvd1BvcnRhbD5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBXcmFwcGVkUm93IGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIEFmdGVyVmlld0luaXQge1xuICBfZHluYW1pYyA9IGZhbHNlO1xuXG4gIEBWaWV3Q2hpbGQoJ3Jvd1BvcnRhbCcpIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjx2b2lkPjtcbiAgcm93VmlldzogRW1iZWRkZWRWaWV3UmVmPHZvaWQ+OyAvLyB0aGUgcm93cyBwcm9qZWN0ZWQgdmlldyAoaW4gbWVtb3J5KVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBDcmVhdGUgdGhlIGNlbGxzIHZpZXcgaW4gbWVtb3J5LCBub3QgdGhlIERPTS5cbiAgICB0aGlzLnJvd1ZpZXcgPSB0aGlzLnRlbXBsYXRlUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhudWxsKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENlbGwgfSBmcm9tICcuL2RhdGFncmlkLWNlbGwnO1xuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgRGF0YWdyaWREaXNwbGF5TW9kZSB9IGZyb20gJy4vZW51bXMvZGlzcGxheS1tb2RlLmVudW0nO1xuaW1wb3J0IHsgRGlzcGxheU1vZGVTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGlzcGxheS1tb2RlLnNlcnZpY2UnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuaW1wb3J0IHsgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UnO1xuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIFNlbGVjdGlvblR5cGUgfSBmcm9tICcuL3Byb3ZpZGVycy9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgV3JhcHBlZFJvdyB9IGZyb20gJy4vd3JhcHBlZC1yb3cnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxubGV0IG5iUm93OiBudW1iZXIgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcm93JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGFncmlkLXJvdy5odG1sJyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0YWdyaWQtcm93XSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgJ1thdHRyLmFyaWEtb3duc10nOiAnaWQnLFxuICAgIHJvbGU6ICdyb3dncm91cCcsXG4gIH0sXG4gIHByb3ZpZGVyczogW0V4cGFuZCwgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBFeHBhbmQgfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkUm93PFQgPSBhbnk+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG4gIHB1YmxpYyBpZDogc3RyaW5nO1xuICBwdWJsaWMgcmFkaW9JZDogc3RyaW5nO1xuICBwdWJsaWMgY2hlY2tib3hJZDogc3RyaW5nO1xuXG4gIC8qIHJlZmVyZW5jZSB0byB0aGUgZW51bSBzbyB0aGF0IHRlbXBsYXRlIGNhbiBhY2Nlc3MgKi9cbiAgcHVibGljIFNFTEVDVElPTl9UWVBFID0gU2VsZWN0aW9uVHlwZTtcblxuICAvKipcbiAgICogTW9kZWwgb2YgdGhlIHJvdywgdG8gdXNlIGZvciBzZWxlY3Rpb25cbiAgICovXG4gIEBJbnB1dCgnY2xyRGdJdGVtJykgaXRlbTogVDtcblxuICBwdWJsaWMgcmVwbGFjZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uPFQ+LFxuICAgIHB1YmxpYyByb3dBY3Rpb25TZXJ2aWNlOiBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBnbG9iYWxFeHBhbmRhYmxlOiBFeHBhbmRhYmxlUm93c0NvdW50LFxuICAgIHB1YmxpYyBleHBhbmQ6IEV4cGFuZCxcbiAgICBwdWJsaWMgaGlkZWFibGVDb2x1bW5TZXJ2aWNlOiBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBkaXNwbGF5TW9kZTogRGlzcGxheU1vZGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIG5iUm93Kys7XG4gICAgdGhpcy5pZCA9ICdjbHItZGctcm93JyArIG5iUm93O1xuICAgIHRoaXMucmFkaW9JZCA9ICdjbHItZGctcm93LXJkJyArIG5iUm93O1xuICAgIHRoaXMuY2hlY2tib3hJZCA9ICdjbHItZGctcm93LWNiJyArIG5iUm93O1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBjb21iaW5lTGF0ZXN0KHRoaXMuZXhwYW5kLnJlcGxhY2UsIHRoaXMuZXhwYW5kLmV4cGFuZENoYW5nZSkuc3Vic2NyaWJlKFxuICAgICAgICAoW2V4cGFuZFJlcGxhY2VWYWx1ZSwgZXhwYW5kQ2hhbmdlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgaWYgKGV4cGFuZFJlcGxhY2VWYWx1ZSAmJiBleHBhbmRDaGFuZ2VWYWx1ZSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZWQgYW5kIGV4cGFuZGluZ1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2RhdGFncmlkLXJvdy1yZXBsYWNlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBIYW5kbGVzIHRoZXNlIGNhc2VzOiBub3QgcmVwbGFjZWQgYW5kIGNvbGxhcHNpbmcgJiByZXBsYWNlZCBhbmRcbiAgICAgICAgICAgIC8vIGNvbGxhcHNpbmcgYW5kIG5vdCByZXBsYWNlZCBhbmQgZXhwYW5kaW5nLlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1yb3ctcmVwbGFjZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2VsZWN0ZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgcm93IGlzIHNlbGVjdGVkXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNlbGVjdGVkKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk5vbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmlzU2VsZWN0ZWQodGhpcy5pdGVtKTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoJ2NsckRnU2VsZWN0ZWQnKVxuICBwdWJsaWMgc2V0IHNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuTm9uZSkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0ZWQodGhpcy5pdGVtLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdTZWxlY3RlZENoYW5nZScpIHNlbGVjdGVkQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHB1YmxpYyB0b2dnbGUoc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZCkge1xuICAgIGlmIChzZWxlY3RlZCAhPT0gdGhpcy5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZWQuZW1pdChzZWxlY3RlZCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBleHBhbmRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmQuZXhwYW5kZWQ7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnRXhwYW5kZWQnKVxuICBwdWJsaWMgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5leHBhbmQuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnRXhwYW5kZWRDaGFuZ2UnKSBleHBhbmRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHB1YmxpYyB0b2dnbGVFeHBhbmQoKSB7XG4gICAgaWYgKHRoaXMuZXhwYW5kLmV4cGFuZGFibGUpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICB9XG4gIH1cblxuICAvKioqKipcbiAgICogcHJvcGVydHkgZGdDZWxsc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBRdWVyeSBMaXN0IG9mIHRoZSBDbHJEYXRhZ3JpZCBjZWxscyBpbiB0aGlzIHJvdy5cbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRDZWxsKSBkZ0NlbGxzOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRDZWxsPjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoaW5ncyBnZXQgc3RhcnRlZFxuICAgIGNvbnN0IGNvbHVtbnNMaXN0ID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpO1xuICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbnNMaXN0KTtcblxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSBDZWxscyBsaXN0IGNoYW5nZXMgcGVyIHJvdy1yZW5kZXJlclxuICAgIHRoaXMuZGdDZWxscy5jaGFuZ2VzLnN1YnNjcmliZShjZWxsTGlzdCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5MaXN0ID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpO1xuICAgICAgaWYgKGNlbGxMaXN0Lmxlbmd0aCA9PT0gY29sdW1uTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBVc2VkIHRvIHNldCB0aGluZ3MgdXAgdGhlIGZpcnN0IHRpbWUgYnV0IG9ubHkgYWZ0ZXIgYWxsIHRoZSBjb2x1bW5zIGFyZSByZWFkeS5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNvbHVtbkxpc3QgPT4ge1xuICAgICAgICAvLyBQcmV2ZW50cyBjZWxsIHVwZGF0ZXMgd2hlbiBjb2xzIGFuZCBjZWxscyBhcnJheSBhcmUgbm90IGFsaWduZWQgLSBvbmx5IHNlZW1zIHRvIHJ1biBvbiBpbml0IC8gZmlyc3QgdGltZS5cbiAgICAgICAgaWYgKGNvbHVtbkxpc3QubGVuZ3RoID09PSB0aGlzLmRnQ2VsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZGlzcGxheU1vZGUudmlldy5zdWJzY3JpYmUodmlld0NoYW5nZSA9PiB7XG4gICAgICAgIC8vIExpc3RlbiBmb3IgdmlldyBjaGFuZ2VzIGFuZCBtb3ZlIGNlbGxzIGFyb3VuZCBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQgZGlzcGxheVR5cGVcbiAgICAgICAgLy8gcmVtb3ZlIGNlbGwgdmlld3MgZnJvbSBkaXNwbGF5IHZpZXdcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3Njcm9sbGFibGVDZWxscy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLl9zY3JvbGxhYmxlQ2VsbHMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGNlbGwgdmlld3MgZnJvbSBjYWxjdWxhdGVkIHZpZXdcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2NhbGN1bGF0ZWRDZWxscy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVkQ2VsbHMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXdDaGFuZ2UgPT09IERhdGFncmlkRGlzcGxheU1vZGUuQ0FMQ1VMQVRFKSB7XG4gICAgICAgICAgdGhpcy5kaXNwbGF5Q2VsbHMgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmRnQ2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZWRDZWxscy5pbnNlcnQoY2VsbC5fdmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwbGF5Q2VsbHMgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZGdDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZUNlbGxzLmluc2VydChjZWxsLl92aWV3KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIDEuIE1hcHMgdGhlIG5ldyBjb2x1bW5MaXN0Q2hhbmdlIHRvIHRoZSBkZ0NlbGxzIGxpc3QgYnkgaW5kZXhcbiAgICogMi4gU2V0cyB0aGUgaGlkZGVuIHN0YXRlIG9uIHRoZSBjZWxsXG4gICAqIFRha2UgYSBDb2x1bW4gbGlzdCBhbmQgdXNlIGluZGV4IHRvIGFjY2VzcyB0aGUgY29sdW1ucyBmb3IgaGlkZWFibGUgcHJvcGVydGllcy5cbiAgICpcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdDogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10pIHtcbiAgICAvLyBNYXAgY2VsbHMgdG8gY29sdW1ucyB3aXRoIEFycmF5LmluZGV4XG4gICAgdGhpcy5kZ0NlbGxzLmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50Q29sdW1uID0gY29sdW1uTGlzdFtpbmRleF07IC8vIEFjY291bnRzIGZvciBudWxsIHNwYWNlLlxuICAgICAgaWYgKGN1cnJlbnRDb2x1bW4pIHtcbiAgICAgICAgY2VsbC5pZCA9IGN1cnJlbnRDb2x1bW4uaWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBwdWJsaWMgZGlzcGxheUNlbGxzID0gZmFsc2U7XG5cbiAgQFZpZXdDaGlsZCgnc3RpY2t5Q2VsbHMnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgX3N0aWNreUNlbGxzOiBWaWV3Q29udGFpbmVyUmVmO1xuICBAVmlld0NoaWxkKCdzY3JvbGxhYmxlQ2VsbHMnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgX3Njcm9sbGFibGVDZWxsczogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgnY2FsY3VsYXRlZENlbGxzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9jYWxjdWxhdGVkQ2VsbHM6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgcHJpdmF0ZSB3cmFwcGVkSW5qZWN0b3I6IEluamVjdG9yO1xuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMud3JhcHBlZEluamVjdG9yID0gbmV3IEhvc3RXcmFwcGVyKFdyYXBwZWRSb3csIHRoaXMudmNyKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgX3ZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcHBlZEluamVjdG9yLmdldChXcmFwcGVkUm93LCB0aGlzLnZjcikucm93VmlldztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlIHtcbiAgYnV0dG9uczogVGVtcGxhdGVSZWY8YW55PiA9IG51bGw7XG4gIHNlbGVjdEFsbERpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfc2VsZWN0QWxsQnV0dG9uQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHB1YmxpYyBnZXQgc2VsZWN0QWxsQnV0dG9uQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0QWxsQnV0dG9uQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBidXR0b25DbGlja2VkKCk6IHZvaWQge1xuICAgIHRoaXMuX3NlbGVjdEFsbEJ1dHRvbkNsaWNrZWQubmV4dCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yIH0gZnJvbSAnLi4vYnVpbHQtaW4vY29tcGFyYXRvcnMvZGF0YWdyaWQtcHJvcGVydHktY29tcGFyYXRvcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyIH0gZnJvbSAnLi4vYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1wcm9wZXJ0eS1zdHJpbmctZmlsdGVyJztcbmltcG9ydCB7IERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCB9IGZyb20gJy4uL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtc3RyaW5nLWZpbHRlci1pbXBsJztcbmltcG9ydCB7IENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3N0YXRlLmludGVyZmFjZSc7XG5cbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciB9IGZyb20gJy4vZmlsdGVycyc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wYWdlJztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL3NvcnQnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5cbi8qKlxuICogVGhpcyBwcm92aWRlciBhZ2dyZWdhdGVzIHN0YXRlIGNoYW5nZXMgZnJvbSB0aGUgdmFyaW91cyBwcm92aWRlcnMgb2YgdGhlIERhdGFncmlkXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdGF0ZVByb3ZpZGVyPFQ+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBmaWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4sXG4gICAgcHJpdmF0ZSBzb3J0OiBTb3J0PFQ+LFxuICAgIHByaXZhdGUgcGFnZTogUGFnZSxcbiAgICBwcml2YXRlIGRlYm91bmNlcjogU3RhdGVEZWJvdW5jZXJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gZ2xvYmFsIHN0YXRlIGNoYW5nZXNcbiAgICovXG4gIGNoYW5nZTogT2JzZXJ2YWJsZTxDbHJEYXRhZ3JpZFN0YXRlSW50ZXJmYWNlPFQ+PiA9IHRoaXMuZGVib3VuY2VyLmNoYW5nZS5waXBlKG1hcCgoKSA9PiB0aGlzLnN0YXRlKSk7XG5cbiAgLypcbiAgICAgKiBCeSBtYWtpbmcgdGhpcyBhIGdldHRlciwgd2Ugb3BlbiB0aGUgcG9zc2liaWxpdHkgZm9yIGEgc2V0dGVyIGluIHRoZSBmdXR1cmUuXG4gICAgICogSXQncyBiZWVuIHJlcXVlc3RlZCBhIGNvdXBsZSB0aW1lcy5cbiAgICAgKi9cbiAgZ2V0IHN0YXRlKCk6IENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2U8VD4ge1xuICAgIGNvbnN0IHN0YXRlOiBDbHJEYXRhZ3JpZFN0YXRlSW50ZXJmYWNlPFQ+ID0ge307XG4gICAgaWYgKHRoaXMucGFnZS5zaXplID4gMCkge1xuICAgICAgc3RhdGUucGFnZSA9IHsgZnJvbTogdGhpcy5wYWdlLmZpcnN0SXRlbSwgdG86IHRoaXMucGFnZS5sYXN0SXRlbSwgc2l6ZTogdGhpcy5wYWdlLnNpemUgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc29ydC5jb21wYXJhdG9yKSB7XG4gICAgICBpZiAodGhpcy5zb3J0LmNvbXBhcmF0b3IgaW5zdGFuY2VvZiBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcikge1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGRlZmF1bHQgb2JqZWN0IHByb3BlcnR5IGNvbXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgICogd2UgZ2l2ZSB0aGUgcHJvcGVydHkgbmFtZSBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgY29tcGFyYXRvci5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgc3RhdGUuc29ydCA9IHsgYnk6ICg8RGF0YWdyaWRQcm9wZXJ0eUNvbXBhcmF0b3I8VD4+dGhpcy5zb3J0LmNvbXBhcmF0b3IpLnByb3AsIHJldmVyc2U6IHRoaXMuc29ydC5yZXZlcnNlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5zb3J0ID0geyBieTogdGhpcy5zb3J0LmNvbXBhcmF0b3IsIHJldmVyc2U6IHRoaXMuc29ydC5yZXZlcnNlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlRmlsdGVycyA9IHRoaXMuZmlsdGVycy5nZXRBY3RpdmVGaWx0ZXJzKCk7XG4gICAgaWYgKGFjdGl2ZUZpbHRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdGUuZmlsdGVycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgYWN0aXZlRmlsdGVycykge1xuICAgICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsKSB7XG4gICAgICAgICAgY29uc3Qgc3RyaW5nRmlsdGVyID0gZmlsdGVyLmZpbHRlckZuO1xuICAgICAgICAgIGlmIChzdHJpbmdGaWx0ZXIgaW5zdGFuY2VvZiBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlIGFnYWluIGZvciB0aGUgZGVmYXVsdCBvYmplY3QgcHJvcGVydHkgZmlsdGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2UgZ2l2ZSB0aGUgcHJvcGVydHkgbmFtZSBpbnN0ZWFkIG9mIHRoZSBmdWxsIGZpbHRlciBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0YXRlLmZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgIHByb3BlcnR5OiBzdHJpbmdGaWx0ZXIucHJvcCxcbiAgICAgICAgICAgICAgdmFsdWU6IGZpbHRlci52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgT25EZXN0cm95LCBQTEFURk9STV9JRCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi8uLi9lbnVtcy9yZW5kZXItc3RlcC5lbnVtJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi8uLi9yZW5kZXIvcmVuZGVyLW9yZ2FuaXplcic7XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJbnRlcm5hbCBkYXRhZ3JpZCBzZXJ2aWNlIHRoYXQgaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlIGNsci1kZy10YWJsZSBlbGVtZW50IGFuZCBleHBvc2VzIGEgbWV0aG9kIHRvIGdldCBoZWlnaHQuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUYWJsZVNpemVTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfdGFibGVSZWY6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIGNvbHVtbnM6IEVsZW1lbnRbXTtcblxuICBwdWJsaWMgZ2V0IHRhYmxlUmVmKCk6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5fdGFibGVSZWY7XG4gIH1cblxuICBwdWJsaWMgc2V0IHRhYmxlUmVmKGVsZW1lbnQ6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5fdGFibGVSZWYgPSBlbGVtZW50O1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QsXG4gICAgcmVuZGVyT3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICByZW5kZXJPcmdhbml6ZXIucmVuZGVyU3RlcC5zdWJzY3JpYmUoc3RlcCA9PiB7XG4gICAgICAgIGlmIChzdGVwID09PSBEYXRhZ3JpZFJlbmRlclN0ZXAuVVBEQVRFX1JPV19XSURUSCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlUm93V2lkdGgoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHB1YmxpYyBzZXQgdGFibGUodGFibGU6IEVsZW1lbnRSZWYpIHtcbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0YWJsZS5uYXRpdmVFbGVtZW50KSB7XG4gICAgICB0aGlzLnRhYmxlUmVmID0gdGFibGUubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZGF0YWdyaWQtdGFibGUnKTtcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gcmVzaXppbmcgY29sdW1ucyB0byBzaG93IHRoZSBjb2x1bW4gYm9yZGVyIGJlaW5nIGRyYWdnZWQuXG4gIGdldENvbHVtbkRyYWdIZWlnaHQoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMudGFibGVSZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMudGFibGVSZWYuY2xpZW50SGVpZ2h0fXB4YDtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgdXBkYXRlUm93V2lkdGgoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnRhYmxlUmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBuZXdXaWR0aDogbnVtYmVyID0gMDtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZVN0eWxlKHRoaXMudGFibGVSZWYsICd3aWR0aCcpO1xuICAgIHRoaXMuY29sdW1ucyA9IEFycmF5LmZyb20odGhpcy50YWJsZVJlZi5xdWVyeVNlbGVjdG9yQWxsKCcuZGF0YWdyaWQtY29sdW1uJykpO1xuICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgbmV3V2lkdGggKz0gaXRlbS5jbGllbnRXaWR0aDtcbiAgICB9KTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudGFibGVSZWYsICd3aWR0aCcsIG5ld1dpZHRoICsgJ3B4Jyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVmlld0NoaWxkLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtbiB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uJztcbmltcG9ydCB7IENsckRhdGFncmlkSXRlbXMgfSBmcm9tICcuL2RhdGFncmlkLWl0ZW1zJztcbmltcG9ydCB7IENsckRhdGFncmlkUGxhY2Vob2xkZXIgfSBmcm9tICcuL2RhdGFncmlkLXBsYWNlaG9sZGVyJztcbmltcG9ydCB7IENsckRhdGFncmlkUm93IH0gZnJvbSAnLi9kYXRhZ3JpZC1yb3cnO1xuaW1wb3J0IHsgRGF0YWdyaWREaXNwbGF5TW9kZSB9IGZyb20gJy4vZW51bXMvZGlzcGxheS1tb2RlLmVudW0nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBEaXNwbGF5TW9kZVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kaXNwbGF5LW1vZGUuc2VydmljZSc7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9maWx0ZXJzJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IEl0ZW1zIH0gZnJvbSAnLi9wcm92aWRlcnMvaXRlbXMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UnO1xuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIFNlbGVjdGlvblR5cGUgfSBmcm9tICcuL3Byb3ZpZGVycy9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgU29ydCB9IGZyb20gJy4vcHJvdmlkZXJzL3NvcnQnO1xuaW1wb3J0IHsgU3RhdGVEZWJvdW5jZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuaW1wb3J0IHsgU3RhdGVQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXJzL3N0YXRlLnByb3ZpZGVyJztcbmltcG9ydCB7IFRhYmxlU2l6ZVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJsZS1zaXplLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuL3JlbmRlci9yZW5kZXItb3JnYW5pemVyJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kYXRhZ3JpZCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRhZ3JpZC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAgU2VsZWN0aW9uLFxuICAgIFNvcnQsXG4gICAgRmlsdGVyc1Byb3ZpZGVyLFxuICAgIFBhZ2UsXG4gICAgSXRlbXMsXG4gICAgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIsXG4gICAgUm93QWN0aW9uU2VydmljZSxcbiAgICBFeHBhbmRhYmxlUm93c0NvdW50LFxuICAgIEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBTdGF0ZURlYm91bmNlcixcbiAgICBTdGF0ZVByb3ZpZGVyLFxuICAgIENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlLFxuICAgIFRhYmxlU2l6ZVNlcnZpY2UsXG4gICAgRGlzcGxheU1vZGVTZXJ2aWNlLFxuICBdLFxuICBob3N0OiB7ICdbY2xhc3MuZGF0YWdyaWQtaG9zdF0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWQ8VCA9IGFueT4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwcml2YXRlIG9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIsXG4gICAgcHVibGljIGl0ZW1zOiBJdGVtczxUPixcbiAgICBwdWJsaWMgZXhwYW5kYWJsZVJvd3M6IEV4cGFuZGFibGVSb3dzQ291bnQsXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uPFQ+LFxuICAgIHB1YmxpYyByb3dBY3Rpb25TZXJ2aWNlOiBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgc3RhdGVQcm92aWRlcjogU3RhdGVQcm92aWRlcjxUPixcbiAgICBwcml2YXRlIGRpc3BsYXlNb2RlOiBEaXNwbGF5TW9kZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7fVxuXG4gIC8qIHJlZmVyZW5jZSB0byB0aGUgZW51bSBzbyB0aGF0IHRlbXBsYXRlIGNhbiBhY2Nlc3MgKi9cbiAgcHVibGljIFNFTEVDVElPTl9UWVBFID0gU2VsZWN0aW9uVHlwZTtcblxuICAvKipcbiAgICogRnJlZXplcyB0aGUgZGF0YWdyaWQgd2hpbGUgZGF0YSBpcyBsb2FkaW5nXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxvYWRpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMubG9hZGluZztcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdMb2FkaW5nJylcbiAgcHVibGljIHNldCBsb2FkaW5nKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5pdGVtcy5sb2FkaW5nID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogT3V0cHV0IGVtaXR0ZWQgd2hlbmV2ZXIgdGhlIGRhdGEgbmVlZHMgdG8gYmUgcmVmcmVzaGVkLCBiYXNlZCBvbiB1c2VyIGFjdGlvbiBvciBleHRlcm5hbCBvbmVzXG4gICAqL1xuICBAT3V0cHV0KCdjbHJEZ1JlZnJlc2gnKSBwdWJsaWMgcmVmcmVzaCA9IG5ldyBFdmVudEVtaXR0ZXI8Q2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZTxUPj4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlLXRyaWdnZXIgdGhlIGNvbXB1dGF0aW9uIG9mIGRpc3BsYXllZCBpdGVtcyBtYW51YWxseVxuICAgKi9cbiAgcHVibGljIGRhdGFDaGFuZ2VkKCkge1xuICAgIHRoaXMuaXRlbXMucmVmcmVzaCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIGdyYWIgdGhlIHNtYXJ0IGl0ZXJhdG9yIGZyb20gcHJvamVjdGVkIGNvbnRlbnRcbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyRGF0YWdyaWRJdGVtcykgcHVibGljIGl0ZXJhdG9yOiBDbHJEYXRhZ3JpZEl0ZW1zPFQ+O1xuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBhbGwgc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIEBJbnB1dCgnY2xyRGdTZWxlY3RlZCcpXG4gIHNldCBzZWxlY3RlZCh2YWx1ZTogVFtdKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID0gU2VsZWN0aW9uVHlwZS5NdWx0aTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9IFNlbGVjdGlvblR5cGUuTm9uZTtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3Rpb24udXBkYXRlQ3VycmVudCh2YWx1ZSwgZmFsc2UpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdTZWxlY3RlZENoYW5nZScpIHNlbGVjdGVkQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VFtdPihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIFNlbGVjdGVkIGl0ZW0gaW4gc2luZ2xlLXNlbGVjdCBtb2RlXG4gICAqL1xuICBASW5wdXQoJ2NsckRnU2luZ2xlU2VsZWN0ZWQnKVxuICBzZXQgc2luZ2xlU2VsZWN0ZWQodmFsdWU6IFQpIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID0gU2VsZWN0aW9uVHlwZS5TaW5nbGU7XG4gICAgLy8gdGhlIGNsckRnU2luZ2xlU2VsZWN0ZWQgaXMgdXBkYXRlZCBpbiBvbmUgb2YgdHdvIGNhc2VzOlxuICAgIC8vIDEuIGFuIGV4cGxpY2l0IHZhbHVlIGlzIHBhc3NlZFxuICAgIC8vIDIuIGlzIGJlaW5nIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2hlcmUgcHJldmlvdXNseSBpdCBoYWQgYSB2YWx1ZVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uY3VycmVudFNpbmdsZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uY3VycmVudFNpbmdsZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uY3VycmVudFNpbmdsZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdTaW5nbGVTZWxlY3RlZENoYW5nZScpIHNpbmdsZVNlbGVjdGVkQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VD4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBTZWxlY3Rpb24vRGVzZWxlY3Rpb24gb24gcm93IGNsaWNrIG1vZGVcbiAgICovXG4gIEBJbnB1dCgnY2xyRGdSb3dTZWxlY3Rpb24nKVxuICBzZXQgcm93U2VsZWN0aW9uTW9kZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuc2VsZWN0aW9uLnJvd1NlbGVjdGlvbk1vZGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgYWxsIGN1cnJlbnRseSBkaXNwbGF5ZWQgaXRlbXMgYXJlIHNlbGVjdGVkXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFsbFNlbGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5pc0FsbFNlbGVjdGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cy9kZXNlbGVjdHMgYWxsIGN1cnJlbnRseSBkaXNwbGF5ZWQgaXRlbXNcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgc2V0IGFsbFNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgLypcbiAgICAgICAgICogVGhpcyBpcyBhIHNldHRlciBidXQgd2UgaWdub3JlIHRoZSB2YWx1ZS5cbiAgICAgICAgICogSXQncyBzdHJhbmdlLCBidXQgaXQgbGV0cyB1cyBoYXZlIGFuIGluZGV0ZXJtaW5hdGUgc3RhdGUgd2hlcmUgb25seVxuICAgICAgICAgKiBzb21lIG9mIHRoZSBpdGVtcyBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgIHRoaXMuc2VsZWN0aW9uLnRvZ2dsZUFsbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbSBwbGFjZWhvbGRlciBkZXRlY3Rpb25cbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyRGF0YWdyaWRQbGFjZWhvbGRlcikgcHVibGljIHBsYWNlaG9sZGVyOiBDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyPFQ+O1xuXG4gIC8qKlxuICAgKiBIaWRlYWJsZSBDb2x1bW4gZGF0YSBzb3VyY2UgLyBkZXRlY3Rpb24uXG4gICAqL1xuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkQ29sdW1uKSBwdWJsaWMgY29sdW1uczogUXVlcnlMaXN0PENsckRhdGFncmlkQ29sdW1uPFQ+PjtcblxuICAvKipcbiAgICogV2hlbiB0aGUgZGF0YWdyaWQgaXMgdXNlci1tYW5hZ2VkIHdpdGhvdXQgdGhlIHNtYXJ0IGl0ZXJhdG9yLCB3ZSBnZXQgdGhlIGl0ZW1zIGRpc3BsYXllZFxuICAgKiBieSBxdWVyeWluZyB0aGUgcHJvamVjdGVkIGNvbnRlbnQuIFRoaXMgaXMgbmVlZGVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIG1vZGVscyBjdXJyZW50bHlcbiAgICogZGlzcGxheWVkLCB0eXBpY2FsbHkgZm9yIHNlbGVjdGlvbi5cbiAgICovXG5cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJEYXRhZ3JpZFJvdykgcm93czogUXVlcnlMaXN0PENsckRhdGFncmlkUm93PFQ+PjtcbiAgQFZpZXdDaGlsZCgnc2Nyb2xsYWJsZUNvbHVtbnMnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgc2Nyb2xsYWJsZUNvbHVtbnM6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmICghdGhpcy5pdGVtcy5zbWFydCkge1xuICAgICAgdGhpcy5pdGVtcy5hbGwgPSB0aGlzLnJvd3MubWFwKChyb3c6IENsckRhdGFncmlkUm93PFQ+KSA9PiByb3cuaXRlbSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5yb3dzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLml0ZW1zLnNtYXJ0KSB7XG4gICAgICAgICAgdGhpcy5pdGVtcy5hbGwgPSB0aGlzLnJvd3MubWFwKChyb3c6IENsckRhdGFncmlkUm93PFQ+KSA9PiByb3cuaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICB0aGlzLl9kaXNwbGF5ZWRSb3dzLmluc2VydChyb3cuX3ZpZXcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY29sdW1ucy5jaGFuZ2VzLnN1YnNjcmliZSgoY29sdW1uczogQ2xyRGF0YWdyaWRDb2x1bW48VD5bXSkgPT4ge1xuICAgICAgICB0aGlzLmNvbHVtblNlcnZpY2UudXBkYXRlQ29sdW1uTGlzdCh0aGlzLmNvbHVtbnMubWFwKGNvbCA9PiBjb2wuaGlkZWFibGUpKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIEdldCBDb2x1bW5TZXJ2aWNlIHJlYWR5IGZvciBIaWRlYWJsZUNvbHVtbnMuXG4gICAgdGhpcy5jb2x1bW5TZXJ2aWNlLnVwZGF0ZUNvbHVtbkxpc3QodGhpcy5jb2x1bW5zLm1hcChjb2wgPT4gY29sLmhpZGVhYmxlKSk7XG4gIH1cblxuICAvKipcbiAgICogT3VyIHNldHVwIGhhcHBlbnMgaW4gdGhlIHZpZXcgb2Ygc29tZSBvZiBvdXIgY29tcG9uZW50cywgc28gd2Ugd2FpdCBmb3IgaXQgdG8gYmUgZG9uZSBiZWZvcmUgc3RhcnRpbmdcbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBUT0RPOiBkZXRlcm1pbmUgaWYgd2UgY2FuIGdldCByaWQgb2YgcHJvdmlkZXIgd2lyaW5nIGluIHZpZXcgaW5pdCBzbyB0aGF0IHN1YnNjcmlwdGlvbnMgY2FuIGJlIGRvbmUgZWFybGllclxuICAgIHRoaXMucmVmcmVzaC5lbWl0KHRoaXMuc3RhdGVQcm92aWRlci5zdGF0ZSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuc3RhdGVQcm92aWRlci5jaGFuZ2Uuc3Vic2NyaWJlKHN0YXRlID0+IHRoaXMucmVmcmVzaC5lbWl0KHN0YXRlKSkpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmNoYW5nZS5zdWJzY3JpYmUocyA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZSkge1xuICAgICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0ZWRDaGFuZ2VkLmVtaXQoPFQ+cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5NdWx0aSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2VkLmVtaXQoPFRbXT5zKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIC8vIEEgc3Vic2NyaXB0aW9uIHRoYXQgbGlzdGVucyBmb3IgZGlzcGxheU1vZGUgY2hhbmdlcyBvbiB0aGUgZGF0YWdyaWRcbiAgICB0aGlzLmRpc3BsYXlNb2RlLnZpZXcuc3Vic2NyaWJlKHZpZXdDaGFuZ2UgPT4ge1xuICAgICAgLy8gUmVtb3ZlIGFueSBwcm9qZWN0ZWQgY29sdW1ucyBmcm9tIHRoZSBwcm9qZWN0ZWREaXNwbGF5Q29sdW1ucyBjb250YWluZXJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcm9qZWN0ZWREaXNwbGF5Q29sdW1ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5fcHJvamVjdGVkRGlzcGxheUNvbHVtbnMuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgYW55IHByb2plY3RlZCBjb2x1bW5zIGZyb20gdGhlIHByb2plY3RlZENhbGN1bGF0aW9uQ29sdW1ucyBjb250YWluZXJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMuX3Byb2plY3RlZENhbGN1bGF0aW9uQ29sdW1ucy5kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBhbnkgcHJvamVjdGVkIHJvd3MgZnJvbSB0aGUgY2FsY3VsYXRpb25Sb3dzIGNvbnRhaW5lclxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2NhbGN1bGF0aW9uUm93cy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRpb25Sb3dzLmRldGFjaCgpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGFueSBwcm9qZWN0ZWQgcm93cyBmcm9tIHRoZSBkaXNwbGF5ZWRSb3dzIGNvbnRhaW5lclxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2Rpc3BsYXllZFJvd3MubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXllZFJvd3MuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBpZiAodmlld0NoYW5nZSA9PT0gRGF0YWdyaWREaXNwbGF5TW9kZS5ESVNQTEFZKSB7XG4gICAgICAgIC8vIFNldCBzdGF0ZSwgc3R5bGUgZm9yIHRoZSBkYXRhZ3JpZCB0byBESVNQTEFZIGFuZCBpbnNlcnQgcm93ICYgY29sdW1ucyBpbnRvIGNvbnRhaW5lcnNcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1jYWxjdWxhdGUtbW9kZScpO1xuICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICAgIHRoaXMuX3Byb2plY3RlZERpc3BsYXlDb2x1bW5zLmluc2VydChjb2x1bW4uX3ZpZXcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICB0aGlzLl9kaXNwbGF5ZWRSb3dzLmluc2VydChyb3cuX3ZpZXcpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldCBzdGF0ZSwgc3R5bGUgZm9yIHRoZSBkYXRhZ3JpZCB0byBDQUxDVUxBVEUgYW5kIGluc2VydCByb3cgJiBjb2x1bW5zIGludG8gY29udGFpbmVyc1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2RhdGFncmlkLWNhbGN1bGF0ZS1tb2RlJyk7XG4gICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgdGhpcy5fcHJvamVjdGVkQ2FsY3VsYXRpb25Db2x1bW5zLmluc2VydChjb2x1bW4uX3ZpZXcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICB0aGlzLl9jYWxjdWxhdGlvblJvd3MuaW5zZXJ0KHJvdy5fdmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gYWxsIHRoZSBzZXJ2aWNlcyBhbmQgcXVlcmllcyBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHJlc2l6ZSgpOiB2b2lkIHtcbiAgICB0aGlzLm9yZ2FuaXplci5yZXNpemUoKTtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ3Byb2plY3RlZERpc3BsYXlDb2x1bW5zJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9wcm9qZWN0ZWREaXNwbGF5Q29sdW1uczogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgncHJvamVjdGVkQ2FsY3VsYXRpb25Db2x1bW5zJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9wcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnM6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ2Rpc3BsYXllZFJvd3MnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgX2Rpc3BsYXllZFJvd3M6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ2NhbGN1bGF0aW9uUm93cycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfY2FsY3VsYXRpb25Sb3dzOiBWaWV3Q29udGFpbmVyUmVmO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1hY3Rpb24tYmFyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kYXRhZ3JpZC1hY3Rpb24tYmFyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZEFjdGlvbkJhciB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuXG5pbXBvcnQgeyBSb3dBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcm93LWFjdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1hY3Rpb24tb3ZlcmZsb3cnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uIChjbGljayk9XCJ0b2dnbGUoJGV2ZW50KVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImRhdGFncmlkLWFjdGlvbi10b2dnbGVcIiAjYW5jaG9yPlxuICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZWxsaXBzaXMtdmVydGljYWxcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLnJvd0FjdGlvbnNcIj48L2Nsci1pY29uPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFsoY2xyUG9wb3Zlck9sZCldPVwib3BlblwiIFtjbHJQb3BvdmVyT2xkQW5jaG9yXT1cImFuY2hvclwiIFtjbHJQb3BvdmVyT2xkQW5jaG9yUG9pbnRdPVwiYW5jaG9yUG9pbnRcIlxuICAgICAgICAgICAgICAgICAgICAgW2NsclBvcG92ZXJPbGRQb3BvdmVyUG9pbnRdPVwicG9wb3ZlclBvaW50XCI+XG4gICAgICAgICAgICA8ZGl2ICNtZW51IGNsYXNzPVwiZGF0YWdyaWQtYWN0aW9uLW92ZXJmbG93XCIgKGNsck91dHNpZGVDbGljayk9XCJjbG9zZSgkZXZlbnQpXCIgW2NsclN0cmljdF09XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRBY3Rpb25PdmVyZmxvdyBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHB1YmxpYyBhbmNob3JQb2ludDogUG9pbnQgPSBQb2ludC5SSUdIVF9DRU5URVI7XG4gIHB1YmxpYyBwb3BvdmVyUG9pbnQ6IFBvaW50ID0gUG9pbnQuTEVGVF9DRU5URVI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByb3dBY3Rpb25TZXJ2aWNlOiBSb3dBY3Rpb25TZXJ2aWNlLCBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncykge1xuICAgIHRoaXMucm93QWN0aW9uU2VydmljZS5yZWdpc3RlcigpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yb3dBY3Rpb25TZXJ2aWNlLnVucmVnaXN0ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFja3Mgd2hldGhlciB0aGUgYWN0aW9uIG92ZXJmbG93IG1lbnUgaXMgb3BlbiBvciBub3RcbiAgICovXG4gIHByaXZhdGUgX29wZW4gPSBmYWxzZTtcbiAgcHVibGljIGdldCBvcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0FjdGlvbk92ZXJmbG93T3BlbicpXG4gIHB1YmxpYyBzZXQgb3BlbihvcGVuOiBib29sZWFuKSB7XG4gICAgY29uc3QgYm9vbE9wZW4gPSAhIW9wZW47XG4gICAgaWYgKGJvb2xPcGVuICE9PSB0aGlzLl9vcGVuKSB7XG4gICAgICB0aGlzLl9vcGVuID0gYm9vbE9wZW47XG4gICAgICB0aGlzLm9wZW5DaGFuZ2VkLmVtaXQoYm9vbE9wZW4pO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnQWN0aW9uT3ZlcmZsb3dPcGVuQ2hhbmdlJykgcHVibGljIG9wZW5DaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgLypcbiAgICAgKiBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBjbGljayB0aGF0IG9wZW5zIHRoZSBtZW51LCB0byBtYWtlIHN1cmUgaXQgZG9lc24ndCBjbG9zZSB0aGUgbWVudSBpbnN0YW50bHlcbiAgICAgKiB3aGVuIHRoZSBldmVudCBidWJibGVzIHVwIHRoZSBET00gYWxsIHRoZSB3YXkgdG8gdGhlIGRvY3VtZW50LCB3aGljaCB3ZSBhbHNvIGxpc3RlbiB0by5cbiAgICAgKi9cbiAgcHJpdmF0ZSBvcGVuaW5nRXZlbnQ6IGFueTtcblxuICAvKipcbiAgICogU2hvd3MvaGlkZXMgdGhlIGFjdGlvbiBvdmVyZmxvdyBtZW51XG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLm9wZW5pbmdFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW47XG4gIH1cblxuICBwdWJsaWMgY2xvc2UoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAvKlxuICAgICAgICAgKiBCZWNhdXNlIHRoaXMgbGlzdGVuZXIgaXMgYWRkZWQgc3luY2hvbm91c2x5LCBiZWZvcmUgdGhlIGV2ZW50IGZpbmlzaGVzIGJ1YmJsaW5nIHVwIHRoZSBET00sXG4gICAgICAgICAqIHdlIGVuZCB1cCBmaXJpbmcgb24gdGhlIHZlcnkgY2xpY2sgdGhhdCBqdXN0IG9wZW5lZCB0aGUgbWVudSwgcFxuICAgICAgICAgKiBvdGVudGlhbGx5IGNsb3NpbmcgaXQgaW1tZWRpYXRlbHkgZXZlcnkgdGltZS4gU28gd2UganVzdCBpZ25vcmUgaXQuXG4gICAgICAgICAqL1xuICAgIGlmIChldmVudCA9PT0gdGhpcy5vcGVuaW5nRXZlbnQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLm9wZW5pbmdFdmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVuID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbHVtbi10b2dnbGUtYnV0dG9ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbi10b2dnbGUtYnV0dG9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmtcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUJ1dHRvbnMuYnV0dG9uQ2xpY2tlZCgpXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJ0b2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdG9nZ2xlQnV0dG9uczogQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UpIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbi10b2dnbGUtdGl0bGUnLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtYnV0dG9uJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGUgfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtdGl0bGUnO1xuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uLXRvZ2dsZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAjYW5jaG9yXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVVJKClcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tbGluayBjb2x1bW4tdG9nZ2xlLS1hY3Rpb25cIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInZpZXctY29sdW1uc1wiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MucGlja0NvbHVtbnNcIj48L2Nsci1pY29uPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbi1zd2l0Y2hcIlxuICAgICAgICAgICAgICpjbHJQb3BvdmVyT2xkPVwib3BlbjsgYW5jaG9yOiBhbmNob3I7IGFuY2hvclBvaW50OiBhbmNob3JQb2ludDsgcG9wb3ZlclBvaW50OiBwb3BvdmVyUG9pbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2gtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiF0aXRsZVwiPlNob3cgQ29sdW1uczwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1jb2x1bW4tdG9nZ2xlLXRpdGxlXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVVJKClcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNsb3NlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5jbG9zZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cInN3aXRjaC1jb250ZW50IGxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxjbHItY2hlY2tib3gtd3JhcHBlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbHJDaGVja2JveCB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiY29sdW1uLmxhc3RWaXNpYmxlQ29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW25nTW9kZWxdPVwiIWNvbHVtbi5oaWRkZW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJ0b2dnbGVDb2x1bW4oJGV2ZW50LCBjb2x1bW4pXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWw+PG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi50ZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPC9jbHItY2hlY2tib3gtd3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2gtZm9vdGVyXCIgKm5nSWY9XCJidXR0b25zLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItZGctY29sdW1uLXRvZ2dsZS1idXR0b25cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2gtZm9vdGVyXCIgKm5nSWY9XCJidXR0b25zLmxlbmd0aCA9PT0gMFwiPlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmsgcDYgdGV4dC11cHBlcmNhc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJhbGxDb2x1bW5zVmlzaWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInNlbGVjdEFsbCgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+U2VsZWN0IEFsbFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuY29sdW1uLXN3aXRjaC13cmFwcGVyXSc6ICd0cnVlJywgJ1tjbGFzcy5hY3RpdmVdJzogJ29wZW4nIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ29sdW1uVG9nZ2xlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHByaXZhdGUgX2FsbENvbHVtbnNWaXNpYmxlOiBib29sZWFuO1xuXG4gIC8qKipcbiAgICogUG9wb3ZlciBpbml0XG4gICAqL1xuICBwdWJsaWMgYW5jaG9yUG9pbnQ6IFBvaW50ID0gUG9pbnQuVE9QX0xFRlQ7XG4gIHB1YmxpYyBwb3BvdmVyUG9pbnQ6IFBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gIHB1YmxpYyBvcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqKipcbiAgICogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIGluaXRcbiAgICovXG4gIHB1YmxpYyBjb2x1bW5zOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSA9IFtdO1xuXG4gIHB1YmxpYyBnZXQgYWxsQ29sdW1uc1Zpc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlO1xuICB9XG5cbiAgcHVibGljIHNldCBhbGxDb2x1bW5zVmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlID0gdmFsdWU7XG4gIH1cblxuICBAQ29udGVudENoaWxkKENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGUpIHRpdGxlOiBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlO1xuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uKSBidXR0b25zOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwcml2YXRlIGNvbHVtblRvZ2dsZUJ1dHRvbnM6IENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNvbHVtbkxpc3QgPT4ge1xuICAgICAgICAvLyBSZXNldCB0aGUgbGlzdCBvZiBjb2x1bW5zXG4gICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS51cGRhdGVGb3JMYXN0VmlzaWJsZUNvbHVtbigpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNWaXNpYmxlID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZTtcbiAgICAgICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkID0gdGhpcy5hbGxDb2x1bW5zVmlzaWJsZTtcblxuICAgICAgICAvLyBBZGQgb25seSB0aGUgaGlkZGVuIGNvbHVtbnMgdG8gdGhlIHRvZ2dsZXIuXG4gICAgICAgIGNvbHVtbkxpc3QuZm9yRWFjaChjb2wgPT4ge1xuICAgICAgICAgIGlmIChjb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbEJ1dHRvbkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBzZWxlY3RBbGwoKSB7XG4gICAgdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2Uuc2hvd0hpZGRlbkNvbHVtbnMoKTtcbiAgICB0aGlzLmFsbENvbHVtbnNWaXNpYmxlID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZTtcbiAgICB0aGlzLmNvbHVtblRvZ2dsZUJ1dHRvbnMuc2VsZWN0QWxsRGlzYWJsZWQgPSB0aGlzLmFsbENvbHVtbnNWaXNpYmxlO1xuICB9XG5cbiAgdG9nZ2xlQ29sdW1uKGV2ZW50OiBib29sZWFuLCBjb2x1bW46IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCkge1xuICAgIGNvbHVtbi5oaWRkZW4gPSAhZXZlbnQ7XG4gICAgdGhpcy5hbGxDb2x1bW5zVmlzaWJsZSA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNoZWNrRm9yQWxsQ29sdW1uc1Zpc2libGU7XG4gICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkID0gdGhpcy5hbGxDb2x1bW5zVmlzaWJsZTtcbiAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS51cGRhdGVGb3JMYXN0VmlzaWJsZUNvbHVtbigpO1xuICB9XG5cbiAgdG9nZ2xlVUkoKSB7XG4gICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuXG4vKlxuICogSSBkb24ndCB0aGluayB0aGlzIGRlc2VydmVzIHRvIGJlIGluIElmRXhwYW5kZWQgaXRzZWxmLFxuICogc28gSSdtIGFkZGluZyBhIHNlY29uZCBkaXJlY3RpdmUgb24gdGhlIHNhbWUgc2VsZWN0b3IgZm9yIG5vdyBqdXN0IGZvciB0aGUgZGF0YWdyaWRcbiAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklmRXhwYW5kZWRdJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkRGV0YWlsUmVnaXN0ZXJlciB7XG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgZXhwYW5kYWJsZVJvd3NDb3VudDogRXhwYW5kYWJsZVJvd3NDb3VudCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQpIHtcbiAgICAgIHRoaXMuZXhwYW5kYWJsZVJvd3NDb3VudC5yZWdpc3RlcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQpIHtcbiAgICAgIHRoaXMuZXhwYW5kYWJsZVJvd3NDb3VudC51bnJlZ2lzdGVyKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4vcHJvdmlkZXJzL3NlbGVjdGlvbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1mb290ZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdJZj1cIihzZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuTXVsdGkpICYmIChzZWxlY3Rpb24uY3VycmVudC5sZW5ndGggPiAwKVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItZm9ybS1jb250cm9sLWRpc2FibGVkXCI+XG4gICAgICAgICAgICAgIDxjbHItY2hlY2tib3gtd3JhcHBlciBjbGFzcz1cImRhdGFncmlkLWZvb3Rlci1zZWxlY3RcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgY2xyQ2hlY2tib3ggdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD1cImNoZWNrZWRcIiBkaXNhYmxlZD5cbiAgICAgICAgICAgICAgICA8bGFiZWw+e3tzZWxlY3Rpb24uY3VycmVudC5sZW5ndGh9fTwvbGFiZWw+XG4gICAgICAgICAgICA8L2Nsci1jaGVja2JveC13cmFwcGVyPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxjbHItZGctY29sdW1uLXRvZ2dsZSAqbmdJZj1cIiF0b2dnbGUgJiYgYWN0aXZlVG9nZ2xlclwiPjwvY2xyLWRnLWNvbHVtbi10b2dnbGU+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1mb290ZXItZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1wYWdpbmF0aW9uXCI+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLWZvb3Rlcl0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkRm9vdGVyPFQgPSBhbnk+IGltcGxlbWVudHMgT25Jbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uPFQ+LFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHt9XG5cbiAgcHVibGljIGFjdGl2ZVRvZ2dsZXI6IGJvb2xlYW47XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICAvKiByZWZlcmVuY2UgdG8gdGhlIGVudW0gc28gdGhhdCB0ZW1wbGF0ZSBjYW4gYWNjZXNzICovXG4gIHB1YmxpYyBTRUxFQ1RJT05fVFlQRSA9IFNlbGVjdGlvblR5cGU7XG5cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSkgdG9nZ2xlOiBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgIGNvbnN0IGhpZGRlbkNvbHVtbnNJblN1YiA9IGNoYW5nZS5maWx0ZXIoY29sID0+IGNvbCk7XG4gICAgICAgIGlmIChoaWRkZW5Db2x1bW5zSW5TdWIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlVG9nZ2xlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGhpZGRlbkNvbHVtbnMgPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5zKCkuZmlsdGVyKGNvbCA9PiBjb2wpO1xuXG4gICAgaWYgKGhpZGRlbkNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hY3RpdmVUb2dnbGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4ge1xuICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSB1dGlsaXR5IGNsYXNzIGZvciB0aGF0IGFkZHMgaGlkZS9zaG93IGZ1bmN0aW9uYWxpdHkgdG8gYSBjb2x1bW4sIGl0cyBjZWxscyBhbmQgZW5hYmxlcyBhIHRvZ2dsZXIgaW4gdGhlXG4gKiBEYXRhZ3JpZENvbHVtblRvZ2dsZSBDb21wb25lbnQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIHtcbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoaWRkZW5DaGFuZ2VzXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHN0cmVhbSBvZiBzdGF0ZSBjaGFuZ2VzIGFuIGluc3RhbmNlIG9mIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB3aWxsIGJyb2FkY2FzdCB0byBzdWJzY3JpYmVycy5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgaGlkZGVuQ2hhbmdlc1N0YXRlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBpbml0IGZ1bmN0aW9uIGZvciBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgaW5zdGFuY2VzIHRoYXQgZG9lcyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAxLiBTZXQgdmFsdWVzIGZvciB0aGUgcHJpdmF0ZSB2YXJpYWJsZXMgdGhhdCBlbmFibGUgYSBoaWRlYWJsZSBjb2x1bW5cbiAgICogMi4gQnJvYWRjYXN0IHRoZSBuZXh0IGhpZGRlbiBjaGFuZ2UgZm9yIGFueW9uZSAoYWxyZWFkeSkgc3Vic2NyaWJlZCB0byB0aGlzIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sIHByaXZhdGUgX2lkOiBzdHJpbmcsIHByaXZhdGUgX2hpZGRlbjogYm9vbGVhbiA9IGZhbHNlKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIFRlbXBsYXRlUmVmIG9mIHRoZSBEYXRhZ3JpZENvbHVtbiB0aGF0IGlzIGhpZGVhYmxlLiBUaGlzIGlzIGN1cnJlbnRseSB1c2VkIHRvXG4gICAqIHBvcHVsYXRlIHRoZSBEYXRhZ3JpZENvbHVtblRvZ2dsZSBVSSB3aXRoIHRoZSBjb3JyZWN0IENvbHVtbiBuYW1lLlxuICAgKlxuICAgKi9cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogcHVibGljIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaWQgb2YgYSBIaWRlYWJsZUNPbHVtbiBpbnN0YW5jZS4gVXNlZCBieSB0aGUgSGlkZWFibGVDT2x1bW5TZXJ2aWNlIGZvciBwYXNzaW5nXG4gICAqIHN0YXRlIGFuZCBhY3Rpb25zIGJldHdlZW4gRGF0ZUdyaWRDb2x1bW5zLCBEYXRhR3JpZENlbGxzICYgdGhlIERhdGFncmlkQ29sdW1uVG9nZ2xlIENvbXBvbmVudHMuXG4gICAqXG4gICAqL1xuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgaGlkZGVuIHZhbHVlIG9mIGEgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIGluc3RhbmNlLlxuICAgKlxuICAgKi9cbiAgZ2V0IGhpZGRlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgc2V0dGVyIGZvciBzZXR0aW5nIHRoZSBoaWRkZW4gc3RhdGUgb2YgYSBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgaW5zdGFuY2UuXG4gICAqIEl0IGFsc28gYnJvYWRjYXN0cyB0aGUgY2hhbmdlIGFmdGVyIGl0cyBzZXQuXG4gICAqXG4gICAqL1xuICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faGlkZGVuID0gdmFsdWU7XG4gICAgdGhpcy5oaWRkZW5DaGFuZ2VzU3RhdGUubmV4dCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIE9ic2VydmFibGUgZm9yIHRoZSBIaWRlYWJsZUNvbHVtbnMgaGlkZGVuIGNoYW5nZXMuXG4gICAqXG4gICAqL1xuICBnZXQgaGlkZGVuQ2hhbmdlU3RhdGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZGVuQ2hhbmdlc1N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLy8gRmxhZyB0aGlzIHRydWUgd2hlbiB0aGUgc2VydmljZSBvbmx5IGhhcyBvbmUgdmlzaWJsZSBjb2x1bW4gb3Blbi5cblxuICBwdWJsaWMgbGFzdFZpc2libGVDb2x1bW46IGJvb2xlYW4gPSBmYWxzZTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmLCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtbiB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckRnSGlkZWFibGVDb2x1bW5dJyB9KVxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RydWN0dXJhbCBkaXJlY3RpdmUgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgYSBjbHItZGctY29sdW1uIGNvbXBvbmVudC5cbiAqXG4gKiA8Y2xyLWRnLWNvbHVtbj5cbiAqICAgICAgIDxuZy1jb250YWluZXIgKmNsckRnSGlkZWFibGVDb2x1bW49XCJ7IGhpZGRlbjogdHJ1ZSB9XCI+XG4gKiAgICAgICAgICAgVXNlciBJRFxuICogICAgICAgPC9uZy1jb250YWluZXI+XG4gKiAgIDwvY2xyLWRnLWNvbHVtbj5cbiAqXG4gKiBJdCBzZXRzIHVwIHN0YXRlIGFuZCBwcm9wZXJ0aWVzIHNvIHRoYXQgY29sdW1ucyBjYW4gYmUgbWFuZ2VzIGZvciBoaWRlL3Nob3cgYnkgYSBzZXJ2aWNlIGFuZCBhbiBpbnRlcm5hbFxuICogZGF0YWdyaWQgdG9nZ2xlIGNvbXBvbmVudC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIHtcbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVc2VkIHRvIGluaXRpYWxpemUgdGhlIGNvbHVtbiB3aXRoIGVpdGhlciBoaWRkZW4gb3IgdmlzaWJsZSBzdGF0ZS5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2hpZGRlbjogYm9vbGVhbjtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldHRlciBmbiBmb3IgdGhlIEBJbnB1dCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhpcyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICogSXQgYWxsb3dzIHRoZSB1c2VyIHRvIHByZS1jb25maWd1cmUgdGhlIGNvbHVtbidzIGhpZGUvc2hvdyBzdGF0ZS4geyBoaWRkZW46IHRydWUgfVxuICAgKiBJdCdzIG1vcmUgdmVyYm9zZSBidXQgaGFzIG1vcmUgQ2xhcml0eS5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogKmNsckRnSGlkZWFibGVDb2x1bW5cbiAgICogKmNsckRnSGlkZWFibGVDb2x1bW49e2hpZGRlbjogZmFsc2V9XG4gICAqICpjbHJEZ0hpZGVhYmxlQ29sdW1uPXtoaWRkZW46IHRydWV9XG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NsckRnSGlkZWFibGVDb2x1bW4nKVxuICBzZXQgY2xyRGdIaWRlYWJsZUNvbHVtbih2YWx1ZTogeyBoaWRkZW46IGJvb2xlYW4gfSkge1xuICAgIHRoaXMuY2xyRGdIaWRkZW4gPSB2YWx1ZSAmJiB2YWx1ZS5oaWRkZW4gPyB2YWx1ZS5oaWRkZW4gOiBmYWxzZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdIaWRkZW4nKVxuICBzZXQgY2xyRGdIaWRkZW4oaGlkZGVuOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGlkZGVuID0gaGlkZGVuID8gaGlkZGVuIDogZmFsc2U7XG4gICAgaWYgKHRoaXMuZGdDb2x1bW4uaGlkZWFibGUpIHtcbiAgICAgIHRoaXMuZGdDb2x1bW4uaGlkZWFibGUuaGlkZGVuID0gdGhpcy5faGlkZGVuO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnSGlkZGVuQ2hhbmdlJykgcHVibGljIGhpZGRlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcGFzc2VkIGludG8gdGhlIGRpcmVjdGl2ZSBmcm9tIHRoZSBwYXJlbnQgKEEgRGF0YWdyaWRDb2x1bW4pLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGNvbHVtbklkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiBVdGlsaXR5IGNsYXNzIHRoYXQgaXMgdXNlZCB0bzpcbiAgICogMS4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEhpZGVhYmxlQ29sdW1uIHRoYXQgd2lsbCBtYW5hZ2UgdGhlIFRlbXBsYXRlUmVmLCBzdGF0ZSBhbmQgY29tbXVuaWNhdGlvblxuICAgKiAyLiBNYW5hZ2UgdGhlIGhpZGRlbi9zaG93biBzdGF0ZSBmb3IgdGhlIGNvbHVtbiB0byB3aGljaCB0aGlzIGRpcmVjdGl2ZSBpcyBhcHBsaWVkXG4gICAqIDMuIHRyYWNrIHRoZSBpZCBvZiB0aGUgaGlkZGVuIGNvbHVtbiBzbyBpdCBjYW4gYmUgdXNlZCBpbiBjZWxscyBhcyB3ZWxsIGFzIG9uIHRoZSBjb2x1bW5cbiAgICovXG4gIHB1YmxpYyBjb2x1bW46IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbDtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFVzZWQgdGhlIERhdGFncmlkQ29sdW1uIHRvIGdldCBhbmQgc2V0IGFuIGlkIGZvciB0aGlzIEhpZGRlbkNvbHVtblxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBkZ0NvbHVtbjogQ2xyRGF0YWdyaWRDb2x1bW48YW55PlxuICApIHtcbiAgICB0aGlzLmNvbHVtbklkID0gZGdDb2x1bW4uY29sdW1uSWQ7XG5cbiAgICAvLyBVc2UgdGhlIHRlbXBsYXRlUmVmIHRvIGNyZWF0ZSB0aGlzIHZpZXdcbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGVSZWYpO1xuXG4gICAgLy8gQ3JlYXRlIGluc3RhbmNlIG9mIHRoZSB1dGlsaXR5IGNsYXNzIERhdGFncmlkSGlkZWFibGVDb2x1bW4uXG4gICAgLy8gTm90ZSB0aGlzIGlzIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgRGF0YWdyaWRDb2x1bW4uXG4gICAgdGhpcy5kZ0NvbHVtbi5oaWRlYWJsZSA9IG5ldyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwodGhpcy50ZW1wbGF0ZVJlZiwgdGhpcy5jb2x1bW5JZCwgdGhpcy5faGlkZGVuKTtcbiAgICB0aGlzLmRnQ29sdW1uLmhpZGVhYmxlLmhpZGRlbkNoYW5nZVN0YXRlLnN1YnNjcmliZShzdGF0ZSA9PiB0aGlzLmhpZGRlbkNoYW5nZS5lbWl0KHN0YXRlKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9wdGlvbmFsLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSXRlbXMgfSBmcm9tICcuL3Byb3ZpZGVycy9pdGVtcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuZ0ZvclRyYWNrQnldJyxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRJdGVtc1RyYWNrQnk8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIF9pdGVtczogSXRlbXM8VD4pIHt9XG5cbiAgQElucHV0KCduZ0ZvclRyYWNrQnknKVxuICBzZXQgdHJhY2tCeSh2YWx1ZTogVHJhY2tCeUZ1bmN0aW9uPFQ+KSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9pdGVtcy50cmFja0J5ID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1wYWdlLXNpemUnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLXNlbGVjdC13cmFwcGVyXCI+XG4gICAgICA8c2VsZWN0IFtjbGFzcy5jbHItcGFnZS1zaXplLXNlbGVjdF09XCJ0cnVlXCIgWyhuZ01vZGVsKV09XCJwYWdlLnNpemVcIj5cbiAgICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIHBhZ2VTaXplT3B0aW9uc1wiIFtuZ1ZhbHVlXT1cIm9wdGlvblwiPnt7b3B0aW9ufX08L29wdGlvbj5cbiAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFBhZ2VTaXplIHtcbiAgQElucHV0KCdjbHJQYWdlU2l6ZU9wdGlvbnMnKSBwYWdlU2l6ZU9wdGlvbnM6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlOiBQYWdlKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICghdGhpcy5wYWdlU2l6ZU9wdGlvbnMgfHwgdGhpcy5wYWdlU2l6ZU9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VTaXplT3B0aW9ucyA9IFt0aGlzLnBhZ2Uuc2l6ZV07XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQYWdlU2l6ZSB9IGZyb20gJy4vZGF0YWdyaWQtcGFnZS1zaXplJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXBhZ2luYXRpb24nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uLXNpemVcIiAqbmdJZj1cIl9wYWdlU2l6ZUNvbXBvbmVudFwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLXBhZ2Utc2l6ZVwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicGFnaW5hdGlvbi1kZXNjcmlwdGlvblwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uLWxpc3RcIiAqbmdJZj1cInBhZ2UubGFzdCA+IDFcIj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJwYWdpbmF0aW9uLWZpcnN0XCIgW2Rpc2FibGVkXT1cInBhZ2UuY3VycmVudCA8PSAxXCIgKGNsaWNrKT1cInBhZ2UuY3VycmVudCA9IDFcIj5cbiAgICAgICAgPGNsci1pY29uIHNoYXBlPVwic3RlcC1mb3J3YXJkLTIgZG93blwiPjwvY2xyLWljb24+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJwYWdpbmF0aW9uLXByZXZpb3VzXCIgW2Rpc2FibGVkXT1cInBhZ2UuY3VycmVudCA8PSAxXCIgKGNsaWNrKT1cInBhZ2UuY3VycmVudCA9IHBhZ2UuY3VycmVudCAtIDFcIj5cbiAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiYW5nbGUgbGVmdFwiPjwvY2xyLWljb24+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxpbnB1dCAjY3VycmVudFBhZ2VJbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwicGFnaW5hdGlvbi1jdXJyZW50XCIgW3NpemVdPVwicGFnZS5sYXN0LnRvU3RyaW5nKCkubGVuZ3RoXCIgW3ZhbHVlXT1cInBhZ2UuY3VycmVudFwiXG4gICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwidXBkYXRlQ3VycmVudFBhZ2UoJGV2ZW50KVwiIChibHVyKT1cInVwZGF0ZUN1cnJlbnRQYWdlKCRldmVudClcIi8+Jm5ic3A7LyZuYnNwOzxzcGFuPnt7cGFnZS5sYXN0fX08L3NwYW4+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwicGFnaW5hdGlvbi1uZXh0XCIgW2Rpc2FibGVkXT1cInBhZ2UuY3VycmVudCA+PSBwYWdlLmxhc3RcIiAoY2xpY2spPVwicGFnZS5jdXJyZW50ID0gcGFnZS5jdXJyZW50ICsgMVwiPlxuICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJhbmdsZSByaWdodFwiPjwvY2xyLWljb24+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJwYWdpbmF0aW9uLWxhc3RcIiBbZGlzYWJsZWRdPVwicGFnZS5jdXJyZW50ID49IHBhZ2UubGFzdFwiIChjbGljayk9XCJwYWdlLmN1cnJlbnQgPSBwYWdlLmxhc3RcIj5cbiAgICAgICAgPGNsci1pY29uIHNoYXBlPVwic3RlcC1mb3J3YXJkLTIgdXBcIj48L2Nsci1pY29uPlxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLnBhZ2luYXRpb25dJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkUGFnaW5hdGlvbiBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZFBhZ2VTaXplKSBfcGFnZVNpemVDb21wb25lbnQ6IENsckRhdGFncmlkUGFnZVNpemU7XG4gIEBWaWV3Q2hpbGQoJ2N1cnJlbnRQYWdlSW5wdXQnKSBjdXJyZW50UGFnZUlucHV0UmVmOiBFbGVtZW50UmVmO1xuXG4gIHByaXZhdGUgZGVmYXVsdFNpemUgPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlOiBQYWdlKSB7fVxuXG4gIC8qKioqKioqKioqXG4gICAqIFN1YnNjcmlwdGlvbiB0byB0aGUgUGFnZSBzZXJ2aWNlIGZvciBwYWdlIGNoYW5nZXMuXG4gICAqIE5vdGU6IHRoaXMgb25seSBlbWl0cyBhZnRlciB0aGUgZGF0YWdyaWQgaXMgaW5pdGlhbGl6ZWQvc3RhYmFsaXplZCBhbmQgdGhlIHBhZ2UgY2hhbmdlcy5cbiAgICovXG4gIG5nT25Jbml0KCkge1xuICAgIC8qXG4gICAgICogRGVmYXVsdCBwYWdlIHNpemUgaXMgMTAuXG4gICAgICogVGhlIHJlYXNvbiB3ZSBzZXQgaXQgaW4gdGhpcyBjb25zdHJ1Y3RvciBhbmQgbm90IGluIHRoZSBwcm92aWRlciBpdHNlbGYgaXMgYmVjYXVzZVxuICAgICAqIHdlIGRvbid0IHdhbnQgcGFnaW5hdGlvbiAocGFnZSBzaXplIDApIGlmIHRoaXMgY29tcG9uZW50IGlzbid0IHByZXNlbnQgaW4gdGhlIGRhdGFncmlkLlxuICAgICAqL1xuICAgIGlmICh0aGlzLmRlZmF1bHRTaXplKSB7XG4gICAgICB0aGlzLnBhZ2Uuc2l6ZSA9IDEwO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlU3Vic2NyaXB0aW9uID0gdGhpcy5wYWdlLmNoYW5nZS5zdWJzY3JpYmUoY3VycmVudCA9PiB0aGlzLmN1cnJlbnRDaGFuZ2VkLmVtaXQoY3VycmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbiB0byB0aGUgcGFnZSBzZXJ2aWNlIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX3BhZ2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnBhZ2UucmVzZXRQYWdlU2l6ZSgpO1xuICAgIGlmICh0aGlzLl9wYWdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9wYWdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhZ2Ugc2l6ZVxuICAgKi9cbiAgcHVibGljIGdldCBwYWdlU2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2Uuc2l6ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdQYWdlU2l6ZScpXG4gIHB1YmxpYyBzZXQgcGFnZVNpemUoc2l6ZTogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5kZWZhdWx0U2l6ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5wYWdlLnNpemUgPSBzaXplO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb3RhbCBpdGVtcyAobmVlZGVkIHRvIGd1ZXNzIHRoZSBsYXN0IHBhZ2UpXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRvdGFsSXRlbXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLnRvdGFsSXRlbXM7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnVG90YWxJdGVtcycpXG4gIHB1YmxpYyBzZXQgdG90YWxJdGVtcyh0b3RhbDogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiB0b3RhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFnZS50b3RhbEl0ZW1zID0gdG90YWw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExhc3QgcGFnZVxuICAgKi9cbiAgcHVibGljIGdldCBsYXN0UGFnZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2UubGFzdDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdMYXN0UGFnZScpXG4gIHB1YmxpYyBzZXQgbGFzdFBhZ2UobGFzdDogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYWdlLmxhc3QgPSBsYXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHBhZ2VcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudFBhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmN1cnJlbnQ7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnUGFnZScpXG4gIHB1YmxpYyBzZXQgY3VycmVudFBhZ2UocGFnZTogbnVtYmVyKSB7XG4gICAgaWYgKHR5cGVvZiBwYWdlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYWdlLmN1cnJlbnQgPSBwYWdlO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnUGFnZUNoYW5nZScpIGN1cnJlbnRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KGZhbHNlKTtcblxuICAvKipcbiAgICogTW92ZXMgdG8gdGhlIHByZXZpb3VzIHBhZ2UgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgcHJldmlvdXMoKSB7XG4gICAgdGhpcy5wYWdlLnByZXZpb3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdG8gdGhlIG5leHQgcGFnZSBpZiBpdCBleGlzdHNcbiAgICovXG4gIHB1YmxpYyBuZXh0KCkge1xuICAgIHRoaXMucGFnZS5uZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHBhZ2UsIHN0YXJ0aW5nIGF0IDBcbiAgICovXG4gIHB1YmxpYyBnZXQgZmlyc3RJdGVtKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5maXJzdEl0ZW07XG4gIH1cblxuICAvKipcbiAgICogSW5kZXggb2YgdGhlIGxhc3QgaXRlbSBkaXNwbGF5ZWQgb24gdGhlIGN1cnJlbnQgcGFnZSwgc3RhcnRpbmcgYXQgMFxuICAgKi9cbiAgcHVibGljIGdldCBsYXN0SXRlbSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2UubGFzdEl0ZW07XG4gIH1cblxuICAvKipcbiAgICogQ29uZGl0aW9uYWxseSBhZGRzIHBhZ2UgbnVtYmVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjdXJyZW50IHBhZ2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbWlkZGxlUGFnZXMoKTogbnVtYmVyW10ge1xuICAgIGNvbnN0IG1pZGRsZVBhZ2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIGlmICh0aGlzLnBhZ2UuY3VycmVudCA+IDEpIHtcbiAgICAgIG1pZGRsZVBhZ2VzLnB1c2godGhpcy5wYWdlLmN1cnJlbnQgLSAxKTtcbiAgICB9XG4gICAgbWlkZGxlUGFnZXMucHVzaCh0aGlzLnBhZ2UuY3VycmVudCk7XG4gICAgaWYgKHRoaXMucGFnZS5jdXJyZW50IDwgdGhpcy5wYWdlLmxhc3QpIHtcbiAgICAgIG1pZGRsZVBhZ2VzLnB1c2godGhpcy5wYWdlLmN1cnJlbnQgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIG1pZGRsZVBhZ2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIG9ubHkgdXBkYXRlIHRoZSBwYWdpbmF0aW9uJ3MgY3VycmVudCBwYWdlIG9uIGJsdXIgb2YgdGhlIGlucHV0IGZpZWxkLCBvclxuICAgKiB3aGVuIHRoZXkgcHJlc3MgZW50ZXIuXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ3VycmVudFBhZ2UoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KGV2ZW50LnRhcmdldC52YWx1ZSwgMTApO1xuXG4gICAgLy8gaWYgdGhlIGlucHV0IHZhbHVlLCBpcyBub3QgYSBudW1iZXIsIHdlIGRvbid0IHVwZGF0ZSB0aGUgcGFnZVxuICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xuICAgICAgaWYgKHBhcnNlZCA8IDEpIHtcbiAgICAgICAgdGhpcy5wYWdlLmN1cnJlbnQgPSAxO1xuICAgICAgfSBlbHNlIGlmIChwYXJzZWQgPiB0aGlzLnBhZ2UubGFzdCkge1xuICAgICAgICB0aGlzLnBhZ2UuY3VycmVudCA9IHRoaXMucGFnZS5sYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYWdlLmN1cnJlbnQgPSBwYXJzZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBpbnB1dCdzIHZhbHVlIHRvIHRoZSBuZXcgY3VycmVudCBwYWdlLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBjb2RlXG4gICAgICogYWJvdmUgbWF5IGhhdmUgY2hhbmdlZCB0aGUgdmFsdWUgZnJvbSB3aGF0IHRoZSB1c2VyIGVudGVyZWQgaW4uXG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50UGFnZUlucHV0UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB0aGlzLnBhZ2UuY3VycmVudDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIElucHV0LCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDZWxsIH0gZnJvbSAnLi9kYXRhZ3JpZC1jZWxsJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJvd0FjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi9wcm92aWRlcnMvc2VsZWN0aW9uJztcblxuLyoqXG4gKiBHZW5lcmljIGJsYW5kIGNvbnRhaW5lciBzZXJ2aW5nIHZhcmlvdXMgcHVycG9zZXMgZm9yIERhdGFncmlkLlxuICogRm9yIGluc3RhbmNlLCBpdCBjYW4gaGVscCBzcGFuIGEgdGV4dCBvdmVyIG11bHRpcGxlIHJvd3MgaW4gZGV0YWlsIHZpZXcuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1yb3ctZGV0YWlsJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFyZXBsYWNlZFJvd1wiPlxuICAgICAgICAgICAgPCEtLSBzcGFjZSBmb3IgbXVsdGlzZWxlY3Rpb24gc3RhdGUgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtY2VsbCBkYXRhZ3JpZC1zZWxlY3QgZGF0YWdyaWQtZml4ZWQtY29sdW1uXCJcbiAgICAgICAgICAgICAgICAqbmdJZj1cInNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTRUxFQ1RJT05fVFlQRS5NdWx0aVwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tIHNwYWNlIGZvciBzaW5nbGUgc2VsZWN0aW9uIHN0YXRlIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNlbGwgZGF0YWdyaWQtc2VsZWN0IGRhdGFncmlkLWZpeGVkLWNvbHVtblwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuU2luZ2xlXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gc3BhY2UgZm9yIHNpbmdsZSByb3cgYWN0aW9uOyBvbmx5IGRpc3BsYXlUeXBlIGlmIHdlIGhhdmUgYXQgbGVhc3Qgb25lIGFjdGlvbmFibGUgcm93IGluIGRhdGFncmlkIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNlbGwgZGF0YWdyaWQtcm93LWFjdGlvbnMgZGF0YWdyaWQtZml4ZWQtY29sdW1uXCJcbiAgICAgICAgICAgICAgICAqbmdJZj1cInJvd0FjdGlvblNlcnZpY2UuaGFzQWN0aW9uYWJsZVJvd1wiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tIHNwYWNlIGZvciBleHBhbmRhYmxlIGNhcmV0IGFjdGlvbjsgb25seSBkaXNwbGF5VHlwZSBpZiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBleHBhbmRhYmxlIHJvdyBpbiBkYXRhZ3JpZCAtLT5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJleHBhbmRhYmxlUm93cy5oYXNFeHBhbmRhYmxlUm93XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZGF0YWdyaWQtZXhwYW5kYWJsZS1jYXJldCBkYXRhZ3JpZC1maXhlZC1jb2x1bW4gZGF0YWdyaWQtY2VsbFwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0YWdyaWQtcm93LWZsZXhdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuZGF0YWdyaWQtcm93LWRldGFpbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1jb250YWluZXJdJzogJ2NlbGxzLmxlbmd0aCA9PT0gMCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkUm93RGV0YWlsPFQgPSBhbnk+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgLyogcmVmZXJlbmNlIHRvIHRoZSBlbnVtIHNvIHRoYXQgdGVtcGxhdGUgY2FuIGFjY2VzcyBpdCAqL1xuICBwdWJsaWMgU0VMRUNUSU9OX1RZUEUgPSBTZWxlY3Rpb25UeXBlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBzZWxlY3Rpb246IFNlbGVjdGlvbixcbiAgICBwdWJsaWMgcm93QWN0aW9uU2VydmljZTogUm93QWN0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgZXhwYW5kOiBFeHBhbmQsXG4gICAgcHVibGljIGhpZGVhYmxlQ29sdW1uU2VydmljZTogSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIHB1YmxpYyBleHBhbmRhYmxlUm93czogRXhwYW5kYWJsZVJvd3NDb3VudFxuICApIHt9XG5cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJEYXRhZ3JpZENlbGwpIGNlbGxzOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRDZWxsPjtcblxuICBASW5wdXQoJ2NsckRnUmVwbGFjZScpXG4gIHNldCByZXBsYWNlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5leHBhbmQuc2V0UmVwbGFjZSghIXZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHVibGljIHJlcGxhY2VkUm93ID0gZmFsc2U7XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGNvbnN0IGNvbHVtbnNMaXN0ID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpO1xuICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbnNMaXN0KTtcblxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSBDZWxscyBsaXN0IGNoYW5nZXMgcGVyIHJvdy1yZW5kZXJlclxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jZWxscy5jaGFuZ2VzLnN1YnNjcmliZShjZWxsTGlzdCA9PiB7XG4gICAgICAgIGNvbnN0IGNvbHVtbkxpc3QgPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5zKCk7XG4gICAgICAgIGlmIChjZWxsTGlzdC5sZW5ndGggPT09IGNvbHVtbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIFVzZWQgdG8gc2V0IHRoaW5ncyB1cCB0aGUgZmlyc3QgdGltZSBidXQgb25seSBhZnRlciBhbGwgdGhlIGNvbHVtbnMgYXJlIHJlYWR5LlxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuY29sdW1uTGlzdENoYW5nZS5zdWJzY3JpYmUoY29sdW1uTGlzdCA9PiB7XG4gICAgICAgIC8vIFByZXZlbnRzIGNlbGwgdXBkYXRlcyB3aGVuIGNvbHMgYW5kIGNlbGxzIGFycmF5IGFyZSBub3QgYWxpZ25lZFxuICAgICAgICBpZiAoY29sdW1uTGlzdC5sZW5ndGggPT09IHRoaXMuY2VsbHMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5leHBhbmQucmVwbGFjZS5zdWJzY3JpYmUocmVwbGFjZUNoYW5nZSA9PiB7XG4gICAgICAgIHRoaXMucmVwbGFjZWRSb3cgPSByZXBsYWNlQ2hhbmdlO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUNlbGxzRm9yQ29sdW1ucyhjb2x1bW5MaXN0OiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSkge1xuICAgIHRoaXMuY2VsbHMuZm9yRWFjaCgoY2VsbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW4gPSBjb2x1bW5MaXN0W2luZGV4XTsgLy8gQWNjb3VudHMgZm9yIG51bGwgc3BhY2UuXG4gICAgICBpZiAoY3VycmVudENvbHVtbikge1xuICAgICAgICBjZWxsLmlkID0gY3VycmVudENvbHVtbi5pZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGNvbnN0IE5PX0xBWU9VVF9DTEFTUyA9ICdkYXRhZ3JpZC1uby1sYXlvdXQnO1xuZXhwb3J0IGNvbnN0IENPTVBVVEVfV0lEVEhfQ0xBU1MgPSAnZGF0YWdyaWQtY29tcHV0aW5nLWNvbHVtbnMtd2lkdGgnO1xuZXhwb3J0IGNvbnN0IFNUUklDVF9XSURUSF9DTEFTUyA9ICdkYXRhZ3JpZC1maXhlZC13aWR0aCc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5cbmltcG9ydCB7IFNUUklDVF9XSURUSF9DTEFTUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi9yZW5kZXItb3JnYW5pemVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRnLWNlbGwnIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRDZWxsUmVuZGVyZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIG9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIG9yZ2FuaXplci5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuQ0xFQVJfV0lEVEhTKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbGVhcldpZHRoKCkpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJXaWR0aCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgbnVsbCk7XG4gIH1cblxuICBwdWJsaWMgc2V0V2lkdGgoc3RyaWN0OiBib29sZWFuLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFNUUklDVF9XSURUSF9DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCBTVFJJQ1RfV0lEVEhfQ0xBU1MpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgdmFsdWUgKyAncHgnKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERyYWdEaXNwYXRjaGVyIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2RyYWctZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBUYWJsZVNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL3RhYmxlLXNpemUuc2VydmljZSc7XG5cbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyLW9yZ2FuaXplcic7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4nLCBwcm92aWRlcnM6IFtEcmFnRGlzcGF0Y2hlcl0gfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZENvbHVtblJlc2l6ZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyLFxuICAgIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcixcbiAgICBwcml2YXRlIGRyYWdEaXNwYXRjaGVyOiBEcmFnRGlzcGF0Y2hlcixcbiAgICBwcml2YXRlIHRhYmxlOiBUYWJsZVNpemVTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuY29sdW1uRWwgPSBlbC5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgY29sdW1uRWw6IGFueTtcbiAgY29sdW1uUmVjdFdpZHRoOiBudW1iZXI7XG4gIGNvbHVtblJlc2l6ZUJ5OiBudW1iZXIgPSAwO1xuXG4gIGhhbmRsZVRyYWNrZXJFbDogRWxlbWVudFJlZjtcblxuICBwYWdlU3RhcnRQb3NpdGlvblg6IG51bWJlcjtcbiAgZHJhZ0Rpc3RhbmNlUG9zaXRpb25YOiBudW1iZXI7IC8vIHJlbGF0aXZlIHRvIHBhZ2VTdGFydFBvc2l0aW9uXG5cbiAgZHJhZ1dpdGhpbk1pbldpZHRoOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29sdW1uTWluV2lkdGg6IG51bWJlcjtcblxuICBAT3V0cHV0KCdjbHJEZ0NvbHVtblJlc2l6ZScpIHJlc2l6ZUVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmRyYWdEaXNwYXRjaGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLmhhbmRsZVRyYWNrZXJFbCA9IHRoaXMuZHJhZ0Rpc3BhdGNoZXIuaGFuZGxlVHJhY2tlclJlZi5uYXRpdmVFbGVtZW50O1xuICAgIHRoaXMuZHJhZ0Rpc3BhdGNoZXIuYWRkRHJhZ0xpc3RlbmVyKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5kcmFnRGlzcGF0Y2hlci5vbkRyYWdTdGFydC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kcmFnU3RhcnRIYW5kbGVyKCkpKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLmRyYWdEaXNwYXRjaGVyLm9uRHJhZ01vdmUuc3Vic2NyaWJlKCRldmVudCA9PiB0aGlzLmRyYWdNb3ZlSGFuZGxlcigkZXZlbnQpKSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5kcmFnRGlzcGF0Y2hlci5vbkRyYWdFbmQuc3Vic2NyaWJlKCgpID0+IHRoaXMuZHJhZ0VuZEhhbmRsZXIoKSkpO1xuICB9XG5cbiAgZHJhZ1N0YXJ0SGFuZGxlcigpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY29sdW1uTWluV2lkdGgpIHtcbiAgICAgIC8vIHNldHMgdGhlIG1pbiB3aWR0aCBvbmx5IG9uIHRoZSB2ZXJ5IGZpcnN0IGRyYWcgYXR0ZW1wdFxuICAgICAgdGhpcy5jb2x1bW5NaW5XaWR0aCA9IHRoaXMuZG9tQWRhcHRlci5taW5XaWR0aCh0aGlzLmNvbHVtbkVsKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmhhbmRsZVRyYWNrZXJFbCwgJ2Rpc3BsYXknLCAnYmxvY2snKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuaGFuZGxlVHJhY2tlckVsLCAnaGVpZ2h0JywgdGhpcy50YWJsZS5nZXRDb2x1bW5EcmFnSGVpZ2h0KCkpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgJ2N1cnNvcicsICdjb2wtcmVzaXplJyk7XG4gICAgdGhpcy5kcmFnRGlzdGFuY2VQb3NpdGlvblggPSAwO1xuICAgIHRoaXMuY29sdW1uUmVjdFdpZHRoID0gdGhpcy5kb21BZGFwdGVyLmNsaWVudFJlY3QodGhpcy5jb2x1bW5FbCkud2lkdGg7XG4gICAgdGhpcy5wYWdlU3RhcnRQb3NpdGlvblggPSB0aGlzLmRvbUFkYXB0ZXIuY2xpZW50UmVjdCh0aGlzLmNvbHVtbkVsKS5yaWdodDtcbiAgfVxuXG4gIGRyYWdNb3ZlSGFuZGxlcihtb3ZlRXZlbnQ6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHBhZ2VNb3ZlUG9zaXRpb24gPSBtb3ZlRXZlbnQucGFnZVggfHwgbW92ZUV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xuICAgIHRoaXMuZHJhZ0Rpc3RhbmNlUG9zaXRpb25YID0gdGhpcy5nZXRQb3NpdGlvbldpdGhpbk1heChwYWdlTW92ZVBvc2l0aW9uIC0gdGhpcy5wYWdlU3RhcnRQb3NpdGlvblgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5oYW5kbGVUcmFja2VyRWwsICdyaWdodCcsIC0xICogdGhpcy5kcmFnRGlzdGFuY2VQb3NpdGlvblggKyAncHgnKTtcbiAgfVxuXG4gIGRyYWdFbmRIYW5kbGVyKCk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5oYW5kbGVUcmFja2VyRWwsICdyaWdodCcsICcwcHgnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuaGFuZGxlVHJhY2tlckVsLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkb2N1bWVudC5ib2R5LCAnY3Vyc29yJywgJ2F1dG8nKTtcblxuICAgIGlmICh0aGlzLmRyYWdEaXN0YW5jZVBvc2l0aW9uWCkge1xuICAgICAgdGhpcy5jb2x1bW5SZXNpemVCeSA9IHRoaXMuZHJhZ0Rpc3RhbmNlUG9zaXRpb25YO1xuXG4gICAgICB0aGlzLnJlc2l6ZUVtaXR0ZXIuZW1pdCh0aGlzLmNvbHVtblJlY3RXaWR0aCArIHRoaXMuY29sdW1uUmVzaXplQnkpO1xuICAgICAgdGhpcy5vcmdhbml6ZXIucmVzaXplKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9zaXRpb25XaXRoaW5NYXgoZHJhZ2dlZERpc3RhbmNlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGlmIChkcmFnZ2VkRGlzdGFuY2UgPCAwKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoZHJhZ2dlZERpc3RhbmNlKSA8IHRoaXMuY29sdW1uUmVjdFdpZHRoIC0gdGhpcy5jb2x1bW5NaW5XaWR0aCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnV2l0aGluTWluV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLmRyYWdXaXRoaW5NaW5XaWR0aCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5oYW5kbGVUcmFja2VyRWwsICdleGNlZWRlZC1tYXgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHJhZ2dlZERpc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyYWdXaXRoaW5NaW5XaWR0aCkge1xuICAgICAgICAgIHRoaXMuZHJhZ1dpdGhpbk1pbldpZHRoID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuaGFuZGxlVHJhY2tlckVsLCAnZXhjZWVkZWQtbWF4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uTWluV2lkdGggLSB0aGlzLmNvbHVtblJlY3RXaWR0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuZHJhZ1dpdGhpbk1pbldpZHRoKSB7XG4gICAgICAgIHRoaXMuZHJhZ1dpdGhpbk1pbldpZHRoID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5oYW5kbGVUcmFja2VyRWwsICdleGNlZWRlZC1tYXgnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRyYWdnZWREaXN0YW5jZTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlclN0ZXAgfSBmcm9tICcuLi9lbnVtcy9yZW5kZXItc3RlcC5lbnVtJztcblxuaW1wb3J0IHsgRGF0YWdyaWRDb2x1bW5SZXNpemVyIH0gZnJvbSAnLi9jb2x1bW4tcmVzaXplcic7XG5pbXBvcnQgeyBTVFJJQ1RfV0lEVEhfQ0xBU1MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuL3JlbmRlci1vcmdhbml6ZXInO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkSGVhZGVyUmVuZGVyZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIG9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIsXG4gICAgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgIHByaXZhdGUgY29sdW1uUmVzaXplcjogRGF0YWdyaWRDb2x1bW5SZXNpemVyXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5vcmdhbml6ZXIuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkNMRUFSX1dJRFRIUykuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xlYXJXaWR0aCgpKVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm9yZ2FuaXplclxuICAgICAgICAuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkRFVEVDVF9TVFJJQ1RfV0lEVEhTKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuZGV0ZWN0U3RyaWN0V2lkdGgoKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGhhcyBhIHN0cmljdCB3aWR0aCwgc28gaXQgZG9lc24ndCBzaHJpbmsgb3IgZXhwYW5kIGJhc2VkIG9uIHRoZSBjb250ZW50LlxuICAgKi9cbiAgcHVibGljIHN0cmljdFdpZHRoOiBudW1iZXI7XG4gIHByaXZhdGUgd2lkdGhTZXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyV2lkdGgoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSB3aWR0aCBvbmx5IGlmIHdlIHNldCBpdCwgYW5kIGl0IGlzIG5vdCBjaGFuZ2VkIGJ5IGRyYWdnaW5nLlxuICAgIGlmICh0aGlzLndpZHRoU2V0ICYmICF0aGlzLmNvbHVtblJlc2l6ZXIuY29sdW1uUmVzaXplQnkpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRldGVjdFN0cmljdFdpZHRoKCkge1xuICAgIGlmICh0aGlzLmNvbHVtblJlc2l6ZXIuY29sdW1uUmVzaXplQnkpIHtcbiAgICAgIHRoaXMuc3RyaWN0V2lkdGggPSB0aGlzLmNvbHVtblJlc2l6ZXIuY29sdW1uUmVjdFdpZHRoICsgdGhpcy5jb2x1bW5SZXNpemVyLmNvbHVtblJlc2l6ZUJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0cmljdFdpZHRoID0gdGhpcy5kb21BZGFwdGVyLnVzZXJEZWZpbmVkV2lkdGgodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY29tcHV0ZVdpZHRoKCk6IG51bWJlciB7XG4gICAgbGV0IHdpZHRoOiBudW1iZXIgPSB0aGlzLnN0cmljdFdpZHRoO1xuICAgIGlmICghd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5kb21BZGFwdGVyLnNjcm9sbFdpZHRoKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbiAgfVxuXG4gIHB1YmxpYyBzZXRXaWR0aCh3aWR0aDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuc3RyaWN0V2lkdGgpIHtcbiAgICAgIGlmICh0aGlzLmNvbHVtblJlc2l6ZXIuY29sdW1uUmVzaXplQnkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIHdpZHRoICsgJ3B4Jyk7XG4gICAgICAgIHRoaXMuY29sdW1uUmVzaXplci5jb2x1bW5SZXNpemVCeSA9IDA7XG4gICAgICAgIHRoaXMud2lkdGhTZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHNldCB3aWR0aCBpZiB0aGVyZSBpcyBhIHVzZXItZGVmaW5lZCBvbmUuIEp1c3QgYWRkIHRoZSBzdHJpY3Qgd2lkdGggY2xhc3MuXG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFNUUklDVF9XSURUSF9DTEFTUyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIHdpZHRoICsgJ3B4Jyk7XG4gICAgdGhpcy53aWR0aFNldCA9IHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLypcbiAqIFRoaXMgdmVyc2lvbiBvZiB0aGUgRG9tQWRhcHRlciBpcyBmb3IgdXNlIG9uIG5vbi1icm93c2VyIHBsYXRmb3Jtcywgd2hlcmUgdGhlcmUgYXJlIG5vXG4gKiBuYXRpdmVFbGVtZW50cyB0byB1c2UgZm9yIGNhbGN1bGF0aW9ucy5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTm9vcERvbUFkYXB0ZXIgaW1wbGVtZW50cyBEb21BZGFwdGVyIHtcbiAgdXNlckRlZmluZWRXaWR0aChlbGVtZW50OiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgc2Nyb2xsQmFyV2lkdGgoZWxlbWVudDogYW55KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBzY3JvbGxXaWR0aChlbGVtZW50OiBhbnkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbXB1dGVkSGVpZ2h0KGVsZW1lbnQ6IGFueSk6IG51bWJlciB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjbGllbnRSZWN0KGVsZW1lbnQ6IGFueSk6IENsaWVudFJlY3Qge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICB9O1xuICB9XG5cbiAgbWluV2lkdGgoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGZvY3VzKGVsZW1lbnQ6IGFueSk6IHZvaWQge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0NoZWNrZWQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBPbkRlc3Ryb3ksXG4gIFBMQVRGT1JNX0lELFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW4gfSBmcm9tICcuLi9kYXRhZ3JpZC1jb2x1bW4nO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4uL3Byb3ZpZGVycy9pdGVtcyc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL3BhZ2UnO1xuaW1wb3J0IHsgVGFibGVTaXplU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy90YWJsZS1zaXplLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRIZWFkZXJSZW5kZXJlciB9IGZyb20gJy4vaGVhZGVyLXJlbmRlcmVyJztcbmltcG9ydCB7IE5vb3BEb21BZGFwdGVyIH0gZnJvbSAnLi9ub29wLWRvbS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi9yZW5kZXItb3JnYW5pemVyJztcblxuLy8gRml4ZXMgYnVpbGQgZXJyb3Jcbi8vIEBkeW5hbWljIChodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTY5OCNpc3N1ZWNvbW1lbnQtMzM4MzQwMjExKVxuZXhwb3J0IGNvbnN0IGRvbUFkYXB0ZXJGYWN0b3J5ID0gKHBsYXRmb3JtSWQ6IE9iamVjdCkgPT4ge1xuICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIocGxhdGZvcm1JZCkpIHtcbiAgICByZXR1cm4gbmV3IERvbUFkYXB0ZXIoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE5vb3BEb21BZGFwdGVyKCk7XG4gIH1cbn07XG5cbi8vIEZpeGVzIGJ1aWxkIGVycm9yXG4vLyBAZHluYW1pYyAoaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTk2OTgjaXNzdWVjb21tZW50LTMzODM0MDIxMSlcbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2Nsci1kYXRhZ3JpZCcsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogRG9tQWRhcHRlciwgdXNlRmFjdG9yeTogZG9tQWRhcHRlckZhY3RvcnksIGRlcHM6IFtQTEFURk9STV9JRF0gfV0sXG59KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkTWFpblJlbmRlcmVyPFQgPSBhbnk+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyLFxuICAgIHByaXZhdGUgaXRlbXM6IEl0ZW1zLFxuICAgIHByaXZhdGUgcGFnZTogUGFnZSxcbiAgICBwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSB0YWJsZVNpemVTZXJ2aWNlOiBUYWJsZVNpemVTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5vcmdhbml6ZXJcbiAgICAgICAgLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5DT01QVVRFX0NPTFVNTl9XSURUSFMpXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb21wdXRlSGVhZGVyc1dpZHRoKCkpXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5wYWdlLnNpemVDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2hlaWdodFNldCkge1xuICAgICAgICAgIHRoaXMucmVzZXREYXRhZ3JpZEhlaWdodCgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5pdGVtcy5jaGFuZ2Uuc3Vic2NyaWJlKCgpID0+ICh0aGlzLnNob3VsZFN0YWJpbGl6ZUNvbHVtbnMgPSB0cnVlKSkpO1xuICB9XG5cbiAgQENvbnRlbnRDaGlsZHJlbihEYXRhZ3JpZEhlYWRlclJlbmRlcmVyKSBwdWJsaWMgaGVhZGVyczogUXVlcnlMaXN0PERhdGFncmlkSGVhZGVyUmVuZGVyZXI+O1xuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkQ29sdW1uKSBwdWJsaWMgY29sdW1uczogUXVlcnlMaXN0PENsckRhdGFncmlkQ29sdW1uPjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhlYWRlcnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBvbmx5IHJlLXN0YWJpbGl6ZSBpZiBhIGNvbHVtbiB3YXMgYWRkZWQgb3IgcmVtb3ZlZC4gUmVvcmRlcmluZyBpcyBmaW5lLlxuICAgICAgICB0aGlzLmNvbHVtbnNTaXplc1N0YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWJpbGl6ZUNvbHVtbnMoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgYW5kIHNldCBUYWJsZSB3aWR0aCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcgaGVyZS5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMudGFibGVTaXplU2VydmljZS50YWJsZSA9IHRoaXMuZWw7XG4gIH1cblxuICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkU3RhYmlsaXplQ29sdW1ucykge1xuICAgICAgdGhpcy5zdGFiaWxpemVDb2x1bW5zKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNob3VsZENvbXB1dGVIZWlnaHQoKSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY29tcHV0ZURhdGFncmlkSGVpZ2h0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9oZWlnaHRTZXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHNob3VsZENvbXB1dGVIZWlnaHQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLl9oZWlnaHRTZXQgJiYgdGhpcy5wYWdlLnNpemUgPiAwKSB7XG4gICAgICBpZiAodGhpcy5pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoID09PSB0aGlzLnBhZ2Uuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBoZWlnaHQgb2YgdGhlIGRhdGFncmlkLlxuICAgKlxuICAgKiBOT1RFOiBXZSBoYWQgdG8gY2hvb3NlIHRvIHNldCB0aGUgaGVpZ2h0IGluc3RlYWQgb2YgdGhlIG1pbi1oZWlnaHQgYmVjYXVzZVxuICAgKiBJRSAxMSByZXF1aXJlcyB0aGUgaGVpZ2h0IG9uIHRoZSBwYXJlbnQgZm9yIHRoZSBjaGlsZHJlbiBmbGV4IGdyb3cvc2hyaW5rIHByb3BlcnRpZXMgdG8gd29yay5cbiAgICogV2hlbiB3ZSB1c2VkIG1pbi1oZWlnaHQsIDEgMSBhdXRvIGRvZXNuJ3QgdXNlZCB0byB3b3JrIGluIElFMTEgOi0oXG4gICAqIEJ1dCB0aGlzIGRvZXNuJ3QgYWZmZWN0IHRoZSBmaXguIEl0IHdvcmtzIGluIGJvdGggZml4ZWQgJiB2YXJpYWJsZSBoZWlnaHQgZGF0YWdyaWRzLlxuICAgKlxuICAgKiBSZWZlcjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDM5NjIwNS9mbGV4LWdyb3ctbm90LXdvcmtpbmctaW4taW50ZXJuZXQtZXhwbG9yZXItMTEtMFxuICAgKi9cbiAgcHJpdmF0ZSBjb21wdXRlRGF0YWdyaWRIZWlnaHQoKSB7XG4gICAgLy8gSUUgZG9lc24ndCByZXR1cm4gY29ycmVjdCB2YWx1ZSBmb3IgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiaGVpZ2h0XCIpXG4gICAgY29uc3QgdmFsdWU6IG51bWJlciA9IHRoaXMuZG9tQWRhcHRlci5jbGllbnRSZWN0KHRoaXMuZWwubmF0aXZlRWxlbWVudCkuaGVpZ2h0O1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdmFsdWUgKyAncHgnKTtcbiAgICB0aGlzLl9oZWlnaHRTZXQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldERhdGFncmlkSGVpZ2h0KCkge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgJycpO1xuICAgIHRoaXMuX2hlaWdodFNldCA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgZWFjaCBoZWFkZXIgY29tcHV0ZSBpdHMgd2lkdGguXG4gICAqL1xuICBwcml2YXRlIGNvbXB1dGVIZWFkZXJzV2lkdGgoKSB7XG4gICAgY29uc3QgbmJDb2x1bW5zOiBudW1iZXIgPSB0aGlzLmhlYWRlcnMubGVuZ3RoO1xuICAgIGxldCBhbGxTdHJpY3QgPSB0cnVlO1xuICAgIHRoaXMuaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XG4gICAgICAvLyBPbiB0aGUgbGFzdCBoZWFkZXIgY29sdW1uIGNoZWNrIHdoZXRoZXIgYWxsIGNvbHVtbnMgaGF2ZSBzdHJpY3Qgd2lkdGhzLlxuICAgICAgLy8gSWYgYWxsIGNvbHVtbnMgaGF2ZSBzdHJpY3Qgd2lkdGhzLCByZW1vdmUgdGhlIHN0cmljdCB3aWR0aCBmcm9tIHRoZSBsYXN0IGNvbHVtbiBhbmQgbWFrZSBpdCB0aGUgY29sdW1uJ3NcbiAgICAgIC8vIG1pbmltdW0gd2lkdGggc28gdGhhdCB3aGVuIGFsbCBwcmV2aW91cyBjb2x1bW5zIHNocmluaywgaXQgd2lsbCBnZXQgYSBmbGV4aWJsZSB3aWR0aCBhbmQgY292ZXIgdGhlIGVtcHR5XG4gICAgICAvLyBnYXAgaW4gdGhlIERhdGFncmlkLlxuXG4gICAgICBpZiAoIWhlYWRlci5zdHJpY3RXaWR0aCkge1xuICAgICAgICBhbGxTdHJpY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5iQ29sdW1ucyA9PT0gaW5kZXggKyAxICYmIGFsbFN0cmljdCkge1xuICAgICAgICBkZWxldGUgaGVhZGVyLnN0cmljdFdpZHRoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9yZ2FuaXplci53aWR0aHNbaW5kZXhdID0geyBweDogaGVhZGVyLmNvbXB1dGVXaWR0aCgpLCBzdHJpY3Q6ICEhaGVhZGVyLnN0cmljdFdpZHRoIH07XG4gICAgfSk7XG5cbiAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaCgoaGVhZGVyLCBpbmRleCkgPT4gaGVhZGVyLnNldFdpZHRoKHRoaXMub3JnYW5pemVyLndpZHRoc1tpbmRleF0ucHgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgd2Ugd2FudCB0byByZS1jb21wdXRlIGNvbHVtbnMgd2lkdGguIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuOlxuICAgKiAxKSBXaGVuIGhlYWRlcnMgY2hhbmdlLCB3aXRoIGNvbHVtbnMgYmVpbmcgYWRkZWQgb3IgcmVtb3ZlZFxuICAgKiAyKSBXaGVuIHJvd3MgYXJlIGxhemlseSBsb2FkZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAqL1xuICBwcml2YXRlIGNvbHVtbnNTaXplc1N0YWJsZSA9IGZhbHNlO1xuXG4gIHByaXZhdGUgc2hvdWxkU3RhYmlsaXplQ29sdW1ucyA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGEgd2hvbGUgcmUtcmVuZHJpbmcgY3ljbGUgdG8gc2V0IGNvbHVtbiBzaXplcywgaWYgbmVlZGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBzdGFiaWxpemVDb2x1bW5zKCkge1xuICAgIHRoaXMuc2hvdWxkU3RhYmlsaXplQ29sdW1ucyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmNvbHVtbnNTaXplc1N0YWJsZSkge1xuICAgICAgLy8gTm90aGluZyB0byBkby5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVzaXplIHdoZW4gdGhlIHJvd3MgYXJlIGxvYWRlZC5cbiAgICBpZiAodGhpcy5pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5vcmdhbml6ZXIucmVzaXplKCk7XG4gICAgICB0aGlzLmNvbHVtbnNTaXplc1N0YWJsZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlclN0ZXAgfSBmcm9tICcuLi9lbnVtcy9yZW5kZXItc3RlcC5lbnVtJztcblxuaW1wb3J0IHsgRGF0YWdyaWRDZWxsUmVuZGVyZXIgfSBmcm9tICcuL2NlbGwtcmVuZGVyZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuL3JlbmRlci1vcmdhbml6ZXInO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGctcm93LCBjbHItZGctcm93LWRldGFpbCcgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFJvd1JlbmRlcmVyIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBvcmdhbml6ZXIuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkFMSUdOX0NPTFVNTlMpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNldFdpZHRocygpKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKERhdGFncmlkQ2VsbFJlbmRlcmVyKSBjZWxsczogUXVlcnlMaXN0PERhdGFncmlkQ2VsbFJlbmRlcmVyPjtcblxuICBwcml2YXRlIHNldFdpZHRocygpIHtcbiAgICBpZiAodGhpcy5vcmdhbml6ZXIud2lkdGhzLmxlbmd0aCAhPT0gdGhpcy5jZWxscy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLm9yZ2FuaXplci53aWR0aHNbaW5kZXhdO1xuICAgICAgY2VsbC5zZXRXaWR0aCh3aWR0aC5zdHJpY3QsIHdpZHRoLnB4KTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLmNlbGxzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0V2lkdGhzKCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zZXRXaWR0aHMoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDbHJGb3Jtc01vZHVsZSB9IGZyb20gJy4uLy4uL2Zvcm1zL2Zvcm1zLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWZFeHBhbmRNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJMb2FkaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJPdXRzaWRlQ2xpY2tNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9vdXRzaWRlLWNsaWNrL291dHNpZGUtY2xpY2subW9kdWxlJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSb3dFeHBhbmRBbmltYXRpb24gfSBmcm9tICcuL2FuaW1hdGlvbi1oYWNrL3Jvdy1leHBhbmQtYW5pbWF0aW9uJztcbmltcG9ydCB7IERhdGFncmlkU3RyaW5nRmlsdGVyIH0gZnJvbSAnLi9idWlsdC1pbi9maWx0ZXJzL2RhdGFncmlkLXN0cmluZy1maWx0ZXInO1xuaW1wb3J0IHsgQWN0aW9uYWJsZU9vbXBhTG9vbXBhIH0gZnJvbSAnLi9jaG9jb2xhdGUvYWN0aW9uYWJsZS1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgRGF0YWdyaWRXaWxseVdvbmthIH0gZnJvbSAnLi9jaG9jb2xhdGUvZGF0YWdyaWQtd2lsbHktd29ua2EnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZU9vbXBhTG9vbXBhIH0gZnJvbSAnLi9jaG9jb2xhdGUvZXhwYW5kYWJsZS1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWQgfSBmcm9tICcuL2RhdGFncmlkJztcbmltcG9ydCB7IENsckRhdGFncmlkQWN0aW9uQmFyIH0gZnJvbSAnLi9kYXRhZ3JpZC1hY3Rpb24tYmFyJztcbmltcG9ydCB7IENsckRhdGFncmlkQWN0aW9uT3ZlcmZsb3cgfSBmcm9tICcuL2RhdGFncmlkLWFjdGlvbi1vdmVyZmxvdyc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENlbGwgfSBmcm9tICcuL2RhdGFncmlkLWNlbGwnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW4gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXRvZ2dsZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbiB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS1idXR0b24nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZSB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS10aXRsZSc7XG5pbXBvcnQgeyBEYXRhZ3JpZERldGFpbFJlZ2lzdGVyZXIgfSBmcm9tICcuL2RhdGFncmlkLWRldGFpbC1yZWdpc3RlcmVyJztcbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1maWx0ZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRGb290ZXIgfSBmcm9tICcuL2RhdGFncmlkLWZvb3Rlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRJdGVtcyB9IGZyb20gJy4vZGF0YWdyaWQtaXRlbXMnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRJdGVtc1RyYWNrQnkgfSBmcm9tICcuL2RhdGFncmlkLWl0ZW1zLXRyYWNrYnknO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQYWdpbmF0aW9uIH0gZnJvbSAnLi9kYXRhZ3JpZC1wYWdpbmF0aW9uJztcbmltcG9ydCB7IENsckRhdGFncmlkUGFnZVNpemUgfSBmcm9tICcuL2RhdGFncmlkLXBhZ2Utc2l6ZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1wbGFjZWhvbGRlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFJvdyB9IGZyb20gJy4vZGF0YWdyaWQtcm93JztcbmltcG9ydCB7IENsckRhdGFncmlkUm93RGV0YWlsIH0gZnJvbSAnLi9kYXRhZ3JpZC1yb3ctZGV0YWlsJztcbmltcG9ydCB7IERhdGFncmlkQ2VsbFJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvY2VsbC1yZW5kZXJlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZENvbHVtblJlc2l6ZXIgfSBmcm9tICcuL3JlbmRlci9jb2x1bW4tcmVzaXplcic7XG5pbXBvcnQgeyBEYXRhZ3JpZEhlYWRlclJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvaGVhZGVyLXJlbmRlcmVyJztcbmltcG9ydCB7IERhdGFncmlkTWFpblJlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvbWFpbi1yZW5kZXJlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFJvd1JlbmRlcmVyIH0gZnJvbSAnLi9yZW5kZXIvcm93LXJlbmRlcmVyJztcbmltcG9ydCB7IFdyYXBwZWRDZWxsIH0gZnJvbSAnLi93cmFwcGVkLWNlbGwnO1xuaW1wb3J0IHsgV3JhcHBlZENvbHVtbiB9IGZyb20gJy4vd3JhcHBlZC1jb2x1bW4nO1xuaW1wb3J0IHsgV3JhcHBlZFJvdyB9IGZyb20gJy4vd3JhcHBlZC1yb3cnO1xuXG5leHBvcnQgY29uc3QgQ0xSX0RBVEFHUklEX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICAvLyBDb3JlXG4gIENsckRhdGFncmlkLFxuICBDbHJEYXRhZ3JpZEFjdGlvbkJhcixcbiAgQ2xyRGF0YWdyaWRBY3Rpb25PdmVyZmxvdyxcbiAgQ2xyRGF0YWdyaWRDb2x1bW4sXG4gIENsckRhdGFncmlkQ29sdW1uVG9nZ2xlLFxuICBDbHJEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uLFxuICBDbHJEYXRhZ3JpZEZpbHRlcixcbiAgQ2xyRGF0YWdyaWRJdGVtcyxcbiAgQ2xyRGF0YWdyaWRJdGVtc1RyYWNrQnksXG4gIENsckRhdGFncmlkUm93LFxuICBDbHJEYXRhZ3JpZFJvd0RldGFpbCxcbiAgRGF0YWdyaWREZXRhaWxSZWdpc3RlcmVyLFxuICBDbHJEYXRhZ3JpZENlbGwsXG4gIENsckRhdGFncmlkRm9vdGVyLFxuICBDbHJEYXRhZ3JpZFBhZ2luYXRpb24sXG4gIENsckRhdGFncmlkUGFnZVNpemUsXG4gIENsckRhdGFncmlkUGxhY2Vob2xkZXIsXG4gIENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uLFxuICBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlLFxuICBXcmFwcGVkQ2VsbCxcbiAgV3JhcHBlZENvbHVtbixcbiAgV3JhcHBlZFJvdyxcblxuICAvLyBSZW5kZXJlcnNcbiAgRGF0YWdyaWRNYWluUmVuZGVyZXIsXG4gIERhdGFncmlkSGVhZGVyUmVuZGVyZXIsXG4gIERhdGFncmlkQ29sdW1uUmVzaXplcixcbiAgRGF0YWdyaWRSb3dSZW5kZXJlcixcbiAgRGF0YWdyaWRDZWxsUmVuZGVyZXIsXG5cbiAgLy8gQ2hvY29sYXRlXG4gIERhdGFncmlkV2lsbHlXb25rYSxcbiAgQWN0aW9uYWJsZU9vbXBhTG9vbXBhLFxuICBFeHBhbmRhYmxlT29tcGFMb29tcGEsXG5cbiAgLy8gQW5pbWF0aW9uIGhhY2tcbiAgRGF0YWdyaWRSb3dFeHBhbmRBbmltYXRpb24sXG5cbiAgLy8gQnVpbHQtaW4gc2hvcnRjdXRzXG4gIERhdGFncmlkU3RyaW5nRmlsdGVyLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBDbHJJY29uTW9kdWxlLFxuICAgIENsckZvcm1zTW9kdWxlLFxuICAgIEZvcm1zTW9kdWxlLFxuICAgIENsckNvbW1vblBvcG92ZXJNb2R1bGUsXG4gICAgQ2xyTG9hZGluZ01vZHVsZSxcbiAgICBDbHJPdXRzaWRlQ2xpY2tNb2R1bGUsXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9EQVRBR1JJRF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9EQVRBR1JJRF9ESVJFQ1RJVkVTLCBDbHJJZkV4cGFuZE1vZHVsZV0sXG4gIGVudHJ5Q29tcG9uZW50czogW1dyYXBwZWRDZWxsLCBXcmFwcGVkQ29sdW1uLCBXcmFwcGVkUm93XSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25Jbml0LCBPcHRpb25hbCwgT3V0cHV0LCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLWJsb2NrJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZHQgY2xhc3M9XCJzdGFjay1ibG9jay1sYWJlbFwiXG4gICAgICAgIChjbGljayk9XCJ0b2dnbGVFeHBhbmQoKVwiXG4gICAgICAgIChrZXl1cC5lbnRlcik9XCJ0b2dnbGVFeHBhbmQoKVwiXG4gICAgICAgIChrZXl1cC5zcGFjZSk9XCJ0b2dnbGVFeHBhbmQoKVwiXG4gICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgIChibHVyKT1cImZvY3VzZWQgPSBmYWxzZVwiXG4gICAgICAgIFthdHRyLnJvbGVdPVwicm9sZVwiXG4gICAgICAgIFthdHRyLnRhYmluZGV4XT1cInRhYkluZGV4XCJcbiAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJhcmlhRXhwYW5kZWRcIj5cbiAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNhcmV0XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInN0YWNrLWJsb2NrLWNhcmV0XCJcbiAgICAgICAgICAgICAgICAqbmdJZj1cImV4cGFuZGFibGVcIlxuICAgICAgICAgICAgICAgIFthdHRyLmRpcl09XCJjYXJldERpcmVjdGlvblwiXG4gICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiY2FyZXRUaXRsZVwiPjwvY2xyLWljb24+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItc3RhY2stbGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kdD5cbiAgICA8ZGQgY2xhc3M9XCJzdGFjay1ibG9jay1jb250ZW50XCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9kZD5cbiAgICA8IS0tIEZJWE1FOiByZW1vdmUgdGhpcyBzdHJpbmcgY29uY2F0ZW5hdGlvbiB3aGVuIGJvb2xlYW4gc3RhdGVzIGFyZSBzdXBwb3J0ZWQgLS0+XG4gICAgPGRpdiBbQGNvbGxhcHNlXT1cIicnKyFleHBhbmRlZFwiIGNsYXNzPVwic3RhY2stY2hpbGRyZW5cIiA+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItc3RhY2stYmxvY2tcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIGAsXG4gIC8vIEN1c3RvbSBlbGVtZW50cyBhcmUgaW5saW5lIGJ5IGRlZmF1bHRcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgICA6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9XG4gICAgYCxcbiAgXSxcbiAgLy8gTWFrZSBzdXJlIHRoZSBob3N0IGhhcyB0aGUgcHJvcGVyIGNsYXNzIGZvciBzdHlsaW5nIHB1cnBvc2VzXG4gIGhvc3Q6IHsgJ1tjbGFzcy5zdGFjay1ibG9ja10nOiAndHJ1ZScgfSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ2NvbGxhcHNlJywgW1xuICAgICAgc3RhdGUoJ3RydWUnLCBzdHlsZSh7IGhlaWdodDogMCwgZGlzcGxheTogJ25vbmUnIH0pKSxcbiAgICAgIHRyYW5zaXRpb24oJ3RydWUgPT4gZmFsc2UnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgaGVpZ2h0OiAnKicsIGRpc3BsYXk6ICcqJyB9KSldKSxcbiAgICAgIHRyYW5zaXRpb24oJ2ZhbHNlID0+IHRydWUnLCBbc3R5bGUoeyBoZWlnaHQ6ICcqJywgZGlzcGxheTogJyonIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0JyldKSxcbiAgICBdKSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tCbG9jayBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3RhY2stYmxvY2stZXhwYW5kZWQnKVxuICBASW5wdXQoJ2NsclNiRXhwYW5kZWQnKVxuICBleHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBAT3V0cHV0KCdjbHJTYkV4cGFuZGVkQ2hhbmdlJykgZXhwYW5kZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnN0YWNrLWJsb2NrLWV4cGFuZGFibGUnKVxuICBASW5wdXQoJ2NsclNiRXhwYW5kYWJsZScpXG4gIGV4cGFuZGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2NoYW5nZWRDaGlsZHJlbjogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfZnVsbHlJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9jaGFuZ2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zdGFjay1ibG9jay1jaGFuZ2VkJylcbiAgZ2V0IGdldENoYW5nZWRWYWx1ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlZCB8fCAodGhpcy5fY2hhbmdlZENoaWxkcmVuID4gMCAmJiAhdGhpcy5leHBhbmRlZCk7XG4gIH1cblxuICBASW5wdXQoJ2NsclNiTm90aWZ5Q2hhbmdlJylcbiAgc2V0IHNldENoYW5nZWRWYWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2NoYW5nZWQgPSB2YWx1ZTtcblxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLl9mdWxseUluaXRpYWxpemVkKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2NoYW5nZWRDaGlsZHJlbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2NoYW5nZWRDaGlsZHJlbi0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgICogVGhpcyB3b3VsZCBiZSBtb3JlIGVmZmljaWVudCB3aXRoIEBDb250ZW50Q2hpbGRyZW4sIHdpdGggdGhlIHBhcmVudCBDbHJTdGFja0Jsb2NrXG4gICAgICogcXVlcnlpbmcgZm9yIGNoaWxkcmVuIFN0YWNrQmxvY2tzLCBidXQgdGhpcyBmZWF0dXJlIGlzIG5vdCBhdmFpbGFibGUgd2hlbiBkb3duZ3JhZGluZ1xuICAgICAqIHRoZSBjb21wb25lbnQgZm9yIEFuZ3VsYXIgMS5cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgQFNraXBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByaXZhdGUgcGFyZW50OiBDbHJTdGFja0Jsb2NrLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5hZGRDaGlsZCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIC8vIGluIG9yZGVyIHRvIGFjY2VzcyB0aGUgcGFyZW50IENsclN0YWNrQmxvY2sncyBwcm9wZXJ0aWVzLFxuICAgIC8vIHRoZSBjaGlsZCBDbHJTdGFja0Jsb2NrICBoYXMgdG8gYmUgZnVsbHkgaW5pdGlhbGl6ZWQgYXQgZmlyc3QuXG4gICAgdGhpcy5fZnVsbHlJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhZGRDaGlsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmV4cGFuZGFibGUgPSB0cnVlO1xuICB9XG5cbiAgdG9nZ2xlRXhwYW5kKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICB9XG4gIH1cblxuICBnZXQgY2FyZXREaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/ICdkb3duJyA6ICdyaWdodCc7XG4gIH1cblxuICBnZXQgY2FyZXRUaXRsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGVkID8gdGhpcy5jb21tb25TdHJpbmdzLmNvbGxhcHNlIDogdGhpcy5jb21tb25TdHJpbmdzLmV4cGFuZDtcbiAgfVxuXG4gIGdldCByb2xlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZSA/ICdidXR0b24nIDogbnVsbDtcbiAgfVxuXG4gIGdldCB0YWJJbmRleCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGUgPyAnMCcgOiBudWxsO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5vbi1mb2N1cycpXG4gIGdldCBvblN0YWNrTGFiZWxGb2N1cygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlICYmICF0aGlzLmV4cGFuZGVkICYmIHRoaXMuZm9jdXNlZDtcbiAgfVxuXG4gIGdldCBhcmlhRXhwYW5kZWQoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuZXhwYW5kYWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGFuZGVkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLXZpZXcnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItc3RhY2staGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8ZGwgY2xhc3M9XCJzdGFjay12aWV3XCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGw+XG4gICAgYCxcbiAgLy8gQ3VzdG9tIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdC5cbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgICA6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9XG4gICAgYCxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tWaWV3IHtcbiAgLyoqXG4gICAqIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuXG4gICAqL1xuICBlZGl0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoJ2NsclN0YWNrU2F2ZScpIHNhdmU6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oZmFsc2UpO1xuXG4gIHByaXZhdGUgX2VkaXRNb2RlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZWRpdGluZ0NoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgZ2V0IGVkaXRpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdGFibGUgJiYgdGhpcy5fZWRpdE1vZGU7XG4gIH1cblxuICBzZXQgZWRpdGluZyh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmVkaXRhYmxlKSB7XG4gICAgICB0aGlzLl9lZGl0TW9kZSA9IHZhbHVlO1xuICAgICAgdGhpcy5lZGl0aW5nQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aGlzLnNhdmUuZW1pdChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBvZiB1bmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmUuXG4gICAqL1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXcgfSBmcm9tICcuL3N0YWNrLXZpZXcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2staGVhZGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGg0IGNsYXNzPVwic3RhY2staGVhZGVyXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YWNrLXRpdGxlXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGFjay1hY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnN0YWNrLWFjdGlvblwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8IS0tIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuIC0tPlxuICAgICAgICAgICAgICAgIDxidXR0b24gKm5nSWY9XCJzdGFja1ZpZXcuZWRpdGFibGVcIiBjbGFzcz1cInN0YWNrLWFjdGlvbiBidG4gYnRuLXNtIGJ0bi1saW5rXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwic3RhY2tWaWV3LmVkaXRpbmcgPSAhc3RhY2tWaWV3LmVkaXRpbmdcIiB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBFZGl0XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPCEtLSBFbmQgb2YgdW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlLiAtLT5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9oND5cbiAgICBgLFxuICAvLyBDdXN0b20gZWxlbWVudHMgYXJlIGlubGluZSBieSBkZWZhdWx0XG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfVxuICAgIGAsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrSGVhZGVyIHtcbiAgY29uc3RydWN0b3IocHVibGljIHN0YWNrVmlldzogQ2xyU3RhY2tWaWV3KSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuLyoqXG4gKiBVbmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmU6IGlubGluZSBlZGl0aW5nLlxuICovXG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcblxuZXhwb3J0IGNsYXNzIFN0YWNrQ29udHJvbCB7XG4gIG1vZGVsOiBhbnk7XG4gIG1vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHN0YWNrVmlldzogQ2xyU3RhY2tWaWV3KSB7XG4gICAgLy8gTWFrZSB0aGUgQ2xyU3RhY2tWaWV3IGVkaXRhYmxlLCBzaW5jZSBpdCBjb250YWlucyBhIFN0YWNrQ29udHJvbFxuICAgIHRoaXMuc3RhY2tWaWV3LmVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnN0YWNrVmlldy5lZGl0aW5nQ2hhbmdlLnN1YnNjcmliZSgoZWRpdGluZzogYm9vbGVhbikgPT4ge1xuICAgICAgLy8gRWRpdCBtb2RlIHdhcyBjbG9zZWRcbiAgICAgIGlmICghZWRpdGluZykge1xuICAgICAgICB0aGlzLm1vZGVsQ2hhbmdlLmVtaXQodGhpcy5tb2RlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbi8qKlxuICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAqXG4gKiBUT0RPOiBzdXBwb3J0IG1vcmUgdHlwZXMgb2YgaW5wdXRzOiBjaGVja2JveCwgcmFkaW8sIC4uLlxuICogVE9ETzogTWlycm9yIGlucHV0IGF0dHJpYnV0ZXMgZnJvbSB0aGUgaG9zdCB0byB0aGUgYWN0dWFsIGlucHV0OiBzaXplLCBtaW4sIG1heCwgcGxhY2Vob2xkZXIsIC4uLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3RhY2tDb250cm9sIH0gZnJvbSAnLi9zdGFjay1jb250cm9sJztcbmltcG9ydCB7IENsclN0YWNrVmlldyB9IGZyb20gJy4vc3RhY2stdmlldyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zdGFjay1pbnB1dCcsXG4gIGlucHV0czogWydtb2RlbDogY2xyTW9kZWwnLCAndHlwZSddLFxuICBvdXRwdXRzOiBbJ21vZGVsQ2hhbmdlOiBjbHJNb2RlbENoYW5nZSddLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFzdGFja1ZpZXcuZWRpdGluZ1wiPnt7bW9kZWx9fTwvc3Bhbj5cbiAgICAgICAgPGlucHV0IFt0eXBlXT1cInR5cGVcIiAqbmdJZj1cInN0YWNrVmlldy5lZGl0aW5nXCIgWyhuZ01vZGVsKV09XCJtb2RlbFwiLz5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja0lucHV0IGV4dGVuZHMgU3RhY2tDb250cm9sIHtcbiAgdHlwZTogc3RyaW5nID0gJ3RleHQnO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdGFja1ZpZXc6IENsclN0YWNrVmlldykge1xuICAgIHN1cGVyKHN0YWNrVmlldyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbi8qKlxuICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAqXG4gKiBUT0RPOiBPZmZlciBhIGEgd2F5IHRvIGN1c3RvbWl6ZSB0aGUgdmFsdWUgZGlzcGxheWVkLCBwbGFpbiB2YWx1ZSBtYXkgYmUgdW5yZWFkYWJsZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN0YWNrQ29udHJvbCB9IGZyb20gJy4vc3RhY2stY29udHJvbCc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXcgfSBmcm9tICcuL3N0YWNrLXZpZXcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2stc2VsZWN0JyxcbiAgaW5wdXRzOiBbJ21vZGVsOiBjbHJNb2RlbCddLFxuICBvdXRwdXRzOiBbJ21vZGVsQ2hhbmdlOiBjbHJNb2RlbENoYW5nZSddLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFzdGFja1ZpZXcuZWRpdGluZ1wiPnt7bW9kZWx9fTwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlbGVjdFwiICpuZ0lmPVwic3RhY2tWaWV3LmVkaXRpbmdcIiA+XG4gICAgICAgICAgICA8c2VsZWN0IFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tTZWxlY3QgZXh0ZW5kcyBTdGFja0NvbnRyb2wge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3RhY2tWaWV3OiBDbHJTdGFja1ZpZXcpIHtcbiAgICBzdXBlcihzdGFja1ZpZXcpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLXN0YWNrLWxhYmVsLCBjbHItc3RhY2stY29udGVudCcgfSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja1ZpZXdDdXN0b21UYWdzIHtcbiAgLy8gTm8gYmVoYXZpb3JcbiAgLy8gVGhlIG9ubHkgcHVycG9zZSBpcyB0byBcImRlY2xhcmVcIiB0aGUgdGFnIGluIEFuZ3VsYXJcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xyU3RhY2tCbG9jayB9IGZyb20gJy4vc3RhY2stYmxvY2snO1xuaW1wb3J0IHsgQ2xyU3RhY2tIZWFkZXIgfSBmcm9tICcuL3N0YWNrLWhlYWRlcic7XG5pbXBvcnQgeyBDbHJTdGFja0lucHV0IH0gZnJvbSAnLi9zdGFjay1pbnB1dCc7XG5pbXBvcnQgeyBDbHJTdGFja1NlbGVjdCB9IGZyb20gJy4vc3RhY2stc2VsZWN0JztcbmltcG9ydCB7IENsclN0YWNrVmlldyB9IGZyb20gJy4vc3RhY2stdmlldyc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXdDdXN0b21UYWdzIH0gZnJvbSAnLi9zdGFjay12aWV3LWN1c3RvbS10YWdzJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcblxuZXhwb3J0IGNvbnN0IENMUl9TVEFDS19WSUVXX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICBDbHJTdGFja1ZpZXcsXG4gIENsclN0YWNrSGVhZGVyLFxuICBDbHJTdGFja0Jsb2NrLFxuICBDbHJTdGFja1ZpZXdDdXN0b21UYWdzLFxuICAvKipcbiAgICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAgICovXG4gIENsclN0YWNrSW5wdXQsXG4gIENsclN0YWNrU2VsZWN0LFxuICAvKipcbiAgICogRW5kIG9mIHVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZS5cbiAgICovXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9TVEFDS19WSUVXX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1NUQUNLX1ZJRVdfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrVmlld01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5sZXQgTkJfSU5TVEFOQ0VTID0gMDtcblxuZXhwb3J0IGNvbnN0IFVOSVFVRV9JRCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+KCdVTklRVUVfSUQnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUlkRmFjdG9yeSgpIHtcbiAgcmV0dXJuICdjbHItaWQtJyArIE5CX0lOU1RBTkNFUysrO1xufVxuXG5leHBvcnQgY29uc3QgVU5JUVVFX0lEX1BST1ZJREVSID0ge1xuICBwcm92aWRlOiBVTklRVUVfSUQsXG4gIHVzZUZhY3Rvcnk6IHVuaXF1ZUlkRmFjdG9yeSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFRyZWVTZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFyZW50OiBBYnN0cmFjdFRyZWVTZWxlY3Rpb24pIHt9XG5cbiAgYWJzdHJhY3QgZ2V0IGNoaWxkcmVuKCk6IEFic3RyYWN0VHJlZVNlbGVjdGlvbltdO1xuXG4gIGFic3RyYWN0IHNlbGVjdGVkQ2hhbmdlZCgpOiB2b2lkO1xuICBhYnN0cmFjdCBpbmRldGVybWluYXRlQ2hhbmdlZCgpOiB2b2lkO1xuXG4gIHByaXZhdGUgX3NlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2luZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwdWJsaWMgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgc2VsZWN0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9zZWxlY3RlZCA9IHZhbHVlO1xuICAgIHRoaXMuaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5wYXJlbnRDaGFuZ2VkKHZhbHVlKSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5jaGlsZENoYW5nZWQoKTtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZENoYW5nZWQoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaW5kZXRlcm1pbmF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXRlcm1pbmF0ZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICBjaGlsZENoYW5nZWQoKTogdm9pZCB7XG4gICAgbGV0IG9uZVNlbGVjdGVkQ2hpbGQgPSBmYWxzZTtcbiAgICBjb25zdCBwcmV2aW91c1NlbGVjdGVkVmFsdWU6IGJvb2xlYW4gPSB0aGlzLl9zZWxlY3RlZDtcbiAgICBjb25zdCBwcmV2aW91c0luZGV0ZXJtaW5hdGVWYWx1ZTogYm9vbGVhbiA9IHRoaXMuX2luZGV0ZXJtaW5hdGU7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLnNlbGVjdGVkKSB7XG4gICAgICAgIG9uZVNlbGVjdGVkQ2hpbGQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvbmVTZWxlY3RlZENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnBhcmVudCAmJlxuICAgICAgKHRoaXMuX3NlbGVjdGVkICE9PSBwcmV2aW91c1NlbGVjdGVkVmFsdWUgfHwgdGhpcy5faW5kZXRlcm1pbmF0ZSAhPT0gcHJldmlvdXNJbmRldGVybWluYXRlVmFsdWUpXG4gICAgKSB7XG4gICAgICB0aGlzLnBhcmVudC5jaGlsZENoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZWxlY3RlZCAhPT0gcHJldmlvdXNTZWxlY3RlZFZhbHVlKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmluZGV0ZXJtaW5hdGUgIT09IHByZXZpb3VzSW5kZXRlcm1pbmF0ZVZhbHVlKSB7XG4gICAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgcGFyZW50Q2hhbmdlZChzZWxlY3RlZDogYm9vbGVhbikge1xuICAgIGlmIChzZWxlY3RlZCAmJiAhdGhpcy5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucGFyZW50Q2hhbmdlZCh0cnVlKSk7XG4gICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGVkICYmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaW5kZXRlcm1pbmF0ZSkpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5wYXJlbnRDaGFuZ2VkKGZhbHNlKSk7XG4gICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJlZVNlbGVjdGlvblNlcnZpY2Uge1xuICBzZWxlY3RhYmxlOiBib29sZWFuID0gZmFsc2U7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IFRyZWVTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi90cmVlLXNlbGVjdGlvbi5zZXJ2aWNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNsclRyZWVTZWxlY3Rpb25Qcm92aWRlckZhY3RvcnkoZXhpc3Rpbmc6IFRyZWVTZWxlY3Rpb25TZXJ2aWNlKSB7XG4gIHJldHVybiBleGlzdGluZyB8fCBuZXcgVHJlZVNlbGVjdGlvblNlcnZpY2UoKTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgYW5pbWF0ZSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgU2tpcFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBFeHBhbmQgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvcHJvdmlkZXJzL2V4cGFuZCc7XG5pbXBvcnQgeyBVTklRVUVfSUQsIFVOSVFVRV9JRF9QUk9WSURFUiB9IGZyb20gJy4uLy4uL3V0aWxzL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZSc7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuXG5pbXBvcnQgeyBBYnN0cmFjdFRyZWVTZWxlY3Rpb24gfSBmcm9tICcuL2Fic3RyYWN0LXRyZWUtc2VsZWN0aW9uJztcbmltcG9ydCB7IGNsclRyZWVTZWxlY3Rpb25Qcm92aWRlckZhY3RvcnkgfSBmcm9tICcuL3Byb3ZpZGVycy90cmVlLXNlbGVjdGlvbi5wcm92aWRlcic7XG5pbXBvcnQgeyBUcmVlU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RyZWUtc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRyZWUtbm9kZScsXG4gIHRlbXBsYXRlVXJsOiAnLi90cmVlLW5vZGUuaHRtbCcsXG4gIHByb3ZpZGVyczogW1xuICAgIEV4cGFuZCxcbiAgICB7IHByb3ZpZGU6IExvYWRpbmdMaXN0ZW5lciwgdXNlRXhpc3Rpbmc6IEV4cGFuZCB9LFxuICAgIHtcbiAgICAgIHByb3ZpZGU6IFRyZWVTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgdXNlRmFjdG9yeTogY2xyVHJlZVNlbGVjdGlvblByb3ZpZGVyRmFjdG9yeSxcbiAgICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBUcmVlU2VsZWN0aW9uU2VydmljZV1dLFxuICAgIH0sXG4gICAgVU5JUVVFX0lEX1BST1ZJREVSLFxuICBdLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignY2hpbGROb2Rlc1N0YXRlJywgW1xuICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoeyBoZWlnaHQ6ICcqJywgJ292ZXJmbG93LXknOiAnaGlkZGVuJyB9KSksXG4gICAgICBzdGF0ZSgnY29sbGFwc2VkJywgc3R5bGUoeyBoZWlnaHQ6IDAsICdvdmVyZmxvdy15JzogJ2hpZGRlbicgfSkpLFxuICAgICAgdHJhbnNpdGlvbignZXhwYW5kZWQgPD0+IGNvbGxhcHNlZCcsIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKSksXG4gICAgXSksXG4gIF0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5jbHItdHJlZS1ub2RlXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUcmVlTm9kZSBleHRlbmRzIEFic3RyYWN0VHJlZVNlbGVjdGlvbiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBub2RlRXhwYW5kOiBFeHBhbmQsXG4gICAgQE9wdGlvbmFsKClcbiAgICBAU2tpcFNlbGYoKVxuICAgIHB1YmxpYyBwYXJlbnQ6IENsclRyZWVOb2RlLFxuICAgIHB1YmxpYyB0cmVlU2VsZWN0aW9uU2VydmljZTogVHJlZVNlbGVjdGlvblNlcnZpY2UsXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBub2RlSWQ6IHN0cmluZyxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY2hpbGRyZW46IENsclRyZWVOb2RlW10gPSBbXTtcblxuICBnZXQgY2hpbGRyZW4oKTogQ2xyVHJlZU5vZGVbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICB9XG5cbiAgLyogUmVnaXN0cmF0aW9uICovXG5cbiAgY2hlY2tJZkNoaWxkTm9kZVJlZ2lzdGVyZWQobm9kZTogQ2xyVHJlZU5vZGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5pbmRleE9mKG5vZGUpID4gLTE7XG4gIH1cblxuICAvLyBUT0RPOiBUaGlzIHNob3VsZCBpZGVhbGx5IGJlIGluIEFic3RyYWN0VHJlZVNlbGVjdGlvblxuICAvLyBUcmllZCBkb2luZyB0aGlzIGJ1dCByYW4gaW50byBzb21lIGlzc3VlcyBhbmQgYWxzbyByYW4gb3V0IG9mIHRpbWUuXG4gIC8vIFdpbGwgZ2V0IHRoaXMgZG9uZSBsYXRlci5cbiAgcmVnaXN0ZXIobm9kZTogQ2xyVHJlZU5vZGUpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2hlY2tJZkNoaWxkTm9kZVJlZ2lzdGVyZWQobm9kZSkpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICBub2RlLnBhcmVudENoYW5nZWQodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBUaGlzIHNob3VsZCBpZGVhbGx5IGJlIGluIEFic3RyYWN0VHJlZVNlbGVjdGlvblxuICAvLyBUcmllZCBkb2luZyB0aGlzIGJ1dCByYW4gaW50byBzb21lIGlzc3VlcyBhbmQgYWxzbyByYW4gb3V0IG9mIHRpbWUuXG4gIC8vIFdpbGwgZ2V0IHRoaXMgZG9uZSBsYXRlci5cbiAgdW5yZWdpc3Rlcihub2RlOiBDbHJUcmVlTm9kZSk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgLyogU2VsZWN0aW9uICovXG5cbiAgYWN0aXZhdGVTZWxlY3Rpb24oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJlZVNlbGVjdGlvblNlcnZpY2UgJiYgIXRoaXMudHJlZVNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0YWJsZSkge1xuICAgICAgdGhpcy50cmVlU2VsZWN0aW9uU2VydmljZS5zZWxlY3RhYmxlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoJ2NsclNlbGVjdGVkJylcbiAgcHVibGljIHNldCBub2RlU2VsZWN0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAvLyByZXF1aXJlZCBmb3IgcmVjdXJzaXZlIHRyZWVzIHRvIGRpc2NhcmQgdW5zZXQgaW5wdXRzLlxuICAgIHRoaXMuYWN0aXZhdGVTZWxlY3Rpb24oKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zZWxlY3RlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJTZWxlY3RlZENoYW5nZScpIG5vZGVTZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBzZWxlY3RlZENoYW5nZWQoKTogdm9pZCB7XG4gICAgdGhpcy5ub2RlU2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgfVxuXG4gIGdldCBzZWxlY3RhYmxlKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnRyZWVTZWxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmVlU2VsZWN0aW9uU2VydmljZS5zZWxlY3RhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBASW5wdXQoJ2NsckluZGV0ZXJtaW5hdGUnKVxuICBzZXQgbm9kZUluZGV0ZXJtaW5hdGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmluZGV0ZXJtaW5hdGUgPSB2YWx1ZTtcbiAgICB0aGlzLmFjdGl2YXRlU2VsZWN0aW9uKCk7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJJbmRldGVybWluYXRlQ2hhbmdlJykgbm9kZUluZGV0ZXJtaW5hdGVDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIGluZGV0ZXJtaW5hdGVDaGFuZ2VkKCk6IHZvaWQge1xuICAgIHRoaXMubm9kZUluZGV0ZXJtaW5hdGVDaGFuZ2VkLmVtaXQodGhpcy5pbmRldGVybWluYXRlKTtcbiAgfVxuXG4gIC8qIEV4cGFuc2lvbiAqL1xuXG4gIHRvZ2dsZUV4cGFuZCgpOiB2b2lkIHtcbiAgICB0aGlzLm5vZGVFeHBhbmQuZXhwYW5kZWQgPSAhdGhpcy5ub2RlRXhwYW5kLmV4cGFuZGVkO1xuICB9XG5cbiAgcHVibGljIGdldCBjYXJldERpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGVFeHBhbmQuZXhwYW5kZWQgPyAnZG93bicgOiAncmlnaHQnO1xuICB9XG5cbiAgcHVibGljIGdldCBjYXJldFRpdGxlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubm9kZUV4cGFuZC5leHBhbmRlZCA/IHRoaXMuY29tbW9uU3RyaW5ncy5jb2xsYXBzZSA6IHRoaXMuY29tbW9uU3RyaW5ncy5leHBhbmQ7XG4gIH1cblxuICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubm9kZUV4cGFuZC5leHBhbmRlZDtcbiAgfVxuXG4gIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5ub2RlRXhwYW5kLmV4cGFuZGVkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5ub2RlRXhwYW5kLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0YXRlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kZWQgJiYgIXRoaXMubm9kZUV4cGFuZC5sb2FkaW5nID8gJ2V4cGFuZGVkJyA6ICdjb2xsYXBzZWQnO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICBnZXQgdHJlZU5vZGVSb2xlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gJ3RyZWVpdGVtJyA6ICd0cmVlJztcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW11bHRpc2VsZWN0YWJsZScpXG4gIGdldCByb290QXJpYU11bHRpU2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5wYXJlbnQgfHwgIXRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXNlbGVjdGVkJylcbiAgZ2V0IGFyaWFTZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RhYmxlID8gdGhpcy5zZWxlY3RlZCA6IG51bGw7XG4gIH1cblxuICBnZXQgYXJpYVRyZWVOb2RlQ2hpbGRyZW5Sb2xlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCA/ICdncm91cCcgOiBudWxsO1xuICB9XG5cbiAgLyogTGlmZWN5Y2xlICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQudW5yZWdpc3Rlcih0aGlzKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xyRm9ybXNNb2R1bGUgfSBmcm9tICcuLi8uLi9mb3Jtcy9mb3Jtcy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWZFeHBhbmRNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJUcmVlTm9kZSB9IGZyb20gJy4vdHJlZS1ub2RlJztcblxuZXhwb3J0IGNvbnN0IENMUl9UUkVFX1ZJRVdfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyVHJlZU5vZGVdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xyRm9ybXNNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfVFJFRV9WSUVXX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1RSRUVfVklFV19ESVJFQ1RJVkVTLCBDbHJJZkV4cGFuZE1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRyZWVWaWV3TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZE1vZHVsZSB9IGZyb20gJy4vZGF0YWdyaWQvZGF0YWdyaWQubW9kdWxlJztcbmltcG9ydCB7IENsclN0YWNrVmlld01vZHVsZSB9IGZyb20gJy4vc3RhY2stdmlldy9zdGFjay12aWV3Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJUcmVlVmlld01vZHVsZSB9IGZyb20gJy4vdHJlZS12aWV3L3RyZWUtdmlldy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoeyBleHBvcnRzOiBbQ2xyRGF0YWdyaWRNb2R1bGUsIENsclN0YWNrVmlld01vZHVsZSwgQ2xyVHJlZVZpZXdNb2R1bGVdIH0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YU1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcblxuLy8gVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNvbnZlcnQgYW4gaW50ZXJuYWwgZXZlbnRcbi8vIHRvIGFuIGV4dGVybmFsIGV2ZW50IHRvIGJlIGVtaXR0ZWQuXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ0V2ZW50PFQ+IHtcbiAgcHVibGljIGRyYWdQb3NpdGlvbjogeyBwYWdlWDogbnVtYmVyOyBwYWdlWTogbnVtYmVyIH07XG4gIHB1YmxpYyBncm91cDogc3RyaW5nIHwgc3RyaW5nW107XG4gIHB1YmxpYyBkcmFnRGF0YVRyYW5zZmVyOiBUO1xuICBwdWJsaWMgZHJvcFBvaW50UG9zaXRpb246IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSB7XG4gICAgdGhpcy5kcmFnUG9zaXRpb24gPSBkcmFnRXZlbnQuZHJhZ1Bvc2l0aW9uO1xuICAgIHRoaXMuZ3JvdXAgPSBkcmFnRXZlbnQuZ3JvdXA7XG4gICAgdGhpcy5kcmFnRGF0YVRyYW5zZmVyID0gZHJhZ0V2ZW50LmRyYWdEYXRhVHJhbnNmZXI7XG4gICAgdGhpcy5kcm9wUG9pbnRQb3NpdGlvbiA9IGRyYWdFdmVudC5kcm9wUG9pbnRQb3NpdGlvbjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuZXhwb3J0IGVudW0gRHJhZ0V2ZW50VHlwZSB7XG4gIERSQUdfU1RBUlQsXG4gIERSQUdfTU9WRSxcbiAgRFJBR19FTkQsXG4gIERSQUdfRU5URVIsXG4gIERSQUdfTEVBVkUsXG4gIERST1AsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+IHtcbiAgdHlwZTogRHJhZ0V2ZW50VHlwZTtcbiAgZ3JvdXA/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgZ2hvc3RFbGVtZW50PzogYW55O1xuICBkcmFnUG9zaXRpb246IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuICBkcmFnRGF0YVRyYW5zZmVyPzogVDtcbiAgLy8gRm9yIGRlZmF1bHQgZ2hvc3RzLCB0aGlzIGRyb3BQb2ludFBvc2l0aW9uIGRlbm90ZXMgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgZ2hvc3QgZWxlbWVudC5cbiAgLy8gVGhpcyBjZW50ZXIgcG9pbnQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZ2hvc3QgaXMgb3ZlciBkcm9wcGFibGUgZWxlbWVudHMgb3Igbm90LlxuICBkcm9wUG9pbnRQb3NpdGlvbj86IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UsIERyYWdFdmVudFR5cGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBEcmFnQW5kRHJvcEV2ZW50QnVzU2VydmljZTxUPiB7XG4gIHByaXZhdGUgZHJhZ1N0YXJ0OiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ01vdmU6IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiA9IG5ldyBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4oKTtcbiAgcHJpdmF0ZSBkcmFnRW5kOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJvcDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuXG4gIGdldCBkcmFnU3RhcnRlZCgpOiBPYnNlcnZhYmxlPERyYWdFdmVudEludGVyZmFjZTxUPj4ge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBkcmFnTW92ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnTW92ZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBkcmFnRW5kZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgZ2V0IGRyb3BwZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcm9wLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgYnJvYWRjYXN0KGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pOiB2b2lkIHtcbiAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgRHJhZ0V2ZW50VHlwZS5EUkFHX1NUQVJUOlxuICAgICAgICB0aGlzLmRyYWdTdGFydC5uZXh0KGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19NT1ZFOlxuICAgICAgICB0aGlzLmRyYWdNb3ZlLm5leHQoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRHJhZ0V2ZW50VHlwZS5EUkFHX0VORDpcbiAgICAgICAgdGhpcy5kcmFnRW5kLm5leHQoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRHJhZ0V2ZW50VHlwZS5EUk9QOlxuICAgICAgICB0aGlzLmRyb3AubmV4dChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBOZ1pvbmUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UsIERyYWdFdmVudFR5cGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcbmltcG9ydCB7IERyYWdBbmREcm9wRXZlbnRCdXNTZXJ2aWNlIH0gZnJvbSAnLi9kcmFnLWFuZC1kcm9wLWV2ZW50LWJ1cy5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERyYWdFdmVudExpc3RlbmVyU2VydmljZTxUPiB7XG4gIHByaXZhdGUgZHJhZ2dhYmxlRWw6IGFueTtcblxuICAvLyBjb250YWlucyB0aGUgc3RhcnRpbmcgZXZlbnRzIHN1Y2ggYXMgbW91c2Vkb3duIGFuZCB0b3VjaHN0YXJ0XG4gIHByaXZhdGUgbGlzdGVuZXJzOiAoKCkgPT4gdm9pZClbXTtcbiAgLy8gY29udGFpbnMgdGhlIG5lc3RlZCBldmVudHMgdGhhdCBoYXBwZW5zIGFmdGVyL2luc2lkZSB0aGUgc3RhcnRpbmcgZXZlbnRzXG4gIC8vIHN1Y2ggYXMgc2VsZWN0c3RhcnQsIG1vdXNlbW92ZS90b3VjaG1vdmUsIG1vdXNldXAvdG91Y2hlbmRcbiAgcHJpdmF0ZSBuZXN0ZWRMaXN0ZW5lcnM6ICgoKSA9PiB2b2lkKVtdO1xuXG4gIHByaXZhdGUgZHJhZ1N0YXJ0OiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ01vdmU6IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiA9IG5ldyBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4oKTtcbiAgcHJpdmF0ZSBkcmFnRW5kOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG5cbiAgcHJpdmF0ZSBoYXNEcmFnU3RhcnRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBkcmFnU3RhcnRlZCgpOiBPYnNlcnZhYmxlPERyYWdFdmVudEludGVyZmFjZTxUPj4ge1xuICAgIHJldHVybiB0aGlzLmRyYWdTdGFydC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBkcmFnTW92ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnTW92ZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBkcmFnRW5kZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnRW5kLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGV2ZW50QnVzOiBEcmFnQW5kRHJvcEV2ZW50QnVzU2VydmljZTxUPikge31cblxuICAvLyBEcmFnZ2FibGUgY29tcG9uZW50IHNldHMgdGhlc2UgcHJvcGVydGllczpcbiAgcHVibGljIGRyYWdEYXRhVHJhbnNmZXI/OiBUO1xuICBwdWJsaWMgZ3JvdXA/OiBzdHJpbmcgfCBzdHJpbmdbXTtcblxuICAvLyBEcmFnZ2FibGVHaG9zdCBjb21wb25lbnQgc2V0cyB0aGVzZSBwcm9wZXJ0aWVzOlxuICBwdWJsaWMgZ2hvc3RFbGVtZW50PzogYW55O1xuICBwdWJsaWMgZHJvcFBvaW50UG9zaXRpb24/OiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfTtcblxuICBwdWJsaWMgYXR0YWNoRHJhZ0xpc3RlbmVycyhkcmFnZ2FibGVFbDogTm9kZSkge1xuICAgIHRoaXMuZHJhZ2dhYmxlRWwgPSBkcmFnZ2FibGVFbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtcbiAgICAgIHRoaXMuY3VzdG9tRHJhZ0V2ZW50KHRoaXMuZHJhZ2dhYmxlRWwsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnKSxcbiAgICAgIHRoaXMuY3VzdG9tRHJhZ0V2ZW50KHRoaXMuZHJhZ2dhYmxlRWwsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCcpLFxuICAgIF07XG4gIH1cblxuICBwdWJsaWMgZGV0YWNoRHJhZ0xpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLm1hcChldmVudCA9PiBldmVudCgpKTtcbiAgICB9XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzLCBvbmNlIHVzZXJzIHN0YXJ0IGRyYWdnaW5nIHdpdGggbW91c2Vkb3duL3RvdWNoc3RhcnQgZXZlbnRzLFxuICAgIC8vIHRoZXkgd2lsbCBlbmQgZHJhZ2dpbmcgYXQgb25lIHBvaW50IHdpdGggbW91c2V1cC90b3VjaGVuZC5cbiAgICAvLyBIb3dldmVyLCB0aGVyZSBtaWdodCBiZSBhIGZldyBjYXNlcyB3aGVyZSBtb3VzZWRvd24vdG91Y2hzdGFydCBldmVudHMgZ2V0IHJlZ2lzdGVyZWQsXG4gICAgLy8gYnV0IHRoZSBkcmFnZ2FibGUgZWxlbWVudCBnZXRzIHJlbW92ZWQgYmVmb3JlIHVzZXIgZW5kcyBkcmFnZ2luZy5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBhdHRhY2hlZCBsaXN0ZW5lcnMgdGhhdCBoYXBwZW5lZCBkdXJpbmcgdGhlIG1vdXNlZG93bi90b3VjaHN0YXJ0IGV2ZW50cy5cbiAgICBpZiAodGhpcy5uZXN0ZWRMaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzLm1hcChldmVudCA9PiBldmVudCgpKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGN1c3RvbURyYWdFdmVudChlbGVtZW50OiBOb2RlLCBzdGFydE9uRXZlbnQ6IHN0cmluZywgbW92ZU9uRXZlbnQ6IHN0cmluZywgZW5kT25FdmVudDogc3RyaW5nKTogKCkgPT4gdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsIHN0YXJ0T25FdmVudCwgKCkgPT4ge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBuZXN0ZWQgbGlzdGVuZXJzJyBwcm9wZXJ0eSB3aXRoIGEgbmV3IGVtcHR5IGFycmF5O1xuICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMgPSBbXTtcblxuICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gZGlzYWJsZSBzZWxlY3Rpb24gZHVyaW5nIGRyYWdnaW5nIChlc3BlY2lhbGx5IGluIEVER0UvSUUxMSkuXG4gICAgICB0aGlzLm5lc3RlZExpc3RlbmVycy5wdXNoKFxuICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCAnc2VsZWN0c3RhcnQnLCAoc2VsZWN0RXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgc2VsZWN0RXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzZWxlY3RFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIExpc3RlbiB0byBtb3VzZW1vdmUvdG91Y2htb3ZlIGV2ZW50cyBvdXRzaWRlIG9mIGFuZ3VsYXIgem9uZS5cbiAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzLnB1c2goXG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgbW92ZU9uRXZlbnQsIChtb3ZlRXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSBpcyBuZWVkZWQgaGVyZSB0byBwcmV2ZW50IG5lc3RlZCBkcmFnZ2FibGVzIGZyb20gZ2V0dGluZyBkcmFnZ2VkXG4gICAgICAgICAgICAvLyBhbHRvZ2V0aGVyLiBXZSBzaG91bGRuJ3QgdXNlIEV2ZW50LnN0b3BQcm9wYWdhdGlvbigpIGhlcmUgYXMgd2UgYXJlIGxpc3RlbmluZyB0byB0aGUgZXZlbnRzXG4gICAgICAgICAgICAvLyBvbiB0aGUgZ2xvYmFsIGVsZW1lbnQgbGV2ZWwuXG5cbiAgICAgICAgICAgIC8vIFdpdGggRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIGl0IHJlZ2lzdGVycyB0aGUgZXZlbnRzIHNlbnQgZnJvbSB0aGUgaW5uZXIgbW9zdCBkcmFnZ2FibGVcbiAgICAgICAgICAgIC8vIGZpcnN0LiBUaGVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoYXQsIGl0IHN0b3BzIGxpc3RlbmluZyB0byB0aGUgc2FtZSB0eXBlIG9mIGV2ZW50cyBvbiB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gZWxlbWVudC4gU28gdGhpcyB3aWxsIGhlbHAgdXMgdG8gbm90IHJlZ2lzdGVyIHRoZSBzYW1lIGV2ZW50cyB0aGF0IHdvdWxkIGNvbWUgZnJvbSB0aGUgcGFyZW50XG4gICAgICAgICAgICAvLyBsZXZlbCBkcmFnZ2FibGVzIGV2ZW50dWFsbHkuXG5cbiAgICAgICAgICAgIG1vdmVFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuaGFzRHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBGaXJlIFwiZHJhZ3N0YXJ0XCJcbiAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3QobW92ZUV2ZW50LCBEcmFnRXZlbnRUeXBlLkRSQUdfU1RBUlQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gRmlyZSBcImRyYWdtb3ZlXCJcbiAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3QobW92ZUV2ZW50LCBEcmFnRXZlbnRUeXBlLkRSQUdfTU9WRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBMaXN0ZW4gdG8gbW91c2V1cC90b3VjaGVuZCBldmVudHMuXG4gICAgICB0aGlzLm5lc3RlZExpc3RlbmVycy5wdXNoKFxuICAgICAgICB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCBlbmRPbkV2ZW50LCAoZW5kRXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIC8vIEZpcmUgXCJkcmFnZW5kXCIgb25seSBpZiBkcmFnc3RhcnQgaXMgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgdGhpcy5oYXNEcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5icm9hZGNhc3QoZW5kRXZlbnQsIERyYWdFdmVudFR5cGUuRFJBR19FTkQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdlIG11c3QgcmVtb3ZlIHRoZSB0aGUgbmVzdGVkIGxpc3RlbmVycyBldmVyeSB0aW1lIGRyYWcgY29tcGxldGVzLlxuICAgICAgICAgIGlmICh0aGlzLm5lc3RlZExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMubWFwKGV2ZW50ID0+IGV2ZW50KCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGJyb2FkY2FzdChldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQsIGV2ZW50VHlwZTogRHJhZ0V2ZW50VHlwZSk6IHZvaWQge1xuICAgIGNvbnN0IGRyYWdFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+ID0gdGhpcy5nZW5lcmF0ZURyYWdFdmVudChldmVudCwgZXZlbnRUeXBlKTtcblxuICAgIHN3aXRjaCAoZHJhZ0V2ZW50LnR5cGUpIHtcbiAgICAgIGNhc2UgRHJhZ0V2ZW50VHlwZS5EUkFHX1NUQVJUOlxuICAgICAgICB0aGlzLmRyYWdTdGFydC5uZXh0KGRyYWdFdmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEcmFnRXZlbnRUeXBlLkRSQUdfTU9WRTpcbiAgICAgICAgdGhpcy5kcmFnTW92ZS5uZXh0KGRyYWdFdmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEcmFnRXZlbnRUeXBlLkRSQUdfRU5EOlxuICAgICAgICB0aGlzLmRyYWdFbmQubmV4dChkcmFnRXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgc2V0IGFmdGVyIHRoZXkgYXJlIGJyb2FkY2FzdGVkIHRvIHRoZSBEcmFnZ2FibGVHaG9zdCBjb21wb25lbnQuXG4gICAgZHJhZ0V2ZW50Lmdob3N0RWxlbWVudCA9IHRoaXMuZ2hvc3RFbGVtZW50O1xuICAgIGRyYWdFdmVudC5kcm9wUG9pbnRQb3NpdGlvbiA9IHRoaXMuZHJvcFBvaW50UG9zaXRpb247XG5cbiAgICB0aGlzLmV2ZW50QnVzLmJyb2FkY2FzdChkcmFnRXZlbnQpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZURyYWdFdmVudChldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQsIGV2ZW50VHlwZTogRHJhZ0V2ZW50VHlwZSk6IERyYWdFdmVudEludGVyZmFjZTxUPiB7XG4gICAgbGV0IG5hdGl2ZUV2ZW50OiBhbnk7XG5cbiAgICBpZiAoKDxUb3VjaEV2ZW50PmV2ZW50KS5oYXNPd25Qcm9wZXJ0eSgnY2hhbmdlZFRvdWNoZXMnKSkge1xuICAgICAgbmF0aXZlRXZlbnQgPSAoPFRvdWNoRXZlbnQ+ZXZlbnQpLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYXRpdmVFdmVudCA9IGV2ZW50O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBldmVudFR5cGUsXG4gICAgICBkcmFnUG9zaXRpb246IHsgcGFnZVg6IG5hdGl2ZUV2ZW50LnBhZ2VYLCBwYWdlWTogbmF0aXZlRXZlbnQucGFnZVkgfSxcbiAgICAgIGdyb3VwOiB0aGlzLmdyb3VwLFxuICAgICAgZHJhZ0RhdGFUcmFuc2ZlcjogdGhpcy5kcmFnRGF0YVRyYW5zZmVyLFxuICAgICAgZ2hvc3RFbGVtZW50OiB0aGlzLmdob3N0RWxlbWVudCxcbiAgICB9O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5cbi8vIFRoaXMgc2VydmljZSBpcyB1c2VkIHRvIGNhcHR1cmUgdGhlIHN0YXRlIG9mIGNsckRyYWdnYWJsZSBlbGVtZW50XG4vLyBhdCBhIGNlcnRhaW4gZXZlbnQgYW5kIHBhc3NlcyBpdCB0byBjbHJEcmFnZ2FibGVHaG9zdCBjb21wb25lbnQuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRHJhZ2dhYmxlU25hcHNob3RTZXJ2aWNlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyKSB7fVxuXG4gIHByaXZhdGUgZHJhZ2dhYmxlRWxDbGllbnRSZWN0OiBDbGllbnRSZWN0O1xuICBwcml2YXRlIHNuYXBzaG90RHJhZ0V2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD47XG5cbiAgcHVibGljIGNhcHR1cmUoZWw6IE5vZGUsIGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pOiB2b2lkIHtcbiAgICB0aGlzLmRyYWdnYWJsZUVsQ2xpZW50UmVjdCA9IHRoaXMuZG9tQWRhcHRlci5jbGllbnRSZWN0KGVsKTtcbiAgICB0aGlzLnNuYXBzaG90RHJhZ0V2ZW50ID0gZXZlbnQ7XG4gIH1cbiAgcHVibGljIGRpc2NhcmQoKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuZHJhZ2dhYmxlRWxDbGllbnRSZWN0O1xuICAgIGRlbGV0ZSB0aGlzLnNuYXBzaG90RHJhZ0V2ZW50O1xuICB9XG4gIGdldCBoYXNEcmFnZ2FibGVTdGF0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLnNuYXBzaG90RHJhZ0V2ZW50ICYmICEhdGhpcy5kcmFnZ2FibGVFbENsaWVudFJlY3Q7XG4gIH1cbiAgZ2V0IGNsaWVudFJlY3QoKTogQ2xpZW50UmVjdCB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ2dhYmxlRWxDbGllbnRSZWN0O1xuICB9XG4gIGdldCBkcmFnRXZlbnQoKTogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5zbmFwc2hvdERyYWdFdmVudDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIE5nWm9uZSwgT25EZXN0cm95LCBPcHRpb25hbCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcbmltcG9ydCB7IERyYWdFdmVudExpc3RlbmVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RyYWctZXZlbnQtbGlzdGVuZXIuc2VydmljZSc7XG5pbXBvcnQgeyBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kcmFnZ2FibGUtc25hcHNob3Quc2VydmljZSc7XG5cbnR5cGUgUGFnZVBvc2l0aW9uID0ge1xuICBwYWdlWDogbnVtYmVyO1xuICBwYWdlWTogbnVtYmVyO1xufTtcbnR5cGUgT2Zmc2V0UG9zaXRpb24gPSB7XG4gIHRvcDogbnVtYmVyO1xuICBsZWZ0OiBudW1iZXI7XG59O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZHJhZ2dhYmxlLWdob3N0JyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ2xlYXZlQW5pbWF0aW9uJywgW1xuICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xuICAgICAgICBzdHlsZSh7IGxlZnQ6ICcqJywgdG9wOiAnKicgfSksXG4gICAgICAgIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IHRvcDogJ3t7dG9wfX0nLCBsZWZ0OiAne3tsZWZ0fX0nIH0pKSxcbiAgICAgIF0pLFxuICAgIF0pLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcmFnZ2FibGVHaG9zdDxUPiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgZHJhZ2dhYmxlR2hvc3RFbDogYW55O1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBASG9zdEJpbmRpbmcoJ0BsZWF2ZUFuaW1hdGlvbicpIGxlYXZlQW5pbUNvbmZpZyA9IHsgdmFsdWU6IDAsIHBhcmFtczogeyB0b3A6ICcwcHgnLCBsZWZ0OiAnMHB4JyB9IH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRyYWdFdmVudExpc3RlbmVyOiBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD4sXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkcmFnZ2FibGVTbmFwc2hvdDogRHJhZ2dhYmxlU25hcHNob3RTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lXG4gICkge1xuICAgIGlmICghdGhpcy5kcmFnRXZlbnRMaXN0ZW5lciB8fCAhdGhpcy5kcmFnZ2FibGVTbmFwc2hvdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2xyLWRyYWdnYWJsZS1naG9zdCBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHJEcmFnZ2FibGUgZGlyZWN0aXZlLicpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ2dhYmxlR2hvc3RFbCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcblxuICAgIC8vIE5lZWQgdG8gdXNlIFJlbmRlcmVyMiBhcyBpdCBydW5zIG91dHNpZGUgb2YgTmdab25lXG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmRyYWdnYWJsZUdob3N0RWwsICdkcmFnZ2FibGUtZ2hvc3QnKTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBnaG9zdCBlbGVtZW50IGluIERyYWdFdmVudExpc3RlbmVyIHRvIHBhc3MgaW4gYSBDbHJEcmFnRXZlbnQuXG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5naG9zdEVsZW1lbnQgPSB0aGlzLmRyYWdnYWJsZUdob3N0RWw7XG5cbiAgICAvLyBEZWZhdWx0IGdob3N0IHNpemUgZ2V0cyB0aGUgc2l6ZSBvZiBDbHJEcmFnZ2FibGUgZWxlbWVudC5cbiAgICB0aGlzLnNldERlZmF1bHRHaG9zdFNpemUodGhpcy5kcmFnZ2FibGVHaG9zdEVsKTtcblxuICAgIGNvbnN0IG9mZnNldDogT2Zmc2V0UG9zaXRpb24gPSB7XG4gICAgICB0b3A6IHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuaGFzRHJhZ2dhYmxlU3RhdGVcbiAgICAgICAgPyB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmRyYWdFdmVudC5kcmFnUG9zaXRpb24ucGFnZVkgLSB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3QudG9wXG4gICAgICAgIDogMCxcbiAgICAgIGxlZnQ6IHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuaGFzRHJhZ2dhYmxlU3RhdGVcbiAgICAgICAgPyB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmRyYWdFdmVudC5kcmFnUG9zaXRpb24ucGFnZVggLSB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3QubGVmdFxuICAgICAgICA6IDAsXG4gICAgfTtcblxuICAgIGxldCBpc0FuaW1hdGlvbkNvbmZpZ3VyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnTW92ZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIC8vIE9uIHRoZSBmaXJzdCBkcmFnIG1vdmUgZXZlbnQsIHdlIGNvbmZpZ3VyZSB0aGUgYW5pbWF0aW9uIGFzIGl0J3MgZGVwZW5kZW50IG9uIHRoZSBmaXJzdCBkcmFnIGV2ZW50LlxuICAgICAgICBpZiAoIWlzQW5pbWF0aW9uQ29uZmlndXJlZCkge1xuICAgICAgICAgIGlmICh0aGlzLmRyYWdnYWJsZVNuYXBzaG90Lmhhc0RyYWdnYWJsZVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVUb09uTGVhdmUoXG4gICAgICAgICAgICAgIGAke3RoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC50b3B9cHhgLFxuICAgICAgICAgICAgICBgJHt0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3QubGVmdH1weGBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvT25MZWF2ZShgJHtldmVudC5kcmFnUG9zaXRpb24ucGFnZVl9cHhgLCBgJHtldmVudC5kcmFnUG9zaXRpb24ucGFnZVh9cHhgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXNBbmltYXRpb25Db25maWd1cmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBkcmFnZ2FibGUgZ2hvc3QuXG4gICAgICAgIGNvbnN0IHRvcExlZnRQb3NpdGlvbjogUGFnZVBvc2l0aW9uID0gdGhpcy5maW5kVG9wTGVmdFBvc2l0aW9uKGV2ZW50LmRyYWdQb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvblN0eWxlKHRoaXMuZHJhZ2dhYmxlR2hvc3RFbCwgdG9wTGVmdFBvc2l0aW9uLnBhZ2VYLCB0b3BMZWZ0UG9zaXRpb24ucGFnZVkpO1xuICAgICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyb3BQb2ludFBvc2l0aW9uID0gdGhpcy5maW5kRHJvcFBvaW50UG9zaXRpb24odG9wTGVmdFBvc2l0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0RGVmYXVsdEdob3N0U2l6ZShlbDogTm9kZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRyYWdnYWJsZVNuYXBzaG90Lmhhc0RyYWdnYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLnNldFNpemVTdHlsZShlbCwgdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LndpZHRoLCB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3QuaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFuaW1hdGVUb09uTGVhdmUodG9wOiBzdHJpbmcsIGxlZnQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICB0aGlzLmxlYXZlQW5pbUNvbmZpZyA9IHsgdmFsdWU6IDAsIHBhcmFtczogeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9IH07XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGZpbmRUb3BMZWZ0UG9zaXRpb24oZHJhZ1Bvc2l0aW9uOiBQYWdlUG9zaXRpb24sIG9mZnNldDogT2Zmc2V0UG9zaXRpb24pOiBQYWdlUG9zaXRpb24ge1xuICAgIHJldHVybiB7IHBhZ2VYOiBkcmFnUG9zaXRpb24ucGFnZVggLSBvZmZzZXQubGVmdCwgcGFnZVk6IGRyYWdQb3NpdGlvbi5wYWdlWSAtIG9mZnNldC50b3AgfTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZERyb3BQb2ludFBvc2l0aW9uKHRvcExlZnRQb3NpdGlvbjogUGFnZVBvc2l0aW9uKTogUGFnZVBvc2l0aW9uIHtcbiAgICBpZiAodGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5oYXNEcmFnZ2FibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVg6IHRvcExlZnRQb3NpdGlvbi5wYWdlWCArIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC53aWR0aCAvIDIsXG4gICAgICAgIHBhZ2VZOiB0b3BMZWZ0UG9zaXRpb24ucGFnZVkgKyB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3QuaGVpZ2h0IC8gMixcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b3BMZWZ0UG9zaXRpb247XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRTaXplU3R5bGUoZWw6IE5vZGUsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJ3dpZHRoJywgYCR7d2lkdGh9cHhgKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAnaGVpZ2h0JywgYCR7aGVpZ2h0fXB4YCk7XG4gIH1cblxuICBwcml2YXRlIHNldFBvc2l0aW9uU3R5bGUoZWw6IE5vZGUsIGxlZnQ6IG51bWJlciwgdG9wOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAnbGVmdCcsIGAke2xlZnR9cHhgKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAndG9wJywgYCR7dG9wfXB4YCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJ3Zpc2liaWxpdHknLCAndmlzaWJsZScpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgT25EZXN0cm95LCBPcHRpb25hbCwgU2tpcFNlbGYsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcbmltcG9ydCB7IERyYWdFdmVudExpc3RlbmVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RyYWctZXZlbnQtbGlzdGVuZXIuc2VydmljZSc7XG5cbi8vIFRoaXMgc3RydWN0dXJhbCBkaXJlY3RpdmUgd2lsbCBiZSB1c2VkIG1haW5seSB0b2dldGhlciB3aXRoIGBjbHItZHJhZ2dhYmxlLWdob3N0YCBkaXJlY3RpdmUgaW5zaWRlIG9mIGNsckRyYWdnYWJsZVxuLy8gZGlyZWN0aXZlLiBUaGUgZGlyZWN0aXZlIGlzIHJlc3BvbnNpYmxlIGZvciBpbnN0YW50aWF0aW5nIGBjbHItZHJhZ2dhYmxlLWdob3N0YCBkaXJlY3RpdmUgb25seSBkdXJpbmcgZHJhZ2dpbmcgc29cbi8vIHRoYXQgQW5ndWxhciBDaGFuZ2UgRGV0ZWN0aW9uIGlzIHByZXZlbnRlZCBmcm9tIHJ1bm5pbmcgaWYgYSBjb21wb25lbnQgb3IgZGlyZWN0aXZlIGlzIHBsYWNlZCBpbnNpZGUgb2YgdGhlXG4vLyBgY2xyLWRyYWdnYWJsZS1naG9zdGAgZGlyZWN0aXZlLlxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xySWZEcmFnZ2VkXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJJZkRyYWdnZWQ8VD4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgQE9wdGlvbmFsKClcbiAgICBAU2tpcFNlbGYoKVxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZHJhZ0V2ZW50TGlzdGVuZXI6IERyYWdFdmVudExpc3RlbmVyU2VydmljZTxUPlxuICApIHtcbiAgICBpZiAoIXRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIgfHwgIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSAqY2xySWZEcmFnZ2VkIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsckRyYWdnYWJsZSBkaXJlY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdTdGFydGVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdFbmRlZC5zdWJzY3JpYmUoKGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xlYXIoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlIH0gZnJvbSAnLi9kcmFnLWV2ZW50LWxpc3RlbmVyLnNlcnZpY2UnO1xuXG4vLyBUaGlzIHByb3ZpZGVyIHJlZ2lzdGVycyB0aGUgZHJhZyBoYW5kbGUgZWxlbWVudC5cbi8vIFdoZW4gaXQgcmVnaXN0ZXJzIGEgZWxlbWVudCBhcyBhIGRyYWcgaGFuZGxlLCBpdCBhdHRhY2hlcyB0aGF0IGVsZW1lbnQgdG8gdGhlIGxpc3RlbmVycyBmcm9tIENsckRyYWdFdmVudExpc3RlbmVyLlxuLy8gQWxzbywgaXQgYWRkcyB0aGUgXCJkcmFnLWhhbmRsZVwiIGNzcyBjbGFzcyB0byB0aGUgcmVnaXN0ZXJlZCBlbGVtZW50IHRocm91Z2ggUmVuZGVyZXIuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2U8VD4ge1xuICBwcml2YXRlIF9jdXN0b21IYW5kbGVFbDogYW55O1xuICBwcml2YXRlIF9kZWZhdWx0SGFuZGxlRWw6IGFueTtcblxuICBnZXQgZGVmYXVsdEhhbmRsZUVsKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWZhdWx0SGFuZGxlRWw7XG4gIH1cblxuICBzZXQgZGVmYXVsdEhhbmRsZUVsKGVsOiBOb2RlKSB7XG4gICAgdGhpcy5fZGVmYXVsdEhhbmRsZUVsID0gZWw7IC8vIGRlZmF1bHRIYW5kbGVFbCB3aWxsIGJlIHVzdWFsbHkgdGhlIGNsckRyYWdnYWJsZSBlbGVtZW50LlxuXG4gICAgLy8gSWYgdGhlIGN1c3RvbUhhbmRsZUVsIGhhcyBiZWVuIHJlZ2lzdGVyZWQsXG4gICAgLy8gZG9uJ3QgbWFrZSB0aGUgZGVmYXVsdEhhbmRsZUVsIHRoZSBkcmFnIGhhbmRsZSB5ZXQgdW50aWwgdGhlIGN1c3RvbUhhbmRsZUVsIGlzIHVucmVnaXN0ZXJlZC5cbiAgICBpZiAoIXRoaXMuX2N1c3RvbUhhbmRsZUVsKSB7XG4gICAgICB0aGlzLm1ha2VFbGVtZW50SGFuZGxlKHRoaXMuX2RlZmF1bHRIYW5kbGVFbCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkcmFnRXZlbnRMaXN0ZW5lcjogRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlPFQ+LCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cbiAgcHJpdmF0ZSBtYWtlRWxlbWVudEhhbmRsZShlbDogTm9kZSkge1xuICAgIGlmICh0aGlzLl9kZWZhdWx0SGFuZGxlRWwgJiYgdGhpcy5fZGVmYXVsdEhhbmRsZUVsICE9PSBlbCkge1xuICAgICAgLy8gQmVmb3JlIG1ha2luZyBhbiBlbGVtZW50IHRoZSBjdXN0b20gaGFuZGxlIGVsZW1lbnQsXG4gICAgICAvLyB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBleGlzdGluZyBkcmFnLWhhbmRsZSBjbGFzcyBmcm9tIHRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZGVmYXVsdEhhbmRsZUVsLCAnZHJhZy1oYW5kbGUnKTtcbiAgICB9XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5hdHRhY2hEcmFnTGlzdGVuZXJzKGVsKTtcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGVsLCAnZHJhZy1oYW5kbGUnKTtcbiAgfVxuXG4gIGdldCBjdXN0b21IYW5kbGVFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VzdG9tSGFuZGxlRWw7XG4gIH1cblxuICBwdWJsaWMgcmVnaXN0ZXJDdXN0b21IYW5kbGUoZWw6IE5vZGUpIHtcbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRldGFjaERyYWdMaXN0ZW5lcnMoKTsgLy8gcmVtb3ZlcyB0aGUgZXhpc3RpbmcgbGlzdGVuZXJzXG4gICAgdGhpcy5fY3VzdG9tSGFuZGxlRWwgPSBlbDtcbiAgICB0aGlzLm1ha2VFbGVtZW50SGFuZGxlKHRoaXMuX2N1c3RvbUhhbmRsZUVsKTtcbiAgfVxuXG4gIHB1YmxpYyB1bnJlZ2lzdGVyQ3VzdG9tSGFuZGxlKCkge1xuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZGV0YWNoRHJhZ0xpc3RlbmVycygpOyAvLyByZW1vdmVzIHRoZSBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2N1c3RvbUhhbmRsZUVsLCAnZHJhZy1oYW5kbGUnKTtcbiAgICBkZWxldGUgdGhpcy5fY3VzdG9tSGFuZGxlRWw7XG4gICAgLy8gaWYgZGVmYXVsdCBoYW5kbGUgaXMgc2V0LCBtYWtlIHRoYXQgaGFuZGxlXG4gICAgaWYgKHRoaXMuX2RlZmF1bHRIYW5kbGVFbCkge1xuICAgICAgdGhpcy5tYWtlRWxlbWVudEhhbmRsZSh0aGlzLl9kZWZhdWx0SGFuZGxlRWwpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8vIFRoaXMgc2VydmljZSBjbGFzcyBhZGRzIGFuZCByZW1vdmVzIHRoZSBcImluLWRyYWdcIiBjbGFzcyB0byB0aGUgZG9jdW1lbnQgYm9keSBlbGVtZW50XG4vLyB0aHJvdWdoIGl0cyBwdWJsaWMgZW50ZXIoKSBhbmQgZXhpdCgpIG1ldGhvZHMuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgR2xvYmFsRHJhZ01vZGVTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIGVudGVyKCk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2luLWRyYWcnKTtcbiAgfVxuXG4gIGV4aXQoKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnaW4tZHJhZycpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnRGYWN0b3J5LFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIENvbnRlbnRDaGlsZCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdG9yLFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBDbHJEcmFnRXZlbnQgfSBmcm9tICcuLi9kcmFnLWV2ZW50JztcbmltcG9ydCB7IENsckRyYWdnYWJsZUdob3N0IH0gZnJvbSAnLi4vZHJhZ2dhYmxlLWdob3N0JztcbmltcG9ydCB7IENscklmRHJhZ2dlZCB9IGZyb20gJy4uL2lmLWRyYWdnZWQnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvZHJhZy1ldmVudC1saXN0ZW5lci5zZXJ2aWNlJztcbmltcG9ydCB7IERyYWdIYW5kbGVSZWdpc3RyYXJTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2RyYWctaGFuZGxlLXJlZ2lzdHJhci5zZXJ2aWNlJztcbmltcG9ydCB7IERyYWdnYWJsZVNuYXBzaG90U2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9kcmFnZ2FibGUtc25hcHNob3Quc2VydmljZSc7XG5pbXBvcnQgeyBHbG9iYWxEcmFnTW9kZVNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvZ2xvYmFsLWRyYWctbW9kZS5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsckRyYWdnYWJsZV0nLFxuICBwcm92aWRlcnM6IFtcbiAgICBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2UsXG4gICAgRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2UsXG4gICAgRHJhZ2dhYmxlU25hcHNob3RTZXJ2aWNlLFxuICAgIEdsb2JhbERyYWdNb2RlU2VydmljZSxcbiAgICBEb21BZGFwdGVyLFxuICBdLFxuICBob3N0OiB7ICdbY2xhc3MuZHJhZ2dhYmxlXSc6ICd0cnVlJywgJ1tjbGFzcy5iZWluZy1kcmFnZ2VkXSc6ICdkcmFnT24nIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyYWdnYWJsZTxUPiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgZHJhZ2dhYmxlRWw6IGFueTtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIGNvbXBvbmVudEZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8Q2xyRHJhZ2dhYmxlR2hvc3Q8VD4+O1xuICBwdWJsaWMgZHJhZ09uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGRyYWdFdmVudExpc3RlbmVyOiBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBkcmFnSGFuZGxlUmVnaXN0cmFyOiBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZTxUPixcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBwcml2YXRlIGRyYWdnYWJsZVNuYXBzaG90OiBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBnbG9iYWxEcmFnTW9kZTogR2xvYmFsRHJhZ01vZGVTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuZHJhZ2dhYmxlRWwgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy5jb21wb25lbnRGYWN0b3J5ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3Rvcnk8Q2xyRHJhZ2dhYmxlR2hvc3Q8VD4+KENsckRyYWdnYWJsZUdob3N0KTtcbiAgfVxuXG4gIEBDb250ZW50Q2hpbGQoQ2xySWZEcmFnZ2VkKSBjdXN0b21HaG9zdDogQ2xySWZEcmFnZ2VkPFQ+O1xuXG4gIEBJbnB1dCgnY2xyRHJhZ2dhYmxlJylcbiAgc2V0IGRhdGFUcmFuc2Zlcih2YWx1ZTogVCkge1xuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ0RhdGFUcmFuc2ZlciA9IHZhbHVlO1xuICB9XG5cbiAgQElucHV0KCdjbHJHcm91cCcpXG4gIHNldCBncm91cCh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmdyb3VwID0gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZURlZmF1bHRHaG9zdChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSB7XG4gICAgdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jYXB0dXJlKHRoaXMuZHJhZ2dhYmxlRWwsIGV2ZW50KTtcbiAgICAvLyBOT1RFOiBUaGUgZGVmYXVsdCBnaG9zdCBlbGVtZW50IHdpbGwgYXBwZWFyXG4gICAgLy8gbmV4dCB0byB0aGUgY2xyRHJhZ2dhYmxlIGluIHRoZSBET00gYXMgYSBzaWJsaW5nIGVsZW1lbnQuXG4gICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudCh0aGlzLmNvbXBvbmVudEZhY3RvcnksIDAsIHRoaXMuaW5qZWN0b3IsIFtcbiAgICAgIFt0aGlzLmRyYWdnYWJsZUVsLmNsb25lTm9kZSh0cnVlKV0sXG4gICAgXSk7XG4gIH1cblxuICBwcml2YXRlIGRlc3Ryb3lEZWZhdWx0R2hvc3QoKSB7XG4gICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7XG4gICAgdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5kaXNjYXJkKCk7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEcmFnU3RhcnQnKSBkcmFnU3RhcnRFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ01vdmUnKSBkcmFnTW92ZUVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnRW5kJykgZHJhZ0VuZEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVSZWdpc3RyYXIuZGVmYXVsdEhhbmRsZUVsID0gdGhpcy5kcmFnZ2FibGVFbDtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnU3RhcnRlZC5zdWJzY3JpYmUoKGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxEcmFnTW9kZS5lbnRlcigpO1xuICAgICAgICB0aGlzLmRyYWdPbiA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5jdXN0b21HaG9zdCkge1xuICAgICAgICAgIHRoaXMuY3JlYXRlRGVmYXVsdEdob3N0KGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0RW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZXZlbnQpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ01vdmVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLmRyYWdNb3ZlRW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZXZlbnQpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ0VuZGVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbERyYWdNb2RlLmV4aXQoKTtcbiAgICAgICAgdGhpcy5kcmFnT24gPSBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUdob3N0KSB7XG4gICAgICAgICAgdGhpcy5kZXN0cm95RGVmYXVsdEdob3N0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnRW5kRW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZXZlbnQpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZGV0YWNoRHJhZ0xpc3RlbmVycygpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBDbHJEcmFnRXZlbnQgfSBmcm9tICcuLi9kcmFnLWV2ZW50JztcbmltcG9ydCB7IERyYWdFdmVudEludGVyZmFjZSwgRHJhZ0V2ZW50VHlwZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2xyRHJvcFRvbGVyYW5jZUludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZHJvcC10b2xlcmFuY2UuaW50ZXJmYWNlJztcbmltcG9ydCB7IERyYWdBbmREcm9wRXZlbnRCdXNTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2RyYWctYW5kLWRyb3AtZXZlbnQtYnVzLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRHJvcHBhYmxlXScsXG4gIHByb3ZpZGVyczogW0RvbUFkYXB0ZXJdLFxuICBob3N0OiB7ICdbY2xhc3MuZHJvcHBhYmxlXSc6ICd0cnVlJywgJ1tjbGFzcy5kcmFnZ2FibGUtbWF0Y2hdJzogJ2lzRHJhZ2dhYmxlTWF0Y2gnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyb3BwYWJsZTxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBkcmFnU3RhcnRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBkcmFnTW92ZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGRyYWdFbmRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIGRyb3BwYWJsZUVsOiBhbnk7XG4gIHByaXZhdGUgY2xpZW50UmVjdDogQ2xpZW50UmVjdDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgZXZlbnRCdXM6IERyYWdBbmREcm9wRXZlbnRCdXNTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7XG4gICAgdGhpcy5kcm9wcGFibGVFbCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIHByaXZhdGUgaXNEcmFnZ2FibGVNYXRjaDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pc0RyYWdnYWJsZU92ZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBzZXQgaXNEcmFnZ2FibGVPdmVyKHZhbHVlOiBib29sZWFuKSB7XG4gICAgLy8gV2UgbmVlZCB0byBhZGQvcmVtb3ZlIHRoaXMgZHJhZ2dhYmxlLW92ZXIgY2xhc3MgdmlhIFJlbmRlcmVyMlxuICAgIC8vIGJlY2F1c2UgaXNEcmFnZ2FibGVPdmVyIGlzIHNldCBvdXRzaWRlIG9mIE5nWm9uZS5cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5kcm9wcGFibGVFbCwgJ2RyYWdnYWJsZS1vdmVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5kcm9wcGFibGVFbCwgJ2RyYWdnYWJsZS1vdmVyJyk7XG4gICAgfVxuICAgIHRoaXMuX2lzRHJhZ2dhYmxlT3ZlciA9IHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfZ3JvdXA6IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIEBJbnB1dCgnY2xyR3JvdXAnKVxuICBzZXQgZ3JvdXAodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5fZ3JvdXAgPSB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX2Ryb3BUb2xlcmFuY2U6IENsckRyb3BUb2xlcmFuY2VJbnRlcmZhY2UgPSB7IHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCB9O1xuXG4gIHByaXZhdGUgZHJvcFRvbGVyYW5jZUdlbmVyYXRvcih0b3AgPSAwLCByaWdodCA9IHRvcCwgYm90dG9tID0gdG9wLCBsZWZ0ID0gcmlnaHQpOiBDbHJEcm9wVG9sZXJhbmNlSW50ZXJmYWNlIHtcbiAgICByZXR1cm4geyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQgfTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRHJvcFRvbGVyYW5jZScpXG4gIHNldCBkcm9wVG9sZXJhbmNlKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcgfCBDbHJEcm9wVG9sZXJhbmNlSW50ZXJmYWNlKSB7XG4gICAgLy8gSWYgdXNlciBwcm92aWRlcyBhbiBvYmplY3QgaGVyZSBhbmQgd2FudHMgdG8gbWFuaXB1bGF0ZS91cGRhdGUgcHJvcGVydGllcyBpbmRpdmlkdWFsbHksXG4gICAgLy8gdGhlIG9iamVjdCBtdXN0IGJlIGltbXV0YWJsZSBhcyB3ZSBnZW5lcmF0ZSBuZXcgb2JqZWN0IGJhc2VkIHVzZXIncyBnaXZlbiBvYmplY3QuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX2Ryb3BUb2xlcmFuY2UgPSB0aGlzLmRyb3BUb2xlcmFuY2VHZW5lcmF0b3IodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdG9sZXJhbmNlVmFsdWVzID0gdmFsdWVcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgICAubWFwKHRvbGVyYW5jZSA9PiBwYXJzZUludCh0b2xlcmFuY2UsIDEwKSk7XG4gICAgICB0aGlzLl9kcm9wVG9sZXJhbmNlID0gdGhpcy5kcm9wVG9sZXJhbmNlR2VuZXJhdG9yKC4uLnRvbGVyYW5jZVZhbHVlcyk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgLy8gVGhlIHZhbHVlIGNvdWxkIGJlIHBhc3NlZCBpbiBhcyB7bGVmdDogMjAsIHRvcDogMzAgfVxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgcmVzdCBvZiB0aGUgZGlyZWN0aW9uIHByb3BlcnRpZXMgc2hvdWxkIGJlIDAuXG4gICAgICAvLyBUaGF0J3Mgd2h5IHdlIGluaXRpYWxpemUgcHJvcGVydGllcyB3aXRoIDAgZmlyc3QsIHRoZW4gb3ZlcnJpZGUgd2l0aCB1c2VyJ3MgZ2l2ZW4gdmFsdWUuXG4gICAgICB0aGlzLl9kcm9wVG9sZXJhbmNlID0geyAuLi50aGlzLmRyb3BUb2xlcmFuY2VHZW5lcmF0b3IoMCksIC4uLnZhbHVlIH07XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRHJhZ1N0YXJ0JykgZHJhZ1N0YXJ0RW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyYWdNb3ZlJykgZHJhZ01vdmVFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ0VuZCcpIGRyYWdFbmRFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ0xlYXZlJykgZHJhZ0xlYXZlRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyYWdFbnRlcicpIGRyYWdFbnRlckVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcm9wJykgZHJvcEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHByaXZhdGUgdW5zdWJzY3JpYmVGcm9tKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0dyb3VwTWF0Y2goZHJhZ2dhYmxlR3JvdXA6IHN0cmluZyB8IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgLy8gQm90aCBEcmFnZ2FibGUgYW5kIERyb3BwYWJsZSBoYXZlIGNsckdyb3VwIGlucHV0LlxuICAgIC8vIFRoZSBjbHJHcm91cCBpbnB1dCBjYW4gYmUgYm90aCBhIHN0cmluZyBrZXkgb3IgYXJyYXkgb2Ygc3RyaW5nIGtleXMgaW4gRHJhZ2dhYmxlIGFuZCBEcm9wcGFibGUuXG5cbiAgICAvLyBJdCdzIG5vdCBtYXRjaCBpZiBEcmFnZ2FibGUgaGFzIG5vIGRlZmluZWQgdmFsdWUgYXNzaWduZWQgdG8gY2xyR3JvdXAsIGJ1dCBEcm9wcGFibGUgaGFzIGEgZGVmaW5lZCBjbHJHcm91cC5cbiAgICBpZiAoIWRyYWdnYWJsZUdyb3VwICYmIHRoaXMuX2dyb3VwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZSBzYW1lIGlzIHRydWUgdGhlIG90aGVyIHdheSByb3VuZC5cbiAgICBpZiAoIXRoaXMuX2dyb3VwICYmIGRyYWdnYWJsZUdyb3VwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSXQncyBtYXRjaCBpZiBib3RoIERyYWdnYWJsZSBhbmQgRHJvcHBhYmxlIGhhdmUgbm8gYXNzaWduZWQgdmFsdWUgZm9yIGNsckdyb3VwLlxuICAgIGlmICghdGhpcy5fZ3JvdXAgJiYgIWRyYWdnYWJsZUdyb3VwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJdCdzIG1hdGNoIGlmIGJvdGggRHJhZ2dhYmxlIGFuZCBEcm9wcGFibGUgaGF2ZSBzaW1wbGUgc3RyaW5nIGtleXMgdGhhdCBhcmUgbWF0Y2hpbmcuXG4gICAgLy8gSXQncyBtYXRjaCBpZiBEcmFnZ2FibGUncyBzaW1wbGUgY2xyR3JvdXAga2V5IGlzIG1hdGNoaW5nIHdpdGggb25lIG9mIHRoZSBjbHJHcm91cCBrZXlzIG9mIERyb3BwYWJsZS4gVGhlXG4gICAgLy8gc2FtZSBpcyB0cnVlIHRoZSBvdGhlciB3YXkgcm91bmQuXG4gICAgLy8gaXQncyBtYXRjaCBpZiBvbmUgb2YgdGhlIGNsckdyb3VwIGtleXMgb2YgRHJvcHBhYmxlIGlzIG1hdGNoaW5nIHdpdGggb25lIG9mIHRoZSBjbHJHcm91cCBrZXlzIG9mIERyYWdnYWJsZS5cbiAgICBpZiAodHlwZW9mIGRyYWdnYWJsZUdyb3VwID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ncm91cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwID09PSBkcmFnZ2FibGVHcm91cDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cC5pbmRleE9mKGRyYWdnYWJsZUdyb3VwKSA+IC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2dyb3VwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZHJhZ2dhYmxlR3JvdXAuaW5kZXhPZih0aGlzLl9ncm91cCkgPiAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ3JvdXAgYXMgc3RyaW5nW10pLnNvbWUoZ3JvdXBLZXkgPT4gZHJhZ2dhYmxlR3JvdXAuaW5kZXhPZihncm91cEtleSkgPiAtMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0luRHJvcEFyZWEocG9pbnQ6IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9KTogYm9vbGVhbiB7XG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jbGllbnRSZWN0KSB7XG4gICAgICB0aGlzLmNsaWVudFJlY3QgPSB0aGlzLmRvbUFkYXB0ZXIuY2xpZW50UmVjdCh0aGlzLmRyb3BwYWJsZUVsKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBwb2ludC5wYWdlWCA+PSB0aGlzLmNsaWVudFJlY3QubGVmdCAtIHRoaXMuX2Ryb3BUb2xlcmFuY2UubGVmdCAmJlxuICAgICAgcG9pbnQucGFnZVggPD0gdGhpcy5jbGllbnRSZWN0LnJpZ2h0ICsgdGhpcy5fZHJvcFRvbGVyYW5jZS5yaWdodCAmJlxuICAgICAgcG9pbnQucGFnZVkgPj0gdGhpcy5jbGllbnRSZWN0LnRvcCAtIHRoaXMuX2Ryb3BUb2xlcmFuY2UudG9wICYmXG4gICAgICBwb2ludC5wYWdlWSA8PSB0aGlzLmNsaWVudFJlY3QuYm90dG9tICsgdGhpcy5fZHJvcFRvbGVyYW5jZS5ib3R0b21cbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkRyYWdTdGFydChkcmFnU3RhcnRFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgLy8gQ2hlY2sgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgaGF2ZSBhIG1hdGNoaW5nIGdyb3VwIGtleS5cbiAgICB0aGlzLmlzRHJhZ2dhYmxlTWF0Y2ggPSB0aGlzLmNoZWNrR3JvdXBNYXRjaChkcmFnU3RhcnRFdmVudC5ncm91cCk7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gZHJhZ01vdmVkIGFuZCBkcmFnRW5kZWQgb25seSBpZiBkcmFnZ2FibGUgYW5kIGRyb3BwYWJsZSBoYXZlIGEgbWF0Y2hpbmcgZ3JvdXAga2V5LlxuICAgIGlmICh0aGlzLmlzRHJhZ2dhYmxlTWF0Y2gpIHtcbiAgICAgIHRoaXMuZHJhZ1N0YXJ0RW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZHJhZ1N0YXJ0RXZlbnQpKTtcbiAgICAgIHRoaXMuZHJhZ01vdmVTdWJzY3JpcHRpb24gPSB0aGlzLmV2ZW50QnVzLmRyYWdNb3ZlZC5zdWJzY3JpYmUoKGRyYWdNb3ZlRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLm9uRHJhZ01vdmUoZHJhZ01vdmVFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZHJhZ0VuZFN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRCdXMuZHJhZ0VuZGVkLnN1YnNjcmliZSgoZHJhZ0VuZEV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgdGhpcy5vbkRyYWdFbmQoZHJhZ0VuZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25EcmFnTW92ZShkcmFnTW92ZUV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pOiB2b2lkIHtcbiAgICBjb25zdCBpc0luRHJvcEFyZWEgPSB0aGlzLmlzSW5Ecm9wQXJlYShkcmFnTW92ZUV2ZW50LmRyb3BQb2ludFBvc2l0aW9uKTtcbiAgICBpZiAoIXRoaXMuX2lzRHJhZ2dhYmxlT3ZlciAmJiBpc0luRHJvcEFyZWEpIHtcbiAgICAgIHRoaXMuaXNEcmFnZ2FibGVPdmVyID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGRyYWdFbnRlckV2ZW50ID0geyAuLi5kcmFnTW92ZUV2ZW50LCB0eXBlOiBEcmFnRXZlbnRUeXBlLkRSQUdfRU5URVIgfTtcbiAgICAgIHRoaXMuZXZlbnRCdXMuYnJvYWRjYXN0KGRyYWdFbnRlckV2ZW50KTtcbiAgICAgIHRoaXMuZHJhZ0VudGVyRW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZHJhZ0VudGVyRXZlbnQpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2lzRHJhZ2dhYmxlT3ZlciAmJiAhaXNJbkRyb3BBcmVhKSB7XG4gICAgICB0aGlzLmlzRHJhZ2dhYmxlT3ZlciA9IGZhbHNlO1xuICAgICAgY29uc3QgZHJhZ0xlYXZlRXZlbnQgPSB7IC4uLmRyYWdNb3ZlRXZlbnQsIHR5cGU6IERyYWdFdmVudFR5cGUuRFJBR19MRUFWRSB9O1xuICAgICAgdGhpcy5ldmVudEJ1cy5icm9hZGNhc3QoZHJhZ0xlYXZlRXZlbnQpO1xuICAgICAgdGhpcy5kcmFnTGVhdmVFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcmFnTGVhdmVFdmVudCkpO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZ01vdmVFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcmFnTW92ZUV2ZW50KSk7XG4gIH1cblxuICBwcml2YXRlIG9uRHJhZ0VuZChkcmFnRW5kRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPik6IHZvaWQge1xuICAgIGlmICh0aGlzLl9pc0RyYWdnYWJsZU92ZXIpIHtcbiAgICAgIGlmIChkcmFnRW5kRXZlbnQuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgIC8vIEJ5IHRoaXMgcG9pbnQsIHRoZSBkcmFnZ2FibGUgZ2hvc3QgY29tcG9uZW50IGlzIGRlc3Ryb3llZCxcbiAgICAgICAgLy8gYnV0IHRoZSBlbGVtZW50IHdvdWxkIGJlIGFjdGl2ZSB1bnRpbCBpdHMgYW5pbWF0aW9uIGNvbXBsZXRlcy5cbiAgICAgICAgLy8gQXMgc3VjaCwgb25jZSB0aGUgZ2hvc3QgaXMgZHJvcHBlZCBvdmVyLCB3ZSB3aWxsIGdpdmUgaXQgXCJkcm9wcGVkXCIgY2xhc3MuXG5cbiAgICAgICAgLy8gVGhpcyBwcm9jZXNzIGNhbm5vdCBiZSBkb25lIGluIHRoZSBnaG9zdCBjb21wb25lbnRcbiAgICAgICAgLy8gYmVjYXVzZSBhbnkgc3Vic2NyaXB0aW9uIHRvIHRoZSBkcm9wIGV2ZW50IGlzIGluZWZmZWN0aXZlIG9yIGludmFsaWRcbiAgICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBoYWQgYmVlbiBhbHJlYWR5IGRlc3Ryb3llZC5cbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhkcmFnRW5kRXZlbnQuZ2hvc3RFbGVtZW50LCAnZHJvcHBlZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkcm9wRXZlbnQgPSB7IC4uLmRyYWdFbmRFdmVudCwgdHlwZTogRHJhZ0V2ZW50VHlwZS5EUk9QIH07XG4gICAgICB0aGlzLmV2ZW50QnVzLmJyb2FkY2FzdChkcm9wRXZlbnQpO1xuICAgICAgdGhpcy5kcm9wRW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZHJvcEV2ZW50KSk7XG4gICAgICB0aGlzLmlzRHJhZ2dhYmxlT3ZlciA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRyYWdFbmRFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcmFnRW5kRXZlbnQpKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbSh0aGlzLmRyYWdNb3ZlU3Vic2NyaXB0aW9uKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbSh0aGlzLmRyYWdFbmRTdWJzY3JpcHRpb24pO1xuICAgIHRoaXMuaXNEcmFnZ2FibGVNYXRjaCA9IGZhbHNlO1xuICAgIGRlbGV0ZSB0aGlzLmNsaWVudFJlY3Q7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmRyYWdTdGFydFN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRCdXMuZHJhZ1N0YXJ0ZWQuc3Vic2NyaWJlKChkcmFnU3RhcnRFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICB0aGlzLm9uRHJhZ1N0YXJ0KGRyYWdTdGFydEV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ1N0YXJ0U3Vic2NyaXB0aW9uKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbSh0aGlzLmRyYWdNb3ZlU3Vic2NyaXB0aW9uKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbSh0aGlzLmRyYWdFbmRTdWJzY3JpcHRpb24pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kcmFnLWhhbmRsZS1yZWdpc3RyYXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJEcmFnSGFuZGxlXScsIGhvc3Q6IHsgJ1tjbGFzcy5kcmFnLWhhbmRsZV0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsckRyYWdIYW5kbGU8VD4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLCBAT3B0aW9uYWwoKSBwcml2YXRlIGRyYWdIYW5kbGVSZWdpc3RyYXI6IERyYWdIYW5kbGVSZWdpc3RyYXJTZXJ2aWNlPFQ+KSB7XG4gICAgaWYgKCF0aGlzLmRyYWdIYW5kbGVSZWdpc3RyYXIpIHtcbiAgICAgIC8vIENsckRyYWdIYW5kbGVSZWdpc3RyYXIgaXMgcHJvdmlkZWQgaW4gQ2xyRHJhZ2dhYmxlIHNvIHdlIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50IGhlcmVcbiAgICAgIC8vIGFzIGNsckRyYWdIYW5kbGUgaXMgcmVxdWlyZWQgdG8gYmUgdXNlZCBvbmx5IGluc2lkZSBvZiBhIGNsckRyYWdnYWJsZSBkaXJlY3RpdmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbHJEcmFnSGFuZGxlIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsckRyYWdnYWJsZSBkaXJlY3RpdmUuJyk7XG4gICAgfVxuICAgIHRoaXMuZHJhZ0hhbmRsZVJlZ2lzdHJhci5yZWdpc3RlckN1c3RvbUhhbmRsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlUmVnaXN0cmFyLnVucmVnaXN0ZXJDdXN0b21IYW5kbGUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRyYWdnYWJsZSB9IGZyb20gJy4vZHJhZ2dhYmxlL2RyYWdnYWJsZSc7XG5pbXBvcnQgeyBDbHJEcm9wcGFibGUgfSBmcm9tICcuL2Ryb3BwYWJsZS9kcm9wcGFibGUnO1xuaW1wb3J0IHsgQ2xySWZEcmFnZ2VkIH0gZnJvbSAnLi9pZi1kcmFnZ2VkJztcbmltcG9ydCB7IENsckRyYWdIYW5kbGUgfSBmcm9tICcuL2RyYWctaGFuZGxlJztcbmltcG9ydCB7IENsckRyYWdnYWJsZUdob3N0IH0gZnJvbSAnLi9kcmFnZ2FibGUtZ2hvc3QnO1xuXG5leHBvcnQgY29uc3QgQ0xSX0RSQUdfQU5EX0RST1BfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbXG4gIENsckRyYWdnYWJsZSxcbiAgQ2xyRHJvcHBhYmxlLFxuICBDbHJJZkRyYWdnZWQsXG4gIENsckRyYWdIYW5kbGUsXG4gIENsckRyYWdnYWJsZUdob3N0LFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9EUkFHX0FORF9EUk9QX0RJUkVDVElWRVNdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJEcmFnZ2FibGVHaG9zdF0sXG4gIGV4cG9ydHM6IFtDTFJfRFJBR19BTkRfRFJPUF9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ0FuZERyb3BNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUm9vdERyb3Bkb3duU2VydmljZSB7XG4gIHByaXZhdGUgX2NoYW5nZXM6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGdldCBjaGFuZ2VzKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgY2xvc2VNZW51cygpOiB2b2lkIHtcbiAgICB0aGlzLl9jaGFuZ2VzLm5leHQoZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHJSb290RHJvcGRvd25GYWN0b3J5KGV4aXN0aW5nOiBSb290RHJvcGRvd25TZXJ2aWNlKSB7XG4gIHJldHVybiBleGlzdGluZyB8fCBuZXcgUm9vdERyb3Bkb3duU2VydmljZSgpO1xufVxuXG5leHBvcnQgY29uc3QgUk9PVF9EUk9QRE9XTl9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogUm9vdERyb3Bkb3duU2VydmljZSxcbiAgdXNlRmFjdG9yeTogY2xyUm9vdERyb3Bkb3duRmFjdG9yeSxcbiAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFJvb3REcm9wZG93blNlcnZpY2VdXSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPcHRpb25hbCwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbmltcG9ydCB7IFJPT1RfRFJPUERPV05fUFJPVklERVIsIFJvb3REcm9wZG93blNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kcm9wZG93bi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRyb3Bkb3duJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZHJvcGRvd25dJzogJ3RydWUnLFxuICAgIC8vIEZJWE1FOiByZW1vdmUgdGhpcyBhcyBzb29uIGFzIHdlIHN0b3Agc3VwcG9ydGluZyB0aGlzIG9sZCA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiPiBzeW50YXhcbiAgICAnW2NsYXNzLm9wZW5dJzogJ2lmT3BlblNlcnZpY2Uub3BlbicsXG4gIH0sXG4gIHByb3ZpZGVyczogW0lmT3BlblNlcnZpY2UsIFJPT1RfRFJPUERPV05fUFJPVklERVIsIHsgcHJvdmlkZTogUE9QT1ZFUl9IT1NUX0FOQ0hPUiwgdXNlRXhpc3Rpbmc6IEVsZW1lbnRSZWYgfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyb3Bkb3duIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBTa2lwU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBwdWJsaWMgcGFyZW50OiBDbHJEcm9wZG93bixcbiAgICBwdWJsaWMgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSxcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgZHJvcGRvd25TZXJ2aWNlOiBSb290RHJvcGRvd25TZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKGRyb3Bkb3duU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh2YWx1ZSA9PiAodGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSB2YWx1ZSkpKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChpZk9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKHZhbHVlID0+IHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpKSk7XG4gIH1cblxuICBASW5wdXQoJ2NsckNsb3NlTWVudU9uSXRlbUNsaWNrJykgaXNNZW51Q2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRyb3Bkb3duIH0gZnJvbSAnLi9kcm9wZG93bic7XG5pbXBvcnQgeyBSb290RHJvcGRvd25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJvcGRvd24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJEcm9wZG93bkl0ZW1dJywgaG9zdDogeyAnW2NsYXNzLmRyb3Bkb3duLWl0ZW1dJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93bkl0ZW0gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkcm9wZG93bjogQ2xyRHJvcGRvd24sXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9kcm9wZG93blNlcnZpY2U6IFJvb3REcm9wZG93blNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyXG4gICkge31cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoKSA9PiB0aGlzLm9uRHJvcGRvd25JdGVtQ2xpY2soKSk7XG4gIH1cblxuICBvbkRyb3Bkb3duSXRlbUNsaWNrKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRyb3Bkb3duLmlzTWVudUNsb3NhYmxlICYmICF0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICB0aGlzLl9kcm9wZG93blNlcnZpY2UuY2xvc2VNZW51cygpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdG9yLCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFBvcG92ZXIgfSBmcm9tICcuLi9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kcm9wZG93bi1tZW51JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRyb3Bkb3duLW1lbnVdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93bk1lbnUgZXh0ZW5kcyBBYnN0cmFjdFBvcG92ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KFBPUE9WRVJfSE9TVF9BTkNIT1IpXG4gICAgcGFyZW50SG9zdDogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgbmVzdGVkOiBDbHJEcm9wZG93bk1lbnVcbiAgKSB7XG4gICAgaWYgKCFwYXJlbnRIb3N0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1kcm9wZG93bi1tZW51IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLWRyb3Bkb3duJyk7XG4gICAgfVxuICAgIHN1cGVyKGluamVjdG9yLCBwYXJlbnRIb3N0KTtcbiAgICBpZiAoIW5lc3RlZCkge1xuICAgICAgLy8gRGVmYXVsdCBwb3NpdGlvbmluZyBmb3Igbm9ybWFsIGRyb3Bkb3duIGlzIGJvdHRvbS1sZWZ0XG4gICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IHBvc2l0aW9uaW5nIGZvciBuZXN0ZWQgZHJvcGRvd24gaXMgcmlnaHQtdG9wXG4gICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICB9XG4gICAgdGhpcy5wb3BvdmVyT3B0aW9ucy5hbGxvd011bHRpcGxlT3BlbiA9IHRydWU7XG4gICAgdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9zaXRpb24nKVxuICBzZXQgcG9zaXRpb24ocG9zaXRpb246IHN0cmluZykge1xuICAgIC8vIHNldCB0aGUgcG9wb3ZlciB2YWx1ZXMgYmFzZWQgb24gbWVudSBwb3NpdGlvblxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfUklHSFQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fUklHSFQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0LXRvcCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQtYm90dG9tJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0LXRvcCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdC1ib3R0b20nOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuaW1wb3J0IHsgQ2xyRHJvcGRvd24gfSBmcm9tICcuL2Ryb3Bkb3duJztcblxuQERpcmVjdGl2ZSh7XG4gIC8vIFdlIHN1cHBvcnQgYm90aCBzZWxlY3RvcnMgZm9yIGxlZ2FjeSByZWFzb25zXG4gIHNlbGVjdG9yOiAnW2NsckRyb3Bkb3duVHJpZ2dlcl0sW2NsckRyb3Bkb3duVG9nZ2xlXScsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRyb3Bkb3duLXRvZ2dsZV0nOiAnaXNSb290TGV2ZWxUb2dnbGUnLFxuICAgICdbY2xhc3MuZHJvcGRvd24taXRlbV0nOiAnIWlzUm9vdExldmVsVG9nZ2xlJyxcbiAgICAnW2NsYXNzLmV4cGFuZGFibGVdJzogJyFpc1Jvb3RMZXZlbFRvZ2dsZScsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ2FjdGl2ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyb3Bkb3duVHJpZ2dlciB7XG4gIHB1YmxpYyBpc1Jvb3RMZXZlbFRvZ2dsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoZHJvcGRvd246IENsckRyb3Bkb3duLCBwcml2YXRlIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UpIHtcbiAgICAvLyBpZiB0aGUgY29udGFpbmluZyBkcm9wZG93biBoYXMgYSBwYXJlbnQsIHRoZW4gdGhpcyBpcyBub3QgdGhlIHJvb3QgbGV2ZWwgb25lXG4gICAgaWYgKGRyb3Bkb3duLnBhcmVudCkge1xuICAgICAgdGhpcy5pc1Jvb3RMZXZlbFRvZ2dsZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICBvbkRyb3Bkb3duVHJpZ2dlckNsaWNrKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckRyb3Bkb3duIH0gZnJvbSAnLi9kcm9wZG93bic7XG5pbXBvcnQgeyBDbHJEcm9wZG93bkl0ZW0gfSBmcm9tICcuL2Ryb3Bkb3duLWl0ZW0nO1xuaW1wb3J0IHsgQ2xyRHJvcGRvd25NZW51IH0gZnJvbSAnLi9kcm9wZG93bi1tZW51JztcbmltcG9ydCB7IENsckRyb3Bkb3duVHJpZ2dlciB9IGZyb20gJy4vZHJvcGRvd24tdHJpZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfRFJPUERPV05fRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyRHJvcGRvd24sIENsckRyb3Bkb3duTWVudSwgQ2xyRHJvcGRvd25UcmlnZ2VyLCBDbHJEcm9wZG93bkl0ZW1dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0RST1BET1dOX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX0RST1BET1dOX0RJUkVDVElWRVMsIENsckNvbmRpdGlvbmFsTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJvcGRvd25Nb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLy8gQFRPRE8gTWFrZSB0aGlzIGFuIGVudW1cbmV4cG9ydCBjb25zdCBBTEVSVF9UWVBFUzogc3RyaW5nW10gPSBbJ2luZm8nLCAnd2FybmluZycsICdkYW5nZXInLCAnc3VjY2VzcyddO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFsZXJ0SW5mb09iamVjdCB9IGZyb20gJy4uL3V0aWxzL2FsZXJ0LWluZm8tb2JqZWN0JztcbmltcG9ydCB7IEFMRVJUX1RZUEVTIH0gZnJvbSAnLi4vdXRpbHMvYWxlcnQtdHlwZXMnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncykge31cblxuICBwcml2YXRlIGRlZmF1bHRJY29uU2hhcGUgPSAnaW5mby1jaXJjbGUnO1xuICBwcml2YXRlIF9hbGVydEljb25TaGFwZSA9ICcnO1xuICBwcml2YXRlIF9hbGVydFR5cGUgPSAnaW5mbyc7XG5cbiAgZ2V0IGFsZXJ0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hbGVydFR5cGU7XG4gIH1cbiAgc2V0IGFsZXJ0VHlwZSh2YWw6IHN0cmluZykge1xuICAgIGlmIChBTEVSVF9UWVBFUy5pbmRleE9mKHZhbCkgPiAtMSkge1xuICAgICAgdGhpcy5fYWxlcnRUeXBlID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhbGVydEljb25TaGFwZSgpOiBzdHJpbmcge1xuICAgIGlmICgnJyA9PT0gdGhpcy5fYWxlcnRJY29uU2hhcGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmljb25JbmZvRnJvbVR5cGUodGhpcy5fYWxlcnRUeXBlKS5zaGFwZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FsZXJ0SWNvblNoYXBlO1xuICB9XG4gIHNldCBhbGVydEljb25TaGFwZSh2YWw6IHN0cmluZykge1xuICAgIGlmICghdmFsKSB7XG4gICAgICB0aGlzLl9hbGVydEljb25TaGFwZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodmFsICE9PSB0aGlzLl9hbGVydEljb25TaGFwZSkge1xuICAgICAgdGhpcy5fYWxlcnRJY29uU2hhcGUgPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFsZXJ0SWNvblRpdGxlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkluZm9Gcm9tVHlwZSh0aGlzLl9hbGVydFR5cGUpLnRpdGxlO1xuICB9XG5cbiAgcHVibGljIGljb25JbmZvRnJvbVR5cGUodHlwZTogc3RyaW5nKTogQWxlcnRJbmZvT2JqZWN0IHtcbiAgICBjb25zdCByZXR1cm5PYmogPSB7IHNoYXBlOiAnJywgY3NzQ2xhc3M6ICcnLCB0aXRsZTogJycgfTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgIHJldHVybk9iai5zaGFwZSA9ICdleGNsYW1hdGlvbi10cmlhbmdsZSc7XG4gICAgICAgIHJldHVybk9iai5jc3NDbGFzcyA9ICdhbGVydC13YXJuaW5nJztcbiAgICAgICAgcmV0dXJuT2JqLnRpdGxlID0gdGhpcy5jb21tb25TdHJpbmdzLndhcm5pbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGFuZ2VyJzpcbiAgICAgICAgcmV0dXJuT2JqLnNoYXBlID0gJ2V4Y2xhbWF0aW9uLWNpcmNsZSc7XG4gICAgICAgIHJldHVybk9iai5jc3NDbGFzcyA9ICdhbGVydC1kYW5nZXInO1xuICAgICAgICByZXR1cm5PYmoudGl0bGUgPSB0aGlzLmNvbW1vblN0cmluZ3MuZGFuZ2VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICByZXR1cm5PYmouc2hhcGUgPSAnY2hlY2stY2lyY2xlJztcbiAgICAgICAgcmV0dXJuT2JqLmNzc0NsYXNzID0gJ2FsZXJ0LXN1Y2Nlc3MnO1xuICAgICAgICByZXR1cm5PYmoudGl0bGUgPSB0aGlzLmNvbW1vblN0cmluZ3Muc3VjY2VzcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm5PYmouc2hhcGUgPSB0aGlzLmRlZmF1bHRJY29uU2hhcGU7XG4gICAgICAgIHJldHVybk9iai5jc3NDbGFzcyA9ICdhbGVydC1pbmZvJztcbiAgICAgICAgcmV0dXJuT2JqLnRpdGxlID0gdGhpcy5jb21tb25TdHJpbmdzLmluZm87XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5PYmo7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJBbGVydCB9IGZyb20gJy4uL2FsZXJ0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE11bHRpQWxlcnRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBhbGxBbGVydHM6IFF1ZXJ5TGlzdDxDbHJBbGVydD4gPSBuZXcgUXVlcnlMaXN0PENsckFsZXJ0PigpO1xuICBwcml2YXRlIF9jdXJyZW50ID0gMDtcblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgcHVibGljIGdldCBjaGFuZ2VzKCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICB9XG4gIHNldCBjdXJyZW50KGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoaW5kZXggIT09IHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBpbmRleDtcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBnZXQgYWN0aXZlQWxlcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmFsbEFsZXJ0cy5maWx0ZXIoYWxlcnQgPT4gIWFsZXJ0Ll9jbG9zZWQpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRBbGVydCgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVBbGVydHNbdGhpcy5jdXJyZW50XTtcbiAgfVxuXG4gIHNldCBjdXJyZW50QWxlcnQoYWxlcnQ6IENsckFsZXJ0KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5hY3RpdmVBbGVydHMuaW5kZXhPZihhbGVydCk7XG4gIH1cblxuICBnZXQgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlQWxlcnRzLmxlbmd0aDtcbiAgfVxuXG4gIG1hbmFnZShhbGVydHM6IFF1ZXJ5TGlzdDxDbHJBbGVydD4pIHtcbiAgICB0aGlzLmFsbEFsZXJ0cyA9IGFsZXJ0cztcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50ID09PSB0aGlzLmFjdGl2ZUFsZXJ0cy5sZW5ndGggLSAxID8gMCA6IHRoaXMuY3VycmVudCArIDE7XG4gIH1cblxuICBwcmV2aW91cygpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVBbGVydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudCA9PT0gMCA/IHRoaXMuYWN0aXZlQWxlcnRzLmxlbmd0aCAtIDEgOiB0aGlzLmN1cnJlbnQgLSAxO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5wcmV2aW91cygpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPcHRpb25hbCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8vIHByb3ZpZGVyc1xuaW1wb3J0IHsgQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaWNvbi1hbmQtdHlwZXMuc2VydmljZSc7XG5pbXBvcnQgeyBNdWx0aUFsZXJ0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL211bHRpLWFsZXJ0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWFsZXJ0JyxcbiAgcHJvdmlkZXJzOiBbQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlXSxcbiAgdGVtcGxhdGVVcmw6ICcuL2FsZXJ0Lmh0bWwnLFxuICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBpY29uU2VydmljZTogQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlLFxuICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIEBPcHRpb25hbCgpIHB1YmxpYyBtdWx0aUFsZXJ0U2VydmljZTogTXVsdGlBbGVydFNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7fVxuXG4gIEBJbnB1dCgnY2xyQWxlcnRTaXplU21hbGwnKSBpc1NtYWxsOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgnY2xyQWxlcnRDbG9zYWJsZScpIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCdjbHJBbGVydEFwcExldmVsJykgaXNBcHBMZXZlbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgnY2xyQWxlcnRDbG9zZWQnKSBfY2xvc2VkOiBib29sZWFuID0gZmFsc2U7XG4gIEBPdXRwdXQoJ2NsckFsZXJ0Q2xvc2VkQ2hhbmdlJykgX2Nsb3NlZENoYW5nZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIEBJbnB1dCgnY2xyQWxlcnRUeXBlJylcbiAgc2V0IGFsZXJ0VHlwZSh2YWw6IHN0cmluZykge1xuICAgIHRoaXMuaWNvblNlcnZpY2UuYWxlcnRUeXBlID0gdmFsO1xuICB9XG4gIGdldCBhbGVydFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pY29uU2VydmljZS5hbGVydFR5cGU7XG4gIH1cblxuICBASW5wdXQoJ2NsckFsZXJ0SWNvbicpXG4gIHNldCBhbGVydEljb25TaGFwZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5pY29uU2VydmljZS5hbGVydEljb25TaGFwZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGFsZXJ0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pY29uU2VydmljZS5pY29uSW5mb0Zyb21UeXBlKHRoaXMuaWNvblNlcnZpY2UuYWxlcnRUeXBlKS5jc3NDbGFzcztcbiAgfVxuXG4gIHByaXZhdGUgcHJldmlvdXNseUhpZGRlbiA9IGZhbHNlO1xuICBwcml2YXRlIGhpZGRlbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZGV0ZWN0Q2hhbmdlc0lmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzbHlIaWRkZW4gIT09IHRoaXMuaGlkZGVuKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlIaWRkZW4gPSB0aGlzLmhpZGRlbjtcbiAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNIaWRkZW4oKSB7XG4gICAgaWYgKHRoaXMubXVsdGlBbGVydFNlcnZpY2UpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydCA9PT0gdGhpcykge1xuICAgICAgICBpZiAodGhpcy5oaWRkZW4gPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnByZXZpb3VzbHlIaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNseUhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmRldGVjdENoYW5nZXNJZk5lZWRlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmhpZGRlbjtcbiAgfVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jbG9zYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlKSB7XG4gICAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlZENoYW5nZWQuZW1pdCh0cnVlKTtcbiAgfVxuXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VkQ2hhbmdlZC5lbWl0KGZhbHNlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2ljb24tYW5kLXR5cGVzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYWxlcnQtaXRlbScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1pY29uLXdyYXBwZXJcIj5cbiAgICAgICAgICAgIDxjbHItaWNvbiBjbGFzcz1cImFsZXJ0LWljb25cIiBcbiAgICAgICAgICAgICAgW2F0dHIuc2hhcGVdPVwiaWNvblNlcnZpY2UuYWxlcnRJY29uU2hhcGVcIiBcbiAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiaWNvblNlcnZpY2UuYWxlcnRJY29uVGl0bGVcIj48L2Nsci1pY29uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHsgY2xhc3M6ICdhbGVydC1pdGVtJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydEl0ZW0ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaWNvblNlcnZpY2U6IEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSkge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQWxlcnQgfSBmcm9tICcuL2FsZXJ0JztcbmltcG9ydCB7IE11bHRpQWxlcnRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbXVsdGktYWxlcnQuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1hbGVydHMnLFxuICB0ZW1wbGF0ZVVybDogJy4vYWxlcnRzLmh0bWwnLFxuICBwcm92aWRlcnM6IFtNdWx0aUFsZXJ0U2VydmljZV0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmFsZXJ0c10nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5hbGVydC1kYW5nZXJdJzogXCJ0aGlzLmN1cnJlbnRBbGVydFR5cGUgPT0gJ2RhbmdlcidcIixcbiAgICAnW2NsYXNzLmFsZXJ0LWluZm9dJzogXCJ0aGlzLmN1cnJlbnRBbGVydFR5cGUgPT0gJ2luZm8nXCIsXG4gICAgJ1tjbGFzcy5hbGVydC1zdWNjZXNzXSc6IFwidGhpcy5jdXJyZW50QWxlcnRUeXBlID09ICdzdWNjZXNzJ1wiLFxuICAgICdbY2xhc3MuYWxlcnQtd2FybmluZ10nOiBcInRoaXMuY3VycmVudEFsZXJ0VHlwZSA9PSAnd2FybmluZydcIixcbiAgfSxcbiAgc3R5bGVzOiBbJzpob3N0IHsgZGlzcGxheTogYmxvY2sgfSddLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydHMgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJBbGVydCkgYWxsQWxlcnRzOiBRdWVyeUxpc3Q8Q2xyQWxlcnQ+O1xuXG4gIC8qKlxuICAgKiBJbnB1dC9PdXRwdXQgdG8gc3VwcG9ydCB0d28gd2F5IGJpbmRpbmcgb24gY3VycmVudCBhbGVydCBpbmRleFxuICAgKi9cbiAgQElucHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleCcpXG4gIHB1YmxpYyBzZXQgX2lucHV0Q3VycmVudEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbmRleCkgJiYgaW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50ID0gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyQ3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UnKSBwdWJsaWMgY3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oZmFsc2UpO1xuXG4gIHNldCBjdXJyZW50QWxlcnRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50ID0gaW5kZXg7XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbGVydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQ7XG4gIH1cblxuICAvKipcbiAgICogSW5wdXQvT3V0cHV0IHRvIHN1cHBvcnQgdHdvIHdheSBiaW5kaW5nIG9uIGN1cnJlbnQgYWxlcnQgaW5zdGFuY2VcbiAgICovXG4gIEBJbnB1dCgnY2xyQ3VycmVudEFsZXJ0JylcbiAgc2V0IGN1cnJlbnRBbGVydChhbGVydDogQ2xyQWxlcnQpIHtcbiAgICBpZiAoYWxlcnQpIHtcbiAgICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0ID0gYWxlcnQ7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50QWxlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0O1xuICB9XG4gIEBPdXRwdXQoJ2NsckN1cnJlbnRBbGVydENoYW5nZScpIHB1YmxpYyBjdXJyZW50QWxlcnRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENsckFsZXJ0PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVuc3VyZSB3ZSBhcmUgb25seSBkZWFsaW5nIHdpdGggYWxlcnRzIHRoYXQgaGF2ZSBub3QgYmVlbiBjbG9zZWQgeWV0XG4gICAqL1xuICBnZXQgYWxlcnRzKCkge1xuICAgIHJldHVybiB0aGlzLmFsbEFsZXJ0cy5maWx0ZXIoYWxlcnQgPT4ge1xuICAgICAgcmV0dXJuIGFsZXJ0LmlzSGlkZGVuID09PSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBjdXJyZW50QWxlcnRUeXBlKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0KSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQuYWxlcnRUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbXVsdGlBbGVydFNlcnZpY2U6IE11bHRpQWxlcnRTZXJ2aWNlKSB7fVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLm1hbmFnZSh0aGlzLmFsbEFsZXJ0cyk7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZShpbmRleCA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRBbGVydEluZGV4Q2hhbmdlLm5leHQoaW5kZXgpO1xuICAgICAgdGhpcy5jdXJyZW50QWxlcnRDaGFuZ2UubmV4dCh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckFsZXJ0IH0gZnJvbSAnLi9hbGVydCc7XG5pbXBvcnQgeyBNdWx0aUFsZXJ0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL211bHRpLWFsZXJ0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWFsZXJ0cy1wYWdlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9hbGVydHMtcGFnZXIuaHRtbCcsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5hbGVydHMtcGFnZXJdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckFsZXJ0c1BhZ2VyIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIG11bHRpQWxlcnRTZXJ2aWNlQ2hhbmdlczogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBJbnB1dC9PdXRwdXQgdG8gc3VwcG9ydCB0d28gd2F5IGJpbmRpbmcgb24gY3VycmVudCBhbGVydCBpbnN0YW5jZVxuICAgKi9cbiAgQElucHV0KCdjbHJDdXJyZW50QWxlcnQnKVxuICBzZXQgY3VycmVudEFsZXJ0KGFsZXJ0OiBDbHJBbGVydCkge1xuICAgIGlmIChhbGVydCkge1xuICAgICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQgPSBhbGVydDtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbGVydCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQ7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJDdXJyZW50QWxlcnRDaGFuZ2UnKSBjdXJyZW50QWxlcnRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENsckFsZXJ0PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIElucHV0L091dHB1dCB0byBzdXBwb3J0IHR3byB3YXkgYmluZGluZyBvbiBjdXJyZW50IGFsZXJ0IGluZGV4XG4gICAqL1xuICBASW5wdXQoJ2NsckN1cnJlbnRBbGVydEluZGV4JylcbiAgc2V0IGN1cnJlbnRBbGVydEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQgPSBpbmRleDtcbiAgfVxuICBnZXQgY3VycmVudEFsZXJ0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudDtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckN1cnJlbnRBbGVydEluZGV4Q2hhbmdlJykgY3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbXVsdGlBbGVydFNlcnZpY2U6IE11bHRpQWxlcnRTZXJ2aWNlLCBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncykge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlQ2hhbmdlcyA9IHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoaW5kZXggPT4ge1xuICAgICAgdGhpcy5jdXJyZW50QWxlcnRJbmRleENoYW5nZS5lbWl0KGluZGV4KTtcbiAgICAgIHRoaXMuY3VycmVudEFsZXJ0Q2hhbmdlLmVtaXQodGhpcy5tdWx0aUFsZXJ0U2VydmljZS5hY3RpdmVBbGVydHNbaW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuXG4gIHBhZ2VVcCgpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLm5leHQoKTtcbiAgfVxuXG4gIHBhZ2VEb3duKCkge1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UucHJldmlvdXMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2VDaGFuZ2VzLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckRyb3Bkb3duTW9kdWxlIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJBbGVydCB9IGZyb20gJy4vYWxlcnQnO1xuaW1wb3J0IHsgQ2xyQWxlcnRJdGVtIH0gZnJvbSAnLi9hbGVydC1pdGVtJztcbmltcG9ydCB7IENsckFsZXJ0cyB9IGZyb20gJy4vYWxlcnRzJztcbmltcG9ydCB7IENsckFsZXJ0c1BhZ2VyIH0gZnJvbSAnLi9hbGVydHMtcGFnZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX0FMRVJUX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsckFsZXJ0LCBDbHJBbGVydEl0ZW0sIENsckFsZXJ0cywgQ2xyQWxlcnRzUGFnZXJdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJEcm9wZG93bk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9BTEVSVF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9BTEVSVF9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQWxlcnRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJBbGVydE1vZHVsZSB9IGZyb20gJy4vYWxlcnQvYWxlcnQubW9kdWxlJztcblxuQE5nTW9kdWxlKHsgZXhwb3J0czogW0NsckFsZXJ0TW9kdWxlXSB9KVxuZXhwb3J0IGNsYXNzIENsckVtcGhhc2lzTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBjbGFzcyBSZXNwb25zaXZlTmF2Q29kZXMge1xuICBwdWJsaWMgc3RhdGljIE5BVl9MRVZFTF8xOiBudW1iZXIgPSAxO1xuICBwdWJsaWMgc3RhdGljIE5BVl9MRVZFTF8yOiBudW1iZXIgPSAyO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTE9TRV9BTEw6IHN0cmluZyA9ICdOQVZfQ0xPU0VfQUxMJztcbiAgcHVibGljIHN0YXRpYyBOQVZfT1BFTjogc3RyaW5nID0gJ05BVl9PUEVOJztcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xPU0U6IHN0cmluZyA9ICdOQVZfQ0xPU0UnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9UT0dHTEU6IHN0cmluZyA9ICdOQVZfVE9HR0xFJztcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xBU1NfSEFNQlVSR0VSX01FTlU6IHN0cmluZyA9ICdvcGVuLWhhbWJ1cmdlci1tZW51JztcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xBU1NfT1ZFUkZMT1dfTUVOVTogc3RyaW5nID0gJ29wZW4tb3ZlcmZsb3ctbWVudSc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX1RSSUdHRVJfMTogc3RyaW5nID0gJ2hlYWRlci1oYW1idXJnZXItdHJpZ2dlcic7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX1RSSUdHRVJfMjogc3RyaW5nID0gJ2hlYWRlci1vdmVyZmxvdy10cmlnZ2VyJztcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xBU1NfTEVWRUxfMTogc3RyaW5nID0gJ2Nsci1uYXYtbGV2ZWwtMSc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX0xFVkVMXzI6IHN0cmluZyA9ICdjbHItbmF2LWxldmVsLTInO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgY2xhc3MgUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfY29udHJvbENvZGU6IHN0cmluZywgcHJpdmF0ZSBfbmF2TGV2ZWw6IG51bWJlcikge31cblxuICBnZXQgY29udHJvbENvZGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbENvZGU7XG4gIH1cblxuICBnZXQgbmF2TGV2ZWwoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fbmF2TGV2ZWw7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdkNvZGVzIH0gZnJvbSAnLi4vcmVzcG9uc2l2ZS1uYXYtY29kZXMnO1xuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlIH0gZnJvbSAnLi4vcmVzcG9uc2l2ZS1uYXYtY29udHJvbC1tZXNzYWdlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2Uge1xuICBwdWJsaWMgcmVzcG9uc2l2ZU5hdkxpc3Q6IG51bWJlcltdID0gW107XG4gIHByaXZhdGUgcmVnaXN0ZXJOYXZTdWJqZWN0OiBTdWJqZWN0PG51bWJlcltdPiA9IG5ldyBTdWJqZWN0PG51bWJlcltdPigpO1xuICBwcml2YXRlIGNvbnRyb2xOYXZTdWJqZWN0OiBTdWJqZWN0PFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZT4gPSBuZXcgU3ViamVjdDxSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2U+KCk7XG5cbiAgZ2V0IHJlZ2lzdGVyZWROYXZzKCk6IE9ic2VydmFibGU8bnVtYmVyW10+IHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3Rlck5hdlN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgbmF2Q29udHJvbCgpOiBPYnNlcnZhYmxlPFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZT4ge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xOYXZTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jbG9zZUFsbE5hdnMoKTsgLy8gV2Ugc3RhcnQgd2l0aCBhbGwgbmF2cyBjbG9zZWRcbiAgfVxuXG4gIHJlZ2lzdGVyTmF2KG5hdkxldmVsOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZiAoIW5hdkxldmVsIHx8IHRoaXMuaXNOYXZSZWdpc3RlcmVkKG5hdkxldmVsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZMaXN0LnB1c2gobmF2TGV2ZWwpO1xuICAgIHRoaXMucmVnaXN0ZXJOYXZTdWJqZWN0Lm5leHQodGhpcy5yZXNwb25zaXZlTmF2TGlzdCk7XG4gIH1cblxuICBpc05hdlJlZ2lzdGVyZWQobmF2TGV2ZWw6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnJlc3BvbnNpdmVOYXZMaXN0LmluZGV4T2YobmF2TGV2ZWwpID4gLTEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ011bHRpcGxlIGNsci1uYXYtbGV2ZWwgJyArIG5hdkxldmVsICsgJyBhdHRyaWJ1dGVzIGZvdW5kLiBQbGVhc2UgbWFrZSBzdXJlIHRoYXQgb25seSBvbmUgZXhpc3RzJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdW5yZWdpc3Rlck5hdihuYXZMZXZlbDogbnVtYmVyKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnJlc3BvbnNpdmVOYXZMaXN0LmluZGV4T2YobmF2TGV2ZWwpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLnJlc3BvbnNpdmVOYXZMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyTmF2U3ViamVjdC5uZXh0KHRoaXMucmVzcG9uc2l2ZU5hdkxpc3QpO1xuICAgIH1cbiAgfVxuXG4gIHNlbmRDb250cm9sTWVzc2FnZShjb250cm9sQ29kZTogc3RyaW5nLCBuYXZMZXZlbDogbnVtYmVyKSB7XG4gICAgY29uc3QgbWVzc2FnZTogUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlID0gbmV3IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZShjb250cm9sQ29kZSwgbmF2TGV2ZWwpO1xuICAgIHRoaXMuY29udHJvbE5hdlN1YmplY3QubmV4dChtZXNzYWdlKTtcbiAgfVxuXG4gIGNsb3NlQWxsTmF2cygpIHtcbiAgICBjb25zdCBtZXNzYWdlOiBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UgPSBuZXcgUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlKFxuICAgICAgUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTE9TRV9BTEwsXG4gICAgICAtOTk5XG4gICAgKTtcbiAgICB0aGlzLmNvbnRyb2xOYXZTdWJqZWN0Lm5leHQobWVzc2FnZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9uYXYvcHJvdmlkZXJzL3Jlc3BvbnNpdmUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb2RlcyB9IGZyb20gJy4uL25hdi9yZXNwb25zaXZlLW5hdi1jb2Rlcyc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UgfSBmcm9tICcuLi9uYXYvcmVzcG9uc2l2ZS1uYXYtY29udHJvbC1tZXNzYWdlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLW1haW4tY29udGFpbmVyJywgaG9zdDogeyAnW2NsYXNzLm1haW4tY29udGFpbmVyXSc6ICd0cnVlJyB9IH0pXG5leHBvcnQgY2xhc3MgQ2xyTWFpbkNvbnRhaW5lciBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX2NsYXNzTGlzdDogRE9NVG9rZW5MaXN0O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgcmVzcG9uc2l2ZU5hdlNlcnZpY2U6IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9jbGFzc0xpc3QgPSB0aGlzLmVsUmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0O1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UubmF2Q29udHJvbC5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKG1lc3NhZ2U6IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSkgPT4ge1xuICAgICAgICB0aGlzLnByb2Nlc3NNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByb2Nlc3NNZXNzYWdlKG1lc3NhZ2U6IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSk6IHZvaWQge1xuICAgIGxldCBuYXZDbGFzczogc3RyaW5nID0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTEFTU19IQU1CVVJHRVJfTUVOVTtcbiAgICBpZiAobWVzc2FnZS5jb250cm9sQ29kZSA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTE9TRV9BTEwpIHtcbiAgICAgIHRoaXMuX2NsYXNzTGlzdC5yZW1vdmUoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTEFTU19IQU1CVVJHRVJfTUVOVSk7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QucmVtb3ZlKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfT1ZFUkZMT1dfTUVOVSk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLm5hdkxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzEpIHtcbiAgICAgIHRoaXMuY29udHJvbE5hdihtZXNzYWdlLmNvbnRyb2xDb2RlLCBuYXZDbGFzcyk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLm5hdkxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzIpIHtcbiAgICAgIG5hdkNsYXNzID0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTEFTU19PVkVSRkxPV19NRU5VO1xuICAgICAgdGhpcy5jb250cm9sTmF2KG1lc3NhZ2UuY29udHJvbENvZGUsIG5hdkNsYXNzKTtcbiAgICB9XG4gIH1cblxuICBjb250cm9sTmF2KGNvbnRyb2xDb2RlOiBzdHJpbmcsIG5hdkNsYXNzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoY29udHJvbENvZGUgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfT1BFTikge1xuICAgICAgdGhpcy5fY2xhc3NMaXN0LmFkZChuYXZDbGFzcyk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sQ29kZSA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTE9TRSkge1xuICAgICAgdGhpcy5fY2xhc3NMaXN0LnJlbW92ZShuYXZDbGFzcyk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sQ29kZSA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9UT0dHTEUpIHtcbiAgICAgIHRoaXMuX2NsYXNzTGlzdC50b2dnbGUobmF2Q2xhc3MpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJNYWluQ29udGFpbmVyIH0gZnJvbSAnLi9tYWluLWNvbnRhaW5lcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfTEFZT1VUX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0Nsck1haW5Db250YWluZXJdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0xBWU9VVF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9MQVlPVVRfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsck1haW5Db250YWluZXJNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2lsbHlXb25rYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS93aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1tYWluLWNvbnRhaW5lcicgfSlcbmV4cG9ydCBjbGFzcyBNYWluQ29udGFpbmVyV2lsbHlXb25rYSBleHRlbmRzIFdpbGx5V29ua2Ege31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPb21wYUxvb21wYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS9vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL3Jlc3BvbnNpdmUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IE1haW5Db250YWluZXJXaWxseVdvbmthIH0gZnJvbSAnLi9tYWluLWNvbnRhaW5lci13aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1oZWFkZXInIH0pXG5leHBvcnQgY2xhc3MgTmF2RGV0ZWN0aW9uT29tcGFMb29tcGEgZXh0ZW5kcyBPb21wYUxvb21wYSB7XG4gIHByaXZhdGUgcmVzcG9uc2l2ZU5hdlNlcnZpY2U6IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIEBPcHRpb25hbCgpIHdpbGx5V29ua2E6IE1haW5Db250YWluZXJXaWxseVdvbmthLFxuICAgIHJlc3BvbnNpdmVOYXZTZXJ2aWNlOiBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2VcbiAgKSB7XG4gICAgaWYgKCF3aWxseVdvbmthKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1oZWFkZXIgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItbWFpbi1jb250YWluZXInKTtcbiAgICB9XG4gICAgc3VwZXIoY2RyLCB3aWxseVdvbmthKTtcbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlID0gcmVzcG9uc2l2ZU5hdlNlcnZpY2U7XG4gIH1cblxuICAvLyBOYXZEZXRlY3Rpb25Pb21wYUxvb21wYSBpcyB0aGUgYWRkaXRpb24gb2YgdGhlIG5hdiBsZXZlbHNcbiAgLy8gU2luY2Ugd2Ugc3VwcG9ydCAyIGxldmVscywgdGhlIHBvc3NpYmlsaXRpZXMgYXJlIDAsIDEgb3IgMyAoMSArIDIpXG4gIGdldCBmbGF2b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UucmVzcG9uc2l2ZU5hdkxpc3QucmVkdWNlKChzdW0sIG5hdkxldmVsKSA9PiBzdW0gKyBuYXZMZXZlbCwgMCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcmVzcG9uc2l2ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdkNvZGVzIH0gZnJvbSAnLi9yZXNwb25zaXZlLW5hdi1jb2Rlcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1oZWFkZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICpuZ0lmPVwiaXNOYXZMZXZlbDFPblBhZ2VcIlxuICAgICAgICAgICAgY2xhc3M9XCJoZWFkZXItaGFtYnVyZ2VyLXRyaWdnZXJcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZU5hdihyZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzEpXCI+XG4gICAgICAgICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgKm5nSWY9XCJpc05hdkxldmVsMk9uUGFnZVwiXG4gICAgICAgICAgICBjbGFzcz1cImhlYWRlci1vdmVyZmxvdy10cmlnZ2VyXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVOYXYocmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8yKVwiPlxuICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImhlYWRlci1iYWNrZHJvcFwiIChjbGljayk9XCJjbG9zZU9wZW5OYXYoKVwiPjwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5oZWFkZXJdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckhlYWRlciBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwdWJsaWMgaXNOYXZMZXZlbDFPblBhZ2U6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGlzTmF2TGV2ZWwyT25QYWdlOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyByZXNwb25zaXZlTmF2Q29kZXMgPSBSZXNwb25zaXZlTmF2Q29kZXM7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZXNwb25zaXZlTmF2U2VydmljZTogUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5yZWdpc3RlcmVkTmF2cy5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKG5hdkxldmVsTGlzdDogbnVtYmVyW10pID0+IHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTmF2VHJpZ2dlcnMobmF2TGV2ZWxMaXN0KTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvLyByZXNldCB0cmlnZ2Vycy4gaGFuZGxlcyBjYXNlcyB3aGVuIGFuIGFwcGxpY2F0aW9uIGhhcyBkaWZmZXJlbnQgbmF2IGxldmVscyBvbiBkaWZmZXJlbnQgcGFnZXMuXG4gIHJlc2V0TmF2VHJpZ2dlcnMoKSB7XG4gICAgdGhpcy5pc05hdkxldmVsMU9uUGFnZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNOYXZMZXZlbDJPblBhZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIGRlY2lkZXMgd2hpY2ggdHJpZ2dlcnMgdG8gc2hvdyBvbiB0aGUgaGVhZGVyXG4gIGluaXRpYWxpemVOYXZUcmlnZ2VycyhuYXZMaXN0OiBudW1iZXJbXSk6IHZvaWQge1xuICAgIHRoaXMucmVzZXROYXZUcmlnZ2VycygpO1xuICAgIGlmIChuYXZMaXN0Lmxlbmd0aCA+IDIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ01vcmUgdGhhbiAyIE5hdiBMZXZlbHMgZGV0ZWN0ZWQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5hdkxpc3QuZm9yRWFjaChuYXZMZXZlbCA9PiB7XG4gICAgICBpZiAobmF2TGV2ZWwgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMSkge1xuICAgICAgICB0aGlzLmlzTmF2TGV2ZWwxT25QYWdlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobmF2TGV2ZWwgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMikge1xuICAgICAgICB0aGlzLmlzTmF2TGV2ZWwyT25QYWdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNsb3NlcyB0aGUgbmF2IHRoYXQgaXMgb3BlblxuICBjbG9zZU9wZW5OYXYoKSB7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5jbG9zZUFsbE5hdnMoKTtcbiAgfVxuXG4gIC8vIHRvZ2dsZXMgdGhlIG5hdiB0aGF0IGlzIG9wZW5cbiAgdG9nZ2xlTmF2KG5hdkxldmVsOiBudW1iZXIpIHtcbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnNlbmRDb250cm9sTWVzc2FnZShSZXNwb25zaXZlTmF2Q29kZXMuTkFWX1RPR0dMRSwgbmF2TGV2ZWwpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jlc3BvbnNpdmUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb2RlcyB9IGZyb20gJy4vcmVzcG9uc2l2ZS1uYXYtY29kZXMnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyLW5hdi1sZXZlbF0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyTmF2TGV2ZWwgaW1wbGVtZW50cyBPbkluaXQge1xuICBASW5wdXQoJ2Nsci1uYXYtbGV2ZWwnKSBfbGV2ZWw6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlc3BvbnNpdmVOYXZTZXJ2aWNlOiBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UsIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5sZXZlbCAhPT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8xICYmIHRoaXMubGV2ZWwgIT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMikge1xuICAgICAgY29uc29sZS5lcnJvcignTmF2IExldmVsIGNhbiBvbmx5IGJlIDEgb3IgMicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnJlZ2lzdGVyTmF2KHRoaXMubGV2ZWwpO1xuICAgIHRoaXMuYWRkTmF2Q2xhc3ModGhpcy5sZXZlbCk7XG4gIH1cblxuICBhZGROYXZDbGFzcyhsZXZlbDogbnVtYmVyKSB7XG4gICAgY29uc3QgbmF2SG9zdENsYXNzTGlzdCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdDtcbiAgICBpZiAobGV2ZWwgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMSkge1xuICAgICAgbmF2SG9zdENsYXNzTGlzdC5hZGQoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTEFTU19MRVZFTF8xKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzIpIHtcbiAgICAgIG5hdkhvc3RDbGFzc0xpc3QuYWRkKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfTEVWRUxfMik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGxldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2xldmVsO1xuICB9XG5cbiAgLy8gZ2V0dGVyIHRvIGFjY2VzcyB0aGUgcmVzcG9uc2l2ZSBuYXZpZ2F0aW9uIGNvZGVzIGZyb20gdGhlIHRlbXBsYXRlXG4gIGdldCByZXNwb25zaXZlTmF2Q29kZXMoKTogUmVzcG9uc2l2ZU5hdkNvZGVzIHtcbiAgICByZXR1cm4gUmVzcG9uc2l2ZU5hdkNvZGVzO1xuICB9XG5cbiAgb3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnNlbmRDb250cm9sTWVzc2FnZShSZXNwb25zaXZlTmF2Q29kZXMuTkFWX09QRU4sIHRoaXMubGV2ZWwpO1xuICB9XG5cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5zZW5kQ29udHJvbE1lc3NhZ2UoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9DTE9TRSwgdGhpcy5sZXZlbCk7XG4gIH1cblxuICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXRzIHRoZSBiZXN0IHdheSB0byBkbyB0aGlzLiBQb3NzaWJsZSBtZXRob2RzXG4gIC8vIDEuIEhvc3RMaXN0ZW5lciAoY3VycmVudCBzb2x1dGlvbilcbiAgLy8gMi4gRGlyZWN0aXZlcyBvbiB0aGUgLm5hdi1saW5rIGNsYXNzLiBXZSBkaXNjdXNzZWQgb24gbW92aW5nIGF3YXkgZnJvbSBjbGFzcyBzZWxlY3RvcnMgYnV0IEkgZm9yZ2V0IHRoZSByZWFzb25cbiAgLy8gd2h5XG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pXG4gIG9uTW91c2VDbGljayh0YXJnZXQ6IGFueSkge1xuICAgIGxldCBjdXJyZW50OiBhbnkgPSB0YXJnZXQ7IC8vIEdldCB0aGUgZWxlbWVudCBpbiB0aGUgRE9NIG9uIHdoaWNoIHRoZSBtb3VzZSB3YXMgY2xpY2tlZFxuICAgIGNvbnN0IG5hdkhvc3Q6IGFueSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50OyAvLyBHZXQgdGhlIGN1cnJlbnQgbmF2IG5hdGl2ZSBIVE1MIGVsZW1lbnRcblxuICAgIC8vIFN0YXJ0IGNoZWNraW5nIGlmIGN1cnJlbnQgYW5kIG5hdkhvc3QgYXJlIGVxdWFsLlxuICAgIC8vIElmIG5vdCB0cmF2ZXJzZSB0byB0aGUgcGFyZW50Tm9kZSBhbmQgY2hlY2sgYWdhaW4uXG4gICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSBuYXZIb3N0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ25hdi1saW5rJykpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UudW5yZWdpc3Rlck5hdih0aGlzLmxldmVsKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRHJvcGRvd25Nb2R1bGUgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5cbmltcG9ydCB7IE1haW5Db250YWluZXJXaWxseVdvbmthIH0gZnJvbSAnLi9jaG9jb2xhdGUvbWFpbi1jb250YWluZXItd2lsbHktd29ua2EnO1xuaW1wb3J0IHsgTmF2RGV0ZWN0aW9uT29tcGFMb29tcGEgfSBmcm9tICcuL2Nob2NvbGF0ZS9uYXYtZGV0ZWN0aW9uLW9vbXBhLWxvb21wYSc7XG5pbXBvcnQgeyBDbHJIZWFkZXIgfSBmcm9tICcuL2hlYWRlcic7XG5pbXBvcnQgeyBDbHJOYXZMZXZlbCB9IGZyb20gJy4vbmF2LWxldmVsJztcblxuZXhwb3J0IGNvbnN0IENMUl9OQVZJR0FUSU9OX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICBDbHJIZWFkZXIsXG4gIENsck5hdkxldmVsLFxuICBOYXZEZXRlY3Rpb25Pb21wYUxvb21wYSxcbiAgTWFpbkNvbnRhaW5lcldpbGx5V29ua2EsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJEcm9wZG93bk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9OQVZJR0FUSU9OX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX05BVklHQVRJT05fRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsck5hdmlnYXRpb25Nb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgdGVtcGxhdGU6IGBcbiAgICAgIDxuZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVJlZkNvbnRhaW5lciB7XG4gIEBWaWV3Q2hpbGQoVGVtcGxhdGVSZWYpIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGVtcGxhdGVSZWZDb250YWluZXIgfSBmcm9tICcuL3RlbXBsYXRlLXJlZi1jb250YWluZXInO1xuXG5leHBvcnQgKiBmcm9tICcuL3RlbXBsYXRlLXJlZi1jb250YWluZXInO1xuXG5leHBvcnQgY29uc3QgVEVNUExBVEVfUkVGX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1RlbXBsYXRlUmVmQ29udGFpbmVyXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBURU1QTEFURV9SRUZfRElSRUNUSVZFUyB9IGZyb20gJy4vaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbVEVNUExBVEVfUkVGX0RJUkVDVElWRVNdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtURU1QTEFURV9SRUZfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtURU1QTEFURV9SRUZfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsclRlbXBsYXRlUmVmTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFdpbGx5V29ua2EgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItdGFicycgfSlcbmV4cG9ydCBjbGFzcyBUYWJzV2lsbHlXb25rYSBleHRlbmRzIFdpbGx5V29ua2Ege31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgT29tcGFMb29tcGEgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IElGX0FDVElWRV9JRCwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBUYWJzV2lsbHlXb25rYSB9IGZyb20gJy4vdGFicy13aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJUYWJMaW5rXSwgY2xyLXRhYi1jb250ZW50JyB9KVxuZXhwb3J0IGNsYXNzIEFjdGl2ZU9vbXBhTG9vbXBhIGV4dGVuZHMgT29tcGFMb29tcGEge1xuICBwcml2YXRlIGlmQWN0aXZlOiBJZkFjdGl2ZVNlcnZpY2U7XG4gIHByaXZhdGUgaWQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIEBPcHRpb25hbCgpIHdpbGx5V29ua2E6IFRhYnNXaWxseVdvbmthLFxuICAgIEBJbmplY3QoSUZfQUNUSVZFX0lEKSBpZDogbnVtYmVyLFxuICAgIGlmQWN0aXZlOiBJZkFjdGl2ZVNlcnZpY2VcbiAgKSB7XG4gICAgaWYgKCF3aWxseVdvbmthKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsclRhYkxpbmsgYW5kIGNsci10YWItY29udGVudCBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsci10YWJzJyk7XG4gICAgfVxuICAgIHN1cGVyKGNkciwgd2lsbHlXb25rYSk7XG4gICAgdGhpcy5pZkFjdGl2ZSA9IGlmQWN0aXZlO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgfVxuXG4gIGdldCBmbGF2b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZBY3RpdmUuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vLyBUT0RPOiBpZiB3ZSBmaW5kIG1vcmUgY29tcG9uZW50cyB0aGF0IGNvdWxkIHVzZSB0aGlzLCBjb25zaWRlciBtb3ZpbmcgdGhpcyB0byB1dGlsc1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFyaWFTZXJ2aWNlIHtcbiAgcHVibGljIGFyaWFMYWJlbGxlZEJ5OiBzdHJpbmc7XG4gIHB1YmxpYyBhcmlhQ29udHJvbHM6IHN0cmluZztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsclRhYiB9IGZyb20gJy4uL3RhYic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUYWJzU2VydmljZSB7XG4gIHByaXZhdGUgX2NoaWxkcmVuOiBDbHJUYWJbXSA9IFtdO1xuXG4gIHJlZ2lzdGVyKHRhYjogQ2xyVGFiKSB7XG4gICAgdGhpcy5fY2hpbGRyZW4ucHVzaCh0YWIpO1xuICB9XG5cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgfVxuXG4gIGdldCBhY3RpdmVUYWIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZmluZCgodGFiOiBDbHJUYWIpID0+IHtcbiAgICAgIHJldHVybiB0YWIuYWN0aXZlO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IG92ZXJmbG93VGFicygpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoKHRhYjogQ2xyVGFiKSA9PiB7XG4gICAgICByZXR1cm4gdGFiLnRhYkxpbmsuaW5PdmVyZmxvdyA9PT0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHVucmVnaXN0ZXIodGFiOiBDbHJUYWIpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZih0YWIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEluamVjdCwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElGX0FDVElWRV9JRCwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UnO1xuaW1wb3J0IHsgQXJpYVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9hcmlhLnNlcnZpY2UnO1xuXG5sZXQgbmJUYWJDb250ZW50Q29tcG9uZW50czogbnVtYmVyID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRhYi1jb250ZW50JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICd0YWJDb250ZW50SWQnLFxuICAgICdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ2FyaWFMYWJlbGxlZEJ5JyxcbiAgICAnW2F0dHIuYXJpYS1oaWRkZW5dJzogJyFhY3RpdmUnLFxuICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdhY3RpdmUnLFxuICAgICdbYXR0ci5kYXRhLWhpZGRlbl0nOiAnIWFjdGl2ZScsXG4gICAgcm9sZTogJ3RhYnBhbmVsJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFiQ29udGVudCB7XG4gIEBWaWV3Q2hpbGQoJ3RhYkNvbnRlbnRQcm9qZWN0ZWRSZWYnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8Q2xyVGFiQ29udGVudD47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIEBJbmplY3QoSUZfQUNUSVZFX0lEKSBwdWJsaWMgaWQ6IG51bWJlcixcbiAgICBwcml2YXRlIGFyaWFTZXJ2aWNlOiBBcmlhU2VydmljZVxuICApIHtcbiAgICBpZiAoIXRoaXMudGFiQ29udGVudElkKSB7XG4gICAgICB0aGlzLnRhYkNvbnRlbnRJZCA9ICdjbHItdGFiLWNvbnRlbnQtJyArIG5iVGFiQ29udGVudENvbXBvbmVudHMrKztcbiAgICB9XG4gIH1cblxuICBnZXQgYXJpYUxhYmVsbGVkQnkoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmlhU2VydmljZS5hcmlhTGFiZWxsZWRCeTtcbiAgfVxuXG4gIGdldCB0YWJDb250ZW50SWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmlhU2VydmljZS5hcmlhQ29udHJvbHM7XG4gIH1cblxuICBASW5wdXQoJ2lkJylcbiAgc2V0IHRhYkNvbnRlbnRJZChpZDogc3RyaW5nKSB7XG4gICAgdGhpcy5hcmlhU2VydmljZS5hcmlhQ29udHJvbHMgPSBpZDtcbiAgfVxuXG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPT09IHRoaXMuaWQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmxldCBuYlRhYnNDb21wb25lbnQgPSAwO1xuXG5leHBvcnQgY29uc3QgVEFCU19JRCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxudW1iZXI+KCdUQUJTX0lEJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbkZhY3RvcnkoKSB7XG4gIHJldHVybiAnY2xyLXRhYnMtJyArIG5iVGFic0NvbXBvbmVudCsrO1xufVxuXG5leHBvcnQgY29uc3QgVEFCU19JRF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogVEFCU19JRCxcbiAgdXNlRmFjdG9yeTogdG9rZW5GYWN0b3J5LFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IFRlbXBsYXRlUmVmQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi1jb250YWluZXInO1xuXG5pbXBvcnQgeyBBcmlhU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2FyaWEuc2VydmljZSc7XG5pbXBvcnQgeyBUQUJTX0lEIH0gZnJvbSAnLi90YWJzLWlkLnByb3ZpZGVyJztcblxubGV0IG5iVGFiTGlua0NvbXBvbmVudHM6IG51bWJlciA9IDA7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJUYWJMaW5rXScsXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICd0YWJMaW5rSWQnLFxuICAgICdbYXR0ci5hcmlhLXNlbGVjdGVkXSc6ICdhY3RpdmUnLFxuICAgICdbYXR0ci5hcmlhLWhpZGRlbl0nOiAnZmFsc2UnLFxuICAgICdbYXR0ci5hcmlhLWNvbnRyb2xzXSc6ICdhcmlhQ29udHJvbHMnLFxuICAgICdbY2xhc3MuYnRuXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmJ0bi1saW5rXSc6ICchaW5PdmVyZmxvdycsXG4gICAgJ1tjbGFzcy5uYXYtbGlua10nOiAnIWluT3ZlcmZsb3cnLFxuICAgICdbY2xhc3MubmF2LWl0ZW1dJzogJyFpbk92ZXJmbG93JyxcbiAgICAnW2NsYXNzLmFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICByb2xlOiAndGFiJyxcbiAgICB0eXBlOiAnYnV0dG9uJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFiTGluayB7XG4gIEBJbnB1dCgnY2xyVGFiTGlua0luT3ZlcmZsb3cnKSBpbk92ZXJmbG93OiBib29sZWFuO1xuICB0ZW1wbGF0ZVJlZkNvbnRhaW5lcjogVGVtcGxhdGVSZWZDb250YWluZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIEBJbmplY3QoSUZfQUNUSVZFX0lEKSBwcml2YXRlIGlkOiBudW1iZXIsXG4gICAgcHJpdmF0ZSBhcmlhU2VydmljZTogQXJpYVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBASW5qZWN0KFRBQlNfSUQpIHB1YmxpYyB0YWJzSWQ6IG51bWJlclxuICApIHtcbiAgICBpZiAoIXRoaXMudGFiTGlua0lkKSB7XG4gICAgICB0aGlzLnRhYkxpbmtJZCA9ICdjbHItdGFiLWxpbmstJyArIG5iVGFiTGlua0NvbXBvbmVudHMrKztcbiAgICB9XG5cbiAgICAvLyBUYWIgbGlua3MgY2FuIGJlIHJlbmRlcmVkIGluIG9uZSBvZiB0d28gcGxhY2VzOiBpbiB0aGUgbWFpbiBhcmVhIG9yIGluc2lkZSB0aGUgb3ZlcmZsb3cgZHJvcGRvd24gbWVudS5cbiAgICAvLyBIZXJlLCB3ZSBjcmVhdGUgYSBjb250YWluZXIgc28gdGhhdCBpdHMgdGVtcGxhdGUgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGVtYmVkZGVkVmlldyBvbiB0aGUgZmx5LlxuICAgIC8vIFNlZSBUYWJzU2VydmljZSdzIHJlbmRlclZpZXcoKSBtZXRob2QgYW5kIGhvdyBpdCdzIHVzZWQgaW4gVGFicyBjbGFzcyBmb3IgYW4gZXhhbXBsZS5cbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoVGVtcGxhdGVSZWZDb250YWluZXIpO1xuICAgIHRoaXMudGVtcGxhdGVSZWZDb250YWluZXIgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIDEsIHVuZGVmaW5lZCwgW1xuICAgICAgW3RoaXMuZWwubmF0aXZlRWxlbWVudF0sXG4gICAgXSkuaW5zdGFuY2U7XG4gIH1cblxuICBnZXQgYXJpYUNvbnRyb2xzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUNvbnRyb2xzO1xuICB9XG5cbiAgZ2V0IHRhYkxpbmtJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFMYWJlbGxlZEJ5O1xuICB9XG5cbiAgQElucHV0KCdpZCcpXG4gIHNldCB0YWJMaW5rSWQoaWQ6IHN0cmluZykge1xuICAgIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUxhYmVsbGVkQnkgPSBpZDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9IHRoaXMuaWQ7XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50ID09PSB0aGlzLmlkO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElGX0FDVElWRV9JRCwgSUZfQUNUSVZFX0lEX1BST1ZJREVSLCBJZkFjdGl2ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuc2VydmljZSc7XG5cbmltcG9ydCB7IEFyaWFTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYXJpYS5zZXJ2aWNlJztcbmltcG9ydCB7IFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdGFicy5zZXJ2aWNlJztcbmltcG9ydCB7IENsclRhYkNvbnRlbnQgfSBmcm9tICcuL3RhYi1jb250ZW50JztcbmltcG9ydCB7IENsclRhYkxpbmsgfSBmcm9tICcuL3RhYi1saW5rLmRpcmVjdGl2ZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10YWInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgcHJvdmlkZXJzOiBbSUZfQUNUSVZFX0lEX1BST1ZJREVSLCBBcmlhU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYiB7XG4gIEBDb250ZW50Q2hpbGQoQ2xyVGFiTGluaykgdGFiTGluazogQ2xyVGFiTGluaztcbiAgQENvbnRlbnRDaGlsZChDbHJUYWJDb250ZW50KSB0YWJDb250ZW50OiBDbHJUYWJDb250ZW50O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBpZkFjdGl2ZVNlcnZpY2U6IElmQWN0aXZlU2VydmljZSxcbiAgICBASW5qZWN0KElGX0FDVElWRV9JRCkgcHVibGljIGlkOiBudW1iZXIsXG4gICAgcHJpdmF0ZSB0YWJzU2VydmljZTogVGFic1NlcnZpY2VcbiAgKSB7XG4gICAgdGFic1NlcnZpY2UucmVnaXN0ZXIodGhpcyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnRhYnNTZXJ2aWNlLnVucmVnaXN0ZXIodGhpcyk7XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50ID09PSB0aGlzLmlkO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBYnN0cmFjdFBvcG92ZXIgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9hYnN0cmFjdC1wb3BvdmVyJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10YWItb3ZlcmZsb3ctY29udGVudCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kcm9wZG93bi1tZW51XSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFiT3ZlcmZsb3dDb250ZW50IGV4dGVuZHMgQWJzdHJhY3RQb3BvdmVyIHtcbiAgY29uc3RydWN0b3IoaW5qZWN0b3I6IEluamVjdG9yLCBAU2tpcFNlbGYoKSBwYXJlbnRIb3N0OiBFbGVtZW50UmVmKSB7XG4gICAgc3VwZXIoaW5qZWN0b3IsIHBhcmVudEhvc3QpO1xuICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fUklHSFQ7XG4gICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEluamVjdCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBUYWJzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RhYnMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUYWJMaW5rIH0gZnJvbSAnLi90YWItbGluay5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVEFCU19JRCwgVEFCU19JRF9QUk9WSURFUiB9IGZyb20gJy4vdGFicy1pZC5wcm92aWRlcic7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGFicycsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDx1bCBjbGFzcz1cIm5hdlwiIHJvbGU9XCJ0YWJsaXN0XCIgW2F0dHIuYXJpYS1vd25zXT1cInRhYklkc1wiPlxuICAgICAgICAgICAgPCEtLXRhYiBsaW5rcy0tPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgbGluayBvZiB0YWJMaW5rRGlyZWN0aXZlc1wiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJsaW5rLnRhYnNJZCA9PT0gdGFic0lkICYmICFsaW5rLmluT3ZlcmZsb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibGluay50ZW1wbGF0ZVJlZkNvbnRhaW5lci50ZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidGFic1NlcnZpY2Uub3ZlcmZsb3dUYWJzLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFicy1vdmVyZmxvdyBib3R0b20tcmlnaHRcIiBbY2xhc3Mub3Blbl09XCJpZk9wZW5TZXJ2aWNlLm9wZW5cIlxuICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZU92ZXJmbG93KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1saW5rIG5hdi1saW5rIGRyb3Bkb3duLXRvZ2dsZVwiIHR5cGU9XCJidXR0b25cIiBbY2xhc3MuYWN0aXZlXT1cImFjdGl2ZVRhYkluT3ZlcmZsb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJlbGxpcHNpcy1ob3Jpem9udGFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5pcy1pbmZvXT1cImlmT3BlblNlcnZpY2Uub3BlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLm1vcmVcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDwhLS10YWIgbGlua3MgaW4gb3ZlcmZsb3cgbWVudS0tPlxuICAgICAgICAgICAgICAgICAgICA8Y2xyLXRhYi1vdmVyZmxvdy1jb250ZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgbGluayBvZiB0YWJMaW5rRGlyZWN0aXZlc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJsaW5rLnRhYnNJZCA9PT0gdGFic0lkICYmIGxpbmsuaW5PdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJsaW5rLnRlbXBsYXRlUmVmQ29udGFpbmVyLnRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9jbHItdGFiLW92ZXJmbG93LWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC91bD5cbiAgICAgICAgPCEtLXRhYiBjb250ZW50LS0+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBwcm92aWRlcnM6IFtJZkFjdGl2ZVNlcnZpY2UsIElmT3BlblNlcnZpY2UsIFRhYnNTZXJ2aWNlLCBUQUJTX0lEX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFicyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICBAQ29udGVudENoaWxkcmVuKENsclRhYkxpbmssIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgdGFiTGlua0RpcmVjdGl2ZXM6IFF1ZXJ5TGlzdDxDbHJUYWJMaW5rPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgcHVibGljIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHVibGljIHRhYnNTZXJ2aWNlOiBUYWJzU2VydmljZSxcbiAgICBASW5qZWN0KFRBQlNfSUQpIHB1YmxpYyB0YWJzSWQ6IG51bWJlcixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHt9XG5cbiAgZ2V0IGFjdGl2ZVRhYkluT3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMudGFic1NlcnZpY2Uub3ZlcmZsb3dUYWJzLmluZGV4T2YodGhpcy50YWJzU2VydmljZS5hY3RpdmVUYWIpID4gLTE7XG4gIH1cblxuICBnZXQgdGFiSWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhYnNTZXJ2aWNlLmNoaWxkcmVuLm1hcCh0YWIgPT4gdGFiLnRhYkxpbmsudGFiTGlua0lkKS5qb2luKCcgJyk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy50YWJMaW5rRGlyZWN0aXZlcy5maXJzdC5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZU92ZXJmbG93KGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXIubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENsclRlbXBsYXRlUmVmTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBBY3RpdmVPb21wYUxvb21wYSB9IGZyb20gJy4vY2hvY29sYXRlL2FjdGl2ZS1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgVGFic1dpbGx5V29ua2EgfSBmcm9tICcuL2Nob2NvbGF0ZS90YWJzLXdpbGx5LXdvbmthJztcbmltcG9ydCB7IENsclRhYiB9IGZyb20gJy4vdGFiJztcbmltcG9ydCB7IENsclRhYkNvbnRlbnQgfSBmcm9tICcuL3RhYi1jb250ZW50JztcbmltcG9ydCB7IENsclRhYkxpbmsgfSBmcm9tICcuL3RhYi1saW5rLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJUYWJPdmVyZmxvd0NvbnRlbnQgfSBmcm9tICcuL3RhYi1vdmVyZmxvdy1jb250ZW50JztcbmltcG9ydCB7IENsclRhYnMgfSBmcm9tICcuL3RhYnMnO1xuXG5leHBvcnQgY29uc3QgQ0xSX1RBQlNfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbXG4gIENsclRhYkNvbnRlbnQsXG4gIENsclRhYixcbiAgQ2xyVGFicyxcbiAgQ2xyVGFiT3ZlcmZsb3dDb250ZW50LFxuICBDbHJUYWJMaW5rLFxuICBUYWJzV2lsbHlXb25rYSxcbiAgQWN0aXZlT29tcGFMb29tcGEsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlLCBDbHJDb25kaXRpb25hbE1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyVGVtcGxhdGVSZWZNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfVEFCU19ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9UQUJTX0RJUkVDVElWRVMsIENsckNvbmRpdGlvbmFsTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFic01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSB7XG4gIHB1YmxpYyBuYXZHcm91cENvdW50OiBudW1iZXIgPSAwO1xuXG4gIHJlZ2lzdGVyTmF2R3JvdXAoKSB7XG4gICAgdGhpcy5uYXZHcm91cENvdW50Kys7XG4gIH1cblxuICB1bnJlZ2lzdGVyTmF2R3JvdXAoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZHcm91cENvdW50LS07XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmVydGljYWxOYXZJY29uU2VydmljZSB7XG4gIHByaXZhdGUgX2ljb25zOiBudW1iZXIgPSAwO1xuXG4gIGdldCBoYXNJY29ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faWNvbnMgPiAwO1xuICB9XG5cbiAgcmVnaXN0ZXJJY29uKCk6IHZvaWQge1xuICAgIHRoaXMuX2ljb25zKys7XG4gIH1cblxuICB1bnJlZ2lzdGVySWNvbigpOiB2b2lkIHtcbiAgICB0aGlzLl9pY29ucy0tO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTmF2U2VydmljZSB7XG4gIHByaXZhdGUgX2FuaW1hdGVPbkNvbGxhcHNlZDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgZ2V0IGFuaW1hdGVPbkNvbGxhcHNlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZU9uQ29sbGFwc2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29sbGFwc2VkQ2hhbmdlZDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgZ2V0IGNvbGxhcHNlZENoYW5nZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlZENoYW5nZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9jb2xsYXBzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWQ7XG4gIH1cblxuICBzZXQgY29sbGFwc2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh0aGlzLmNvbGxhcHNpYmxlICYmIHRoaXMuX2NvbGxhcHNlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29sbGFwc2VCZWhhdmlvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY29sbGFwc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgY29sbGFwc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNpYmxlO1xuICB9XG5cbiAgc2V0IGNvbGxhcHNpYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh0aGlzLl9jb2xsYXBzaWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUgJiYgdGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb2xsYXBzZUJlaGF2aW9yKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbGxhcHNpYmxlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDb2xsYXBzZUJlaGF2aW9yKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5fYW5pbWF0ZU9uQ29sbGFwc2VkLm5leHQodmFsdWUpO1xuICAgIHRoaXMuX2NvbGxhcHNlZCA9IHZhbHVlO1xuICAgIHRoaXMuX2NvbGxhcHNlZENoYW5nZWQubmV4dCh2YWx1ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLXJlZ2lzdHJhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2SWNvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtaWNvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci12ZXJ0aWNhbC1uYXYnLFxuICB0ZW1wbGF0ZVVybDogJy4vdmVydGljYWwtbmF2Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtWZXJ0aWNhbE5hdlNlcnZpY2UsIFZlcnRpY2FsTmF2SWNvblNlcnZpY2UsIFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlXSxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnY2xyLXZlcnRpY2FsLW5hdicsXG4gICAgJ1tjbGFzcy5pcy1jb2xsYXBzZWRdJzogJ2NvbGxhcHNlZCcsXG4gICAgJ1tjbGFzcy5oYXMtbmF2LWdyb3Vwc10nOiAnaGFzTmF2R3JvdXBzJyxcbiAgICAnW2NsYXNzLmhhcy1pY29uc10nOiAnaGFzSWNvbnMnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJWZXJ0aWNhbE5hdiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGdldCBjb2xsYXBzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbmF2U2VydmljZS5jb2xsYXBzaWJsZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyVmVydGljYWxOYXZDb2xsYXBzaWJsZScpXG4gIHNldCBjb2xsYXBzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2libGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBjb2xsYXBzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkO1xuICB9XG5cbiAgQElucHV0KCdjbHJWZXJ0aWNhbE5hdkNvbGxhcHNlZCcpXG4gIHNldCBjb2xsYXBzZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCA9IHZhbHVlO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyVmVydGljYWxOYXZDb2xsYXBzZWRDaGFuZ2UnKVxuICBwcml2YXRlIF9jb2xsYXBzZWRDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIGdldCBoYXNOYXZHcm91cHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZS5uYXZHcm91cENvdW50ID4gMDtcbiAgfVxuXG4gIGdldCBoYXNJY29ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbmF2SWNvblNlcnZpY2UuaGFzSWNvbnM7XG4gIH1cblxuICBwcml2YXRlIF9zdWI6IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9uYXZTZXJ2aWNlOiBWZXJ0aWNhbE5hdlNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbmF2SWNvblNlcnZpY2U6IFZlcnRpY2FsTmF2SWNvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlOiBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICB0aGlzLl9zdWIgPSB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZENoYW5nZWQuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlZENoYW5nZWQuZW1pdCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICB0b2dnbGVCeUJ1dHRvbigpIHtcbiAgICB0aGlzLmNvbGxhcHNlZCA9ICF0aGlzLmNvbGxhcHNlZDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1Yi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfZXhwYW5kQ2hhbmdlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBnZXQgZXhwYW5kQ2hhbmdlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBleHBhbmQoKTogdm9pZCB7XG4gICAgdGhpcy5fZXhwYW5kQ2hhbmdlLm5leHQodHJ1ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uRXZlbnQsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBFeHBhbmQgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvcHJvdmlkZXJzL2V4cGFuZCc7XG5cbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLXJlZ2lzdHJhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuY29uc3QgRVhQQU5ERURfU1RBVEU6IHN0cmluZyA9ICdleHBhbmRlZCc7XG5jb25zdCBDT0xMQVBTRURfU1RBVEU6IHN0cmluZyA9ICdjb2xsYXBzZWQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdmVydGljYWwtbmF2LWdyb3VwJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3ZlcnRpY2FsLW5hdi1ncm91cC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbRXhwYW5kLCBWZXJ0aWNhbE5hdkdyb3VwU2VydmljZV0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdjbHJFeHBhbmQnLCBbXG4gICAgICBzdGF0ZShFWFBBTkRFRF9TVEFURSwgc3R5bGUoeyBoZWlnaHQ6ICcqJyB9KSksXG4gICAgICBzdGF0ZShDT0xMQVBTRURfU1RBVEUsIHN0eWxlKHsgaGVpZ2h0OiAwLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nLCB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9KSksXG4gICAgICB0cmFuc2l0aW9uKGAke0VYUEFOREVEX1NUQVRFfSA8PT4gJHtDT0xMQVBTRURfU1RBVEV9YCwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpKSxcbiAgICBdKSxcbiAgXSxcbiAgaG9zdDogeyBjbGFzczogJ25hdi1ncm91cCcgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZHcm91cCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2l0ZW1FeHBhbmQ6IEV4cGFuZCxcbiAgICBwcml2YXRlIF9uYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2U6IFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdkdyb3VwU2VydmljZTogVmVydGljYWxOYXZHcm91cFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbmF2U2VydmljZTogVmVydGljYWxOYXZTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIHRoaXMuX25hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZS5yZWdpc3Rlck5hdkdyb3VwKCk7XG5cbiAgICAvLyBGSVhNRTogVGhpcyBzdWJzY3JpcHRpb24gaGFuZGxlcyBhIGNvcm5lciBjYXNlXG4gICAgLy8gVmVydGljYWwgTmF2IGNvbGxhcHNlIHJlcXVpcmVzIHRoZSBhbmltYXRpb24gdG8gcnVuIGZpcnN0IGFuZCB0aGVuXG4gICAgLy8gcmVtb3ZlIHRoZSBub2RlcyBmcm9tIHRoZSBET00uIElmIHRoZSB1c2VyIGRpcmVjdGx5IHNldHMgdGhlIGlucHV0XG4gICAgLy8gb24gdGhlIGNscklmRXhwYW5kZWQgZGlyZWN0aXZlLCB3ZSBoYXZlIG5vIGNoYW5jZSB0byBydW4gdGhlIGFuaW1hdGlvblxuICAgIC8vIGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZS4gVGhpcyBzdWJzY3JpcHRpb24gbWFrZXMgc3VyZSB0aGF0IHRoZVxuICAgIC8vIGFuaW1hdGlvbiBzdGF0ZXMgYXJlIGNvcnJlY3QgZm9yIHRoYXQgZWRnZSBjYXNlLlxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX2l0ZW1FeHBhbmQuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID09PSBDT0xMQVBTRURfU1RBVEUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSBFWFBBTkRFRF9TVEFURTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9PT0gRVhQQU5ERURfU1RBVEUpIHtcbiAgICAgICAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyAxLiBJZiB0aGUgbmF2IGlzIGNvbGxhcHNpbmcsIGNsb3NlIHRoZSBvcGVuIG5hdiBncm91cCArIHNhdmUgaXRzIHN0YXRlXG4gICAgLy8gMi4gSWYgdGhlIG5hdiBpcyBleHBhbmRpbmcsIGV4cGFuZCB0aGUgbmF2IGdyb3VwIGlmIHRoZSBwcmV2aW91cyBzdGF0ZSB3YXMgZXhwYW5kZWRcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9uYXZTZXJ2aWNlLmFuaW1hdGVPbkNvbGxhcHNlZC5zdWJzY3JpYmUoKGdvaW5nVG9Db2xsYXBzZTogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoZ29pbmdUb0NvbGxhcHNlICYmIHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICB0aGlzLndhc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICAgICAgICB9IGVsc2UgaWYgKCFnb2luZ1RvQ29sbGFwc2UgJiYgdGhpcy53YXNFeHBhbmRlZCkge1xuICAgICAgICAgIHRoaXMuZXhwYW5kR3JvdXAoKTtcbiAgICAgICAgICB0aGlzLndhc0V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIElmIGEgbGluayBpcyBjbGlja2VkLCBleHBhbmQgdGhlIG5hdiBncm91cFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX25hdkdyb3VwU2VydmljZS5leHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKChleHBhbmQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGV4cGFuZCAmJiAhdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgIHRoaXMuZXhwYW5kR3JvdXAoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSB3YXNFeHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MuaXMtZXhwYW5kZWQnKVxuICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1FeHBhbmQuZXhwYW5kZWQ7XG4gIH1cblxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5faXRlbUV4cGFuZC5leHBhbmRlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2l0ZW1FeHBhbmQuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCdjbHJWZXJ0aWNhbE5hdkdyb3VwRXhwYW5kZWQnKVxuICBzZXQgdXNlckV4cGFuZGVkSW5wdXQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMuZXhwYW5kZWQgIT09IHZhbHVlKSB7XG4gICAgICAvLyBXZSBoYXZlIHRvIGNhbGwgdG9nZ2xlRXhwYW5kIGJlY2F1c2Ugc29tZSBjYXNlcyByZXF1aXJlIGFuaW1hdGlvbnMgdG8gb2NjdXIgZmlyc3RcbiAgICAgIC8vIERpcmVjdGx5IHNldHRpbmcgdGhlIEV4cGFuZCBzZXJ2aWNlIHZhbHVlIHNraXBzIHRoZSBhbmltYXRpb24gYW5kIGNhbiByZXN1bHQgaW5cbiAgICAgIC8vIG5vZGVzIGluIHRoZSBET00gYnV0IHRoZSBuYXYgZ3JvdXAgc3RpbGwgYmVpbmcgY29sbGFwc2VkXG4gICAgICB0aGlzLnRvZ2dsZUV4cGFuZCgpO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsclZlcnRpY2FsTmF2R3JvdXBFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgcHJpdmF0ZSBfZXhwYW5kQW5pbWF0aW9uU3RhdGU6IHN0cmluZyA9IENPTExBUFNFRF9TVEFURTtcblxuICBleHBhbmRHcm91cCgpOiB2b2lkIHtcbiAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAvLyBFeHBhbmRlZCBhbmltYXRpb24gb2NjdXJzIGFmdGVyIEV4cGFuZC5leHBhbmQgaXMgc2V0IHRvIHRydWVcbiAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gRVhQQU5ERURfU1RBVEU7XG4gIH1cblxuICBjb2xsYXBzZUdyb3VwKCk6IHZvaWQge1xuICAgIC8vIElmIGEgVmVydGljYWwgTmF2IEdyb3VwIHRvZ2dsZSBidXR0b24gaXMgY2xpY2tlZCB3aGlsZSB0aGUgVmVydGljYWwgTmF2IGlzIGluIENvbGxhcHNlZCBzdGF0ZSxcbiAgICAvLyB0aGUgVmVydGljYWwgTmF2IHNob3VsZCBiZSBleHBhbmRlZCBmaXJzdC5cbiAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICB9XG5cbiAgLy8gY2xvc2VzIGEgZ3JvdXAgYWZ0ZXIgdGhlIGNvbGxhcHNlIGFuaW1hdGlvblxuICBleHBhbmRBbmltYXRpb25Eb25lKCRldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoJGV2ZW50LnRvU3RhdGUgPT09IENPTExBUFNFRF9TVEFURSkge1xuICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBleHBhbmRBbmltYXRpb25TdGF0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRBbmltYXRpb25TdGF0ZTtcbiAgfVxuXG4gIHNldCBleHBhbmRBbmltYXRpb25TdGF0ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9leHBhbmRBbmltYXRpb25TdGF0ZSkge1xuICAgICAgdGhpcy5fZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVFeHBhbmQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgIHRoaXMuY29sbGFwc2VHcm91cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBuYXYgaXMgY29sbGFzcGVkLCBmaXJzdCBvcGVuIHRoZSBuYXZcbiAgICAgIGlmICh0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gdGhlbiBleHBhbmQgdGhlIG5hdiBncm91cFxuICAgICAgdGhpcy5leHBhbmRHcm91cCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBpZiBzb21lb25lIG1hcmtzIGEgbmF2IGdyb3VwIGV4cGFuZGVkIGluIGEgY29sbGFwc2VkIG5hdlxuICAgIC8vIHRoZSBleHBhbmRlZCBwcm9wZXJ0eSBpcyBzd2l0Y2hlZCBiYWNrIHRvIGNvbGxhcHNlZCBzdGF0ZS5cbiAgICBpZiAodGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQgJiYgdGhpcy5leHBhbmRlZCkge1xuICAgICAgdGhpcy53YXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB0aGlzLl9uYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UudW5yZWdpc3Rlck5hdkdyb3VwKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci12ZXJ0aWNhbC1uYXYtZ3JvdXAtY2hpbGRyZW4nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZHcm91cENoaWxkcmVuIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZJY29uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1pY29uLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyVmVydGljYWxOYXZJY29uXScsIGhvc3Q6IHsgY2xhc3M6ICduYXYtaWNvbicgfSB9KVxuZXhwb3J0IGNsYXNzIENsclZlcnRpY2FsTmF2SWNvbiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3ZlcnRpY2FsTmF2SWNvblNlcnZpY2U6IFZlcnRpY2FsTmF2SWNvblNlcnZpY2UpIHtcbiAgICB0aGlzLl92ZXJ0aWNhbE5hdkljb25TZXJ2aWNlLnJlZ2lzdGVySWNvbigpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdmVydGljYWxOYXZJY29uU2VydmljZS51bnJlZ2lzdGVySWNvbigpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEhvc3RMaXN0ZW5lciwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdbY2xyVmVydGljYWxOYXZMaW5rXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJWZXJ0aWNhbE5hdkljb25dXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8c3BhbiBjbGFzcz1cIm5hdi10ZXh0XCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+ICAgIFxuICAgICAgICA8L3NwYW4+XG4gICAgYCxcbiAgaG9zdDogeyBjbGFzczogJ25hdi1saW5rJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJWZXJ0aWNhbE5hdkxpbmsge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIF9uYXZHcm91cFNlcnZpY2U6IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlKSB7fVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgcHVibGljIGV4cGFuZFBhcmVudE5hdkdyb3VwKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9uYXZHcm91cFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuX25hdkdyb3VwU2VydmljZS5leHBhbmQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENscklmRXhwYW5kTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdiB9IGZyb20gJy4vdmVydGljYWwtbmF2JztcbmltcG9ydCB7IENsclZlcnRpY2FsTmF2R3JvdXAgfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi1ncm91cCc7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdkdyb3VwQ2hpbGRyZW4gfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi1ncm91cC1jaGlsZHJlbic7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdkljb24gfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi1pY29uJztcbmltcG9ydCB7IENsclZlcnRpY2FsTmF2TGluayB9IGZyb20gJy4vdmVydGljYWwtbmF2LWxpbmsnO1xuXG5leHBvcnQgY29uc3QgQ0xSX1ZFUlRJQ0FMX05BVl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyVmVydGljYWxOYXYsXG4gIENsclZlcnRpY2FsTmF2TGluayxcbiAgQ2xyVmVydGljYWxOYXZHcm91cCxcbiAgQ2xyVmVydGljYWxOYXZHcm91cENoaWxkcmVuLFxuICBDbHJWZXJ0aWNhbE5hdkljb24sXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJJZkV4cGFuZE1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9WRVJUSUNBTF9OQVZfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfVkVSVElDQUxfTkFWX0RJUkVDVElWRVMsIENscklmRXhwYW5kTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsck1haW5Db250YWluZXJNb2R1bGUgfSBmcm9tICcuL21haW4tY29udGFpbmVyL21haW4tY29udGFpbmVyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJOYXZpZ2F0aW9uTW9kdWxlIH0gZnJvbSAnLi9uYXYvbmF2aWdhdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVGFic01vZHVsZSB9IGZyb20gJy4vdGFicy90YWJzLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdk1vZHVsZSB9IGZyb20gJy4vdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoeyBleHBvcnRzOiBbQ2xyTWFpbkNvbnRhaW5lck1vZHVsZSwgQ2xyTmF2aWdhdGlvbk1vZHVsZSwgQ2xyVGFic01vZHVsZSwgQ2xyVmVydGljYWxOYXZNb2R1bGVdIH0pXG5leHBvcnQgY2xhc3MgQ2xyTGF5b3V0TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNjcm9sbGluZ1NlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7fVxuXG4gIHN0b3BTY3JvbGxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCduby1zY3JvbGxpbmcnKTtcbiAgfVxuXG4gIHJlc3VtZVNjcm9sbGluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ25vLXNjcm9sbGluZycpKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ25vLXNjcm9sbGluZycpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uRXZlbnQsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZSxcbiAgVmlld0NoaWxkLFxuICBJbmplY3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGb2N1c1RyYXBEaXJlY3RpdmUgfSBmcm9tICcuLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNjcm9sbGluZ1NlcnZpY2UgfSBmcm9tICcuLi91dGlscy9zY3JvbGxpbmcvc2Nyb2xsaW5nLXNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFVOSVFVRV9JRCwgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLW1vZGFsJyxcbiAgdmlld1Byb3ZpZGVyczogW1Njcm9sbGluZ1NlcnZpY2VdLFxuICB0ZW1wbGF0ZVVybDogJy4vbW9kYWwuaHRtbCcsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBub25lOyB9XG4gICAgICAgIDpob3N0Lm9wZW4geyBkaXNwbGF5OiBpbmxpbmU7IH1cbiAgICBgLFxuICBdLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignZmFkZURvd24nLCBbXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IGZhbHNlJywgW3N0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIC0yNSUpJyB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gICAgICB0cmFuc2l0aW9uKCdmYWxzZSA9PiAqJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAtMjUlKScgfSkpXSksXG4gICAgXSksXG4gICAgdHJpZ2dlcignZmFkZScsIFtcbiAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAuODUgfSkpXSksXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSldKSxcbiAgICBdKSxcbiAgXSxcbiAgcHJvdmlkZXJzOiBbVU5JUVVFX0lEX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTW9kYWwgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIEBWaWV3Q2hpbGQoRm9jdXNUcmFwRGlyZWN0aXZlKSBmb2N1c1RyYXA6IEZvY3VzVHJhcERpcmVjdGl2ZTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLm9wZW4nKVxuICBASW5wdXQoJ2Nsck1vZGFsT3BlbicpXG4gIF9vcGVuOiBib29sZWFuID0gZmFsc2U7XG4gIEBPdXRwdXQoJ2Nsck1vZGFsT3BlbkNoYW5nZScpIF9vcGVuQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgQElucHV0KCdjbHJNb2RhbENsb3NhYmxlJykgY2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoJ2Nsck1vZGFsU2l6ZScpIHNpemU6IHN0cmluZztcbiAgQElucHV0KCdjbHJNb2RhbFN0YXRpY0JhY2tkcm9wJykgc3RhdGljQmFja2Ryb3A6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCdjbHJNb2RhbFNraXBBbmltYXRpb24nKSBza2lwQW5pbWF0aW9uOiBzdHJpbmcgPSAnZmFsc2UnO1xuXG4gIC8vIHByZXNlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCBieSB3aXphcmRzXG4gIEBJbnB1dCgnY2xyTW9kYWxPdmVycmlkZVNjcm9sbFNlcnZpY2UnKSBieXBhc3NTY3JvbGxTZXJ2aWNlOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgnY2xyTW9kYWxQcmV2ZW50Q2xvc2UnKSBzdG9wQ2xvc2U6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQE91dHB1dCgnY2xyTW9kYWxBbHRlcm5hdGVDbG9zZScpIGFsdENsb3NlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9zY3JvbGxpbmdTZXJ2aWNlOiBTY3JvbGxpbmdTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzLFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgbW9kYWxJZDogc3RyaW5nXG4gICkge31cblxuICBnZXQgc2l6ZUNsYXNzKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgcmV0dXJuICdtb2RhbC0nICsgdGhpcy5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IHdoZW4gX29wZW4gaXMgc2V0IHRvIHRydWUgYW5kIHNldCBuby1zY3JvbGxpbmcgdG8gdHJ1ZVxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtwcm9wTmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlIH0pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYnlwYXNzU2Nyb2xsU2VydmljZSAmJiBjaGFuZ2VzICYmIGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ19vcGVuJykpIHtcbiAgICAgIGlmIChjaGFuZ2VzLl9vcGVuLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxpbmdTZXJ2aWNlLnN0b3BTY3JvbGxpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbGluZ1NlcnZpY2UucmVzdW1lU2Nyb2xsaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc2Nyb2xsaW5nU2VydmljZS5yZXN1bWVTY3JvbGxpbmcoKTtcbiAgfVxuXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgdGhpcy5fb3BlbkNoYW5nZWQuZW1pdCh0cnVlKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JvZHk6a2V5dXAuZXNjYXBlJylcbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RvcENsb3NlKSB7XG4gICAgICB0aGlzLmFsdENsb3NlLmVtaXQoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY2xvc2FibGUgfHwgIXRoaXMuX29wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgIC8vIHRvZG86IHJlbW92ZSB0aGlzIGFmdGVyIGFuaW1hdGlvbiBidWcgaXMgZml4ZWQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTU3OThcbiAgICAvLyB0aGlzIHdhcyBoYW5kbGVkIGJ5IHRoZSBmYWRlRG9uZSBldmVudCBiZWxvdywgYnV0IHRoYXQgQW5pbWF0aW9uRXZlbnQgaXMgbm90IGZpcmluZyBpbiBBbmd1bGFyIDQuMC5cbiAgICB0aGlzLl9vcGVuQ2hhbmdlZC5lbWl0KGZhbHNlKTtcbiAgICAvLyBTUEVDTUVcbiAgICB0aGlzLmZvY3VzVHJhcC5zZXRQcmV2aW91c0ZvY3VzKCk7IC8vIEhhbmRsZXMgbW92aW5nIGZvY3VzIGJhY2sgdG8gdGhlIGVsZW1lbnQgdGhhdCBoYWQgaXQgYmVmb3JlLlxuICB9XG5cbiAgZmFkZURvbmUoZTogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoZS50b1N0YXRlID09PSAndm9pZCcpIHtcbiAgICAgIHRoaXMuX29wZW5DaGFuZ2VkLmVtaXQoZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRm9jdXNUcmFwTW9kdWxlIH0gZnJvbSAnLi4vdXRpbHMvZm9jdXMtdHJhcC9mb2N1cy10cmFwLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJNb2RhbCB9IGZyb20gJy4vbW9kYWwnO1xuXG5leHBvcnQgY29uc3QgQ0xSX01PREFMX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0Nsck1vZGFsXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyRm9jdXNUcmFwTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX01PREFMX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX01PREFMX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJNb2RhbE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUG9zaXRpb24ge1xuICBhbmNob3JQb2ludDogUG9pbnQ7XG4gIHBvcG92ZXJQb2ludDogUG9pbnQ7XG4gIG9mZnNldFk6IG51bWJlcjtcbiAgb2Zmc2V0WDogbnVtYmVyO1xufVxuXG5leHBvcnQgY29uc3QgU0lHTlBPU1RfUE9TSVRJT05TOiB7IFtpbnB1dDogc3RyaW5nXTogUG9zaXRpb24gfSA9IHtcbiAgJ3RvcC1sZWZ0JzogeyBhbmNob3JQb2ludDogUG9pbnQuVE9QX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5CT1RUT01fUklHSFQsIG9mZnNldFk6IC0xMCwgb2Zmc2V0WDogMCB9LFxuICAndG9wLW1pZGRsZSc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlRPUF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuQk9UVE9NX0NFTlRFUiwgb2Zmc2V0WTogLTEwLCBvZmZzZXRYOiAwIH0sXG4gICd0b3AtcmlnaHQnOiB7IGFuY2hvclBvaW50OiBQb2ludC5UT1BfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkJPVFRPTV9MRUZULCBvZmZzZXRZOiAtMTAsIG9mZnNldFg6IDAgfSxcbiAgJ3JpZ2h0LXRvcCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlJJR0hUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5MRUZUX0JPVFRPTSwgb2Zmc2V0WTogMiwgb2Zmc2V0WDogMTQgfSxcbiAgJ3JpZ2h0LW1pZGRsZSc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlJJR0hUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgb2Zmc2V0WTogNiwgb2Zmc2V0WDogMTQgfSxcbiAgJ3JpZ2h0LWJvdHRvbSc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlJJR0hUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5MRUZUX1RPUCwgb2Zmc2V0WTogLTEsIG9mZnNldFg6IDE0IH0sXG4gICdib3R0b20tcmlnaHQnOiB7IGFuY2hvclBvaW50OiBQb2ludC5CT1RUT01fQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LlRPUF9MRUZULCBvZmZzZXRZOiA5LCBvZmZzZXRYOiAtMSB9LFxuICAnYm90dG9tLW1pZGRsZSc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LkJPVFRPTV9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuVE9QX0NFTlRFUiwgb2Zmc2V0WTogOSwgb2Zmc2V0WDogMTIgfSxcbiAgJ2JvdHRvbS1sZWZ0JzogeyBhbmNob3JQb2ludDogUG9pbnQuQk9UVE9NX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5UT1BfUklHSFQsIG9mZnNldFk6IDksIG9mZnNldFg6IDAgfSxcbiAgJ2xlZnQtYm90dG9tJzogeyBhbmNob3JQb2ludDogUG9pbnQuTEVGVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuUklHSFRfVE9QLCBvZmZzZXRZOiAwLCBvZmZzZXRYOiAtMTQgfSxcbiAgJ2xlZnQtbWlkZGxlJzogeyBhbmNob3JQb2ludDogUG9pbnQuTEVGVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBvZmZzZXRZOiA0LCBvZmZzZXRYOiAtMTQgfSxcbiAgJ2xlZnQtdG9wJzogeyBhbmNob3JQb2ludDogUG9pbnQuTEVGVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuUklHSFRfQk9UVE9NLCBvZmZzZXRZOiAwLCBvZmZzZXRYOiAtMTQgfSxcbiAgZGVmYXVsdDogeyBhbmNob3JQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkxFRlRfQ0VOVEVSLCBvZmZzZXRZOiA2LCBvZmZzZXRYOiAxNCB9LFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RvciwgSW5wdXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFic3RyYWN0UG9wb3ZlciB9IGZyb20gJy4uL2NvbW1vbi9hYnN0cmFjdC1wb3BvdmVyJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbmltcG9ydCB7IFNJR05QT1NUX1BPU0lUSU9OUyB9IGZyb20gJy4vc2lnbnBvc3QtcG9zaXRpb25zJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbi8vIGFrYSB3aGVyZSB0aGUgYXJyb3cgLyBwb2ludGVyIGlzIGF0IGluIHJlbGF0aW9uIHRvIHRoZSBhbmNob3JcbmNvbnN0IFBPU0lUSU9OUzogc3RyaW5nW10gPSBbXG4gICd0b3AtbGVmdCcsXG4gICd0b3AtbWlkZGxlJyxcbiAgJ3RvcC1yaWdodCcsXG4gICdyaWdodC10b3AnLFxuICAncmlnaHQtbWlkZGxlJywgLy8gZGVmYXVsdFxuICAncmlnaHQtYm90dG9tJyxcbiAgJ2JvdHRvbS1yaWdodCcsXG4gICdib3R0b20tbWlkZGxlJyxcbiAgJ2JvdHRvbS1sZWZ0JyxcbiAgJ2xlZnQtYm90dG9tJyxcbiAgJ2xlZnQtbWlkZGxlJyxcbiAgJ2xlZnQtdG9wJyxcbl07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zaWducG9zdC1jb250ZW50JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInNpZ25wb3N0LWZsZXgtd3JhcFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItcG9pbnRlclwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNpZ25wb3N0LWNvbnRlbnQtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJzaWducG9zdC1hY3Rpb24gY2xvc2VcIiAoY2xpY2spPVwiY2xvc2UoKVwiPlxuICAgICAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJjbG9zZVwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MuY2xvc2VcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2lnbnBvc3QtY29udGVudC1ib2R5XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5zaWducG9zdC1jb250ZW50XSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTaWducG9zdENvbnRlbnQgZXh0ZW5kcyBBYnN0cmFjdFBvcG92ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KFBPUE9WRVJfSE9TVF9BTkNIT1IpXG4gICAgcGFyZW50SG9zdDogRWxlbWVudFJlZixcbiAgICBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIGlmICghcGFyZW50SG9zdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItc2lnbnBvc3QtY29udGVudCBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsci1zaWducG9zdCcpO1xuICAgIH1cbiAgICBzdXBlcihpbmplY3RvciwgcGFyZW50SG9zdCk7XG4gICAgdGhpcy5jb21tb25TdHJpbmdzID0gY29tbW9uU3RyaW5ncztcbiAgICAvLyBEZWZhdWx0c1xuICAgIHRoaXMucG9zaXRpb24gPSAncmlnaHQtbWlkZGxlJztcbiAgICB0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICB9XG5cbiAgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncztcblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ2xvc2UgZnVuY3Rpb24gdGhhdCB1c2VzIHRoZSBzaWducG9zdCBpbnN0YW5jZSB0byB0b2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBjb250ZW50IHBvcG92ZXIuXG4gICAqXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfcG9zaXRpb246IHN0cmluZztcblxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBzZXR0ZXIgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgQ2xyU2lnbnBvc3RDb250ZW50IHBvcG92ZXIuIFRoaXMgaXMgYSBjb21iaW5hdGlvbiBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAtIGFuY2hvclBvaW50IC0gd2hlcmUgb24gdGhlIHRyaWdnZXIgdG8gYW5jaG9yIHRoZSBDbHJTaWducG9zdENvbnRlbnRcbiAgICogLSBwb3BvdmVyUG9pbnQgLSB3aGVyZSBvbiB0aGUgQ2xyU2lnbnBvc3RDb250ZW50IGNvbnRhaW5lciB0byBhbGlnbiB3aXRoIHRoZSBhbmNob3JQb2ludFxuICAgKiAtIG9mZnNldFkgLSB3aGVyZSBvbiB0aGUgWSBheGlzIHRvIGFsaWduIHRoZSBDbHJTaWducG9zdENvbnRlbnQgc28gaXQgbWVldHMgc3BlY3NcbiAgICogLSBvZmZzZXRYIC0gd2hlcmUgb24gdGhlIFggYXhpcyB0byBhbGlnbiB0aGUgQ2xyU2lnbnBvc3RDb250ZW50IHNvIGl0IG1lZXRzIHNwZWNzXG4gICAqIFRoZXJlIGFyZSAxMiBwb3NzaWJsZSBwb3NpdGlvbnMgdG8gcGxhY2UgYSBDbHJTaWducG9zdENvbnRlbnQgY29udGFpbmVyOlxuICAgKiAtIHRvcC1sZWZ0XG4gICAqIC0gdG9wLW1pZGRsZVxuICAgKiAtIHRvcC1yaWdodFxuICAgKiAtIHJpZ2h0LXRvcFxuICAgKiAtIHJpZ2h0LW1pZGRsZVxuICAgKiAtIHJpZ2h0LWJvdHRvbVxuICAgKiAtIGJvdHRvbS1yaWdodFxuICAgKiAtIGJvdHRvbS1taWRkbGVcbiAgICogLSBib3R0b20tbGVmdFxuICAgKiAtIGxlZnQtYm90dG9tXG4gICAqIC0gbGVmdC1taWRkbGVcbiAgICogLSBsZWZ0LXRvcFxuICAgKlxuICAgKiBJIHRoaW5rIG9mIGl0IGFzIGZvbGxvd3MgZm9yICd0b3AtbGVmdCcgLT4gQ09OVEFJTkVSX1NJREUtU0lERV9QT1NJVElPTi4gSW4gdGhpcyBjYXNlIENPTlRBSU5FUl9TSURFIGlzICd0b3AnXG4gICAqIG1lYW5pbmcgdGhlIHRvcCBvZiB0aGUgdHJpZ2dlciBpY29uIChhYm92ZSB0aGUgaWNvbiB0aGF0IGhpZGVzL3Nob3dzKSB0aGUgQ2xyU2lnbnBvc3RDb250ZW50LiBBbmQsIFNJREVfUE9TSVRJT05cbiAgICogaXMgJ2xlZnQnIG1lYW5pbmcgdHdvIHRoaW5nczogMSkgdGhlIENsclNpZ25wb3N0Q29udGVudCBjb250YWluZXIgZXh0ZW5kcyB0byB0aGUgbGVmdCBhbmQgMikgdGhlICdhcnJvdy9wb2ludGVyJ1xuICAgKiBsaW5raW5nIHRoZSBTaW5ncG9zdENvbnRlbnQgdG8gdGhlIHRyaWdnZXIgcG9pbnRzIGRvd24gYXQgdGhlIGhvcml6b250YWwgY2VudGVyIG9mIHRoZSB0cmlnZ2VyIGljb24uXG4gICAqXG4gICAqIEBwYXJhbSBuZXdQb3NpdGlvblxuICAgKi9cbiAgQElucHV0KCdjbHJQb3NpdGlvbicpXG4gIHNldCBwb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKSB7XG4gICAgLy8gVWdoXG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIHRoaXMucG9zaXRpb24pO1xuICAgIGlmIChwb3NpdGlvbiAmJiBQT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPiAtMSkge1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSAncmlnaHQtbWlkZGxlJztcbiAgICB9XG4gICAgLy8gVWdoXG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgY29uc3Qgc2V0UG9zaXRpb24gPSBTSUdOUE9TVF9QT1NJVElPTlNbdGhpcy5wb3NpdGlvbl07XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IHNldFBvc2l0aW9uLmFuY2hvclBvaW50O1xuICAgIHRoaXMucG9wb3ZlclBvaW50ID0gc2V0UG9zaXRpb24ucG9wb3ZlclBvaW50O1xuICAgIHRoaXMucG9wb3Zlck9wdGlvbnMub2Zmc2V0WSA9IHNldFBvc2l0aW9uLm9mZnNldFk7XG4gICAgdGhpcy5wb3BvdmVyT3B0aW9ucy5vZmZzZXRYID0gc2V0UG9zaXRpb24ub2Zmc2V0WDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsclNpZ25wb3N0IH0gZnJvbSAnLi9zaWducG9zdCc7XG5pbXBvcnQgeyBDbHJTaWducG9zdENvbnRlbnQgfSBmcm9tICcuL3NpZ25wb3N0LWNvbnRlbnQnO1xuaW1wb3J0IHsgQ2xyU2lnbnBvc3RUcmlnZ2VyIH0gZnJvbSAnLi9zaWducG9zdC10cmlnZ2VyJztcblxuZXhwb3J0IGNvbnN0IENMUl9TSUdOUE9TVF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJTaWducG9zdCwgQ2xyU2lnbnBvc3RDb250ZW50LCBDbHJTaWducG9zdFRyaWdnZXJdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX1NJR05QT1NUX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1NJR05QT1NUX0RJUkVDVElWRVMsIENsckNvbmRpdGlvbmFsTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU2lnbnBvc3RNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5pbXBvcnQgeyBQT1BPVkVSX0hPU1RfQU5DSE9SIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdG9vbHRpcCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy50b29sdGlwXSc6ICd0cnVlJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbSWZPcGVuU2VydmljZSwgeyBwcm92aWRlOiBQT1BPVkVSX0hPU1RfQU5DSE9SLCB1c2VFeGlzdGluZzogRWxlbWVudFJlZiB9XSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVG9vbHRpcCB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdG9yLCBJbnB1dCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0UG9wb3ZlciB9IGZyb20gJy4uL2NvbW1vbi9hYnN0cmFjdC1wb3BvdmVyJztcbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXInO1xuaW1wb3J0IHsgUE9QT1ZFUl9IT1NUX0FOQ0hPUiB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuJztcblxuY29uc3QgUE9TSVRJT05TOiBzdHJpbmdbXSA9IFsnYm90dG9tLWxlZnQnLCAnYm90dG9tLXJpZ2h0JywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdyaWdodCcsICdsZWZ0J107XG5cbmNvbnN0IFNJWkVTOiBzdHJpbmdbXSA9IFsneHMnLCAnc20nLCAnbWQnLCAnbGcnXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRvb2x0aXAtY29udGVudCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy50b29sdGlwLWNvbnRlbnRdJzogJ3RydWUnLFxuICAgIC8vIEknbSBnaXZpbmcgdXAgb24gYW5pbWF0aW9uLCB0aGV5IGRpZCBub3Qgd29yayBiZWZvcmUgYW5kIHdpbGwgbm90IHdvcmsgbm93LlxuICAgIC8vIFRvbyBtYW55IGNvbmZsaWN0cyB3aXRoIENsYXJpdHkgVUkuXG4gICAgJ1tzdHlsZS5vcGFjaXR5XSc6ICcxJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVG9vbHRpcENvbnRlbnQgZXh0ZW5kcyBBYnN0cmFjdFBvcG92ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KFBPUE9WRVJfSE9TVF9BTkNIT1IpXG4gICAgcGFyZW50SG9zdDogRWxlbWVudFJlZlxuICApIHtcbiAgICBpZiAoIXBhcmVudEhvc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyLXRvb2x0aXAtY29udGVudCBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsci10b29sdGlwJyk7XG4gICAgfVxuICAgIHN1cGVyKGluamVjdG9yLCBwYXJlbnRIb3N0KTtcbiAgICAvLyBEZWZhdWx0c1xuICAgIHRoaXMucG9zaXRpb24gPSAncmlnaHQnO1xuICAgIHRoaXMuc2l6ZSA9ICdzbSc7XG4gIH1cblxuICBwcml2YXRlIF9wb3NpdGlvbjogc3RyaW5nO1xuXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gIH1cblxuICBASW5wdXQoJ2NsclBvc2l0aW9uJylcbiAgc2V0IHBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpIHtcbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3Rvb2x0aXAtJyArIHRoaXMucG9zaXRpb24pO1xuICAgIGlmIChwb3NpdGlvbiAmJiBQT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPiAtMSkge1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSAncmlnaHQnO1xuICAgIH1cbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3Rvb2x0aXAtJyArIHRoaXMucG9zaXRpb24pO1xuXG4gICAgLy8gc2V0IHRoZSBwb3BvdmVyIHZhbHVlcyBiYXNlZCBvbiBkaXJlY3Rpb25cbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuVE9QX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5MRUZUX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfc2l6ZTogc3RyaW5nO1xuXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG5cbiAgQElucHV0KCdjbHJTaXplJylcbiAgc2V0IHNpemUoc2l6ZTogc3RyaW5nKSB7XG4gICAgLy8gVWdoXG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0b29sdGlwLScgKyB0aGlzLnNpemUpO1xuICAgIGlmIChzaXplICYmIFNJWkVTLmluZGV4T2Yoc2l6ZSkgPiAtMSkge1xuICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NpemUgPSAnc20nO1xuICAgIH1cbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3Rvb2x0aXAtJyArIHRoaXMuc2l6ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclRvb2x0aXBUcmlnZ2VyXScsIGhvc3Q6IHsgJ1thdHRyLnRhYmluZGV4XSc6ICcwJywgJ1tjbGFzcy50b29sdGlwLXRyaWdnZXJdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJUb29sdGlwVHJpZ2dlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSkge31cblxuICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJylcbiAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICBzaG93VG9vbHRpcCgpOiB2b2lkIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IHRydWU7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJylcbiAgQEhvc3RMaXN0ZW5lcignYmx1cicpXG4gIGhpZGVUb29sdGlwKCk6IHZvaWQge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vblBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJUb29sdGlwIH0gZnJvbSAnLi90b29sdGlwJztcbmltcG9ydCB7IENsclRvb2x0aXBDb250ZW50IH0gZnJvbSAnLi90b29sdGlwLWNvbnRlbnQnO1xuaW1wb3J0IHsgQ2xyVG9vbHRpcFRyaWdnZXIgfSBmcm9tICcuL3Rvb2x0aXAtdHJpZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfVE9PTFRJUF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJUb29sdGlwLCBDbHJUb29sdGlwVHJpZ2dlciwgQ2xyVG9vbHRpcENvbnRlbnRdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX1RPT0xUSVBfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfVE9PTFRJUF9ESVJFQ1RJVkVTLCBDbHJDb25kaXRpb25hbE1vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRvb2x0aXBNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRyb3Bkb3duTW9kdWxlIH0gZnJvbSAnLi9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyU2lnbnBvc3RNb2R1bGUgfSBmcm9tICcuL3NpZ25wb3N0L3NpZ25wb3N0Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi90b29sdGlwL3Rvb2x0aXAubW9kdWxlJztcblxuQE5nTW9kdWxlKHsgZXhwb3J0czogW0NsckRyb3Bkb3duTW9kdWxlLCBDbHJTaWducG9zdE1vZHVsZSwgQ2xyVG9vbHRpcE1vZHVsZV0gfSlcbmV4cG9ydCBjbGFzcyBDbHJQb3BvdmVyTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEJ1dHRvbkh1YlNlcnZpY2Uge1xuICBwdWJsaWMgYnV0dG9uc1JlYWR5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfcHJldmlvdXNCdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IHByZXZpb3VzQnRuQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0J0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9uZXh0QnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBuZXh0QnRuQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9uZXh0QnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2RhbmdlckJ0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgZGFuZ2VyQnRuQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9kYW5nZXJCdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY2FuY2VsQnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBjYW5jZWxCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbmNlbEJ0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9maW5pc2hCdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IGZpbmlzaEJ0bkNsaWNrZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fZmluaXNoQnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2N1c3RvbUJ0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgY3VzdG9tQnRuQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9jdXN0b21CdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHVibGljIGJ1dHRvbkNsaWNrZWQoYnV0dG9uVHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCdwcmV2aW91cycgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzQnRuQ2xpY2tlZC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmICgnbmV4dCcgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX25leHRCdG5DbGlja2VkLm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKCdmaW5pc2gnID09PSBidXR0b25UeXBlKSB7XG4gICAgICB0aGlzLl9maW5pc2hCdG5DbGlja2VkLm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKCdkYW5nZXInID09PSBidXR0b25UeXBlKSB7XG4gICAgICB0aGlzLl9kYW5nZXJCdG5DbGlja2VkLm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKCdjYW5jZWwnID09PSBidXR0b25UeXBlKSB7XG4gICAgICB0aGlzLl9jYW5jZWxCdG5DbGlja2VkLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY3VzdG9tQnRuQ2xpY2tlZC5uZXh0KGJ1dHRvblR5cGUpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZSB9IGZyb20gJy4uL3dpemFyZC1wYWdlJztcblxuLyoqXG4gKiBQYWdlQ29sbGVjdGlvblNlcnZpY2UgbWFuYWdlcyB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcyBhc3NpZ25lZCB0byB0aGUgd2l6YXJkIGFuZCBvZmZlcnNcbiAqIGEgbnVtYmVyIG9mIGZ1bmN0aW9ucyB1c2VmdWwgYWNyb3NzIHRoZSB3aXphcmRzIHByb3ZpZGVycyBhbmQgc3ViY29tcG9uZW50cyAtLSBhbGwgcmVsYXRlZFxuICogdG8gZXNzZW50aWFsbHkgbG9va3VwcyBvbiB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcy5cbiAqXG4gKiBUaGUgZWFzaWVzdCB3YXkgdG8gYWNjZXNzIFBhZ2VDb2xsZWN0aW9uU2VydmljZSBpcyB2aWEgdGhlIHdpemFyZC4gVGhlXG4gKiBmb2xsb3dpbmcgZXhhbXBsZSB3b3VsZCBhbGxvdyB5b3UgdG8gYWNjZXNzIHlvdXIgaW5zdGFuY2Ugb2YgdGhlIHdpemFyZCBmcm9tIHlvdXIgaG9zdFxuICogY29tcG9uZW50IGFuZCB0aGVyZWJ5IGFjY2VzcyB0aGUgcGFnZSBjb2xsZWN0aW9uIHZpYSBZb3VySG9zdENvbXBvbmVudC53aXphcmQucGFnZUNvbGxlY3Rpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIDxjbHItd2l6YXJkICN3aXphcmQgLi4uPlxuICpcbiAqIEBleGFtcGxlXG4gKiBleHBvcnQgY2xhc3MgWW91ckhvc3RDb21wb25lbnQge1xuICogICBAVmlld0NoaWxkKFwid2l6YXJkXCIpIHdpemFyZDogV2l6YXJkO1xuICogICAuLi5cbiAqIH1cbiAqXG4gKiBUaGUgaGVhcnQgb2YgdGhlIHBhZ2UgY29sbGVjdGlvbiBpcyB0aGUgcXVlcnkgbGlzdCBvZiBwYWdlcywgd2hpY2ggaXQgaXMgYXNzaWduZWQgYXMgYVxuICogcmVmZXJlbmNlIHRvIHRoZSBXaXphcmQucGFnZXMgUXVlcnlMaXN0IHdoZW4gdGhlIHdpemFyZCBpcyBjcmVhdGVkLlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBhZ2VDb2xsZWN0aW9uU2VydmljZSB7XG4gIC8qKlxuICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgV2l6YXJkLnBhZ2VzIFF1ZXJ5TGlzdC5cbiAgICpcbiAgICogUG9wdWxhdGVkIHdoZW4gdGhlIHdpemFyZCBpcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcGFnZXM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRQYWdlPjtcblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIFBhZ2VDb2xsZWN0aW9uU2VydmljZS5wYWdlcyBRdWVyeUxpc3QgdG8gYW4gYXJyYXkgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIFVzZWZ1bCBmb3IgbWFueSBpbnN0YW5jZXMgd2hlbiB5b3Ugd291bGQgcHJlZmVyIGEgUXVlcnlMaXN0IHRvIGFjdCBsaWtlIGFuIGFycmF5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhZ2VzQXNBcnJheSgpOiBDbHJXaXphcmRQYWdlW10ge1xuICAgIHJldHVybiB0aGlzLnBhZ2VzID8gdGhpcy5wYWdlcy50b0FycmF5KCkgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIHBhZ2VzIHF1ZXJ5IGxpc3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFnZXNDb3VudCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2VzID8gdGhpcy5wYWdlcy5sZW5ndGggOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5leHQtdG8tbGFzdCBwYWdlIGluIHRoZSBxdWVyeSBsaXN0IG9mIHBhZ2VzLiBPcGVyYXRlcyBhcyBhIGdldHRlclxuICAgKiBzbyB0aGF0IGl0IGlzbid0IHdvcmtpbmcgd2l0aCBzdGFsZSBkYXRhLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBlbnVsdGltYXRlUGFnZSgpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBjb25zdCBwYWdlQ291bnQgPSB0aGlzLnBhZ2VzQ291bnQ7XG5cbiAgICBpZiAocGFnZUNvdW50IDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhZ2VzQXNBcnJheVtwYWdlQ291bnQgLSAyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsYXN0IHBhZ2UgaW4gdGhlIHF1ZXJ5IGxpc3Qgb2YgcGFnZXMuIE9wZXJhdGVzIGFzIGEgZ2V0dGVyXG4gICAqIHNvIHRoYXQgaXQgaXNuJ3Qgd29ya2luZyB3aXRoIHN0YWxlIGRhdGEuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbGFzdFBhZ2UoKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgcGFnZUNvdW50ID0gdGhpcy5wYWdlc0NvdW50O1xuXG4gICAgaWYgKHBhZ2VDb3VudCA8IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbcGFnZUNvdW50IC0gMV07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgcGFnZSBpbiB0aGUgcXVlcnkgbGlzdCBvZiBwYWdlcy4gT3BlcmF0ZXMgYXMgYSBnZXR0ZXJcbiAgICogc28gdGhhdCBpdCBpc24ndCB3b3JraW5nIHdpdGggc3RhbGUgZGF0YS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBmaXJzdFBhZ2UoKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgaWYgKCF0aGlzLnBhZ2VzQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbMF07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBtb3N0bHkgaW50ZXJuYWxseSwgYnV0IGFjY2VwdHMgYSBzdHJpbmcgSUQgYW5kIHJldHVybnMgYSBDbHJXaXphcmRQYWdlXG4gICAqIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIElEIHBhc3NlZC4gTm90ZSB0aGF0IElEcyBoZXJlIHNob3VsZCBpbmNsdWRlIHRoZSBwcmVmaXhcbiAgICogXCJjbHItd2l6YXJkLXBhZ2UtXCIuXG4gICAqXG4gICAqIFJldHVybnMgdGhlIG5leHQtdG8tbGFzdCBwYWdlIGluIHRoZSBxdWVyeSBsaXN0IG9mIHBhZ2VzLiBPcGVyYXRlcyBhcyBhIGdldHRlclxuICAgKiBzbyB0aGF0IGl0IGlzbid0IHdvcmtpbmcgd2l0aCBzdGFsZSBkYXRhLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFnZUJ5SWQoaWQ6IHN0cmluZyk6IENscldpemFyZFBhZ2Uge1xuICAgIGNvbnN0IGZvdW5kUGFnZXM6IENscldpemFyZFBhZ2VbXSA9IHRoaXMucGFnZXMuZmlsdGVyKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiBpZCA9PT0gcGFnZS5pZCk7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tSZXN1bHRzKGZvdW5kUGFnZXMsIGlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIHMgbnVtYmVyIGFzIGEgcGFyYW1ldGVyIGFuZCB0cmVhdHMgdGhhdCBudW1iZXIgYXMgdGhlIGluZGV4IG9mIHRoZSBwYWdlXG4gICAqIHlvdSdyZSBsb29raW5nIGZvciBpbiB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcy4gUmV0dXJucyBhICB3aXphcmQgcGFnZSBvYmplY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRQYWdlQnlJbmRleChpbmRleDogbnVtYmVyKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgcGFnZUNvdW50ID0gdGhpcy5wYWdlc0NvdW50O1xuICAgIGNvbnN0IHBhZ2VzTGFzdEluZGV4OiBudW1iZXIgPSBwYWdlQ291bnQgPiAxID8gcGFnZUNvdW50IC0gMSA6IDA7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXRyaWV2ZSBwYWdlIHdpdGggaW5kZXggb2YgJyArIGluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPiBwYWdlc0xhc3RJbmRleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYWdlIGluZGV4IGlzIGdyZWF0ZXIgdGhhbiBsZW5ndGggb2YgcGFnZXMgYXJyYXkuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFnZXNBc0FycmF5W2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUYWtlcyBhIHdpemFyZCBwYWdlIG9iamVjdCBhcyBhIHBhcmFtZXRlciBhbmQgcmV0dXJucyBpdHMgaW5kZXggaW4gdGhlXG4gICAqIGNvbGxlY3Rpb24gb2YgcGFnZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRQYWdlSW5kZXgocGFnZTogQ2xyV2l6YXJkUGFnZSk6IG51bWJlciB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBhZ2VzQXNBcnJheS5pbmRleE9mKHBhZ2UpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgcGFnZSBjYW5ub3QgYmUgZm91bmQgaW4gY29sbGVjdGlvbiBvZiBwYWdlcy4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ29uc29saWRhdGVzIGd1YXJkIGxvZ2ljIHRoYXQgcHJldmVudHMgYSBjb3VwbGUgb2YgdW5mb3J0dW5hdGUgZWRnZSBjYXNlcyB3aXRoXG4gICAqIGxvb2sgdXBzIG9uIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIGNoZWNrUmVzdWx0cyhyZXN1bHRzOiBDbHJXaXphcmRQYWdlW10sIHJlcXVlc3RlZFBhZ2VJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZm91bmRQYWdlc0NvdW50OiBudW1iZXIgPSByZXN1bHRzLmxlbmd0aCB8fCAwO1xuXG4gICAgaWYgKGZvdW5kUGFnZXNDb3VudCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTW9yZSB0aGFuIG9uZSBwYWdlIGhhcyB0aGUgcmVxdWVzdGVkIGlkICcgKyByZXF1ZXN0ZWRQYWdlSWQgKyAnLicpO1xuICAgIH0gZWxzZSBpZiAoZm91bmRQYWdlc0NvdW50IDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYWdlIGNhbiBiZSBmb3VuZCB3aXRoIHRoZSBpZCAnICsgcmVxdWVzdGVkUGFnZUlkICsgJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgdHdvIG51bWVyaWMgaW5kZXhlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB3aXphcmQgcGFnZSBvYmplY3RzIHRoYXQgaW5jbHVkZVxuICAgKiBhbGwgd2l6YXJkIHBhZ2VzIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24gZnJvbSB0aGUgZmlyc3QgaW5kZXggdG8gdGhlIHNlY29uZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHBhZ2VSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IENscldpemFyZFBhZ2VbXSB7XG4gICAgbGV0IHBhZ2VzOiBDbHJXaXphcmRQYWdlW10gPSBbXTtcblxuICAgIGlmIChzdGFydCA8IDAgfHwgZW5kIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBpc05hTihzdGFydCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSBudWxsIHx8IHR5cGVvZiBlbmQgPT09IHVuZGVmaW5lZCB8fCBpc05hTihlbmQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IHRoaXMucGFnZXNDb3VudCkge1xuICAgICAgZW5kID0gdGhpcy5wYWdlc0NvdW50O1xuICAgIH1cblxuICAgIHBhZ2VzID0gdGhpcy5wYWdlc0FzQXJyYXk7XG5cbiAgICBpZiAoZW5kIC0gc3RhcnQgPT09IDApIHtcbiAgICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBvbmUgcGFnZSB0aGV5IHdhbnRcbiAgICAgIHJldHVybiBbdGhpcy5nZXRQYWdlQnlJbmRleChzdGFydCldO1xuICAgIH1cblxuICAgIC8vIHNsaWNlIGVuZCBkb2VzIG5vdCBpbmNsdWRlIGl0ZW0gcmVmZXJlbmNlZCBieSBlbmQgaW5kZXgsIHdoaWNoIGlzIHdlaXJkIGZvciB1c2Vyc1xuICAgIC8vIGluY3JlbWVudGluZyBlbmQgaW5kZXggaGVyZSB0byBjb3JyZWN0IHRoYXQgc28gdXNlcnMgYW5kIG90aGVyIG1ldGhvZHNcbiAgICAvLyBkb24ndCBoYXZlIHRvIHRoaW5rIGFib3V0IGl0XG4gICAgZW5kID0gZW5kICsgMTtcblxuICAgIC8vIHNsaWNlIGRvZXMgbm90IHJldHVybiB0aGUgbGFzdCBvbmUgaW4gdGhlIHJhbmdlIGJ1dCBpdCBkb2VzIGluY2x1ZGUgdGhlIGZpcnN0IG9uZVxuICAgIC8vIGRvZXMgbm90IG1vZGlmeSBvcmlnaW5hbCBhcnJheVxuICAgIHJldHVybiBwYWdlcy5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIHR3byB3aXphcmQgcGFnZSBvYmplY3RzIGFuZCByZXR1cm5zIHRob3NlIHBhZ2Ugb2JqZWN0cyB3aXRoIGFsbCBvdGhlciBwYWdlXG4gICAqIG9iamVjdHMgYmV0d2VlbiB0aGVtIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24uIEl0IGRvZXNuJ3QgY2FyZSB3aGljaCBwYWdlIGlzIGFoZWFkIG9mIHRoZVxuICAgKiBvdGhlciBpbiB0aGUgcGFyYW1ldGVycy4gSXQgd2lsbCBiZSBzbWFydCBlbm91Z2ggdG8gZmlndXJlIHRoYXQgb3V0ICBvbiBpdHMgb3duLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFnZVJhbmdlRnJvbVBhZ2VzKHBhZ2U6IENscldpemFyZFBhZ2UsIG90aGVyUGFnZTogQ2xyV2l6YXJkUGFnZSk6IENscldpemFyZFBhZ2VbXSB7XG4gICAgY29uc3QgcGFnZUluZGV4ID0gdGhpcy5nZXRQYWdlSW5kZXgocGFnZSk7XG4gICAgY29uc3Qgb3RoZXJQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChvdGhlclBhZ2UpO1xuICAgIGxldCBzdGFydEluZGV4OiBudW1iZXI7XG4gICAgbGV0IGVuZEluZGV4OiBudW1iZXI7XG5cbiAgICBpZiAocGFnZUluZGV4IDw9IG90aGVyUGFnZUluZGV4KSB7XG4gICAgICBzdGFydEluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgZW5kSW5kZXggPSBvdGhlclBhZ2VJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJbmRleCA9IG90aGVyUGFnZUluZGV4O1xuICAgICAgZW5kSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhZ2VSYW5nZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdGhlIHdpemFyZCBwYWdlIG9iamVjdCBvZlxuICAgKiB0aGUgcGFnZSBpbW1lZGlhdGVseSBiZWZvcmUgaXQgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbi4gUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzXG4gICAqIG5vIHBhZ2UgYmVmb3JlIHRoZSBwYWdlIGl0IGlzIHBhc3NlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFByZXZpb3VzUGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgbXlQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChwYWdlKTtcbiAgICBjb25zdCBwcmV2aW91c1BhZ2VJbmRleCA9IG15UGFnZUluZGV4IC0gMTtcbiAgICBpZiAocHJldmlvdXNQYWdlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUJ5SW5kZXgocHJldmlvdXNQYWdlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSBCb29sZWFuIHRoYXQgc2F5cyBpZlxuICAgKiB0aGUgcGFnZSB5b3Ugc2VudCBpdCBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzUGFnZUlzQ29tcGxldGVkKHBhZ2U6IENscldpemFyZFBhZ2UpIHtcbiAgICBsZXQgcHJldmlvdXNQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJldmlvdXNQYWdlID0gdGhpcy5nZXRQcmV2aW91c1BhZ2UocGFnZSk7XG5cbiAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNQYWdlKSB7XG4gICAgICAvLyBwYWdlIGlzIHRoZSBmaXJzdCBwYWdlLiBubyBwcmV2aW91cyBwYWdlLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZpb3VzUGFnZS5jb21wbGV0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdGhlIHdpemFyZCBwYWdlIG9iamVjdCBvZlxuICAgKiB0aGUgcGFnZSBpbW1lZGlhdGVseSBhZnRlciBpdCBpbiB0aGUgcGFnZSBjb2xsZWN0aW9uLiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXNcbiAgICogbm8gcGFnZSBhZnRlciB0aGUgcGFnZSBpdCBpcyBwYXNzZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXROZXh0UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgbXlQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChwYWdlKTtcbiAgICBjb25zdCBuZXh0UGFnZUluZGV4ID0gbXlQYWdlSW5kZXggKyAxO1xuXG4gICAgaWYgKG5leHRQYWdlSW5kZXggPj0gdGhpcy5wYWdlc0FzQXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUJ5SW5kZXgobmV4dFBhZ2VJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIGdlbmVyYXRlcyBhIHN0ZXAgaXRlbSBpZCBmcm9tIHRoZVxuICAgKiBwYWdlIElELiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgc3RlcCBpdGVtIElEIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RlcEl0ZW1JZEZvclBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIGNvbnN0IHBhZ2VJZCA9IHBhZ2UuaWQ7XG4gICAgY29uc3QgcGFnZUlkUGFydHMgPSBwYWdlSWQuc3BsaXQoJy0nKS5yZXZlcnNlKCk7XG5cbiAgICBwYWdlSWRQYXJ0c1sxXSA9ICdzdGVwJztcbiAgICByZXR1cm4gcGFnZUlkUGFydHMucmV2ZXJzZSgpLmpvaW4oJy0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmFsbHkgb25seSB1c2VkIGludGVybmFsbHkgdG8gbWFyayB0aGF0IGEgc3BlY2lmaWMgcGFnZSBoYXMgYmVlbiBcImNvbW1pdHRlZFwiLlxuICAgKiBUaGlzIGludm9sdmVzIG1hcmtpbmcgdGhlIHBhZ2UgY29tcGxldGUgYW5kIGZpcmluZyB0aGUgQ2xyV2l6YXJkUGFnZS5vbkNvbW1pdFxuICAgKiAoY2xyV2l6YXJkUGFnZU9uQ29tbWl0KSBvdXRwdXQuIFRha2VzIHRoZSB3aXphcmQgcGFnZSBvYmplY3QgdGhhdCB5b3UgaW50ZW5kIHRvXG4gICAqIG1hcmsgY29tcGxldGVkIGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY29tbWl0UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgcGFnZUhhc092ZXJyaWRlcyA9IHBhZ2Uuc3RvcE5leHQgfHwgcGFnZS5wcmV2ZW50RGVmYXVsdDtcbiAgICBwYWdlLmNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICBpZiAoIXBhZ2VIYXNPdmVycmlkZXMpIHtcbiAgICAgIC8vIHByZXZlbnQgbG9vcCBvZiBldmVudCBlbWlzc2lvbjsgYWx0ZXJuYXRlIGZsb3dzIHdvcmsgb2ZmXG4gICAgICAvLyBvZiBldmVudCBlbWl0dGVycyB0aGlzIGlzIGhvdyB0aGV5IGJyZWFrIHRoYXQgY3ljbGUuXG4gICAgICBwYWdlLm9uQ29tbWl0LmVtaXQocGFnZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlZCBieSB0aGUgbmF2U2VydmljZSB0byBuYXZpZ2F0ZSBiYWNrIHRvIGZpcnN0IHBvc3NpYmxlIHN0ZXAgYWZ0ZXJcbiAgLy8gcGFnZXMgYXJlIHJlc2V0XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX3BhZ2VzUmVzZXQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHRoYXQgdGhlIG5hdmlnYXRpb24gc2VydmljZSBsaXN0ZW5zIHRvIGluIG9yZGVyIHRvIGtub3cgd2hlblxuICAgKiB0aGUgcGFnZSBjb2xsZWN0aW9uIGNvbXBsZXRlZCBzdGF0ZXMgaGF2ZSBiZWVuIHJlc2V0IHRvIGZhbHNlIHNvIHRoYXQgd2F5IGl0XG4gICAqIGNhbiBhbHNvIHJlc2V0IHRoZSBuYXZpZ2F0aW9uIHRvIG1ha2UgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIHBhZ2UgY29sbGVjdGlvblxuICAgKiBjdXJyZW50L2FjdGl2ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBwYWdlc1Jlc2V0KCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9wYWdlc1Jlc2V0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYWxsIGNvbXBsZXRlZCBzdGF0ZXMgb2YgdGhlIHBhZ2VzIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24gdG8gZmFsc2UgYW5kXG4gICAqIG5vdGlmaWVzIHRoZSBuYXZpZ2F0aW9uIHNlcnZpY2UgdG8gbGlrZXdpc2UgcmVzZXQgdGhlIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICB0aGlzLnBhZ2VzQXNBcnJheS5mb3JFYWNoKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiB7XG4gICAgICBwYWdlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuX3BhZ2VzUmVzZXQubmV4dCh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xscyB0aHJvdWdoIGFsbCB0aGUgcGFnZXMgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbiB0byBtYWtlIHN1cmUgdGhlcmUgYXJlIG5vXG4gICAqIGluY29tcGxldGUgcGFnZXMgc2FuZHdpY2hlZCBiZXR3ZWVuIGNvbXBsZXRlZCBwYWdlcyBpbiB0aGUgd29ya2Zsb3cuIElkZW50aWZpZXNcbiAgICogdGhlIGZpcnN0IGluY29tcGxldGUgcGFnZSBpbmRleCBhbmQgc2V0cyBhbGwgcGFnZXMgYmVoaW5kIGl0IHRvIGEgY29tcGxldGVkXG4gICAqIHN0YXRlIG9mIGZhbHNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29tcGxldGVkU3RhdGVzKCk6IHZvaWQge1xuICAgIGNvbnN0IGZpcnN0SW5jb21wbGV0ZUluZGV4ID0gdGhpcy5maW5kRmlyc3RJbmNvbXBsZXRlUGFnZUluZGV4KCk7XG5cbiAgICBpZiAoZmlyc3RJbmNvbXBsZXRlSW5kZXggPT09IHRoaXMucGFnZXNBc0FycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGFsbCBjb21wbGV0ZSBubyBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wYWdlc0FzQXJyYXkuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKGluZGV4ID4gZmlyc3RJbmNvbXBsZXRlSW5kZXgpIHtcbiAgICAgICAgcGFnZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpbmNvbXBsZXRlIHBhZ2UgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZpbmRGaXJzdEluY29tcGxldGVQYWdlSW5kZXgoKTogbnVtYmVyIHtcbiAgICBsZXQgcmV0dXJuSW5kZXg6IG51bWJlciA9IG51bGw7XG4gICAgdGhpcy5wYWdlc0FzQXJyYXkuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKG51bGwgPT09IHJldHVybkluZGV4ICYmIGZhbHNlID09PSBwYWdlLmNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm5JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmFsbHRocm91Z2gsIGFsbCBjb21wbGV0ZWQsIHJldHVybiBsYXN0IHBhZ2VcbiAgICBpZiAobnVsbCA9PT0gcmV0dXJuSW5kZXgpIHtcbiAgICAgIHJldHVybkluZGV4ID0gdGhpcy5wYWdlc0NvdW50IC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuSW5kZXg7XG4gIH1cblxuICBwdWJsaWMgZmluZEZpcnN0SW5jb21wbGV0ZVBhZ2UoKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgbXlJbmNvbXBsZXRlSW5kZXggPSB0aGlzLmZpbmRGaXJzdEluY29tcGxldGVQYWdlSW5kZXgoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbbXlJbmNvbXBsZXRlSW5kZXhdO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi4vd2l6YXJkLXBhZ2UnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9idXR0b24taHViLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5cbi8qKlxuICogUGVyZm9ybXMgbmF2aWdhdGlvbiBmdW5jdGlvbnMgZm9yIGEgd2l6YXJkIGFuZCBtYW5hZ2VzIHRoZSBjdXJyZW50IHBhZ2UuIFByZXNlbnRlZCBhcyBhXG4gKiBzZXBhcmF0ZSBzZXJ2aWNlIHRvIGVuY2Fwc3VsYXRlIHRoZSBiZWhhdmlvciBvZiBuYXZpZ2F0aW5nIGFuZCBjb21wbGV0aW5nIHRoZSB3aXphcmQgc29cbiAqIHRoYXQgaXQgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgdGhlIHdpemFyZCBhbmQgaXRzIHN1Yi1jb21wb25lbnRzLlxuICpcbiAqIFRoZSBlYXNpZXN0IHdheSB0byBhY2Nlc3MgdGhlIG5hdmlnYXRpb24gc2VydmljZSBpcyB0aGVyZSBhIHJlZmVyZW5jZSBvbiB5b3VyIHdpemFyZC4gVGhlXG4gKiBGb2xsb3dpbmcgZXhhbXBsZSB3b3VsZCBhbGxvdyB5b3UgdG8gYWNjZXNzIHlvdXIgaW5zdGFuY2Ugb2YgdGhlIHdpemFyZCBmcm9tIHlvdXIgaG9zdFxuICogY29tcG9uZW50IGFuZCB0aGVyZWJ5IGFjY2VzcyB0aGUgbmF2aWdhdGlvbiBzZXJ2aWNlIHZpYSBZb3VySG9zdENvbXBvbmVudC53aXphcmQubmF2U2VydmljZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGNsci13aXphcmQgI3dpemFyZCAuLi4+XG4gKlxuICogQGV4YW1wbGVcbiAqIGV4cG9ydCBjbGFzcyBZb3VySG9zdENvbXBvbmVudCB7XG4gKiAgIEBWaWV3Q2hpbGQoXCJ3aXphcmRcIikgd2l6YXJkOiBXaXphcmQ7XG4gKiAgIC4uLlxuICogfVxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBwcmV2aW91cyBidXR0b24gaXMgY2xpY2tlZCBpbiB0aGUgd2l6YXJkLiBQZXJmb3JtcyBjaGVja3NcbiAgICogYmVmb3JlIGFsZXJ0aW5nIHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhlIGJ1dHRvbiBjbGljay4gRW5hY3RzIG5hdmlnYXRpb24gdG9cbiAgICogdGhlIHByZXZpb3VzIHBhZ2UgaWYgbm90IG92ZXJyaWRkZW4gYXQgdGhlIHBhZ2UgbGV2ZWwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBOZXh0IGJ1dHRvbiBpcyBjbGlja2VkIGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIG5leHRCdXR0b25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSXMgbm90aWZpZWQgd2hlbiBhIGRhbmdlciBidXR0b24gaXMgY2xpY2tlZCBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkYW5nZXJCdXR0b25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSXMgbm90aWZpZWQgd2hlbiBhICBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZmluaXNoQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBDdXN0b20gYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY3VzdG9tQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBDYW5jZWwgYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC4gTm90aWZpZXMgdGhlIHdpemFyZCxcbiAgICogd2hpY2ggaGFuZGxlcyBhbGwgY2FuY2VsIGZ1bmN0aW9uYWxpdHksIGlmIGNhbmNlbCBpcyBub3Qgb3ZlcnJpZGRlbiBhdCB0aGUgcGFnZVxuICAgKiBsZXZlbC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBuYXZpZ2F0aW9uIHRvIG1ha2UgdGhlIGZpcnN0IHBhZ2UgY3VycmVudCB3aGVuIHRoZSBwYWdlIGNvbGxlY3Rpb24gc2VydmljZVxuICAgKiBlbWl0cyBhbiBldmVudCBub3RpZnlpbmcgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgdGhhdCBpdCBoYXMgcmVzZXQgYWxsIHBhZ2VzXG4gICAqIHRvIHRoZWlyIHByaXN0aW5lLCBpbmNvbXBsZXRlIHN0YXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwYWdlc1Jlc2V0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UuIEFsc28gc2V0cyB1cCBzdWJzY3JpcHRpb25zXG4gICAqIHRoYXQgbGlzdGVuIHRvIHRoZSBidXR0b24gc2VydmljZSB0byBkZXRlcm1pbmUgd2hlbiBhIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIGluIHRoZSB3aXphcmQuIElzIGFsc28gcmVzcG9uc2libGUgZm9yIHRha2luZyBhY3Rpb24gd2hlbiB0aGUgcGFnZSBjb2xsZWN0aW9uXG4gICAqIHJlcXVlc3RzIHRoYXQgbmF2aWdhdGlvbiBiZSByZXNldCB0byBpdHMgcHJpc3RpbmUgc3RhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VDb2xsZWN0aW9uOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UsIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlKSB7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5wcmV2aW91c0J0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlSXNGaXJzdCB8fCBjdXJyZW50UGFnZS5wcmV2aW91c1N0ZXBEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFnZS5wcmV2aW91c0J1dHRvbkNsaWNrZWQuZW1pdChjdXJyZW50UGFnZSk7XG4gICAgICBpZiAoIWN1cnJlbnRQYWdlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV4dEJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5uZXh0QnRuQ2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCduZXh0Jyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRhbmdlckJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5kYW5nZXJCdG5DbGlja2VkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQW5kQ29tbWl0Q3VycmVudFBhZ2UoJ2RhbmdlcicpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5maW5pc2hCdXR0b25TdWJzY3JpcHRpb24gPSB0aGlzLmJ1dHRvblNlcnZpY2UuZmluaXNoQnRuQ2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCdmaW5pc2gnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY3VzdG9tQnV0dG9uU3Vic2NyaXB0aW9uID0gdGhpcy5idXR0b25TZXJ2aWNlLmN1c3RvbUJ0bkNsaWNrZWQuc3Vic2NyaWJlKCh0eXBlOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICghdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlLmN1c3RvbUJ1dHRvbkNsaWNrZWQuZW1pdCh0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uID0gdGhpcy5idXR0b25TZXJ2aWNlLmNhbmNlbEJ0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZS5wYWdlT25DYW5jZWwuZW1pdCh0aGlzLmN1cnJlbnRQYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhZ2VzUmVzZXRTdWJzY3JpcHRpb24gPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzUmVzZXQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0Rmlyc3RQYWdlQ3VycmVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMubmV4dEJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuZGFuZ2VyQnV0dG9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5maW5pc2hCdXR0b25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLmN1c3RvbUJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5wYWdlc1Jlc2V0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9jdXJyZW50Q2hhbmdlZCA9IG5ldyBTdWJqZWN0PENscldpemFyZFBhZ2U+KCk7XG5cbiAgLyoqXG4gICAqIEFuIE9ic2VydmFibGUgdGhhdCBpcyBwcmVkb21pbmFudGx5IHVzZWQgYW1vbmdzdCB0aGUgc3ViY29tcG9uZW50cyBhbmQgc2VydmljZXNcbiAgICogb2YgdGhlIHdpemFyZC4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB1c2VycyBsaXN0ZW4gdG8gdGhlIENscldpemFyZFBhZ2Uub25Mb2FkXG4gICAqIChjbHJXaXphcmRQYWdlT25Mb2FkKSBvdXRwdXQgaW5zdGVhZCBvZiB0aGlzIE9ic2VydmFibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUNoYW5nZWQoKTogT2JzZXJ2YWJsZTxDbHJXaXphcmRQYWdlPiB7XG4gICAgLy8gVE9ETzogTUFLRSBTVVJFIEVYVEVSTkFMIE9VVFBVVFMgU0FZICdDSEFOR0UnIE5PVCAnQ0hBTkdFRCdcbiAgICAvLyBBIEJSRUFLSU5HIENIQU5HRSBTTyBBV0FJVElORyBNSU5PUiBSRUxFQVNFXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgQm9vbGVhbiBmbGFnIHVzZWQgYnkgdGhlIENscldpemFyZFBhZ2UgdG8gYXZvaWQgYSByYWNlIGNvbmRpdGlvbiB3aGVuIHBhZ2VzIGFyZVxuICAgKiBsb2FkaW5nIGFuZCB0aGVyZSBpcyBubyBjdXJyZW50IHBhZ2UgZGVmaW5lZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgbmF2U2VydmljZUxvYWRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuZm9yY2VGb3J3YXJkIChjbHJXaXphcmRGb3JjZUZvcndhcmROYXZpZ2F0aW9uKSBpbnB1dC4gV2hlbiB0cnVlLFxuICAgKiBuYXZpZ2F0aW5nIGJhY2t3YXJkcyBpbiB0aGUgc3RlcG5hdiBtZW51IHdpbGwgcmVzZXQgYW55IHNraXBwZWQgcGFnZXMnIGNvbXBsZXRlZFxuICAgKiBzdGF0ZSB0byBmYWxzZS5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBhIHdpemFyZCBleGVjdXRlcyB2YWxpZGF0aW9uIG9uIGEgcGFnZS1ieS1wYWdlIGJhc2lzIHdoZW5cbiAgICogdGhlIG5leHQgYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZvcmNlRm9yd2FyZE5hdmlnYXRpb24gPSBmYWxzZTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlVGl0bGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgLy8gd2hlbiB0aGUgcXVlcnlsaXN0IG9mIHBhZ2VzIGlzIGVtcHR5LiB0aGlzIGlzIHRoZSBmaXJzdCBwbGFjZSBpdCBmYWlscy4uLlxuICAgIGlmICghdGhpcy5jdXJyZW50UGFnZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlLnRpdGxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCb29sZWFuIHRoYXQgdGVsbHMgeW91IHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlIGZpcnN0XG4gICAqIHBhZ2UgaW4gdGhlIFdpemFyZC5cbiAgICpcbiAgICogVGhpcyBpcyBoZWxwZnVsIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIGEgcGFnZSBpcyBuYXZpZ2FibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUlzRmlyc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGFnZUNvbGxlY3Rpb24uZmlyc3RQYWdlID09PSB0aGlzLmN1cnJlbnRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCb29sZWFuIHRoYXQgdGVsbHMgeW91IHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlXG4gICAqIGxhc3QgcGFnZSBpbiB0aGUgV2l6YXJkLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGJ1dHRvbnMgc2hvdWxkIGRpc3BsYXkgaW4gdGhlIHdpemFyZCBmb290ZXIuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUlzTGFzdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5sYXN0UGFnZSA9PT0gdGhpcy5jdXJyZW50UGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDbHJXaXphcmRQYWdlIG9iamVjdCBvZiB0aGUgY3VycmVudCBwYWdlIG9yIG51bGwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGlmICghdGhpcy5fY3VycmVudFBhZ2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIENscldpemFyZFBhZ2Ugb2JqZWN0LCBzaW5jZSB0aGF0IG9iamVjdCB0byBiZSB0aGUgY3VycmVudC9hY3RpdmVcbiAgICogcGFnZSBpbiB0aGUgd2l6YXJkLCBhbmQgZW1pdHMgdGhlIENscldpemFyZFBhZ2Uub25Mb2FkIChjbHJXaXphcmRQYWdlT25Mb2FkKVxuICAgKiBldmVudCBmb3IgdGhhdCBwYWdlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYWxsIG9mIHRoaXMgd29yayBpcyBieXBhc3NlZCBpZiB0aGUgQ2xyV2l6YXJkUGFnZSBvYmplY3QgaXMgYWxyZWFkeVxuICAgKiB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHNldCBjdXJyZW50UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYWdlICE9PSBwYWdlICYmICF0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICB0aGlzLl9jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICBwYWdlLm9uTG9hZC5lbWl0KHBhZ2UuaWQpO1xuICAgICAgdGhpcy5fY3VycmVudENoYW5nZWQubmV4dChwYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9tb3ZlZFRvTmV4dFBhZ2UgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHVzZWQgaW50ZXJuYWxseSB0byBhbGVydCB0aGUgd2l6YXJkIHRoYXQgZm9yd2FyZCBuYXZpZ2F0aW9uXG4gICAqIGhhcyBvY2N1cnJlZC4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHRoZSBXaXphcmQub25Nb3ZlTmV4dFxuICAgKiAoY2xyV2l6YXJkT25OZXh0KSBvdXRwdXQgaW5zdGVhZCBvZiB0aGlzIG9uZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1vdmVkVG9OZXh0UGFnZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZWRUb05leHRQYWdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBfd2l6YXJkRmluaXNoZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHVzZWQgaW50ZXJuYWxseSB0byBhbGVydCB0aGUgd2l6YXJkIHRoYXQgdGhlIG5hdiBzZXJ2aWNlXG4gICAqIGhhcyBhcHByb3ZlZCBjb21wbGV0aW9uIG9mIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSB0aGUgV2l6YXJkLndpemFyZEZpbmlzaGVkIChjbHJXaXphcmRPbkZpbmlzaClcbiAgICogb3V0cHV0IGluc3RlYWQgb2YgdGhpcyBvbmUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCB3aXphcmRGaW5pc2hlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fd2l6YXJkRmluaXNoZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgYWR2YW5jZVxuICAgKiB0aGUgdXNlciB0byB0aGUgbmV4dCBwYWdlLlxuICAgKlxuICAgKiBXaGVuIGludm9rZWQsIHRoaXMgbWV0aG9kIHdpbGwgbW92ZSB0aGUgd2l6YXJkIHRvIHRoZSBuZXh0IHBhZ2UgYWZ0ZXJcbiAgICogc3VjY2Vzc2Z1bCB2YWxpZGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZ29lcyB0aHJvdWdoIGFsbCBjaGVja3NcbiAgICogYW5kIGV2ZW50IGVtaXNzaW9ucyBhcyBpZiBXaXphcmQubmV4dChmYWxzZSkgaGFkIGJlZW4gY2FsbGVkLlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHVzZSBXaXphcmQubmV4dChmYWxzZSkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIG5leHQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2VJc0xhc3QpIHtcbiAgICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnZmluaXNoJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCduZXh0Jyk7XG5cbiAgICBpZiAoIXRoaXMud2l6YXJkSGFzQWx0TmV4dCAmJiAhdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgdGhpcy5fbW92ZWRUb05leHRQYWdlLm5leHQodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ5cGFzc2VzIGNoZWNrcyBhbmQgbW9zdCBldmVudCBlbWlzc2lvbnMgdG8gZm9yY2UgYSBwYWdlIHRvIG5hdmlnYXRlIGZvcndhcmQuXG4gICAqXG4gICAqIENvbXBhcmFibGUgdG8gY2FsbGluZyBXaXphcmQubmV4dCgpIG9yIFdpemFyZC5mb3JjZU5leHQoKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZm9yY2VOZXh0KCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICBjb25zdCBuZXh0UGFnZTogQ2xyV2l6YXJkUGFnZSA9IHRoaXMucGFnZUNvbGxlY3Rpb24uZ2V0TmV4dFBhZ2UoY3VycmVudFBhZ2UpO1xuXG4gICAgLy8gY2F0Y2ggZXJyYW50IG51bGwgb3IgdW5kZWZpbmVkcyB0aGF0IGNyZWVwIGluXG4gICAgaWYgKCFuZXh0UGFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgd2l6YXJkIGhhcyBubyBuZXh0IHBhZ2UgdG8gZ28gdG8uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWN1cnJlbnRQYWdlLmNvbXBsZXRlZCkge1xuICAgICAgLy8gdGhpcyBpcyBhIHN0YXRlIHRoYXQgYWx0IG5leHQgZmxvd3MgY2FuIGdldCB0aGVtc2VsdmVzIGluLi4uXG4gICAgICB0aGlzLnBhZ2VDb2xsZWN0aW9uLmNvbW1pdFBhZ2UoY3VycmVudFBhZ2UpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gbmV4dFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIGJ1dHRvbi9hY3Rpb24gdHlwZSBhcyBhIHBhcmFtZXRlci4gRW5jYXBzdWxhdGVzIGFsbCBsb2dpYyBmb3JcbiAgICogZXZlbnQgZW1pc3Npb25zLCBzdGF0ZSBvZiB0aGUgY3VycmVudCBwYWdlLCBhbmQgd2l6YXJkIGFuZCBwYWdlIGxldmVsIG92ZXJyaWRlcy5cbiAgICpcbiAgICogQXZvaWQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5IHVubGVzcyB5b3UgcmVhbGx5IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNoZWNrQW5kQ29tbWl0Q3VycmVudFBhZ2UoYnV0dG9uVHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFBhZ2U6IENscldpemFyZFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlO1xuICAgIGxldCBpQW1UaGVMYXN0UGFnZTogYm9vbGVhbjtcblxuICAgIGxldCBpc05leHQ6IGJvb2xlYW47XG4gICAgbGV0IGlzRGFuZ2VyOiBib29sZWFuO1xuICAgIGxldCBpc0Rhbmdlck5leHQ6IGJvb2xlYW47XG4gICAgbGV0IGlzRGFuZ2VyRmluaXNoOiBib29sZWFuO1xuICAgIGxldCBpc0ZpbmlzaDogYm9vbGVhbjtcblxuICAgIGlmICghY3VycmVudFBhZ2UucmVhZHlUb0NvbXBsZXRlIHx8IHRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpQW1UaGVMYXN0UGFnZSA9IHRoaXMuY3VycmVudFBhZ2VJc0xhc3Q7XG5cbiAgICBpc05leHQgPSBidXR0b25UeXBlID09PSAnbmV4dCc7XG4gICAgaXNEYW5nZXIgPSBidXR0b25UeXBlID09PSAnZGFuZ2VyJztcbiAgICBpc0Rhbmdlck5leHQgPSBpc0RhbmdlciAmJiAhaUFtVGhlTGFzdFBhZ2U7XG4gICAgaXNEYW5nZXJGaW5pc2ggPSBpc0RhbmdlciAmJiBpQW1UaGVMYXN0UGFnZTtcbiAgICBpc0ZpbmlzaCA9IGJ1dHRvblR5cGUgPT09ICdmaW5pc2gnIHx8IGlzRGFuZ2VyRmluaXNoO1xuXG4gICAgaWYgKGlzRmluaXNoICYmICFpQW1UaGVMYXN0UGFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRQYWdlLnByaW1hcnlCdXR0b25DbGlja2VkLmVtaXQoYnV0dG9uVHlwZSk7XG5cbiAgICBpZiAoaXNGaW5pc2gpIHtcbiAgICAgIGN1cnJlbnRQYWdlLmZpbmlzaEJ1dHRvbkNsaWNrZWQuZW1pdChjdXJyZW50UGFnZSk7XG4gICAgfSBlbHNlIGlmIChpc0Rhbmdlcikge1xuICAgICAgY3VycmVudFBhZ2UuZGFuZ2VyQnV0dG9uQ2xpY2tlZC5lbWl0KCk7XG4gICAgfSBlbHNlIGlmIChpc05leHQpIHtcbiAgICAgIGN1cnJlbnRQYWdlLm5leHRCdXR0b25DbGlja2VkLmVtaXQoKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFBhZ2Uuc3RvcE5leHQgfHwgY3VycmVudFBhZ2UucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGN1cnJlbnRQYWdlLm9uQ29tbWl0LmVtaXQoY3VycmVudFBhZ2UuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG9yZGVyIGlzIHZlcnkgaW1wb3J0YW50IHdpdGggdGhlc2UgZW1pdHRlcnMhXG4gICAgaWYgKGlzRmluaXNoKSB7XG4gICAgICAvLyBtYXJrIHBhZ2UgYXMgY29tcGxldGVcbiAgICAgIGlmICghdGhpcy53aXphcmRIYXNBbHROZXh0KSB7XG4gICAgICAgIHRoaXMucGFnZUNvbGxlY3Rpb24uY29tbWl0UGFnZShjdXJyZW50UGFnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl93aXphcmRGaW5pc2hlZC5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2l6YXJkSGFzQWx0TmV4dCkge1xuICAgICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5jb21taXRQYWdlKGN1cnJlbnRQYWdlKTtcblxuICAgICAgaWYgKGlzTmV4dCB8fCBpc0Rhbmdlck5leHQpIHtcbiAgICAgICAgdGhpcy5fbW92ZWRUb05leHRQYWdlLm5leHQodHJ1ZSk7XG4gICAgICB9XG4gICAgICAvLyBqdW1wIG91dCBoZXJlLCBubyBtYXR0ZXIgd2hhdCB0eXBlIHdlJ3JlIGxvb2tpbmcgYXRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXh0IHx8IGlzRGFuZ2VyTmV4dCkge1xuICAgICAgdGhpcy5mb3JjZU5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgY29uY2x1ZGVcbiAgICogdGhlIHdpemFyZC5cbiAgICpcbiAgICogV2hlbiBpbnZva2VkLCB0aGlzIG1ldGhvZCB3aWxsICBpbml0aWF0ZSB0aGUgd29yayBpbnZvbHZlZCB3aXRoIGZpbmFsaXppbmdcbiAgICogYW5kIGZpbmlzaGluZyB0aGUgd2l6YXJkIHdvcmtmbG93LiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZ29lcyB0aHJvdWdoIGFsbFxuICAgKiBjaGVja3MgYW5kIGV2ZW50IGVtaXNzaW9ucyBhcyBpZiBXaXphcmQuZmluaXNoKGZhbHNlKSBoYWQgYmVlbiBjYWxsZWQuXG4gICAqXG4gICAqIEluIG1vc3QgY2FzZXMsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gdXNlIFdpemFyZC5maW5pc2goZmFsc2UpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBmaW5pc2goKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCdmaW5pc2gnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX21vdmVkVG9QcmV2aW91c1BhZ2UgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGUgd2l6YXJkIHdoZW4gYmFja3dhcmRzIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkIHZpYSB0aGVcbiAgICogcHJldmlvdXMgYnV0dG9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbW92ZWRUb1ByZXZpb3VzUGFnZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZWRUb1ByZXZpb3VzUGFnZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9ncmFtbWF0aWNhbGx5IG1vdmVzIHRoZSB3aXphcmQgdG8gdGhlIHBhZ2UgYmVmb3JlIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIEluIG1vc3QgaW5zdGFuY2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGNhbGwgV2l6YXJkLnByZXZpb3VzKClcbiAgICogd2hpY2ggZG9lcyB0aGUgc2FtZSB0aGluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgbGV0IHByZXZpb3VzUGFnZTogQ2xyV2l6YXJkUGFnZTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlSXNGaXJzdCB8fCB0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldmlvdXNQYWdlID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5nZXRQcmV2aW91c1BhZ2UodGhpcy5jdXJyZW50UGFnZSk7XG5cbiAgICBpZiAoIXByZXZpb3VzUGFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21vdmVkVG9QcmV2aW91c1BhZ2UubmV4dCh0cnVlKTtcblxuICAgIGlmICh0aGlzLmZvcmNlRm9yd2FyZE5hdmlnYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudFBhZ2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IHByZXZpb3VzUGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX2NhbmNlbFdpemFyZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIHdpemFyZCB0aGF0IGEgdXNlciBpcyB0cnlpbmcgdG8gY2FuY2VsIGl0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbm90aWZ5V2l6YXJkQ2FuY2VsKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbmNlbFdpemFyZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSBob29rIGludG8gdGhlIGNhbmNlbCB3b3JrZmxvdyBvZiB0aGUgd2l6YXJkIGZyb20gdGhlIG5hdiBzZXJ2aWNlLiBOb3RlIHRoYXRcbiAgICogdGhpcyByb3V0ZSBnb2VzIHRocm91Z2ggYWxsIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zIGFzIGlmIGEgY2FuY2VsIGJ1dHRvbiBoYWRcbiAgICogYmVlbiBjbGlja2VkLlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCB1c2VycyBsb29raW5nIGZvciBhIGhvb2sgaW50byB0aGUgY2FuY2VsIHJvdXRpbmUgYXJlIGFjdHVhbGx5IGxvb2tpbmdcbiAgICogZm9yIGEgd2F5IHRvIGNsb3NlIHRoZSB3aXphcmQgZnJvbSB0aGVpciBob3N0IGNvbXBvbmVudCBiZWNhdXNlIHRoZXkgaGF2ZSBwcmV2ZW50ZWRcbiAgICogdGhlIGRlZmF1bHQgY2FuY2VsIGFjdGlvbi5cbiAgICpcbiAgICogSW4gdGhpcyBpbnN0YW5jZSwgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIFdpemFyZC5jbG9zZSgpIHRvIGF2b2lkIGFueSBldmVudFxuICAgKiBlbWlzc2lvbiBsb29wIHJlc3VsdGluZyBmcm9tIGFuIGV2ZW50IGhhbmRsZXIgY2FsbGluZyBiYWNrIGludG8gcm91dGluZSB0aGF0IHdpbGxcbiAgICogYWdhaW4gZXZva2UgdGhlIGV2ZW50cyBpdCBoYW5kbGVzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5fY2FuY2VsV2l6YXJkLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuc3RvcENhbmNlbCAoY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWwpIGlucHV0LiBXaGVuIHRydWUsIHRoZSBjYW5jZWxcbiAgICogcm91dGluZSBpcyBzdWJ2ZXJ0ZWQgYW5kIG11c3QgYmUgcmVpbnN0YXRlZCBpbiB0aGUgaG9zdCBjb21wb25lbnQgY2FsbGluZyBXaXphcmQuY2xvc2UoKVxuICAgKiBhdCBzb21lIHBvaW50LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB3aXphcmRIYXNBbHRDYW5jZWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBib29sZWFuIGZsYWcgc2hhcmVkIGFjcm9zcyB0aGUgV2l6YXJkIHN1YmNvbXBvbmVudHMgdGhhdCBmb2xsb3dzIHRoZSB2YWx1ZVxuICAgKiBvZiB0aGUgV2l6YXJkLnN0b3BOZXh0IChjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQpIGlucHV0LiBXaGVuIHRydWUsIHRoZSBuZXh0IGFuZCBmaW5pc2hcbiAgICogcm91dGluZXMgYXJlIHN1YnZlcnRlZCBhbmQgbXVzdCBiZSByZWluc3RhdGVkIGluIHRoZSBob3N0IGNvbXBvbmVudCBjYWxsaW5nIFdpemFyZC5uZXh0KCksXG4gICAqIFdpemFyZC5mb3JjZU5leHQoKSwgV2l6YXJkLmZpbmlzaCgpLCBvciBXaXphcmQuZm9yY2VGaW5pc2goKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgd2l6YXJkSGFzQWx0TmV4dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuc3RvcE5hdmlnYXRpb24gKGNscldpemFyZFByZXZlbnROYXZpZ2F0aW9uKSBpbnB1dC4gV2hlbiB0cnVlLCBhbGxcbiAgICogbmF2aWdhdGlvbmFsIGVsZW1lbnRzIGluIHRoZSB3aXphcmQgYXJlIGRpc2FibGVkLlxuICAgKlxuICAgKiBUaGlzIGlzIGludGVuZGVkIHRvIGZyZWV6ZSB0aGUgd2l6YXJkIGluIHBsYWNlLiBFdmVudHMgYXJlIG5vdCBmaXJlZCBzbyB0aGlzIGlzXG4gICAqIG5vdCBhIHdheSB0byBpbXBsZW1lbnQgYWx0ZXJuYXRlIGZ1bmN0aW9uYWxpdHkgZm9yIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHdpemFyZFN0b3BOYXZpZ2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBmbGFnIHNoYXJlZCB3aXRoIHRoZSBzdGVwbmF2IGl0ZW1zIHRoYXQgcHJldmVudHMgdXNlciBjbGlja3Mgb25cbiAgICogc3RlcG5hdiBpdGVtcyBmcm9tIG5hdmlnYXRpbmcgdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgd2l6YXJkRGlzYWJsZVN0ZXBuYXY6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYWxsIHJlcXVpcmVkIGNoZWNrcyB0byBkZXRlcm1pbmUgaWYgYSB1c2VyIGNhbiBuYXZpZ2F0ZSB0byBhIHBhZ2UuIENoZWNraW5nIGF0IGVhY2hcbiAgICogcG9pbnQgaWYgYSBwYWdlIGlzIG5hdmlnYWJsZSAtLSBjb21wbGV0ZWQgd2hlcmUgdGhlIHBhZ2UgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3QgY29tcGxldGVkXG4gICAqIHBhZ2UuXG4gICAqXG4gICAqIFRha2VzIHR3byBwYXJhbWV0ZXJzLiBUaGUgZmlyc3Qgb25lIG11c3QgYmUgZWl0aGVyIHRoZSBDbHJXaXphcmRQYWdlIG9iamVjdCBvciB0aGUgSUQgb2YgdGhlXG4gICAqIENscldpemFyZFBhZ2Ugb2JqZWN0IHRoYXQgeW91IHdhbnQgdG8gbWFrZSB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyBvcHRpb25hbCBhbmQgaXMgYSBCb29sZWFuIGZsYWcgZm9yIFwibGF6eSBjb21wbGV0aW9uXCIuIFdoYXQgdGhpcyBtZWFuc1xuICAgKiBpcyB0aGUgV2l6YXJkIHdpbGwgbWFyayBhbGwgcGFnZXMgYmV0d2VlbiB0aGUgY3VycmVudCBwYWdlIGFuZCB0aGUgcGFnZSB5b3Ugd2FudCB0byBuYXZpZ2F0ZVxuICAgKiB0byBhcyBjb21wbGV0ZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBpbmZvcm1hdGlvbmFsIHdpemFyZHMgdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGFjdGlvbixcbiAgICogYWxsb3dpbmcgYW4gZWFzeSBtZWFucyBmb3IgdXNlcnMgdG8ganVtcCBhaGVhZC5cbiAgICpcbiAgICogVG8gYXZvaWQgY2hlY2tzIG9uIG5hdmlnYXRpb24sIHVzZSBDbHJXaXphcmRQYWdlLm1ha2VDdXJyZW50KCkgaW5zdGVhZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ29UbyhwYWdlVG9Hb1RvT3JJZDogYW55LCBsYXp5Q29tcGxldGU6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGxldCBwYWdlVG9Hb1RvOiBDbHJXaXphcmRQYWdlO1xuICAgIGxldCBjdXJyZW50UGFnZTogQ2xyV2l6YXJkUGFnZTtcbiAgICBsZXQgbXlQYWdlczogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIGxldCBwYWdlc1RvQ2hlY2s6IENscldpemFyZFBhZ2VbXTtcbiAgICBsZXQgb2theVRvTW92ZTogYm9vbGVhbiA9IHRydWU7XG4gICAgbGV0IGdvaW5nRm9yd2FyZDogYm9vbGVhbjtcbiAgICBsZXQgY3VycmVudFBhZ2VJbmRleDogbnVtYmVyO1xuICAgIGxldCBnb1RvUGFnZUluZGV4OiBudW1iZXI7XG5cbiAgICBteVBhZ2VzID0gdGhpcy5wYWdlQ29sbGVjdGlvbjtcbiAgICBwYWdlVG9Hb1RvID0gdHlwZW9mIHBhZ2VUb0dvVG9PcklkID09PSAnc3RyaW5nJyA/IG15UGFnZXMuZ2V0UGFnZUJ5SWQocGFnZVRvR29Ub09ySWQpIDogcGFnZVRvR29Ub09ySWQ7XG4gICAgY3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlO1xuXG4gICAgLy8gbm8gcG9pbnQgaW4gZ29pbmcgdG8gdGhlIGN1cnJlbnQgcGFnZS4geW91J3JlIHRoZXJlIGFscmVhZHkhXG4gICAgLy8gYWxzbyBoYXJkIGJsb2NrIG9uIGFueSBuYXZpZ2F0aW9uIHdoZW4gc3RvcE5hdmlnYXRpb24gaXMgdHJ1ZVxuICAgIGlmIChwYWdlVG9Hb1RvID09PSBjdXJyZW50UGFnZSB8fCB0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudFBhZ2VJbmRleCA9IG15UGFnZXMuZ2V0UGFnZUluZGV4KGN1cnJlbnRQYWdlKTtcbiAgICBnb1RvUGFnZUluZGV4ID0gbXlQYWdlcy5nZXRQYWdlSW5kZXgocGFnZVRvR29Ubyk7XG4gICAgZ29pbmdGb3J3YXJkID0gZ29Ub1BhZ2VJbmRleCA+IGN1cnJlbnRQYWdlSW5kZXg7XG4gICAgcGFnZXNUb0NoZWNrID0gbXlQYWdlcy5nZXRQYWdlUmFuZ2VGcm9tUGFnZXModGhpcy5jdXJyZW50UGFnZSwgcGFnZVRvR29Ubyk7XG5cbiAgICBva2F5VG9Nb3ZlID0gbGF6eUNvbXBsZXRlIHx8IHRoaXMuY2FuR29UbyhwYWdlc1RvQ2hlY2spO1xuXG4gICAgaWYgKCFva2F5VG9Nb3ZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGdvaW5nRm9yd2FyZCAmJiBsYXp5Q29tcGxldGUpIHtcbiAgICAgIHBhZ2VzVG9DaGVjay5mb3JFYWNoKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiB7XG4gICAgICAgIGlmIChwYWdlICE9PSBwYWdlVG9Hb1RvKSB7XG4gICAgICAgICAgcGFnZS5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFnb2luZ0ZvcndhcmQgJiYgdGhpcy5mb3JjZUZvcndhcmROYXZpZ2F0aW9uKSB7XG4gICAgICBwYWdlc1RvQ2hlY2suZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4ge1xuICAgICAgICBwYWdlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2VUb0dvVG87XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIHJhbmdlIG9mIENscldpemFyZFBhZ2Ugb2JqZWN0cyBhcyBhIHBhcmFtZXRlci4gUGVyZm9ybXMgdGhlIHdvcmsgb2YgY2hlY2tpbmdcbiAgICogdGhvc2Ugb2JqZWN0cyB0byBkZXRlcm1pbmUgaWYgbmF2aWdhdGlvbiBjYW4gYmUgYWNjb21wbGlzaGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjYW5Hb1RvKHBhZ2VzVG9DaGVjazogQ2xyV2l6YXJkUGFnZVtdKTogYm9vbGVhbiB7XG4gICAgbGV0IG9rYXlUb01vdmUgPSB0cnVlO1xuICAgIGNvbnN0IG15UGFnZXMgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uO1xuXG4gICAgLy8gcHJldmlvdXMgcGFnZSBjYW4gYmUgaW1wb3J0YW50IHdoZW4gbW92aW5nIGJlY2F1c2UgaWYgaXQncyBjb21wbGV0ZWQgaXRcbiAgICAvLyBhbGxvd3MgdXMgdG8gbW92ZSB0byB0aGUgcGFnZSBldmVuIGlmIGl0J3MgaW5jb21wbGV0ZS4uLlxuICAgIGxldCBwcmV2aW91c1BhZ2VQYXNzZXM6IGJvb2xlYW47XG5cbiAgICBpZiAoIXBhZ2VzVG9DaGVjayB8fCBwYWdlc1RvQ2hlY2subGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHBhZ2VzVG9DaGVjay5mb3JFYWNoKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiB7XG4gICAgICBsZXQgcHJldmlvdXNQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gICAgICBpZiAoIW9rYXlUb01vdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZS5jb21wbGV0ZWQpIHtcbiAgICAgICAgLy8gZGVmYXVsdCBpcyB0cnVlLiBqdXN0IGp1bXAgb3V0IGluc3RlYWQgb2YgY29tcGxpY2F0aW5nIGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHNvIHdlIGtub3cgb3VyIHBhZ2UgaXMgbm90IGNvbXBsZXRlZC4uLlxuICAgICAgcHJldmlvdXNQYWdlID0gbXlQYWdlcy5nZXRQYWdlSW5kZXgocGFnZSkgPiAwID8gbXlQYWdlcy5nZXRQcmV2aW91c1BhZ2UocGFnZSkgOiBudWxsO1xuICAgICAgcHJldmlvdXNQYWdlUGFzc2VzID0gcHJldmlvdXNQYWdlID09PSBudWxsIHx8IHByZXZpb3VzUGFnZS5jb21wbGV0ZWQgPT09IHRydWU7XG5cbiAgICAgIC8vIHdlIGFyZSBmYWxzZSBpZiBub3QgdGhlIGN1cnJlbnQgcGFnZSBBTkQgcHJldmlvdXMgcGFnZSBpcyBub3QgY29tcGxldGVkXG4gICAgICAvLyAoYnV0IG11c3QgaGF2ZSBhIHByZXZpb3VzIHBhZ2UpXG4gICAgICBpZiAoIXBhZ2UuY3VycmVudCAmJiAhcHJldmlvdXNQYWdlUGFzc2VzKSB7XG4gICAgICAgIG9rYXlUb01vdmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2ggdG8gdHJ1ZSBhcyBkZWZhdWx0XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2theVRvTW92ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rcyB0aHJvdWdoIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzIHRvIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzIGluY29tcGxldGVcbiAgICogYW5kIG1ha2VzIHRoYXQgcGFnZSB0aGUgY3VycmVudC9hY3RpdmUgcGFnZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc2V0TGFzdEVuYWJsZWRQYWdlQ3VycmVudCgpOiB2b2lkIHtcbiAgICBjb25zdCBhbGxQYWdlczogQ2xyV2l6YXJkUGFnZVtdID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5wYWdlc0FzQXJyYXk7XG4gICAgbGV0IGxhc3RDb21wbGV0ZWRQYWdlSW5kZXg6IG51bWJlciA9IG51bGw7XG5cbiAgICBhbGxQYWdlcy5mb3JFYWNoKChwYWdlOiBDbHJXaXphcmRQYWdlLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAocGFnZS5jb21wbGV0ZWQpIHtcbiAgICAgICAgbGFzdENvbXBsZXRlZFBhZ2VJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggPT09IG51bGwpIHtcbiAgICAgIC8vIGFsd2F5cyBpcyBhdCBsZWFzdCB0aGUgZmlyc3QgaXRlbS4uLlxuICAgICAgbGFzdENvbXBsZXRlZFBhZ2VJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChsYXN0Q29tcGxldGVkUGFnZUluZGV4ICsgMSA8IGFsbFBhZ2VzLmxlbmd0aCkge1xuICAgICAgbGFzdENvbXBsZXRlZFBhZ2VJbmRleCA9IGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggKyAxO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFBhZ2UgPSBhbGxQYWdlc1tsYXN0Q29tcGxldGVkUGFnZUluZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgZmlyc3QgcGFnZSBpbiB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcyBhbmQgbWFrZXMgdGhhdCBwYWdlIHRoZVxuICAgKiBjdXJyZW50L2FjdGl2ZSBwYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZXRGaXJzdFBhZ2VDdXJyZW50KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzQXNBcnJheVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBzdGVwbmF2IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHdpemFyZCB3aGVuIHBhZ2VzIGFyZSBkeW5hbWljYWxseVxuICAgKiBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHVwZGF0ZU5hdmlnYXRpb24oKTogdm9pZCB7XG4gICAgbGV0IHRvU2V0Q3VycmVudDogQ2xyV2l6YXJkUGFnZTtcbiAgICBsZXQgY3VycmVudFBhZ2VSZW1vdmVkOiBib29sZWFuO1xuXG4gICAgdGhpcy5wYWdlQ29sbGVjdGlvbi51cGRhdGVDb21wbGV0ZWRTdGF0ZXMoKTtcblxuICAgIGN1cnJlbnRQYWdlUmVtb3ZlZCA9IHRoaXMucGFnZUNvbGxlY3Rpb24ucGFnZXNBc0FycmF5LmluZGV4T2YodGhpcy5jdXJyZW50UGFnZSkgPCAwO1xuICAgIGlmIChjdXJyZW50UGFnZVJlbW92ZWQpIHtcbiAgICAgIHRvU2V0Q3VycmVudCA9IHRoaXMucGFnZUNvbGxlY3Rpb24uZmluZEZpcnN0SW5jb21wbGV0ZVBhZ2UoKTtcbiAgICAgIHRoaXMuY3VycmVudFBhZ2UgPSB0b1NldEN1cnJlbnQ7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkSGVhZGVyQWN0aW9uIH0gZnJvbSAnLi4vd2l6YXJkLWhlYWRlci1hY3Rpb24nO1xuaW1wb3J0IHsgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGVhZGVyQWN0aW9uU2VydmljZSB7XG4gIC8vIHRoaXMgc2VydmljZSBjb21tdW5pY2F0ZXMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHByZXNlbmNlL2Rpc3BsYXkgb2YgaGVhZGVyIGFjdGlvbnNcbiAgLy8gYWNyb3NzIHRoZSB3aXphcmRcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmF2U2VydmljZTogV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UpIHt9XG5cbiAgcHVibGljIHdpemFyZEhlYWRlckFjdGlvbnM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRIZWFkZXJBY3Rpb24+O1xuXG4gIHB1YmxpYyBnZXQgd2l6YXJkSGFzSGVhZGVyQWN0aW9ucygpOiBib29sZWFuIHtcbiAgICBjb25zdCB3aXphcmRIZHJBY3Rpb25zID0gdGhpcy53aXphcmRIZWFkZXJBY3Rpb25zO1xuICAgIGlmICghd2l6YXJkSGRyQWN0aW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gd2l6YXJkSGRyQWN0aW9ucy50b0FycmF5KCkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY3VycmVudFBhZ2VIYXNIZWFkZXJBY3Rpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2UgPyB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2UuaGFzSGVhZGVyQWN0aW9ucyA6IGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdldCBzaG93V2l6YXJkSGVhZGVyQWN0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuY3VycmVudFBhZ2VIYXNIZWFkZXJBY3Rpb25zICYmIHRoaXMud2l6YXJkSGFzSGVhZGVyQWN0aW9ucztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGlzcGxheUhlYWRlckFjdGlvbnNXcmFwcGVyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlSGFzSGVhZGVyQWN0aW9ucyB8fCB0aGlzLndpemFyZEhhc0hlYWRlckFjdGlvbnM7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxubGV0IHdpemFyZEhlYWRlckFjdGlvbkluZGV4ID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXdpemFyZC1oZWFkZXItYWN0aW9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJidG4gY2xyLXdpemFyZC1oZWFkZXItYWN0aW9uIGJ0bi1saW5rXCJcbiAgICAgICAgICAgIFtpZF09XCJpZFwiXG4gICAgICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImNsaWNrKClcIlxuICAgICAgICAgICAgW3RpdGxlXT1cInRpdGxlXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG4gIGhvc3Q6IHsgY2xhc3M6ICdjbHItd2l6YXJkLWhlYWRlci1hY3Rpb24td3JhcHBlcicgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkSGVhZGVyQWN0aW9uIHtcbiAgLy8gdGl0bGUgaXMgZXhwbGFuYXRvcnkgdGV4dCBhZGRlZCB0byB0aGUgaGVhZGVyIGFjdGlvblxuICBASW5wdXQoJ3RpdGxlJykgdGl0bGU6IHN0cmluZyA9ICcnO1xuXG4gIC8vIElmIG91ciBob3N0IGhhcyBhbiBJRCBhdHRyaWJ1dGUsIHdlIHVzZSB0aGlzIGluc3RlYWQgb2Ygb3VyIGluZGV4LlxuICBASW5wdXQoJ2lkJykgX2lkOiBzdHJpbmcgPSAod2l6YXJkSGVhZGVyQWN0aW9uSW5kZXgrKykudG9TdHJpbmcoKTtcblxuICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBjbHItd2l6YXJkLWhlYWRlci1hY3Rpb24tJHt0aGlzLl9pZH1gO1xuICB9XG5cbiAgQElucHV0KCdjbHJXaXphcmRIZWFkZXJBY3Rpb25EaXNhYmxlZCcpIHB1YmxpYyBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoJ2FjdGlvbkNsaWNrZWQnKSBoZWFkZXJBY3Rpb25DbGlja2VkOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoZmFsc2UpO1xuXG4gIGNsaWNrKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcGFzc2luZyB0aGUgaGVhZGVyIGFjdGlvbiBpZCBhbGxvd3MgdXNlcnMgdG8gaGF2ZSBvbmUgbWV0aG9kIHRoYXRcbiAgICAvLyByb3V0ZXMgdG8gbWFueSBkaWZmZXJlbnQgYWN0aW9ucyBiYXNlZCBvbiB0aGUgdHlwZSBvZiBoZWFkZXIgYWN0aW9uXG4gICAgLy8gY2xpY2tlZC4gdGhpcyBpcyBmdXJ0aGVyIGFpZGVkIGJ5IHVzZXJzIGJlaW5nIGFibGUgdG8gc3BlY2lmeSBpZHNcbiAgICAvLyBmb3IgdGhlaXIgaGVhZGVyIGFjdGlvbnMuXG4gICAgdGhpcy5oZWFkZXJBY3Rpb25DbGlja2VkLmVtaXQodGhpcy5faWQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhZ2VCdXR0b25zXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRQYWdlQnV0dG9ucyB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlQnV0dG9uc1RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQYWdlSGVhZGVyQWN0aW9uc10nIH0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZUhlYWRlckFjdGlvbnMge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZUhlYWRlckFjdGlvbnNUZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUGFnZU5hdlRpdGxlXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRQYWdlTmF2VGl0bGUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZU5hdlRpdGxlVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhZ2VUaXRsZV0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZVRpdGxlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VUaXRsZVRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEJ1dHRvbkh1YlNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9idXR0b24taHViLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VCdXR0b25zIH0gZnJvbSAnLi93aXphcmQtcGFnZS1idXR0b25zJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VIZWFkZXJBY3Rpb25zIH0gZnJvbSAnLi93aXphcmQtcGFnZS1oZWFkZXItYWN0aW9ucyc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlTmF2VGl0bGUgfSBmcm9tICcuL3dpemFyZC1wYWdlLW5hdnRpdGxlJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VUaXRsZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtdGl0bGUnO1xuXG5sZXQgd2l6YXJkUGFnZUluZGV4ID0gMDtcblxuLyoqXG4gKiBUaGUgQ2xyV2l6YXJkUGFnZSBjb21wb25lbnQgaXMgcmVzcG9uc2libGUgZm9yIGRpc3BsYXlpbmcgdGhlIGNvbnRlbnQgb2YgZWFjaCBzdGVwXG4gKiBpbiB0aGUgd2l6YXJkIHdvcmtmbG93LlxuICpcbiAqIENscldpemFyZFBhZ2UgY29tcG9uZW50IGhhcyBob29rcyBpbnRvIHRoZSBuYXZpZ2F0aW9uIHNlcnZpY2UgKENscldpemFyZFBhZ2UubmF2U2VydmljZSksXG4gKiBwYWdlIGNvbGxlY3Rpb24gKENscldpemFyZFBhZ2UucGFnZUNvbGxlY3Rpb24pLCBhbmQgYnV0dG9uIHNlcnZpY2VcbiAqIChDbHJXaXphcmRQYWdlLmJ1dHRvblNlcnZpY2UpLiBUaGVzZSB0aHJlZSBwcm92aWRlcnMgYXJlIHNoYXJlZCBhY3Jvc3MgdGhlIGNvbXBvbmVudHNcbiAqIHdpdGhpbiBlYWNoIGluc3RhbmNlIG9mIGEgV2l6YXJkLlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXdpemFyZC1wYWdlJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgaG9zdDoge1xuICAgICdbaWRdJzogJ2lkJyxcbiAgICByb2xlOiAndGFicGFuZWwnLFxuICAgICdbYXR0ci5hcmlhLWhpZGRlbl0nOiAnIWN1cnJlbnQnLFxuICAgICdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ3N0ZXBJdGVtSWQnLFxuICAgICdbY2xhc3MuYWN0aXZlXSc6ICdjdXJyZW50JyxcbiAgICAnW2NsYXNzLmNsci13aXphcmQtcGFnZV0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFBhZ2UgaW1wbGVtZW50cyBPbkluaXQge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDbHJXaXphcmRQYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBuYXZTZXJ2aWNlOiBXaXphcmROYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgcGFnZUNvbGxlY3Rpb246IFBhZ2VDb2xsZWN0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgYnV0dG9uU2VydmljZTogQnV0dG9uSHViU2VydmljZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBwYWdlIHRpdGxlIHdoaWNoIGlzIHVzZWQgZm9yIGEgbnVtYmVyXG4gICAqIG9mIGRpZmZlcmVudCB0YXNrcyBmb3IgZGlzcGxheSBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJXaXphcmRQYWdlVGl0bGUpIHB1YmxpYyBwYWdlVGl0bGU6IENscldpemFyZFBhZ2VUaXRsZTtcblxuICAvKipcbiAgICogQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGRlc2lyZWQgdGl0bGUgZm9yIHRoZSBwYWdlJ3Mgc3RlcCBpbiB0aGVcbiAgICogbmF2aWdhdGlvbiBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB3aXphcmQuIENhbiBiZSBwcm9qZWN0ZWQgdG8gY2hhbmdlIHRoZVxuICAgKiBuYXZpZ2F0aW9uIGxpbmsncyB0ZXh0LlxuICAgKlxuICAgKiBJZiBub3QgZGVmaW5lZCwgdGhlbiBDbHJXaXphcmRQYWdlLnBhZ2VUaXRsZSB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgc3RlcG5hdi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyV2l6YXJkUGFnZU5hdlRpdGxlKSBwdWJsaWMgcGFnZU5hdlRpdGxlOiBDbHJXaXphcmRQYWdlTmF2VGl0bGU7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBidXR0b25zIGRlZmluZWQgd2l0aGluIHRoZSBwYWdlLiBJZiBub3QgZGVmaW5lZCxcbiAgICogdGhlIHdpemFyZCBkZWZhdWx0cyB0byB0aGUgc2V0IG9mIGJ1dHRvbnMgZGVmaW5lZCBhcyBhIGRpcmVjdCBjaGlsZCBvZiB0aGVcbiAgICogd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJXaXphcmRQYWdlQnV0dG9ucykgcHVibGljIF9idXR0b25zOiBDbHJXaXphcmRQYWdlQnV0dG9ucztcblxuICAvKipcbiAgICogQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGhlYWRlciBhY3Rpb25zIGRlZmluZWQgd2l0aGluIHRoZSBwYWdlLiBJZiBub3QgZGVmaW5lZCxcbiAgICogdGhlIHdpemFyZCBkZWZhdWx0cyB0byB0aGUgc2V0IG9mIGhlYWRlciBhY3Rpb25zIGRlZmluZWQgYXMgYSBkaXJlY3QgY2hpbGQgb2YgdGhlXG4gICAqIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyV2l6YXJkUGFnZUhlYWRlckFjdGlvbnMpIHB1YmxpYyBfaGVhZGVyQWN0aW9uczogQ2xyV2l6YXJkUGFnZUhlYWRlckFjdGlvbnM7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9uZXh0U3RlcERpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIHRoYXQgdGVsbHMgd2hldGhlciBvciBub3QgdGhlIHdpemFyZCBzaG91bGQgYmUgYWxsb3dlZFxuICAgKiB0byBtb3ZlIHRvIHRoZSBuZXh0IHBhZ2UuXG4gICAqXG4gICAqIFVzZWZ1bCBmb3IgaW4tcGFnZSB2YWxpZGF0aW9uIGJlY2F1c2UgaXQgcHJldmVudHMgZm9yd2FyZCBuYXZpZ2F0aW9uXG4gICAqIGFuZCB2aXNpYmx5IGRpc2FibGVzIHRoZSBuZXh0IGJ1dHRvbi5cbiAgICpcbiAgICogRG9lcyBub3QgcmVxdWlyZSB0aGF0IHlvdSByZS1pbXBsZW1lbnQgbmF2aWdhdGlvbiByb3V0aW5lcyBsaWtlIHlvdVxuICAgKiB3b3VsZCBpZiB5b3Ugd2VyZSB1c2luZyBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0IG9yXG4gICAqIFdpemFyZC5wcmV2ZW50RGVmYXVsdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgbmV4dFN0ZXBEaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dFN0ZXBEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBhZ2Ugc2hvdWxkIGFsbG93IGZvcndhcmQgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUGFnZU5leHREaXNhYmxlZCcpXG4gIHB1YmxpYyBzZXQgbmV4dFN0ZXBEaXNhYmxlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX25leHRTdGVwRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX25leHRTdGVwRGlzYWJsZWQgPSB2YWxCb29sO1xuICAgICAgdGhpcy5uZXh0U3RlcERpc2FibGVkQ2hhbmdlLmVtaXQodmFsQm9vbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHZhbHVlIG9mIENscldpemFyZFBhZ2UubmV4dFN0ZXBEaXNhYmxlZCBjaGFuZ2VzLlxuICAgKiBTaG91bGQgZW1pdCB0aGUgbmV3IHZhbHVlIG9mIG5leHRTdGVwRGlzYWJsZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlTmV4dERpc2FibGVkQ2hhbmdlJykgbmV4dFN0ZXBEaXNhYmxlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfcHJldmlvdXNTdGVwRGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIgdGhhdCB0ZWxscyB3aGV0aGVyIG9yIG5vdCB0aGUgd2l6YXJkIHNob3VsZCBiZSBhbGxvd2VkXG4gICAqIHRvIG1vdmUgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAqXG4gICAqIFVzZWZ1bCBmb3IgaW4tcGFnZSB2YWxpZGF0aW9uIGJlY2F1c2UgaXQgcHJldmVudHMgYmFja3dhcmQgbmF2aWdhdGlvblxuICAgKiBhbmQgdmlzaWJseSBkaXNhYmxlcyB0aGUgcHJldmlvdXMgYnV0dG9uLlxuICAgKlxuICAgKiBEb2VzIG5vdCByZXF1aXJlIHRoYXQgeW91IHJlLWltcGxlbWVudCBuYXZpZ2F0aW9uIHJvdXRpbmVzIGxpa2UgeW91XG4gICAqIHdvdWxkIGlmIHlvdSB3ZXJlIHVzaW5nIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHQgb3JcbiAgICogV2l6YXJkLnByZXZlbnREZWZhdWx0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBwcmV2aW91c1N0ZXBEaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNTdGVwRGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSBwYWdlIHNob3VsZCBhbGxvdyBiYWNrd2FyZCBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQYWdlUHJldmlvdXNEaXNhYmxlZCcpXG4gIHB1YmxpYyBzZXQgcHJldmlvdXNTdGVwRGlzYWJsZWQodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgdmFsQm9vbCA9ICEhdmFsO1xuICAgIGlmICh2YWxCb29sICE9PSB0aGlzLl9wcmV2aW91c1N0ZXBEaXNhYmxlZCkge1xuICAgICAgdGhpcy5fcHJldmlvdXNTdGVwRGlzYWJsZWQgPSB2YWxCb29sO1xuICAgICAgdGhpcy5wcmV2aW91c1N0ZXBEaXNhYmxlZENoYW5nZS5lbWl0KHZhbEJvb2wpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB2YWx1ZSBvZiBDbHJXaXphcmRQYWdlLnByZXZpb3VzU3RlcERpc2FibGVkIGNoYW5nZXMuXG4gICAqIFNob3VsZCBlbWl0IHRoZSBuZXcgdmFsdWUgb2YgcHJldmlvdXNTdGVwRGlzYWJsZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlUHJldmlvdXNEaXNhYmxlZENoYW5nZScpXG4gIHB1YmxpYyBwcmV2aW91c1N0ZXBEaXNhYmxlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYWxsIGFjdGlvbnMgZnJvbSB0aGUgcGFnZSBsZXZlbCwgc28geW91IGNhbiB1c2UgYW4gYWx0ZXJuYXRlIGZ1bmN0aW9uIGZvclxuICAgKiB2YWxpZGF0aW9uIG9yIGRhdGEtbXVuZ2luZyB3aXRoIGEgQ2xyV2l6YXJkUGFnZS5vbkNvbW1pdCAoY2xyV2l6YXJkUGFnZU9uQ29tbWl0IG91dHB1dCksXG4gICAqIENscldpemFyZFBhZ2Uub25DYW5jZWwgKGNscldpemFyZFBhZ2VPbkNhbmNlbCBvdXRwdXQpLCBvciBvbmVcbiAgICogb2YgdGhlIGdyYW51bGFyIHBhZ2UtbGV2ZWwgYnV0dG9uIGNsaWNrIGV2ZW50IGVtaXR0ZXJzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHQnKSBwdWJsaWMgcHJldmVudERlZmF1bHQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHByaXZhdGUgX3N0b3BDYW5jZWwgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIgdGhhdCByZXRyaWV2ZXMgd2hldGhlciB0aGUgcGFnZSBpcyBwcmV2ZW50aW5nIHRoZSBjYW5jZWwgYWN0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBzdG9wQ2FuY2VsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdG9wQ2FuY2VsO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgY2FuY2VsIGFjdGlvbiBmcm9tIHRoZSBwYWdlIGxldmVsLiBBbGxvd3MgeW91IHRvIHVzZSBhblxuICAgKiBhbHRlcm5hdGUgZnVuY3Rpb24gZm9yIHZhbGlkYXRpb24gb3IgZGF0YS1tdW5naW5nIGJlZm9yZSBjYW5jZWxsaW5nIHRoZVxuICAgKiB3aXphcmQgd2hlbiBjb21iaW5lZCB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLm9uQ2FuY2VsXG4gICAqICh0aGUgY2xyV2l6YXJkUGFnZU9uQ2FuY2VsIG91dHB1dCkuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoYXQgeW91IG1hbnVhbGx5IGNsb3NlIHRoZSB3aXphcmQgZnJvbSB5b3VyIGhvc3QgY29tcG9uZW50LFxuICAgKiB1c3VhbGx5IHdpdGggYSBjYWxsIHRvIFdpemFyZC5mb3JjZU5leHQoKSBvciB3aXphcmQubmV4dCgpO1xuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkUGFnZVxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHRDYW5jZWwnKVxuICBwdWJsaWMgc2V0IHN0b3BDYW5jZWwodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgdmFsQm9vbCA9ICEhdmFsO1xuICAgIGlmICh2YWxCb29sICE9PSB0aGlzLl9zdG9wQ2FuY2VsKSB7XG4gICAgICB0aGlzLl9zdG9wQ2FuY2VsID0gdmFsQm9vbDtcbiAgICAgIHRoaXMuc3RvcENhbmNlbENoYW5nZS5lbWl0KHZhbEJvb2wpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0Q2FuY2VsQ2hhbmdlJykgc3RvcENhbmNlbENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfc3RvcE5leHQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIgdGhhdCB0ZWxscyB5b3Ugd2hldGhlciB0aGUgcGFnZSBpcyBwcmV2ZW50aW5nIHRoZSBuZXh0IGFjdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgc3RvcE5leHQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BOZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBmb3J3YXJkIG5hdmlnYXRpb24gZnJvbSB0aGUgcGFnZSBsZXZlbC4gQWxsb3dzIHlvdSB0byB1c2UgYW5cbiAgICogYWx0ZXJuYXRlIGZ1bmN0aW9uIGZvciB2YWxpZGF0aW9uIG9yIGRhdGEtbXVuZ2luZyBiZWZvcmUgbW92aW5nIHRoZVxuICAgKiB3aXphcmQgdG8gdGhlIG5leHQgcGFnZXdoZW4gY29tYmluZWQgd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5vbkNvbW1pdFxuICAgKiAoY2xyV2l6YXJkUGFnZU9uQ29tbWl0KSBvciBDbHJXaXphcmRQYWdlLm5leHRCdXR0b25DbGlja2VkXG4gICAqIChjbHJXaXphcmRQYWdlTmV4dCkgb3V0cHV0cy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhhdCB5b3UgbWFudWFsbHkgdGVsbCB0aGUgd2l6YXJkIHRvIG5hdmlnYXRlIGZvcndhcmQgZnJvbVxuICAgKiB0aGUgaG9zdENvbXBvbmVudCwgdXN1YWxseSB3aXRoIGEgY2FsbCB0byBXaXphcmQuZm9yY2VOZXh0KCkgb3JcbiAgICogd2l6YXJkLm5leHQoKTtcbiAgICpcbiAgICogQG1lbWJlcm9mIENscldpemFyZFBhZ2VcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0TmV4dCcpXG4gIHB1YmxpYyBzZXQgc3RvcE5leHQodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgdmFsQm9vbCA9ICEhdmFsO1xuICAgIGlmICh2YWxCb29sICE9PSB0aGlzLl9zdG9wTmV4dCkge1xuICAgICAgdGhpcy5fc3RvcE5leHQgPSB2YWxCb29sO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbiBldmVudCBlbWl0dGVyIGNhcnJpZWQgb3ZlciBmcm9tIGEgbGVnYWN5IHZlcnNpb24gb2YgQ2xyV2l6YXJkUGFnZS5cbiAgICogRmlyZXMgYW4gZXZlbnQgb24gQ2xyV2l6YXJkUGFnZSB3aGVuZXZlciB0aGUgbmV4dCBvciBmaW5pc2ggYnV0dG9uc1xuICAgKiBhcmUgY2xpY2tlZCBhbmQgdGhlIHBhZ2UgaXMgdGhlIGN1cnJlbnQgcGFnZSBvZiB0aGUgV2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhdXRvbWF0aWNhbGx5IGVtaXQgYW4gZXZlbnQgd2hlbiBhIGN1c3RvbVxuICAgKiBidXR0b24gaXMgdXNlZCBpbiBwbGFjZSBvZiBhIG5leHQgb3IgZmluaXNoIGJ1dHRvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VPbkNvbW1pdCcpIG9uQ29tbWl0OiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gQ2xyV2l6YXJkUGFnZSBiZWNvbWVzIHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhlXG4gICAqIFdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VPbkxvYWQnKSBvbkxvYWQ6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBDbHJXaXphcmRQYWdlIGludm9rZXMgdGhlIGNhbmNlbCByb3V0aW5lIGZvciB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLnN0b3BDYW5jZWxcbiAgICogKGNscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdENhbmNlbCkgb3IgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXRzIHRvIGltcGxlbWVudCBjdXN0b20gY2FuY2VsXG4gICAqIGZ1bmN0aW9uYWxpdHkgYXQgdGhlIHBhZ2UgbGV2ZWwuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvXG4gICAqIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FybiB1c2VycyBiZWZvcmUgY2FuY2VsbGluZyB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuY2xvc2UoKSBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC5cbiAgICogVGhpcyBjb25zdGl0dWVzIGEgZnVsbCByZXBsYWNlbWVudCBvZiB0aGUgY2FuY2VsIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlT25DYW5jZWwnKSBwYWdlT25DYW5jZWw6IEV2ZW50RW1pdHRlcjxDbHJXaXphcmRQYWdlPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgZmluaXNoIGJ1dHRvbiBpcyBjbGlja2VkIGFuZCB0aGUgQ2xyV2l6YXJkUGFnZSBpc1xuICAgKiB0aGUgd2l6YXJkJ3MgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0XG4gICAqIChjbHJXaXphcmRQYWdlUGFnZVByZXZlbnREZWZhdWx0KSBpbnB1dCB0byBpbXBsZW1lbnQgY3VzdG9tIGZpbmlzaFxuICAgKiBmdW5jdGlvbmFsaXR5IGF0IHRoZSBwYWdlIGxldmVsLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkb1xuICAgKiB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm4gdXNlcnMgYmVmb3JlIGFsbG93aW5nIHRoZW0gdG8gY29tcGxldGVcbiAgICogdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLmZpbmlzaCgpIG9yIFdpemFyZC5mb3JjZUZpbmlzaCgpXG4gICAqIGZyb20gdGhlIGhvc3QgY29tcG9uZW50LiBUaGlzIGNvbWJpbmF0aW9uIGNyZWF0ZXMgYSBmdWxsIHJlcGxhY2VtZW50IG9mXG4gICAqIHRoZSBmaW5pc2ggZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VGaW5pc2gnKSBmaW5pc2hCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8Q2xyV2l6YXJkUGFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIHByZXZpb3VzIGJ1dHRvbiBpcyBjbGlja2VkIGFuZCB0aGUgQ2xyV2l6YXJkUGFnZSBpc1xuICAgKiB0aGUgd2l6YXJkJ3MgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0XG4gICAqIChjbHJXaXphcmRQYWdlUGFnZVByZXZlbnREZWZhdWx0KSBpbnB1dCB0byBpbXBsZW1lbnQgY3VzdG9tIGJhY2t3YXJkc1xuICAgKiBuYXZpZ2F0aW9uIGF0IHRoZSBwYWdlIGxldmVsLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkb1xuICAgKiB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm4gdXNlcnMgYmVmb3JlIGFsbG93aW5nIHRoZW0gdG8gZ29cbiAgICogYmFja3dhcmRzIGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHlvdSB0byBjYWxsIFdpemFyZC5wcmV2aW91cygpXG4gICAqIGZyb20gdGhlIGhvc3QgY29tcG9uZW50LiBUaGlzIGNvbWJpbmF0aW9uIGNyZWF0ZXMgYSBmdWxsIHJlcGxhY2VtZW50IG9mXG4gICAqIHRoZSBiYWNrd2FyZHMgbmF2aWdhdGlvbiBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZVByZXZpb3VzJykgcHJldmlvdXNCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8Q2xyV2l6YXJkUGFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG5leHQgYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZSBDbHJXaXphcmRQYWdlIGlzXG4gICAqIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gZm9yd2FyZHNcbiAgICogbmF2aWdhdGlvbiBhdCB0aGUgcGFnZSBsZXZlbC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG9cbiAgICogdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuIHVzZXJzIGJlZm9yZSBhbGxvd2luZyB0aGVtIHRvIGdvXG4gICAqIHRvIHRoZSBuZXh0IHBhZ2UgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLmZvcmNlTmV4dCgpIG9yIFdpemFyZC5uZXh0KClcbiAgICogZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXMgY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2ZcbiAgICogdGhlIGZvcndhcmQgbmF2aWdhdGlvbiBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZU5leHQnKSBuZXh0QnV0dG9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPENscldpemFyZFBhZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIGEgZGFuZ2VyIGJ1dHRvbiBpcyBjbGlja2VkIGFuZCB0aGUgQ2xyV2l6YXJkUGFnZSBpc1xuICAgKiB0aGUgd2l6YXJkJ3MgY3VycmVudCBwYWdlLiBCeSBkZWZhdWx0LCBhIGRhbmdlciBidXR0b24gd2lsbCBhY3QgYXNcbiAgICogZWl0aGVyIGEgXCJuZXh0XCIgb3IgXCJmaW5pc2hcIiBidXR0b24gZGVwZW5kaW5nIG9uIGlmIHRoZSBDbHJXaXphcmRQYWdlIGlzIHRoZVxuICAgKiBsYXN0IHBhZ2Ugb3Igbm90LlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0XG4gICAqIChjbHJXaXphcmRQYWdlUGFnZVByZXZlbnREZWZhdWx0KSBpbnB1dCB0byBpbXBsZW1lbnQgY3VzdG9tIGZvcndhcmRzXG4gICAqIG9yIGZpbmlzaCBuYXZpZ2F0aW9uIGF0IHRoZSBwYWdlIGxldmVsIHdoZW4gdGhlIGRhbmdlciBidXR0b24gaXMgY2xpY2tlZC5cbiAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG8gdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuXG4gICAqIHVzZXJzIGJlZm9yZSBhbGxvd2luZyB0aGVtIHRvIGdvIHRvIHRoZSBuZXh0IHBhZ2UgaW4gdGhlIHdpemFyZCBvclxuICAgKiBmaW5pc2ggdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLmZpbmlzaCgpLCBXaXphcmQuZm9yY2VGaW5pc2goKSxcbiAgICogV2l6YXJkLmZvcmNlTmV4dCgpIG9yIFdpemFyZC5uZXh0KCkgZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXNcbiAgICogY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2YgdGhlIGZvcndhcmQgbmF2aWdhdGlvbiBhbmRcbiAgICogZmluaXNoIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlRGFuZ2VyJykgZGFuZ2VyQnV0dG9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPENscldpemFyZFBhZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIGEgbmV4dCwgZmluaXNoLCBvciBkYW5nZXIgYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZVxuICAgKiBDbHJXaXphcmRQYWdlIGlzIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gZm9yd2FyZHNcbiAgICogb3IgZmluaXNoIG5hdmlnYXRpb24gYXQgdGhlIHBhZ2UgbGV2ZWwsIHJlZ2FyZGxlc3Mgb2YgdGhlIHR5cGUgb2ZcbiAgICogcHJpbWFyeSBidXR0b24uXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FyblxuICAgKiB1c2VycyBiZWZvcmUgYWxsb3dpbmcgdGhlbSB0byBnbyB0byB0aGUgbmV4dCBwYWdlIGluIHRoZSB3aXphcmQgb3JcbiAgICogZmluaXNoIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHlvdSB0byBjYWxsIFdpemFyZC5maW5pc2goKSwgV2l6YXJkLmZvcmNlRmluaXNoKCksXG4gICAqIFdpemFyZC5mb3JjZU5leHQoKSBvciBXaXphcmQubmV4dCgpIGZyb20gdGhlIGhvc3QgY29tcG9uZW50LiBUaGlzXG4gICAqIGNvbWJpbmF0aW9uIGNyZWF0ZXMgYSBmdWxsIHJlcGxhY2VtZW50IG9mIHRoZSBmb3J3YXJkIG5hdmlnYXRpb24gYW5kXG4gICAqIGZpbmlzaCBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZVByaW1hcnknKSBwcmltYXJ5QnV0dG9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZUN1c3RvbUJ1dHRvbicpIGN1c3RvbUJ1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBBbiBpbnB1dCB2YWx1ZSB0aGF0IGlzIHVzZWQgaW50ZXJuYWxseSB0byBnZW5lcmF0ZSB0aGUgQ2xyV2l6YXJkUGFnZSBJRCBhc1xuICAgKiB3ZWxsIGFzIHRoZSBzdGVwIG5hdiBpdGVtIElELlxuICAgKlxuICAgKiBUeXBlZCBhcyBhbnkgYmVjYXVzZSBpdCBzaG91bGQgYmUgYWJsZSB0byBhY2NlcHQgbnVtYmVycyBhcyB3ZWxsIGFzXG4gICAqIHN0cmluZ3MuIFBhc3NpbmcgYW4gaW5kZXggZm9yIHdpemFyZCB3aG9zZSBwYWdlcyBhcmUgY3JlYXRlZCB3aXRoIGFuXG4gICAqIG5nRm9yIGxvb3AgaXMgYSBjb21tb24gdXNlIGNhc2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2lkJykgX2lkOiBhbnkgPSAod2l6YXJkUGFnZUluZGV4KyspLnRvU3RyaW5nKCk7XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IGdlbmVyYXRlcyBhbiBJRCBzdHJpbmcgZm9yIHRoZSB3aXphcmQgcGFnZSBmcm9tXG4gICAqIGVpdGhlciB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoZSBDbHJXaXphcmRQYWdlIFwiaWRcIiBpbnB1dCBvciBhIHdpemFyZCBwYWdlXG4gICAqIGNvdW50ZXIgc2hhcmVkIGFjcm9zcyBhbGwgd2l6YXJkIHBhZ2VzIGluIHRoZSBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSB2YWx1ZSBwYXNzZWQgaW50byB0aGUgSUQgaW5wdXQgV2lsbCBiZSBwcmVmaXhlZCB3aXRoXG4gICAqIFwiY2xyLXdpemFyZC1wYWdlLVwiLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICpcbiAgICogQG1lbWJlcm9mIENscldpemFyZFBhZ2VcbiAgICovXG4gIHB1YmxpYyBnZXQgaWQoKSB7XG4gICAgLy8gY292ZXJzIHRoaW5ncyBsaWtlIG51bGwsIHVuZGVmaW5lZCwgZmFsc2UsIGFuZCBlbXB0eSBzdHJpbmdcbiAgICAvLyB3aGlsZSBhbGxvd2luZyB6ZXJvIHRvIHBhc3NcbiAgICBjb25zdCBpZElzTm9uWmVyb0ZhbHN5ID0gIXRoaXMuX2lkICYmIHRoaXMuX2lkICE9PSAwO1xuXG4gICAgLy8gaW4gYWRkaXRpb24gdG8gbm9uLXplcm8gZmFsc3kgd2UgYWxzbyB3YW50IHRvIG1ha2Ugc3VyZSBfaWQgaXMgbm90IGEgbmVnYXRpdmVcbiAgICAvLyBudW1iZXIuXG4gICAgaWYgKGlkSXNOb25aZXJvRmFsc3kgfHwgdGhpcy5faWQgPCAwKSB7XG4gICAgICAvLyBndWFyZCBoZXJlIGluIHRoZSBldmVudCB0aGF0IGlucHV0IGJlY29tZXMgdW5kZWZpbmVkIG9yIG51bGwgYnkgYWNjaWRlbnRcbiAgICAgIHRoaXMuX2lkID0gKHdpemFyZFBhZ2VJbmRleCsrKS50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gYGNsci13aXphcmQtcGFnZS0ke3RoaXMuX2lkfWA7XG4gIH1cblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgc2VydmVzIGFzIGEgY29udmVuaWVuY2UgZm9yIHRob3NlIHdobyB3b3VsZCByYXRoZXJcbiAgICogbm90IHRoaW5rIGluIHRoZSB0ZXJtcyBvZiAhQ2xyV2l6YXJkUGFnZS5uZXh0U3RlcERpc2FibGVkLiBGb3Igc29tZSB1c2UgY2FzZXMsXG4gICAqIENscldpemFyZFBhZ2UucmVhZHlUb0NvbXBsZXRlIGlzIG1vcmUgbG9naWNhbCBhbmQgZGVjbGFyYXRpdmUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHJlYWR5VG9Db21wbGV0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMubmV4dFN0ZXBEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfY29tcGxldGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBwYWdlIGlzIG1hcmtlZCBhcyBjb21wbGV0ZWQgaWYgaXQgaXMgYm90aCByZWFkeVRvQ29tcGxldGUgYW5kIGNvbXBsZXRlZCxcbiAgICogYXMgaW4gdGhlIG5leHQgb3IgZmluaXNoIGFjdGlvbiBoYXMgYmVlbiBleGVjdXRlZCB3aGlsZSB0aGlzIHBhZ2Ugd2FzIGN1cnJlbnQuXG4gICAqXG4gICAqIE5vdGUgdGhlcmUgaXMgYW5kIG9wZW4gcXVlc3Rpb24gYWJvdXQgaG93IHRvIGhhbmRsZSBwYWdlcyB0aGF0IGFyZSBtYXJrZWRcbiAgICogY29tcGxldGUgYnV0IHdobyBhcmUgbm8gbG9uZ2VyIHJlYWR5VG9Db21wbGV0ZS4gVGhpcyBtaWdodCBpbmRpY2F0ZSBhbiBlcnJvclxuICAgKiBzdGF0ZSBmb3IgdGhlIENscldpemFyZFBhZ2UuIEN1cnJlbnRseSwgdGhlIHdpemFyZCBkb2VzIG5vdCBhY2tub3dsZWRnZSB0aGlzIHN0YXRlXG4gICAqIGFuZCBvbmx5IHJldHVybnMgdGhhdCB0aGUgcGFnZSBpcyBpbmNvbXBsZXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjb21wbGV0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlICYmIHRoaXMucmVhZHlUb0NvbXBsZXRlO1xuXG4gICAgLy8gRk9SIFYyOiBVTldJTkQgQ09NUExFVEVELCBSRUFEWVRPQ09NUExFVEUsIEFORCBFUlJPUlNcbiAgICAvLyBTVUNIIFRIQVQgRVJST1JTIElTIElUUyBPV04gSU5QVVQuIElGIEEgU1RFUCBJU1xuICAgIC8vIElOQ09NUExFVEUgQU5EIEVSUk9SRUQsIEVSUk9SRUQgV0lMTCBOT1QgU0hPVy5cbiAgICAvLyBGSVJTVCBRVUVTVElPTjogQU0gSSBHUkVZIE9SIENPTE9SRUQ/XG4gICAgLy8gU0VDT05EIFFVRVNUSU9OOiBBTSBJIEdSRUVOIE9SIFJFRD9cbiAgfVxuXG4gIC8qKlxuICAgKiBBIENscldpemFyZFBhZ2UgY2FuIGJlIG1hbnVhbGx5IHNldCB0byBjb21wbGV0ZWQgdXNpbmcgdGhpcyBib29sZWFuIHNldHRlci5cbiAgICogSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB1c2VycyByZWx5IG9uIHRoZSBjb252ZW5pZW5jZSBmdW5jdGlvbnMgaW4gdGhlIHdpemFyZFxuICAgKiBhbmQgbmF2aWdhdGlvbiBzZXJ2aWNlIGluc3RlYWQgb2YgbWFudWFsbHkgc2V0dGluZyBwYWdlc8OiwoDCmSBjb21wbGV0aW9uIHN0YXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkUGFnZVxuICAgKi9cbiAgcHVibGljIHNldCBjb21wbGV0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jb21wbGV0ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aXRoIHRoZSBuYXZpZ2F0aW9uIHNlcnZpY2UgdG8gc2VlIGlmIGl0IGlzIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZSA9PT0gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmVuYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGFnZSBpcyBuYXZpZ2FibGVcbiAgICogaW4gdGhlIHdpemFyZC4gQSB3aXphcmQgcGFnZSBjYW4gYmUgbmF2aWdhdGVkIHRvIGlmIGl0IGlzIGNvbXBsZXRlZFxuICAgKiBvciB0aGUgcGFnZSBiZWZvcmUgaXQgaXMgY29tcGxldGVkLlxuICAgKlxuICAgKiBUaGlzIGdldHRlciBoYW5kbGVzIHRoZSBsb2dpYyBmb3IgZW5hYmxpbmcgb3IgZGlzYWJsaW5nIHRoZSBsaW5rcyBpblxuICAgKiB0aGUgc3RlcCBuYXYgb24gdGhlIGxlZnQgU2lkZSBvZiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBlbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnQgfHwgdGhpcy5jb21wbGV0ZWQgfHwgdGhpcy5wcmV2aW91c0NvbXBsZXRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwYWdlIGJlZm9yZSB0aGlzXG4gICAqIENscldpemFyZFBhZ2UgaXMgY29tcGxldGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciBvciBub3RcbiAgICogYSBwYWdlIGlzIG5hdmlnYWJsZSBpZiBpdCBpcyBub3QgY3VycmVudCBvciBhbHJlYWR5IGNvbXBsZXRlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgcHJldmlvdXNDb21wbGV0ZWQoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcHJldmlvdXNQYWdlID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5nZXRQcmV2aW91c1BhZ2UodGhpcyk7XG5cbiAgICBpZiAoIXByZXZpb3VzUGFnZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZpb3VzUGFnZS5jb21wbGV0ZWQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgdGl0bGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMucGFnZVRpdGxlLnBhZ2VUaXRsZVRlbXBsYXRlUmVmO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5hdlRpdGxlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIGlmICh0aGlzLnBhZ2VOYXZUaXRsZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFnZU5hdlRpdGxlLnBhZ2VOYXZUaXRsZVRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYWdlVGl0bGUucGFnZVRpdGxlVGVtcGxhdGVSZWY7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaGVhZGVyQWN0aW9ucygpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICBpZiAoIXRoaXMuX2hlYWRlckFjdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlckFjdGlvbnMucGFnZUhlYWRlckFjdGlvbnNUZW1wbGF0ZVJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBoYXNIZWFkZXJBY3Rpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuX2hlYWRlckFjdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgYnV0dG9ucygpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICBpZiAoIXRoaXMuX2J1dHRvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2J1dHRvbnMucGFnZUJ1dHRvbnNUZW1wbGF0ZVJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCByZXR1cm5zIGEgYm9vbGVhbiB0aGF0IHNheXMgd2hldGhlciBvclxuICAgKiBub3QgdGhlIENscldpemFyZFBhZ2UgaW5jbHVkZXMgYnV0dG9ucy4gVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlXG4gICAqIFdpemFyZCBzaG91bGQgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYnV0dG9uIHNldCBkZWZpbmVkIGFzXG4gICAqIGl0cyBkaXJlY3QgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhhc0J1dHRvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5fYnV0dG9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VzIHRoZSBuYXYgc2VydmljZSB0byBtYWtlIHRoZSBDbHJXaXphcmRQYWdlIHRoZSBjdXJyZW50IHBhZ2UgaW4gdGhlXG4gICAqIHdpemFyZC4gQnlwYXNzZXMgYWxsIGNoZWNrcyBidXQgc3RpbGwgZW1pdHMgdGhlIENscldpemFyZFBhZ2Uub25Mb2FkXG4gICAqIChjbHJXaXphcmRQYWdlT25Mb2FkKSBvdXRwdXQuXG4gICAqXG4gICAqIEluIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgdGhlIGRlZmF1bHQgbmF2aWdhdGlvbiBmdW5jdGlvbnNcbiAgICogaW4gV2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIG1ha2VDdXJyZW50KCk6IHZvaWQge1xuICAgIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZSA9IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTGlua3MgdGhlIG5hdiBzZXJ2aWNlIGFuZCBlc3RhYmxpc2hlcyB0aGUgY3VycmVudCBwYWdlIGlmIG9uZSBpcyBub3QgZGVmaW5lZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICBjb25zdCBuYXZTZXJ2aWNlID0gdGhpcy5uYXZTZXJ2aWNlO1xuICAgIGlmICghbmF2U2VydmljZS5jdXJyZW50UGFnZSAmJiAhbmF2U2VydmljZS5uYXZTZXJ2aWNlTG9hZGVkKSB7XG4gICAgICB0aGlzLm1ha2VDdXJyZW50KCk7XG4gICAgICB0aGlzLm5hdlNlcnZpY2UubmF2U2VydmljZUxvYWRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IHJldHVybnMgdGhlIGlkIHVzZWQgYnkgdGhlIHN0ZXAgbmF2IGl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBwYWdlLlxuICAgKlxuICAgKiBDbHJXaXphcmRQYWdlIG5lZWRzIHRoaXMgSUQgc3RyaW5nIGZvciBhcmlhIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBzdGVwSXRlbUlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucGFnZUNvbGxlY3Rpb24uZ2V0U3RlcEl0ZW1JZEZvclBhZ2UodGhpcyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIERvQ2hlY2ssXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIEl0ZXJhYmxlRGlmZmVycyxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYnV0dG9uLWh1Yi5zZXJ2aWNlJztcbmltcG9ydCB7IEhlYWRlckFjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oZWFkZXItYWN0aW9ucy5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VDb2xsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UtY29sbGVjdGlvbi5zZXJ2aWNlJztcbi8vIHByb3ZpZGVyc1xuaW1wb3J0IHsgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENscldpemFyZEhlYWRlckFjdGlvbiB9IGZyb20gJy4vd2l6YXJkLWhlYWRlci1hY3Rpb24nO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UnO1xuXG4vKipcbiAqXG4gKiBUaGUgV2l6YXJkIGNvbXBvbmVudFxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXdpemFyZCcsXG4gIHByb3ZpZGVyczogW1dpemFyZE5hdmlnYXRpb25TZXJ2aWNlLCBQYWdlQ29sbGVjdGlvblNlcnZpY2UsIEJ1dHRvbkh1YlNlcnZpY2UsIEhlYWRlckFjdGlvblNlcnZpY2VdLFxuICB0ZW1wbGF0ZVVybDogJy4vd2l6YXJkLmh0bWwnLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItd2l6YXJkXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLndpemFyZC1tZF0nOiBcInNpemUgPT0gJ21kJ1wiLFxuICAgICdbY2xhc3Mud2l6YXJkLWxnXSc6IFwic2l6ZSA9PSAnbGcnXCIsXG4gICAgJ1tjbGFzcy53aXphcmQteGxdJzogXCJzaXplID09ICd4bCdcIixcbiAgICAnW2NsYXNzLmxhc3RQYWdlXSc6ICduYXZTZXJ2aWNlLmN1cnJlbnRQYWdlSXNMYXN0JyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIEFmdGVyQ29udGVudEluaXQsIERvQ2hlY2sge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBXaXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBuYXZTZXJ2aWNlOiBXaXphcmROYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgcGFnZUNvbGxlY3Rpb246IFBhZ2VDb2xsZWN0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgYnV0dG9uU2VydmljZTogQnV0dG9uSHViU2VydmljZSxcbiAgICBwdWJsaWMgaGVhZGVyQWN0aW9uU2VydmljZTogSGVhZGVyQWN0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzXG4gICkge1xuICAgIHRoaXMuZ29OZXh0U3Vic2NyaXB0aW9uID0gdGhpcy5uYXZTZXJ2aWNlLm1vdmVkVG9OZXh0UGFnZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5vbk1vdmVOZXh0LmVtaXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZ29QcmV2aW91c1N1YnNjcmlwdGlvbiA9IHRoaXMubmF2U2VydmljZS5tb3ZlZFRvUHJldmlvdXNQYWdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZVByZXZpb3VzLmVtaXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2FuY2VsU3Vic2NyaXB0aW9uID0gdGhpcy5uYXZTZXJ2aWNlLm5vdGlmeVdpemFyZENhbmNlbC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENhbmNlbCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy53aXphcmRGaW5pc2hlZFN1YnNjcmlwdGlvbiA9IHRoaXMubmF2U2VydmljZS53aXphcmRGaW5pc2hlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnN0b3BOZXh0KSB7XG4gICAgICAgIHRoaXMuZm9yY2VGaW5pc2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2l6YXJkRmluaXNoZWQuZW1pdCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kaWZmZXIgPSBkaWZmZXJzLmZpbmQoW10pLmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBtYXJraW5nIHdoZW4gdGhlIGNvbGxlY3Rpb24gb2Ygd2l6YXJkIHBhZ2VzIGhhcyBiZWVuIGFkZGVkIHRvIG9yIGRlbGV0ZWQgZnJvbVxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBkaWZmZXI6IGFueTtcblxuICAvKipcbiAgICogQ29udGFpbnMgdGhlIHNpemUgZGVmaW5lZCBieSB0aGUgY2xyV2l6YXJkU2l6ZSBpbnB1dFxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFNpemUnKSBzaXplOiBzdHJpbmcgPSAneGwnO1xuXG4gIC8qKlxuICAgKiBSZXNldHMgcGFnZSBjb21wbGV0ZWQgc3RhdGVzIHdoZW4gbmF2aWdhdGluZyBiYWNrd2FyZHMuIENhbiBiZSBzZXQgdXNpbmdcbiAgICogdGhlIGNscldpemFyZEZvcmNlRm9yd2FyZE5hdmlnYXRpb24gaW5wdXQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkRm9yY2VGb3J3YXJkTmF2aWdhdGlvbicpXG4gIHNldCBmb3JjZUZvcndhcmQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9mb3JjZUZvcndhcmQgPSAhIXZhbHVlO1xuICAgIHRoaXMubmF2U2VydmljZS5mb3JjZUZvcndhcmROYXZpZ2F0aW9uID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfZm9yY2VGb3J3YXJkOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBmb3JjZUZvcndhcmQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlRm9yd2FyZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxscyB0aGUgbW9kYWwgcGFydCBvZiB0aGUgd2l6YXJkIHdoZXRoZXIgaXQgc2hvdWxkIGhhdmUgYSBjbG9zZSBcIlhcIlxuICAgKiBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lci4gU2V0IHdpdGggdGhlIGNscldpemFyZENsb3NhYmxlIGlucHV0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZENsb3NhYmxlJykgY2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUb2dnbGVzIG9wZW4vY2xvc2Ugb2YgdGhlIHdpemFyZCBjb21wb25lbnQuIFNldCB1c2luZyB0aGUgY2xyV2l6YXJkT3BlblxuICAgKiBpbnB1dC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgcHVibGljIF9vcGVuOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgnY2xyV2l6YXJkT3BlbicpXG4gIHNldCBjbHJXaXphcmRPcGVuKG9wZW46IGJvb2xlYW4pIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgdGhpcy5idXR0b25TZXJ2aWNlLmJ1dHRvbnNSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX29wZW4gPSBvcGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyBvcGVuZWQgb3IgY2xvc2VkLiBFbWl0cyB0aHJvdWdoIHRoZVxuICAgKiBjbHJXaXphcmRPcGVuQ2hhbmdlIG91dHB1dC4gV29ya3MgaW4gY29uanVuY3Rpb24gd2l0aCB0aGVcbiAgICogY2xyV2l6YXJkT3BlbiBiaW5kaW5nIHNvIHlvdSBjYW4gdXNlLi4uXG4gICAqXG4gICAqIDxjbHItd2l6YXJkIFsoY2xyV2l6YXJkT3BlbildPVwiYmxhaFwiXG4gICAqIC4uLm9yLi4uXG4gICAqIDxjbHItd2l6YXJkIFtjbHJXaXphcmRPcGVuXT1cInNvbWV0aGluZ1wiIChjbHJXaXphcmRPcGVuQ2hhbmdlKT1cImRvU29tZXRoaWduKCRldmVudClcIj5cbiAgICpcbiAgICogLi4uZm9yIHR3by13YXkgYmluZGluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT3BlbkNoYW5nZScpIF9vcGVuQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyBjYW5jZWxlZC4gQ2FuIGJlIG9ic2VydmVkIHRocm91Z2ggdGhlIGNscldpemFyZE9uQ2FuY2VsXG4gICAqIG91dHB1dC5cbiAgICpcbiAgICogQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGNscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsIGlucHV0IHRvIGNyZWF0ZVxuICAgKiB3aXphcmQtbGV2ZWwgY3VzdG9tIGNhbmNlbCByb3V0aW5lcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25DYW5jZWwnKSBvbkNhbmNlbDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgaXMgY29tcGxldGVkLiBDYW4gYmUgb2JzZXJ2ZWQgdGhyb3VnaCB0aGUgY2xyV2l6YXJkT25GaW5pc2hcbiAgICogb3V0cHV0LlxuICAgKlxuICAgKiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0IGlucHV0IHRvIGNyZWF0ZVxuICAgKiB3aXphcmQtbGV2ZWwgY3VzdG9tIGNvbXBsZXRpb24gcm91dGluZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZE9uRmluaXNoJykgd2l6YXJkRmluaXNoZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIHJlc2V0LiBTZWUgLnJlc2V0KCkuIENhbiBiZSBvYnNlcnZlZCB0aHJvdWdoXG4gICAqIHRoZSBjbHJXaXphcmRPblJlc2V0IG91dHB1dC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25SZXNldCcpIG9uUmVzZXQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogQSBRdWVyeUxpc3Qgb2YgdGhlIHBhZ2VzIGluIHRoZSB3aXphcmQuIE5vdGUgdGhhdCBhIFF1ZXJ5TGlzdCBpcyBzb3J0IG9mXG4gICAqIGxpa2UgYW4gQXJyYXkgYnV0IG5vdCByZWFsbHkuIE5vdGUgYWxzbyB0aGF0IHBhZ2VzIGRvZXMgbm90IGNvbnRhaW5cbiAgICogV2l6YXJkUGFnZXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCB3aXRoIGFuIG5nSWYuXG4gICAqXG4gICAqIE1vc3QgaW50ZXJhY3Rpb25zIHdpdGggYSBDbHJXaXphcmQncyBwYWdlcyBhcmUgbW9yZSBlYXNpbHkgZG9uZSB1c2luZyB0aGVcbiAgICogaGVscGVyIGZ1bmN0aW9uIGluIHRoZSBQYWdlQ29sbGVjdGlvblNlcnZpY2UsIGFjY2Vzc2libGUgZnJvbSB0aGVcbiAgICogQ2xyV2l6YXJkIHRocm91Z2ggQ2xyV2l6YXJkLnBhZ2VDb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkcmVuKENscldpemFyZFBhZ2UpIHB1YmxpYyBwYWdlczogUXVlcnlMaXN0PENscldpemFyZFBhZ2U+O1xuXG4gIC8qKlxuICAgKiBBIFF1ZXJ5TGlzdCBvZiB0aGUgaGVhZGVyIGFjdGlvbnMgZGVmaW5lZCBhdCB0aGUgQ2xyV2l6YXJkIGxldmVsLiBEb2VzIG5vdFxuICAgKiBjb250YWluIGhlYWRlciBhY3Rpb25zIGRlZmluZWQgYXQgdGhlIHBhZ2UgbGV2ZWwuIE1vc3RseSB1c2VkIGJ5IG90aGVyIGZ1bmN0aW9uYWxpdHlcbiAgICogdGhhdCBuZWVkcyB0byBlaXRoZXIga25vdyBpZiB0aGUgQ2xyV2l6YXJkIGhhcyBoZWFkZXIgYWN0aW9ucyBvciBuZWVkcyB0byBzdGFtcCB0aGVtXG4gICAqIHNvbWV3aGVyZS5cbiAgICpcbiAgICogQ291bGQgYmUgdXNlZnVsIGlmIHlvdSBuZWVkZWQgdG8gbG9jYXRlIGFuZCBwcm9ncmFtbWF0aWNhbGx5IGFjdGl2YXRlIGEgc3BlY2lmaWNcbiAgICogaGVhZGVyIGFjdGlvbi4gQnV0IHRoaXMgaXMgcHJvYmFibHkgZWFzaWVyIHRvIGRvIGJ5IGludm9raW5nIHRoZSBoZWFkZXIgYWN0aW9uJ3NcbiAgICogZXZlbnQgaGFuZGxlciBpbiB5b3VyIGhvc3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkcmVuKENscldpemFyZEhlYWRlckFjdGlvbikgcHVibGljIGhlYWRlckFjdGlvbnM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRIZWFkZXJBY3Rpb24+O1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSBjdXJyZW50IHBhZ2UgaGFzIGNoYW5nZWQuIENhbiBiZSBvYnNlcnZlZCB0aHJvdWdoIHRoZSBjbHJXaXphcmRDdXJyZW50UGFnZUNoYW5nZWRcbiAgICogb3V0cHV0LiBUaGlzIGNhbiBoYXBwZW4gb24gLm5leHQoKSBvciAucHJldmlvdXMoKS5cbiAgICogVXNlZnVsIGZvciBub24tYmxvY2tpbmcgdmFsaWRhdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkQ3VycmVudFBhZ2VDaGFuZ2VkJykgY3VycmVudFBhZ2VDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBtb3ZlcyB0byB0aGUgbmV4dCBwYWdlLiBDYW4gYmUgb2JzZXJ2ZWQgdGhyb3VnaCB0aGUgY2xyV2l6YXJkT25OZXh0XG4gICAqIG91dHB1dC5cbiAgICpcbiAgICogQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGNscldpemFyZFByZXZlbnREZWZhdWx0TmV4dCBpbnB1dCB0byBjcmVhdGVcbiAgICogd2l6YXJkLWxldmVsIGN1c3RvbSBuYXZpZ2F0aW9uIHJvdXRpbmVzLCB3aGljaCBhcmUgdXNlZnVsIGZvciB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRPbk5leHQnKSBvbk1vdmVOZXh0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBtb3ZlcyB0byB0aGUgcHJldmlvdXMgcGFnZS4gQ2FuIGJlIG9ic2VydmVkIHRocm91Z2ggdGhlXG4gICAqIGNscldpemFyZE9uUHJldmlvdXMgb3V0cHV0LlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZnVsIGZvciB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRPblByZXZpb3VzJykgb25Nb3ZlUHJldmlvdXM6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogUHJldmVudHMgQ2xyV2l6YXJkIGZyb20gbW92aW5nIHRvIHRoZSBuZXh0IHBhZ2Ugb3IgY2xvc2luZyBpdHNlbGYgb24gZmluaXNoaW5nLlxuICAgKiBTZXQgdXNpbmcgdGhlIGNscldpemFyZFByZXZlbnREZWZhdWx0TmV4dCBpbnB1dC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHVzaW5nIHN0b3BOZXh0IHdpbGwgcmVxdWlyZSB5b3UgdG8gY3JlYXRlIHlvdXIgb3duIGNhbGxzIHRvXG4gICAqIC5uZXh0KCkgYW5kIC5maW5pc2goKSBpbiB5b3VyIGhvc3QgY29tcG9uZW50IHRvIG1ha2UgdGhlIENscldpemFyZCB3b3JrIGFzXG4gICAqIGV4cGVjdGVkLlxuICAgKlxuICAgKiBQcmltYXJpbHkgdXNlZCBmb3IgdmFsaWRhdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQnKVxuICBzZXQgc3RvcE5leHQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9zdG9wTmV4dCA9ICEhdmFsdWU7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLndpemFyZEhhc0FsdE5leHQgPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9zdG9wTmV4dDogYm9vbGVhbiA9IGZhbHNlO1xuICBnZXQgc3RvcE5leHQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BOZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIENscldpemFyZCBmcm9tIGNsb3Npbmcgd2hlbiB0aGUgY2FuY2VsIGJ1dHRvbiBvciBjbG9zZSBcIlhcIiBpcyBjbGlja2VkLlxuICAgKiBTZXQgdXNpbmcgdGhlIGNscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsIGlucHV0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdXNpbmcgc3RvcENhbmNlbCB3aWxsIHJlcXVpcmUgeW91IHRvIGNyZWF0ZSB5b3VyIG93biBjYWxscyB0b1xuICAgKiAuY2xvc2UoKSBpbiB5b3VyIGhvc3QgY29tcG9uZW50IHRvIG1ha2UgdGhlIENscldpemFyZCB3b3JrIGFzIGV4cGVjdGVkLlxuICAgKlxuICAgKiBVc2VmdWwgZm9yIGRvaW5nIGNoZWNrcyBvciBwcm9tcHRzIGJlZm9yZSBjbG9zaW5nIGEgQ2xyV2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsJylcbiAgc2V0IHN0b3BDYW5jZWwodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9zdG9wQ2FuY2VsID0gISF2YWx1ZTtcbiAgICB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkSGFzQWx0Q2FuY2VsID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfc3RvcENhbmNlbDogYm9vbGVhbiA9IGZhbHNlO1xuICBnZXQgc3RvcENhbmNlbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcENhbmNlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBDbHJXaXphcmQgZnJvbSBwZXJmb3JtaW5nIGFueSBmb3JtIG9mIG5hdmlnYXRpb24gYXdheSBmcm9tIHRoZSBjdXJyZW50XG4gICAqIHBhZ2UuIFNldCB1c2luZyB0aGUgY2xyV2l6YXJkUHJldmVudE5hdmlnYXRpb24gaW5wdXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzdG9wTmF2aWdhdGlvbiBpcyBtZWFudCB0byBmcmVlemUgdGhlIHdpemFyZCBpbiBwbGFjZSwgdHlwaWNhbGx5XG4gICAqIGR1cmluZyBhIGxvbmcgdmFsaWRhdGlvbiBvciBiYWNrZ3JvdW5kIGFjdGlvbiB3aGVyZSB5b3Ugd2FudCB0aGUgd2l6YXJkIHRvXG4gICAqIGRpc3BsYXkgbG9hZGluZyBjb250ZW50IGJ1dCBub3QgYWxsb3cgdGhlIHVzZXIgdG8gZXhlY3V0ZSBuYXZpZ2F0aW9uIGluXG4gICAqIHRoZSBzdGVwbmF2LCBjbG9zZSBYLCBvciB0aGUgIGJhY2ssIGZpbmlzaCwgb3IgbmV4dCBidXR0b25zLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFByZXZlbnROYXZpZ2F0aW9uJylcbiAgc2V0IHN0b3BOYXZpZ2F0aW9uKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc3RvcE5hdmlnYXRpb24gPSAhIXZhbHVlO1xuICAgIHRoaXMubmF2U2VydmljZS53aXphcmRTdG9wTmF2aWdhdGlvbiA9IHZhbHVlO1xuICB9XG4gIHByaXZhdGUgX3N0b3BOYXZpZ2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBzdG9wTmF2aWdhdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcE5hdmlnYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgY2xpY2tzIG9uIHRoZSBsaW5rcyBpbiB0aGUgc3RlcG5hdiBmcm9tIHdvcmtpbmcuXG4gICAqXG4gICAqIEEgbW9yZSBncmFudWxhciBieXBhc3Npbmcgb2YgbmF2aWdhdGlvbiB3aGljaCBjYW4gYmUgdXNlZnVsIHdoZW4geW91clxuICAgKiBDbHJXaXphcmQgaXMgaW4gYSBzdGF0ZSBvZiBjb21wbGV0aW9uIGFuZCB5b3UgZG9uJ3Qgd2FudCB1c2VycyB0byBiZVxuICAgKiBhYmxlIHRvIGp1bXAgYmFja3dhcmRzIGFuZCBjaGFuZ2UgdGhpbmdzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZERpc2FibGVTdGVwbmF2JylcbiAgc2V0IGRpc2FibGVTdGVwbmF2KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZGlzYWJsZVN0ZXBuYXYgPSAhIXZhbHVlO1xuICAgIHRoaXMubmF2U2VydmljZS53aXphcmREaXNhYmxlU3RlcG5hdiA9IHZhbHVlO1xuICB9XG4gIHByaXZhdGUgX2Rpc2FibGVTdGVwbmF2OiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBkaXNhYmxlU3RlcG5hdigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZVN0ZXBuYXY7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBvbmx5IHRvIGNvbW11bmljYXRlIHRvIHRoZSB1bmRlcmx5aW5nIG1vZGFsIHRoYXQgYW5pbWF0aW9ucyBhcmUgbm90XG4gICAqIHdhbnRlZC4gUHJpbWFyeSB1c2UgaXMgZm9yIHRoZSBkaXNwbGF5IG9mIHN0YXRpYy9pbmxpbmUgd2l6YXJkcy5cbiAgICpcbiAgICogU2V0IHVzaW5nIGNscldpemFyZFByZXZlbnRNb2RhbEFuaW1hdGlvbiBpbnB1dC4gQnV0IHlvdSBzaG91bGQgbmV2ZXIgc2V0IGl0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFByZXZlbnRNb2RhbEFuaW1hdGlvbicpIF9zdG9wTW9kYWxBbmltYXRpb25zOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgc3RvcE1vZGFsQW5pbWF0aW9ucygpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLl9zdG9wTW9kYWxBbmltYXRpb25zKSB7XG4gICAgICByZXR1cm4gJ3RydWUnO1xuICAgIH1cbiAgICByZXR1cm4gJ2ZhbHNlJztcbiAgfVxuXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlU3Vic2NyaXB0aW9uID0gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlQ2hhbmdlZC5zdWJzY3JpYmUoKHBhZ2U6IENscldpemFyZFBhZ2UpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudFBhZ2VDaGFuZ2VkLmVtaXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ29OZXh0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgZ29QcmV2aW91c1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGNhbmNlbFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGN1cnJlbnRQYWdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgd2l6YXJkRmluaXNoZWRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5nb05leHRTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuZ29OZXh0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdvUHJldmlvdXNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuZ29QcmV2aW91c1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jYW5jZWxTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY2FuY2VsU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndpemFyZEZpbmlzaGVkU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLndpemFyZEZpbmlzaGVkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgcmVmZXJlbmNlcyB0aGF0IGFyZSBuZWVkZWQgYnkgdGhlIHByb3ZpZGVycy5cbiAgICpcbiAgICogQG5hbWUgbmdBZnRlckNvbnRlbnRJbml0XG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5wYWdlcyA9IHRoaXMucGFnZXM7XG4gICAgdGhpcy5oZWFkZXJBY3Rpb25TZXJ2aWNlLndpemFyZEhlYWRlckFjdGlvbnMgPSB0aGlzLmhlYWRlckFjdGlvbnM7XG5cbiAgICAvLyBPbmx5IHRyaWdnZXIgYnV0dG9ucyByZWFkeSBpZiBkZWZhdWx0IGlzIG9wZW4gKGlubGluZWQpXG4gICAgaWYgKHRoaXMuX29wZW4pIHtcbiAgICAgIHRoaXMuYnV0dG9uU2VydmljZS5idXR0b25zUmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIHdoZW4gcGFnZXMgYXJlIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGlzLnBhZ2VzXG4gICAqXG4gICAqIEBuYW1lIG5nRG9DaGVja1xuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBwdWJsaWMgbmdEb0NoZWNrKCkge1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmRpZmZlci5kaWZmKHRoaXMucGFnZXMpO1xuICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oKHI6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLm5hdlNlcnZpY2UudXBkYXRlTmF2aWdhdGlvbigpO1xuICAgICAgfSk7XG4gICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbSgocjogYW55KSA9PiB7XG4gICAgICAgIHRoaXMubmF2U2VydmljZS51cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVudCBwcm9wZXJ0eSBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHdpemFyZCBpcyBzdGF0aWMvaW4tbGluZSBvciBub3QuXG4gICAqXG4gICAqIEBuYW1lIGlzU3RhdGljXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaXNTdGF0aWMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnY2xyLXdpemFyZC0taW5saW5lJyk7XG4gIH1cblxuICAvKipcbiAgICogQXMgYSBnZXR0ZXIsIGN1cnJlbnQgcGFnZSBpcyBhIGNvbnZlbmllbnQgd2F5IHRvIHJldHJpZXZlIHRoZSBjdXJyZW50IHBhZ2UgZnJvbVxuICAgKiB0aGUgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UuXG4gICAqXG4gICAqIEFzIGEgc2V0dGVyLCBjdXJyZW50IHBhZ2UgYWNjZXB0cyBhIENscldpemFyZFBhZ2UgYW5kIHBhc3NlcyBpdCB0byBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKiB0byBiZSBtYWRlIHRoZSBjdXJyZW50IHBhZ2UuIGN1cnJlbnRQYWdlIHBlcmZvcm1zIGNoZWNrcyB0byBtYWtlIHN1cmUgaXQgY2FuIG5hdmlnYXRlXG4gICAqIHRvIHRoZSBkZXNpZ25hdGVkIHBhZ2UuXG4gICAqXG4gICAqIEBuYW1lIGN1cnJlbnRQYWdlXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudFBhZ2UoKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZTtcbiAgfVxuICBwdWJsaWMgc2V0IGN1cnJlbnRQYWdlKHBhZ2U6IENscldpemFyZFBhZ2UpIHtcbiAgICB0aGlzLm5hdlNlcnZpY2UuZ29UbyhwYWdlLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW50IHByb3BlcnR5IGZvciBkZXRlcm1pbmluZyBpZiB0aGUgY3VycmVudCBwYWdlIGlzIHRoZSBsYXN0IHBhZ2Ugb2ZcbiAgICogdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG5hbWUgaXNMYXN0XG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaXNMYXN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2VJc0xhc3Q7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVudCBwcm9wZXJ0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgdGhlIGN1cnJlbnQgcGFnZSBpcyB0aGUgZmlyc3QgcGFnZSBvZlxuICAgKiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbmFtZSBpc0ZpcnN0XG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaXNGaXJzdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlSXNGaXJzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyB0aGUgYWN0aW9ucyBuZWVkZWQgdG8gb3BlbiB0aGUgd2l6YXJkLiBJZiB0aGVyZSBpcyBubyBjdXJyZW50XG4gICAqIHBhZ2UgZGVmaW5lZCwgc2V0cyB0aGUgZmlyc3QgcGFnZSBpbiB0aGUgd2l6YXJkIHRvIGJlIGN1cnJlbnQuXG4gICAqXG4gICAqIEBuYW1lIG9wZW5cbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5fb3BlbiA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuY3VycmVudFBhZ2UpIHtcbiAgICAgIHRoaXMubmF2U2VydmljZS5zZXRGaXJzdFBhZ2VDdXJyZW50KCk7XG4gICAgfVxuXG4gICAgLy8gT25seSByZW5kZXIgYnV0dG9ucyB3aGVuIHdpemFyZCBpcyBvcGVuZWQsIHRvIGF2b2lkIGNob2NvbGF0ZSBlcnJvcnNcbiAgICB0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuX29wZW5DaGFuZ2VkLmVtaXQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogRG9lcyB0aGUgd29yayBpbnZvbHZlZCB3aXRoIGNsb3NpbmcgdGhlIHdpemFyZC4gQ2FsbCB0aGlzIGRpcmVjdGx5IGluc3RlYWRcbiAgICogb2YgY2FuY2VsKCkgdG8gaW1wbGVtZW50IGFsdGVybmF0aXZlIGNhbmNlbCBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbmFtZSBjbG9zZVxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgdGhpcy5fb3BlbkNoYW5nZWQuZW1pdChmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVudCBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIG9wZW4gYW5kIGNsb3NlIHRoZSB3aXphcmQuIEl0IG9wZXJhdGVzXG4gICAqIGJ5IGNoZWNraW5nIGEgQm9vbGVhbiBwYXJhbWV0ZXIuIElmIHRydWUsIHRoZSB3aXphcmQgaXMgb3BlbmVkLiBJZiBmYWxzZSxcbiAgICogaXQgaXMgY2xvc2VkLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBkZWZhdWx0IHZhbHVlIGZvciB0aGlzIHBhcmFtZXRlciwgc28gYnkgZGVmYXVsdCB0aGUgd2l6YXJkIHdpbGxcbiAgICogY2xvc2UgaWYgaW52b2tlZCB3aXRoIG5vIHBhcmFtZXRlci5cbiAgICpcbiAgICogQG5hbWUgdG9nZ2xlXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyB0b2dnbGUodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSB3aXphcmQgdG8gdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAqXG4gICAqIEBuYW1lIHByZXZpb3VzXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBwcmV2aW91cygpOiB2b2lkIHtcbiAgICB0aGlzLm5hdlNlcnZpY2UucHJldmlvdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNsdWRlcyBhIEJvb2xlYW4gcGFyYW1ldGVyIHRoYXQgd2lsbCBza2lwIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zLlxuICAgKiBJZiB0cnVlLCB0aGUgd2l6YXJkIHdpbGwgbW92ZSB0byB0aGUgbmV4dCBwYWdlIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mXG4gICAqIGl0cyBjdXJyZW50IHBhZ2UuIFRoaXMgaXMgdXNlZnVsIGZvciBhbHRlcm5hdGl2ZSBuYXZpZ2F0aW9uIHdoZXJlIGV2ZW50XG4gICAqIGVtaXNzaW9ucyBoYXZlIGFscmVhZHkgYmVlbiBkb25lIGFuZCBmaXJpbmcgdGhlbSBhZ2FpbiBtYXkgY2F1c2UgYW4gZXZlbnQgbG9vcC5cbiAgICpcbiAgICogR2VuZXJhbGx5LCB3aXRoIGFsdGVybmF0aXZlIG5hdmlnYXRpb24sIHVzZXJzIGFyZSBzdXBwbHlpbmcgdGhlaXIgb3duIGNoZWNrc1xuICAgKiBhbmQgdmFsaWRhdGlvbi4gU28gdGhlcmUgaXMgbm8gcG9pbnQgaW4gc3VwZXJzZWRpbmcgdGhlaXIgYnVzaW5lc3MgbG9naWNcbiAgICogd2l0aCBvdXIgZGVmYXVsdCBiZWhhdmlvci5cbiAgICpcbiAgICogSWYgZmFsc2UsIHRoZSB3aXphcmQgd2lsbCBleGVjdXRlIGRlZmF1bHQgY2hlY2tzIGFuZCBlbWl0IGV2ZW50cyBhcyBub3JtYWwuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGZvciBjdXN0b20gYnV0dG9ucyBvciBwcm9ncmFtbWF0aWMgd29ya2Zsb3dzIHRoYXQgYXJlIG5vdFxuICAgKiBleGVjdXRpbmcgdGhlIHdpemFyZHMgZGVmYXVsdCBjaGVja3MgYW5kIGVtaXNzaW9ucy4gSXQgaXMgYW5vdGhlciB3YXkgdG9cbiAgICogbmF2aWdhdGUgd2l0aG91dCBoYXZpbmcgdG8gcmV3cml0ZSB0aGUgd2l6YXJkw6LCgMKZcyBkZWZhdWx0IGZ1bmN0aW9uYWxpdHlcbiAgICogZnJvbSBzY3JhdGNoLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBuZXh0KCkgZG9lcyBub3QgZXhlY3V0ZSBldmVudCBlbWlzc2lvbnMgb3IgY2hlY2tzIGJlY2F1c2UgdGhlXG4gICAqIDgwJSBjYXNlIGlzIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXMgcGFydCBvZiBhbiBhbHRlcm5hdGl2ZVxuICAgKiBuYXZpZ2F0aW9uIHdpdGggY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0LlxuICAgKlxuICAgKiBAbmFtZSBuZXh0XG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBuZXh0KHNraXBDaGVja3NBbmRFbWl0czogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICBpZiAoc2tpcENoZWNrc0FuZEVtaXRzKSB7XG4gICAgICB0aGlzLmZvcmNlTmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5hdlNlcnZpY2UubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNsdWRlcyBhIEJvb2xlYW4gcGFyYW1ldGVyIHRoYXQgd2lsbCBza2lwIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zLlxuICAgKiBJZiB0cnVlLCB0aGUgd2l6YXJkIHdpbGwgIGNvbXBsZXRlIGFuZCBjbG9zZSByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZSBvZlxuICAgKiBpdHMgY3VycmVudCBwYWdlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYWx0ZXJuYXRpdmUgbmF2aWdhdGlvbiB3aGVyZSBldmVudFxuICAgKiBlbWlzc2lvbnMgaGF2ZSBhbHJlYWR5IGJlZW4gZG9uZSBhbmQgZmlyaW5nIHRoZW0gYWdhaW4gbWF5IGNhdXNlIGFuIGV2ZW50IGxvb3AuXG4gICAqXG4gICAqIElmIGZhbHNlLCB0aGUgd2l6YXJkIHdpbGwgZXhlY3V0ZSBkZWZhdWx0IGNoZWNrcyBhbmQgZW1pdCBldmVudHMgYmVmb3JlXG4gICAqIGNvbXBsZXRpbmcgYW5kIGNsb3NpbmcuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGZpbmlzaCgpIGRvZXMgbm90IGV4ZWN1dGUgZXZlbnQgZW1pc3Npb25zIG9yIGNoZWNrcyBiZWNhdXNlIHRoZVxuICAgKiA4MCUgY2FzZSBpcyB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFzIHBhcnQgb2YgYW4gYWx0ZXJuYXRpdmVcbiAgICogbmF2aWdhdGlvbiB3aXRoIGNscldpemFyZFByZXZlbnREZWZhdWx0TmV4dC5cbiAgICpcbiAgICogQG5hbWUgZmluaXNoXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBmaW5pc2goc2tpcENoZWNrc0FuZEVtaXRzOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIGlmIChza2lwQ2hlY2tzQW5kRW1pdHMpIHtcbiAgICAgIHRoaXMuZm9yY2VGaW5pc2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYXZTZXJ2aWNlLmZpbmlzaCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIHRoZSB3b3JrIG9mIGZpbmlzaGluZyB1cCB0aGUgd2l6YXJkIGFuZCBjbG9zaW5nIGl0IGJ1dCBkb2Vzbid0IGRvIHRoZVxuICAgKiBjaGVja3MgYW5kIGVtaXNzaW9ucyB0aGF0IG90aGVyIHBhdGhzIGRvLiBHb29kIGZvciBhIGxhc3Qgc3RlcCBpbiBhblxuICAgKiBhbHRlcm5hdGUgd29ya2Zsb3cuXG4gICAqXG4gICAqIERvZXMgdGhlIHNhbWUgdGhpbmcgYXMgY2FsbGluZyBDbHJXaXphcmQuZmluaXNoKHRydWUpIG9yIENscldpemFyZC5maW5pc2goKVxuICAgKiB3aXRob3V0IGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAbmFtZSBmb3JjZUZpbmlzaFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgZm9yY2VGaW5pc2goKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogRG9lcyB0aGUgd29yayBvZiBtb3ZpbmcgdGhlIHdpemFyZCB0byB0aGUgbmV4dCBwYWdlIHdpdGhvdXQgdGhlXG4gICAqIGNoZWNrcyBhbmQgZW1pc3Npb25zIHRoYXQgb3RoZXIgcGF0aHMgZG8uIEdvb2QgZm9yIGEgbGFzdCBzdGVwIGluIGFuXG4gICAqIGFsdGVybmF0ZSB3b3JrZmxvdy5cbiAgICpcbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBjYWxsaW5nIENscldpemFyZC5uZXh0KHRydWUpIG9yIENscldpemFyZC5uZXh0KClcbiAgICogd2l0aG91dCBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogQG5hbWUgZm9yY2VOZXh0XG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBmb3JjZU5leHQoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLmZvcmNlTmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbmNlbHMgYW5kIGNsb3NlcyB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBEbyBub3QgdXNlIHRoaXMgZm9yIGFuIG92ZXJyaWRlIG9mIHRoZSBjYW5jZWwgdGhlIGZ1bmN0aW9uYWxpdHlcbiAgICogd2l0aCBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbCwgY2xyV2l6YXJkUHJldmVudFBhZ2VEZWZhdWx0Q2FuY2VsLFxuICAgKiBvciBjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHQgYmVjYXVzZSBpdCB3aWxsIGluaXRpYXRlIHRoZSBzYW1lIGNoZWNrc1xuICAgKiBhbmQgZXZlbnQgZW1pc3Npb25zIHRoYXQgaW52b2tlZCB5b3VyIGV2ZW50IGhhbmRsZXIuXG4gICAqXG4gICAqIFVzZSBDbHJXaXphcmQuY2xvc2UoKSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAbmFtZSBjYW5jZWxcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIGNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLm5hdlNlcnZpY2UuY2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGJlaGF2aW9yIG9mIHRoZSB1bmRlcmx5aW5nIG1vZGFsIHRvIGF2b2lkIGNvbGxpc2lvbnMgd2l0aFxuICAgKiBhbHRlcm5hdGl2ZSBjYW5jZWwgZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogSW4gbW9zdCBjYXNlcywgdXNlIENscldpemFyZC5jYW5jZWwoKSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAbmFtZSBtb2RhbENhbmNlbFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgbW9kYWxDYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0FuZENhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgYWx0ZXJuYXRpdmUgY2FuY2VsIGZsb3dzIGRlZmluZWQgYXQgdGhlIGN1cnJlbnQgcGFnZSBvclxuICAgKiB3aXphcmQgbGV2ZWwuIFBlcmZvcm1zIGEgY2FuY2VsZWQgaWYgbm90LiBFbWl0cyBldmVudHMgdGhhdCBpbml0aWF0ZVxuICAgKiB0aGUgYWx0ZXJuYXRpdmUgY2FuY2VsIG91dHB1dHMgKGNscldpemFyZFBhZ2VPbkNhbmNlbCBhbmRcbiAgICogY2xyV2l6YXJkT25DYW5jZWwpIGlmIHNvLlxuICAgKlxuICAgKiBAbmFtZSBjaGVja0FuZENhbmNlbFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgY2hlY2tBbmRDYW5jZWwoKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlO1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlSGFzT3ZlcnJpZGVzID0gY3VycmVudFBhZ2Uuc3RvcENhbmNlbCB8fCBjdXJyZW50UGFnZS5wcmV2ZW50RGVmYXVsdDtcblxuICAgIGlmICh0aGlzLnN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudFBhZ2UucGFnZU9uQ2FuY2VsLmVtaXQoKTtcbiAgICBpZiAoIWN1cnJlbnRQYWdlSGFzT3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzLm9uQ2FuY2VsLmVtaXQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RvcENhbmNlbCAmJiAhY3VycmVudFBhZ2VIYXNPdmVycmlkZXMpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyB0aGUgd2l6YXJkIElEIGFzIGEgc3RyaW5nIHBhcmFtZXRlciBhbmQgY2FsbHMgdG8gV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICogdG8gbmF2aWdhdGUgdG8gdGhlIHBhZ2Ugd2l0aCB0aGF0IElELiBOYXZpZ2F0aW9uIHdpbGwgaW52b2tlIHRoZSB3aXphcmTDosKAwplzIGRlZmF1bHRcbiAgICogY2hlY2tzIGFuZCBldmVudCBlbWlzc2lvbnMuXG4gICAqXG4gICAqIFByb2JhYmx5IGxlc3MgdXNlZnVsIHRoYW4gY2FsbGluZyBkaXJlY3RseSB0byBDbHJXaXphcmQubmF2U2VydmljZS5nb1RvKCkgYmVjYXVzZSB0aGVcbiAgICogbmF2IHNlcnZpY2UgbWV0aG9kIGNhbiBhY2NlcHQgZWl0aGVyIGEgc3RyaW5nIElEIG9yIGEgcGFnZSBvYmplY3QuXG4gICAqXG4gICAqIFRoZSBmb3JtYXQgb2YgdGhlIGV4cGVjdGVkIElEIHBhcmFtZXRlciBjYW4gYmUgZm91bmQgaW4gdGhlIHJldHVybiBvZiB0aGVcbiAgICogQ2xyV2l6YXJkUGFnZS5pZCBnZXR0ZXIsIHVzdWFsbHkgcHJlZml4ZWQgd2l0aCDDosKAwpxjbHItd2l6YXJkLXBhZ2Utw6LCgMKcIGFuZCB0aGVuIGVpdGhlciBhXG4gICAqIG51bWVyaWMgSUQgb3IgdGhlIElEIHNwZWNpZmllZCBmb3IgdGhlIENscldpemFyZFBhZ2UgY29tcG9uZW50w6LCgMKZcyDDosKAwpxpZMOiwoDCnSBpbnB1dC5cbiAgICpcbiAgICogQG5hbWUgZ29Ub1xuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgZ29UbyhwYWdlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICghcGFnZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5uYXZTZXJ2aWNlLmdvVG8ocGFnZUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdG8gUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLnJlc2V0KCkgYW5kIGVtaXRzIHRoZVxuICAgKiBDbHJXaXphcmQub25SZXNldCBldmVudC5cbiAgICpcbiAgICogUmVzZXQgc2V0cyBhbGwgV2l6YXJkUGFnZXMgdG8gaW5jb21wbGV0ZSBhbmQgc2V0cyB0aGUgZmlyc3QgcGFnZSBpbiB0aGUgQ2xyV2l6YXJkIHRvXG4gICAqIGJlIHRoZSBjdXJyZW50IHBhZ2UsIGVzc2VudGlhbGx5IHJlc2V0dGluZyB0aGUgd2l6YXJkIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIFVzZXJzIHdvdWxkIHRoZW4gdXNlIHRoZSBvblJlc2V0IGV2ZW50IHRvIHJlc2V0IHRoZSBkYXRhIG9yIG1vZGVsIGluIHRoZWlyXG4gICAqIGhvc3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBJdCBjb3VsZCBiZSB1c2VmdWwgdG8gY2FsbCBhIHJlc2V0IHdpdGhvdXQgZmlyaW5nIHRoZSBvblJlc2V0IGV2ZW50LiBUbyBkbyB0aGlzLFxuICAgKiBqdXN0IGNhbGwgQ2xyV2l6YXJkLnBhZ2VDb2xsZWN0aW9uLnJlc2V0KCkgZGlyZWN0bHkuXG4gICAqXG4gICAqIEBuYW1lIHJlc2V0XG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICB0aGlzLnBhZ2VDb2xsZWN0aW9uLnJlc2V0KCk7XG4gICAgdGhpcy5vblJlc2V0Lm5leHQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYnV0dG9uLWh1Yi5zZXJ2aWNlJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0JVVFRPTl9UWVBFUzogYW55ID0ge1xuICBjYW5jZWw6ICdjYW5jZWwnLFxuICBwcmV2aW91czogJ3ByZXZpb3VzJyxcbiAgbmV4dDogJ25leHQnLFxuICBmaW5pc2g6ICdmaW5pc2gnLFxuICBkYW5nZXI6ICdkYW5nZXInLFxufTtcblxuZXhwb3J0IGNvbnN0IENVU1RPTV9CVVRUT05fVFlQRVM6IGFueSA9IHtcbiAgY2FuY2VsOiAnY3VzdG9tLWNhbmNlbCcsXG4gIHByZXZpb3VzOiAnY3VzdG9tLXByZXZpb3VzJyxcbiAgbmV4dDogJ2N1c3RvbS1uZXh0JyxcbiAgZmluaXNoOiAnY3VzdG9tLWZpbmlzaCcsXG4gIGRhbmdlcjogJ2N1c3RvbS1kYW5nZXInLFxufTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXdpemFyZC1idXR0b24nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiYnRuIGNsci13aXphcmQtYnRuXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tbGlua109XCJpc0NhbmNlbFwiXG4gICAgICAgICAgICBbY2xhc3MuY2xyLXdpemFyZC1idG4tLXRlcnRpYXJ5XT1cImlzQ2FuY2VsXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tb3V0bGluZV09XCJpc1ByZXZpb3VzXCJcbiAgICAgICAgICAgIFtjbGFzcy5jbHItd2l6YXJkLWJ0bi0tc2Vjb25kYXJ5XT1cImlzUHJldmlvdXNcIlxuICAgICAgICAgICAgW2NsYXNzLmJ0bi1wcmltYXJ5XT1cImlzUHJpbWFyeUFjdGlvblwiXG4gICAgICAgICAgICBbY2xhc3MuY2xyLXdpemFyZC1idG4tLXByaW1hcnldPVwiaXNQcmltYXJ5QWN0aW9uXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tc3VjY2Vzc109XCJpc0ZpbmlzaFwiXG4gICAgICAgICAgICBbY2xhc3MuYnRuLWRhbmdlcl09XCJpc0RhbmdlclwiXG4gICAgICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwiaXNEaXNhYmxlZFwiXG4gICAgICAgICAgICBbYXR0ci5kaXNhYmxlZF09XCJfZGlzYWJsZWRBdHRyaWJ1dGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cImNsaWNrKClcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgaG9zdDogeyBjbGFzczogJ2Nsci13aXphcmQtYnRuLXdyYXBwZXInLCAnW2F0dHIuYXJpYS1oaWRkZW5dJzogJ2lzSGlkZGVuJyB9LFxuICBzdHlsZXM6IFsnW2FyaWEtaGlkZGVuPVwidHJ1ZVwiXSB7IGRpc3BsYXk6IG5vbmU7IH0nXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkQnV0dG9uIHtcbiAgQElucHV0KCd0eXBlJykgcHVibGljIHR5cGU6IHN0cmluZyA9ICcnO1xuXG4gIEBJbnB1dCgnY2xyV2l6YXJkQnV0dG9uRGlzYWJsZWQnKSBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASW5wdXQoJ2NscldpemFyZEJ1dHRvbkhpZGRlbicpIHB1YmxpYyBoaWRkZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBFdmVudEVtaXR0ZXIgd2hpY2ggaXMgZW1pdHRlZCB3aGVuIGEgYnV0dG9uIGlzIGNsaWNrZWQuXG4gIEBPdXRwdXQoJ2NscldpemFyZEJ1dHRvbkNsaWNrZWQnKSB3YXNDbGlja2VkOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLCBwdWJsaWMgYnV0dG9uU2VydmljZTogQnV0dG9uSHViU2VydmljZSkge31cblxuICBwcml2YXRlIGNoZWNrRGVmYXVsdEFuZEN1c3RvbVR5cGUodmFsdWVUb0NoZWNrOiBzdHJpbmcgPSAnJywgdHlwZVRvTG9va1VwOiBzdHJpbmcpIHtcbiAgICBpZiAoREVGQVVMVF9CVVRUT05fVFlQRVNbdHlwZVRvTG9va1VwXSA9PT0gdmFsdWVUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKENVU1RPTV9CVVRUT05fVFlQRVNbdHlwZVRvTG9va1VwXSA9PT0gdmFsdWVUb0NoZWNrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0NhbmNlbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ2NhbmNlbCcpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc05leHQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh0aGlzLnR5cGUsICduZXh0Jyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzUHJldmlvdXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh0aGlzLnR5cGUsICdwcmV2aW91cycpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0ZpbmlzaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ2ZpbmlzaCcpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0RhbmdlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ2RhbmdlcicpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc1ByaW1hcnlBY3Rpb24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaXNOZXh0IHx8IHRoaXMuaXNEYW5nZXIgfHwgdGhpcy5pc0ZpbmlzaDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgX2Rpc2FibGVkQXR0cmlidXRlKCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgLy8gZGVhbGluZyB3aXRoIG5lZ2F0aXZlcyBoZXJlLiBjb2duaXRpdmVseSBlYXNpZXIgdG8gdGhpbmsgb2YgaXQgbGlrZSB0aGlzLi4uXG4gICAgY29uc3QgZGlzYWJsZWQgPSB0cnVlO1xuICAgIGNvbnN0IG5hdiA9IHRoaXMubmF2U2VydmljZTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlO1xuXG4gICAgLy8gRW5zdXJlIHdlIGRvbid0IGNoYW5nZSB0aGUgcmVzcG9uc2UgdW50aWwgYnV0dG9ucyBhcmUgcmVhZHkgdG8gYXZvaWQgY2hvY29sYXRlXG4gICAgaWYgKCF0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5KSB7XG4gICAgICByZXR1cm4gIWRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IG5hdi53aXphcmRTdG9wTmF2aWdhdGlvbiB8fCAhcGFnZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDYW5jZWwpIHtcbiAgICAgIHJldHVybiAhZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQcmV2aW91cyAmJiAobmF2LmN1cnJlbnRQYWdlSXNGaXJzdCB8fCBwYWdlLnByZXZpb3VzU3RlcERpc2FibGVkKSkge1xuICAgICAgcmV0dXJuIGRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRGFuZ2VyICYmICFwYWdlLnJlYWR5VG9Db21wbGV0ZSkge1xuICAgICAgcmV0dXJuIGRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTmV4dCAmJiAobmF2LmN1cnJlbnRQYWdlSXNMYXN0IHx8ICFwYWdlLnJlYWR5VG9Db21wbGV0ZSkpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0ZpbmlzaCAmJiAoIW5hdi5jdXJyZW50UGFnZUlzTGFzdCB8fCAhcGFnZS5yZWFkeVRvQ29tcGxldGUpKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICFkaXNhYmxlZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNIaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgLy8gZGVhbGluZyB3aXRoIG5lZ2F0aXZlcyBoZXJlLiBjb2duaXRpdmVseSBlYXNpZXIgdG8gdGhpbmsgb2YgaXQgbGlrZSB0aGlzLi4uXG4gICAgY29uc3QgaGlkZGVuID0gdHJ1ZTtcbiAgICBjb25zdCBuYXYgPSB0aGlzLm5hdlNlcnZpY2U7XG5cbiAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgY2hhbmdlIHRoZSByZXNwb25zZSB1bnRpbCBidXR0b25zIGFyZSByZWFkeSB0byBhdm9pZCBjaG9jb2xhdGVcbiAgICBpZiAoIXRoaXMuYnV0dG9uU2VydmljZS5idXR0b25zUmVhZHkpIHtcbiAgICAgIHJldHVybiAhaGlkZGVuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhpZGRlbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDYW5jZWwpIHtcbiAgICAgIHJldHVybiAhaGlkZGVuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUHJldmlvdXMgJiYgbmF2LmN1cnJlbnRQYWdlSXNGaXJzdCkge1xuICAgICAgcmV0dXJuIGhpZGRlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc05leHQgJiYgbmF2LmN1cnJlbnRQYWdlSXNMYXN0KSB7XG4gICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRmluaXNoICYmICFuYXYuY3VycmVudFBhZ2VJc0xhc3QpIHtcbiAgICAgIHJldHVybiBoaWRkZW47XG4gICAgfVxuXG4gICAgcmV0dXJuICFoaWRkZW47XG4gIH1cblxuICBjbGljaygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy53YXNDbGlja2VkLmVtaXQodGhpcy50eXBlKTtcbiAgICB0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uQ2xpY2tlZCh0aGlzLnR5cGUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItd2l6YXJkLXRpdGxlLCBjbHItd2l6YXJkLXBhZ2V0aXRsZScgfSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRDdXN0b21UYWdzIHtcbiAgLy8gTm8gYmVoYXZpb3JcbiAgLy8gVGhlIG9ubHkgcHVycG9zZSBpcyB0byBcImRlY2xhcmVcIiB0aGUgdGFnIGluIEFuZ3VsYXJcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQtc3RlcG5hdicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxvbCBjbGFzcz1cImNsci13aXphcmQtc3RlcG5hdi1saXN0XCIgcm9sZT1cInRhYmxpc3RcIj5cbiAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgcGFnZSBvZiBwYWdlU2VydmljZS5wYWdlc1wiIGNsci13aXphcmQtc3RlcG5hdi1pdGVtIFxuICAgICAgICAgICAgW3BhZ2VdPVwicGFnZVwiIGNsYXNzPVwiY2xyLXdpemFyZC1zdGVwbmF2LWl0ZW1cIj48L2xpPlxuICAgICAgICA8L29sPlxuICAgIGAsXG4gIGhvc3Q6IHsgY2xhc3M6ICdjbHItd2l6YXJkLXN0ZXBuYXYnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFN0ZXBuYXYge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZVNlcnZpY2U6IFBhZ2VDb2xsZWN0aW9uU2VydmljZSkge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdbY2xyLXdpemFyZC1zdGVwbmF2LWl0ZW1dJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWxpbmsgY2xyLXdpemFyZC1zdGVwbmF2LWxpbmtcIiAoY2xpY2spPVwiY2xpY2soKVwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInBhZ2UubmF2VGl0bGVcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAnaWQnLFxuICAgICdbYXR0ci5hcmlhLXNlbGVjdGVkXSc6ICdpc0N1cnJlbnQnLFxuICAgICdbYXR0ci5hcmlhLWNvbnRyb2xzXSc6ICdpZCcsXG4gICAgcm9sZTogJ3RhYicsXG4gICAgJ1tjbGFzcy5jbHItbmF2LWxpbmtdJzogJ3RydWUnLFxuICAgICdbY2xhc3MubmF2LWl0ZW1dJzogJ3RydWUnLFxuICAgICdbY2xhc3MuYWN0aXZlXSc6ICdpc0N1cnJlbnQnLFxuICAgICdbY2xhc3MuZGlzYWJsZWRdJzogJ2lzRGlzYWJsZWQnLFxuICAgICdbY2xhc3Mubm8tY2xpY2tdJzogJyFjYW5OYXZpZ2F0ZScsXG4gICAgJ1tjbGFzcy5jb21wbGV0ZV0nOiAnaXNDb21wbGV0ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFN0ZXBuYXZJdGVtIHtcbiAgQElucHV0KCdwYWdlJykgcHVibGljIHBhZ2U6IENscldpemFyZFBhZ2U7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLCBwdWJsaWMgcGFnZUNvbGxlY3Rpb246IFBhZ2VDb2xsZWN0aW9uU2VydmljZSkge31cblxuICBwcml2YXRlIHBhZ2VHdWFyZCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXphcmQgc3RlcG5hdiBpdGVtIGlzIG5vdCBhc3NvY2lhdGVkIHdpdGggYSB3aXphcmQgcGFnZS4nKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5nZXRTdGVwSXRlbUlkRm9yUGFnZSh0aGlzLnBhZ2UpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0Rpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHRoaXMucGFnZUd1YXJkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5kaXNhYmxlZCB8fCB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkU3RvcE5hdmlnYXRpb24gfHwgdGhpcy5uYXZTZXJ2aWNlLndpemFyZERpc2FibGVTdGVwbmF2O1xuICB9XG5cbiAgcHVibGljIGdldCBpc0N1cnJlbnQoKTogYm9vbGVhbiB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmN1cnJlbnQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmNvbXBsZXRlZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY2FuTmF2aWdhdGUoKTogYm9vbGVhbiB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5wcmV2aW91c1BhZ2VJc0NvbXBsZXRlZCh0aGlzLnBhZ2UpO1xuICB9XG5cbiAgY2xpY2soKTogdm9pZCB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcblxuICAgIC8vIGlmIHdlIGNsaWNrIG9uIG91ciBvd24gc3RlcG5hdiBvciBhIGRpc2FibGVkIHN0ZXBuYXYsIHdlIGRvbid0IHdhbnQgdG8gZG8gYW55dGhpbmdcbiAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8IHRoaXMuaXNDdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5uYXZTZXJ2aWNlLmdvVG8odGhpcy5wYWdlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQWxlcnRNb2R1bGUgfSBmcm9tICcuLi9lbXBoYXNpcy9hbGVydC9hbGVydC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTW9kYWxNb2R1bGUgfSBmcm9tICcuLi9tb2RhbC9tb2RhbC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJXaXphcmQgfSBmcm9tICcuL3dpemFyZCc7XG5pbXBvcnQgeyBDbHJXaXphcmRCdXR0b24gfSBmcm9tICcuL3dpemFyZC1idXR0b24nO1xuaW1wb3J0IHsgQ2xyV2l6YXJkQ3VzdG9tVGFncyB9IGZyb20gJy4vd2l6YXJkLWN1c3RvbS10YWdzJztcbmltcG9ydCB7IENscldpemFyZEhlYWRlckFjdGlvbiB9IGZyb20gJy4vd2l6YXJkLWhlYWRlci1hY3Rpb24nO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZUJ1dHRvbnMgfSBmcm9tICcuL3dpemFyZC1wYWdlLWJ1dHRvbnMnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZUhlYWRlckFjdGlvbnMgfSBmcm9tICcuL3dpemFyZC1wYWdlLWhlYWRlci1hY3Rpb25zJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VOYXZUaXRsZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtbmF2dGl0bGUnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZVRpdGxlIH0gZnJvbSAnLi93aXphcmQtcGFnZS10aXRsZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRTdGVwbmF2IH0gZnJvbSAnLi93aXphcmQtc3RlcG5hdic7XG5pbXBvcnQgeyBDbHJXaXphcmRTdGVwbmF2SXRlbSB9IGZyb20gJy4vd2l6YXJkLXN0ZXBuYXYtaXRlbSc7XG5cbmV4cG9ydCBjb25zdCBDTFJfV0laQVJEX0RJUkVDVElWRVM6IGFueVtdID0gW1xuICBDbHJXaXphcmQsXG4gIENscldpemFyZFBhZ2UsXG4gIENscldpemFyZFN0ZXBuYXYsXG4gIENscldpemFyZFN0ZXBuYXZJdGVtLFxuICBDbHJXaXphcmRCdXR0b24sXG4gIENscldpemFyZEhlYWRlckFjdGlvbixcbiAgQ2xyV2l6YXJkQ3VzdG9tVGFncyxcbiAgQ2xyV2l6YXJkUGFnZVRpdGxlLFxuICBDbHJXaXphcmRQYWdlTmF2VGl0bGUsXG4gIENscldpemFyZFBhZ2VCdXR0b25zLFxuICBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucyxcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsck1vZGFsTW9kdWxlLCBDbHJBbGVydE1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9XSVpBUkRfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfV0laQVJEX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckJ1dHRvbk1vZHVsZSB9IGZyb20gJy4vYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRGF0YU1vZHVsZSB9IGZyb20gJy4vZGF0YS9kYXRhLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJEcmFnQW5kRHJvcE1vZHVsZSB9IGZyb20gJy4vdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnLWFuZC1kcm9wLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJFbXBoYXNpc01vZHVsZSB9IGZyb20gJy4vZW1waGFzaXMvZW1waGFzaXMubW9kdWxlJztcbmltcG9ydCB7IENsckZvcm1zTW9kdWxlIH0gZnJvbSAnLi9mb3Jtcy9mb3Jtcy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJMYXlvdXRNb2R1bGUgfSBmcm9tICcuL2xheW91dC9sYXlvdXQubW9kdWxlJztcbmltcG9ydCB7IENsck1vZGFsTW9kdWxlIH0gZnJvbSAnLi9tb2RhbC9tb2RhbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4vcG9wb3Zlci9wb3BvdmVyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENscklmRXhwYW5kTW9kdWxlIH0gZnJvbSAnLi91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJGb2N1c1RyYXBNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ01vZHVsZSB9IGZyb20gJy4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRNb2R1bGUgfSBmcm9tICcuL3dpemFyZC93aXphcmQubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgZXhwb3J0czogW1xuICAgIENsckVtcGhhc2lzTW9kdWxlLFxuICAgIENsckRhdGFNb2R1bGUsXG4gICAgQ2xySWNvbk1vZHVsZSxcbiAgICBDbHJNb2RhbE1vZHVsZSxcbiAgICBDbHJMb2FkaW5nTW9kdWxlLFxuICAgIENscklmRXhwYW5kTW9kdWxlLFxuICAgIENsckNvbmRpdGlvbmFsTW9kdWxlLFxuICAgIENsckZvY3VzVHJhcE1vZHVsZSxcbiAgICBDbHJCdXR0b25Nb2R1bGUsXG4gICAgQ2xyRm9ybXNNb2R1bGUsXG4gICAgQ2xyTGF5b3V0TW9kdWxlLFxuICAgIENsclBvcG92ZXJNb2R1bGUsXG4gICAgQ2xyV2l6YXJkTW9kdWxlLFxuICAgIENsckRyYWdBbmREcm9wTW9kdWxlLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDbGFyaXR5TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG4vKipcbiAqIFByaXZhdGUgY291bnRlciB0byBnZW5lcmF0ZSB1bmlxdWUgSURzIGZvciB0aGUgY2hlY2tib3hlcywgdG8gYmluZCB0aGUgbGFiZWxzIHRvIHRoZW0uXG4gKi9cbmxldCBsYXRlc3RJZCA9IDA7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2xyQ2hlY2tib3ggd2lsbCBiZSByZW5hbWVkIHRvIENsckNoZWNrYm94RGVwcmVjYXRlZCBpbiAwLjEyLCBhbmQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgbmV3XG4gKiBpbXBsZW1lbnRhdGlvbiBpbiAwLjEzLCBzbyBpZiB5b3UgaW1wb3J0IGl0IHlvdSB3aWxsIG5lZWQgdG8gdXBkYXRlIHlvdXIgcmVmZXJlbmNlcy5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNoZWNrYm94JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPCEtLVxuICAgICAgICAgICAgRklYTUU6IFdlIGFyZSBub3Qgc3Vic2NyaWJlZCB0byB0aGUgY2hhbmdlIGV2ZW50IGJ1dCB0aGUgY2xpY2sgZXZlbnQgaGVyZS5cbiAgICAgICAgICAgIFRoZSByZWFzb24gZm9yIHRoYXQgaXMgYmVjYXVzZSBjaGVja2JveGVzIGJlaGF2ZSBkaWZmZXJlbnRseSBvbiBJRSAmIEVkZ2UuXG4gICAgICAgICAgICBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTk0NDc5MzlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgVG8gZml4IHRoYXQsIHdlIGxpc3RlbiB0byBldmVyeSBjbGljayBldmVudCBhbmQgdGhlbiB0b2dnbGUgdGhlIGNoZWNrYm94IG1hbnVhbGx5XG4gICAgICAgICAgICB0byBtYWtlIGl0IGJlaGF2ZSB0aGUgc2FtZSB3YXkgYWNyb3NzIHRoZSBicm93c2VycyB3ZSBzdXBwb3J0LlxuICAgICAgICAgICAgXG4gICAgICAgICAgICBUaGlzIHdvcmtzIGZvciBjYXNlcyB3aGVuIHVzZXJzIHRvZ2dsZSB0aGUgY2hlY2tib3ggdXNpbmcgdGhlIGtleWJvYXJkIHRvbzpcbiAgICAgICAgICAgIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI3ODc4OTQwL3NwYWNlYmFyLXRyaWdnZXJpbmctY2xpY2stZXZlbnQtb24tY2hlY2tib3hcbiAgICAgICAgLS0+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiY2xyQXJpYUxhYmVsZWRCeVwiXG4gICAgICAgICAgICAgICBbaWRdPVwiaWRcIiBbbmFtZV09XCJuYW1lXCIgW2NoZWNrZWRdPVwiY2hlY2tlZFwiXG4gICAgICAgICAgICAgICBbaW5kZXRlcm1pbmF0ZV09XCJpbmRldGVybWluYXRlXCIgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgIChibHVyKT1cInRvdWNoKClcIiAoY2xpY2spPVwiY2hlY2tJbmRldGVybWluYXRlU3RhdGUoKVwiPlxuICAgICAgICA8bGFiZWwgW2F0dHIuZm9yXT1cImlkXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbGFiZWw+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmNoZWNrYm94XSc6ICchaW5saW5lJywgJ1tjbGFzcy5jaGVja2JveC1pbmxpbmVdJzogJ2lubGluZScsICdbY2xhc3MuZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyB9LFxuICAvKlxuICAgICAqIFRoaXMgcHJvdmlkZXIgbGV0cyB1cyBkZWNsYXJlIG91ciBjaGVja2JveCBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAqIHdoaWNoIGFsbG93cyB1cyB0byB1c2UgWyhuZ01vZGVsKV0gZGlyZWN0bHkgb24gb3VyIGNvbXBvbmVudCxcbiAgICAgKiB3aXRoIGFsbCB0aGUgYXV0b21hdGljIGZlYXR1cmVzIHdpcmluZyB0aGF0IGNvbWUgd2l0aCBpdC5cbiAgICAgKi9cbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2xyQ2hlY2tib3hEZXByZWNhdGVkKSwgbXVsdGk6IHRydWUgfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94RGVwcmVjYXRlZCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgLy8gSWYgb3VyIGhvc3QgaGFzIGFuIElEIGF0dHJpYnV0ZSwgd2UgdXNlIHRoaXMgaW5zdGVhZCBvZiBvdXIgaW5kZXguXG4gIEBJbnB1dCgnaWQnKSBfaWQ6IHN0cmluZyA9IChsYXRlc3RJZCsrKS50b1N0cmluZygpO1xuXG4gIHB1YmxpYyBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGBjbHItY2hlY2tib3gtJHt0aGlzLl9pZH1gO1xuICB9XG5cbiAgLy8gSWYgaG9zdCBwcm92aWRlcyBhbiBjbHJBcmlhTGFiZWxlZEJ5IGlucHV0LCB3ZSBhcHBseSBpdCB0byB0aGUgY2hlY2tib3hcbiAgQElucHV0KCdjbHJBcmlhTGFiZWxlZEJ5JykgcHVibGljIGNsckFyaWFMYWJlbGVkQnk6IHN0cmluZyA9IG51bGw7XG5cbiAgLy8gSWYgb3VyIGhvc3QgaGFzIGEgbmFtZSBhdHRyaWJ1dGUsIHdlIGFwcGx5IGl0IHRvIHRoZSBjaGVja2JveC5cbiAgQElucHV0KCduYW1lJykgcHVibGljIG5hbWU6IHN0cmluZyA9IG51bGw7XG5cbiAgLy8gSWYgdGhlIGhvc3QgaXMgZGlzYWJsZWQgd2UgYXBwbHkgaXQgdG8gdGhlIGNoZWNrYm94XG4gIEBJbnB1dCgnY2xyRGlzYWJsZWQnKSBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBTdXBwb3J0IGZvciBpbmxpbmUgY2hlY2tib3hlcywgYWRkcyB0aGUgbmVjZXNzYXJ5IGNsYXNzIHRvIHRoZSBob3N0XG4gIEBJbnB1dCgnY2xySW5saW5lJykgcHVibGljIGlubGluZSA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX2NoZWNrZWQgPSBmYWxzZTtcblxuICBwdWJsaWMgZ2V0IGNoZWNrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gIH1cblxuICBASW5wdXQoJ2NsckNoZWNrZWQnKVxuICBwdWJsaWMgc2V0IGNoZWNrZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2NoZWNrZWQpIHtcbiAgICAgIGlmICh0aGlzLl9pbmRldGVybWluYXRlKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXRlcm1pbmF0ZShmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldENoZWNrZWQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2luZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwdWJsaWMgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV0ZXJtaW5hdGU7XG4gIH1cblxuICBASW5wdXQoJ2NsckluZGV0ZXJtaW5hdGUnKVxuICBwdWJsaWMgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9jaGVja2VkKSB7XG4gICAgICAgIHRoaXMuc2V0Q2hlY2tlZChmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckluZGV0ZXJtaW5hdGVDaGFuZ2UnKVxuICBwdWJsaWMgaW5kZXRlcm1pbmF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgcHJpdmF0ZSBzZXRJbmRldGVybWluYXRlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IHZhbHVlO1xuICAgIHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KHRoaXMuX2luZGV0ZXJtaW5hdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRDaGVja2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY2hlY2tlZCA9IHZhbHVlO1xuICAgIHRoaXMuY2hhbmdlLmVtaXQodGhpcy5fY2hlY2tlZCk7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJDaGVja2VkQ2hhbmdlJykgcHVibGljIGNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy5jaGVja2VkKTtcbiAgfVxuXG4gIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLmNoZWNrZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgICogVGhlc2UgY2FsbGJhY2tzIHdpbGwgYmUgZ2l2ZW4gdG8gdXMgdGhyb3VnaCB0aGUgQ29udHJvbFZhbHVlQWNjZXNzb3IgaW50ZXJmYWNlLFxuICAgICAqIGFuZCB3ZSBuZWVkIHRvIGNhbGwgdGhlbSB3aGVuIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBjaGVja2JveC5cbiAgICAgKi9cbiAgcHJpdmF0ZSBvbkNoYW5nZUNhbGxiYWNrID0gKF86IGFueSkgPT4ge307XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2U7XG4gIH1cblxuICBwcml2YXRlIG9uVG91Y2hlZENhbGxiYWNrID0gKCkgPT4ge307XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gb25Ub3VjaGVkO1xuICB9XG5cbiAgcHVibGljIHRvdWNoKCkge1xuICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgfVxuXG4gIGNoZWNrSW5kZXRlcm1pbmF0ZVN0YXRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJDaGVja2JveERlcHJlY2F0ZWQgfSBmcm9tICcuL2NoZWNrYm94JztcblxuZXhwb3J0IGNvbnN0IENMUl9DSEVDS0JPWF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJDaGVja2JveERlcHJlY2F0ZWRdO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbQ0xSX0NIRUNLQk9YX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbQ0xSX0NIRUNLQk9YX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hEZXByZWNhdGVkTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEYXRlcGlja2VyTW9kdWxlIH0gZnJvbSAnLi4vZm9ybXMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDaGVja2JveERlcHJlY2F0ZWRNb2R1bGUgfSBmcm9tICcuL2NoZWNrYm94L2NoZWNrYm94Lm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBleHBvcnRzOiBbQ2xyQ2hlY2tib3hEZXByZWNhdGVkTW9kdWxlLCBDbHJEYXRlcGlja2VyTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRm9ybXNEZXByZWNhdGVkTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25NZXRhZGF0YSwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2xsYXBzZSgpOiBBbmltYXRpb25NZXRhZGF0YVtdIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICByZXR1cm4gW1xuICAgIHN0YXRlKCd0cnVlJywgc3R5bGUoeyBoZWlnaHQ6IDAsICdvdmVyZmxvdy15JzogJ2hpZGRlbicgfSkpLFxuICAgIHRyYW5zaXRpb24oJ3RydWUgPT4gZmFsc2UnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgaGVpZ2h0OiAnKicsICdvdmVyZmxvdy15JzogJ2hpZGRlbicgfSkpXSksXG4gICAgdHJhbnNpdGlvbignZmFsc2UgPT4gdHJ1ZScsIFtzdHlsZSh7IGhlaWdodDogJyonLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0JyldKSxcbiAgXTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbk1ldGFkYXRhLCBzdHlsZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZmFkZShvcGFjaXR5OiBudW1iZXIgPSAxKTogQW5pbWF0aW9uTWV0YWRhdGFbXSB7XG4gIHJldHVybiBbXG4gICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW3N0eWxlKHsgb3BhY2l0eTogMCB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogb3BhY2l0eSB9KSldKSxcbiAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSldKSxcbiAgXTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbk1ldGFkYXRhLCBzdHlsZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZmFkZVNsaWRlKGRpcmVjdGlvbjogc3RyaW5nKTogQW5pbWF0aW9uTWV0YWRhdGFbXSB7XG4gIGxldCB0cmFuc2Zvcm06IHN0cmluZyA9IG51bGw7XG4gIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsIDI1JSknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCAtMjUlKSc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDI1JSwgMCknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTI1JSwgMCknO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkaXJlY3Rpb24gJyArIGRpcmVjdGlvbiArICcgZm9yIHNsaWRlIGFuaW1hdGlvbi4nKTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogdHJhbnNmb3JtIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0JyldKSxcbiAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfSkpXSksXG4gIF07XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25NZXRhZGF0YSwgc3R5bGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWRlKGRpcmVjdGlvbjogc3RyaW5nKTogQW5pbWF0aW9uTWV0YWRhdGFbXSB7XG4gIGxldCB0cmFuc2Zvcm06IHN0cmluZyA9IG51bGw7XG4gIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsIDI1JSknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCAtMjUlKSc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDI1JSwgMCknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTI1JSwgMCknO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBkaXJlY3Rpb24gJyArIGRpcmVjdGlvbiArICcgZm9yIHNsaWRlIGFuaW1hdGlvbi4nKTtcbiAgfVxuICByZXR1cm4gW1xuICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtzdHlsZSh7IHRyYW5zZm9ybTogdHJhbnNmb3JtIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0JyldKSxcbiAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfSkpXSksXG4gIF07XG59XG4iXSwibmFtZXMiOlsiRGlyZWN0aXZlIiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiLCJTdWJqZWN0IiwidHNsaWJfMS5fX3ZhbHVlcyIsIkV2ZW50RW1pdHRlciIsIlRlbXBsYXRlUmVmIiwiVmlld0NvbnRhaW5lclJlZiIsIklucHV0IiwiT3V0cHV0IiwiT3B0aW9uYWwiLCJJbmplY3RhYmxlIiwiQ29tcG9uZW50IiwiU2tpcFNlbGYiLCJWaWV3Q2hpbGQiLCJmb3J3YXJkUmVmIiwiRWxlbWVudFJlZiIsIkNvbnRlbnRDaGlsZHJlbiIsIkhvc3RMaXN0ZW5lciIsInRyaWdnZXIiLCJ0cmFuc2l0aW9uIiwic3R5bGUiLCJhbmltYXRlIiwia2V5ZnJhbWVzIiwiUmVuZGVyZXIyIiwiZmlsdGVyIiwiQmVoYXZpb3JTdWJqZWN0IiwiSG9zdEJpbmRpbmciLCJJbmplY3Rpb25Ub2tlbiIsIkNvbnRlbnRDaGlsZCIsIkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciIsInRzbGliXzEuX19leHRlbmRzIiwiTmdDb250cm9sIiwiSW5qZWN0IiwiRE9DVU1FTlQiLCJpc1BsYXRmb3JtQnJvd3NlciIsIkluamVjdG9yIiwiUExBVEZPUk1fSUQiLCJmaXJzdCIsIk5nWm9uZSIsImdldExvY2FsZURheU5hbWVzIiwiRm9ybVN0eWxlIiwiVHJhbnNsYXRpb25XaWR0aCIsImdldExvY2FsZU1vbnRoTmFtZXMiLCJnZXRMb2NhbGVGaXJzdERheU9mV2VlayIsImdldExvY2FsZURhdGVGb3JtYXQiLCJGb3JtYXRXaWR0aCIsIkxPQ0FMRV9JRCIsIlNlbGYiLCJGb3Jtc01vZHVsZSIsIlNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IiLCJDaGFuZ2VEZXRlY3RvclJlZiIsIk5nRm9yT2YiLCJJdGVyYWJsZURpZmZlcnMiLCJjb21iaW5lTGF0ZXN0IiwibWFwIiwic3RhdGUiLCJRdWVyeUxpc3QiLCJ0b2tlbkZhY3RvcnkiLCJQT1NJVElPTlMiLCJOR19WQUxVRV9BQ0NFU1NPUiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7UUFPQTtTQUlDOztvQkFKQUEsWUFBUyxTQUFDLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRTs7UUFJbkMsdUJBQUM7S0FKRDs7Ozs7OztBQ0dBLFFBQWEsbUJBQW1CLEdBQWdCLENBQUMsZ0JBQWdCLENBQUM7QUFFbEU7UUFBQTtTQUM2Qjs7b0JBRDVCQyxXQUFRLFNBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQ0MsbUJBQVksQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDLG1CQUFt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QUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFO1FBQ3pHLFdBQVcsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRTtRQUMxRyxjQUFjLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7UUFDN0csY0FBYyxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7UUFDM0csY0FBYyxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLEVBQUU7UUFDM0csZUFBZSxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFO1FBQzlHLGFBQWEsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsU0FBUyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRTtRQUMxRyxhQUFhLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQVcsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUMxRyxhQUFh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Q0Usa0JBQU8sQ0FBQyxrQkFBa0IsRUFBRUQsZ0JBQUssQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN4RixDQUFDO0lBQ0osQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=