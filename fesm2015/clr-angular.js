import { Directive, NgModule, EventEmitter, Input, Output, TemplateRef, ViewContainerRef, Optional, Injectable, Component, SkipSelf, ViewChild, forwardRef, ChangeDetectorRef, ElementRef, Renderer2, ContentChildren, QueryList, InjectionToken, Inject, HostListener, NgZone, HostBinding, Injector, ComponentFactoryResolver, ContentChild, IterableDiffers, Self, PLATFORM_ID, defineInjectable, LOCALE_ID } from '@angular/core';
import { CommonModule, DOCUMENT, isPlatformBrowser, FormatWidth, FormStyle, getLocaleDateFormat, getLocaleDayNames, getLocaleFirstDayOfWeek, getLocaleMonthNames, TranslationWidth, NgForOf } from '@angular/common';
import { Subject, BehaviorSubject, combineLatest } from 'rxjs';
import { animate, keyframes, style, transition, trigger, state } from '@angular/animations';
import { NgControl, FormsModule, SelectMultipleControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { first, filter, map } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrIconCustomTag {
}
ClrIconCustomTag.decorators = [
    { type: Directive, args: [{ selector: 'clr-icon' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_ICON_DIRECTIVES = [ClrIconCustomTag];
class ClrIconModule {
}
ClrIconModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], declarations: [CLR_ICON_DIRECTIVES], exports: [CLR_ICON_DIRECTIVES] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const Point = {
    RIGHT_CENTER: 0,
    RIGHT_TOP: 1,
    RIGHT_BOTTOM: 2,
    TOP_CENTER: 3,
    TOP_RIGHT: 4,
    TOP_LEFT: 5,
    BOTTOM_CENTER: 6,
    BOTTOM_RIGHT: 7,
    BOTTOM_LEFT: 8,
    LEFT_CENTER: 9,
    LEFT_TOP: 10,
    LEFT_BOTTOM: 11,
};
Point[Point.RIGHT_CENTER] = 'RIGHT_CENTER';
Point[Point.RIGHT_TOP] = 'RIGHT_TOP';
Point[Point.RIGHT_BOTTOM] = 'RIGHT_BOTTOM';
Point[Point.TOP_CENTER] = 'TOP_CENTER';
Point[Point.TOP_RIGHT] = 'TOP_RIGHT';
Point[Point.TOP_LEFT] = 'TOP_LEFT';
Point[Point.BOTTOM_CENTER] = 'BOTTOM_CENTER';
Point[Point.BOTTOM_RIGHT] = 'BOTTOM_RIGHT';
Point[Point.BOTTOM_LEFT] = 'BOTTOM_LEFT';
Point[Point.LEFT_CENTER] = 'LEFT_CENTER';
Point[Point.LEFT_TOP] = 'LEFT_TOP';
Point[Point.LEFT_BOTTOM] = 'LEFT_BOTTOM';
/** @type {?} */
const POSITION_RELATIVE = 'relative';
/** @type {?} */
const POSITION_ABSOLUTE = 'absolute';
/** @type {?} */
const POSITION_FIXED = 'fixed';
/** @type {?} */
const OVERFLOW_SCROLL = 'scroll';
/** @type {?} */
const OVERFLOW_AUTO = 'auto';
class Popover {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        /*
             * Containers up to the first positioned one will have an event on scroll
             */
        this.scrollableElements = [];
        this.boundOnScrollListener = this.emitScrollEvent.bind(this);
        // Browsers don't agree with what to do if some of these are not specified, so we set them all to be safe.
        element.style.position = POSITION_ABSOLUTE;
        element.style.top = 0;
        element.style.bottom = 'auto';
        element.style.left = 0;
        element.style.right = 'auto';
    }
    // TODO: need a way to account for parameters that change dynamically (positioning).
    /**
     * @param {?} anchor
     * @param {?} anchorAlign
     * @param {?} popoverAlign
     * @param {?=} __3
     * @return {?}
     */
    anchor(anchor, anchorAlign, popoverAlign, { offsetX = 0, offsetY = 0, useAnchorParent = false } = {}) {
        // TODO: we are assuming here that the popover is inside or next to the anchor.
        // We'd need to go up the popover tree too otherwise
        this.addScrollEventListeners(anchor);
        if (useAnchorParent) {
            anchor = anchor.parentNode;
        }
        // explicitly override anchor's style to static
        anchor.style.position = 'static';
        /** @type {?} */
        const anchorRect = anchor.getBoundingClientRect();
        /** @type {?} */
        const popoverRect = this.element.getBoundingClientRect();
        // position of left top corner of anchor + the offset
        /** @type {?} */
        let leftDiff = anchorRect.left - popoverRect.left + offsetX;
        /** @type {?} */
        let topDiff = anchorRect.top - popoverRect.top + offsetY;
        // first, adjust positioning based on anchor's align point
        switch (anchorAlign) {
            case Point.LEFT_TOP:
            case Point.TOP_LEFT:
                break;
            case Point.TOP_CENTER:
                leftDiff += anchorRect.width / 2;
                break;
            case Point.TOP_RIGHT:
                leftDiff += anchorRect.width;
                break;
            case Point.RIGHT_TOP:
                leftDiff += anchorRect.width;
                break;
            case Point.LEFT_BOTTOM:
                topDiff += anchorRect.height;
                break;
            case Point.BOTTOM_LEFT:
                topDiff += anchorRect.height;
                break;
            case Point.BOTTOM_CENTER:
                topDiff += anchorRect.height;
                leftDiff += anchorRect.width / 2;
                break;
            case Point.BOTTOM_RIGHT:
                topDiff += anchorRect.height;
                leftDiff += anchorRect.width;
                break;
            case Point.RIGHT_BOTTOM:
                topDiff += anchorRect.height;
                leftDiff += anchorRect.width;
                break;
            case Point.LEFT_CENTER:
                topDiff += anchorRect.height / 2;
                break;
            case Point.RIGHT_CENTER:
                topDiff += anchorRect.height / 2;
                leftDiff += anchorRect.width;
                break;
            default:
        }
        // second, adjust positioning based on popover's align point
        switch (popoverAlign) {
            case Point.LEFT_TOP:
            case Point.TOP_LEFT:
                break;
            case Point.TOP_CENTER:
                leftDiff -= popoverRect.width / 2;
                break;
            case Point.TOP_RIGHT:
                leftDiff -= popoverRect.width;
                break;
            case Point.RIGHT_TOP:
                leftDiff -= popoverRect.width;
                break;
            case Point.LEFT_BOTTOM:
                topDiff -= popoverRect.height;
                break;
            case Point.BOTTOM_LEFT:
                topDiff -= popoverRect.height;
                break;
            case Point.BOTTOM_CENTER:
                topDiff -= popoverRect.height;
                leftDiff -= popoverRect.width / 2;
                break;
            case Point.BOTTOM_RIGHT:
                topDiff -= popoverRect.height;
                leftDiff -= popoverRect.width;
                break;
            case Point.RIGHT_BOTTOM:
                topDiff -= popoverRect.height;
                leftDiff -= popoverRect.width;
                break;
            case Point.LEFT_CENTER:
                topDiff -= popoverRect.height / 2;
                break;
            case Point.RIGHT_CENTER:
                topDiff -= popoverRect.height / 2;
                leftDiff -= popoverRect.width;
                break;
            default:
        }
        // Third, adjust with popover's margins based on the two align points.
        // Here, we make an assumption that popover is primarily positioned outside the
        // anchor with minor offset. Without this assumption, it's impossible to apply
        // the popover's margins in a predictable way. For example, assume that a popover
        // and its anchor are exactly the same size. if a popover is positioned inside the
        // anchor (which is technically possible), then it becomes impossible to know what to do
        // if the popover has a non-zero margin value all around (because applying the margin in
        // all four directions will result in no margin visually, which isn't what we want).
        // Therefore, our logic makes assumptions about margins of interest given the points,
        // and only covers the cases where popover is outside the anchor.
        /** @type {?} */
        const popoverComputedStyle = getComputedStyle(this.element);
        /** @type {?} */
        const marginLeft = parseInt(popoverComputedStyle.marginLeft, 10);
        /** @type {?} */
        const marginRight = parseInt(popoverComputedStyle.marginRight, 10);
        /** @type {?} */
        const marginTop = parseInt(popoverComputedStyle.marginTop, 10);
        /** @type {?} */
        const marginBottom = parseInt(popoverComputedStyle.marginBottom, 10);
        switch (anchorAlign) {
            case Point.LEFT_TOP:
            case Point.TOP_LEFT:
            case Point.TOP_RIGHT:
            case Point.RIGHT_TOP:
                if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                    topDiff -= marginBottom;
                    leftDiff -= marginRight;
                }
                if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                    topDiff -= marginTop;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                    topDiff += marginTop;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                    topDiff += marginTop;
                    leftDiff -= marginRight;
                }
                break;
            case Point.LEFT_BOTTOM:
            case Point.BOTTOM_LEFT:
            case Point.BOTTOM_RIGHT:
            case Point.RIGHT_BOTTOM:
                if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                    topDiff -= marginBottom;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                    topDiff -= marginBottom;
                    leftDiff -= marginRight;
                }
                if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                    topDiff += marginTop;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                    topDiff += marginTop;
                    leftDiff -= marginRight;
                }
                break;
            case Point.TOP_CENTER:
                topDiff -= marginBottom;
                leftDiff += marginLeft;
                leftDiff -= marginRight;
                break;
            case Point.BOTTOM_CENTER:
                topDiff += marginTop;
                leftDiff += marginLeft;
                leftDiff -= marginRight;
                break;
            case Point.LEFT_CENTER:
                topDiff += marginTop;
                topDiff -= marginBottom;
                leftDiff -= marginRight;
                break;
            case Point.RIGHT_CENTER:
                topDiff += marginTop;
                topDiff -= marginBottom;
                leftDiff += marginLeft;
                break;
            default:
        }
        this.element.style.transform = `translateX(${Math.round(leftDiff)}px) translateY(${Math.round(topDiff)}px)`;
        return this._scroll.asObservable();
    }
    /**
     * @return {?}
     */
    release() {
        this.element.style.transform = '';
        this.removeScrollEventListeners();
    }
    /**
     * @param {?} container
     * @return {?}
     */
    isPositioned(container) {
        /** @type {?} */
        const position = getComputedStyle(container).position;
        return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
    }
    /**
     * @return {?}
     */
    emitScrollEvent() {
        this._scroll.next();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    addScrollEventListeners(e) {
        this._scroll = new Subject();
        /** @type {?} */
        const anchor = e;
        /** @type {?} */
        let current = e;
        while (current && current !== document) {
            if (this.scrolls(current)) {
                current.addEventListener('scroll', this.boundOnScrollListener);
                this.scrollableElements.push(current);
            }
            if (current !== anchor && this.isPositioned(current)) {
                break;
            }
            current = current.parentNode;
        }
    }
    /**
     * @return {?}
     */
    removeScrollEventListeners() {
        for (const elem of this.scrollableElements) {
            elem.removeEventListener('scroll', this.boundOnScrollListener);
        }
        this.scrollableElements.length = 0;
        if (this._scroll) {
            this._scroll.complete();
            delete this._scroll;
        }
    }
    /**
     * @param {?} container
     * @return {?}
     */
    scrolls(container) {
        /** @type {?} */
        const computedStyles = getComputedStyle(container);
        return (computedStyles.overflowX === OVERFLOW_SCROLL ||
            computedStyles.overflowX === OVERFLOW_AUTO ||
            computedStyles.overflowY === OVERFLOW_SCROLL ||
            computedStyles.overflowY === OVERFLOW_AUTO);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let openCount = 0;
/** @type {?} */
const waiting = [];
// pending create functions
class PopoverDirectiveOld {
    /**
     * @param {?} templateRef
     * @param {?} viewContainer
     */
    constructor(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.popoverOptions = {};
        this.clrPopoverOldChange = new EventEmitter(false);
    }
    /**
     * @param {?} open
     * @return {?}
     */
    set clrPopoverOld(open) {
        if (open) {
            if (this.popoverOptions.allowMultipleOpen) {
                this.createPopover();
            }
            else {
                if (openCount === 0) {
                    this.createPopover();
                }
                else {
                    waiting.push(() => {
                        this.createPopover();
                    });
                }
            }
        }
        else {
            this.viewContainer.clear();
            this.destroyPopover();
            if (!this.popoverOptions.allowMultipleOpen) {
                if (waiting.length > 0) {
                    /** @type {?} */
                    const createPopoverFn = waiting.shift();
                    createPopoverFn();
                }
            }
        }
    }
    /**
     * @return {?}
     */
    createPopover() {
        /** @type {?} */
        const embeddedViewRef = (/** @type {?} */ (this.viewContainer.createEmbeddedView(this.templateRef)));
        // TODO: Not sure of the risks associated with using this. Find an alternative.
        // Needed for find the correct height and width of dynamically created views
        // inside of the popover. For Eg: Button Groups
        embeddedViewRef.detectChanges();
        // filter out other nodes in the view ref so we are only left with element nodes
        /** @type {?} */
        const elementNodes = embeddedViewRef.rootNodes.filter((node) => {
            return node.nodeType === 1;
        });
        // we take the first element node in the embedded view; usually there should only be one anyways
        this._popoverInstance = new Popover(elementNodes[0]);
        this._subscription = this._popoverInstance
            .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
            .subscribe(() => {
            this.clrPopoverOldChange.emit(false);
        });
        openCount++;
    }
    /**
     * @return {?}
     */
    destroyPopover() {
        if (this._popoverInstance) {
            this._subscription.unsubscribe();
            this._popoverInstance.release();
            delete this._popoverInstance;
            openCount--;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyPopover();
    }
}
PopoverDirectiveOld.decorators = [
    { type: Directive, args: [{ selector: '[clrPopoverOld]' },] }
];
/** @nocollapse */
PopoverDirectiveOld.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef }
];
PopoverDirectiveOld.propDecorators = {
    anchorElem: [{ type: Input, args: ['clrPopoverOldAnchor',] }],
    anchorPoint: [{ type: Input, args: ['clrPopoverOldAnchorPoint',] }],
    popoverPoint: [{ type: Input, args: ['clrPopoverOldPopoverPoint',] }],
    popoverOptions: [{ type: Input, args: ['clrPopoverOldOptions',] }],
    clrPopoverOldChange: [{ type: Output, args: ['clrPopoverOldChange',] }],
    clrPopoverOld: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const POPOVER_DIRECTIVES = [PopoverDirectiveOld];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrCommonPopoverModule {
}
ClrCommonPopoverModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], declarations: [POPOVER_DIRECTIVES], exports: [POPOVER_DIRECTIVES] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
 * This does not mean you should extend it, simply implementing it is fine.
 * @abstract
 */
class LoadingListener {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const ClrLoadingState = {
    DEFAULT: 0,
    LOADING: 1,
    SUCCESS: 2,
    ERROR: 3,
};
ClrLoadingState[ClrLoadingState.DEFAULT] = 'DEFAULT';
ClrLoadingState[ClrLoadingState.LOADING] = 'LOADING';
ClrLoadingState[ClrLoadingState.SUCCESS] = 'SUCCESS';
ClrLoadingState[ClrLoadingState.ERROR] = 'ERROR';
class ClrLoading {
    // We find the first parent that handles something loading
    /**
     * @param {?} listener
     */
    constructor(listener) {
        this.listener = listener;
        this._loadingState = ClrLoadingState.DEFAULT;
    }
    /**
     * @return {?}
     */
    get loadingState() {
        return this._loadingState;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set loadingState(value) {
        if (value === true) {
            value = ClrLoadingState.LOADING;
        }
        else if (!value) {
            value = ClrLoadingState.DEFAULT;
        }
        if (value === this._loadingState) {
            return;
        }
        this._loadingState = value;
        if (this.listener) {
            this.listener.loadingStateChange(value);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.loadingState = ClrLoadingState.DEFAULT;
    }
}
ClrLoading.decorators = [
    { type: Directive, args: [{ selector: '[clrLoading]' },] }
];
/** @nocollapse */
ClrLoading.ctorParameters = () => [
    { type: LoadingListener, decorators: [{ type: Optional }] }
];
ClrLoading.propDecorators = {
    loadingState: [{ type: Input, args: ['clrLoading',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ButtonInGroupService {
    constructor() {
        this._changes = new Subject();
    }
    /**
     * @return {?}
     */
    get changes() {
        return this._changes.asObservable();
    }
    /**
     * @param {?} button
     * @return {?}
     */
    updateButtonGroup(button) {
        this._changes.next(button);
    }
}
ButtonInGroupService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrButton {
    /**
     * @param {?} buttonInGroupService
     */
    constructor(buttonInGroupService) {
        this.buttonInGroupService = buttonInGroupService;
        this._enableService = false;
        this._inMenu = false;
        this._classNames = 'btn';
        this._name = null;
        this._type = null;
        this._disabled = null;
        this._click = new EventEmitter(false);
    }
    /**
     * @return {?}
     */
    get inMenu() {
        return this._inMenu;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inMenu(value) {
        value = !!value;
        if (this._inMenu !== value) {
            this._inMenu = value;
            // We check if the service flag is enabled
            // and if the service exists because the service is optional
            if (this._enableService && this.buttonInGroupService) {
                this.buttonInGroupService.updateButtonGroup(this);
            }
        }
    }
    /**
     * @return {?}
     */
    get classNames() {
        return this._classNames;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set classNames(value) {
        if (typeof value === 'string') {
            /** @type {?} */
            const classNames = value.split(' ');
            if (classNames.indexOf('btn') === -1) {
                classNames.push('btn');
            }
            this._classNames = classNames.join(' ');
        }
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        if (typeof value === 'string') {
            this._name = value;
        }
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        if (typeof value === 'string') {
            this._type = value;
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (value !== null && value !== false) {
            this._disabled = '';
        }
        else {
            this._disabled = null;
        }
    }
    /**
     * @param {?} state
     * @return {?}
     */
    loadingStateChange(state$$1) {
        this.loading = state$$1 === ClrLoadingState.LOADING;
    }
    /**
     * @return {?}
     */
    emitClick() {
        this._click.emit(true);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._enableService = true;
    }
}
ClrButton.decorators = [
    { type: Component, args: [{
                selector: 'clr-button',
                template: `
        <ng-template #buttonProjectedRef>
            <button 
                [class]="classNames" 
                (click)="emitClick()"
                [attr.type]="type"
                [attr.name]="name"
                [attr.disabled]="disabled">
                <span class="spinner spinner-inline" *ngIf="loading"></span>
                <ng-content></ng-content>
            </button>
        </ng-template>
    `,
                providers: [{ provide: LoadingListener, useExisting: ClrButton }]
            }] }
];
/** @nocollapse */
ClrButton.ctorParameters = () => [
    { type: ButtonInGroupService, decorators: [{ type: SkipSelf }, { type: Optional }] }
];
ClrButton.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['buttonProjectedRef',] }],
    inMenu: [{ type: Input, args: ['clrInMenu',] }],
    classNames: [{ type: Input, args: ['class',] }],
    name: [{ type: Input, args: ['name',] }],
    type: [{ type: Input, args: ['type',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    _click: [{ type: Output, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @type {?} */
const CLR_MENU_POSITIONS = [
    'bottom-left',
    'bottom-right',
    'top-left',
    'top-right',
    'left-bottom',
    'left-top',
    'right-bottom',
    'right-top',
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// @TODO Put the Required type back in when our minimumly supported version of Angular uses
// TS 2.8 or greater (should be Angular 7)
// export class ClrCommonStringsService implements Required<ClrCommonStrings> {
class ClrCommonStringsService {
    constructor() {
        this.open = 'Open';
        this.close = 'Close';
        this.show = 'Show';
        this.hide = 'Hide';
        this.expand = 'Expand';
        this.collapse = 'Collapse';
        this.more = 'More';
        this.select = 'Select';
        this.selectAll = 'Select All';
        this.previous = 'Previous';
        this.next = 'Next';
        this.current = 'Jump to current';
        this.info = 'Info';
        this.success = 'Success';
        this.warning = 'Warning';
        this.danger = 'Error';
        this.rowActions = 'Available actions';
        this.pickColumns = 'Show or hide columns';
    }
}
/**
 * @param {?=} existing
 * @return {?}
 */
function commonStringsFactory(existing) {
    /** @type {?} */
    const defaults = new ClrCommonStringsService();
    if (existing) {
        return Object.assign({}, defaults, existing);
    }
    return defaults;
}
/** @type {?} */
const COMMON_STRINGS_PROVIDER = {
    useFactory: commonStringsFactory,
    // We have a circular dependency for now, we can address it later once these
    // tree-shakeable providers have proper documentation.
    deps: [[new Optional(), new SkipSelf(), forwardRef(() => ClrCommonStrings)]],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class ClrCommonStrings {
}
ClrCommonStrings.decorators = [
    { type: Injectable, args: [Object.assign({ providedIn: 'root' }, COMMON_STRINGS_PROVIDER),] }
];
/** @nocollapse */ ClrCommonStrings.ngInjectableDef = defineInjectable({ factory: function ClrCommonStrings_Factory() { return new ClrCommonStrings(); }, token: ClrCommonStrings, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrButtonGroup {
    /**
     * @param {?} buttonGroupNewService
     * @param {?} elementRef
     * @param {?} commonStrings
     */
    constructor(buttonGroupNewService, elementRef, commonStrings) {
        this.buttonGroupNewService = buttonGroupNewService;
        this.elementRef = elementRef;
        this.commonStrings = commonStrings;
        this.inlineButtons = [];
        this.menuButtons = [];
        this._openMenu = false;
        this.anchorPoint = Point.BOTTOM_LEFT; // default if menuPosition isn't set
        // default if menuPosition isn't set
        this.popoverPoint = Point.LEFT_TOP; // default if menuPosition isn't set
        /**
         * Flag with indicates if the overflow menu toggle was clicked.
         * If true, this can save us traversing the DOM to find
         * whether the click was withing the button group toggle
         * or menu in the onMouseClick method
         */
        this._overflowMenuToggleClicked = false;
    }
    /**
     * 1. Initializes the initial Button Group View
     * 2. Subscribes to changes on the ContentChildren
     *    in case the user content projection changes
     * @return {?}
     */
    ngAfterContentInit() {
        this.initializeButtons();
        this.buttonGroupNewService.changes.subscribe(button => this.rearrangeButton(button));
        this.buttons.changes.subscribe(() => {
            this.initializeButtons();
        });
    }
    /**
     * Moves the button into the other ViewContainer
     * when an update is received.
     *
     * @param {?} button
     * @return {?}
     */
    rearrangeButton(button) {
        /** @type {?} */
        let fromView;
        /** @type {?} */
        let toView;
        if (button.inMenu) {
            fromView = this.inlineButtons;
            toView = this.menuButtons;
        }
        else {
            fromView = this.menuButtons;
            toView = this.inlineButtons;
        }
        /** @type {?} */
        const index = fromView.indexOf(button);
        if (index > -1) {
            fromView.splice(index, 1);
            /** @type {?} */
            const moveIndex = this.getMoveIndex(button);
            if (moveIndex <= toView.length) {
                toView.splice(moveIndex, 0, button);
            }
        }
    }
    /**
     * Author: Eudes
     *
     * Finds the order of a button w.r.t other buttons
     *
     * @param {?} buttonToMove
     * @return {?}
     */
    getMoveIndex(buttonToMove) {
        /** @type {?} */
        const tempArr = this.buttons.filter(button => button.inMenu === buttonToMove.inMenu);
        return tempArr.indexOf(buttonToMove);
    }
    /**
     * @return {?}
     */
    initializeButtons() {
        /** @type {?} */
        const tempInlineButtons = [];
        /** @type {?} */
        const tempInMenuButtons = [];
        this.buttons.forEach(button => {
            if (button.inMenu) {
                tempInMenuButtons.push(button);
            }
            else {
                tempInlineButtons.push(button);
            }
        });
        this.inlineButtons = tempInlineButtons;
        this.menuButtons = tempInMenuButtons;
    }
    /**
     * @return {?}
     */
    get menuPosition() {
        return this._menuPosition;
    }
    /**
     * @param {?} pos
     * @return {?}
     */
    set menuPosition(pos) {
        if (pos && CLR_MENU_POSITIONS.indexOf(pos) > -1) {
            this._menuPosition = pos;
        }
        else {
            this._menuPosition = 'bottom-left';
        }
        // set the popover values based on menu position
        switch (this._menuPosition) {
            case 'top-right':
                this.anchorPoint = Point.TOP_RIGHT;
                this.popoverPoint = Point.RIGHT_BOTTOM;
                break;
            case 'top-left':
                this.anchorPoint = Point.TOP_LEFT;
                this.popoverPoint = Point.LEFT_BOTTOM;
                break;
            case 'bottom-right':
                this.anchorPoint = Point.BOTTOM_RIGHT;
                this.popoverPoint = Point.RIGHT_TOP;
                break;
            case 'bottom-left':
                this.anchorPoint = Point.BOTTOM_LEFT;
                this.popoverPoint = Point.LEFT_TOP;
                break;
            case 'right-top':
                this.anchorPoint = Point.RIGHT_TOP;
                this.popoverPoint = Point.LEFT_TOP;
                break;
            case 'right-bottom':
                this.anchorPoint = Point.RIGHT_BOTTOM;
                this.popoverPoint = Point.LEFT_BOTTOM;
                break;
            case 'left-top':
                this.anchorPoint = Point.LEFT_TOP;
                this.popoverPoint = Point.RIGHT_TOP;
                break;
            case 'left-bottom':
                this.anchorPoint = Point.LEFT_BOTTOM;
                this.popoverPoint = Point.RIGHT_BOTTOM;
                break;
            default:
                this.anchorPoint = Point.BOTTOM_LEFT;
                this.popoverPoint = Point.LEFT_TOP;
                break;
        }
    }
    /**
     * @return {?}
     */
    get openMenu() {
        return this._openMenu;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set openMenu(value) {
        this._openMenu = value;
    }
    // default if menuPosition isn't set
    /**
     * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
     * clicked. Also set a flag that indicates that the toggle
     * was clicked so that we don't traverse the DOM to find the
     * location of the click.
     * @return {?}
     */
    toggleMenu() {
        this.openMenu = !this.openMenu;
        this._overflowMenuToggleClicked = true;
    }
    // TODO: Generic Directive to handle this
    /**
     * Called on mouse clicks anywhere in the DOM.
     * Checks to see if the mouseclick happened on the host or outside
     * @param {?} target
     * @return {?}
     */
    onMouseClick(target) {
        if (this.openMenu && !this._overflowMenuToggleClicked) {
            // Reset the overflow menu toggle clicked flag
            this._overflowMenuToggleClicked = false;
            /** @type {?} */
            let current = target;
            // Get the element in the DOM on which the mouse was clicked
            /** @type {?} */
            const host = this.elementRef.nativeElement;
            if (current.classList.contains('dropdown-menu')) {
                current = current.parentNode;
                while (current) {
                    if (current === document) {
                        this.openMenu = false;
                        return;
                    }
                    // If clicked on dropdown menu and menu is in host
                    // do nothing
                    if (current === host) {
                        return;
                    }
                    current = current.parentNode;
                }
            }
            this.openMenu = false;
        }
        this._overflowMenuToggleClicked = false; // Reset the overflow menu toggle clicked flag
    }
}
ClrButtonGroup.decorators = [
    { type: Component, args: [{
                selector: 'clr-button-group',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-container *ngFor=\"let inlineButton of inlineButtons\">\n    <ng-template [ngTemplateOutlet]=\"inlineButton.templateRef\"></ng-template>\n</ng-container>\n<ng-container *ngIf=\"menuButtons.length > 0\">\n    <div\n        class=\"btn-group-overflow open\"\n        [ngClass]=\"menuPosition\"\n        #anchor>\n        <button\n            class=\"btn dropdown-toggle\"\n            (click)=\"toggleMenu()\">\n            <clr-icon shape=\"ellipsis-horizontal\" [attr.title]=\"commonStrings.more\"></clr-icon>\n        </button>\n        <div\n            class=\"dropdown-menu\"\n            *clrPopoverOld=\"openMenu; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint;\">\n            <ng-template [ngTemplateOutlet]=\"ref\"></ng-template>\n        </div>\n    </div>\n</ng-container>\n<ng-template #ref>\n    <ng-container *ngFor=\"let menuButton of menuButtons\">\n        <ng-template [ngTemplateOutlet]=\"menuButton.templateRef\"></ng-template>\n    </ng-container>\n</ng-template>\n",
                providers: [ButtonInGroupService],
                host: { '[class.btn-group]': 'true' }
            }] }
];
/** @nocollapse */
ClrButtonGroup.ctorParameters = () => [
    { type: ButtonInGroupService },
    { type: ElementRef },
    { type: ClrCommonStrings }
];
ClrButtonGroup.propDecorators = {
    buttons: [{ type: ContentChildren, args: [ClrButton,] }],
    menuPosition: [{ type: Input, args: ['clrMenuPosition',] }],
    onMouseClick: [{ type: HostListener, args: ['document:click', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_BUTTON_GROUP_DIRECTIVES = [ClrButton, ClrButtonGroup];
class ClrButtonGroupModule {
}
ClrButtonGroupModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule, ClrCommonPopoverModule],
                declarations: [CLR_BUTTON_GROUP_DIRECTIVES],
                exports: [CLR_BUTTON_GROUP_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrLoadingButton {
    /**
     * @param {?} el
     * @param {?} renderer
     */
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.buttonState = ClrLoadingState;
        this.state = ClrLoadingState.DEFAULT;
        this.clrLoadingChange = new EventEmitter(false);
    }
    /**
     * @param {?} state
     * @return {?}
     */
    loadingStateChange(state$$1) {
        if (state$$1 === this.state) {
            return;
        }
        this.state = state$$1;
        switch (state$$1) {
            case ClrLoadingState.DEFAULT:
                this.renderer.removeStyle(this.el.nativeElement, 'width');
                if (!this.disabled) {
                    this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                }
                break;
            case ClrLoadingState.LOADING:
                this.setExplicitButtonWidth();
                this.renderer.setAttribute(this.el.nativeElement, 'disabled', '');
                break;
            case ClrLoadingState.SUCCESS:
                this.setExplicitButtonWidth();
                break;
            case ClrLoadingState.ERROR:
                this.loadingStateChange(ClrLoadingState.DEFAULT);
                break;
            default:
                break;
        }
        this.clrLoadingChange.emit(state$$1);
    }
    /**
     * @return {?}
     */
    setExplicitButtonWidth() {
        if (this.el.nativeElement && this.el.nativeElement.getBoundingClientRect) {
            /** @type {?} */
            const boundingClientRect = this.el.nativeElement.getBoundingClientRect();
            this.renderer.setStyle(this.el.nativeElement, 'width', `${boundingClientRect.width}px`);
        }
    }
}
ClrLoadingButton.decorators = [
    { type: Component, args: [{
                selector: 'button[clrLoading]',
                template: `
        <ng-container [ngSwitch]="state">
            <span *ngSwitchCase="buttonState.LOADING">
                <span @spinner class="spinner spinner-inline"></span>
            </span>
            <span *ngSwitchCase="buttonState.SUCCESS">
                <span @validated (@validated.done)="this.loadingStateChange(this.buttonState.DEFAULT)" class="spinner spinner-inline spinner-check"></span>
            </span>
            <span *ngSwitchCase="buttonState.DEFAULT" @defaultButton>
                <ng-content></ng-content>
            </span>
        </ng-container>
    `,
                providers: [{ provide: LoadingListener, useExisting: ClrLoadingButton }],
                animations: [
                    trigger('defaultButton', [
                        transition(':enter', [style({ opacity: 0 }), animate('200ms 100ms ease-in', style({ opacity: 1 }))]),
                        // TODO: see if we can get leave animation to work before spinner's enter animation
                        transition(':leave', [style({ opacity: 0 })]),
                    ]),
                    trigger('spinner', [
                        transition(':enter', [style({ opacity: 0 }), animate('200ms 100ms ease-in', style({ opacity: 1 }))]),
                        transition(':leave', [style({ opacity: 1 }), animate('100ms ease-out', style({ opacity: 0 }))]),
                    ]),
                    trigger('validated', [
                        transition(':enter', [
                            animate('600ms', keyframes([
                                style({ transform: 'scale(0,0)', offset: 0 }),
                                style({ opacity: 1, offset: 0.2 }),
                                style({ transform: 'scale(1.2,1.2)', offset: 0.4 }),
                                style({ transform: 'scale(.9,.9)', offset: 0.6 }),
                                style({ transform: 'scale(1,1)', offset: 1 }),
                            ])),
                        ]),
                        transition(':leave', [style({ opacity: 1 }), animate('100ms ease-out', style({ opacity: 0 }))]),
                    ]),
                ],
                host: { '[attr.disabled]': "disabled? '' : null" }
            }] }
];
/** @nocollapse */
ClrLoadingButton.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
ClrLoadingButton.propDecorators = {
    disabled: [{ type: Input, args: ['disabled',] }],
    clrLoadingChange: [{ type: Output, args: ['clrLoadingChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_LOADING_BUTTON_DIRECTIVES = [ClrLoadingButton];
class ClrLoadingButtonModule {
}
ClrLoadingButtonModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [CLR_LOADING_BUTTON_DIRECTIVES],
                exports: [CLR_LOADING_BUTTON_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrButtonModule {
}
ClrButtonModule.decorators = [
    { type: NgModule, args: [{
                exports: [ClrLoadingButtonModule, ClrButtonGroupModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class EmptyAnchor {
}
EmptyAnchor.decorators = [
    { type: Component, args: [{
                template: ''
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Internal module, please do not export!
 */
class ClrHostWrappingModule {
}
ClrHostWrappingModule.decorators = [
    { type: NgModule, args: [{ declarations: [EmptyAnchor], exports: [EmptyAnchor], entryComponents: [EmptyAnchor] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrControlError {
}
ClrControlError.decorators = [
    { type: Component, args: [{
                selector: 'clr-control-error',
                template: `
    <ng-content></ng-content>
    `,
                host: { '[class.clr-subtext]': 'true' }
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrControlHelper {
}
ClrControlHelper.decorators = [
    { type: Component, args: [{
                selector: 'clr-control-helper',
                template: `
    <ng-content></ng-content>
    `,
                host: { '[class.clr-subtext]': 'true' }
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgControlService {
    constructor() {
        // Observable to subscribe to the control, since its not available immediately for projected content
        this._controlChanges = new Subject();
    }
    /**
     * @return {?}
     */
    get controlChanges() {
        return this._controlChanges.asObservable();
    }
    /**
     * @param {?} control
     * @return {?}
     */
    setControl(control) {
        this._controlChanges.next(control);
    }
}
NgControlService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class IfErrorService {
    /**
     * @param {?} ngControlService
     */
    constructor(ngControlService) {
        this.ngControlService = ngControlService;
        // Implement our own status changes observable, since Angular controls don't
        // fire on events like blur, and we want to return the boolean state instead of a string
        this._statusChanges = new Subject();
        this.subscriptions = [];
        // Wait for the control to be available
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            if (control) {
                this.control = control;
                this.listenForChanges();
            }
        }));
    }
    /**
     * @return {?}
     */
    get statusChanges() {
        return this._statusChanges.asObservable();
    }
    // Subscribe to the status change events, only after touched and emit the control
    /**
     * @return {?}
     */
    listenForChanges() {
        this.subscriptions.push(this.control.statusChanges.subscribe(() => {
            this.sendValidity();
        }));
    }
    /**
     * @return {?}
     */
    sendValidity() {
        if ((this.control.touched || this.control.dirty) && this.control.invalid) {
            this._statusChanges.next(true);
        }
        else {
            this._statusChanges.next(false);
        }
    }
    // Allows a control to push a status check upstream, such as on blur
    /**
     * @return {?}
     */
    triggerStatusChange() {
        if (this.control) {
            this.sendValidity();
        }
    }
    // Clean up subscriptions
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
IfErrorService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
IfErrorService.ctorParameters = () => [
    { type: NgControlService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrIfError {
    /**
     * @param {?} ifErrorService
     * @param {?} ngControlService
     * @param {?} template
     * @param {?} container
     */
    constructor(ifErrorService, ngControlService, template, container) {
        this.ifErrorService = ifErrorService;
        this.ngControlService = ngControlService;
        this.template = template;
        this.container = container;
        this.subscriptions = [];
        this.displayed = false;
        if (!this.ifErrorService) {
            throw new Error('clrIfError can only be used within a form control container element like clr-input-container');
        }
        else {
            this.displayError(false);
        }
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.control = control;
        }));
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            // If there is a specific error to track, check it, otherwise check overall validity
            if (this.error && this.control) {
                this.displayError(this.control.hasError(this.error));
            }
            else {
                this.displayError(invalid);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @param {?} invalid
     * @return {?}
     */
    displayError(invalid) {
        if (invalid && !this.displayed) {
            this.container.createEmbeddedView(this.template);
            this.displayed = true;
        }
        else if (!invalid) {
            this.container.clear();
            this.displayed = false;
        }
    }
}
ClrIfError.decorators = [
    { type: Directive, args: [{ selector: '[clrIfError]' },] }
];
/** @nocollapse */
ClrIfError.ctorParameters = () => [
    { type: IfErrorService, decorators: [{ type: Optional }] },
    { type: NgControlService, decorators: [{ type: Optional }] },
    { type: TemplateRef },
    { type: ViewContainerRef }
];
ClrIfError.propDecorators = {
    error: [{ type: Input, args: ['clrIfError',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let counter = 0;
class ControlIdService {
    constructor() {
        this._id = 'clr-form-control-' + ++counter;
        this._idChange = new BehaviorSubject(this._id);
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this._idChange.next(value);
    }
    /**
     * @return {?}
     */
    get idChange() {
        return this._idChange.asObservable();
    }
}
ControlIdService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {string} */
const Layouts = {
    VERTICAL: 'vertical',
    HORIZONTAL: 'horizontal',
    COMPACT: 'compact',
};
class LayoutService {
    constructor() {
        this.layout = Layouts.HORIZONTAL;
        // This is basically a replacement for Object.values(), which IE11 and Node <9 don't support :(
        // String enums cannot be reverse-mapped, meaning Layouts['COMPACT'] does not return 'compact' so
        // this exists to deal with this little caveat to get the list of the values as an array.
        this.layoutValues = Object.keys(Layouts).map(key => Layouts[key]);
    }
    /**
     * @return {?}
     */
    isVertical() {
        return this.layout === Layouts.VERTICAL;
    }
    /**
     * @return {?}
     */
    isHorizontal() {
        return this.layout === Layouts.HORIZONTAL;
    }
    /**
     * @return {?}
     */
    isCompact() {
        return this.layout === Layouts.COMPACT;
    }
    /**
     * @return {?}
     */
    get layoutClass() {
        return `clr-form-${this.layout}`;
    }
    /**
     * @param {?} layout
     * @return {?}
     */
    isValid(layout) {
        return this.layoutValues.indexOf(layout) > -1;
    }
}
LayoutService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrLabel {
    /**
     * @param {?} controlIdService
     * @param {?} layoutService
     * @param {?} ngControlService
     * @param {?} renderer
     * @param {?} el
     */
    constructor(controlIdService, layoutService, ngControlService, renderer, el) {
        this.controlIdService = controlIdService;
        this.layoutService = layoutService;
        this.ngControlService = ngControlService;
        this.renderer = renderer;
        this.el = el;
        this.subscriptions = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Only add the clr-control-label if it is inside a control container
        if (this.controlIdService || this.ngControlService) {
            this.renderer.addClass(this.el.nativeElement, 'clr-control-label');
        }
        // Only set the grid column classes if we are in the right context and if they aren't already set
        if (this.layoutService &&
            !this.layoutService.isVertical() &&
            this.el.nativeElement &&
            this.el.nativeElement.className.indexOf('clr-col') < 0) {
            this.renderer.addClass(this.el.nativeElement, 'clr-col-xs-12');
            this.renderer.addClass(this.el.nativeElement, 'clr-col-md-2');
        }
        if (this.controlIdService && !this.forAttr) {
            this.subscriptions.push(this.controlIdService.idChange.subscribe(id => (this.forAttr = id)));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
ClrLabel.decorators = [
    { type: Directive, args: [{ selector: 'label' },] }
];
/** @nocollapse */
ClrLabel.ctorParameters = () => [
    { type: ControlIdService, decorators: [{ type: Optional }] },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: NgControlService, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef }
];
ClrLabel.propDecorators = {
    forAttr: [{ type: HostBinding, args: ['attr.for',] }, { type: Input, args: ['for',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const IS_NEW_FORMS_LAYOUT = new InjectionToken('IS_NEW_FORMS_LAYOUT');
/** @type {?} */
const IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER = {
    provide: IS_NEW_FORMS_LAYOUT,
    useValue: true,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class MarkControlService {
    constructor() {
        this._dirty = new Subject();
    }
    /**
     * @return {?}
     */
    get dirtyChange() {
        return this._dirty.asObservable();
    }
    /**
     * @return {?}
     */
    markAsDirty() {
        this._dirty.next();
    }
}
MarkControlService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrForm {
    /**
     * @param {?} layoutService
     * @param {?} markControlService
     */
    constructor(layoutService, markControlService) {
        this.layoutService = layoutService;
        this.markControlService = markControlService;
    }
    /**
     * @return {?}
     */
    markAsDirty() {
        this.markControlService.markAsDirty();
    }
}
ClrForm.decorators = [
    { type: Directive, args: [{
                selector: '[clrForm]',
                providers: [LayoutService, MarkControlService, IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER],
                host: {
                    '[class.clr-form]': 'true',
                    '[class.clr-form-horizontal]': 'layoutService.isHorizontal()',
                    '[class.clr-form-compact]': 'layoutService.isCompact()',
                },
            },] }
];
/** @nocollapse */
ClrForm.ctorParameters = () => [
    { type: LayoutService },
    { type: MarkControlService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrLayout {
    /**
     * @param {?} layoutService
     */
    constructor(layoutService) {
        this.layoutService = layoutService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Only set the layout if it is a valid option
        if (this.layout && this.layoutService.isValid(this.layout)) {
            this.layoutService.layout = this.layout;
        }
    }
}
ClrLayout.decorators = [
    { type: Directive, args: [{
                selector: '[clrLayout]',
            },] }
];
/** @nocollapse */
ClrLayout.ctorParameters = () => [
    { type: LayoutService }
];
ClrLayout.propDecorators = {
    layout: [{ type: Input, args: ['clrLayout',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrCommonFormsModule {
}
ClrCommonFormsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
                exports: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrCheckboxWrapper {
    constructor() {
        // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
        // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
        // but we'd still need to insert a label
        this._dynamic = false;
    }
}
ClrCheckboxWrapper.decorators = [
    { type: Component, args: [{
                selector: 'clr-checkbox-wrapper',
                template: `
    <ng-content select="[clrCheckbox]"></ng-content>
    <ng-content select="label"></ng-content>
    <label *ngIf="!label"></label>
  `,
                host: {
                    '[class.clr-checkbox-wrapper]': 'true',
                },
                providers: [ControlIdService]
            }] }
];
ClrCheckboxWrapper.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
 * still undefined.
 * TODO - make sure these comment annotations do not break ng-packgr.
 * @template W
 */
class HostWrapper {
    /**
     * @param {?} containerType
     * @param {?} vcr
     * @param {?=} index
     */
    constructor(containerType, vcr, index = 0) {
        this.injector = vcr.injector;
        // If the host is already wrapped, we don't do anything
        if (!this.injector.get(containerType, null)) {
            /** @type {?} */
            const cfr = this.injector.get(ComponentFactoryResolver);
            /** @type {?} */
            const el = this.injector.get(ElementRef);
            // We need a new anchor, since we're projecting the current one.
            vcr.createComponent(cfr.resolveComponentFactory(EmptyAnchor));
            /** @type {?} */
            const factory = cfr.resolveComponentFactory(containerType);
            // Craft the element array based on what slot to use. Angular only uses the index to determine
            // which ng-content to project into, so if you have more than one ng-content you'll need to set
            // the index in the constructor appropriately
            /** @type {?} */
            const element = [];
            element[index] = [el.nativeElement];
            // We're assuming only one projection slot, but in more complex cases we might want to provide
            // a different array of projected elements.
            /** @type {?} */
            const containerRef = vcr.createComponent(factory, undefined, undefined, element);
            // We can now remove the useless anchor
            vcr.remove(0);
            // We note that the container was dynamically created
            containerRef.instance._dynamic = true;
            // We keep the wrapper's injector to access the dependencies that weren't available before.
            this.injector = containerRef.injector;
        }
    }
    /**
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    get(token, notFoundValue) {
        return this.injector.get(token, notFoundValue);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ControlClassService {
    constructor() {
        this.className = '';
    }
    /**
     * @param {?=} invalid
     * @param {?=} grid
     * @param {?=} additional
     * @return {?}
     */
    controlClass(invalid = false, grid = false, additional = '') {
        /** @type {?} */
        const controlClasses = [this.className, additional];
        if (invalid) {
            controlClasses.push('clr-error');
        }
        if (grid && this.className.indexOf('clr-col') === -1) {
            controlClasses.push('clr-col-md-10 clr-col-xs-12');
        }
        return controlClasses.join(' ').trim();
    }
    // We want to remove the column classes from the input up to the container
    /**
     * @param {?} renderer
     * @param {?} element
     * @return {?}
     */
    initControlClass(renderer, element) {
        if (element && element.className) {
            this.className = element.className;
            /** @type {?} */
            const klasses = element.className.split(' ');
            klasses.forEach(klass => {
                if (klass.startsWith('clr-col')) {
                    renderer.removeClass(element, klass);
                }
            });
        }
    }
}
ControlClassService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template W
 */
class WrappedFormControl {
    // I lost way too much time trying to make this work without injecting the ViewContainerRef and the Injector,
    // I'm giving up. So we have to inject these two manually for now.
    /**
     * @param {?} vcr
     * @param {?} wrapperType
     * @param {?} injector
     * @param {?} ngControl
     * @param {?} renderer
     * @param {?} el
     */
    constructor(vcr, wrapperType, injector, ngControl, renderer, el) {
        this.vcr = vcr;
        this.wrapperType = wrapperType;
        this.ngControl = ngControl;
        this.subscriptions = [];
        this.index = 0;
        try {
            this.ngControlService = injector.get(NgControlService);
            this.ifErrorService = injector.get(IfErrorService);
            this.controlClassService = injector.get(ControlClassService);
            this.markControlService = injector.get(MarkControlService);
        }
        catch (e) { }
        if (this.controlClassService) {
            this.controlClassService.initControlClass(renderer, el.nativeElement);
        }
        if (this.markControlService) {
            this.subscriptions.push(this.markControlService.dirtyChange.subscribe(() => {
                this.ngControl.control.markAsDirty();
                this.ngControl.control.updateValueAndValidity();
            }));
        }
    }
    /**
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        if (this.controlIdService) {
            this.controlIdService.id = value;
        }
    }
    /**
     * @return {?}
     */
    triggerValidation() {
        if (this.ifErrorService) {
            this.ifErrorService.triggerStatusChange();
        }
    }
    /**
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    getProviderFromContainer(token, notFoundValue) {
        return this._containerInjector.get(token, notFoundValue);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._containerInjector = new HostWrapper(this.wrapperType, this.vcr, this.index);
        this.controlIdService = this._containerInjector.get(ControlIdService);
        if (this._id) {
            this.controlIdService.id = this._id;
        }
        else {
            this._id = this.controlIdService.id;
        }
        if (this.ngControlService) {
            this.ngControlService.setControl(this.ngControl);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
WrappedFormControl.propDecorators = {
    id: [{ type: HostBinding }, { type: Input }],
    triggerValidation: [{ type: HostListener, args: ['blur',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrCheckbox extends WrappedFormControl {
    /**
     * @param {?} vcr
     * @param {?} injector
     * @param {?} control
     * @param {?} renderer
     * @param {?} el
     */
    constructor(vcr, injector, control, renderer, el) {
        super(vcr, ClrCheckboxWrapper, injector, control, renderer, el);
    }
}
ClrCheckbox.decorators = [
    { type: Directive, args: [{ selector: '[clrCheckbox]' },] }
];
/** @nocollapse */
ClrCheckbox.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrCheckboxContainer {
    // @TODO Solve for group validation, which doesn't work now with ngModelGroup
    // Blocked by https://github.com/angular/angular/issues/20268
    // @Input()
    // set clrFormGroup(value: FormGroup) {
    //   this.formGroup = value;
    // }
    // @Input()
    // set clrFormArray(value: FormArray) {
    //   this.formGroup = value;
    // }
    /**
     * @param {?} ifErrorService
     * @param {?} layoutService
     * @param {?} controlClassService
     * @param {?} ngControlService
     */
    constructor(ifErrorService, layoutService, controlClassService, ngControlService) {
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this.inline = false;
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.control = control;
        }));
    }
    // private formGroup: AbstractControl;
    /*
       * Here we want to support the following cases
       * clrInline - true by presence
       * clrInline="true|false" - unless it is explicitly false, strings are considered true
       * [clrInline]="true|false" - expect a boolean
       */
    /**
     * @param {?} value
     * @return {?}
     */
    set clrInline(value) {
        if (typeof value === 'string') {
            this.inline = value === 'false' ? false : true;
        }
        else {
            this.inline = !!value;
        }
    }
    /**
     * @return {?}
     */
    get clrInline() {
        return this.inline;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // @TODO put a solution in for form group validation
        // if (!this.formGroup) {
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            this.invalid = invalid;
        }));
        // } else {
        //   // Because ngModel does this, we have to delay a tick to get the result
        //   Promise.resolve().then(() => {
        //     this.subscriptions.push(
        //       this.formGroup.statusChanges.subscribe(() => {
        //         this.invalid = this.formGroup.invalid;
        //       })
        //     );
        //   });
        // }
    }
    /**
     * @return {?}
     */
    controlClass() {
        return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
    }
    /**
     * @return {?}
     */
    addGrid() {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.map(sub => sub.unsubscribe());
    }
}
ClrCheckboxContainer.decorators = [
    { type: Component, args: [{
                selector: 'clr-checkbox-container',
                template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [class.clr-control-inline]="clrInline" [ngClass]="controlClass()">
      <ng-content select="clr-checkbox-wrapper"></ng-content>
      <div class="clr-subtext-wrapper">
        <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
        <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
        <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
      </div>
    </div>
  `,
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()',
                },
                providers: [NgControlService, ControlClassService, IfErrorService]
            }] }
];
/** @nocollapse */
ClrCheckboxContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: NgControlService }
];
ClrCheckboxContainer.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel,] }],
    clrInline: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrCheckboxModule {
}
ClrCheckboxModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
                declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                entryComponents: [ClrCheckboxWrapper],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let activeCounter = 0;
/** @type {?} */
const IF_ACTIVE_ID = new InjectionToken('IF_ACTIVE_ID');
/**
 * @return {?}
 */
function tokenFactory() {
    return ++activeCounter;
}
/** @type {?} */
const IF_ACTIVE_ID_PROVIDER = {
    provide: IF_ACTIVE_ID,
    useFactory: tokenFactory,
};
/*********
 * @class IfActiveService
 *
 * @description
 * An injectable service used by IfActive structural directives and the components that implement IfActive in their
 * templates. It holds the value of the current state and provides an Observable that both the directive and the
 * implementing component can subscribe to in order to take action on current value changes.
 *
 */
class IfActiveService {
    constructor() {
        /**
         * *****
         * \@property _currentChange
         *
         * \@description
         * A RXJS Subject that updates and provides subscriptions to for the current current state of a component template
         * implemting the IfActive structural directive.
         *
         */
        this._currentChange = new Subject();
    }
    /**
     * ******
     *
     * \@description
     * A getter function that provides an observable for the _current Subject.
     *
     * @return {?}
     */
    get currentChange() {
        return this._currentChange.asObservable();
    }
    /**
     * ******
     *
     * \@description
     * A setter function that updates the current state of _current for this instance of IfActive structural directive.
     * And, broadcasts the new value to all subscribers.
     *
     * @param {?} value
     * @return {?}
     */
    set current(value) {
        if (this._current !== value) {
            this._current = value;
            this._currentChange.next(value);
        }
    }
    /**
     * ******
     *
     * \@description
     * A getter that returns the current value of this IfActive instance.
     * @return {?}
     */
    get current() {
        return this._current;
    }
}
IfActiveService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**********
 *
 * @class ClrIfActive
 *
 * @description
 * A structural directive that controls whether or not the associated TemplateRef is instantiated or not.
 * It makes use of a Component instance level service: IfActiveService to maintain state between itself and
 * the component using it in the component template.
 *
 */
class ClrIfActive {
    /**
     * @param {?} ifActiveService
     * @param {?} id
     * @param {?} template
     * @param {?} container
     */
    constructor(ifActiveService, id, template, container) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.template = template;
        this.container = container;
        this.wasActive = false;
        /**
         * *******
         * \@property activeChange
         *
         * \@description
         * An event emitter that emits when the active property is set to allow for 2way binding when the directive is
         * used with de-structured / de-sugared syntax.
         *
         */
        this.activeChange = new EventEmitter(false);
        this.checkAndUpdateView(ifActiveService.current);
        this.subscription = this.ifActiveService.currentChange.subscribe(newCurrentId => {
            this.checkAndUpdateView(newCurrentId);
        });
    }
    /**
     * @param {?} currentId
     * @return {?}
     */
    checkAndUpdateView(currentId) {
        /** @type {?} */
        const isNowActive = currentId === this.id;
        // only emit if the new active state is changed since last time.
        if (isNowActive !== this.wasActive) {
            this.updateView(isNowActive);
            this.activeChange.emit(isNowActive);
            this.wasActive = isNowActive;
        }
    }
    /**
     * ******
     *
     * \@description
     * A setter that updates IfActiveService.active with value.
     *
     * @param {?} value
     * @return {?}
     */
    set active(value) {
        if (value) {
            this.ifActiveService.current = this.id;
        }
    }
    /**
     * *****
     *
     * \@description
     * A getter that returns the current IfActiveService.active value.
     * @return {?}
     */
    get active() {
        return this.ifActiveService.current === this.id;
    }
    /**
     * ******
     *
     * \@description
     * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param {?} value
     * @return {?}
     */
    updateView(value) {
        if (value) {
            this.container.createEmbeddedView(this.template);
        }
        else {
            this.container.clear();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ClrIfActive.decorators = [
    { type: Directive, args: [{ selector: '[clrIfActive]' },] }
];
/** @nocollapse */
ClrIfActive.ctorParameters = () => [
    { type: IfActiveService },
    { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
    { type: TemplateRef },
    { type: ViewContainerRef }
];
ClrIfActive.propDecorators = {
    active: [{ type: Input, args: ['clrIfActive',] }],
    activeChange: [{ type: Output, args: ['clrIfActiveChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*********
 * @class IfOpenService
 *
 * @description
 * An injectable service used by IfOpen structural directives and the components that implemnt IfOpen in their
 * templates. It holds the value of the open state and provides an Observable that both the directive and the
 * implementing component can subscribe to in order to take action on open value changes.
 *
 */
class IfOpenService {
    constructor() {
        /**
         * *****
         * \@property _openChange
         *
         * \@description
         * A RXJS Subject that updates and provides subscriptions to for the current open state of a component template
         * implemting the IfOpen structural directive.
         */
        this._openChange = new Subject();
        /**
         *  Popovers might need to ignore click events on an element
         *  (eg: popover opens on focus on an input field. Clicks should be ignored in this case)
         */
        this._ignoredElementChange = new Subject();
    }
    /**
     * ******
     *
     * \@description
     * A getter function that provides an observable for the _opened Subject.
     *
     * @return {?}
     */
    get openChange() {
        return this._openChange.asObservable();
    }
    /**
     * ******
     *
     * \@description
     * A setter function that updates the current state of _open for this instance of IfOpen structural directive. And,
     * broadcasts the new value to all subscribers.
     *
     * @param {?} value
     * @return {?}
     */
    set open(value) {
        value = !!value;
        if (this._open !== value) {
            this._open = value;
            this._openChange.next(value);
        }
    }
    /**
     * ******
     *
     * \@description
     * A getter that returns the current value of this IfOpen instance.
     *
     * @return {?}
     */
    get open() {
        return this._open;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleWithEvent(event) {
        this.originalEvent = event;
        this.open = !this.open;
        delete this.originalEvent;
    }
    /**
     * @return {?}
     */
    get ignoredElementChange() {
        return this._ignoredElementChange.asObservable();
    }
    /**
     * @param {?} element
     * @return {?}
     */
    registerIgnoredElement(element) {
        this._ignoredElementChange.next(element);
    }
}
IfOpenService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**********
 *
 * @class ClrIfOpen
 *
 * @description
 * A structural directive that controls whether or not the associated TemplateRef is instantiated or not.
 * It makes use of a Component instance level service: IfOpenService to maintain state between itself and the component
 * using it in the component template.
 *
 */
class ClrIfOpen {
    /**
     * @param {?} ifOpenService
     * @param {?} template
     * @param {?} container
     */
    constructor(ifOpenService, template, container) {
        this.ifOpenService = ifOpenService;
        this.template = template;
        this.container = container;
        /**
         * *******
         * \@property openChange
         *
         * \@description
         * An event emitter that emits when the open property is set to allow for 2way binding when the directive is
         * used with de-structured / de-sugared syntax.
         */
        this.openChange = new EventEmitter(false);
        this.subscription = this.ifOpenService.openChange.subscribe(change => {
            this.updateView(change);
            this.openChange.emit(change);
        });
    }
    /**
     * ******
     *
     * \@description
     * A setter that updates IfOpenService.open with value.
     *
     * @param {?} value
     * @return {?}
     */
    set open(value) {
        this.ifOpenService.open = value;
    }
    /**
     * *****
     *
     * \@description
     * A getter that returns the current IfOpenService.open value.
     *
     * @return {?}
     */
    get open() {
        return this.ifOpenService.open;
    }
    /**
     * ******
     *
     * \@description
     * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param {?} value
     * @return {?}
     */
    updateView(value) {
        if (value) {
            this.container.createEmbeddedView(this.template);
        }
        else {
            this.container.clear();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
ClrIfOpen.decorators = [
    { type: Directive, args: [{ selector: '[clrIfOpen]' },] }
];
/** @nocollapse */
ClrIfOpen.ctorParameters = () => [
    { type: IfOpenService },
    { type: TemplateRef },
    { type: ViewContainerRef }
];
ClrIfOpen.propDecorators = {
    open: [{ type: Input, args: ['clrIfOpen',] }],
    openChange: [{ type: Output, args: ['clrIfOpenChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CONDITIONAL_DIRECTIVES = [ClrIfActive, ClrIfOpen];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrConditionalModule {
}
ClrConditionalModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], declarations: [CONDITIONAL_DIRECTIVES], exports: [CONDITIONAL_DIRECTIVES] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FocusTrapTracker {
    constructor() {
        this._previousFocusTraps = [];
    }
    /**
     * @return {?}
     */
    get current() {
        return this._current;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set current(value) {
        this._previousFocusTraps.push(this._current);
        this._current = value;
    }
    /**
     * @return {?}
     */
    get nbFocusTrappers() {
        return this._previousFocusTraps.length;
    }
    /**
     * @return {?}
     */
    activatePreviousTrapper() {
        this._current = this._previousFocusTraps.pop();
    }
}
FocusTrapTracker.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ FocusTrapTracker.ngInjectableDef = defineInjectable({ factory: function FocusTrapTracker_Factory() { return new FocusTrapTracker(); }, token: FocusTrapTracker, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FocusTrapDirective {
    /**
     * @param {?} el
     * @param {?} injector
     * @param {?} focusTrapsTracker
     * @param {?} renderer
     * @param {?} platformId
     */
    constructor(el, injector, focusTrapsTracker, renderer, platformId) {
        this.el = el;
        this.injector = injector;
        this.focusTrapsTracker = focusTrapsTracker;
        this.renderer = renderer;
        this.platformId = platformId;
        this.document = this.injector.get(DOCUMENT);
        this.focusTrapsTracker.current = this;
        this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFocusIn(event) {
        /** @type {?} */
        const nativeElement = this.el.nativeElement;
        if (this.focusTrapsTracker.current === this && event.target && !nativeElement.contains(event.target)) {
            nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    createFocusableOffScreenEl() {
        // Not using Renderer2's createElement method because that leads to DOM leakage.
        // https://github.com/angular/angular/issues/26954
        /** @type {?} */
        const offScreenSpan = this.document.createElement('span');
        this.renderer.setAttribute(offScreenSpan, 'tabindex', '0');
        this.renderer.addClass(offScreenSpan, 'offscreen-focus-rebounder');
        return offScreenSpan;
    }
    /**
     * @return {?}
     */
    addReboundEls() {
        // We will add these focus rebounding elements only in the following conditions:
        // 1. It should be running inside browser platform as it accesses document.body element
        // 2. We should NOT add them more than once. Hence, we are counting a number of focus trappers
        //    and only add on the first focus trapper.
        if (isPlatformBrowser(this.platformId) && this.focusTrapsTracker.nbFocusTrappers === 1) {
            this.topReboundEl = this.createFocusableOffScreenEl();
            this.bottomReboundEl = this.createFocusableOffScreenEl();
            // Add reboundBeforeTrapEl to the document body as the first child
            this.renderer.insertBefore(this.document.body, this.topReboundEl, this.document.body.firstChild);
            // Add reboundAfterTrapEl to the document body as the last child
            this.renderer.appendChild(this.document.body, this.bottomReboundEl);
        }
    }
    /**
     * @return {?}
     */
    removeReboundEls() {
        if (isPlatformBrowser(this.platformId) &&
            this.focusTrapsTracker.nbFocusTrappers === 1 &&
            this.topReboundEl &&
            this.bottomReboundEl) {
            this.renderer.removeChild(this.document.body, this.topReboundEl);
            this.renderer.removeChild(this.document.body, this.bottomReboundEl);
            // These are here to to make sure that
            // we completely delete all traces of the removed DOM objects.
            delete this.topReboundEl;
            delete this.bottomReboundEl;
        }
    }
    /**
     * @return {?}
     */
    setPreviousFocus() {
        if (this.previousActiveElement && this.previousActiveElement.focus) {
            this.previousActiveElement.focus();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (isPlatformBrowser(this.platformId)) {
            this.previousActiveElement = (/** @type {?} */ (this.document.activeElement));
        }
        this.addReboundEls();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeReboundEls();
        this.setPreviousFocus();
        this.focusTrapsTracker.activatePreviousTrapper();
    }
}
FocusTrapDirective.decorators = [
    { type: Directive, args: [{ selector: '[clrFocusTrap]' },] }
];
/** @nocollapse */
FocusTrapDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector },
    { type: FocusTrapTracker },
    { type: Renderer2 },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
FocusTrapDirective.propDecorators = {
    onFocusIn: [{ type: HostListener, args: ['document:focusin', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const FOCUS_TRAP_DIRECTIVES = [FocusTrapDirective];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrFocusTrapModule {
}
ClrFocusTrapModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [FOCUS_TRAP_DIRECTIVES],
                exports: [FOCUS_TRAP_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @type {?} */
const UP_ARROW = 38;
/** @type {?} */
const DOWN_ARROW = 40;
/** @type {?} */
const RIGHT_ARROW = 39;
/** @type {?} */
const LEFT_ARROW = 37;
/** @type {?} */
const ESC = 27;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * This is the en-001 short locale date format. Setting as default.
 * @type {?}
 */
const DEFAULT_LOCALE_FORMAT = 'dd/MM/y';
// https://en.wikipedia.org/wiki/Date_format_by_country
/** @type {?} */
const LITTLE_ENDIAN_REGEX = /d+.+m+.+y+/i;
/** @type {?} */
const MIDDLE_ENDIAN_REGEX = /m+.+d+.+y+/i;
// No need for BIG_ENDIAN_REGEX because anything that doesn't satisfy the above 2
// is automatically BIG_ENDIAN
/** @type {?} */
const DELIMITER_REGEX = /d+|m+|y+/i;
/** @type {?} */
const USER_INPUT_REGEX = /\d+/g;
/** @type {?} */
const MOBILE_USERAGENT_REGEX = /Mobi/i;
/** @type {?} */
const RTL_REGEX = /\u200f/g;
/** @type {?} */
const YEAR = 'YYYY';
/** @type {?} */
const MONTH = 'MM';
/** @type {?} */
const DATE = 'DD';
/** @type {?} */
const LITTLE_ENDIAN = {
    name: 'LITTLE_ENDIAN',
    format: [DATE, MONTH, YEAR],
};
/** @type {?} */
const MIDDLE_ENDIAN = {
    name: 'MIDDLE_ENDIAN',
    format: [MONTH, DATE, YEAR],
};
/** @type {?} */
const BIG_ENDIAN = {
    name: 'BIG_ENDIAN',
    format: [YEAR, MONTH, DATE],
};
/** @type {?} */
const NO_OF_DAYS_IN_A_WEEK = 7;
/** @type {?} */
const NO_OF_ROWS_IN_CALENDAR_VIEW = 6;
/** @type {?} */
const TOTAL_DAYS_IN_DAYS_VIEW = NO_OF_DAYS_IN_A_WEEK * NO_OF_ROWS_IN_CALENDAR_VIEW;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Returns the number of days in a month.
 * @param {?} year
 * @param {?} month
 * @return {?}
 */
function getNumberOfDaysInTheMonth(year, month) {
    // If we go to the next month, but use a day of 0, it returns the last day from the previous month
    return new Date(year, month + 1, 0).getDate();
}
/**
 * Returns the day for the corresponding date where 0 represents Sunday.
 * @param {?} year
 * @param {?} month
 * @param {?} date
 * @return {?}
 */
function getDay(year, month, date) {
    return new Date(year, month, date).getDay();
}
/**
 * Takes in a year and if it is a 2 digit year, returns the corresponding 4 digit year.
 * Window of 80 years before and 20 years after the present year.
 * Credit: https://github.com/globalizejs/globalize/blob/e1b31cd6a4f1cff75b185b68b7a32220aac5196f/src/date/parse.js
 * @param {?} year
 * @return {?}
 */
function parseToFourDigitYear(year) {
    if (year > 9999 || (year > 100 && year < 999) || year < 10) {
        return -1;
    }
    if (year > 999) {
        return year;
    }
    /** @type {?} */
    const currYear = new Date().getFullYear();
    /** @type {?} */
    const century = Math.floor(currYear / 100) * 100;
    /** @type {?} */
    let result = year + century;
    if (result > currYear + 20) {
        result = result - 100;
    }
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
class DayViewModel {
    /**
     * @param {?} dayModel
     * @param {?=} isTodaysDate
     * @param {?=} isDisabled
     * @param {?=} isSelected
     * @param {?=} isFocusable
     */
    constructor(dayModel, isTodaysDate = false, isDisabled = false, isSelected = false, isFocusable = false) {
        this.dayModel = dayModel;
        this.isTodaysDate = isTodaysDate;
        this.isDisabled = isDisabled;
        this.isSelected = isSelected;
        this.isFocusable = isFocusable;
    }
    /**
     * Gets the tab index based on the isFocusable flag.
     * @return {?}
     */
    get tabIndex() {
        return this.isFocusable ? 0 : -1;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CalendarModel {
    /**
     * @param {?} year
     * @param {?} month
     */
    constructor(year, month) {
        this.year = year;
        this.month = month;
        this.initializeDaysInCalendar();
    }
    /**
     * Populates the days array with the DayModels in the current Calendar.
     * @return {?}
     */
    initializeDaysInCalendar() {
        /** @type {?} */
        const noOfDaysInCalendar = getNumberOfDaysInTheMonth(this.year, this.month);
        this.days = Array(noOfDaysInCalendar)
            .fill(null)
            .map((date, index) => {
            return new DayModel(this.year, this.month, index + 1);
        });
    }
    /**
     * Checks if the calendar passed is equal to the current calendar.
     * @param {?} calendar
     * @return {?}
     */
    isEqual(calendar) {
        if (calendar) {
            return this.year === calendar.year && this.month === calendar.month;
        }
        return false;
    }
    /**
     * Checks if a DayModel is in the Calendar
     * @param {?} day
     * @return {?}
     */
    isDayInCalendar(day) {
        if (day) {
            return this.year === day.year && this.month === day.month;
        }
        return false;
    }
    /**
     * Returns CalendarModel of the previous month.
     * @return {?}
     */
    previousMonth() {
        if (this.month === 0) {
            return new CalendarModel(this.year - 1, 11);
        }
        else {
            return new CalendarModel(this.year, this.month - 1);
        }
    }
    /**
     * Returns CalendarModel of the next month.
     * @return {?}
     */
    nextMonth() {
        if (this.month === 11) {
            return new CalendarModel(this.year + 1, 0);
        }
        else {
            return new CalendarModel(this.year, this.month + 1);
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DayModel {
    /**
     * @param {?} year
     * @param {?} month
     * @param {?} date
     */
    constructor(year, month, date) {
        this.year = year;
        this.month = month;
        this.date = date;
    }
    /**
     * Returns the Calendar for the current DayModel.
     * @return {?}
     */
    get calendar() {
        return new CalendarModel(this.year, this.month);
    }
    /**
     * Checks if the passed CalendarDate is equal to itself.
     * @param {?} day
     * @return {?}
     */
    isEqual(day) {
        if (day) {
            return this.year === day.year && this.month === day.month && this.date === day.date;
        }
        return false;
    }
    /**
     * Converts the CalendarDate into the Javascript Date object.
     * @return {?}
     */
    toDate() {
        return new Date(this.year, this.month, this.date);
    }
    /**
     * Returns a new DayModel which is incremented based on the value passed.
     * @param {?} value
     * @return {?}
     */
    incrementBy(value) {
        // Creating new Javascript Date object to increment because
        // it will automatically take care of switching to next or previous
        // months & years without we having to worry about it.
        /** @type {?} */
        const date = new Date(this.year, this.month, this.date + value);
        return new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Clones the current day model.
     * @return {?}
     */
    clone() {
        return new DayModel(this.year, this.month, this.date);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CalendarViewModel {
    /**
     * @param {?} calendar
     * @param {?} selectedDay
     * @param {?} focusableDay
     * @param {?} today
     * @param {?} firstDayOfWeek
     */
    constructor(calendar, selectedDay, focusableDay, today, firstDayOfWeek) {
        this.calendar = calendar;
        this.selectedDay = selectedDay;
        this.focusableDay = focusableDay;
        this.today = today;
        this.firstDayOfWeek = firstDayOfWeek;
        this.currMonthDayViews = [];
        this.initializeCalendarView();
    }
    /**
     * DayViewModel matrix. Size 6x7
     * @return {?}
     */
    get calendarView() {
        return this._calendarView;
    }
    /**
     * Generates a 6x7 matrix of DayViewModel based on the Calendar.
     * The 6x7 matrix is structured according to the first day of the week.
     * 6 rows to accommodate months which might have dates spanning over 6 weeks.
     * 7 columns because there are 7 days in a week :P :D
     * @return {?}
     */
    initializeCalendarView() {
        // Generate prev and next month calendar models.
        /** @type {?} */
        const prevMonthCalendar = this.calendar.previousMonth();
        /** @type {?} */
        const nextMonthCalendar = this.calendar.nextMonth();
        // Get no of days from prev and next months.
        /** @type {?} */
        const daysFromPrevMonthInCalView = this.numDaysFromPrevMonthInCalView(this.calendar.year, this.calendar.month);
        /** @type {?} */
        const daysFromNextMonthInCalView = TOTAL_DAYS_IN_DAYS_VIEW - (this.calendar.days.length + daysFromPrevMonthInCalView);
        // Generate prev, curr and next day view models
        /** @type {?} */
        let prevMonthDayViews = [];
        /** @type {?} */
        let nextMonthDayViews = [];
        if (daysFromPrevMonthInCalView > 0) {
            prevMonthDayViews = this.generateDayViewModels(prevMonthCalendar.days.slice(-1 * daysFromPrevMonthInCalView), true, false);
        }
        this.currMonthDayViews = this.generateDayViewModels(this.calendar.days, false, true);
        if (daysFromNextMonthInCalView > 0) {
            nextMonthDayViews = this.generateDayViewModels(nextMonthCalendar.days.slice(0, daysFromNextMonthInCalView), true, false);
        }
        // Generate calendar view and initialize flags
        this._calendarView = this.generateCalendarView(prevMonthDayViews, this.currMonthDayViews, nextMonthDayViews);
        this.initializeSelectedDay();
        this.initializeFocusableDay();
    }
    /**
     * Generates a DayViewModel array based on the DayModel passed
     * @param {?} days
     * @param {?} isDisabled
     * @param {?} isCurrentCalendar
     * @return {?}
     */
    generateDayViewModels(days, isDisabled, isCurrentCalendar) {
        /** @type {?} */
        const dayViews = days.map(day => {
            return new DayViewModel(day, false, isDisabled, false, false);
        });
        if (isCurrentCalendar && this.calendar.isDayInCalendar(this.today)) {
            dayViews[this.today.date - 1].isTodaysDate = true;
        }
        return dayViews;
    }
    /**
     * Gets the first day of the current month to figure out how many dates of previous month
     * are needed to complete the Calendar View based on the first day of the week.
     * eg: Assuming locale en-US, the first day of the week is Sunday,
     * if first day of the current month lands on Wednesday, then
     * (this.getDay function would return 3 since
     * first day of the week is 0), we need the 3 days from the previous month.
     * @param {?} currentYear
     * @param {?} currentMonth
     * @return {?}
     */
    numDaysFromPrevMonthInCalView(currentYear, currentMonth) {
        /** @type {?} */
        const firstDayOfCurrMonth = getDay(currentYear, currentMonth, 1);
        if (firstDayOfCurrMonth >= this.firstDayOfWeek) {
            return firstDayOfCurrMonth - this.firstDayOfWeek;
        }
        else {
            return NO_OF_DAYS_IN_A_WEEK + firstDayOfCurrMonth - this.firstDayOfWeek;
        }
    }
    /**
     * Checks if the Day passed is in the CalendarView.
     * @param {?} day
     * @return {?}
     */
    isDayInCalendarView(day) {
        if (!this.calendar.isDayInCalendar(day)) {
            return false;
        }
        return true;
    }
    /**
     * Using the DayViewModels from the previous, current and next month, this function
     * generates the CalendarView.
     * @param {?} prev
     * @param {?} curr
     * @param {?} next
     * @return {?}
     */
    generateCalendarView(prev, curr, next) {
        /** @type {?} */
        const combinationArr = [...prev, ...curr, ...next];
        /** @type {?} */
        const calendarView = [];
        for (let i = 0; i < NO_OF_ROWS_IN_CALENDAR_VIEW; i++) {
            calendarView[i] = combinationArr.slice(i * NO_OF_DAYS_IN_A_WEEK, (i + 1) * NO_OF_DAYS_IN_A_WEEK);
        }
        return calendarView;
    }
    /**
     * Initialize the selected day if the day is in the calendar.
     * @return {?}
     */
    initializeSelectedDay() {
        if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
            this.currMonthDayViews[this.selectedDay.date - 1].isSelected = true;
        }
    }
    /**
     * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
     * we check for the selected day. If selected day is not set then check if today is in the current
     * calendar. If not then just set the 15th of the current calendar month.
     * @return {?}
     */
    initializeFocusableDay() {
        if (this.focusableDay && this.isDayInCalendarView(this.focusableDay)) {
            this.setFocusableFlag(this.focusableDay, true);
        }
        else if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
            this.setFocusableFlag(this.selectedDay, true);
            this.focusableDay = this.selectedDay.clone();
        }
        else if (this.isDayInCalendarView(this.today)) {
            this.setFocusableFlag(this.today, true);
            this.focusableDay = this.today.clone();
        }
        else {
            this.focusableDay = new DayModel(this.calendar.year, this.calendar.month, 15);
            this.setFocusableFlag(this.focusableDay, true);
        }
    }
    /**
     * @param {?} day
     * @param {?} flag
     * @return {?}
     */
    setFocusableFlag(day, flag) {
        if (day) {
            this.currMonthDayViews[day.date - 1].isFocusable = flag;
        }
    }
    /**
     * Updates the focusable day in the calendar.
     * @param {?} day
     * @return {?}
     */
    updateFocusableDay(day) {
        this.setFocusableFlag(this.focusableDay, false);
        this.setFocusableFlag(day, true);
        this.focusableDay = day;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service is responsible for:
 * 1. Initializing the displayed calendar.
 * 2. Moving the calendar to the next, previous or current months
 * 3. Managing the focused and selected day models.
 */
class DateNavigationService {
    constructor() {
        /**
         * Variable to store today's date.
         */
        this._todaysFullDate = new Date();
        this._selectedDayChange = new Subject();
        this._displayedCalendarChange = new Subject();
        this._focusOnCalendarChange = new Subject();
        this._focusedDayChange = new Subject();
    }
    /**
     * @return {?}
     */
    get displayedCalendar() {
        return this._displayedCalendar;
    }
    // not a setter because i want this to remain private
    /**
     * @param {?} value
     * @return {?}
     */
    setDisplayedCalendar(value) {
        if (!this._displayedCalendar.isEqual(value)) {
            this._displayedCalendar = value;
            this._displayedCalendarChange.next();
        }
    }
    /**
     * @return {?}
     */
    initializeTodaysDate() {
        this._todaysFullDate = new Date();
        this._today = new DayModel(this._todaysFullDate.getFullYear(), this._todaysFullDate.getMonth(), this._todaysFullDate.getDate());
    }
    /**
     * @return {?}
     */
    get today() {
        return this._today;
    }
    /**
     * @return {?}
     */
    get selectedDayChange() {
        return this._selectedDayChange.asObservable();
    }
    /**
     * Notifies that the selected day has changed so that the date can be emitted to the user.
     * Note: Only to be called from day.ts
     * @param {?} dayModel
     * @return {?}
     */
    notifySelectedDayChanged(dayModel) {
        if (dayModel.isEqual(this.selectedDay)) {
            return;
        }
        this.selectedDay = dayModel;
        this._selectedDayChange.next(dayModel);
    }
    /**
     * Initializes the calendar based on the selected day.
     * @return {?}
     */
    initializeCalendar() {
        this.focusedDay = null; // Can be removed later on the store focus
        this.initializeTodaysDate();
        if (this.selectedDay) {
            this._displayedCalendar = new CalendarModel(this.selectedDay.year, this.selectedDay.month);
        }
        else {
            this._displayedCalendar = new CalendarModel(this.today.year, this.today.month);
        }
    }
    /**
     * @param {?} month
     * @return {?}
     */
    changeMonth(month) {
        this.setDisplayedCalendar(new CalendarModel(this._displayedCalendar.year, month));
    }
    /**
     * @param {?} year
     * @return {?}
     */
    changeYear(year) {
        this.setDisplayedCalendar(new CalendarModel(year, this._displayedCalendar.month));
    }
    /**
     * Moves the displayed calendar to the next month.
     * @return {?}
     */
    moveToNextMonth() {
        this.setDisplayedCalendar(this._displayedCalendar.nextMonth());
    }
    /**
     * Moves the displayed calendar to the previous month.
     * @return {?}
     */
    moveToPreviousMonth() {
        this.setDisplayedCalendar(this._displayedCalendar.previousMonth());
    }
    /**
     * Moves the displayed calendar to the current month and year.
     * @return {?}
     */
    moveToCurrentMonth() {
        if (!this.displayedCalendar.isDayInCalendar(this.today)) {
            this.setDisplayedCalendar(new CalendarModel(this.today.year, this.today.month));
        }
        this._focusOnCalendarChange.next();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    incrementFocusDay(value) {
        this.focusedDay = this.focusedDay.incrementBy(value);
        if (this._displayedCalendar.isDayInCalendar(this.focusedDay)) {
            this._focusedDayChange.next(this.focusedDay);
        }
        else {
            this.setDisplayedCalendar(this.focusedDay.calendar);
        }
        this._focusOnCalendarChange.next();
    }
    /**
     * This observable lets the subscriber know that the displayed calendar has changed.
     * @return {?}
     */
    get displayedCalendarChange() {
        return this._displayedCalendarChange.asObservable();
    }
    /**
     * This observable lets the subscriber know that the focus should be applied on the calendar.
     * @return {?}
     */
    get focusOnCalendarChange() {
        return this._focusOnCalendarChange.asObservable();
    }
    /**
     * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
     * @return {?}
     */
    get focusedDayChange() {
        return this._focusedDayChange.asObservable();
    }
}
DateNavigationService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service focuses the day that is focusable in the calendar.
 */
class DatepickerFocusService {
    /**
     * @param {?} _ngZone
     * @param {?} platformId
     */
    constructor(_ngZone, platformId) {
        this._ngZone = _ngZone;
        this.platformId = platformId;
    }
    // Credit: Material: https://github.com/angular/material2/blob/master/src/lib/datepicker/calendar.ts
    /**
     * @param {?} elRef
     * @return {?}
     */
    focusCell(elRef) {
        this._ngZone.runOutsideAngular(() => {
            this._ngZone.onStable
                .asObservable()
                .pipe(first())
                .subscribe(() => {
                if (isPlatformBrowser(this.platformId)) {
                    /** @type {?} */
                    const focusEl = elRef.nativeElement.querySelector('[tabindex="0"]');
                    if (focusEl) {
                        focusEl.focus();
                    }
                }
            });
        });
    }
}
DatepickerFocusService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DatepickerFocusService.ctorParameters = () => [
    { type: NgZone },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service extracts the Angular CLDR data needed by the datepicker.
 */
class LocaleHelperService {
    /**
     * @param {?} locale
     */
    constructor(locale) {
        this.locale = locale;
        this._firstDayOfWeek = 0;
        this.initializeLocaleData();
    }
    /**
     * @return {?}
     */
    get firstDayOfWeek() {
        return this._firstDayOfWeek;
    }
    /**
     * @return {?}
     */
    get localeDaysNarrow() {
        return this._localeDaysNarrow;
    }
    /**
     * @return {?}
     */
    get localeMonthsAbbreviated() {
        return this._localeMonthsAbbreviated;
    }
    /**
     * @return {?}
     */
    get localeMonthsWide() {
        return this._localeMonthsWide;
    }
    /**
     * @return {?}
     */
    get localeDateFormat() {
        return this._localeDateFormat;
    }
    /**
     * Initializes the locale data.
     * @return {?}
     */
    initializeLocaleData() {
        // Order in which these functions is called is very important.
        this.initializeFirstDayOfWeek();
        this.initializeLocaleDateFormat();
        this.initializeLocaleMonthsAbbreviated();
        this.initializeLocaleMonthsWide();
        this.initializeLocaleDaysNarrow();
    }
    /**
     * Initialize day names in the TranslationWidth.Narrow format based on the locale.
     * eg: [S, M, T...] for en-US.
     * @return {?}
     */
    initializeLocaleDaysNarrow() {
        // Get locale day names starting with Sunday
        /** @type {?} */
        const tempArr = getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Narrow).slice();
        // Get first day of the week based on the locale
        /** @type {?} */
        const firstDayOfWeek = this.firstDayOfWeek;
        // Rearrange the tempArr to start with the first day of the week based on the locale.
        if (firstDayOfWeek > 0) {
            /** @type {?} */
            const prevDays = tempArr.splice(0, firstDayOfWeek);
            tempArr.push(...prevDays);
        }
        this._localeDaysNarrow = tempArr;
    }
    /**
     * Initializes the array of month names in the TranslationWidth.Abbreviated format.
     * e.g. `[Jan, Feb, ...]` for en-US
     * @return {?}
     */
    initializeLocaleMonthsAbbreviated() {
        this._localeMonthsAbbreviated = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated).slice();
    }
    /**
     * Initializes the array of month names in the TranslationWidth.Wide format.
     * e.g. `[January, February, ...]` for en-US
     * @return {?}
     */
    initializeLocaleMonthsWide() {
        this._localeMonthsWide = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Wide).slice();
    }
    /**
     * Initializes the first day of the week based on the locale.
     * @return {?}
     */
    initializeFirstDayOfWeek() {
        this._firstDayOfWeek = getLocaleFirstDayOfWeek(this.locale);
    }
    /**
     * @return {?}
     */
    initializeLocaleDateFormat() {
        this._localeDateFormat = getLocaleDateFormat(this.locale, FormatWidth.Short);
    }
}
LocaleHelperService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LocaleHelperService.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrCalendar {
    /**
     * @param {?} _localeHelperService
     * @param {?} _dateNavigationService
     * @param {?} _datepickerFocusService
     * @param {?} _elRef
     */
    constructor(_localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
        this._localeHelperService = _localeHelperService;
        this._dateNavigationService = _dateNavigationService;
        this._datepickerFocusService = _datepickerFocusService;
        this._elRef = _elRef;
        this._subs = [];
        this.generateCalendarView();
        this.initializeSubscriptions();
    }
    /**
     * Gets the locale days according to the TranslationWidth.Narrow format.
     * @return {?}
     */
    get localeDaysNarrow() {
        return this._localeHelperService.localeDaysNarrow;
    }
    /**
     * @return {?}
     */
    get calendar() {
        return this._dateNavigationService.displayedCalendar;
    }
    /**
     * @return {?}
     */
    get selectedDay() {
        return this._dateNavigationService.selectedDay;
    }
    /**
     * @return {?}
     */
    get focusedDay() {
        return this._dateNavigationService.focusedDay;
    }
    /**
     * @return {?}
     */
    get today() {
        return this._dateNavigationService.today;
    }
    /**
     * Initialize subscriptions to:
     * 1. update the calendar view model.
     * 2. update the focusable day in the calendar view model.
     * 3. focus on the focusable day in the calendar.
     * @return {?}
     */
    initializeSubscriptions() {
        this._subs.push(this._dateNavigationService.displayedCalendarChange.subscribe(() => {
            this.generateCalendarView();
        }));
        this._subs.push(this._dateNavigationService.focusedDayChange.subscribe((focusedDay) => {
            this.calendarViewModel.updateFocusableDay(focusedDay);
        }));
        this._subs.push(this._dateNavigationService.focusOnCalendarChange.subscribe(() => {
            this._datepickerFocusService.focusCell(this._elRef);
        }));
    }
    /**
     * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
     * @return {?}
     */
    generateCalendarView() {
        this.calendarViewModel = new CalendarViewModel(this.calendar, this.selectedDay, this.focusedDay, this.today, this._localeHelperService.firstDayOfWeek);
    }
    /**
     * Delegates Keyboard arrow navigation to the DateNavigationService.
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        if (event && this.focusedDay) {
            switch (event.keyCode) {
                case UP_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(-1 * NO_OF_DAYS_IN_A_WEEK);
                    break;
                case DOWN_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(NO_OF_DAYS_IN_A_WEEK);
                    break;
                case LEFT_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(-1);
                    break;
                case RIGHT_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(1);
                    break;
                default:
                    break; // No default case. TSLint x-(
            }
        }
    }
    /**
     * Focuses on the focusable day when the Calendar View is initialized.
     * @return {?}
     */
    ngAfterViewInit() {
        this._datepickerFocusService.focusCell(this._elRef);
    }
    /**
     * Unsubscribe from subscriptions.
     * @return {?}
     */
    ngOnDestroy() {
        this._subs.forEach((sub) => sub.unsubscribe());
    }
}
ClrCalendar.decorators = [
    { type: Component, args: [{ selector: 'clr-calendar', template: "<table class=\"calendar-table weekdays\">\n    <tr class=\"calendar-row\">\n        <td *ngFor=\"let day of localeDaysNarrow\" class=\"calendar-cell weekday\">\n            {{day}}\n        </td>\n    </tr>\n</table>\n<table\n    class=\"calendar-table calendar-dates\">\n    <tr class=\"calendar-row\" *ngFor=\"let row of calendarViewModel.calendarView\">\n        <td *ngFor=\"let dayView of row\" class=\"calendar-cell\">\n            <clr-day [clrDayView]=\"dayView\"></clr-day>\n        </td>\n    </tr>\n</table>\n" }] }
];
/** @nocollapse */
ClrCalendar.ctorParameters = () => [
    { type: LocaleHelperService },
    { type: DateNavigationService },
    { type: DatepickerFocusService },
    { type: ElementRef }
];
ClrCalendar.propDecorators = {
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class FocusService {
    constructor() {
        this._focused = new BehaviorSubject(false);
    }
    /**
     * @return {?}
     */
    get focusChange() {
        return this._focused.asObservable();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    set focused(state$$1) {
        this._focused.next(state$$1);
    }
}
FocusService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DateFormControlService {
    constructor() {
        this._touchedChange = new Subject();
        this._dirtyChange = new Subject();
    }
    /**
     * @return {?}
     */
    get touchedChange() {
        return this._touchedChange.asObservable();
    }
    /**
     * @return {?}
     */
    get dirtyChange() {
        return this._dirtyChange.asObservable();
    }
    /**
     * @return {?}
     */
    markAsTouched() {
        this._touchedChange.next();
    }
    /**
     * @return {?}
     */
    markAsDirty() {
        this._dirtyChange.next();
    }
}
DateFormControlService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DateIOService {
    /**
     * @param {?} _localeHelperService
     */
    constructor(_localeHelperService) {
        this._localeHelperService = _localeHelperService;
        this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
        this.localeDisplayFormat = LITTLE_ENDIAN;
        this.delimiters = ['/', '/'];
        this.cldrLocaleDateFormat = this._localeHelperService.localeDateFormat;
        this.initializeLocaleDisplayFormat();
    }
    /**
     * @return {?}
     */
    initializeLocaleDisplayFormat() {
        /** @type {?} */
        const format = this.cldrLocaleDateFormat.toLocaleLowerCase();
        if (LITTLE_ENDIAN_REGEX.test(format)) {
            this.localeDisplayFormat = LITTLE_ENDIAN;
        }
        else if (MIDDLE_ENDIAN_REGEX.test(format)) {
            this.localeDisplayFormat = MIDDLE_ENDIAN;
        }
        else {
            // everything else is set to BIG-ENDIAN FORMAT
            this.localeDisplayFormat = BIG_ENDIAN;
        }
        this.extractDelimiters();
    }
    /**
     * @return {?}
     */
    extractDelimiters() {
        if (this.cldrLocaleDateFormat) {
            // Sanitize Date Format. Remove RTL characters.
            // FIXME: When we support RTL, remove this and handle it correctly.
            /** @type {?} */
            const localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, '');
            /** @type {?} */
            const delimiters = localeFormat.split(DELIMITER_REGEX);
            // NOTE: The split from the CLDR date format should always result
            // in an arary with 4 elements. The 1st and the 2nd values are the delimiters
            // we will use in order.
            // Eg: "dd/MM/y".split(/d+|m+|y+/i) results in ["", "/", "/", ""]
            if (delimiters && delimiters.length === 4) {
                this.delimiters = [delimiters[1], delimiters[2]];
            }
            else {
                console.error('Unexpected date format received. Delimiters extracted: ', delimiters);
            }
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    toLocaleDisplayFormatString(date) {
        if (date) {
            if (isNaN(date.getTime())) {
                return '';
            }
            /** @type {?} */
            const dateNo = date.getDate();
            /** @type {?} */
            const monthNo = date.getMonth() + 1;
            /** @type {?} */
            const dateStr = dateNo > 9 ? dateNo.toString() : '0' + dateNo;
            /** @type {?} */
            const monthStr = monthNo > 9 ? monthNo.toString() : '0' + monthNo;
            if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
            }
            else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
            }
            else {
                return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
            }
        }
        return '';
    }
    /**
     * @return {?}
     */
    get placeholderText() {
        /** @type {?} */
        const format = this.localeDisplayFormat.format;
        return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
    }
    /**
     * Checks if the month entered by the user is valid or not.
     * Note: Month is 0 based.
     * @param {?} month
     * @return {?}
     */
    isValidMonth(month) {
        return month > -1 && month < 12;
    }
    /**
     * Checks if the date is valid depending on the year and month provided.
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    isValidDate(year, month, date) {
        return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
    }
    /**
     * Validates the parameters provided and returns the date.
     * If the parameters are not
     * valid then return null.
     * NOTE: (Month here is 1 based since the user has provided that as an input)
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    validateAndGetDate(year, month, date) {
        // I don't know whats wrong with the TS compiler. It throws an error if I write
        // the below if statement. The error is:
        // Operator '!==' cannot be applied to types '2' and '4'
        // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
        /*
            if (year.length !== 2 || year.length !== 4) {
                return null;
            }
            */
        // I don't know whats wrong with the TS compiler. It throws an error if I write
        // the below if statement. The error is:
        // Operator '!==' cannot be applied to types '2' and '4'
        // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
        /*
                if (year.length !== 2 || year.length !== 4) {
                    return null;
                }
                */
        // Instead I have to write the logic like this x-(
        /** @type {?} */
        const y = +year;
        /** @type {?} */
        const m = +month - 1;
        // month is 0 based
        /** @type {?} */
        const d = +date;
        if (!this.isValidMonth(m) || !this.isValidDate(y, m, d)) {
            return null;
        }
        /** @type {?} */
        const result = parseToFourDigitYear(y);
        return result !== -1 ? new Date(result, m, d) : null;
    }
    /**
     * Checks if the input provided by the user is valid.
     * @param {?} date
     * @return {?}
     */
    isValidInput(date) {
        if (!date) {
            return null;
        }
        /** @type {?} */
        const dateParts = date.match(USER_INPUT_REGEX);
        if (!dateParts || dateParts.length !== 3) {
            return null;
        }
        const [firstPart, secondPart, thirdPart] = dateParts;
        if (this.localeDisplayFormat === LITTLE_ENDIAN) {
            // secondPart is month && firstPart is date
            return this.validateAndGetDate(thirdPart, secondPart, firstPart);
        }
        else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
            // firstPart is month && secondPart is date
            return this.validateAndGetDate(thirdPart, firstPart, secondPart);
        }
        else {
            // secondPart is month && thirdPart is date
            return this.validateAndGetDate(firstPart, secondPart, thirdPart);
        }
    }
}
DateIOService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DateIOService.ctorParameters = () => [
    { type: LocaleHelperService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
// iPad mini screen width
// http://stephen.io/mediaqueries/#iPadMini
/** @type {?} */
const DATEPICKER_ENABLE_BREAKPOINT = 768;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatepickerEnabledService {
    /**
     * @param {?} _document
     */
    constructor(_document) {
        this._document = _document;
        this._isUserAgentMobile = false;
        if (this._document) {
            this._isUserAgentMobile = MOBILE_USERAGENT_REGEX.test(_document.defaultView.navigator.userAgent);
            this._innerWidth = _document.defaultView.innerWidth;
        }
    }
    /**
     * Returns if the calendar should be active or not.
     * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
     * then the calendar is inactive.
     * @return {?}
     */
    get isEnabled() {
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
        // What they recommend is:
        //"In summary, we recommend looking for the string 'Mobi'
        // anywhere in the User Agent to detect a mobile device."
        if (this._document) {
            if (this._innerWidth < DATEPICKER_ENABLE_BREAKPOINT && this._isUserAgentMobile) {
                return false;
            }
        }
        return true;
    }
}
DatepickerEnabledService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DatepickerEnabledService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This component contains two template for the old and new forms layouts.
 * When it is time to remove the old forms layouts support, remove the ng-templates
 * and ng-container, and just keep the inner content of the #newLayout as the template
 * and move the ng-content for clrDate.
 */
class ClrDateContainer {
    /**
     * @param {?} _ifOpenService
     * @param {?} _dateNavigationService
     * @param {?} _datepickerEnabledService
     * @param {?} dateFormControlService
     * @param {?} commonStrings
     * @param {?} ifErrorService
     * @param {?} focusService
     * @param {?} controlClassService
     * @param {?} layoutService
     * @param {?} newFormsLayout
     * @param {?} ngControlService
     */
    constructor(_ifOpenService, _dateNavigationService, _datepickerEnabledService, dateFormControlService, commonStrings, ifErrorService, focusService, controlClassService, layoutService, newFormsLayout, ngControlService) {
        this._ifOpenService = _ifOpenService;
        this._dateNavigationService = _dateNavigationService;
        this._datepickerEnabledService = _datepickerEnabledService;
        this.dateFormControlService = dateFormControlService;
        this.commonStrings = commonStrings;
        this.ifErrorService = ifErrorService;
        this.focusService = focusService;
        this.controlClassService = controlClassService;
        this.layoutService = layoutService;
        this.newFormsLayout = newFormsLayout;
        this.ngControlService = ngControlService;
        this._dynamic = false;
        this.invalid = false;
        this.focus = false;
        this.subscriptions = [];
        this.subscriptions.push(this._ifOpenService.openChange.subscribe(open => {
            if (open) {
                this.initializeCalendar();
            }
        }));
        this.subscriptions.push(this.focusService.focusChange.subscribe(state$$1 => {
            this.focus = state$$1;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.control = control;
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            this.invalid = invalid;
        }));
    }
    /**
     * Returns the classes to apply to the control
     * @return {?}
     */
    controlClass() {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    }
    /**
     * Determines if the control needs to add grid classes
     * @return {?}
     */
    addGrid() {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    }
    /**
     * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
     * @return {?}
     */
    get isEnabled() {
        return this._datepickerEnabledService.isEnabled;
    }
    /**
     * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
     * @return {?}
     */
    initializeCalendar() {
        this._dateNavigationService.initializeCalendar();
    }
    /**
     * Toggles the Datepicker Popover.
     * @param {?} event
     * @return {?}
     */
    toggleDatepicker(event) {
        this._ifOpenService.toggleWithEvent(event);
        this.dateFormControlService.markAsTouched();
    }
    /**
     * Unsubscribe from subscriptions.
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.map(sub => sub.unsubscribe());
    }
}
ClrDateContainer.decorators = [
    { type: Component, args: [{
                selector: 'clr-date-container',
                template: `
    <ng-template #oldLayout>
        <ng-content></ng-content>
        <ng-container *ngTemplateOutlet="clrDate"></ng-container>
        <button
            type="button"
            class="datepicker-trigger"
            (click)="toggleDatepicker($event)"
            *ngIf="isEnabled">
            <clr-icon shape="calendar" class="datepicker-trigger-icon" [attr.title]="commonStrings.open"></clr-icon>
        </button>
        <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>
    </ng-template>
    
    <ng-template #newLayout>
      <ng-content select="label"></ng-content>
      <div class="clr-control-container" [ngClass]="controlClass()">
        <div class="clr-input-wrapper">
          <div class="clr-input-group" [class.clr-focus]="focus">
            <ng-container *ngTemplateOutlet="clrDate"></ng-container>
            <button type="button" class="datepicker-trigger" (click)="toggleDatepicker($event)" *ngIf="isEnabled" [attr.title]="commonStrings.open" [disabled]="control?.disabled">
              <clr-icon shape="calendar" class="clr-input-group-icon-action"></clr-icon>
            </button>
            <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>
          </div>
          <clr-icon class="clr-validate-icon" shape="exclamation-circle"></clr-icon>
        </div>
        <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
        <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
      </div>
    </ng-template>
    
    <ng-template #clrDate>
      <ng-content select="[clrDate]"></ng-content>
    </ng-template>
    
    <ng-container *ngIf="newFormsLayout; then newLayout else oldLayout"></ng-container>
    `,
                providers: [
                    ControlIdService,
                    IfOpenService,
                    LocaleHelperService,
                    IfErrorService,
                    ControlClassService,
                    FocusService,
                    NgControlService,
                    DateIOService,
                    DateNavigationService,
                    DatepickerEnabledService,
                    DateFormControlService,
                ],
                host: {
                    '[class.date-container]': '!newFormsLayout',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-form-control]': 'newFormsLayout',
                }
            }] }
];
/** @nocollapse */
ClrDateContainer.ctorParameters = () => [
    { type: IfOpenService },
    { type: DateNavigationService },
    { type: DatepickerEnabledService },
    { type: DateFormControlService },
    { type: ClrCommonStrings },
    { type: IfErrorService },
    { type: FocusService },
    { type: ControlClassService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [IS_NEW_FORMS_LAYOUT,] }] },
    { type: NgControlService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDateInput extends WrappedFormControl {
    /**
     * @param {?} vcr
     * @param {?} injector
     * @param {?} el
     * @param {?} renderer
     * @param {?} control
     * @param {?} container
     * @param {?} _dateIOService
     * @param {?} _dateNavigationService
     * @param {?} _datepickerEnabledService
     * @param {?} dateFormControlService
     * @param {?} platformId
     * @param {?} focusService
     * @param {?} newFormsLayout
     */
    constructor(vcr, injector, el, renderer, control, container, _dateIOService, _dateNavigationService, _datepickerEnabledService, dateFormControlService, platformId, focusService, newFormsLayout) {
        super(vcr, ClrDateContainer, injector, control, renderer, el);
        this.el = el;
        this.renderer = renderer;
        this.control = control;
        this.container = container;
        this._dateIOService = _dateIOService;
        this._dateNavigationService = _dateNavigationService;
        this._datepickerEnabledService = _datepickerEnabledService;
        this.dateFormControlService = dateFormControlService;
        this.platformId = platformId;
        this.focusService = focusService;
        this.newFormsLayout = newFormsLayout;
        this.index = 4;
        //We need this variable because if the date input has a value initialized
        //we do not output it. This variable is false during initial load. We make sure that
        //during initial load dayModelOutputted is equal to the value entered by the user so that initialized
        //value isn't emitted back to the user. After initial load,
        //we set this to true and the dayModelOutputted is set only
        //when the Output is emitted to the user.
        this.previousOutputInitializedFlag = false;
        this.initialLoad = true;
        //
        // Output Management
        // Note: For now we will not emit both clrDateChange and ngControl outputs
        // at the same time. This requires us to listen to keydown and blur events to figure out
        // exactly when the Output should be emitted.
        // Our recommendation right now is to either use clrDate or use ngModel/FormControl.
        // Do not use both of them together.
        //
        this._dateUpdated = new EventEmitter(false);
    }
    /**
     * @param {?} dayModel
     * @return {?}
     */
    initializePreviousOutput(dayModel) {
        if (!this.previousOutputInitializedFlag) {
            this.previousOutput = dayModel;
            this.previousOutputInitializedFlag = true;
        }
    }
    /**
     * 1. Populate services if the date container is not present.
     * 2. Initialize Subscriptions.
     * 3. Process User Input.
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (!this.container) {
            this.populateContainerServices();
        }
        this.initializeSubscriptions();
        this.processInitialInputs();
        if (this.clrNewLayout !== undefined) {
            this.newFormsLayout = !!this.clrNewLayout;
        }
    }
    /**
     * Process the inputs initialized by the user which were missed
     * because of late subscriptions or lifecycle method calls.
     * @return {?}
     */
    processInitialInputs() {
        this.processUserDateObject(this.dateValueOnInitialLoad);
        // Handle Inital Value from Reactive Forms
        // TODO: We are repeating this logic at multiple places. This makes me think
        // if this class should have implemented the ControlValueAccessor interface.
        // Will explore that later and see if its a cleaner solution.
        if (this.control && this.control.value) {
            this.updateInputValue(this.control.value);
            this.initializePreviousOutput(this._dateNavigationService.selectedDay);
        }
    }
    /**
     * Write the initial input set by the user on to the input field.
     * @return {?}
     */
    ngAfterViewInit() {
        // I don't know why I have to do this but after using the new HostWrapping Module I have to delay the processing
        // of the initial Input set by the user to here.  If I do not 2 issues occur:
        // 1. the Input setter is called before ngOnInit. ngOnInit initializes the services without which the setter
        // fails
        // 2. The Renderer doesn't work before ngAfterViewInit
        //(It used to before the new HostWrapping Module for some reason).
        // I need the renderer to set the value property on the input to make sure that if the user has supplied a Date
        // input object,  we reflect it with the right date on the input field using the IO service.  I am not sure if
        // these are major issues or not but just noting them down here.
        if (this._dateNavigationService) {
            /** @type {?} */
            const selDay = this._dateNavigationService.selectedDay;
            if (selDay) {
                /** @type {?} */
                const dateStr = this._dateIOService.toLocaleDisplayFormatString(selDay.toDate());
                this.writeDateStrToInputField(dateStr);
            }
        }
        this.initialLoad = false;
    }
    /**
     * Populates the services from the container component.
     * @return {?}
     */
    populateContainerServices() {
        this._dateIOService = this.getProviderFromContainer(DateIOService);
        this._dateNavigationService = this.getProviderFromContainer(DateNavigationService);
        this._datepickerEnabledService = this.getProviderFromContainer(DatepickerEnabledService);
        this.dateFormControlService = this.getProviderFromContainer(DateFormControlService);
    }
    /**
     * Writes the date string value to the input field
     * @param {?} value
     * @return {?}
     */
    writeDateStrToInputField(value) {
        this.renderer.setProperty(this.el.nativeElement, 'value', value);
    }
    /**
     * Javascript Date object input set by the user.
     * @param {?} value
     * @return {?}
     */
    set date(value) {
        if (this.initialLoad) {
            // Store date value passed by the user to process after the services have been initialized by
            // the ngOnInit hook.
            this.dateValueOnInitialLoad = value;
        }
        else {
            this.processUserDateObject(value);
        }
    }
    /**
     * Processes a date object to check if its valid or not.
     * @param {?} value
     * @return {?}
     */
    processUserDateObject(value) {
        if (this._dateIOService) {
            // The date object is converted back to string because in Javascript you can create a date object
            // like this: new Date("Test"). This is a date object but it is invalid. Converting the date object
            // that the user passed helps us to verify the validity of the date object.
            /** @type {?} */
            const dateStr = this._dateIOService.toLocaleDisplayFormatString(value);
            this.updateInputValue(dateStr);
        }
    }
    /**
     * @param {?} dateStr
     * @return {?}
     */
    updateInputValue(dateStr) {
        /** @type {?} */
        const date = this._dateIOService.isValidInput(dateStr);
        if (date) {
            /** @type {?} */
            const dayModel = new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
            if (!dayModel.isEqual(this._dateNavigationService.selectedDay)) {
                this._dateNavigationService.selectedDay = dayModel;
                this.writeDateStrToInputField(dateStr);
            }
        }
        else {
            this._dateNavigationService.selectedDay = null;
        }
    }
    /**
     * Returns the date format for the placeholder according to which the input should be entered by the user.
     * @return {?}
     */
    get placeholderText() {
        return this.placeholder ? this.placeholder : this._dateIOService.placeholderText;
    }
    /**
     * Sets the input type to text when the datepicker is enabled. Reverts back to the native date input
     * when the datepicker is disabled. Datepicker is disabled on mobiles.
     * @return {?}
     */
    get inputType() {
        return isPlatformBrowser(this.platformId) && this._datepickerEnabledService.isEnabled ? 'text' : 'date';
    }
    /**
     * @param {?} dayModel
     * @return {?}
     */
    emitDateOutput(dayModel) {
        if (dayModel && !dayModel.isEqual(this.previousOutput)) {
            this._dateUpdated.emit(dayModel.toDate());
            this.previousOutput = dayModel;
        }
        else if (!dayModel && this.previousOutput) {
            this._dateUpdated.emit(null);
            this.previousOutput = null;
        }
    }
    /**
     * @return {?}
     */
    setFocusStates() {
        if (this.focusService) {
            this.focusService.focused = true;
        }
    }
    /**
     * @return {?}
     */
    triggerValidation() {
        super.triggerValidation();
        if (this.focusService) {
            this.focusService.focused = false;
        }
    }
    /**
     * Fires this method when the user changes the input focuses out of the input field.
     * @param {?} target
     * @return {?}
     */
    onValueChange(target) {
        /** @type {?} */
        const value = target.value;
        /** @type {?} */
        const date = this._dateIOService.isValidInput(value);
        if (date) {
            /** @type {?} */
            const dayModel = new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
            this._dateNavigationService.selectedDay = dayModel;
            this.emitDateOutput(dayModel);
        }
        else {
            this._dateNavigationService.selectedDay = null;
            this.emitDateOutput(null);
        }
    }
    /**
     * Initialize DateIO Subscriptions
     * @return {?}
     */
    initializeSubscriptions() {
        if (this._dateNavigationService && this._dateIOService) {
            // This subscription is fired when the user selects a date from the popover.
            this.subscriptions.push(this._dateNavigationService.selectedDayChange.subscribe((dayModel) => {
                /** @type {?} */
                const dateStr = this._dateIOService.toLocaleDisplayFormatString(dayModel.toDate());
                this.writeDateStrToInputField(dateStr);
                // This makes sure that ngModelChange is fired
                // TODO: Check if there is a better way to do this.
                // NOTE: Its important to use NgControl and not NgModel because
                // NgModel only works with template driven forms
                if (this.control) {
                    this.control.control.setValue(dateStr);
                }
                this.emitDateOutput(dayModel);
            }));
            // We do not emit an Output from this subscription because
            // we only emit the Output when the user has focused out of the input.
            if (this.control) {
                this.subscriptions.push(this.control.valueChanges.subscribe((value) => {
                    /** @type {?} */
                    const date = this._dateIOService.isValidInput(value);
                    if (date) {
                        /** @type {?} */
                        const dayModel = new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
                        this._dateNavigationService.selectedDay = dayModel;
                        this.initializePreviousOutput(dayModel);
                    }
                    else if (value === '' || value === null) {
                        this._dateNavigationService.selectedDay = null;
                        this.initializePreviousOutput(null);
                    }
                    else {
                        this.initializePreviousOutput(null);
                    }
                }));
            }
        }
        if (this.dateFormControlService) {
            this.subscriptions.push(this.dateFormControlService.touchedChange.subscribe(() => {
                if (this.control) {
                    this.control.control.markAsTouched();
                }
            }));
            this.subscriptions.push(this.dateFormControlService.dirtyChange.subscribe(() => {
                if (this.control) {
                    this.control.control.markAsDirty();
                }
            }));
        }
    }
}
ClrDateInput.decorators = [
    { type: Directive, args: [{
                selector: '[clrDate]',
                host: {
                    '[class.date-input]': '!newFormsLayout',
                    '[class.clr-input]': 'newFormsLayout',
                },
            },] }
];
/** @nocollapse */
ClrDateInput.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: ClrDateContainer, decorators: [{ type: Optional }] },
    { type: DateIOService, decorators: [{ type: Optional }] },
    { type: DateNavigationService, decorators: [{ type: Optional }] },
    { type: DatepickerEnabledService, decorators: [{ type: Optional }] },
    { type: DateFormControlService, decorators: [{ type: Optional }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: FocusService, decorators: [{ type: Optional }] },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [IS_NEW_FORMS_LAYOUT,] }] }
];
ClrDateInput.propDecorators = {
    clrNewLayout: [{ type: Input }],
    date: [{ type: Input, args: ['clrDate',] }],
    placeholder: [{ type: Input }],
    placeholderText: [{ type: HostBinding, args: ['attr.placeholder',] }],
    inputType: [{ type: HostBinding, args: ['attr.type',] }],
    _dateUpdated: [{ type: Output, args: ['clrDateChange',] }],
    setFocusStates: [{ type: HostListener, args: ['focus',] }],
    triggerValidation: [{ type: HostListener, args: ['blur',] }],
    onValueChange: [{ type: HostListener, args: ['change', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// Literally any annotation would work here, but writing our own @HoneyBadger annotation feels overkill.
/**
 * @abstract
 */
class AbstractPopover {
    /**
     * @param {?} injector
     * @param {?} parentHost
     */
    constructor(injector, parentHost) {
        this.parentHost = parentHost;
        this.updateAnchor = false;
        this.popoverOptions = {};
        /*
             * Until https://github.com/angular/angular/issues/8785 is supported, we don't have any way to instantiate
             * a separate directive on the host. So let's do dirty but performant for now.
             */
        this.closeOnOutsideClick = false;
        this.el = injector.get(ElementRef);
        this.ifOpenService = injector.get(IfOpenService);
        this.renderer = injector.get(Renderer2);
        // Default anchor is the parent host
        this.anchorElem = parentHost.nativeElement;
        this.popoverInstance = new Popover(this.el.nativeElement);
        this.subscription = this.ifOpenService.openChange.subscribe(change => {
            if (change) {
                this.anchor();
                this.attachESCListener();
            }
            else {
                this.release();
                this.detachESCListener();
            }
        });
        if (this.ifOpenService.open) {
            this.anchor();
            this.attachESCListener();
        }
    }
    /**
     * @return {?}
     */
    anchor() {
        this.updateAnchor = true;
        // Ugh
        this.ignore = this.ifOpenService.originalEvent;
    }
    /**
     * @return {?}
     */
    release() {
        this.detachOutsideClickListener();
        this.popoverInstance.release();
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.updateAnchor) {
            this.updateAnchor = false;
            this.popoverInstance
                .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                .subscribe(() => {
                // if a scroll event is detected, close the popover
                this.ifOpenService.open = false;
            });
            this.attachOutsideClickListener();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.release();
        this.detachESCListener();
        this.subscription.unsubscribe();
    }
    /*
         * Fallback to hide when *clrIfOpen is not being used
         */
    /**
     * @return {?}
     */
    get isOffScreen() {
        return this.ifOpenService.open ? false : true;
    }
    /**
     * @return {?}
     */
    attachESCListener() {
        this.documentESCListener = this.renderer.listen('document', 'keydown', event => {
            if (event && event.keyCode === ESC) {
                this.ifOpenService.open = false;
            }
        });
    }
    /**
     * @return {?}
     */
    detachESCListener() {
        if (this.documentESCListener) {
            this.documentESCListener();
            delete this.documentESCListener;
        }
    }
    /**
     * @return {?}
     */
    attachOutsideClickListener() {
        if (this.closeOnOutsideClick) {
            this.hostClickListener = this.renderer.listen(this.el.nativeElement, 'click', event => (this.ignore = event));
            if (this.ignoredElement) {
                this.ignoredElementClickListener = this.renderer.listen(this.ignoredElement, 'click', event => (this.ignore = event));
            }
            this.documentClickListener = this.renderer.listen('document', 'click', event => {
                if (event === this.ignore) {
                    delete this.ignore;
                }
                else {
                    this.ifOpenService.open = false;
                }
            });
        }
    }
    /**
     * @return {?}
     */
    detachOutsideClickListener() {
        if (this.closeOnOutsideClick) {
            if (this.hostClickListener) {
                this.hostClickListener();
                delete this.hostClickListener;
            }
            if (this.ignoredElementClickListener) {
                this.ignoredElementClickListener();
                delete this.ignoredElementClickListener;
            }
            if (this.documentClickListener) {
                this.documentClickListener();
                delete this.documentClickListener;
            }
        }
    }
}
AbstractPopover.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AbstractPopover.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef, decorators: [{ type: SkipSelf }] }
];
AbstractPopover.propDecorators = {
    isOffScreen: [{ type: HostBinding, args: ['class.is-off-screen',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service manages which view is visible in the datepicker popover.
 */
class ViewManagerService {
    constructor() {
        this._currentView = "DAYVIEW" /* DAYVIEW */;
    }
    /**
     * @return {?}
     */
    get isDayView() {
        return this._currentView === "DAYVIEW" /* DAYVIEW */;
    }
    /**
     * @return {?}
     */
    get isYearView() {
        return this._currentView === "YEARVIEW" /* YEARVIEW */;
    }
    /**
     * @return {?}
     */
    get isMonthView() {
        return this._currentView === "MONTHVIEW" /* MONTHVIEW */;
    }
    /**
     * @return {?}
     */
    changeToMonthView() {
        this._currentView = "MONTHVIEW" /* MONTHVIEW */;
    }
    /**
     * @return {?}
     */
    changeToYearView() {
        this._currentView = "YEARVIEW" /* YEARVIEW */;
    }
    /**
     * @return {?}
     */
    changeToDayView() {
        this._currentView = "DAYVIEW" /* DAYVIEW */;
    }
}
ViewManagerService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatepickerViewManager extends AbstractPopover {
    /**
     * @param {?} parent
     * @param {?} _injector
     * @param {?} _viewManagerService
     */
    constructor(parent, _injector, _viewManagerService) {
        super(_injector, parent);
        this._viewManagerService = _viewManagerService;
        this.configurePopover();
    }
    /**
     * Configure Popover Direction and Close indicators
     * @return {?}
     */
    configurePopover() {
        this.anchorPoint = Point.BOTTOM_LEFT;
        this.popoverPoint = Point.LEFT_TOP;
        this.closeOnOutsideClick = true;
    }
    /**
     * Returns if the current view is the monthpicker.
     * @return {?}
     */
    get isMonthView() {
        return this._viewManagerService.isMonthView;
    }
    /**
     * Returns if the current view is the yearpicker.
     * @return {?}
     */
    get isYearView() {
        return this._viewManagerService.isYearView;
    }
    /**
     * Returns if the current view is the daypicker.
     * @return {?}
     */
    get isDayView() {
        return this._viewManagerService.isDayView;
    }
}
ClrDatepickerViewManager.decorators = [
    { type: Component, args: [{
                selector: 'clr-datepicker-view-manager',
                template: "<!--\n* Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n* This software is released under MIT license.\n* The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<clr-monthpicker *ngIf=\"isMonthView\"></clr-monthpicker>\n<clr-yearpicker *ngIf=\"isYearView\"></clr-yearpicker>\n<clr-daypicker *ngIf=\"isDayView\"></clr-daypicker>\n",
                providers: [ViewManagerService, DatepickerFocusService],
                host: { '[class.datepicker]': 'true' }
            }] }
];
/** @nocollapse */
ClrDatepickerViewManager.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: SkipSelf }] },
    { type: Injector },
    { type: ViewManagerService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDay {
    /**
     * @param {?} _dateNavigationService
     * @param {?} _ifOpenService
     * @param {?} dateFormControlService
     */
    constructor(_dateNavigationService, _ifOpenService, dateFormControlService) {
        this._dateNavigationService = _dateNavigationService;
        this._ifOpenService = _ifOpenService;
        this.dateFormControlService = dateFormControlService;
    }
    /**
     * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
     * @return {?}
     */
    onDayViewFocus() {
        this._dateNavigationService.focusedDay = this.dayView.dayModel;
    }
    /**
     * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
     * @return {?}
     */
    selectDay() {
        /** @type {?} */
        const day = this.dayView.dayModel;
        this._dateNavigationService.notifySelectedDayChanged(day);
        this.dateFormControlService.markAsDirty();
        this._ifOpenService.open = false;
    }
}
ClrDay.decorators = [
    { type: Component, args: [{
                selector: 'clr-day',
                template: `
        <button
            class="day-btn"
            type="button"
            [class.is-today]="dayView.isTodaysDate"
            [class.is-disabled]="dayView.isDisabled"
            [class.is-selected]="dayView.isSelected"
            [attr.tabindex]="dayView.tabIndex"
            (click)="selectDay()"
            (focus)="onDayViewFocus()">
            {{dayView.dayModel.date}}
        </button>
    `,
                host: { '[class.day]': 'true' }
            }] }
];
/** @nocollapse */
ClrDay.ctorParameters = () => [
    { type: DateNavigationService },
    { type: IfOpenService },
    { type: DateFormControlService }
];
ClrDay.propDecorators = {
    dayView: [{ type: Input, args: ['clrDayView',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDaypicker {
    /**
     * @param {?} _viewManagerService
     * @param {?} _dateNavigationService
     * @param {?} _localeHelperService
     * @param {?} commonStrings
     */
    constructor(_viewManagerService, _dateNavigationService, _localeHelperService, commonStrings) {
        this._viewManagerService = _viewManagerService;
        this._dateNavigationService = _dateNavigationService;
        this._localeHelperService = _localeHelperService;
        this.commonStrings = commonStrings;
    }
    /**
     * Calls the ViewManagerService to change to the monthpicker view.
     * @return {?}
     */
    changeToMonthView() {
        this._viewManagerService.changeToMonthView();
    }
    /**
     * Calls the ViewManagerService to change to the yearpicker view.
     * @return {?}
     */
    changeToYearView() {
        this._viewManagerService.changeToYearView();
    }
    /**
     * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
     * @return {?}
     */
    get calendarMonth() {
        return this._localeHelperService.localeMonthsAbbreviated[this._dateNavigationService.displayedCalendar.month];
    }
    /**
     * Returns the year value of the calendar.
     * @return {?}
     */
    get calendarYear() {
        return this._dateNavigationService.displayedCalendar.year;
    }
    /**
     * Calls the DateNavigationService to move to the next month.
     * @return {?}
     */
    nextMonth() {
        this._dateNavigationService.moveToNextMonth();
    }
    /**
     * Calls the DateNavigationService to move to the previous month.
     * @return {?}
     */
    previousMonth() {
        this._dateNavigationService.moveToPreviousMonth();
    }
    /**
     * Calls the DateNavigationService to move to the current month.
     * @return {?}
     */
    currentMonth() {
        this._dateNavigationService.moveToCurrentMonth();
    }
}
ClrDaypicker.decorators = [
    { type: Component, args: [{ selector: 'clr-daypicker', template: "<div class=\"calendar-header\">\n    <div class=\"calendar-pickers\">\n        <button class=\"calendar-btn monthpicker-trigger\" type=\"button\" (click)=\"changeToMonthView()\">\n            {{calendarMonth}}\n        </button>\n        <button class=\"calendar-btn yearpicker-trigger\" type=\"button\" (click)=\"changeToYearView()\">\n            {{calendarYear}}\n        </button>\n    </div>\n    <div class=\"calendar-switchers\">\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"previousMonth()\">\n            <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n        </button>\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"currentMonth()\">\n            <clr-icon shape=\"event\" [attr.title]=\"commonStrings.current\"></clr-icon>\n        </button>\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"nextMonth()\">\n            <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n<clr-calendar></clr-calendar>\n", host: { '[class.daypicker]': 'true' } }] }
];
/** @nocollapse */
ClrDaypicker.ctorParameters = () => [
    { type: ViewManagerService },
    { type: DateNavigationService },
    { type: LocaleHelperService },
    { type: ClrCommonStrings }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrMonthpicker {
    /**
     * @param {?} _viewManagerService
     * @param {?} _localeHelperService
     * @param {?} _dateNavigationService
     * @param {?} _datepickerFocusService
     * @param {?} _elRef
     */
    constructor(_viewManagerService, _localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
        this._viewManagerService = _viewManagerService;
        this._localeHelperService = _localeHelperService;
        this._dateNavigationService = _dateNavigationService;
        this._datepickerFocusService = _datepickerFocusService;
        this._elRef = _elRef;
        this._focusedMonthIndex = this.calendarMonthIndex;
    }
    /**
     * Gets the months array which is used to rendered the monthpicker view.
     * Months are in the TranslationWidth.Wide format.
     * @return {?}
     */
    get monthNames() {
        return this._localeHelperService.localeMonthsWide;
    }
    /**
     * Gets the month value of the Calendar.
     * @return {?}
     */
    get calendarMonthIndex() {
        return this._dateNavigationService.displayedCalendar.month;
    }
    /**
     * Calls the DateNavigationService to update the month value of the calendar.
     * Also changes the view to the daypicker.
     * @param {?} monthIndex
     * @return {?}
     */
    changeMonth(monthIndex) {
        this._dateNavigationService.changeMonth(monthIndex);
        this._viewManagerService.changeToDayView();
    }
    /**
     * Compares the month passed to the focused month and returns the tab index.
     * @param {?} monthIndex
     * @return {?}
     */
    getTabIndex(monthIndex) {
        return monthIndex === this._focusedMonthIndex ? 0 : -1;
    }
    /**
     * Handles the Keyboard arrow navigation for the monthpicker.
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        // NOTE: Didn't move this to the date navigation service because
        // the logic is fairly simple and it didn't make sense for me
        // to create extra observables just to move this logic to the service.
        if (event) {
            /** @type {?} */
            const keyCode = event.keyCode;
            if (keyCode === UP_ARROW && this._focusedMonthIndex > 0) {
                event.preventDefault();
                this._focusedMonthIndex--;
                this._datepickerFocusService.focusCell(this._elRef);
            }
            else if (keyCode === DOWN_ARROW && this._focusedMonthIndex < 11) {
                event.preventDefault();
                this._focusedMonthIndex++;
                this._datepickerFocusService.focusCell(this._elRef);
            }
            else if (keyCode === RIGHT_ARROW && this._focusedMonthIndex < 6) {
                event.preventDefault();
                this._focusedMonthIndex = this._focusedMonthIndex + 6;
                this._datepickerFocusService.focusCell(this._elRef);
            }
            else if (keyCode === LEFT_ARROW && this._focusedMonthIndex > 5) {
                event.preventDefault();
                this._focusedMonthIndex = this._focusedMonthIndex - 6;
                this._datepickerFocusService.focusCell(this._elRef);
            }
        }
    }
    /**
     * Focuses on the current calendar month when the View is initialized.
     * @return {?}
     */
    ngAfterViewInit() {
        this._datepickerFocusService.focusCell(this._elRef);
    }
}
ClrMonthpicker.decorators = [
    { type: Component, args: [{
                selector: 'clr-monthpicker',
                template: `
        <button
            type="button"
            class="calendar-btn month"
            *ngFor="let month of monthNames; let monthIndex = index"
            (click)="changeMonth(monthIndex)"
            [class.is-selected]="monthIndex === calendarMonthIndex"
            [attr.tabindex]="getTabIndex(monthIndex)">
            {{month}}
        </button>
    `,
                host: {
                    '[class.monthpicker]': 'true',
                }
            }] }
];
/** @nocollapse */
ClrMonthpicker.ctorParameters = () => [
    { type: ViewManagerService },
    { type: LocaleHelperService },
    { type: DateNavigationService },
    { type: DatepickerFocusService },
    { type: ElementRef }
];
ClrMonthpicker.propDecorators = {
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @type {?} */
const YEARS_TO_DISPLAY = 10;
class YearRangeModel {
    /**
     * @param {?} year
     */
    constructor(year) {
        this.year = year;
        this.yearRange = [];
        this.generateYearRange();
    }
    /**
     * Gets the number in the middle of the range.
     * @return {?}
     */
    get middleYear() {
        return this.yearRange[Math.floor(this.yearRange.length / 2)];
    }
    /**
     * Generates the year range based on the year parameter.
     * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
     * @return {?}
     */
    generateYearRange() {
        /** @type {?} */
        const remainder = this.year % YEARS_TO_DISPLAY;
        /** @type {?} */
        const floor = this.year - remainder;
        /** @type {?} */
        const ceil = floor + YEARS_TO_DISPLAY;
        this.yearRange = this.generateRange(floor, ceil);
    }
    /**
     * Function which generate a range of numbers from floor to ceil.
     * @param {?} floor
     * @param {?} ceil
     * @return {?}
     */
    generateRange(floor, ceil) {
        return Array.from({ length: ceil - floor }, (v, k) => k + floor);
    }
    /**
     * Generates the YearRangeModel for the next decade.
     * @return {?}
     */
    nextDecade() {
        return new YearRangeModel(this.year + 10);
    }
    /**
     * Generates the YearRangeModel for the previous decade.
     * @return {?}
     */
    previousDecade() {
        return new YearRangeModel(this.year - 10);
    }
    /**
     * Generates the YearRangeModel for the current decade.
     * @return {?}
     */
    currentDecade() {
        return new YearRangeModel(new Date().getFullYear());
    }
    /**
     * Checks if the value is in the YearRangeModel.
     * @param {?} value
     * @return {?}
     */
    inRange(value) {
        return this.yearRange.indexOf(value) > -1;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrYearpicker {
    /**
     * @param {?} _dateNavigationService
     * @param {?} _viewManagerService
     * @param {?} _datepickerFocusService
     * @param {?} _elRef
     * @param {?} commonStrings
     */
    constructor(_dateNavigationService, _viewManagerService, _datepickerFocusService, _elRef, commonStrings) {
        this._dateNavigationService = _dateNavigationService;
        this._viewManagerService = _viewManagerService;
        this._datepickerFocusService = _datepickerFocusService;
        this._elRef = _elRef;
        this.commonStrings = commonStrings;
        this.yearRangeModel = new YearRangeModel(this.calendarYear);
        this._focusedYear = this.calendarYear;
    }
    /**
     * Gets the year which the user is currently on.
     * @return {?}
     */
    get calendarYear() {
        return this._dateNavigationService.displayedCalendar.year;
    }
    /**
     * Increments the focus year by the value passed. Updates the YearRangeModel if the
     * new value is not in the current decade.
     * @param {?} value
     * @return {?}
     */
    incrementFocusYearBy(value) {
        this._focusedYear = this._focusedYear + value;
        if (!this.yearRangeModel.inRange(this._focusedYear)) {
            if (value > 0) {
                this.yearRangeModel = this.yearRangeModel.nextDecade();
            }
            else {
                this.yearRangeModel = this.yearRangeModel.previousDecade();
            }
        }
        this._datepickerFocusService.focusCell(this._elRef);
    }
    /**
     * Calls the DateNavigationService to update the year value of the calendar.
     * Also changes the view to the daypicker.
     * @param {?} year
     * @return {?}
     */
    changeYear(year) {
        this._dateNavigationService.changeYear(year);
        this._viewManagerService.changeToDayView();
    }
    /**
     * Updates the YearRangeModel to the previous decade.
     * @return {?}
     */
    previousDecade() {
        this.yearRangeModel = this.yearRangeModel.previousDecade();
        // Year in the yearpicker is not focused because while navigating to a different decade,
        // you want the focus to remain on the decade switcher arrows.
    }
    /**
     * Updates the YearRangeModel to the current decade.
     * @return {?}
     */
    currentDecade() {
        if (!this.yearRangeModel.inRange(this._dateNavigationService.today.year)) {
            this.yearRangeModel = this.yearRangeModel.currentDecade();
        }
        this._datepickerFocusService.focusCell(this._elRef);
    }
    /**
     * Updates the YearRangeModel to the next decade.
     * @return {?}
     */
    nextDecade() {
        this.yearRangeModel = this.yearRangeModel.nextDecade();
        // Year in the yearpicker is not focused because while navigating to a different decade,
        // you want the focus to remain on the decade switcher arrows.
    }
    /**
     * Compares the year passed to the focused year and returns the tab index.
     * @param {?} year
     * @return {?}
     */
    getTabIndex(year) {
        if (!this.yearRangeModel.inRange(this._focusedYear)) {
            if (this.yearRangeModel.inRange(this.calendarYear)) {
                this._focusedYear = this.calendarYear;
            }
            else {
                this._focusedYear = this.yearRangeModel.middleYear;
            }
        }
        return this._focusedYear === year ? 0 : -1;
    }
    /**
     * Handles the Keyboard arrow navigation for the yearpicker.
     * @param {?} event
     * @return {?}
     */
    onKeyDown(event) {
        // NOTE: Didn't move this to the date navigation service because
        // the logic is fairly simple and it didn't make sense for me
        // to create extra observables just to move this logic to the service.
        if (event) {
            /** @type {?} */
            const keyCode = event.keyCode;
            if (keyCode === UP_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(-1);
            }
            else if (keyCode === DOWN_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(1);
            }
            else if (keyCode === RIGHT_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(5);
            }
            else if (keyCode === LEFT_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(-5);
            }
        }
    }
    /**
     * Focuses on the current calendar year when the View is initialized.
     * @return {?}
     */
    ngAfterViewInit() {
        this._datepickerFocusService.focusCell(this._elRef);
    }
}
ClrYearpicker.decorators = [
    { type: Component, args: [{
                selector: 'clr-yearpicker',
                template: `
        <div class="year-switchers">
            <button class="calendar-btn switcher" type="button" (click)="previousDecade()">
                <clr-icon shape="angle" dir="left" [attr.title]="commonStrings.previous"></clr-icon>
            </button>
            <button class="calendar-btn switcher" type="button" (click)="currentDecade()">
                <clr-icon shape="event" [attr.title]="commonStrings.current"></clr-icon>
            </button>
            <button class="calendar-btn switcher" type="button" (click)="nextDecade()">
                <clr-icon shape="angle" dir="right" [attr.title]="commonStrings.next"></clr-icon>
            </button>
        </div>
        <div class="years">
            <button
                *ngFor="let year of yearRangeModel.yearRange"
                type="button"
                class="calendar-btn year"
                [attr.tabindex]="getTabIndex(year)"
                [class.is-selected]="year === calendarYear"
                (click)="changeYear(year)">
                {{year}}
            </button>
        </div>
    `,
                host: {
                    '[class.yearpicker]': 'true',
                }
            }] }
];
/** @nocollapse */
ClrYearpicker.ctorParameters = () => [
    { type: DateNavigationService },
    { type: ViewManagerService },
    { type: DatepickerFocusService },
    { type: ElementRef },
    { type: ClrCommonStrings }
];
ClrYearpicker.propDecorators = {
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_DATEPICKER_DIRECTIVES = [
    ClrDay,
    ClrDateContainer,
    ClrDateInput,
    ClrDatepickerViewManager,
    ClrMonthpicker,
    ClrYearpicker,
    ClrDaypicker,
    ClrCalendar,
];
class ClrDatepickerModule {
}
ClrDatepickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrHostWrappingModule, ClrConditionalModule, ClrIconModule, ClrFocusTrapModule],
                declarations: [CLR_DATEPICKER_DIRECTIVES],
                exports: [CLR_DATEPICKER_DIRECTIVES],
                entryComponents: [ClrDateContainer],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrInputContainer {
    /**
     * @param {?} ifErrorService
     * @param {?} layoutService
     * @param {?} controlClassService
     * @param {?} ngControlService
     */
    constructor(ifErrorService, layoutService, controlClassService, ngControlService) {
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.control = control;
        }));
    }
    /**
     * @return {?}
     */
    controlClass() {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    }
    /**
     * @return {?}
     */
    addGrid() {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.map(sub => sub.unsubscribe());
        }
    }
}
ClrInputContainer.decorators = [
    { type: Component, args: [{
                selector: 'clr-input-container',
                template: `
        <ng-content select="label"></ng-content>
        <label *ngIf="!label && addGrid()"></label>
        <div class="clr-control-container" [ngClass]="controlClass()">
            <div class="clr-input-wrapper">
                <ng-content select="[clrInput]"></ng-content>
                <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
            </div>
            <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
            <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
        </div>
    `,
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()',
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }] }
];
/** @nocollapse */
ClrInputContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: NgControlService }
];
ClrInputContainer.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrInput extends WrappedFormControl {
    /**
     * @param {?} vcr
     * @param {?} injector
     * @param {?} control
     * @param {?} renderer
     * @param {?} el
     */
    constructor(vcr, injector, control, renderer, el) {
        super(vcr, ClrInputContainer, injector, control, renderer, el);
        this.index = 1;
    }
}
ClrInput.decorators = [
    { type: Directive, args: [{ selector: '[clrInput]', host: { '[class.clr-input]': 'true' } },] }
];
/** @nocollapse */
ClrInput.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrInputModule {
}
ClrInputModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrInput, ClrInputContainer],
                exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer],
                entryComponents: [ClrInputContainer],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/* tslint:disable-next-line:variable-name */
/** @type {?} */
const ToggleService = new InjectionToken(undefined);
/* tslint:disable-next-line:variable-name */
/**
 * @return {?}
 */
function ToggleServiceProvider() {
    return new BehaviorSubject(false);
}
class ClrPasswordContainer {
    /**
     * @param {?} ifErrorService
     * @param {?} layoutService
     * @param {?} controlClassService
     * @param {?} focusService
     * @param {?} ngControlService
     * @param {?} toggleService
     * @param {?} commonStrings
     */
    constructor(ifErrorService, layoutService, controlClassService, focusService, ngControlService, toggleService, commonStrings) {
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.focusService = focusService;
        this.ngControlService = ngControlService;
        this.toggleService = toggleService;
        this.commonStrings = commonStrings;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.show = false;
        this.focus = false;
        this._toggle = true;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            this.invalid = invalid;
        }));
        this.subscriptions.push(this.focusService.focusChange.subscribe(state$$1 => {
            this.focus = state$$1;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.control = control;
        }));
    }
    /**
     * @param {?} state
     * @return {?}
     */
    set clrToggle(state$$1) {
        this._toggle = state$$1;
        if (!state$$1) {
            this.show = false;
        }
    }
    /**
     * @return {?}
     */
    get clrToggle() {
        return this._toggle;
    }
    /**
     * @return {?}
     */
    toggle() {
        this.show = !this.show;
        this.toggleService.next(this.show);
    }
    /**
     * @return {?}
     */
    controlClass() {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    }
    /**
     * @return {?}
     */
    addGrid() {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.map(sub => sub.unsubscribe());
        }
    }
}
ClrPasswordContainer.decorators = [
    { type: Component, args: [{
                selector: 'clr-password-container',
                template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrPassword]"></ng-content>
          <clr-icon *ngIf="!show && clrToggle"
            shape="eye" 
            class="clr-input-group-icon-action"
            [attr.title]="commonStrings.show"
            (click)="toggle()"></clr-icon>
          <clr-icon *ngIf="show && clrToggle" 
            shape="eye-hide"
            class="clr-input-group-icon-action"
            [attr.title]="commonStrings.hide"
            (click)="toggle()"></clr-icon>
        </div>
        <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
      <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
    </div>
    `,
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()',
                },
                providers: [
                    IfErrorService,
                    NgControlService,
                    ControlIdService,
                    ControlClassService,
                    FocusService,
                    { provide: ToggleService, useFactory: ToggleServiceProvider },
                ]
            }] }
];
/** @nocollapse */
ClrPasswordContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: FocusService },
    { type: NgControlService },
    { type: BehaviorSubject, decorators: [{ type: Inject, args: [ToggleService,] }] },
    { type: ClrCommonStrings }
];
ClrPasswordContainer.propDecorators = {
    clrToggle: [{ type: Input, args: ['clrToggle',] }],
    label: [{ type: ContentChild, args: [ClrLabel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrPassword extends WrappedFormControl {
    /**
     * @param {?} vcr
     * @param {?} injector
     * @param {?} control
     * @param {?} renderer
     * @param {?} el
     * @param {?} focusService
     * @param {?} toggleService
     */
    constructor(vcr, injector, control, renderer, el, focusService, toggleService) {
        super(vcr, ClrPasswordContainer, injector, control, renderer, el);
        this.focusService = focusService;
        this.toggleService = toggleService;
        this.index = 1;
        if (!this.focusService) {
            throw new Error('clrPassword requires being wrapped in <clr-password-container>');
        }
        this.subscriptions.push(this.toggleService.subscribe(toggle => {
            renderer.setProperty(el.nativeElement, 'type', toggle ? 'text' : 'password');
        }));
    }
    /**
     * @return {?}
     */
    triggerFocus() {
        if (this.focusService) {
            this.focusService.focused = true;
        }
    }
    /**
     * @return {?}
     */
    triggerValidation() {
        super.triggerValidation();
        if (this.focusService) {
            this.focusService.focused = false;
        }
    }
}
ClrPassword.decorators = [
    { type: Directive, args: [{ selector: '[clrPassword]', host: { '[class.clr-input]': 'true' } },] }
];
/** @nocollapse */
ClrPassword.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: FocusService, decorators: [{ type: Optional }] },
    { type: BehaviorSubject, decorators: [{ type: Optional }, { type: Inject, args: [ToggleService,] }] }
];
ClrPassword.propDecorators = {
    triggerFocus: [{ type: HostListener, args: ['focus',] }],
    triggerValidation: [{ type: HostListener, args: ['blur',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrPasswordModule {
}
ClrPasswordModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrPassword, ClrPasswordContainer],
                exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer],
                entryComponents: [ClrPasswordContainer],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrRadioWrapper {
    constructor() {
        // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
        // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
        // but we'd still need to insert a label
        this._dynamic = false;
    }
}
ClrRadioWrapper.decorators = [
    { type: Component, args: [{
                selector: 'clr-radio-wrapper',
                template: `
    <ng-content select="[clrRadio]"></ng-content>
    <ng-content select="label"></ng-content>
    <label *ngIf="!label"></label>
  `,
                host: {
                    '[class.clr-radio-wrapper]': 'true',
                },
                providers: [ControlIdService]
            }] }
];
ClrRadioWrapper.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrRadio extends WrappedFormControl {
    /**
     * @param {?} vcr
     * @param {?} injector
     * @param {?} control
     * @param {?} renderer
     * @param {?} el
     */
    constructor(vcr, injector, control, renderer, el) {
        super(vcr, ClrRadioWrapper, injector, control, renderer, el);
    }
}
ClrRadio.decorators = [
    { type: Directive, args: [{ selector: '[clrRadio]' },] }
];
/** @nocollapse */
ClrRadio.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrRadioContainer {
    /**
     * @param {?} ifErrorService
     * @param {?} layoutService
     * @param {?} controlClassService
     * @param {?} ngControlService
     */
    constructor(ifErrorService, layoutService, controlClassService, ngControlService) {
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this.inline = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.control = control;
        }));
    }
    /*
       * Here we want to support the following cases
       * clrInline - true by presence
       * clrInline="true|false" - unless it is explicitly false, strings are considered true
       * [clrInline]="true|false" - expect a boolean
       */
    /**
     * @param {?} value
     * @return {?}
     */
    set clrInline(value) {
        if (typeof value === 'string') {
            this.inline = value === 'false' ? false : true;
        }
        else {
            this.inline = !!value;
        }
    }
    /**
     * @return {?}
     */
    get clrInline() {
        return this.inline;
    }
    /**
     * @return {?}
     */
    controlClass() {
        return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
    }
    /**
     * @return {?}
     */
    addGrid() {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.map(sub => sub.unsubscribe());
    }
}
ClrRadioContainer.decorators = [
    { type: Component, args: [{
                selector: 'clr-radio-container',
                template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [class.clr-control-inline]="clrInline" [ngClass]="controlClass()">
      <ng-content select="clr-radio-wrapper"></ng-content>
      <div class="clr-subtext-wrapper">
        <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
        <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
        <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
      </div>
    </div>
    `,
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()',
                },
                providers: [NgControlService, ControlClassService, IfErrorService]
            }] }
];
/** @nocollapse */
ClrRadioContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: NgControlService }
];
ClrRadioContainer.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel,] }],
    clrInline: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrRadioModule {
}
ClrRadioModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
                declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                entryComponents: [ClrRadioWrapper],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrSelectContainer {
    /**
     * @param {?} ifErrorService
     * @param {?} layoutService
     * @param {?} controlClassService
     * @param {?} ngControlService
     */
    constructor(ifErrorService, layoutService, controlClassService, ngControlService) {
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.multi = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.multi = control.valueAccessor instanceof SelectMultipleControlValueAccessor;
            this.control = control;
        }));
    }
    /**
     * @return {?}
     */
    wrapperClass() {
        return this.multi ? 'clr-multiselect-wrapper' : 'clr-select-wrapper';
    }
    /**
     * @return {?}
     */
    controlClass() {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    }
    /**
     * @return {?}
     */
    addGrid() {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.map(sub => sub.unsubscribe());
        }
    }
}
ClrSelectContainer.decorators = [
    { type: Component, args: [{
                selector: 'clr-select-container',
                template: `    
        <ng-content select="label"></ng-content>
        <label *ngIf="!label && addGrid()"></label>
        <div class="clr-control-container" [ngClass]="controlClass()">
            <div [ngClass]="wrapperClass()">
                <ng-content select="[clrSelect]"></ng-content>
                <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
            </div>
            <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
            <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
        </div>
    `,
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()',
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }] }
];
/** @nocollapse */
ClrSelectContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: NgControlService }
];
ClrSelectContainer.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel,] }],
    multiple: [{ type: ContentChild, args: [SelectMultipleControlValueAccessor,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrSelect extends WrappedFormControl {
    /**
     * @param {?} vcr
     * @param {?} injector
     * @param {?} control
     * @param {?} renderer
     * @param {?} el
     */
    constructor(vcr, injector, control, renderer, el) {
        super(vcr, ClrSelectContainer, injector, control, renderer, el);
        this.index = 1;
    }
}
ClrSelect.decorators = [
    { type: Directive, args: [{ selector: '[clrSelect]', host: { '[class.clr-select]': 'true' } },] }
];
/** @nocollapse */
ClrSelect.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrSelectModule {
}
ClrSelectModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrSelect, ClrSelectContainer],
                exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer],
                entryComponents: [ClrSelectContainer],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTextareaContainer {
    /**
     * @param {?} ifErrorService
     * @param {?} layoutService
     * @param {?} controlClassService
     * @param {?} ngControlService
     */
    constructor(ifErrorService, layoutService, controlClassService, ngControlService) {
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(invalid => {
            this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(control => {
            this.control = control;
        }));
    }
    /**
     * @return {?}
     */
    controlClass() {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    }
    /**
     * @return {?}
     */
    addGrid() {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscriptions) {
            this.subscriptions.map(sub => sub.unsubscribe());
        }
    }
}
ClrTextareaContainer.decorators = [
    { type: Component, args: [{
                selector: 'clr-textarea-container',
                template: `
        <ng-content select="label"></ng-content>
        <label *ngIf="!label && addGrid()"></label>
        <div class="clr-control-container" [ngClass]="controlClass()">
            <div class="clr-textarea-wrapper">
                <ng-content select="[clrTextarea]"></ng-content>
                <clr-icon *ngIf="invalid" class="clr-validate-icon" shape="exclamation-circle" aria-hidden="true"></clr-icon>
            </div>
            <ng-content select="clr-control-helper" *ngIf="!invalid"></ng-content>
            <ng-content select="clr-control-error" *ngIf="invalid"></ng-content>
        </div>
    `,
                host: {
                    '[class.clr-form-control]': 'true',
                    '[class.clr-form-control-disabled]': 'control?.disabled',
                    '[class.clr-row]': 'addGrid()',
                },
                providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
            }] }
];
/** @nocollapse */
ClrTextareaContainer.ctorParameters = () => [
    { type: IfErrorService },
    { type: LayoutService, decorators: [{ type: Optional }] },
    { type: ControlClassService },
    { type: NgControlService }
];
ClrTextareaContainer.propDecorators = {
    label: [{ type: ContentChild, args: [ClrLabel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTextarea extends WrappedFormControl {
    /**
     * @param {?} vcr
     * @param {?} injector
     * @param {?} control
     * @param {?} renderer
     * @param {?} el
     */
    constructor(vcr, injector, control, renderer, el) {
        super(vcr, ClrTextareaContainer, injector, control, renderer, el);
        this.index = 1;
    }
}
ClrTextarea.decorators = [
    { type: Directive, args: [{ selector: '[clrTextarea]', host: { '[class.clr-textarea]': 'true' } },] }
];
/** @nocollapse */
ClrTextarea.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
    { type: Renderer2 },
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTextareaModule {
}
ClrTextareaModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                declarations: [ClrTextarea, ClrTextareaContainer],
                exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer],
                entryComponents: [ClrTextareaContainer],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrFormsModule {
}
ClrFormsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [
                    ClrCommonFormsModule,
                    ClrCheckboxModule,
                    ClrDatepickerModule,
                    ClrInputModule,
                    ClrPasswordModule,
                    ClrRadioModule,
                    ClrSelectModule,
                    ClrTextareaModule,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class Expand {
    constructor() {
        this.expandable = 0;
        // private _replace: boolean = false;
        this._replace = new BehaviorSubject(false);
        this._loading = false;
        this._expanded = false;
        // TODO: Move this to the datagrid RowExpand.
        // I spent some time doing this but ran into a couple of issues
        // Will take care of this later.
        this._animate = new Subject();
        this._expandChange = new Subject();
    }
    /**
     * @return {?}
     */
    get replace() {
        return this._replace.asObservable();
    }
    /**
     * @param {?} replaceValue
     * @return {?}
     */
    setReplace(replaceValue) {
        this._replace.next(replaceValue);
    }
    /**
     * @return {?}
     */
    get loading() {
        return this._loading;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set loading(value) {
        value = !!value;
        if (value !== this._loading) {
            this._loading = value;
        }
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this._expanded;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expanded(value) {
        value = !!value;
        if (value !== this._expanded) {
            this._expanded = value;
            this._animate.next();
            this._expandChange.next(value);
        }
    }
    /**
     * @return {?}
     */
    get animate() {
        return this._animate.asObservable();
    }
    /**
     * @return {?}
     */
    get expandChange() {
        return this._expandChange.asObservable();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    loadingStateChange(state$$1) {
        switch (state$$1) {
            case ClrLoadingState.LOADING:
                this.loading = true;
                break;
            default:
                this.loading = false;
                this._animate.next();
                break;
        }
    }
}
Expand.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * TODO: make this a reusable directive outside of Datagrid, like [clrLoading].
 */
class ClrIfExpanded {
    /**
     * @param {?} template
     * @param {?} container
     * @param {?} expand
     */
    constructor(template, container, expand) {
        this.template = template;
        this.container = container;
        this.expand = expand;
        this._expanded = false;
        this.expandedChange = new EventEmitter(true);
        /**
         * Subscriptions to all the services and queries changes
         */
        this._subscriptions = [];
        expand.expandable++;
        this._subscriptions.push(expand.expandChange.subscribe(() => {
            this.updateView();
            this.expandedChange.emit(this.expand.expanded);
        }));
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this._expanded;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expanded(value) {
        if (typeof value === 'boolean') {
            this.expand.expanded = value;
            this._expanded = value;
        }
    }
    /**
     * @return {?}
     */
    updateView() {
        if (this.expand.expanded && this.container.length !== 0) {
            return;
        }
        if (this.expand.expanded) {
            // Should we pass a context? I don't see anything useful to pass right now,
            // but we can come back to it in the future as a solution for additional features.
            this.container.createEmbeddedView(this.template);
        }
        else {
            // TODO: Move when we move the animation logic to Datagrid Row Expand
            // We clear before the animation is over. Not ideal, but doing better would involve a much heavier
            // process for very little gain. Once Angular animations are dynamic enough, we should be able to
            // get the optimal behavior.
            this.container.clear();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateView();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.expand.expandable--;
        this._subscriptions.forEach((sub) => sub.unsubscribe());
    }
}
ClrIfExpanded.decorators = [
    { type: Directive, args: [{ selector: '[clrIfExpanded]' },] }
];
/** @nocollapse */
ClrIfExpanded.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: Expand }
];
ClrIfExpanded.propDecorators = {
    expanded: [{ type: Input, args: ['clrIfExpanded',] }],
    expandedChange: [{ type: Output, args: ['clrIfExpandedChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const EXPAND_DIRECTIVES = [ClrIfExpanded];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrIfExpandModule {
}
ClrIfExpandModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], declarations: [EXPAND_DIRECTIVES], exports: [EXPAND_DIRECTIVES] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_LOADING_DIRECTIVES = [ClrLoading];
class ClrLoadingModule {
}
ClrLoadingModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], declarations: [CLR_LOADING_DIRECTIVES], exports: [CLR_LOADING_DIRECTIVES] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class OutsideClick {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
        this.strict = false;
        this.outsideClick = new EventEmitter(false);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    documentClick(event) {
        /** @type {?} */
        const target = event.target;
        // Get the element in the DOM on which the mouse was clicked
        /** @type {?} */
        const host = this.el.nativeElement;
        if (target === host) {
            return;
        }
        if (!this.strict && host.contains(target)) {
            return;
        }
        this.outsideClick.emit(event);
    }
}
OutsideClick.decorators = [
    { type: Directive, args: [{ selector: '[clrOutsideClick]' },] }
];
/** @nocollapse */
OutsideClick.ctorParameters = () => [
    { type: ElementRef }
];
OutsideClick.propDecorators = {
    strict: [{ type: Input, args: ['clrStrict',] }],
    outsideClick: [{ type: Output, args: ['clrOutsideClick',] }],
    documentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const OUSTIDE_CLICK_DIRECTIVES = [OutsideClick];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrOutsideClickModule {
}
ClrOutsideClickModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], declarations: [OUSTIDE_CLICK_DIRECTIVES], exports: [OUSTIDE_CLICK_DIRECTIVES] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DomAdapter {
    /**
     * @param {?} element
     * @return {?}
     */
    userDefinedWidth(element) {
        element.classList.add('datagrid-cell-width-zero');
        /** @type {?} */
        const userDefinedWidth = parseInt(getComputedStyle(element).getPropertyValue('width'), 10);
        element.classList.remove('datagrid-cell-width-zero');
        return userDefinedWidth;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    scrollBarWidth(element) {
        return element.offsetWidth - element.clientWidth;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    scrollWidth(element) {
        return element.scrollWidth || 0;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    computedHeight(element) {
        return parseInt(getComputedStyle(element).getPropertyValue('height'), 10);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    clientRect(element) {
        /** @type {?} */
        const elementClientRect = element.getBoundingClientRect();
        return {
            top: parseInt(elementClientRect.top, 10),
            bottom: parseInt(elementClientRect.bottom, 10),
            left: parseInt(elementClientRect.left, 10),
            right: parseInt(elementClientRect.right, 10),
            width: parseInt(elementClientRect.width, 10),
            height: parseInt(elementClientRect.height, 10),
        };
    }
    /**
     * @param {?} element
     * @return {?}
     */
    minWidth(element) {
        return parseInt(getComputedStyle(element).getPropertyValue('min-width'), 10);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    focus(element) {
        element.focus();
    }
}
DomAdapter.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatagridRowExpandAnimation {
    /**
     * @param {?} el
     * @param {?} domAdapter
     * @param {?} renderer
     * @param {?} expand
     */
    constructor(el, domAdapter, renderer, expand) {
        this.el = el;
        this.domAdapter = domAdapter;
        this.renderer = renderer;
        this.expand = expand;
        if (expand && expand.animate) {
            expand.animate.subscribe(() => {
                // We already had an animation waiting, so we just have to run in, not prepare again
                if (this.oldHeight) {
                    setTimeout(() => this.run());
                }
                else {
                    this.animate();
                }
            });
        }
    }
    /*
         * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
         * They're working on it, but have no ETA.
         */
    /**
     * @return {?}
     */
    animate() {
        // Check if we do have web-animations available. If not, just skip the animation.
        if (!this.el.nativeElement.animate) {
            return;
        }
        // We had an animation running, we skip to the end
        if (this.running) {
            this.running.finish();
        }
        this.oldHeight = this.domAdapter.computedHeight(this.el.nativeElement);
        // We set the height of the element immediately to avoid a flicker before the animation starts.
        this.renderer.setStyle(this.el.nativeElement, 'height', this.oldHeight + 'px');
        this.renderer.setStyle(this.el.nativeElement, 'overflow-y', 'hidden');
        setTimeout(() => {
            if (this.expand.loading) {
                return;
            }
            this.run();
        });
    }
    /**
     * @return {?}
     */
    run() {
        this.renderer.setStyle(this.el.nativeElement, 'height', null);
        /** @type {?} */
        const newHeight = this.domAdapter.computedHeight(this.el.nativeElement);
        this.running = this.el.nativeElement.animate({ height: [this.oldHeight + 'px', newHeight + 'px'], easing: 'ease-in-out' }, { duration: 200 });
        this.running.onfinish = () => {
            this.renderer.setStyle(this.el.nativeElement, 'overflow-y', null);
            delete this.running;
        };
        delete this.oldHeight;
    }
}
DatagridRowExpandAnimation.decorators = [
    { type: Directive, args: [{ selector: 'clr-dg-row' },] }
];
/** @nocollapse */
DatagridRowExpandAnimation.ctorParameters = () => [
    { type: ElementRef },
    { type: DomAdapter },
    { type: Renderer2 },
    { type: Expand }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * @abstract
 */
class CustomFilter {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * This provider implements some form of synchronous debouncing through a lock pattern
 * to avoid emitting multiple state changes for a single user action.
 */
class StateDebouncer {
    constructor() {
        /**
         * The Observable that lets other classes subscribe to global state changes
         */
        this._change = new Subject();
        /*
             * This is the lock, to only emit once all the changes have finished processing
             */
        this.nbChanges = 0;
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    /**
     * @return {?}
     */
    get change() {
        return this._change.asObservable();
    }
    /**
     * @return {?}
     */
    changeStart() {
        this.nbChanges++;
    }
    /**
     * @return {?}
     */
    changeDone() {
        if (--this.nbChanges === 0) {
            this._change.next();
        }
    }
}
StateDebouncer.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class Page {
    /**
     * @param {?} stateDebouncer
     */
    constructor(stateDebouncer) {
        this.stateDebouncer = stateDebouncer;
        /**
         * Page size, a value of 0 means no pagination
         */
        this._size = 0;
        /**
         * Total items (needed to guess the last page)
         */
        this._totalItems = 0;
        /**
         * The Observable that lets other classes subscribe to page changes
         */
        this._change = new Subject();
        this._sizeChange = new Subject();
        /**
         * Current page
         */
        this._current = 1;
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    set size(size) {
        /** @type {?} */
        const oldSize = this._size;
        if (size !== oldSize) {
            this.stateDebouncer.changeStart();
            this._size = size;
            if (size === 0) {
                this._current = 1;
            }
            else {
                // Yeap. That's the formula to keep the first item from the old page still
                // displayed in the new one.
                this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
            }
            // We always emit an event even if the current page index didn't change, because
            // the size changing means the items inside the page are different
            this._change.next(this._current);
            this._sizeChange.next(this._size);
            this.stateDebouncer.changeDone();
        }
    }
    /**
     * @return {?}
     */
    get totalItems() {
        return this._totalItems;
    }
    /**
     * @param {?} total
     * @return {?}
     */
    set totalItems(total) {
        this._totalItems = total;
        // If we have less items than before, we might need to change the current page
        if (this.current > this.last) {
            this.current = this.last;
        }
    }
    /**
     * @return {?}
     */
    get last() {
        if (this._last) {
            return this._last;
        }
        // If the last page isn't known, we compute it from the last item's index
        if (this.size > 0 && this.totalItems) {
            return Math.ceil(this.totalItems / this.size);
        }
        return 1;
    }
    /**
     * @param {?} page
     * @return {?}
     */
    set last(page) {
        this._last = page;
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    /**
     * @return {?}
     */
    get change() {
        return this._change.asObservable();
    }
    /**
     * @return {?}
     */
    get sizeChange() {
        return this._sizeChange.asObservable();
    }
    /**
     * @return {?}
     */
    get current() {
        return this._current;
    }
    /**
     * @param {?} page
     * @return {?}
     */
    set current(page) {
        if (page !== this._current) {
            this.stateDebouncer.changeStart();
            this._current = page;
            this._change.next(page);
            this.stateDebouncer.changeDone();
        }
    }
    /**
     * Moves to the previous page if it exists
     * @return {?}
     */
    previous() {
        if (this.current > 1) {
            this.current--;
        }
    }
    /**
     * Moves to the next page if it exists
     * @return {?}
     */
    next() {
        if (this.current < this.last) {
            this.current++;
        }
    }
    /**
     * Index of the first item displayed on the current page, starting at 0
     * @return {?}
     */
    get firstItem() {
        if (this.size === 0) {
            return 0;
        }
        return (this.current - 1) * this.size;
    }
    /**
     * Index of the last item displayed on the current page, starting at 0
     * @return {?}
     */
    get lastItem() {
        if (this.size === 0) {
            return this.totalItems - 1;
        }
        /** @type {?} */
        let lastInPage = this.current * this.size - 1;
        if (this.totalItems) {
            lastInPage = Math.min(lastInPage, this.totalItems - 1);
        }
        return lastInPage;
    }
    /**
     * Resets the page size to 0
     * @return {?}
     */
    resetPageSize() {
        this.size = 0;
    }
}
Page.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Page.ctorParameters = () => [
    { type: StateDebouncer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class FiltersProvider {
    /**
     * @param {?} _page
     * @param {?} stateDebouncer
     */
    constructor(_page, stateDebouncer) {
        this._page = _page;
        this.stateDebouncer = stateDebouncer;
        /**
         * This subject is the list of filters that changed last, not the whole list.
         * We emit a list rather than just one filter to allow batch changes to several at once.
         */
        this._change = new Subject();
        /**
         * List of all filters, whether they're active or not
         */
        this._all = [];
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    /**
     * @return {?}
     */
    get change() {
        return this._change.asObservable();
    }
    /**
     * Tests if at least one filter is currently active
     * @return {?}
     */
    hasActiveFilters() {
        // We do not use getActiveFilters() because this function will be called much more often
        // and stopping the loop early might be relevant.
        for (const { filter: filter$$1 } of this._all) {
            if (filter$$1 && filter$$1.isActive()) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns a list of all currently active filters
     * @return {?}
     */
    getActiveFilters() {
        /** @type {?} */
        const ret = [];
        for (const { filter: filter$$1 } of this._all) {
            if (filter$$1 && filter$$1.isActive()) {
                ret.push(filter$$1);
            }
        }
        return ret;
    }
    /**
     * Registers a filter, and returns a deregistration function
     * @template F
     * @param {?} filter
     * @return {?}
     */
    add(filter$$1) {
        /** @type {?} */
        const index = this._all.length;
        /** @type {?} */
        const subscription = filter$$1.changes.subscribe(() => this.resetPageAndEmitFilterChange([filter$$1]));
        /** @type {?} */
        let hasUnregistered = false;
        /** @type {?} */
        const registered = new RegisteredFilter(filter$$1, () => {
            if (hasUnregistered) {
                return;
            }
            subscription.unsubscribe();
            this._all.splice(index, 1);
            if (filter$$1.isActive()) {
                this.resetPageAndEmitFilterChange([]);
            }
            hasUnregistered = true;
        });
        this._all.push(registered);
        if (filter$$1.isActive()) {
            this.resetPageAndEmitFilterChange([filter$$1]);
        }
        return registered;
    }
    /**
     * Accepts an item if it is accepted by all currently active filters
     * @param {?} item
     * @return {?}
     */
    accepts(item) {
        for (const { filter: filter$$1 } of this._all) {
            if (filter$$1 && filter$$1.isActive() && !filter$$1.accepts(item)) {
                return false;
            }
        }
        return true;
    }
    /**
     * @param {?} filters
     * @return {?}
     */
    resetPageAndEmitFilterChange(filters) {
        this.stateDebouncer.changeStart();
        // filtering may change the page number such that current page number doesn't exist in the filtered dataset.
        // So here we always set the current page to 1 so that it'll fetch first page's data with the given filter.
        this._page.current = 1;
        this._change.next(filters);
        this.stateDebouncer.changeDone();
    }
}
FiltersProvider.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FiltersProvider.ctorParameters = () => [
    { type: Page },
    { type: StateDebouncer }
];
/**
 * @template T, F
 */
class RegisteredFilter {
    /**
     * @param {?} filter
     * @param {?} unregister
     */
    constructor(filter$$1, unregister) {
        this.filter = filter$$1;
        this.unregister = unregister;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T, F
 */
class DatagridFilterRegistrar {
    /**
     * @param {?} filters
     */
    constructor(filters) {
        this.filters = filters;
    }
    /**
     * @return {?}
     */
    get filter() {
        return this.registered && this.registered.filter;
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    setFilter(filter$$1) {
        // If we previously had another filter, we unregister it
        this.deleteFilter();
        if (filter$$1 instanceof RegisteredFilter) {
            this.registered = filter$$1;
        }
        else if (filter$$1) {
            this.registered = this.filters.add(filter$$1);
        }
    }
    /**
     * @return {?}
     */
    deleteFilter() {
        if (this.registered) {
            this.registered.unregister();
            delete this.registered;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.deleteFilter();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Custom filter that can be added in any column to override the default object property string filter.
 * The reason this is not just an input on DatagridColumn is because we need the filter's template to be projected,
 * since it can be anything (not just a text input).
 * @template T
 */
class ClrDatagridFilter extends DatagridFilterRegistrar {
    /**
     * @param {?} _filters
     * @param {?} commonStrings
     */
    constructor(_filters, commonStrings) {
        super(_filters);
        this.commonStrings = commonStrings;
        this.anchorPoint = Point.RIGHT_BOTTOM;
        this.popoverPoint = Point.RIGHT_TOP;
        this.popoverOptions = { allowMultipleOpen: true };
        /**
         * Tracks whether the filter dropdown is open or not
         */
        this._open = false;
        this.openChanged = new EventEmitter(false);
    }
    /**
     * @return {?}
     */
    get open() {
        return this._open;
    }
    /**
     * @param {?} open
     * @return {?}
     */
    set open(open) {
        /** @type {?} */
        const boolOpen = !!open;
        if (boolOpen !== this._open) {
            this._open = boolOpen;
            this.openChanged.emit(boolOpen);
        }
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    set customFilter(filter$$1) {
        this.setFilter(filter$$1);
    }
    /**
     * Indicates if the filter is currently active
     * @return {?}
     */
    get active() {
        return !!this.filter && this.filter.isActive();
    }
    /**
     * Shows/hides the filter dropdown
     * @return {?}
     */
    toggle() {
        this.open = !this.open;
    }
}
ClrDatagridFilter.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-filter',
                // We register this component as a CustomFilter, for the parent column to detect it.
                providers: [{ provide: CustomFilter, useExisting: ClrDatagridFilter }],
                template: `
        <button #anchor class="datagrid-filter-toggle" (click)="toggle()"
            [class.datagrid-filter-open]="open" [class.datagrid-filtered]="active"
            type="button"></button>

        <ng-template [(clrPopoverOld)]="open" [clrPopoverOldAnchor]="anchor" [clrPopoverOldAnchorPoint]="anchorPoint"
             [clrPopoverOldPopoverPoint]="popoverPoint" [clrPopoverOldOptions]="popoverOptions">
            <div class="datagrid-filter">
                <!-- FIXME: this whole filter part needs a final design before we can try to have a cleaner DOM -->
                <div class="datagrid-filter-close-wrapper">
                    <button type="button" class="close" (click)="open = false">
                        <clr-icon shape="close" [attr.title]="commonStrings.close"></clr-icon>
                    </button>
                </div>
    
                <ng-content></ng-content>
            </div>
        </ng-template>
    `
            }] }
];
/** @nocollapse */
ClrDatagridFilter.ctorParameters = () => [
    { type: FiltersProvider },
    { type: ClrCommonStrings }
];
ClrDatagridFilter.propDecorators = {
    open: [{ type: Input, args: ['clrDgFilterOpen',] }],
    openChanged: [{ type: Output, args: ['clrDgFilterOpenChange',] }],
    customFilter: [{ type: Input, args: ['clrDgFilter',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class DatagridStringFilterImpl {
    /**
     * @param {?} filterFn
     */
    constructor(filterFn) {
        this.filterFn = filterFn;
        /**
         * The Observable required as part of the Filter interface
         */
        this._changes = new Subject();
        /**
         * Raw input value
         */
        this._rawValue = '';
        /**
         * Input value converted to lowercase
         */
        this._lowerCaseValue = '';
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    /**
     * @return {?}
     */
    get changes() {
        return this._changes.asObservable();
    }
    /**
     * @return {?}
     */
    get value() {
        return this._rawValue;
    }
    /**
     * @return {?}
     */
    get lowerCaseValue() {
        return this._lowerCaseValue;
    }
    /**
     * Common setter for the input value
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._rawValue) {
            this._rawValue = value;
            this._lowerCaseValue = value.toLowerCase().trim();
            this._changes.next(value);
        }
    }
    /**
     * Indicates if the filter is currently active, meaning the input is not empty
     * @return {?}
     */
    isActive() {
        return !!this.value;
    }
    /**
     * Tests if an item matches a search text
     * @param {?} item
     * @return {?}
     */
    accepts(item) {
        // We always test with the lowercase value of the input, to stay case insensitive
        return this.filterFn.accepts(item, this.lowerCaseValue);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class DatagridStringFilter extends DatagridFilterRegistrar {
    /**
     * @param {?} filters
     * @param {?} domAdapter
     */
    constructor(filters, domAdapter) {
        super(filters);
        this.domAdapter = domAdapter;
        /**
         * Indicates if the filter dropdown is open
         */
        this.open = false;
        this.filterValueChange = new EventEmitter();
    }
    /**
     * Customizable filter logic based on a search text
     * @param {?} value
     * @return {?}
     */
    set customStringFilter(value) {
        if (value instanceof RegisteredFilter) {
            this.setFilter(value);
        }
        else {
            this.setFilter(new DatagridStringFilterImpl(value));
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.filterContainer.openChanged.subscribe((open) => {
            if (open) {
                // We need the timeout because at the time this executes, the input isn't
                // displayed yet.
                setTimeout(() => {
                    this.domAdapter.focus(this.input.nativeElement);
                });
            }
        });
    }
    /**
     * Common setter for the input value
     * @return {?}
     */
    get value() {
        return this.filter.value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!this.filter) {
            return;
        }
        if (!value) {
            value = '';
        }
        if (value !== this.filter.value) {
            this.filter.value = value;
            this.filterValueChange.emit(value);
        }
    }
    /**
     * @return {?}
     */
    close() {
        this.open = false;
    }
}
DatagridStringFilter.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-string-filter',
                providers: [{ provide: CustomFilter, useExisting: DatagridStringFilter }],
                template: `
        <clr-dg-filter [clrDgFilter]="registered" [(clrDgFilterOpen)]="open">
            <!--
                Even though this *ngIf looks useless because the filter container already has one,
                it prevents NgControlStatus and other directives automatically added by Angular
                on inputs with NgModel from freaking out because of their host binding changing
                mid-change detection when the input is destroyed.
            -->
            <input #input type="text" name="search" [(ngModel)]="value" *ngIf="open"
                (keyup.enter)="close()" (keyup.escape)="close()"/>
        </clr-dg-filter>
    `
            }] }
];
/** @nocollapse */
DatagridStringFilter.ctorParameters = () => [
    { type: FiltersProvider },
    { type: DomAdapter }
];
DatagridStringFilter.propDecorators = {
    customStringFilter: [{ type: Input, args: ['clrDgStringFilter',] }],
    input: [{ type: ViewChild, args: ['input',] }],
    filterContainer: [{ type: ViewChild, args: [ClrDatagridFilter,] }],
    value: [{ type: Input, args: ['clrFilterValue',] }],
    filterValueChange: [{ type: Output, args: ['clrFilterValueChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class OompaLoompa {
    // FIXME: Request Injector once we move to Angular 4.2+, it'll allow easier refactors
    /**
     * @param {?} cdr
     * @param {?} willyWonka
     */
    constructor(cdr, willyWonka) {
        this.subscription = willyWonka.chocolate.subscribe(() => {
            if (this.latestFlavor !== this.flavor) {
                cdr.detectChanges();
            }
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.latestFlavor = this.flavor;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RowActionService {
    constructor() {
        this.actionableCount = 0;
    }
    /**
     * @return {?}
     */
    register() {
        this.actionableCount++;
    }
    /**
     * @return {?}
     */
    unregister() {
        this.actionableCount--;
    }
    /**
     * false means no rows with action
     * @return {?}
     */
    get hasActionableRow() {
        return this.actionableCount > 0;
    }
}
RowActionService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
 * declarative API, we need to fight against change detection and its one-way flow. This is
 * currently the least dirty solution to do what we want.
 *
 * Do not modify or even use this class unless you know exactly what you're doing.
 * It has the potential to trigger change detection loops or kill app performances.
 */
class WillyWonka {
    constructor() {
        this._chocolate = new Subject();
    }
    /**
     * @return {?}
     */
    get chocolate() {
        return this._chocolate.asObservable();
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this._chocolate.next();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatagridWillyWonka extends WillyWonka {
}
DatagridWillyWonka.decorators = [
    { type: Directive, args: [{ selector: 'clr-datagrid' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ActionableOompaLoompa extends OompaLoompa {
    /**
     * @param {?} cdr
     * @param {?} willyWonka
     * @param {?} rowActions
     */
    constructor(cdr, willyWonka, rowActions) {
        if (!willyWonka) {
            throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
        }
        super(cdr, willyWonka);
        this.rowActions = rowActions;
    }
    /**
     * @return {?}
     */
    get flavor() {
        return this.rowActions.hasActionableRow;
    }
}
ActionableOompaLoompa.decorators = [
    { type: Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
];
/** @nocollapse */
ActionableOompaLoompa.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DatagridWillyWonka, decorators: [{ type: Optional }] },
    { type: RowActionService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ExpandableRowsCount {
    constructor() {
        this.expandableCount = 0;
    }
    /**
     * @return {?}
     */
    register() {
        this.expandableCount++;
    }
    /**
     * @return {?}
     */
    unregister() {
        this.expandableCount--;
    }
    /**
     * false means no rows with action
     * @return {?}
     */
    get hasExpandableRow() {
        return this.expandableCount > 0;
    }
}
ExpandableRowsCount.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ExpandableOompaLoompa extends OompaLoompa {
    /**
     * @param {?} cdr
     * @param {?} willyWonka
     * @param {?} expandableCount
     */
    constructor(cdr, willyWonka, expandableCount) {
        if (!willyWonka) {
            throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
        }
        super(cdr, willyWonka);
        this.expandableCount = expandableCount;
    }
    /**
     * @return {?}
     */
    get flavor() {
        return this.expandableCount.hasExpandableRow;
    }
}
ExpandableOompaLoompa.decorators = [
    { type: Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
];
/** @nocollapse */
ExpandableOompaLoompa.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DatagridWillyWonka, decorators: [{ type: Optional }] },
    { type: ExpandableRowsCount }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Generic accessor for deep object properties
 * that can be specified as simple dot-separated strings.
 * @template T
 */
class NestedProperty {
    /**
     * @param {?} prop
     */
    constructor(prop) {
        this.prop = prop;
        if (prop.indexOf('.') >= 0) {
            this.splitProp = prop.split('.');
        }
    }
    // Safe getter for a deep object property, will not throw an error but return
    // undefined if one of the intermediate properties is null or undefined.
    /**
     * @param {?} item
     * @return {?}
     */
    getPropValue(item) {
        if (this.splitProp) {
            /** @type {?} */
            let value = item;
            for (const nestedProp of this.splitProp) {
                if (value == null || typeof value === 'undefined' || typeof value[nestedProp] === 'undefined') {
                    return undefined;
                }
                value = value[nestedProp];
            }
            return value;
        }
        else {
            return item[this.prop];
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class DatagridPropertyComparator {
    /**
     * @param {?} prop
     */
    constructor(prop) {
        this.prop = prop;
        this.nestedProp = new NestedProperty(prop);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    compare(a, b) {
        /** @type {?} */
        let propA = this.nestedProp.getPropValue(a);
        /** @type {?} */
        let propB = this.nestedProp.getPropValue(b);
        if (typeof propA === 'string') {
            propA = propA.toLowerCase();
        }
        if (typeof propB === 'string') {
            propB = propB.toLowerCase();
        }
        if (typeof propA === 'undefined' || propA === null) {
            if (typeof propB === 'undefined' || propB === null) {
                return 0;
            }
            else {
                return 1;
            }
        }
        else {
            if (typeof propB === 'undefined' || propB === null) {
                return -1;
            }
            else if (propA < propB) {
                return -1;
            }
            else if (propA > propB) {
                return 1;
            }
            else {
                return 0;
            }
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class DatagridPropertyStringFilter {
    /**
     * @param {?} prop
     * @param {?=} exact
     */
    constructor(prop, exact = false) {
        this.prop = prop;
        this.exact = exact;
        this.nestedProp = new NestedProperty(prop);
    }
    /**
     * @param {?} item
     * @param {?} search
     * @return {?}
     */
    accepts(item, search) {
        /** @type {?} */
        const propValue = this.nestedProp.getPropValue(item);
        if (typeof propValue === 'undefined') {
            return false;
        }
        else if (this.exact) {
            return ('' + propValue).toLowerCase() === search;
        }
        else {
            return ('' + propValue).toLowerCase().indexOf(search) >= 0;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
const ClrDatagridSortOrder = {
    UNSORTED: 0,
    ASC: 1,
    DESC: -1,
};
ClrDatagridSortOrder[ClrDatagridSortOrder.UNSORTED] = 'UNSORTED';
ClrDatagridSortOrder[ClrDatagridSortOrder.ASC] = 'ASC';
ClrDatagridSortOrder[ClrDatagridSortOrder.DESC] = 'DESC';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DragDispatcher {
    /**
     * @param {?} _ngZone
     * @param {?} _renderer
     */
    constructor(_ngZone, _renderer) {
        this._ngZone = _ngZone;
        this._renderer = _renderer;
        this._onDragStart = new Subject();
        this._onDragMove = new Subject();
        this._onDragEnd = new Subject();
    }
    /**
     * @return {?}
     */
    get onDragStart() {
        return this._onDragStart;
    }
    /**
     * @return {?}
     */
    get onDragMove() {
        return this._onDragMove;
    }
    /**
     * @return {?}
     */
    get onDragEnd() {
        return this._onDragEnd;
    }
    /**
     * @return {?}
     */
    addDragListener() {
        /** @type {?} */
        const handleEl = this.handleRef.nativeElement;
        this._listeners = [
            this.customDragEvent(handleEl, 'mousedown', 'mousemove', 'mouseup'),
            this.customDragEvent(handleEl, 'touchstart', 'touchmove', 'touchend'),
        ];
    }
    /**
     * @param {?} element
     * @param {?} startOnEvent
     * @param {?} moveOnEvent
     * @param {?} endOnEvent
     * @return {?}
     */
    customDragEvent(element, startOnEvent, moveOnEvent, endOnEvent) {
        /** @type {?} */
        let dragMoveListener;
        /** @type {?} */
        let dragEndListener;
        return this._renderer.listen(element, startOnEvent, (startEvent) => {
            this.notifyDragStart(startEvent);
            dragMoveListener = this._ngZone.runOutsideAngular(() => {
                return this._renderer.listen('document', moveOnEvent, (moveEvent) => {
                    this.notifyDragMove(moveEvent);
                });
            });
            dragEndListener = this._renderer.listen('document', endOnEvent, (endEvent) => {
                // Unsubscribing from mouseMoveListener
                dragMoveListener();
                this.notifyDragEnd(endEvent);
                // Unsubscribing from itself
                dragEndListener();
            });
        });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    notifyDragStart(event) {
        return this._onDragStart.next(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    notifyDragMove(event) {
        return this._onDragMove.next(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    notifyDragEnd(event) {
        return this._onDragEnd.next(event);
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this._listeners) {
            this._listeners.map(event => event());
        }
    }
}
DragDispatcher.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DragDispatcher.ctorParameters = () => [
    { type: NgZone },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class Sort {
    /**
     * @param {?} stateDebouncer
     */
    constructor(stateDebouncer) {
        this.stateDebouncer = stateDebouncer;
        /**
         * Ascending order if false, descending if true
         */
        this._reverse = false;
        /**
         * The Observable that lets other classes subscribe to sort changes
         */
        this._change = new Subject();
    }
    /**
     * @return {?}
     */
    get comparator() {
        return this._comparator;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set comparator(value) {
        this.stateDebouncer.changeStart();
        this._comparator = value;
        this.emitChange();
        this.stateDebouncer.changeDone();
    }
    /**
     * @return {?}
     */
    get reverse() {
        return this._reverse;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set reverse(value) {
        this.stateDebouncer.changeStart();
        this._reverse = value;
        this.emitChange();
        this.stateDebouncer.changeDone();
    }
    /**
     * @return {?}
     */
    emitChange() {
        this._change.next(this);
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    /**
     * @return {?}
     */
    get change() {
        return this._change.asObservable();
    }
    /**
     * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
     * optional forceReverse input parameter allows to override that toggling behavior by sorting in
     * reverse order if `true`.
     *
     * \@memberof Sort
     * @param {?} sortBy
     * @param {?=} forceReverse
     * @return {?}
     */
    toggle(sortBy, forceReverse) {
        this.stateDebouncer.changeStart();
        // We modify private properties directly, to batch the change event
        if (this.comparator === sortBy) {
            this._reverse = typeof forceReverse !== 'undefined' ? forceReverse || !this._reverse : !this._reverse;
        }
        else {
            this._comparator = sortBy;
            this._reverse = typeof forceReverse !== 'undefined' ? forceReverse : false;
        }
        this.emitChange();
        this.stateDebouncer.changeDone();
    }
    /**
     * Clears the current sorting order
     * @return {?}
     */
    clear() {
        this.comparator = null;
    }
    /**
     * Compares two objects according to the current comparator
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    compare(a, b) {
        return (this.reverse ? -1 : 1) * this.comparator.compare(a, b);
    }
}
Sort.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Sort.ctorParameters = () => [
    { type: StateDebouncer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WrappedColumn {
    constructor() {
        this._dynamic = false;
    }
    // the columns projected view (in memory)
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Create the cells view in memory, not the DOM.
        this.columnView = this.templateRef.createEmbeddedView(null);
    }
}
WrappedColumn.decorators = [
    { type: Component, args: [{
                selector: 'dg-wrapped-column',
                template: `        
        <ng-template #columnPortal>
            <ng-content></ng-content>
        </ng-template>
    `
            }] }
];
WrappedColumn.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['columnPortal',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let nbCount = 0;
/**
 * @template T
 */
class ClrDatagridColumn extends DatagridFilterRegistrar {
    /**
     * @param {?} _sort
     * @param {?} filters
     * @param {?} _dragDispatcher
     * @param {?} vcr
     */
    constructor(_sort, filters, _dragDispatcher, vcr) {
        super(filters);
        this._sort = _sort;
        this._dragDispatcher = _dragDispatcher;
        this.vcr = vcr;
        // deprecated: to be removed - START
        /**
         * Indicates if the column is currently sorted
         *
         * @deprecated This will be removed soon, in favor of the sortOrder mechanism
         */
        this._sorted = false;
        /**
         * @deprecated This will be removed soon, in favor of the sortOrder mechanism
         */
        this.sortedChange = new EventEmitter();
        // deprecated: to be removed - END
        /**
         * Indicates how the column is currently sorted
         */
        this._sortOrder = ClrDatagridSortOrder.UNSORTED;
        this.sortOrderChange = new EventEmitter();
        /**
         * A custom filter for this column that can be provided in the projected content
         */
        this.customFilter = false;
        this.filterValueChange = new EventEmitter();
        this._sortSubscription = _sort.change.subscribe(sort => {
            // We're only listening to make sure we emit an event when the column goes from sorted to unsorted
            if (this.sortOrder !== ClrDatagridSortOrder.UNSORTED && sort.comparator !== this._sortBy) {
                this._sortOrder = ClrDatagridSortOrder.UNSORTED;
                this.sortOrderChange.emit(this._sortOrder);
            }
            // deprecated: to be removed - START
            if (this.sorted && sort.comparator !== this._sortBy) {
                this._sorted = false;
                this.sortedChange.emit(false);
            }
            // deprecated: to be removed - END
        });
        this.columnId = 'dg-col-' + nbCount.toString(); // Approximate a GUID
        nbCount++;
    }
    /**
     * \@property hidden
     *
     * \@description
     * A property that allows the column to be hidden / shown with css
     * Note the default allows the ClrDatagridColumn to have an *ngIf on it. (EHCAIWC - will occur if its not
     * initialized)
     *
     * \@default false
     *
     * @return {?}
     */
    get hidden() {
        return !!this.hideable && this.hideable.hidden;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set handleElRef(value) {
        this._dragDispatcher.handleRef = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set handleTrackerElRef(value) {
        this._dragDispatcher.handleTrackerRef = value;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._sortSubscription.unsubscribe();
    }
    /**
     * @return {?}
     */
    get field() {
        return this._field;
    }
    /**
     * @param {?} field
     * @return {?}
     */
    set field(field) {
        if (typeof field === 'string') {
            this._field = field;
            if (!this.customFilter) {
                this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
            }
            if (!this._sortBy) {
                this._sortBy = new DatagridPropertyComparator(field);
            }
        }
    }
    /**
     * @return {?}
     */
    get sortBy() {
        return this._sortBy;
    }
    /**
     * @param {?} comparator
     * @return {?}
     */
    set sortBy(comparator) {
        if (typeof comparator === 'string') {
            this._sortBy = new DatagridPropertyComparator(comparator);
        }
        else {
            if (comparator) {
                this._sortBy = comparator;
            }
            else {
                if (this._field) {
                    this._sortBy = new DatagridPropertyComparator(this._field);
                }
                else {
                    delete this._sortBy;
                }
            }
        }
    }
    /**
     * Indicates if the column is sortable
     * @return {?}
     */
    get sortable() {
        return !!this._sortBy;
    }
    /**
     * @return {?}
     */
    get sorted() {
        return this._sorted;
    }
    /**
     * @deprecated This will be removed soon, in favor of the sortOrder mechanism
     * @param {?} value
     * @return {?}
     */
    set sorted(value) {
        if (!value && this.sorted) {
            this._sorted = false;
            this._sort.clear();
        }
        else if (value && !this.sorted) {
            this.sort();
        }
    }
    /**
     * @return {?}
     */
    get sortOrder() {
        return this._sortOrder;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sortOrder(value) {
        if (typeof value === 'undefined') {
            return;
        }
        // only if the incoming order is different from the current one
        if (this._sortOrder === value) {
            return;
        }
        switch (value) {
            // the Unsorted case happens when the current state is either Asc or Desc
            default:
            case ClrDatagridSortOrder.UNSORTED:
                this._sort.clear();
                break;
            case ClrDatagridSortOrder.ASC:
                this.sort(false);
                break;
            case ClrDatagridSortOrder.DESC:
                this.sort(true);
                break;
        }
    }
    /**
     * @return {?}
     */
    get ariaSort() {
        switch (this._sortOrder) {
            default:
            case ClrDatagridSortOrder.UNSORTED:
                return 'none';
            case ClrDatagridSortOrder.ASC:
                return 'ascending';
            case ClrDatagridSortOrder.DESC:
                return 'descending';
        }
    }
    /**
     * Sorts the datagrid based on this column
     * @param {?=} reverse
     * @return {?}
     */
    sort(reverse) {
        if (!this.sortable) {
            return;
        }
        this._sort.toggle(this._sortBy, reverse);
        // setting the private variable to not retrigger the setter logic
        this._sortOrder = this._sort.reverse ? ClrDatagridSortOrder.DESC : ClrDatagridSortOrder.ASC;
        this.sortOrderChange.emit(this._sortOrder);
        // deprecated: to be removed - START
        this._sorted = true;
        this.sortedChange.emit(true);
        // deprecated: to be removed - END
    }
    /**
     * Indicates if the column is currently sorted in ascending order
     * @return {?}
     */
    get asc() {
        // deprecated: if condition to be removed - START
        if (typeof this.sortOrder === 'undefined') {
            return this.sorted && !this._sort.reverse;
        }
        else {
            return this.sortOrder === ClrDatagridSortOrder.ASC;
        }
        // deprecated: if condition to be removed - END
    }
    /**
     * Indicates if the column is currently sorted in descending order
     * @return {?}
     */
    get desc() {
        // deprecated: if condition to be removed - START
        if (typeof this.sortOrder === 'undefined') {
            return this.sorted && this._sort.reverse;
        }
        else {
            return this.sortOrder === ClrDatagridSortOrder.DESC;
        }
        // deprecated: if condition to be removed - END
    }
    /**
     * @param {?} custom
     * @return {?}
     */
    set projectedFilter(custom) {
        if (custom) {
            this.deleteFilter();
            this.customFilter = true;
        }
    }
    /**
     * @return {?}
     */
    get filterValue() {
        return this.filter.value;
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set updateFilterValue(newValue) {
        if (!this.filter) {
            return;
        }
        if (!newValue) {
            newValue = '';
        }
        if (newValue !== this.filter.value) {
            this.filter.value = newValue;
        }
    }
    /**
     * @param {?} newValue
     * @return {?}
     */
    set filterValue(newValue) {
        this.updateFilterValue = newValue;
        this.filterValueChange.emit(this.filter.value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.wrappedInjector = new HostWrapper(WrappedColumn, this.vcr);
    }
    /**
     * @return {?}
     */
    get _view() {
        return this.wrappedInjector.get(WrappedColumn, this.vcr).columnView;
    }
}
ClrDatagridColumn.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-column',
                template: `
        <div class="datagrid-column-flex">
            <!-- I'm really not happy with that select since it's not very scalable -->
            <ng-content select="clr-dg-filter, clr-dg-string-filter"></ng-content>

            <clr-dg-string-filter
                    *ngIf="field && !customFilter"
                    [clrDgStringFilter]="registered"
                    [(clrFilterValue)]="filterValue"></clr-dg-string-filter>

            <ng-template #columnTitle>
                <ng-content></ng-content>
            </ng-template>

            <button class="datagrid-column-title" *ngIf="sortable" (click)="sort()" type="button">
                <ng-container *ngTemplateOutlet="columnTitle"></ng-container>
            </button>

            <span class="datagrid-column-title" *ngIf="!sortable">
               <ng-container *ngTemplateOutlet="columnTitle"></ng-container>
            </span>

            <div class="datagrid-column-separator">
                <button #columnHandle class="datagrid-column-handle" tabindex="-1" type="button"></button>
                <div #columnHandleTracker class="datagrid-column-handle-tracker"></div>
            </div>
        </div>
    `,
                host: {
                    '[class.datagrid-column]': 'true',
                    '[class.datagrid-column--hidden]': 'hidden',
                    '[attr.aria-sort]': 'ariaSort',
                    role: 'columnheader',
                }
            }] }
];
/** @nocollapse */
ClrDatagridColumn.ctorParameters = () => [
    { type: Sort },
    { type: FiltersProvider },
    { type: DragDispatcher },
    { type: ViewContainerRef }
];
ClrDatagridColumn.propDecorators = {
    handleElRef: [{ type: ViewChild, args: ['columnHandle',] }],
    handleTrackerElRef: [{ type: ViewChild, args: ['columnHandleTracker',] }],
    field: [{ type: Input, args: ['clrDgField',] }],
    sortBy: [{ type: Input, args: ['clrDgSortBy',] }],
    sorted: [{ type: Input, args: ['clrDgSorted',] }],
    sortedChange: [{ type: Output, args: ['clrDgSortedChange',] }],
    sortOrder: [{ type: Input, args: ['clrDgSortOrder',] }],
    sortOrderChange: [{ type: Output, args: ['clrDgSortOrderChange',] }],
    asc: [{ type: HostBinding, args: ['class.asc',] }],
    desc: [{ type: HostBinding, args: ['class.desc',] }],
    projectedFilter: [{ type: ContentChild, args: [CustomFilter,] }],
    updateFilterValue: [{ type: Input, args: ['clrFilterValue',] }],
    filterValueChange: [{ type: Output, args: ['clrFilterValueChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class Items {
    /**
     * @param {?} _filters
     * @param {?} _sort
     * @param {?} _page
     */
    constructor(_filters, _sort, _page) {
        this._filters = _filters;
        this._sort = _sort;
        this._page = _page;
        /**
         * Indicates if the data is currently loading
         */
        this.loading = false;
        // TODO: Verify that trackBy is registered for the *ngFor case too
        /**
         * Tracking function to identify objects. Default is reference equality.
         */
        this.trackBy = (index, item) => item;
        /**
         * Whether we should use smart items for this datagrid or let the user handle
         * everything.
         */
        this._smart = false;
        /**
         * List of items currently displayed
         */
        this._displayed = [];
        /**
         * The Observable that lets other classes subscribe to items changes
         */
        this._change = new Subject();
        this._allChanges = new Subject();
    }
    /**
     * Cleans up our subscriptions to other providers
     * @return {?}
     */
    destroy() {
        if (this._filtersSub) {
            this._filtersSub.unsubscribe();
        }
        if (this._sortSub) {
            this._sortSub.unsubscribe();
        }
        if (this._pageSub) {
            this._pageSub.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    get smart() {
        return this._smart;
    }
    /**
     * @return {?}
     */
    smartenUp() {
        this._smart = true;
        /*
             * These observers trigger a chain of function: filter -> sort -> paginate
             * An observer up the chain re-triggers all the operations that follow it.
             */
        this._filtersSub = this._filters.change.subscribe(() => this._filterItems());
        this._sortSub = this._sort.change.subscribe(() => {
            // Special case, if the datagrid went from sorted to unsorted, we have to re-filter
            // to get the original order back
            if (!this._sort.comparator) {
                this._filterItems();
            }
            else {
                this._sortItems();
            }
        });
        this._pageSub = this._page.change.subscribe(() => this._changePage());
    }
    /**
     * @return {?}
     */
    get all() {
        return this._all;
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set all(items) {
        this._all = items;
        this.emitAllChanges(items);
        if (this.smart) {
            this._filterItems();
        }
        else {
            this._displayed = items;
            this.emitChange();
        }
    }
    /**
     * Manually recompute the list of displayed items
     * @return {?}
     */
    refresh() {
        if (this.smart) {
            this._filterItems();
        }
    }
    /**
     * @return {?}
     */
    get displayed() {
        // Ideally we could return an immutable array, but we don't have it in Clarity yet.
        return this._displayed;
    }
    /**
     * @return {?}
     */
    emitChange() {
        this._change.next(this.displayed);
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    /**
     * @return {?}
     */
    get change() {
        return this._change.asObservable();
    }
    /**
     * @param {?} items
     * @return {?}
     */
    emitAllChanges(items) {
        this._allChanges.next(items);
    }
    /**
     * @return {?}
     */
    get allChanges() {
        return this._allChanges.asObservable();
    }
    /**
     * Checks if we don't have data to process yet, to abort early operations
     * @return {?}
     */
    get uninitialized() {
        return !this._all;
    }
    /**
     * FiltersProvider items from the raw list
     * @return {?}
     */
    _filterItems() {
        if (this.uninitialized) {
            return;
        }
        if (this._filters.hasActiveFilters()) {
            this._filtered = this._all.filter(item => this._filters.accepts(item));
        }
        else {
            // Work on a shallow copy of the array, to not modify the user's model
            this._filtered = this._all.slice();
        }
        this._page.totalItems = this._filtered.length;
        this._sortItems();
    }
    /**
     * Sorts items in the filtered list
     * @return {?}
     */
    _sortItems() {
        if (this.uninitialized) {
            return;
        }
        if (this._sort.comparator) {
            this._filtered.sort((a, b) => this._sort.compare(a, b));
        }
        this._changePage();
    }
    /**
     * Extracts the current page from the sorted list
     * @return {?}
     */
    _changePage() {
        if (this.uninitialized) {
            return;
        }
        if (this._page.size > 0) {
            this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
        }
        else {
            this._displayed = this._filtered;
        }
        this.emitChange();
    }
}
Items.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Items.ctorParameters = () => [
    { type: FiltersProvider },
    { type: Sort },
    { type: Page }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDatagridItems {
    /**
     * @param {?} template
     * @param {?} differs
     * @param {?} items
     * @param {?} vcr
     */
    constructor(template, differs, items, vcr) {
        this.template = template;
        this.differs = differs;
        this.items = items;
        this.vcr = vcr;
        this.differ = null;
        this.subscriptions = [];
        items.smartenUp();
        this.iterableProxy = new NgForOf(this.vcr, this.template, this.differs);
        this.subscriptions.push(items.change.subscribe(newItems => {
            this.iterableProxy.ngForOf = newItems;
            this.iterableProxy.ngDoCheck();
        }));
    }
    /**
     * @param {?} items
     * @return {?}
     */
    set rawItems(items) {
        this._rawItems = items ? items : []; // local copy for ngOnChange diffing
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set trackBy(value) {
        this.iterableProxy.ngForTrackBy = value;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (!this.differ) {
            this.differ = this.differs.find(this._rawItems).create(this.iterableProxy.ngForTrackBy);
        }
        if (this.differ) {
            /** @type {?} */
            const changes = this.differ.diff(this._rawItems);
            if (changes) {
                // TODO: not very efficient right now,
                // but premature optimization is the root of all evil.
                this.items.all = this._rawItems;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
ClrDatagridItems.decorators = [
    { type: Directive, args: [{
                selector: '[clrDgItems][clrDgItemsOf]',
            },] }
];
/** @nocollapse */
ClrDatagridItems.ctorParameters = () => [
    { type: TemplateRef },
    { type: IterableDiffers },
    { type: Items },
    { type: ViewContainerRef }
];
ClrDatagridItems.propDecorators = {
    rawItems: [{ type: Input, args: ['clrDgItemsOf',] }],
    trackBy: [{ type: Input, args: ['clrDgItemsTrackBy',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDatagridPlaceholder {
    /**
     * @param {?} items
     */
    constructor(items) {
        this.items = items;
    }
    /**
     * Tests if the datagrid is empty, meaning it doesn't contain any items
     * @return {?}
     */
    get emptyDatagrid() {
        return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
    }
}
ClrDatagridPlaceholder.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-placeholder',
                template: `
        <div
            class="datagrid-placeholder"
            [class.datagrid-empty]="emptyDatagrid">
                <div class="datagrid-placeholder-image" *ngIf="emptyDatagrid"></div>
                <ng-content *ngIf="emptyDatagrid"></ng-content>
        </div>
    `,
                host: { '[class.datagrid-placeholder-container]': 'true' }
            }] }
];
/** @nocollapse */
ClrDatagridPlaceholder.ctorParameters = () => [
    { type: Items }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const POPOVER_HOST_ANCHOR = new InjectionToken('POPOVER_HOST_ANCHOR');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*********
 *
 * @description
 * A Directive added to the ClrSignpost Trigger button that will call the ClrSignpost.toggle() function to hide/show the
 * ClrSignpostContent.
 *
 */
class ClrSignpostTrigger {
    /**
     * @param {?} ifOpenService
     * @param {?} renderer
     * @param {?} el
     */
    constructor(ifOpenService, renderer, el) {
        this.ifOpenService = ifOpenService;
        this.renderer = renderer;
        this.el = el;
        this.subscriptions = [];
        this.subscriptions.push(this.ifOpenService.openChange.subscribe((isOpen) => {
            if (isOpen) {
                this.renderer.addClass(this.el.nativeElement, 'active');
            }
            else {
                this.renderer.removeClass(this.el.nativeElement, 'active');
            }
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((sub) => sub.unsubscribe());
    }
    /**
     * *******
     *
     * \@description
     * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
     * @param {?} event
     * @return {?}
     */
    onSignpostTriggerClick(event) {
        this.ifOpenService.toggleWithEvent(event);
    }
}
ClrSignpostTrigger.decorators = [
    { type: Directive, args: [{ selector: '[clrSignpostTrigger]', host: { class: 'signpost-trigger' } },] }
];
/** @nocollapse */
ClrSignpostTrigger.ctorParameters = () => [
    { type: IfOpenService },
    { type: Renderer2 },
    { type: ElementRef }
];
ClrSignpostTrigger.propDecorators = {
    onSignpostTriggerClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*********
 *
 * @class ClrSignpost
 *
 * @description
 * Class used to configure and control the state of a ClrSignpost and its associated ClrSignpostContent.
 * It supports the clrPosition with a 'right-middle' default.
 *
 */
class ClrSignpost {
    /**
     * @param {?} commonStrings
     */
    constructor(commonStrings) {
        this.commonStrings = commonStrings;
        /**
         * *******
         * \@property useCustomTrigger
         *
         * \@description
         * Flag used to determine if we need to use the default trigger or a user supplied trigger element.
         *
         */
        this.useCustomTrigger = false;
    }
    /**
     * *******
     * \@property signPostTrigger
     *
     * \@description
     * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
     *
     * @param {?} trigger
     * @return {?}
     */
    set customTrigger(trigger$$1) {
        this.useCustomTrigger = !!trigger$$1;
    }
}
ClrSignpost.decorators = [
    { type: Component, args: [{
                selector: 'clr-signpost',
                template: `
        <ng-container *ngIf="!useCustomTrigger">
            <button
                type="button"
                class="signpost-action btn btn-small btn-link"
                clrSignpostTrigger>
                <clr-icon shape="info" [attr.title]="commonStrings.info"></clr-icon>
            </button>
        </ng-container>
        
        <ng-content></ng-content>
    `,
                host: { '[class.signpost]': 'true' },
                providers: [IfOpenService, { provide: POPOVER_HOST_ANCHOR, useExisting: ElementRef }]
            }] }
];
/** @nocollapse */
ClrSignpost.ctorParameters = () => [
    { type: ClrCommonStrings }
];
ClrSignpost.propDecorators = {
    customTrigger: [{ type: ContentChild, args: [ClrSignpostTrigger,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 * An \@Injectable provider class that enables
 *
 * 1. Managing, track hideability of DatagridColumns
 *
 */
class HideableColumnService {
    constructor() {
        /**
         * *******
         * \@property dgHiddenColumnMap
         *
         * \@description
         * An array of DatagridHideableColumn.
         * NOTE: because we can have columns w/o the *clrDgHideableColumn directive
         * this array will have empty spaces a.k.a nulls. This is needed to be able to map
         * DatagridCells to DatagridColumns in the RowRenderer.
         *
         */
        this._columnList = [];
        /**
         * *******
         *
         * \@property dgHiddenColumnMapChange
         *
         * \@description
         * A behavior subject that can broadcast updates to the column list.
         * NOTE: I am using BehaviorSubject because <clr-dg-column-toggle> is not getting the latest _columnListChange
         * on page load.
         *
         */
        this._columnListChange = new BehaviorSubject(this._columnList);
    }
    /**
     * *******
     *
     * \@property canHideNextColumn
     *
     * \@description
     * Service function that is called by clr-dg-column-toggle component. Use this if you need to ask if you can hide
     * a column. It acts as a guard against hiding all the columns making sure there is at least one column displayed.
     *
     * @return {?}
     */
    get canHideNextColumn() {
        /** @type {?} */
        const hiddenColumns = this._columnList.filter(column => column !== undefined).filter(column => column.hidden);
        return this._columnList.length - hiddenColumns.length > 1;
    }
    /**
     * *******
     *
     * \@property checkForAllColumnsVisible
     *
     * \@description
     * For when you need to know if the datagrid's columns are all showing.
     *
     * @return {?}
     */
    get checkForAllColumnsVisible() {
        return !this._columnList.some(column => column && column.hidden);
    }
    /**
     * ********
     * \@property columnListChange
     *
     * \@description
     * A public property that enables subscribers to hear updates to the column map.
     * Use this if you need to do something whenever the Datagrid's column list is changed (i.e *ngIf on a column).
     *
     * @return {?}
     */
    get columnListChange() {
        return this._columnListChange.asObservable();
    }
    /**
     * *******
     *
     * \@description
     * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
     * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
     *
     * @return {?}
     */
    getColumns() {
        return this._columnList;
    }
    /**
     * *******
     *
     * \@description
     * Iterate through the current _columnList:
     * - if it has a DatagridHideableColumn and is hidden then show it.
     * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
     *
     * @return {?}
     */
    showHiddenColumns() {
        this._columnList.forEach(column => {
            if (column && column.hidden === true) {
                column.hidden = false;
            }
            if (column && column.lastVisibleColumn) {
                column.lastVisibleColumn = false;
            }
        });
    }
    /**
     *
     * \@description
     * Creates an array of DatagridHideableColumn's || null based column array passed as param.
     * Is dependent on the order in \@ContentChildren in Datagrid.
     *
     * @param {?} columns
     * @return {?}
     */
    updateColumnList(columns) {
        this._columnList = columns; // clear the list
        this.updateForLastVisibleColumn(); // Update our visibility state for UI
        this._columnListChange.next(this._columnList); // Broadcast it
    }
    /**
     * *******
     *
     * \@description
     * Gets the current visible count for all columns.
     * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
     * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
     * lastVisibleColumn.
     *
     * @return {?}
     */
    updateForLastVisibleColumn() {
        // There is more than one column showing, make sure nothing is marked lastVisibleColumn
        if (this.canHideNextColumn) {
            this._columnList.map(column => {
                if (column && column.lastVisibleColumn) {
                    column.lastVisibleColumn = false;
                }
            });
        }
        else {
            // The visibleCount is down to only one column showing. Find it and flag it as the lastVisibleColumn
            this._columnList.map(column => {
                if (column && !column.hidden) {
                    column.lastVisibleColumn = true;
                }
            });
        }
    }
    /**
     * *******
     *
     * \@description
     * Return a HideableColumn in this._columnList for the given id.
     *
     *
     * @param {?} id
     * @return {?}
     */
    getColumnById(id) {
        if (id) {
            return this._columnList.find(column => column && column.id === id);
        }
        return;
    }
}
HideableColumnService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WrappedCell {
    constructor() {
        this._dynamic = false;
    }
    // the cells projected view
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.cellView = this.templateRef.createEmbeddedView(null);
    }
}
WrappedCell.decorators = [
    { type: Component, args: [{
                selector: 'dg-wrapped-cell',
                template: `        
        <ng-template #cellPortal>
            <ng-content></ng-content>
        </ng-template>
    `
            }] }
];
WrappedCell.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['cellPortal',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridCell {
    /**
     * @param {?} hideableColumnService
     * @param {?} _el
     * @param {?} _renderer
     * @param {?} vcr
     */
    constructor(hideableColumnService, _el, _renderer, vcr) {
        this.hideableColumnService = hideableColumnService;
        this._el = _el;
        this._renderer = _renderer;
        this.vcr = vcr;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
        this.mapHideableColumn(this._id);
    }
    /**
     * @param {?} columnId
     * @return {?}
     */
    mapHideableColumn(columnId) {
        if (!columnId) {
            return;
        }
        /** @type {?} */
        const hideableColumn = this.hideableColumnService.getColumnById(this._id);
        this.setHiddenClass(hideableColumn.hidden);
        this.hiddenStateSubscription = hideableColumn.hiddenChangeState.subscribe(() => {
            this.setHiddenClass(hideableColumn.hidden);
        });
    }
    /**
     * @param {?} hideableColumnValue
     * @return {?}
     */
    setHiddenClass(hideableColumnValue) {
        if (hideableColumnValue) {
            this._renderer.addClass(this._el.nativeElement, 'datagrid-cell--hidden');
        }
        else {
            this._renderer.removeClass(this._el.nativeElement, 'datagrid-cell--hidden');
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.wrappedInjector = new HostWrapper(WrappedCell, this.vcr);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.hiddenStateSubscription) {
            this.hiddenStateSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    get _view() {
        return this.wrappedInjector.get(WrappedCell, this.vcr).cellView;
    }
}
ClrDatagridCell.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-cell',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    '[class.datagrid-cell]': 'true',
                    '[class.datagrid-signpost-trigger]': 'signpost.length > 0',
                    role: 'cell',
                }
            }] }
];
/** @nocollapse */
ClrDatagridCell.ctorParameters = () => [
    { type: HideableColumnService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ViewContainerRef }
];
ClrDatagridCell.propDecorators = {
    signpost: [{ type: ContentChildren, args: [ClrSignpost,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
const DatagridDisplayMode = {
    DISPLAY: 0,
    CALCULATE: 1,
};
DatagridDisplayMode[DatagridDisplayMode.DISPLAY] = 'DISPLAY';
DatagridDisplayMode[DatagridDisplayMode.CALCULATE] = 'CALCULATE';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
const DatagridRenderStep = {
    ALIGN_COLUMNS: 0,
    CALCULATE_MODE_ON: 1,
    CALCULATE_MODE_OFF: 2,
    CLEAR_WIDTHS: 3,
    COMPUTE_COLUMN_WIDTHS: 4,
    DETECT_STRICT_WIDTHS: 5,
    UPDATE_ROW_WIDTH: 6,
};
DatagridRenderStep[DatagridRenderStep.ALIGN_COLUMNS] = 'ALIGN_COLUMNS';
DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_ON] = 'CALCULATE_MODE_ON';
DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_OFF] = 'CALCULATE_MODE_OFF';
DatagridRenderStep[DatagridRenderStep.CLEAR_WIDTHS] = 'CLEAR_WIDTHS';
DatagridRenderStep[DatagridRenderStep.COMPUTE_COLUMN_WIDTHS] = 'COMPUTE_COLUMN_WIDTHS';
DatagridRenderStep[DatagridRenderStep.DETECT_STRICT_WIDTHS] = 'DETECT_STRICT_WIDTHS';
DatagridRenderStep[DatagridRenderStep.UPDATE_ROW_WIDTH] = 'UPDATE_ROW_WIDTH';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatagridRenderOrganizer {
    constructor() {
        this._renderStep = new Subject();
        this.alreadySized = false;
        this.widths = [];
    }
    /**
     * @return {?}
     */
    get renderStep() {
        return this._renderStep.asObservable();
    }
    /**
     * @param {?} step
     * @return {?}
     */
    filterRenderSteps(step) {
        return this.renderStep.pipe(filter(testStep => step === testStep));
    }
    /**
     * @return {?}
     */
    resize() {
        this.widths.length = 0;
        this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_ON);
        if (this.alreadySized) {
            this._renderStep.next(DatagridRenderStep.CLEAR_WIDTHS);
        }
        this._renderStep.next(DatagridRenderStep.DETECT_STRICT_WIDTHS);
        this._renderStep.next(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS);
        this._renderStep.next(DatagridRenderStep.ALIGN_COLUMNS);
        this.alreadySized = true;
        this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_OFF);
        this._renderStep.next(DatagridRenderStep.UPDATE_ROW_WIDTH);
    }
}
DatagridRenderOrganizer.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DisplayModeService {
    /**
     * @param {?} renderOrganizer
     */
    constructor(renderOrganizer) {
        this.subscriptions = [];
        this._view = new BehaviorSubject(DatagridDisplayMode.DISPLAY);
        this.subscriptions.push(renderOrganizer
            .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_ON)
            .subscribe(() => this._view.next(DatagridDisplayMode.CALCULATE)));
        this.subscriptions.push(renderOrganizer
            .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_OFF)
            .subscribe(() => this._view.next(DatagridDisplayMode.DISPLAY)));
    }
    /**
     * @return {?}
     */
    get view() {
        return this._view.asObservable();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
DisplayModeService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DisplayModeService.ctorParameters = () => [
    { type: DatagridRenderOrganizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let nbSelection = 0;
/** @enum {number} */
const SelectionType = {
    None: 0,
    Single: 1,
    Multi: 2,
};
SelectionType[SelectionType.None] = 'None';
SelectionType[SelectionType.Single] = 'Single';
SelectionType[SelectionType.Multi] = 'Multi';
/**
 * @template T
 */
class Selection {
    // Ref of single selected item
    /**
     * @param {?} _items
     * @param {?} _filters
     */
    constructor(_items, _filters) {
        this._items = _items;
        this._filters = _filters;
        this.prevSelectionRefs = []; // Refs of selected items
        this._selectionType = SelectionType.None;
        this.rowSelectionMode = false;
        /**
         * Ignore items changes in the same change detection cycle.
         */
        // tslint:disable-next-line
        this.debounce = false;
        /**
         * Subscriptions to the other providers changes.
         */
        this.subscriptions = [];
        /**
         * The Observable that lets other classes subscribe to selection changes
         */
        this._change = new Subject();
        this.id = 'clr-dg-selection' + nbSelection++;
        this.subscriptions.push(this._filters.change.subscribe(() => {
            if (!this._selectable) {
                return;
            }
            this.clearSelection();
        }));
        this.subscriptions.push(this._items.allChanges.subscribe(updatedItems => {
            switch (this.selectionType) {
                case SelectionType.None: {
                    break;
                }
                case SelectionType.Single: {
                    /** @type {?} */
                    let newSingle;
                    /** @type {?} */
                    const trackBy = this._items.trackBy;
                    /** @type {?} */
                    let selectionUpdated = false;
                    // if the currentSingle has been set before data was loaded, we look up and save the ref from current data set
                    if (this.currentSingle && !this.prevSingleSelectionRef) {
                        if (this._items.all && this._items.trackBy) {
                            /** @type {?} */
                            const lookup = this._items.all.findIndex(maybe => maybe === this.currentSingle);
                            this.prevSingleSelectionRef = this._items.trackBy(lookup, this.currentSingle);
                        }
                    }
                    updatedItems.forEach((item, index) => {
                        /** @type {?} */
                        const ref = trackBy(index, item);
                        // If one of the updated items is the previously selectedSingle, set it as the new one
                        if (this.prevSingleSelectionRef === ref) {
                            newSingle = item;
                            selectionUpdated = true;
                        }
                    });
                    // If we're using smart datagrids, we expect all items to be present in the updatedItems array.
                    // Therefore, we should delete the currentSingle if it used to be defined but doesn't exist anymore.
                    // No explicit "delete" is required, since newSingle would be undefined at this point.
                    // Marking it as selectionUpdated here will set currentSingle to undefined below in the setTimeout.
                    if (this._items.smart && !newSingle) {
                        selectionUpdated = true;
                    }
                    // TODO: Discussed this with Eudes and this is fine for now.
                    // But we need to figure out a different pattern for the
                    // child triggering the parent change detection problem.
                    // Using setTimeout for now to fix this.
                    setTimeout(() => {
                        if (selectionUpdated) {
                            this.currentSingle = newSingle;
                        }
                    }, 0);
                    break;
                }
                case SelectionType.Multi: {
                    /** @type {?} */
                    let leftOver = this.current.slice();
                    /** @type {?} */
                    const trackBy = this._items.trackBy;
                    /** @type {?} */
                    let selectionUpdated = false;
                    // if the current has been set before data was loaded, we look up and save the ref from current data set
                    if (this.current.length > 0 && this.prevSelectionRefs.length !== this.current.length) {
                        if (this._items.all && this._items.trackBy) {
                            this.prevSelectionRefs = [];
                            this.current.forEach(item => {
                                /** @type {?} */
                                const lookup = this._items.all.findIndex(maybe => maybe === item);
                                this.prevSelectionRefs.push(this._items.trackBy(lookup, item));
                            });
                        }
                    }
                    // TODO: revisit this when we work on https://github.com/vmware/clarity/issues/2342
                    // currently, the selection is cleared when filter is applied, so the logic inside
                    // the if statement below results in broken behavior.
                    if (leftOver.length > 0) {
                        updatedItems.forEach((item, index) => {
                            /** @type {?} */
                            const ref = trackBy(index, item);
                            // Look in current selected refs array if item is selected, and update actual value
                            /** @type {?} */
                            const selectedIndex = this.prevSelectionRefs.indexOf(ref);
                            if (selectedIndex > -1) {
                                leftOver[selectedIndex] = item;
                                selectionUpdated = true;
                            }
                        });
                        // Filter out any unmatched items if we're using smart datagrids where we expect all items to be
                        // present
                        if (this._items.smart) {
                            leftOver = leftOver.filter(selected => updatedItems.indexOf(selected) > -1);
                            if (this.current.length !== leftOver.length) {
                                selectionUpdated = true;
                            }
                        }
                        // TODO: Discussed this with Eudes and this is fine for now.
                        // But we need to figure out a different pattern for the
                        // child triggering the parent change detection problem.
                        // Using setTimeout for now to fix this.
                        setTimeout(() => {
                            if (selectionUpdated) {
                                this.current = leftOver;
                            }
                        }, 0);
                    }
                    break;
                }
                default: {
                    break;
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    clearSelection() {
        this.current.length = 0;
        this.prevSelectionRefs = [];
        this.emitChange();
    }
    /**
     * @return {?}
     */
    get selectionType() {
        return this._selectionType;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectionType(value) {
        if (value === this.selectionType) {
            return;
        }
        this._selectionType = value;
        if (value === SelectionType.None) {
            delete this.current;
        }
        else {
            this.updateCurrent([], false);
        }
    }
    /**
     * @return {?}
     */
    get _selectable() {
        return this._selectionType === SelectionType.Multi || this._selectionType === SelectionType.Single;
    }
    /**
     * Cleans up our subscriptions to other providers
     * @return {?}
     */
    destroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    get currentSingle() {
        return this._currentSingle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set currentSingle(value) {
        if (value === this._currentSingle) {
            return;
        }
        this._currentSingle = value;
        if (this._items.all && this._items.trackBy && value) {
            /** @type {?} */
            const lookup = this._items.all.findIndex(maybe => maybe === value);
            this.prevSingleSelectionRef = this._items.trackBy(lookup, value);
        }
        this.emitChange();
        // Ignore items changes in the same change detection cycle.
        // @TODO This can likely be removed!
        this.debounce = true;
        setTimeout(() => (this.debounce = false));
    }
    /**
     * @return {?}
     */
    get current() {
        return this._current;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set current(value) {
        this.updateCurrent(value, true);
    }
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    updateCurrent(value, emit) {
        this._current = value;
        if (emit) {
            this.emitChange();
            // Ignore items changes in the same change detection cycle.
            // @TODO This can likely be removed!
            this.debounce = true;
            setTimeout(() => (this.debounce = false));
        }
    }
    /**
     * @return {?}
     */
    emitChange() {
        if (this._selectionType === SelectionType.Single) {
            this._change.next(this.currentSingle);
        }
        else if (this._selectionType === SelectionType.Multi) {
            this._change.next(this.current);
        }
    }
    // We do not want to expose the Subject itself, but the Observable which is read-only
    /**
     * @return {?}
     */
    get change() {
        return this._change.asObservable();
    }
    /**
     * Checks if an item is currently selected
     * @param {?} item
     * @return {?}
     */
    isSelected(item) {
        if (this._selectionType === SelectionType.Single) {
            return this.currentSingle === item;
        }
        else if (this._selectionType === SelectionType.Multi) {
            return this.current.indexOf(item) >= 0;
        }
        return false;
    }
    /**
     * Selects an item
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        this.current.push(item);
        if (this._items.trackBy) {
            // Push selected ref onto array
            /** @type {?} */
            const lookup = this._items.all.findIndex(maybe => maybe === item);
            this.prevSelectionRefs.push(this._items.trackBy(lookup, item));
        }
    }
    /**
     * Deselects an item
     * @param {?} indexOfItem
     * @return {?}
     */
    deselectItem(indexOfItem) {
        this.current.splice(indexOfItem, 1);
        if (this._items.trackBy && indexOfItem < this.prevSelectionRefs.length) {
            // Keep selected refs array in sync
            this.prevSelectionRefs.splice(indexOfItem, 1);
        }
    }
    /**
     * Selects or deselects an item
     * @param {?} item
     * @param {?} selected
     * @return {?}
     */
    setSelected(item, selected) {
        switch (this._selectionType) {
            case SelectionType.None:
                break;
            case SelectionType.Single:
                // in single selection, set currentSingle method should be used
                break;
            case SelectionType.Multi:
                /** @type {?} */
                const index = this.current.indexOf(item);
                if (index >= 0 && !selected) {
                    this.deselectItem(index);
                    this.emitChange();
                }
                else if (index < 0 && selected) {
                    this.selectItem(item);
                    this.emitChange();
                }
                break;
            default:
                break;
        }
    }
    /**
     * Checks if all currently displayed items are selected
     * @return {?}
     */
    isAllSelected() {
        if (this._selectionType !== SelectionType.Multi || !this._items.displayed) {
            return false;
        }
        /** @type {?} */
        const displayedItems = this._items.displayed;
        /** @type {?} */
        const nbDisplayed = this._items.displayed.length;
        if (nbDisplayed < 1) {
            return false;
        }
        /** @type {?} */
        const temp = displayedItems.filter(item => this.current.indexOf(item) > -1);
        return temp.length === displayedItems.length;
    }
    /**
     * Selects or deselects all currently displayed items
     * @return {?}
     */
    toggleAll() {
        if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
            return;
        }
        /*
             * If every currently displayed item is already selected, we clear them.
             * If at least one item isn't selected, we select every currently displayed item.
             */
        if (this.isAllSelected()) {
            this._items.displayed.forEach(item => {
                /** @type {?} */
                const currentIndex = this.current.indexOf(item);
                if (currentIndex > -1) {
                    this.deselectItem(currentIndex);
                }
            });
        }
        else {
            this._items.displayed.forEach(item => {
                if (this.current.indexOf(item) < 0) {
                    this.selectItem(item);
                }
            });
        }
        this.emitChange();
    }
}
Selection.decorators = [
    { type: Injectable }
];
/** @nocollapse */
Selection.ctorParameters = () => [
    { type: Items },
    { type: FiltersProvider }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WrappedRow {
    constructor() {
        this._dynamic = false;
    }
    // the rows projected view (in memory)
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // Create the cells view in memory, not the DOM.
        this.rowView = this.templateRef.createEmbeddedView(null);
    }
}
WrappedRow.decorators = [
    { type: Component, args: [{
                selector: 'dg-wrapped-row',
                template: `        
        <ng-template #rowPortal>
            <ng-content></ng-content>
        </ng-template>
    `
            }] }
];
WrappedRow.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['rowPortal',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let nbRow = 0;
/**
 * @template T
 */
class ClrDatagridRow {
    /**
     * @param {?} selection
     * @param {?} rowActionService
     * @param {?} globalExpandable
     * @param {?} expand
     * @param {?} hideableColumnService
     * @param {?} displayMode
     * @param {?} vcr
     * @param {?} renderer
     * @param {?} el
     * @param {?} commonStrings
     */
    constructor(selection, rowActionService, globalExpandable, expand, hideableColumnService, displayMode, vcr, renderer, el, commonStrings) {
        this.selection = selection;
        this.rowActionService = rowActionService;
        this.globalExpandable = globalExpandable;
        this.expand = expand;
        this.hideableColumnService = hideableColumnService;
        this.displayMode = displayMode;
        this.vcr = vcr;
        this.renderer = renderer;
        this.el = el;
        this.commonStrings = commonStrings;
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
        this._selected = false;
        this.selectedChanged = new EventEmitter(false);
        this.expandedChange = new EventEmitter(false);
        this.subscriptions = [];
        this.displayCells = false;
        nbRow++;
        this.id = 'clr-dg-row' + nbRow;
        this.radioId = 'clr-dg-row-rd' + nbRow;
        this.checkboxId = 'clr-dg-row-cb' + nbRow;
        this.subscriptions.push(combineLatest(this.expand.replace, this.expand.expandChange).subscribe(([expandReplaceValue, expandChangeValue]) => {
            if (expandReplaceValue && expandChangeValue) {
                // replaced and expanding
                this.replaced = true;
                this.renderer.addClass(this.el.nativeElement, 'datagrid-row-replaced');
            }
            else {
                this.replaced = false;
                // Handles these cases: not replaced and collapsing & replaced and
                // collapsing and not replaced and expanding.
                this.renderer.removeClass(this.el.nativeElement, 'datagrid-row-replaced');
            }
        }));
    }
    /**
     * Indicates if the row is selected
     * @return {?}
     */
    get selected() {
        if (this.selection.selectionType === SelectionType.None) {
            return this._selected;
        }
        else {
            return this.selection.isSelected(this.item);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        if (this.selection.selectionType === SelectionType.None) {
            this._selected = value;
        }
        else {
            this.selection.setSelected(this.item, value);
        }
    }
    /**
     * @param {?=} selected
     * @return {?}
     */
    toggle(selected = !this.selected) {
        if (selected !== this.selected) {
            this.selected = selected;
            this.selectedChanged.emit(selected);
        }
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this.expand.expanded;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expanded(value) {
        this.expand.expanded = value;
    }
    /**
     * @return {?}
     */
    toggleExpand() {
        if (this.expand.expandable) {
            this.expanded = !this.expanded;
            this.expandedChange.emit(this.expanded);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // Make sure things get started
        /** @type {?} */
        const columnsList = this.hideableColumnService.getColumns();
        this.updateCellsForColumns(columnsList);
        // Triggered when the Cells list changes per row-renderer
        this.dgCells.changes.subscribe(cellList => {
            /** @type {?} */
            const columnList = this.hideableColumnService.getColumns();
            if (cellList.length === columnList.length) {
                this.updateCellsForColumns(columnList);
            }
        });
        // Used to set things up the first time but only after all the columns are ready.
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(columnList => {
            // Prevents cell updates when cols and cells array are not aligned - only seems to run on init / first time.
            if (columnList.length === this.dgCells.length) {
                this.updateCellsForColumns(columnList);
            }
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.subscriptions.push(this.displayMode.view.subscribe(viewChange => {
            // Listen for view changes and move cells around depending on the current displayType
            // remove cell views from display view
            for (let i = this._scrollableCells.length; i > 0; i--) {
                this._scrollableCells.detach();
            }
            // remove cell views from calculated view
            for (let i = this._calculatedCells.length; i > 0; i--) {
                this._calculatedCells.detach();
            }
            if (viewChange === DatagridDisplayMode.CALCULATE) {
                this.displayCells = false;
                this.dgCells.forEach(cell => {
                    this._calculatedCells.insert(cell._view);
                });
            }
            else {
                this.displayCells = true;
                this.dgCells.forEach(cell => {
                    this._scrollableCells.insert(cell._view);
                });
            }
        }));
    }
    /**
     * *******
     *
     * \@description
     * 1. Maps the new columnListChange to the dgCells list by index
     * 2. Sets the hidden state on the cell
     * Take a Column list and use index to access the columns for hideable properties.
     *
     * @param {?} columnList
     * @return {?}
     */
    updateCellsForColumns(columnList) {
        // Map cells to columns with Array.index
        this.dgCells.forEach((cell, index) => {
            /** @type {?} */
            const currentColumn = columnList[index];
            if (currentColumn) {
                cell.id = currentColumn.id;
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((sub) => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.wrappedInjector = new HostWrapper(WrappedRow, this.vcr);
    }
    /**
     * @return {?}
     */
    get _view() {
        return this.wrappedInjector.get(WrappedRow, this.vcr).rowView;
    }
}
ClrDatagridRow.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-row',
                template: "<!--\n  We need to wrap the #rowContent in label element if we are in rowSelectionMode.\n  Clicking of that wrapper label will equate to clicking on the whole row, which triggers the checkbox to toggle.\n-->\n<label class=\"datagrid-row-clickable\" *ngIf=\"selection.rowSelectionMode\">\n  <ng-template [ngTemplateOutlet]=\"rowContent\"></ng-template>\n</label>\n\n<ng-template *ngIf=\"!selection.rowSelectionMode\" [ngTemplateOutlet]=\"rowContent\"></ng-template>\n\n<!--\n    We need the \"project into template\" hacks because we need this in 2 different places\n    depending on whether the details replace the row or not.\n-->\n<ng-template #detail>\n  <ng-content select=\"clr-dg-row-detail\"></ng-content>\n</ng-template>\n\n<ng-template #rowContent>\n  <div role=\"row\" [id]=\"id\" class=\"datagrid-row-master datagrid-row-flex\">\n    <div class=\"datagrid-row-sticky\">\n      <!-- Sticky elements here -->\n      <ng-container #stickyCells></ng-container> <!-- placeholder for projecting other sticky cells as pinned-->\n    </div>\n    <div class=\"datagrid-row-scrollable\" [ngClass]=\"{'is-replaced': replaced && expanded}\">\n      <div class=\"datagrid-scrolling-cells\">\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\">\n          <input clrCheckbox type=\"checkbox\" [ngModel]=\"selected\" (ngModelChange)=\"toggle($event)\" [id]=\"checkboxId\"\n                 [attr.aria-label]=\"commonStrings.select\">\n        </div>\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\">\n            <!-- TODO: it would be better if in addition to the generic \"Select\" label, we could add aria-labelledby\n            to label the radio by the first cell in the row (typically an id or name).\n            It's pretty easy to label it with the whole row since we already have an id for it, but in most\n            cases the row is far too long to serve as a label, the screenreader reads every single cell content. -->\n            <input type=\"radio\" clrRadio [id]=\"radioId\" [name]=\"selection.id + '-radio'\" [value]=\"item\"\n                   [(ngModel)]=\"selection.currentSingle\" [checked]=\"selection.currentSingle === item\"\n                   [attr.aria-label]=\"commonStrings.select\">\n        </div>\n        <div *ngIf=\"rowActionService.hasActionableRow\"\n             class=\"datagrid-row-actions datagrid-fixed-column datagrid-cell\">\n          <ng-content select=\"clr-dg-action-overflow\"></ng-content>\n        </div>\n        <div *ngIf=\"globalExpandable.hasExpandableRow\"\n             class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\">\n          <ng-container *ngIf=\"expand.expandable\">\n            <button (click)=\"toggleExpand()\" *ngIf=\"!expand.loading\" type=\"button\" class=\"datagrid-expandable-caret-button\">\n              <clr-icon shape=\"caret\"\n                        class=\"datagrid-expandable-caret-icon\"\n                        [attr.dir]=\"expand.expanded ? 'down' : 'right'\"\n                        [attr.title]=\"expand.expanded ? commonStrings.collapse : commonStrings.expand\"></clr-icon>\n            </button>\n            <div class=\"spinner spinner-sm\" *ngIf=\"expand.loading\"></div>\n          </ng-container>\n        </div>\n        <ng-container #scrollableCells></ng-container>\n      </div>\n      <!-- details here when replace, re-visit when sticky container is used for pinned cells -->\n      <ng-template *ngIf=\"replaced && !expand.loading\"\n                   [ngTemplateOutlet]=\"detail\"></ng-template>\n    </div>\n    <ng-template *ngIf=\"!replaced && !expand.loading\"\n                 [ngTemplateOutlet]=\"detail\"></ng-template>\n  </div>\n</ng-template>\n\n<ng-container #calculatedCells></ng-container>\n",
                host: {
                    '[class.datagrid-row]': 'true',
                    '[class.datagrid-selected]': 'selected',
                    '[attr.aria-owns]': 'id',
                    role: 'rowgroup',
                },
                providers: [Expand, { provide: LoadingListener, useExisting: Expand }]
            }] }
];
/** @nocollapse */
ClrDatagridRow.ctorParameters = () => [
    { type: Selection },
    { type: RowActionService },
    { type: ExpandableRowsCount },
    { type: Expand },
    { type: HideableColumnService },
    { type: DisplayModeService },
    { type: ViewContainerRef },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ClrCommonStrings }
];
ClrDatagridRow.propDecorators = {
    item: [{ type: Input, args: ['clrDgItem',] }],
    selected: [{ type: Input, args: ['clrDgSelected',] }],
    selectedChanged: [{ type: Output, args: ['clrDgSelectedChange',] }],
    expanded: [{ type: Input, args: ['clrDgExpanded',] }],
    expandedChange: [{ type: Output, args: ['clrDgExpandedChange',] }],
    dgCells: [{ type: ContentChildren, args: [ClrDatagridCell,] }],
    _stickyCells: [{ type: ViewChild, args: ['stickyCells', { read: ViewContainerRef },] }],
    _scrollableCells: [{ type: ViewChild, args: ['scrollableCells', { read: ViewContainerRef },] }],
    _calculatedCells: [{ type: ViewChild, args: ['calculatedCells', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ColumnToggleButtonsService {
    constructor() {
        this.buttons = null;
        this.selectAllDisabled = false;
        this._selectAllButtonClicked = new Subject();
    }
    /**
     * @return {?}
     */
    get selectAllButtonClicked() {
        return this._selectAllButtonClicked.asObservable();
    }
    /**
     * @return {?}
     */
    buttonClicked() {
        this._selectAllButtonClicked.next();
    }
}
ColumnToggleButtonsService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This provider aggregates state changes from the various providers of the Datagrid
 * @template T
 */
class StateProvider {
    /**
     * @param {?} filters
     * @param {?} sort
     * @param {?} page
     * @param {?} debouncer
     */
    constructor(filters, sort, page, debouncer) {
        this.filters = filters;
        this.sort = sort;
        this.page = page;
        this.debouncer = debouncer;
        /**
         * The Observable that lets other classes subscribe to global state changes
         */
        this.change = this.debouncer.change.pipe(map(() => this.state));
    }
    /*
         * By making this a getter, we open the possibility for a setter in the future.
         * It's been requested a couple times.
         */
    /**
     * @return {?}
     */
    get state() {
        /** @type {?} */
        const state$$1 = {};
        if (this.page.size > 0) {
            state$$1.page = { from: this.page.firstItem, to: this.page.lastItem, size: this.page.size };
        }
        if (this.sort.comparator) {
            if (this.sort.comparator instanceof DatagridPropertyComparator) {
                /*
                         * Special case for the default object property comparator,
                         * we give the property name instead of the actual comparator.
                         */
                state$$1.sort = { by: ((/** @type {?} */ (this.sort.comparator))).prop, reverse: this.sort.reverse };
            }
            else {
                state$$1.sort = { by: this.sort.comparator, reverse: this.sort.reverse };
            }
        }
        /** @type {?} */
        const activeFilters = this.filters.getActiveFilters();
        if (activeFilters.length > 0) {
            state$$1.filters = [];
            for (const filter$$1 of activeFilters) {
                if (filter$$1 instanceof DatagridStringFilterImpl) {
                    /** @type {?} */
                    const stringFilter = filter$$1.filterFn;
                    if (stringFilter instanceof DatagridPropertyStringFilter) {
                        /*
                                     * Special case again for the default object property filter,
                                     * we give the property name instead of the full filter object.
                                     */
                        state$$1.filters.push({
                            property: stringFilter.prop,
                            value: filter$$1.value,
                        });
                        continue;
                    }
                }
                state$$1.filters.push(filter$$1);
            }
        }
        return state$$1;
    }
}
StateProvider.decorators = [
    { type: Injectable }
];
/** @nocollapse */
StateProvider.ctorParameters = () => [
    { type: FiltersProvider },
    { type: Sort },
    { type: Page },
    { type: StateDebouncer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * \@description
 * Internal datagrid service that holds a reference to the clr-dg-table element and exposes a method to get height.
 */
class TableSizeService {
    /**
     * @param {?} platformId
     * @param {?} renderOrganizer
     * @param {?} renderer
     */
    constructor(platformId, renderOrganizer, renderer) {
        this.platformId = platformId;
        this.renderer = renderer;
        this.subscriptions = [];
        this.subscriptions.push(renderOrganizer.renderStep.subscribe(step => {
            if (step === DatagridRenderStep.UPDATE_ROW_WIDTH) {
                this.updateRowWidth();
            }
        }));
    }
    /**
     * @return {?}
     */
    get tableRef() {
        return this._tableRef;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    set tableRef(element) {
        this._tableRef = element;
    }
    /**
     * @param {?} table
     * @return {?}
     */
    set table(table) {
        if (isPlatformBrowser(this.platformId) && table.nativeElement) {
            this.tableRef = table.nativeElement.querySelector('.datagrid-table');
        }
    }
    // Used when resizing columns to show the column border being dragged.
    /**
     * @return {?}
     */
    getColumnDragHeight() {
        if (!this.tableRef) {
            return;
        }
        return `${this.tableRef.clientHeight}px`;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    updateRowWidth() {
        if (!this.tableRef) {
            return;
        }
        /** @type {?} */
        let newWidth = 0;
        this.renderer.removeStyle(this.tableRef, 'width');
        this.columns = Array.from(this.tableRef.querySelectorAll('.datagrid-column'));
        this.columns.forEach(item => {
            newWidth += item.clientWidth;
        });
        this.renderer.setStyle(this.tableRef, 'width', newWidth + 'px');
    }
}
TableSizeService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
TableSizeService.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: DatagridRenderOrganizer },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDatagrid {
    /**
     * @param {?} columnService
     * @param {?} organizer
     * @param {?} items
     * @param {?} expandableRows
     * @param {?} selection
     * @param {?} rowActionService
     * @param {?} stateProvider
     * @param {?} displayMode
     * @param {?} renderer
     * @param {?} el
     * @param {?} commonStrings
     */
    constructor(columnService, organizer, items, expandableRows, selection, rowActionService, stateProvider, displayMode, renderer, el, commonStrings) {
        this.columnService = columnService;
        this.organizer = organizer;
        this.items = items;
        this.expandableRows = expandableRows;
        this.selection = selection;
        this.rowActionService = rowActionService;
        this.stateProvider = stateProvider;
        this.displayMode = displayMode;
        this.renderer = renderer;
        this.el = el;
        this.commonStrings = commonStrings;
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
        /**
         * Output emitted whenever the data needs to be refreshed, based on user action or external ones
         */
        this.refresh = new EventEmitter(false);
        this.selectedChanged = new EventEmitter(false);
        this.singleSelectedChanged = new EventEmitter(false);
        /**
         * Subscriptions to all the services and queries changes
         */
        this._subscriptions = [];
    }
    /**
     * Freezes the datagrid while data is loading
     * @return {?}
     */
    get loading() {
        return this.items.loading;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set loading(value) {
        this.items.loading = value;
    }
    /**
     * Public method to re-trigger the computation of displayed items manually
     * @return {?}
     */
    dataChanged() {
        this.items.refresh();
    }
    /**
     * Array of all selected items
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        if (value) {
            this.selection.selectionType = SelectionType.Multi;
        }
        else {
            this.selection.selectionType = SelectionType.None;
        }
        this.selection.updateCurrent(value, false);
    }
    /**
     * Selected item in single-select mode
     * @param {?} value
     * @return {?}
     */
    set singleSelected(value) {
        this.selection.selectionType = SelectionType.Single;
        // the clrDgSingleSelected is updated in one of two cases:
        // 1. an explicit value is passed
        // 2. is being set to null or undefined, where previously it had a value
        if (value) {
            this.selection.currentSingle = value;
        }
        else if (this.selection.currentSingle) {
            this.selection.currentSingle = null;
        }
    }
    /**
     * Selection/Deselection on row click mode
     * @param {?} value
     * @return {?}
     */
    set rowSelectionMode(value) {
        this.selection.rowSelectionMode = value;
    }
    /**
     * Indicates if all currently displayed items are selected
     * @return {?}
     */
    get allSelected() {
        return this.selection.isAllSelected();
    }
    /**
     * Selects/deselects all currently displayed items
     * @param {?} value
     * @return {?}
     */
    set allSelected(value) {
        /*
             * This is a setter but we ignore the value.
             * It's strange, but it lets us have an indeterminate state where only
             * some of the items are selected.
             */
        this.selection.toggleAll();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (!this.items.smart) {
            this.items.all = this.rows.map((row) => row.item);
        }
        this._subscriptions.push(this.rows.changes.subscribe(() => {
            if (!this.items.smart) {
                this.items.all = this.rows.map((row) => row.item);
            }
            this.rows.forEach(row => {
                this._displayedRows.insert(row._view);
            });
        }));
        this._subscriptions.push(this.columns.changes.subscribe((columns) => {
            this.columnService.updateColumnList(this.columns.map(col => col.hideable));
        }));
        // Get ColumnService ready for HideableColumns.
        this.columnService.updateColumnList(this.columns.map(col => col.hideable));
    }
    /**
     * Our setup happens in the view of some of our components, so we wait for it to be done before starting
     * @return {?}
     */
    ngAfterViewInit() {
        // TODO: determine if we can get rid of provider wiring in view init so that subscriptions can be done earlier
        this.refresh.emit(this.stateProvider.state);
        this._subscriptions.push(this.stateProvider.change.subscribe(state$$1 => this.refresh.emit(state$$1)));
        this._subscriptions.push(this.selection.change.subscribe(s => {
            if (this.selection.selectionType === SelectionType.Single) {
                this.singleSelectedChanged.emit((/** @type {?} */ (s)));
            }
            else if (this.selection.selectionType === SelectionType.Multi) {
                this.selectedChanged.emit((/** @type {?} */ (s)));
            }
        }));
        // A subscription that listens for displayMode changes on the datagrid
        this.displayMode.view.subscribe(viewChange => {
            // Remove any projected columns from the projectedDisplayColumns container
            for (let i = this._projectedDisplayColumns.length; i > 0; i--) {
                this._projectedDisplayColumns.detach();
            }
            // Remove any projected columns from the projectedCalculationColumns container
            for (let i = this._projectedCalculationColumns.length; i > 0; i--) {
                this._projectedCalculationColumns.detach();
            }
            // Remove any projected rows from the calculationRows container
            for (let i = this._calculationRows.length; i > 0; i--) {
                this._calculationRows.detach();
            }
            // Remove any projected rows from the displayedRows container
            for (let i = this._displayedRows.length; i > 0; i--) {
                this._displayedRows.detach();
            }
            if (viewChange === DatagridDisplayMode.DISPLAY) {
                // Set state, style for the datagrid to DISPLAY and insert row & columns into containers
                this.renderer.removeClass(this.el.nativeElement, 'datagrid-calculate-mode');
                this.columns.forEach(column => {
                    this._projectedDisplayColumns.insert(column._view);
                });
                this.rows.forEach(row => {
                    this._displayedRows.insert(row._view);
                });
            }
            else {
                // Set state, style for the datagrid to CALCULATE and insert row & columns into containers
                this.renderer.addClass(this.el.nativeElement, 'datagrid-calculate-mode');
                this.columns.forEach(column => {
                    this._projectedCalculationColumns.insert(column._view);
                });
                this.rows.forEach(row => {
                    this._calculationRows.insert(row._view);
                });
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subscriptions.forEach((sub) => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    resize() {
        this.organizer.resize();
    }
}
ClrDatagrid.decorators = [
    { type: Component, args: [{
                selector: 'clr-datagrid',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-content select=\"clr-dg-action-bar\"></ng-content>\n<div class=\"datagrid\" #datagrid>\n    <div role=\"grid\" class=\"datagrid-table\">\n        <div role=\"rowgroup\" class=\"datagrid-header\">\n            <div role=\"row\" class=\"datagrid-row\">\n                <div class=\"datagrid-row-master datagrid-row-flex\">\n                    <div class=\"datagrid-row-sticky\">\n                        <!-- Sticky elements here -->\n                    </div>\n                    <div class=\"datagrid-row-scrollable\">\n                        <!--header for datagrid where you can select multiple rows -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                             *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n                            <span class=\"datagrid-column-title\">\n                                <input clrCheckbox type=\"checkbox\" [(ngModel)]=\"allSelected\"\n                                       [attr.aria-label]=\"commonStrings.selectAll\">\n                            </span>\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <!-- header for datagrid where you can select one row only -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                             *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\">\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <!-- header for single row action; only displayType if we have at least one actionable row in datagrid -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-row-actions datagrid-fixed-column\"\n                             *ngIf=\"rowActionService.hasActionableRow\">\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <!-- header for carets; only displayType if we have at least one expandable row in datagrid -->\n                        <div role=\"columnheader\" class=\"datagrid-column datagrid-expandable-caret datagrid-fixed-column\"\n                             *ngIf=\"expandableRows.hasExpandableRow\">\n                            <div class=\"datagrid-column-separator\"></div>\n                        </div>\n                        <ng-container #projectedDisplayColumns></ng-container>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <ng-container #displayedRows></ng-container>\n        <!-- Custom placeholder overrides the default empty one -->\n        <ng-content select=\"clr-dg-placeholder\"></ng-content>\n        <clr-dg-placeholder *ngIf=\"!placeholder\"></clr-dg-placeholder>\n    </div>\n</div>\n<ng-content select=\"clr-dg-footer\"></ng-content>\n<div class=\"datagrid-spinner\" *ngIf=\"loading\">\n    <div class=\"spinner spinner-md\">Loading...</div>\n</div>\n\n<div class=\"datagrid-calculation-table\">\n    <div class=\"datagrid-calculation-header\">\n        <ng-container #projectedCalculationColumns></ng-container>\n    </div>\n    <ng-container #calculationRows></ng-container>\n</div>\n",
                providers: [
                    Selection,
                    Sort,
                    FiltersProvider,
                    Page,
                    Items,
                    DatagridRenderOrganizer,
                    RowActionService,
                    ExpandableRowsCount,
                    HideableColumnService,
                    StateDebouncer,
                    StateProvider,
                    ColumnToggleButtonsService,
                    TableSizeService,
                    DisplayModeService,
                ],
                host: { '[class.datagrid-host]': 'true' }
            }] }
];
/** @nocollapse */
ClrDatagrid.ctorParameters = () => [
    { type: HideableColumnService },
    { type: DatagridRenderOrganizer },
    { type: Items },
    { type: ExpandableRowsCount },
    { type: Selection },
    { type: RowActionService },
    { type: StateProvider },
    { type: DisplayModeService },
    { type: Renderer2 },
    { type: ElementRef },
    { type: ClrCommonStrings }
];
ClrDatagrid.propDecorators = {
    loading: [{ type: Input, args: ['clrDgLoading',] }],
    refresh: [{ type: Output, args: ['clrDgRefresh',] }],
    iterator: [{ type: ContentChild, args: [ClrDatagridItems,] }],
    selected: [{ type: Input, args: ['clrDgSelected',] }],
    selectedChanged: [{ type: Output, args: ['clrDgSelectedChange',] }],
    singleSelected: [{ type: Input, args: ['clrDgSingleSelected',] }],
    singleSelectedChanged: [{ type: Output, args: ['clrDgSingleSelectedChange',] }],
    rowSelectionMode: [{ type: Input, args: ['clrDgRowSelection',] }],
    placeholder: [{ type: ContentChild, args: [ClrDatagridPlaceholder,] }],
    columns: [{ type: ContentChildren, args: [ClrDatagridColumn,] }],
    rows: [{ type: ContentChildren, args: [ClrDatagridRow,] }],
    scrollableColumns: [{ type: ViewChild, args: ['scrollableColumns', { read: ViewContainerRef },] }],
    _projectedDisplayColumns: [{ type: ViewChild, args: ['projectedDisplayColumns', { read: ViewContainerRef },] }],
    _projectedCalculationColumns: [{ type: ViewChild, args: ['projectedCalculationColumns', { read: ViewContainerRef },] }],
    _displayedRows: [{ type: ViewChild, args: ['displayedRows', { read: ViewContainerRef },] }],
    _calculationRows: [{ type: ViewChild, args: ['calculationRows', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridActionBar {
}
ClrDatagridActionBar.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-action-bar',
                template: `
        <ng-content></ng-content>
    `,
                host: { '[class.datagrid-action-bar]': 'true' }
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridActionOverflow {
    /**
     * @param {?} rowActionService
     * @param {?} commonStrings
     */
    constructor(rowActionService, commonStrings) {
        this.rowActionService = rowActionService;
        this.commonStrings = commonStrings;
        this.anchorPoint = Point.RIGHT_CENTER;
        this.popoverPoint = Point.LEFT_CENTER;
        /**
         * Tracks whether the action overflow menu is open or not
         */
        this._open = false;
        this.openChanged = new EventEmitter(false);
        this.rowActionService.register();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.rowActionService.unregister();
    }
    /**
     * @return {?}
     */
    get open() {
        return this._open;
    }
    /**
     * @param {?} open
     * @return {?}
     */
    set open(open) {
        /** @type {?} */
        const boolOpen = !!open;
        if (boolOpen !== this._open) {
            this._open = boolOpen;
            this.openChanged.emit(boolOpen);
        }
    }
    /**
     * Shows/hides the action overflow menu
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        this.openingEvent = event;
        this.open = !this.open;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    close(event) {
        /*
             * Because this listener is added synchonously, before the event finishes bubbling up the DOM,
             * we end up firing on the very click that just opened the menu, p
             * otentially closing it immediately every time. So we just ignore it.
             */
        if (event === this.openingEvent) {
            delete this.openingEvent;
            return;
        }
        this.open = false;
    }
}
ClrDatagridActionOverflow.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-action-overflow',
                template: `
        <button (click)="toggle($event)" type="button" class="datagrid-action-toggle" #anchor>
            <clr-icon shape="ellipsis-vertical" [attr.title]="commonStrings.rowActions"></clr-icon>
        </button>
        <ng-template [(clrPopoverOld)]="open" [clrPopoverOldAnchor]="anchor" [clrPopoverOldAnchorPoint]="anchorPoint"
                     [clrPopoverOldPopoverPoint]="popoverPoint">
            <div #menu class="datagrid-action-overflow" (clrOutsideClick)="close($event)" [clrStrict]="true">
                <ng-content></ng-content>
            </div>
        </ng-template>
    `
            }] }
];
/** @nocollapse */
ClrDatagridActionOverflow.ctorParameters = () => [
    { type: RowActionService },
    { type: ClrCommonStrings }
];
ClrDatagridActionOverflow.propDecorators = {
    open: [{ type: Input, args: ['clrDgActionOverflowOpen',] }],
    openChanged: [{ type: Output, args: ['clrDgActionOverflowOpenChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridColumnToggleButton {
    /**
     * @param {?} toggleButtons
     */
    constructor(toggleButtons) {
        this.toggleButtons = toggleButtons;
    }
}
ClrDatagridColumnToggleButton.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-column-toggle-button',
                template: `
        <button class="btn btn-sm btn-link"
            (click)="toggleButtons.buttonClicked()"
            [disabled]="toggleButtons.selectAllDisabled"
            type="button">
            <ng-content></ng-content>
        </button>
    `
            }] }
];
/** @nocollapse */
ClrDatagridColumnToggleButton.ctorParameters = () => [
    { type: ColumnToggleButtonsService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridColumnToggleTitle {
}
ClrDatagridColumnToggleTitle.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-column-toggle-title',
                template: `<ng-content></ng-content>`
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridColumnToggle {
    /**
     * @param {?} hideableColumnService
     * @param {?} columnToggleButtons
     * @param {?} commonStrings
     */
    constructor(hideableColumnService, columnToggleButtons, commonStrings) {
        this.hideableColumnService = hideableColumnService;
        this.columnToggleButtons = columnToggleButtons;
        this.commonStrings = commonStrings;
        this.subscriptions = [];
        /**
         *
         * Popover init
         */
        this.anchorPoint = Point.TOP_LEFT;
        this.popoverPoint = Point.LEFT_BOTTOM;
        this.open = false;
        /**
         * *
         * DatagridHideableColumnModel init
         */
        this.columns = [];
    }
    /**
     * @return {?}
     */
    get allColumnsVisible() {
        return this._allColumnsVisible;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set allColumnsVisible(value) {
        this._allColumnsVisible = value;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(columnList => {
            // Reset the list of columns
            this.columns.length = 0;
            this.hideableColumnService.updateForLastVisibleColumn();
            this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
            this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
            // Add only the hidden columns to the toggler.
            columnList.forEach(col => {
                if (col) {
                    this.columns.push(col);
                }
            });
        }));
        this.subscriptions.push(this.columnToggleButtons.selectAllButtonClicked.subscribe(() => {
            this.selectAll();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    selectAll() {
        this.hideableColumnService.showHiddenColumns();
        this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
        this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
    }
    /**
     * @param {?} event
     * @param {?} column
     * @return {?}
     */
    toggleColumn(event, column) {
        column.hidden = !event;
        this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
        this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
        this.hideableColumnService.updateForLastVisibleColumn();
    }
    /**
     * @return {?}
     */
    toggleUI() {
        this.open = !this.open;
    }
}
ClrDatagridColumnToggle.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-column-toggle',
                template: `
        <button
                #anchor
                (click)="toggleUI()"
                class="btn btn-sm btn-link column-toggle--action"
                type="button">
            <clr-icon shape="view-columns" [attr.title]="commonStrings.pickColumns"></clr-icon>
        </button>
        <div class="column-switch"
             *clrPopoverOld="open; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint">
            <div class="switch-header">
                <ng-container *ngIf="!title">Show Columns</ng-container>
                <ng-content select="clr-dg-column-toggle-title"></ng-content>
                <button
                    class="btn btn-sm btn-link"
                    (click)="toggleUI()"
                    type="button">
                    <clr-icon shape="close" [attr.title]="commonStrings.close"></clr-icon>
                </button>
            </div>
            <ul class="switch-content list-unstyled">
                <li *ngFor="let column of columns">
                    <clr-checkbox-wrapper>
                        <input clrCheckbox type="checkbox"
                          [disabled]="column.lastVisibleColumn"
                          [ngModel]="!column.hidden"
                          (ngModelChange)="toggleColumn($event, column)">
                        <label><ng-template [ngTemplateOutlet]="column.template"></ng-template></label>
                    </clr-checkbox-wrapper>
                </li>
            </ul>
            <div class="switch-footer" *ngIf="buttons.length > 0">
                <ng-content select="clr-dg-column-toggle-button"></ng-content>
            </div>
            <div class="switch-footer" *ngIf="buttons.length === 0">
                <div>
                    <button
                            class="btn btn-sm btn-link p6 text-uppercase"
                            [disabled]="allColumnsVisible"
                            (click)="selectAll()"
                            type="button">Select All
                    </button>
                </div>
            </div>
        </div>
    `,
                host: { '[class.column-switch-wrapper]': 'true', '[class.active]': 'open' }
            }] }
];
/** @nocollapse */
ClrDatagridColumnToggle.ctorParameters = () => [
    { type: HideableColumnService },
    { type: ColumnToggleButtonsService },
    { type: ClrCommonStrings }
];
ClrDatagridColumnToggle.propDecorators = {
    title: [{ type: ContentChild, args: [ClrDatagridColumnToggleTitle,] }],
    buttons: [{ type: ContentChildren, args: [ClrDatagridColumnToggleButton,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * I don't think this deserves to be in IfExpanded itself,
 * so I'm adding a second directive on the same selector for now just for the datagrid
 */
class DatagridDetailRegisterer {
    /**
     * @param {?} expandableRowsCount
     */
    constructor(expandableRowsCount) {
        this.expandableRowsCount = expandableRowsCount;
        if (this.expandableRowsCount) {
            this.expandableRowsCount.register();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.expandableRowsCount) {
            this.expandableRowsCount.unregister();
        }
    }
}
DatagridDetailRegisterer.decorators = [
    { type: Directive, args: [{ selector: '[clrIfExpanded]' },] }
];
/** @nocollapse */
DatagridDetailRegisterer.ctorParameters = () => [
    { type: ExpandableRowsCount, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDatagridFooter {
    /**
     * @param {?} selection
     * @param {?} hideableColumnService
     * @param {?} cdr
     */
    constructor(selection, hideableColumnService, cdr) {
        this.selection = selection;
        this.hideableColumnService = hideableColumnService;
        this.cdr = cdr;
        this.subscriptions = [];
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(change => {
            /** @type {?} */
            const hiddenColumnsInSub = change.filter(col => col);
            if (hiddenColumnsInSub.length > 0) {
                this.activeToggler = true;
            }
        }));
        /** @type {?} */
        const hiddenColumns = this.hideableColumnService.getColumns().filter(col => col);
        if (hiddenColumns.length > 0) {
            this.activeToggler = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => {
            sub.unsubscribe();
        });
    }
}
ClrDatagridFooter.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-footer',
                template: `
        <ng-container
            *ngIf="(selection.selectionType === SELECTION_TYPE.Multi) && (selection.current.length > 0)">
          <div class="clr-form-control-disabled">
              <clr-checkbox-wrapper class="datagrid-footer-select">
                <input clrCheckbox type="checkbox" checked="checked" disabled>
                <label>{{selection.current.length}}</label>
            </clr-checkbox-wrapper>
          </div>
        </ng-container>
        <ng-content select="clr-dg-column-toggle"></ng-content>
        <clr-dg-column-toggle *ngIf="!toggle && activeToggler"></clr-dg-column-toggle>
        <div class="datagrid-footer-description">
            <ng-content></ng-content>
        </div>
        <ng-content select="clr-dg-pagination"></ng-content>
    `,
                host: {
                    '[class.datagrid-footer]': 'true',
                }
            }] }
];
/** @nocollapse */
ClrDatagridFooter.ctorParameters = () => [
    { type: Selection },
    { type: HideableColumnService },
    { type: ChangeDetectorRef }
];
ClrDatagridFooter.propDecorators = {
    toggle: [{ type: ContentChild, args: [ClrDatagridColumnToggle,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 * A utility class for that adds hide/show functionality to a column, its cells and enables a toggler in the
 * DatagridColumnToggle Component.
 *
 */
class DatagridHideableColumnModel {
    /**
     *
     * \@description
     * The init function for DatagridHideableColumnModel instances that does the following:
     *
     * 1. Set values for the private variables that enable a hideable column
     * 2. Broadcast the next hidden change for anyone (already) subscribed to this DatagridHideableColumnModel
     *
     * @param {?} _template
     * @param {?} _id
     * @param {?=} _hidden
     */
    constructor(_template, _id, _hidden = false) {
        this._template = _template;
        this._id = _id;
        this._hidden = _hidden;
        /**
         * \@property hiddenChanges
         *
         * \@description
         * A stream of state changes an instance of DatagridHideableColumnModel will broadcast to subscribers.
         *
         */
        this.hiddenChangesState = new Subject();
        // Flag this true when the service only has one visible column open.
        this.lastVisibleColumn = false;
    }
    /**
     *
     * \@description
     * A getter function that returns an TemplateRef of the DatagridColumn that is hideable. This is currently used to
     * populate the DatagridColumnToggle UI with the correct Column name.
     *
     * @return {?}
     */
    get template() {
        return this._template;
    }
    /**
     *
     * \@description
     * public function that returns the id of a HideableCOlumn instance. Used by the HideableCOlumnService for passing
     * state and actions between DateGridColumns, DataGridCells & the DatagridColumnToggle Components.
     *
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     *
     * \@description
     * A getter that returns the hidden value of a DatagridHideableColumnModel instance.
     *
     * @return {?}
     */
    get hidden() {
        return this._hidden;
    }
    /**
     *
     * \@description
     * The setter for setting the hidden state of a DatagridHideableColumnModel instance.
     * It also broadcasts the change after its set.
     *
     * @param {?} value
     * @return {?}
     */
    set hidden(value) {
        if (this._hidden === value) {
            return;
        }
        this._hidden = value;
        this.hiddenChangesState.next(value);
    }
    /**
     *
     * \@description
     * An Observable for the HideableColumns hidden changes.
     *
     * @return {?}
     */
    get hiddenChangeState() {
        return this.hiddenChangesState.asObservable();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * @description
 * A structural directive meant to be used inside a clr-dg-column component.
 *
 * <clr-dg-column>
 *       <ng-container *clrDgHideableColumn="{ hidden: true }">
 *           User ID
 *       </ng-container>
 *   </clr-dg-column>
 *
 * It sets up state and properties so that columns can be manges for hide/show by a service and an internal
 * datagrid toggle component.
 *
 */
class ClrDatagridHideableColumn {
    /**
     * \@description
     * Used the DatagridColumn to get and set an id for this HiddenColumn
     *
     * @param {?} templateRef
     * @param {?} viewContainerRef
     * @param {?} dgColumn
     */
    constructor(templateRef, viewContainerRef, dgColumn) {
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.dgColumn = dgColumn;
        this.hiddenChange = new EventEmitter();
        this.columnId = dgColumn.columnId;
        // Use the templateRef to create this view
        this.viewContainerRef.createEmbeddedView(this.templateRef);
        // Create instance of the utility class DatagridHideableColumn.
        // Note this is on the parent instance of DatagridColumn.
        this.dgColumn.hideable = new DatagridHideableColumnModel(this.templateRef, this.columnId, this._hidden);
        this.dgColumn.hideable.hiddenChangeState.subscribe(state$$1 => this.hiddenChange.emit(state$$1));
    }
    /**
     *
     * \@description
     * Setter fn for the \@Input with the same name as this structural directive.
     * It allows the user to pre-configure the column's hide/show state. { hidden: true }
     * It's more verbose but has more Clarity.
     *
     *
     * \@example
     * *clrDgHideableColumn
     * *clrDgHideableColumn={hidden: false}
     * *clrDgHideableColumn={hidden: true}
     *
     * @param {?} value
     * @return {?}
     */
    set clrDgHideableColumn(value) {
        this.clrDgHidden = value && value.hidden ? value.hidden : false;
    }
    /**
     * @param {?} hidden
     * @return {?}
     */
    set clrDgHidden(hidden) {
        this._hidden = hidden ? hidden : false;
        if (this.dgColumn.hideable) {
            this.dgColumn.hideable.hidden = this._hidden;
        }
    }
}
ClrDatagridHideableColumn.decorators = [
    { type: Directive, args: [{ selector: '[clrDgHideableColumn]' },] }
];
/** @nocollapse */
ClrDatagridHideableColumn.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: ClrDatagridColumn }
];
ClrDatagridHideableColumn.propDecorators = {
    clrDgHideableColumn: [{ type: Input, args: ['clrDgHideableColumn',] }],
    clrDgHidden: [{ type: Input, args: ['clrDgHidden',] }],
    hiddenChange: [{ type: Output, args: ['clrDgHiddenChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDatagridItemsTrackBy {
    /**
     * @param {?} _items
     */
    constructor(_items) {
        this._items = _items;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set trackBy(value) {
        if (this._items) {
            this._items.trackBy = value;
        }
    }
}
ClrDatagridItemsTrackBy.decorators = [
    { type: Directive, args: [{
                selector: '[ngForTrackBy]',
            },] }
];
/** @nocollapse */
ClrDatagridItemsTrackBy.ctorParameters = () => [
    { type: Items, decorators: [{ type: Optional }] }
];
ClrDatagridItemsTrackBy.propDecorators = {
    trackBy: [{ type: Input, args: ['ngForTrackBy',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridPageSize {
    /**
     * @param {?} page
     */
    constructor(page) {
        this.page = page;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.pageSizeOptions || this.pageSizeOptions.length === 0) {
            this.pageSizeOptions = [this.page.size];
        }
    }
}
ClrDatagridPageSize.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-page-size',
                template: `
    <ng-content></ng-content>
    <div class="clr-select-wrapper">
      <select [class.clr-page-size-select]="true" [(ngModel)]="page.size">
        <option *ngFor="let option of pageSizeOptions" [ngValue]="option">{{option}}</option>
      </select>
    </div>
  `
            }] }
];
/** @nocollapse */
ClrDatagridPageSize.ctorParameters = () => [
    { type: Page }
];
ClrDatagridPageSize.propDecorators = {
    pageSizeOptions: [{ type: Input, args: ['clrPageSizeOptions',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDatagridPagination {
    /**
     * @param {?} page
     */
    constructor(page) {
        this.page = page;
        this.defaultSize = true;
        this.currentChanged = new EventEmitter(false);
    }
    /**
     * *******
     * Subscription to the Page service for page changes.
     * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
     * @return {?}
     */
    ngOnInit() {
        /*
         * Default page size is 10.
         * The reason we set it in this constructor and not in the provider itself is because
         * we don't want pagination (page size 0) if this component isn't present in the datagrid.
         */
        if (this.defaultSize) {
            this.page.size = 10;
        }
        this._pageSubscription = this.page.change.subscribe(current => this.currentChanged.emit(current));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.page.resetPageSize();
        if (this._pageSubscription) {
            this._pageSubscription.unsubscribe();
        }
    }
    /**
     * Page size
     * @return {?}
     */
    get pageSize() {
        return this.page.size;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    set pageSize(size) {
        if (typeof size === 'number') {
            this.defaultSize = false;
            this.page.size = size;
        }
    }
    /**
     * Total items (needed to guess the last page)
     * @return {?}
     */
    get totalItems() {
        return this.page.totalItems;
    }
    /**
     * @param {?} total
     * @return {?}
     */
    set totalItems(total) {
        if (typeof total === 'number') {
            this.page.totalItems = total;
        }
    }
    /**
     * Last page
     * @return {?}
     */
    get lastPage() {
        return this.page.last;
    }
    /**
     * @param {?} last
     * @return {?}
     */
    set lastPage(last) {
        if (typeof last === 'number') {
            this.page.last = last;
        }
    }
    /**
     * Current page
     * @return {?}
     */
    get currentPage() {
        return this.page.current;
    }
    /**
     * @param {?} page
     * @return {?}
     */
    set currentPage(page) {
        if (typeof page === 'number') {
            this.page.current = page;
        }
    }
    /**
     * Moves to the previous page if it exists
     * @return {?}
     */
    previous() {
        this.page.previous();
    }
    /**
     * Moves to the next page if it exists
     * @return {?}
     */
    next() {
        this.page.next();
    }
    /**
     * Index of the first item displayed on the current page, starting at 0
     * @return {?}
     */
    get firstItem() {
        return this.page.firstItem;
    }
    /**
     * Index of the last item displayed on the current page, starting at 0
     * @return {?}
     */
    get lastItem() {
        return this.page.lastItem;
    }
    /**
     * Conditionally adds page numbers before and after the current page
     * @return {?}
     */
    get middlePages() {
        /** @type {?} */
        const middlePages = [];
        if (this.page.current > 1) {
            middlePages.push(this.page.current - 1);
        }
        middlePages.push(this.page.current);
        if (this.page.current < this.page.last) {
            middlePages.push(this.page.current + 1);
        }
        return middlePages;
    }
    /**
     * We only update the pagination's current page on blur of the input field, or
     * when they press enter.
     * @param {?} event
     * @return {?}
     */
    updateCurrentPage(event) {
        /** @type {?} */
        const parsed = parseInt(event.target.value, 10);
        // if the input value, is not a number, we don't update the page
        if (!isNaN(parsed)) {
            if (parsed < 1) {
                this.page.current = 1;
            }
            else if (parsed > this.page.last) {
                this.page.current = this.page.last;
            }
            else {
                this.page.current = parsed;
            }
        }
        /**
         * Set the input's value to the new current page. This is needed because the code
         * above may have changed the value from what the user entered in.
         */
        this.currentPageInputRef.nativeElement.value = this.page.current;
    }
}
ClrDatagridPagination.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-pagination',
                template: `
    <div class="pagination-size" *ngIf="_pageSizeComponent">
      <ng-content select="clr-dg-page-size"></ng-content>
    </div>
    <div class="pagination-description">
      <ng-content></ng-content>
    </div>
    <div class="pagination-list" *ngIf="page.last > 1">
      <button class="pagination-first" [disabled]="page.current <= 1" (click)="page.current = 1">
        <clr-icon shape="step-forward-2 down"></clr-icon>
      </button>
      <button class="pagination-previous" [disabled]="page.current <= 1" (click)="page.current = page.current - 1">
        <clr-icon shape="angle left"></clr-icon>
      </button>
      <input #currentPageInput type="text" class="pagination-current" [size]="page.last.toString().length" [value]="page.current"
             (keydown.enter)="updateCurrentPage($event)" (blur)="updateCurrentPage($event)"/>&nbsp;/&nbsp;<span>{{page.last}}</span>
      <button class="pagination-next" [disabled]="page.current >= page.last" (click)="page.current = page.current + 1">
        <clr-icon shape="angle right"></clr-icon>
      </button>
      <button class="pagination-last" [disabled]="page.current >= page.last" (click)="page.current = page.last">
        <clr-icon shape="step-forward-2 up"></clr-icon>
      </button>
    </div>
    `,
                host: { '[class.pagination]': 'true' }
            }] }
];
/** @nocollapse */
ClrDatagridPagination.ctorParameters = () => [
    { type: Page }
];
ClrDatagridPagination.propDecorators = {
    _pageSizeComponent: [{ type: ContentChild, args: [ClrDatagridPageSize,] }],
    currentPageInputRef: [{ type: ViewChild, args: ['currentPageInput',] }],
    pageSize: [{ type: Input, args: ['clrDgPageSize',] }],
    totalItems: [{ type: Input, args: ['clrDgTotalItems',] }],
    lastPage: [{ type: Input, args: ['clrDgLastPage',] }],
    currentPage: [{ type: Input, args: ['clrDgPage',] }],
    currentChanged: [{ type: Output, args: ['clrDgPageChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Generic bland container serving various purposes for Datagrid.
 * For instance, it can help span a text over multiple rows in detail view.
 * @template T
 */
class ClrDatagridRowDetail {
    /**
     * @param {?} selection
     * @param {?} rowActionService
     * @param {?} expand
     * @param {?} hideableColumnService
     * @param {?} expandableRows
     */
    constructor(selection, rowActionService, expand, hideableColumnService, expandableRows) {
        this.selection = selection;
        this.rowActionService = rowActionService;
        this.expand = expand;
        this.hideableColumnService = hideableColumnService;
        this.expandableRows = expandableRows;
        /* reference to the enum so that template can access it */
        this.SELECTION_TYPE = SelectionType;
        this.subscriptions = [];
        this.replacedRow = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set replace(value) {
        this.expand.setReplace(!!value);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const columnsList = this.hideableColumnService.getColumns();
        this.updateCellsForColumns(columnsList);
        // Triggered when the Cells list changes per row-renderer
        this.subscriptions.push(this.cells.changes.subscribe(cellList => {
            /** @type {?} */
            const columnList = this.hideableColumnService.getColumns();
            if (cellList.length === columnList.length) {
                this.updateCellsForColumns(columnList);
            }
        }));
        // Used to set things up the first time but only after all the columns are ready.
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(columnList => {
            // Prevents cell updates when cols and cells array are not aligned
            if (columnList.length === this.cells.length) {
                this.updateCellsForColumns(columnList);
            }
        }));
        this.subscriptions.push(this.expand.replace.subscribe(replaceChange => {
            this.replacedRow = replaceChange;
        }));
    }
    /**
     * @param {?} columnList
     * @return {?}
     */
    updateCellsForColumns(columnList) {
        this.cells.forEach((cell, index) => {
            /** @type {?} */
            const currentColumn = columnList[index];
            if (currentColumn) {
                cell.id = currentColumn.id;
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
ClrDatagridRowDetail.decorators = [
    { type: Component, args: [{
                selector: 'clr-dg-row-detail',
                template: `
        <ng-container *ngIf="!replacedRow">
            <!-- space for multiselection state -->
            <div class="datagrid-cell datagrid-select datagrid-fixed-column"
                *ngIf="selection.selectionType === SELECTION_TYPE.Multi">
            </div>
            <!-- space for single selection state -->
            <div class="datagrid-cell datagrid-select datagrid-fixed-column"
                *ngIf="selection.selectionType === SELECTION_TYPE.Single">
            </div>
            <!-- space for single row action; only displayType if we have at least one actionable row in datagrid -->
            <div class="datagrid-cell datagrid-row-actions datagrid-fixed-column"
                *ngIf="rowActionService.hasActionableRow">
            </div>
            <!-- space for expandable caret action; only displayType if we have at least one expandable row in datagrid -->
            <div *ngIf="expandableRows.hasExpandableRow"
                        class="datagrid-expandable-caret datagrid-fixed-column datagrid-cell">
            </div>
        </ng-container>
        <ng-content></ng-content>
    `,
                host: {
                    '[class.datagrid-row-flex]': 'true',
                    '[class.datagrid-row-detail]': 'true',
                    '[class.datagrid-container]': 'cells.length === 0',
                }
            }] }
];
/** @nocollapse */
ClrDatagridRowDetail.ctorParameters = () => [
    { type: Selection },
    { type: RowActionService },
    { type: Expand },
    { type: HideableColumnService },
    { type: ExpandableRowsCount }
];
ClrDatagridRowDetail.propDecorators = {
    cells: [{ type: ContentChildren, args: [ClrDatagridCell,] }],
    replace: [{ type: Input, args: ['clrDgReplace',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const STRICT_WIDTH_CLASS = 'datagrid-fixed-width';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatagridCellRenderer {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} organizer
     */
    constructor(el, renderer, organizer) {
        this.el = el;
        this.renderer = renderer;
        this.subscriptions = [];
        this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(() => this.clearWidth()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    clearWidth() {
        this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        this.renderer.setStyle(this.el.nativeElement, 'width', null);
    }
    /**
     * @param {?} strict
     * @param {?} value
     * @return {?}
     */
    setWidth(strict, value) {
        if (strict) {
            this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        }
        else {
            this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        }
        this.renderer.setStyle(this.el.nativeElement, 'width', value + 'px');
    }
}
DatagridCellRenderer.decorators = [
    { type: Directive, args: [{ selector: 'clr-dg-cell' },] }
];
/** @nocollapse */
DatagridCellRenderer.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DatagridRenderOrganizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatagridColumnResizer {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} organizer
     * @param {?} domAdapter
     * @param {?} dragDispatcher
     * @param {?} table
     */
    constructor(el, renderer, organizer, domAdapter, dragDispatcher, table) {
        this.renderer = renderer;
        this.organizer = organizer;
        this.domAdapter = domAdapter;
        this.dragDispatcher = dragDispatcher;
        this.table = table;
        this.columnResizeBy = 0;
        // relative to pageStartPosition
        this.dragWithinMinWidth = false;
        this.resizeEmitter = new EventEmitter();
        this.subscriptions = [];
        this.columnEl = el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dragDispatcher.destroy();
        this.subscriptions.forEach((sub) => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.handleTrackerEl = this.dragDispatcher.handleTrackerRef.nativeElement;
        this.dragDispatcher.addDragListener();
        this.subscriptions.push(this.dragDispatcher.onDragStart.subscribe(() => this.dragStartHandler()));
        this.subscriptions.push(this.dragDispatcher.onDragMove.subscribe($event => this.dragMoveHandler($event)));
        this.subscriptions.push(this.dragDispatcher.onDragEnd.subscribe(() => this.dragEndHandler()));
    }
    /**
     * @return {?}
     */
    dragStartHandler() {
        if (!this.columnMinWidth) {
            // sets the min width only on the very first drag attempt
            this.columnMinWidth = this.domAdapter.minWidth(this.columnEl);
        }
        this.renderer.setStyle(this.handleTrackerEl, 'display', 'block');
        this.renderer.setStyle(this.handleTrackerEl, 'height', this.table.getColumnDragHeight());
        this.renderer.setStyle(document.body, 'cursor', 'col-resize');
        this.dragDistancePositionX = 0;
        this.columnRectWidth = this.domAdapter.clientRect(this.columnEl).width;
        this.pageStartPositionX = this.domAdapter.clientRect(this.columnEl).right;
    }
    /**
     * @param {?} moveEvent
     * @return {?}
     */
    dragMoveHandler(moveEvent) {
        /** @type {?} */
        const pageMovePosition = moveEvent.pageX || moveEvent.changedTouches[0].pageX;
        this.dragDistancePositionX = this.getPositionWithinMax(pageMovePosition - this.pageStartPositionX);
        this.renderer.setStyle(this.handleTrackerEl, 'right', -1 * this.dragDistancePositionX + 'px');
    }
    /**
     * @return {?}
     */
    dragEndHandler() {
        this.renderer.setStyle(this.handleTrackerEl, 'right', '0px');
        this.renderer.setStyle(this.handleTrackerEl, 'display', 'none');
        this.renderer.setStyle(document.body, 'cursor', 'auto');
        if (this.dragDistancePositionX) {
            this.columnResizeBy = this.dragDistancePositionX;
            this.resizeEmitter.emit(this.columnRectWidth + this.columnResizeBy);
            this.organizer.resize();
        }
    }
    /**
     * @param {?} draggedDistance
     * @return {?}
     */
    getPositionWithinMax(draggedDistance) {
        if (draggedDistance < 0) {
            if (Math.abs(draggedDistance) < this.columnRectWidth - this.columnMinWidth) {
                if (this.dragWithinMinWidth) {
                    this.dragWithinMinWidth = false;
                    this.renderer.removeClass(this.handleTrackerEl, 'exceeded-max');
                }
                return draggedDistance;
            }
            else {
                if (!this.dragWithinMinWidth) {
                    this.dragWithinMinWidth = true;
                    this.renderer.addClass(this.handleTrackerEl, 'exceeded-max');
                }
                return this.columnMinWidth - this.columnRectWidth;
            }
        }
        else {
            if (this.dragWithinMinWidth) {
                this.dragWithinMinWidth = false;
                this.renderer.removeClass(this.handleTrackerEl, 'exceeded-max');
            }
            return draggedDistance;
        }
    }
}
DatagridColumnResizer.decorators = [
    { type: Directive, args: [{ selector: 'clr-dg-column', providers: [DragDispatcher] },] }
];
/** @nocollapse */
DatagridColumnResizer.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DatagridRenderOrganizer },
    { type: DomAdapter },
    { type: DragDispatcher },
    { type: TableSizeService }
];
DatagridColumnResizer.propDecorators = {
    resizeEmitter: [{ type: Output, args: ['clrDgColumnResize',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatagridHeaderRenderer {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} organizer
     * @param {?} domAdapter
     * @param {?} columnResizer
     */
    constructor(el, renderer, organizer, domAdapter, columnResizer) {
        this.el = el;
        this.renderer = renderer;
        this.organizer = organizer;
        this.domAdapter = domAdapter;
        this.columnResizer = columnResizer;
        this.widthSet = false;
        this.subscriptions = [];
        this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(() => this.clearWidth()));
        this.subscriptions.push(this.organizer
            .filterRenderSteps(DatagridRenderStep.DETECT_STRICT_WIDTHS)
            .subscribe(() => this.detectStrictWidth()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    clearWidth() {
        // remove the width only if we set it, and it is not changed by dragging.
        if (this.widthSet && !this.columnResizer.columnResizeBy) {
            this.renderer.setStyle(this.el.nativeElement, 'width', null);
        }
    }
    /**
     * @return {?}
     */
    detectStrictWidth() {
        if (this.columnResizer.columnResizeBy) {
            this.strictWidth = this.columnResizer.columnRectWidth + this.columnResizer.columnResizeBy;
        }
        else {
            this.strictWidth = this.domAdapter.userDefinedWidth(this.el.nativeElement);
        }
    }
    /**
     * @return {?}
     */
    computeWidth() {
        /** @type {?} */
        let width = this.strictWidth;
        if (!width) {
            width = this.domAdapter.scrollWidth(this.el.nativeElement);
        }
        return width;
    }
    /**
     * @param {?} width
     * @return {?}
     */
    setWidth(width) {
        if (this.strictWidth) {
            if (this.columnResizer.columnResizeBy) {
                this.renderer.setStyle(this.el.nativeElement, 'width', width + 'px');
                this.columnResizer.columnResizeBy = 0;
                this.widthSet = false;
            }
            // Don't set width if there is a user-defined one. Just add the strict width class.
            this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
            return;
        }
        this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        this.renderer.setStyle(this.el.nativeElement, 'width', width + 'px');
        this.widthSet = true;
    }
}
DatagridHeaderRenderer.decorators = [
    { type: Directive, args: [{ selector: 'clr-dg-column' },] }
];
/** @nocollapse */
DatagridHeaderRenderer.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DatagridRenderOrganizer },
    { type: DomAdapter },
    { type: DatagridColumnResizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NoopDomAdapter {
    /**
     * @param {?} element
     * @return {?}
     */
    userDefinedWidth(element) {
        return 0;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    scrollBarWidth(element) {
        return 0;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    scrollWidth(element) {
        return 0;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    computedHeight(element) {
        return 0;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    clientRect(element) {
        return {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0,
        };
    }
    /**
     * @param {?} element
     * @return {?}
     */
    minWidth(element) {
        return 0;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    focus(element) { }
}
NoopDomAdapter.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// Fixes build error
// @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
/** @type {?} */
const domAdapterFactory = (platformId) => {
    if (isPlatformBrowser(platformId)) {
        return new DomAdapter();
    }
    else {
        return new NoopDomAdapter();
    }
};
// Fixes build error
// @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
/**
 * @template T
 */
class DatagridMainRenderer {
    /**
     * @param {?} organizer
     * @param {?} items
     * @param {?} page
     * @param {?} domAdapter
     * @param {?} el
     * @param {?} renderer
     * @param {?} tableSizeService
     */
    constructor(organizer, items, page, domAdapter, el, renderer, tableSizeService) {
        this.organizer = organizer;
        this.items = items;
        this.page = page;
        this.domAdapter = domAdapter;
        this.el = el;
        this.renderer = renderer;
        this.tableSizeService = tableSizeService;
        this._heightSet = false;
        this.subscriptions = [];
        /**
         * Indicates if we want to re-compute columns width. This should only happen:
         * 1) When headers change, with columns being added or removed
         * 2) When rows are lazily loaded for the first time
         */
        this.columnsSizesStable = false;
        this.shouldStabilizeColumns = true;
        this.subscriptions.push(this.organizer
            .filterRenderSteps(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS)
            .subscribe(() => this.computeHeadersWidth()));
        this.subscriptions.push(this.page.sizeChange.subscribe(() => {
            if (this._heightSet) {
                this.resetDatagridHeight();
            }
        }));
        this.subscriptions.push(this.items.change.subscribe(() => (this.shouldStabilizeColumns = true)));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.subscriptions.push(this.headers.changes.subscribe(() => {
            // TODO: only re-stabilize if a column was added or removed. Reordering is fine.
            this.columnsSizesStable = false;
            this.stabilizeColumns();
        }));
    }
    // Initialize and set Table width for horizontal scrolling here.
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.tableSizeService.table = this.el;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.shouldStabilizeColumns) {
            this.stabilizeColumns();
        }
        if (this.shouldComputeHeight()) {
            setTimeout(() => {
                this.computeDatagridHeight();
            });
        }
    }
    /**
     * @return {?}
     */
    shouldComputeHeight() {
        if (!this._heightSet && this.page.size > 0) {
            if (this.items.displayed.length === this.page.size) {
                return true;
            }
        }
        return false;
    }
    /**
     * Computes the height of the datagrid.
     *
     * NOTE: We had to choose to set the height instead of the min-height because
     * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
     * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
     * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
     *
     * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
     * @return {?}
     */
    computeDatagridHeight() {
        // IE doesn't return correct value for getComputedStyle(element).getPropertyValue("height")
        /** @type {?} */
        const value = this.domAdapter.clientRect(this.el.nativeElement).height;
        this.renderer.setStyle(this.el.nativeElement, 'height', value + 'px');
        this._heightSet = true;
    }
    /**
     * @return {?}
     */
    resetDatagridHeight() {
        this.renderer.setStyle(this.el.nativeElement, 'height', '');
        this._heightSet = false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * Makes each header compute its width.
     * @return {?}
     */
    computeHeadersWidth() {
        /** @type {?} */
        const nbColumns = this.headers.length;
        /** @type {?} */
        let allStrict = true;
        this.headers.forEach((header, index) => {
            // On the last header column check whether all columns have strict widths.
            // If all columns have strict widths, remove the strict width from the last column and make it the column's
            // minimum width so that when all previous columns shrink, it will get a flexible width and cover the empty
            // gap in the Datagrid.
            if (!header.strictWidth) {
                allStrict = false;
            }
            if (nbColumns === index + 1 && allStrict) {
                delete header.strictWidth;
            }
            this.organizer.widths[index] = { px: header.computeWidth(), strict: !!header.strictWidth };
        });
        this.headers.forEach((header, index) => header.setWidth(this.organizer.widths[index].px));
    }
    /**
     * Triggers a whole re-rendring cycle to set column sizes, if needed.
     * @return {?}
     */
    stabilizeColumns() {
        this.shouldStabilizeColumns = false;
        if (this.columnsSizesStable) {
            // Nothing to do.
            return;
        }
        // Resize when the rows are loaded.
        if (this.items.displayed.length > 0) {
            this.organizer.resize();
            this.columnsSizesStable = true;
        }
    }
}
DatagridMainRenderer.decorators = [
    { type: Directive, args: [{
                selector: 'clr-datagrid',
                providers: [{ provide: DomAdapter, useFactory: domAdapterFactory, deps: [PLATFORM_ID] }],
            },] }
];
/** @nocollapse */
DatagridMainRenderer.ctorParameters = () => [
    { type: DatagridRenderOrganizer },
    { type: Items },
    { type: Page },
    { type: DomAdapter },
    { type: ElementRef },
    { type: Renderer2 },
    { type: TableSizeService }
];
DatagridMainRenderer.propDecorators = {
    headers: [{ type: ContentChildren, args: [DatagridHeaderRenderer,] }],
    columns: [{ type: ContentChildren, args: [ClrDatagridColumn,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class DatagridRowRenderer {
    /**
     * @param {?} organizer
     */
    constructor(organizer) {
        this.organizer = organizer;
        this.subscriptions = [];
        this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.ALIGN_COLUMNS).subscribe(() => this.setWidths()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
    /**
     * @return {?}
     */
    setWidths() {
        if (this.organizer.widths.length !== this.cells.length) {
            return;
        }
        this.cells.forEach((cell, index) => {
            /** @type {?} */
            const width = this.organizer.widths[index];
            cell.setWidth(width.strict, width.px);
        });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.cells.changes.subscribe(() => {
            this.setWidths();
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setWidths();
    }
}
DatagridRowRenderer.decorators = [
    { type: Directive, args: [{ selector: 'clr-dg-row, clr-dg-row-detail' },] }
];
/** @nocollapse */
DatagridRowRenderer.ctorParameters = () => [
    { type: DatagridRenderOrganizer }
];
DatagridRowRenderer.propDecorators = {
    cells: [{ type: ContentChildren, args: [DatagridCellRenderer,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_DATAGRID_DIRECTIVES = [
    // Core
    ClrDatagrid,
    ClrDatagridActionBar,
    ClrDatagridActionOverflow,
    ClrDatagridColumn,
    ClrDatagridColumnToggle,
    ClrDatagridHideableColumn,
    ClrDatagridFilter,
    ClrDatagridItems,
    ClrDatagridItemsTrackBy,
    ClrDatagridRow,
    ClrDatagridRowDetail,
    DatagridDetailRegisterer,
    ClrDatagridCell,
    ClrDatagridFooter,
    ClrDatagridPagination,
    ClrDatagridPageSize,
    ClrDatagridPlaceholder,
    ClrDatagridColumnToggleButton,
    ClrDatagridColumnToggleTitle,
    WrappedCell,
    WrappedColumn,
    WrappedRow,
    // Renderers
    DatagridMainRenderer,
    DatagridHeaderRenderer,
    DatagridColumnResizer,
    DatagridRowRenderer,
    DatagridCellRenderer,
    // Chocolate
    DatagridWillyWonka,
    ActionableOompaLoompa,
    ExpandableOompaLoompa,
    // Animation hack
    DatagridRowExpandAnimation,
    // Built-in shortcuts
    DatagridStringFilter,
];
class ClrDatagridModule {
}
ClrDatagridModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ClrIconModule,
                    ClrFormsModule,
                    FormsModule,
                    ClrCommonPopoverModule,
                    ClrLoadingModule,
                    ClrOutsideClickModule,
                ],
                declarations: [CLR_DATAGRID_DIRECTIVES],
                exports: [CLR_DATAGRID_DIRECTIVES, ClrIfExpandModule],
                entryComponents: [WrappedCell, WrappedColumn, WrappedRow],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrStackBlock {
    /*
         * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
         * querying for children StackBlocks, but this feature is not available when downgrading
         * the component for Angular 1.
         */
    /**
     * @param {?} parent
     * @param {?} commonStrings
     */
    constructor(parent, commonStrings) {
        this.parent = parent;
        this.commonStrings = commonStrings;
        this.expanded = false;
        this.expandedChange = new EventEmitter(false);
        this.expandable = false;
        this.focused = false;
        this._changedChildren = 0;
        this._fullyInitialized = false;
        this._changed = false;
        if (parent) {
            parent.addChild();
        }
    }
    /**
     * @return {?}
     */
    get getChangedValue() {
        return this._changed || (this._changedChildren > 0 && !this.expanded);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set setChangedValue(value) {
        this._changed = value;
        if (this.parent && this._fullyInitialized) {
            if (value) {
                this.parent._changedChildren++;
            }
            else {
                this.parent._changedChildren--;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // in order to access the parent ClrStackBlock's properties,
        // the child ClrStackBlock  has to be fully initialized at first.
        this._fullyInitialized = true;
    }
    /**
     * @return {?}
     */
    addChild() {
        this.expandable = true;
    }
    /**
     * @return {?}
     */
    toggleExpand() {
        if (this.expandable) {
            this.expanded = !this.expanded;
            this.expandedChange.emit(this.expanded);
        }
    }
    /**
     * @return {?}
     */
    get caretDirection() {
        return this.expanded ? 'down' : 'right';
    }
    /**
     * @return {?}
     */
    get caretTitle() {
        return this.expanded ? this.commonStrings.collapse : this.commonStrings.expand;
    }
    /**
     * @return {?}
     */
    get role() {
        return this.expandable ? 'button' : null;
    }
    /**
     * @return {?}
     */
    get tabIndex() {
        return this.expandable ? '0' : null;
    }
    /**
     * @return {?}
     */
    get onStackLabelFocus() {
        return this.expandable && !this.expanded && this.focused;
    }
    /**
     * @return {?}
     */
    get ariaExpanded() {
        if (!this.expandable) {
            return null;
        }
        else {
            return this.expanded ? 'true' : 'false';
        }
    }
}
ClrStackBlock.decorators = [
    { type: Component, args: [{
                selector: 'clr-stack-block',
                template: `
    <dt class="stack-block-label"
        (click)="toggleExpand()"
        (keyup.enter)="toggleExpand()"
        (keyup.space)="toggleExpand()"
        (focus)="focused = true"
        (blur)="focused = false"
        [attr.role]="role"
        [attr.tabindex]="tabIndex"
        [attr.aria-expanded]="ariaExpanded">
      <clr-icon shape="caret"
                class="stack-block-caret"
                *ngIf="expandable"
                [attr.dir]="caretDirection"
                [attr.title]="caretTitle"></clr-icon>
      <ng-content select="clr-stack-label"></ng-content>
    </dt>
    <dd class="stack-block-content">
      <ng-content></ng-content>
    </dd>
    <!-- FIXME: remove this string concatenation when boolean states are supported -->
    <div [@collapse]="''+!expanded" class="stack-children" >
      <ng-content select="clr-stack-block"></ng-content>
    </div>
  `,
                // Make sure the host has the proper class for styling purposes
                host: { '[class.stack-block]': 'true' },
                animations: [
                    trigger('collapse', [
                        state('true', style({ height: 0, display: 'none' })),
                        transition('true => false', [animate('0.2s ease-in-out', style({ height: '*', display: '*' }))]),
                        transition('false => true', [style({ height: '*', display: '*' }), animate('0.2s ease-in-out')]),
                    ]),
                ],
                styles: [`
        :host { display: block; }
    `]
            }] }
];
/** @nocollapse */
ClrStackBlock.ctorParameters = () => [
    { type: ClrStackBlock, decorators: [{ type: SkipSelf }, { type: Optional }] },
    { type: ClrCommonStrings }
];
ClrStackBlock.propDecorators = {
    expanded: [{ type: HostBinding, args: ['class.stack-block-expanded',] }, { type: Input, args: ['clrSbExpanded',] }],
    expandedChange: [{ type: Output, args: ['clrSbExpandedChange',] }],
    expandable: [{ type: HostBinding, args: ['class.stack-block-expandable',] }, { type: Input, args: ['clrSbExpandable',] }],
    getChangedValue: [{ type: HostBinding, args: ['class.stack-block-changed',] }],
    setChangedValue: [{ type: Input, args: ['clrSbNotifyChange',] }],
    onStackLabelFocus: [{ type: HostBinding, args: ['class.on-focus',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrStackView {
    constructor() {
        /**
         * Undocumented experimental feature: inline editing.
         */
        this.editable = false;
        this.save = new EventEmitter(false);
        this._editMode = false;
        this.editingChange = new EventEmitter(false);
        /**
         * End of undocumented experimental feature.
         */
    }
    /**
     * @return {?}
     */
    get editing() {
        return this.editable && this._editMode;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set editing(value) {
        if (this.editable) {
            this._editMode = value;
            this.editingChange.emit(value);
            if (!value) {
                this.save.emit(null);
            }
        }
    }
}
ClrStackView.decorators = [
    { type: Component, args: [{
                selector: 'clr-stack-view',
                template: `
        <ng-content select="clr-stack-header"></ng-content>
        <dl class="stack-view"><ng-content></ng-content></dl>
    `,
                styles: [`
        :host { display: block; }
    `]
            }] }
];
ClrStackView.propDecorators = {
    save: [{ type: Output, args: ['clrStackSave',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrStackHeader {
    /**
     * @param {?} stackView
     */
    constructor(stackView) {
        this.stackView = stackView;
    }
}
ClrStackHeader.decorators = [
    { type: Component, args: [{
                selector: 'clr-stack-header',
                template: `
        <h4 class="stack-header">
            <span class="stack-title"><ng-content></ng-content></span>
            
            <span class="stack-actions">
                <ng-content select=".stack-action"></ng-content>
                <!-- Undocumented experimental feature: inline editing. -->
                <button *ngIf="stackView.editable" class="stack-action btn btn-sm btn-link" 
                        (click)="stackView.editing = !stackView.editing" type="button">
                        Edit
                </button>
                <!-- End of undocumented experimental feature. -->
            </span>
        </h4>
    `,
                styles: [`
        :host { display: block; }
    `]
            }] }
];
/** @nocollapse */
ClrStackHeader.ctorParameters = () => [
    { type: ClrStackView }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class StackControl {
    /**
     * @param {?} stackView
     */
    constructor(stackView) {
        this.stackView = stackView;
        this.modelChange = new EventEmitter(false);
        // Make the ClrStackView editable, since it contains a StackControl
        this.stackView.editable = true;
        this.stackView.editingChange.subscribe((editing) => {
            // Edit mode was closed
            if (!editing) {
                this.modelChange.emit(this.model);
            }
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrStackInput extends StackControl {
    /**
     * @param {?} stackView
     */
    constructor(stackView) {
        super(stackView);
        this.stackView = stackView;
        this.type = 'text';
    }
}
ClrStackInput.decorators = [
    { type: Component, args: [{
                selector: 'clr-stack-input',
                inputs: ['model: clrModel', 'type'],
                outputs: ['modelChange: clrModelChange'],
                template: `
        <span *ngIf="!stackView.editing">{{model}}</span>
        <input [type]="type" *ngIf="stackView.editing" [(ngModel)]="model"/>
    `
            }] }
];
/** @nocollapse */
ClrStackInput.ctorParameters = () => [
    { type: ClrStackView }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrStackSelect extends StackControl {
    /**
     * @param {?} stackView
     */
    constructor(stackView) {
        super(stackView);
        this.stackView = stackView;
    }
}
ClrStackSelect.decorators = [
    { type: Component, args: [{
                selector: 'clr-stack-select',
                inputs: ['model: clrModel'],
                outputs: ['modelChange: clrModelChange'],
                template: `
        <span *ngIf="!stackView.editing">{{model}}</span>
        <div class="select" *ngIf="stackView.editing" >
            <select [(ngModel)]="model">
                <ng-content></ng-content>
            </select>
        </div>
    `
            }] }
];
/** @nocollapse */
ClrStackSelect.ctorParameters = () => [
    { type: ClrStackView }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrStackViewCustomTags {
}
ClrStackViewCustomTags.decorators = [
    { type: Directive, args: [{ selector: 'clr-stack-label, clr-stack-content' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_STACK_VIEW_DIRECTIVES = [
    ClrStackView,
    ClrStackHeader,
    ClrStackBlock,
    ClrStackViewCustomTags,
    /**
     * Undocumented experimental feature: inline editing.
     */
    ClrStackInput,
    ClrStackSelect,
];
class ClrStackViewModule {
}
ClrStackViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ClrIconModule],
                declarations: [CLR_STACK_VIEW_DIRECTIVES],
                exports: [CLR_STACK_VIEW_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let NB_INSTANCES = 0;
/** @type {?} */
const UNIQUE_ID = new InjectionToken('UNIQUE_ID');
/**
 * @return {?}
 */
function uniqueIdFactory() {
    return 'clr-id-' + NB_INSTANCES++;
}
/** @type {?} */
const UNIQUE_ID_PROVIDER = {
    provide: UNIQUE_ID,
    useFactory: uniqueIdFactory,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * @abstract
 */
class AbstractTreeSelection {
    /**
     * @param {?} parent
     */
    constructor(parent) {
        this.parent = parent;
        this._selected = false;
        this._indeterminate = false;
    }
    /**
     * @return {?}
     */
    get selected() {
        return this._selected;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selected(value) {
        this._selected = value;
        this.indeterminate = false;
        this.children.forEach(child => child.parentChanged(value));
        if (this.parent) {
            this.parent.childChanged();
        }
        this.selectedChanged();
    }
    /**
     * @return {?}
     */
    get indeterminate() {
        return this._indeterminate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set indeterminate(value) {
        value = !!value;
        if (this._indeterminate !== value) {
            this._indeterminate = value;
            this.indeterminateChanged();
        }
    }
    /**
     * @return {?}
     */
    childChanged() {
        /** @type {?} */
        let oneSelectedChild = false;
        /** @type {?} */
        const previousSelectedValue = this._selected;
        /** @type {?} */
        const previousIndeterminateValue = this._indeterminate;
        this._selected = true;
        this._indeterminate = false;
        for (const child of this.children) {
            if (child.indeterminate) {
                this._selected = false;
                this._indeterminate = true;
                break;
            }
            if (child.selected) {
                oneSelectedChild = true;
                if (this._selected === false) {
                    this._indeterminate = true;
                    break;
                }
            }
            else {
                this._selected = false;
                if (oneSelectedChild) {
                    this._indeterminate = true;
                    break;
                }
            }
        }
        if (this.parent &&
            (this._selected !== previousSelectedValue || this._indeterminate !== previousIndeterminateValue)) {
            this.parent.childChanged();
        }
        if (this.selected !== previousSelectedValue) {
            this.selectedChanged();
        }
        if (this.indeterminate !== previousIndeterminateValue) {
            this.indeterminateChanged();
        }
    }
    /**
     * @param {?} selected
     * @return {?}
     */
    parentChanged(selected) {
        if (selected && !this.selected) {
            this._selected = true;
            this.indeterminate = false;
            this.children.forEach(child => child.parentChanged(true));
            this.selectedChanged();
        }
        if (!selected && (this.selected || this.indeterminate)) {
            this._selected = false;
            this.indeterminate = false;
            this.children.forEach(child => child.parentChanged(false));
            this.selectedChanged();
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TreeSelectionService {
    constructor() {
        this.selectable = false;
    }
}
TreeSelectionService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} existing
 * @return {?}
 */
function clrTreeSelectionProviderFactory(existing) {
    return existing || new TreeSelectionService();
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
const ɵ0 = clrTreeSelectionProviderFactory;
class ClrTreeNode extends AbstractTreeSelection {
    /**
     * @param {?} nodeExpand
     * @param {?} parent
     * @param {?} treeSelectionService
     * @param {?} nodeId
     * @param {?} commonStrings
     */
    constructor(nodeExpand, parent, treeSelectionService, nodeId, commonStrings) {
        super(parent);
        this.nodeExpand = nodeExpand;
        this.parent = parent;
        this.treeSelectionService = treeSelectionService;
        this.nodeId = nodeId;
        this.commonStrings = commonStrings;
        this._children = [];
        this.nodeSelectedChange = new EventEmitter(true);
        this.nodeIndeterminateChanged = new EventEmitter(true);
        if (this.parent) {
            this.parent.register(this);
        }
    }
    /**
     * @return {?}
     */
    get children() {
        return this._children;
    }
    /* Registration */
    /**
     * @param {?} node
     * @return {?}
     */
    checkIfChildNodeRegistered(node) {
        return this.children.indexOf(node) > -1;
    }
    // TODO: This should ideally be in AbstractTreeSelection
    // Tried doing this but ran into some issues and also ran out of time.
    // Will get this done later.
    /**
     * @param {?} node
     * @return {?}
     */
    register(node) {
        if (!this.checkIfChildNodeRegistered(node)) {
            this.children.push(node);
            if (this.selectable) {
                if (this.selected) {
                    node.parentChanged(this.selected);
                }
            }
        }
    }
    // TODO: This should ideally be in AbstractTreeSelection
    // Tried doing this but ran into some issues and also ran out of time.
    // Will get this done later.
    /**
     * @param {?} node
     * @return {?}
     */
    unregister(node) {
        /** @type {?} */
        const index = this.children.indexOf(node);
        if (index > -1) {
            this.children.splice(index, 1);
        }
    }
    /* Selection */
    /**
     * @return {?}
     */
    activateSelection() {
        if (this.treeSelectionService && !this.treeSelectionService.selectable) {
            this.treeSelectionService.selectable = true;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nodeSelected(value) {
        // required for recursive trees to discard unset inputs.
        this.activateSelection();
        if (value === undefined || value === null) {
            return;
        }
        if (this.selected !== value) {
            this.selected = value;
        }
    }
    /**
     * @return {?}
     */
    selectedChanged() {
        this.nodeSelectedChange.emit(this.selected);
    }
    /**
     * @return {?}
     */
    get selectable() {
        if (this.treeSelectionService) {
            return this.treeSelectionService.selectable;
        }
        return false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set nodeIndeterminate(value) {
        this.indeterminate = value;
        this.activateSelection();
    }
    /**
     * @return {?}
     */
    indeterminateChanged() {
        this.nodeIndeterminateChanged.emit(this.indeterminate);
    }
    /* Expansion */
    /**
     * @return {?}
     */
    toggleExpand() {
        this.nodeExpand.expanded = !this.nodeExpand.expanded;
    }
    /**
     * @return {?}
     */
    get caretDirection() {
        return this.nodeExpand.expanded ? 'down' : 'right';
    }
    /**
     * @return {?}
     */
    get caretTitle() {
        return this.nodeExpand.expanded ? this.commonStrings.collapse : this.commonStrings.expand;
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this.nodeExpand.expanded;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expanded(value) {
        value = !!value;
        if (this.nodeExpand.expanded !== value) {
            this.nodeExpand.expanded = value;
        }
    }
    /**
     * @return {?}
     */
    get state() {
        return this.expanded && !this.nodeExpand.loading ? 'expanded' : 'collapsed';
    }
    /**
     * @return {?}
     */
    get treeNodeRole() {
        return this.parent ? 'treeitem' : 'tree';
    }
    /**
     * @return {?}
     */
    get rootAriaMultiSelectable() {
        if (this.parent || !this.selectable) {
            return null;
        }
        else {
            return true;
        }
    }
    /**
     * @return {?}
     */
    get ariaSelected() {
        return this.selectable ? this.selected : null;
    }
    /**
     * @return {?}
     */
    get ariaTreeNodeChildrenRole() {
        return this.children.length > 0 ? 'group' : null;
    }
    /* Lifecycle */
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.parent) {
            this.parent.unregister(this);
        }
    }
}
ClrTreeNode.decorators = [
    { type: Component, args: [{
                selector: 'clr-tree-node',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"clr-tree-node-content-container\">\n    <button\n        type=\"button\"\n        class=\"clr-treenode-caret\"\n        (click)=\"toggleExpand()\"\n        *ngIf=\"nodeExpand.expandable && !nodeExpand.loading\"\n        [attr.aria-expanded]=\"nodeExpand.expanded\">\n        <clr-icon\n            class=\"clr-treenode-caret-icon\"\n            shape=\"caret\"\n            [attr.dir]=\"caretDirection\"\n            [attr.title]=\"caretTitle\"></clr-icon>\n    </button>\n    <div class=\"clr-treenode-spinner-container\" *ngIf=\"nodeExpand.expandable && nodeExpand.loading\">\n        <span class=\"clr-treenode-spinner spinner\">\n            Loading...\n        </span>\n    </div>\n    <input type=\"checkbox\" clrCheckbox *ngIf=\"selectable\" [class.clr-indeterminate]=\"indeterminate\" [(ngModel)]=\"selected\" [attr.aria-labeledby]=\"nodeId\" />\n    <div class=\"clr-treenode-content\" [id]=\"nodeId\">\n        <ng-content></ng-content>\n    </div>\n</div>\n<!-- FIXME: remove this string concatenation when boolean states are supported -->\n<div\n    class=\"clr-treenode-children\"\n    [@childNodesState]=\"state\"\n    [attr.role]=\"ariaTreeNodeChildrenRole\">\n    <ng-content select=\"clr-tree-node\"></ng-content>\n    <ng-content select=\"[clrIfExpanded]\"></ng-content>\n</div>\n",
                providers: [
                    Expand,
                    { provide: LoadingListener, useExisting: Expand },
                    {
                        provide: TreeSelectionService,
                        useFactory: ɵ0,
                        deps: [[new Optional(), new SkipSelf(), TreeSelectionService]],
                    },
                    UNIQUE_ID_PROVIDER,
                ],
                animations: [
                    trigger('childNodesState', [
                        state('expanded', style({ height: '*', 'overflow-y': 'hidden' })),
                        state('collapsed', style({ height: 0, 'overflow-y': 'hidden' })),
                        transition('expanded <=> collapsed', animate('0.2s ease-in-out')),
                    ]),
                ],
                host: { '[class.clr-tree-node]': 'true' }
            }] }
];
/** @nocollapse */
ClrTreeNode.ctorParameters = () => [
    { type: Expand },
    { type: ClrTreeNode, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: TreeSelectionService },
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] },
    { type: ClrCommonStrings }
];
ClrTreeNode.propDecorators = {
    nodeSelected: [{ type: Input, args: ['clrSelected',] }],
    nodeSelectedChange: [{ type: Output, args: ['clrSelectedChange',] }],
    nodeIndeterminate: [{ type: Input, args: ['clrIndeterminate',] }],
    nodeIndeterminateChanged: [{ type: Output, args: ['clrIndeterminateChange',] }],
    treeNodeRole: [{ type: HostBinding, args: ['attr.role',] }],
    rootAriaMultiSelectable: [{ type: HostBinding, args: ['attr.aria-multiselectable',] }],
    ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_TREE_VIEW_DIRECTIVES = [ClrTreeNode];
class ClrTreeViewModule {
}
ClrTreeViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule, FormsModule, ClrFormsModule],
                declarations: [CLR_TREE_VIEW_DIRECTIVES],
                exports: [CLR_TREE_VIEW_DIRECTIVES, ClrIfExpandModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDataModule {
}
ClrDataModule.decorators = [
    { type: NgModule, args: [{ exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This class is used to convert an internal event
// to an external event to be emitted.
/**
 * @template T
 */
class ClrDragEvent {
    /**
     * @param {?} dragEvent
     */
    constructor(dragEvent) {
        this.dragPosition = dragEvent.dragPosition;
        this.group = dragEvent.group;
        this.dragDataTransfer = dragEvent.dragDataTransfer;
        this.dropPointPosition = dragEvent.dropPointPosition;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const DragEventType = {
    DRAG_START: 0,
    DRAG_MOVE: 1,
    DRAG_END: 2,
    DRAG_ENTER: 3,
    DRAG_LEAVE: 4,
    DROP: 5,
};
DragEventType[DragEventType.DRAG_START] = 'DRAG_START';
DragEventType[DragEventType.DRAG_MOVE] = 'DRAG_MOVE';
DragEventType[DragEventType.DRAG_END] = 'DRAG_END';
DragEventType[DragEventType.DRAG_ENTER] = 'DRAG_ENTER';
DragEventType[DragEventType.DRAG_LEAVE] = 'DRAG_LEAVE';
DragEventType[DragEventType.DROP] = 'DROP';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class DragAndDropEventBusService {
    constructor() {
        this.dragStart = new Subject();
        this.dragMove = new Subject();
        this.dragEnd = new Subject();
        this.drop = new Subject();
    }
    /**
     * @return {?}
     */
    get dragStarted() {
        return this.dragStart.asObservable();
    }
    /**
     * @return {?}
     */
    get dragMoved() {
        return this.dragMove.asObservable();
    }
    /**
     * @return {?}
     */
    get dragEnded() {
        return this.dragEnd.asObservable();
    }
    /**
     * @return {?}
     */
    get dropped() {
        return this.drop.asObservable();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    broadcast(event) {
        switch (event.type) {
            case DragEventType.DRAG_START:
                this.dragStart.next(event);
                break;
            case DragEventType.DRAG_MOVE:
                this.dragMove.next(event);
                break;
            case DragEventType.DRAG_END:
                this.dragEnd.next(event);
                break;
            case DragEventType.DROP:
                this.drop.next(event);
                break;
            default:
                break;
        }
    }
}
DragAndDropEventBusService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ DragAndDropEventBusService.ngInjectableDef = defineInjectable({ factory: function DragAndDropEventBusService_Factory() { return new DragAndDropEventBusService(); }, token: DragAndDropEventBusService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class DragEventListenerService {
    /**
     * @param {?} ngZone
     * @param {?} renderer
     * @param {?} eventBus
     */
    constructor(ngZone, renderer, eventBus) {
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.eventBus = eventBus;
        this.dragStart = new Subject();
        this.dragMove = new Subject();
        this.dragEnd = new Subject();
        this.hasDragStarted = false;
    }
    /**
     * @return {?}
     */
    get dragStarted() {
        return this.dragStart.asObservable();
    }
    /**
     * @return {?}
     */
    get dragMoved() {
        return this.dragMove.asObservable();
    }
    /**
     * @return {?}
     */
    get dragEnded() {
        return this.dragEnd.asObservable();
    }
    /**
     * @param {?} draggableEl
     * @return {?}
     */
    attachDragListeners(draggableEl) {
        this.draggableEl = draggableEl;
        this.listeners = [
            this.customDragEvent(this.draggableEl, 'mousedown', 'mousemove', 'mouseup'),
            this.customDragEvent(this.draggableEl, 'touchstart', 'touchmove', 'touchend'),
        ];
    }
    /**
     * @return {?}
     */
    detachDragListeners() {
        if (this.listeners) {
            this.listeners.map(event => event());
        }
        // In most cases, once users start dragging with mousedown/touchstart events,
        // they will end dragging at one point with mouseup/touchend.
        // However, there might be a few cases where mousedown/touchstart events get registered,
        // but the draggable element gets removed before user ends dragging.
        // In that case, we need to remove the attached listeners that happened during the mousedown/touchstart events.
        if (this.nestedListeners) {
            this.nestedListeners.map(event => event());
        }
    }
    /**
     * @param {?} element
     * @param {?} startOnEvent
     * @param {?} moveOnEvent
     * @param {?} endOnEvent
     * @return {?}
     */
    customDragEvent(element, startOnEvent, moveOnEvent, endOnEvent) {
        return this.renderer.listen(element, startOnEvent, () => {
            // Initialize nested listeners' property with a new empty array;
            this.nestedListeners = [];
            // This is needed to disable selection during dragging (especially in EDGE/IE11).
            this.nestedListeners.push(this.renderer.listen('document', 'selectstart', (selectEvent) => {
                selectEvent.preventDefault();
                selectEvent.stopImmediatePropagation();
            }));
            // Listen to mousemove/touchmove events outside of angular zone.
            this.nestedListeners.push(this.ngZone.runOutsideAngular(() => {
                return this.renderer.listen('document', moveOnEvent, (moveEvent) => {
                    // Event.stopImmediatePropagation() is needed here to prevent nested draggables from getting dragged
                    // altogether. We shouldn't use Event.stopPropagation() here as we are listening to the events
                    // on the global element level.
                    // With Event.stopImmediatePropagation(), it registers the events sent from the inner most draggable
                    // first. Then immediately after that, it stops listening to the same type of events on the same
                    // element. So this will help us to not register the same events that would come from the parent
                    // level draggables eventually.
                    moveEvent.stopImmediatePropagation();
                    if (!this.hasDragStarted) {
                        this.hasDragStarted = true;
                        // Fire "dragstart"
                        this.broadcast(moveEvent, DragEventType.DRAG_START);
                    }
                    else {
                        // Fire "dragmove"
                        this.broadcast(moveEvent, DragEventType.DRAG_MOVE);
                    }
                });
            }));
            // Listen to mouseup/touchend events.
            this.nestedListeners.push(this.renderer.listen('document', endOnEvent, (endEvent) => {
                if (this.hasDragStarted) {
                    // Fire "dragend" only if dragstart is registered
                    this.hasDragStarted = false;
                    this.broadcast(endEvent, DragEventType.DRAG_END);
                }
                // We must remove the the nested listeners every time drag completes.
                if (this.nestedListeners) {
                    this.nestedListeners.map(event => event());
                }
            }));
        });
    }
    /**
     * @param {?} event
     * @param {?} eventType
     * @return {?}
     */
    broadcast(event, eventType) {
        /** @type {?} */
        const dragEvent = this.generateDragEvent(event, eventType);
        switch (dragEvent.type) {
            case DragEventType.DRAG_START:
                this.dragStart.next(dragEvent);
                break;
            case DragEventType.DRAG_MOVE:
                this.dragMove.next(dragEvent);
                break;
            case DragEventType.DRAG_END:
                this.dragEnd.next(dragEvent);
                break;
            default:
                break;
        }
        // The following properties are set after they are broadcasted to the DraggableGhost component.
        dragEvent.ghostElement = this.ghostElement;
        dragEvent.dropPointPosition = this.dropPointPosition;
        this.eventBus.broadcast(dragEvent);
    }
    /**
     * @param {?} event
     * @param {?} eventType
     * @return {?}
     */
    generateDragEvent(event, eventType) {
        /** @type {?} */
        let nativeEvent;
        if (((/** @type {?} */ (event))).hasOwnProperty('changedTouches')) {
            nativeEvent = ((/** @type {?} */ (event))).changedTouches[0];
        }
        else {
            nativeEvent = event;
        }
        return {
            type: eventType,
            dragPosition: { pageX: nativeEvent.pageX, pageY: nativeEvent.pageY },
            group: this.group,
            dragDataTransfer: this.dragDataTransfer,
            ghostElement: this.ghostElement,
        };
    }
}
DragEventListenerService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DragEventListenerService.ctorParameters = () => [
    { type: NgZone },
    { type: Renderer2 },
    { type: DragAndDropEventBusService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This service is used to capture the state of clrDraggable element
// at a certain event and passes it to clrDraggableGhost component.
/**
 * @template T
 */
class DraggableSnapshotService {
    /**
     * @param {?} domAdapter
     */
    constructor(domAdapter) {
        this.domAdapter = domAdapter;
    }
    /**
     * @param {?} el
     * @param {?} event
     * @return {?}
     */
    capture(el, event) {
        this.draggableElClientRect = this.domAdapter.clientRect(el);
        this.snapshotDragEvent = event;
    }
    /**
     * @return {?}
     */
    discard() {
        delete this.draggableElClientRect;
        delete this.snapshotDragEvent;
    }
    /**
     * @return {?}
     */
    get hasDraggableState() {
        return !!this.snapshotDragEvent && !!this.draggableElClientRect;
    }
    /**
     * @return {?}
     */
    get clientRect() {
        return this.draggableElClientRect;
    }
    /**
     * @return {?}
     */
    get dragEvent() {
        return this.snapshotDragEvent;
    }
}
DraggableSnapshotService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DraggableSnapshotService.ctorParameters = () => [
    { type: DomAdapter }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDraggableGhost {
    /**
     * @param {?} el
     * @param {?} dragEventListener
     * @param {?} draggableSnapshot
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(el, dragEventListener, draggableSnapshot, renderer, ngZone) {
        this.el = el;
        this.dragEventListener = dragEventListener;
        this.draggableSnapshot = draggableSnapshot;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.subscriptions = [];
        this.leaveAnimConfig = { value: 0, params: { top: '0px', left: '0px' } };
        if (!this.dragEventListener || !this.draggableSnapshot) {
            throw new Error('The clr-draggable-ghost component can only be used inside of a clrDraggable directive.');
        }
        this.draggableGhostEl = this.el.nativeElement;
        // Need to use Renderer2 as it runs outside of NgZone
        this.renderer.addClass(this.draggableGhostEl, 'draggable-ghost');
        // Register the ghost element in DragEventListener to pass in a ClrDragEvent.
        this.dragEventListener.ghostElement = this.draggableGhostEl;
        // Default ghost size gets the size of ClrDraggable element.
        this.setDefaultGhostSize(this.draggableGhostEl);
        /** @type {?} */
        const offset = {
            top: this.draggableSnapshot.hasDraggableState
                ? this.draggableSnapshot.dragEvent.dragPosition.pageY - this.draggableSnapshot.clientRect.top
                : 0,
            left: this.draggableSnapshot.hasDraggableState
                ? this.draggableSnapshot.dragEvent.dragPosition.pageX - this.draggableSnapshot.clientRect.left
                : 0,
        };
        /** @type {?} */
        let isAnimationConfigured = false;
        this.subscriptions.push(this.dragEventListener.dragMoved.subscribe((event) => {
            // On the first drag move event, we configure the animation as it's dependent on the first drag event.
            if (!isAnimationConfigured) {
                if (this.draggableSnapshot.hasDraggableState) {
                    this.animateToOnLeave(`${this.draggableSnapshot.clientRect.top}px`, `${this.draggableSnapshot.clientRect.left}px`);
                }
                else {
                    this.animateToOnLeave(`${event.dragPosition.pageY}px`, `${event.dragPosition.pageX}px`);
                }
                isAnimationConfigured = true;
            }
            // Position the draggable ghost.
            /** @type {?} */
            const topLeftPosition = this.findTopLeftPosition(event.dragPosition, offset);
            this.setPositionStyle(this.draggableGhostEl, topLeftPosition.pageX, topLeftPosition.pageY);
            this.dragEventListener.dropPointPosition = this.findDropPointPosition(topLeftPosition);
        }));
    }
    /**
     * @param {?} el
     * @return {?}
     */
    setDefaultGhostSize(el) {
        if (this.draggableSnapshot.hasDraggableState) {
            this.setSizeStyle(el, this.draggableSnapshot.clientRect.width, this.draggableSnapshot.clientRect.height);
        }
    }
    /**
     * @param {?} top
     * @param {?} left
     * @return {?}
     */
    animateToOnLeave(top, left) {
        this.ngZone.run(() => {
            this.leaveAnimConfig = { value: 0, params: { top: top, left: left } };
        });
    }
    /**
     * @param {?} dragPosition
     * @param {?} offset
     * @return {?}
     */
    findTopLeftPosition(dragPosition, offset) {
        return { pageX: dragPosition.pageX - offset.left, pageY: dragPosition.pageY - offset.top };
    }
    /**
     * @param {?} topLeftPosition
     * @return {?}
     */
    findDropPointPosition(topLeftPosition) {
        if (this.draggableSnapshot.hasDraggableState) {
            return {
                pageX: topLeftPosition.pageX + this.draggableSnapshot.clientRect.width / 2,
                pageY: topLeftPosition.pageY + this.draggableSnapshot.clientRect.height / 2,
            };
        }
        else {
            return topLeftPosition;
        }
    }
    /**
     * @param {?} el
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    setSizeStyle(el, width, height) {
        this.renderer.setStyle(el, 'width', `${width}px`);
        this.renderer.setStyle(el, 'height', `${height}px`);
    }
    /**
     * @param {?} el
     * @param {?} left
     * @param {?} top
     * @return {?}
     */
    setPositionStyle(el, left, top) {
        this.renderer.setStyle(el, 'left', `${left}px`);
        this.renderer.setStyle(el, 'top', `${top}px`);
        this.renderer.setStyle(el, 'visibility', 'visible');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((sub) => sub.unsubscribe());
    }
}
ClrDraggableGhost.decorators = [
    { type: Component, args: [{
                selector: 'clr-draggable-ghost',
                template: `<ng-content></ng-content>`,
                animations: [
                    trigger('leaveAnimation', [
                        transition(':leave', [
                            style({ left: '*', top: '*' }),
                            animate('0.2s ease-in-out', style({ top: '{{top}}', left: '{{left}}' })),
                        ]),
                    ]),
                ]
            }] }
];
/** @nocollapse */
ClrDraggableGhost.ctorParameters = () => [
    { type: ElementRef },
    { type: DragEventListenerService, decorators: [{ type: Optional }] },
    { type: DraggableSnapshotService, decorators: [{ type: Optional }] },
    { type: Renderer2 },
    { type: NgZone }
];
ClrDraggableGhost.propDecorators = {
    leaveAnimConfig: [{ type: HostBinding, args: ['@leaveAnimation',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This structural directive will be used mainly together with `clr-draggable-ghost` directive inside of clrDraggable
// directive. The directive is responsible for instantiating `clr-draggable-ghost` directive only during dragging so
// that Angular Change Detection is prevented from running if a component or directive is placed inside of the
// `clr-draggable-ghost` directive.
/**
 * @template T
 */
class ClrIfDragged {
    /**
     * @param {?} template
     * @param {?} container
     * @param {?} dragEventListener
     */
    constructor(template, container, dragEventListener) {
        this.template = template;
        this.container = container;
        this.dragEventListener = dragEventListener;
        this.subscriptions = [];
        if (!this.dragEventListener || !this.container) {
            throw new Error('The *clrIfDragged directive can only be used inside of a clrDraggable directive.');
        }
        this.subscriptions.push(this.dragEventListener.dragStarted.subscribe((event) => {
            this.container.createEmbeddedView(this.template);
        }));
        this.subscriptions.push(this.dragEventListener.dragEnded.subscribe((event) => {
            this.container.clear();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((sub) => sub.unsubscribe());
    }
}
ClrIfDragged.decorators = [
    { type: Directive, args: [{ selector: '[clrIfDragged]' },] }
];
/** @nocollapse */
ClrIfDragged.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: DragEventListenerService, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This provider registers the drag handle element.
// When it registers a element as a drag handle, it attaches that element to the listeners from ClrDragEventListener.
// Also, it adds the "drag-handle" css class to the registered element through Renderer.
/**
 * @template T
 */
class DragHandleRegistrarService {
    /**
     * @param {?} dragEventListener
     * @param {?} renderer
     */
    constructor(dragEventListener, renderer) {
        this.dragEventListener = dragEventListener;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    get defaultHandleEl() {
        return this._defaultHandleEl;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    set defaultHandleEl(el) {
        this._defaultHandleEl = el; // defaultHandleEl will be usually the clrDraggable element.
        // If the customHandleEl has been registered,
        // don't make the defaultHandleEl the drag handle yet until the customHandleEl is unregistered.
        if (!this._customHandleEl) {
            this.makeElementHandle(this._defaultHandleEl);
        }
    }
    /**
     * @param {?} el
     * @return {?}
     */
    makeElementHandle(el) {
        if (this._defaultHandleEl && this._defaultHandleEl !== el) {
            // Before making an element the custom handle element,
            // we should remove the existing drag-handle class from the draggable element.
            this.renderer.removeClass(this._defaultHandleEl, 'drag-handle');
        }
        this.dragEventListener.attachDragListeners(el);
        this.renderer.addClass(el, 'drag-handle');
    }
    /**
     * @return {?}
     */
    get customHandleEl() {
        return this._customHandleEl;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    registerCustomHandle(el) {
        this.dragEventListener.detachDragListeners(); // removes the existing listeners
        this._customHandleEl = el;
        this.makeElementHandle(this._customHandleEl);
    }
    /**
     * @return {?}
     */
    unregisterCustomHandle() {
        this.dragEventListener.detachDragListeners(); // removes the existing listeners
        this.renderer.removeClass(this._customHandleEl, 'drag-handle');
        delete this._customHandleEl;
        // if default handle is set, make that handle
        if (this._defaultHandleEl) {
            this.makeElementHandle(this._defaultHandleEl);
        }
    }
}
DragHandleRegistrarService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DragHandleRegistrarService.ctorParameters = () => [
    { type: DragEventListenerService },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This service class adds and removes the "in-drag" class to the document body element
// through its public enter() and exit() methods.
class GlobalDragModeService {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    enter() {
        this.renderer.addClass(document.body, 'in-drag');
    }
    /**
     * @return {?}
     */
    exit() {
        this.renderer.removeClass(document.body, 'in-drag');
    }
}
GlobalDragModeService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
GlobalDragModeService.ctorParameters = () => [
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDraggable {
    /**
     * @param {?} el
     * @param {?} dragEventListener
     * @param {?} dragHandleRegistrar
     * @param {?} viewContainerRef
     * @param {?} cfr
     * @param {?} injector
     * @param {?} draggableSnapshot
     * @param {?} globalDragMode
     */
    constructor(el, dragEventListener, dragHandleRegistrar, viewContainerRef, cfr, injector, draggableSnapshot, globalDragMode) {
        this.el = el;
        this.dragEventListener = dragEventListener;
        this.dragHandleRegistrar = dragHandleRegistrar;
        this.viewContainerRef = viewContainerRef;
        this.cfr = cfr;
        this.injector = injector;
        this.draggableSnapshot = draggableSnapshot;
        this.globalDragMode = globalDragMode;
        this.subscriptions = [];
        this.dragOn = false;
        this.dragStartEmitter = new EventEmitter();
        this.dragMoveEmitter = new EventEmitter();
        this.dragEndEmitter = new EventEmitter();
        this.draggableEl = this.el.nativeElement;
        this.componentFactory = this.cfr.resolveComponentFactory(ClrDraggableGhost);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataTransfer(value) {
        this.dragEventListener.dragDataTransfer = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set group(value) {
        this.dragEventListener.group = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    createDefaultGhost(event) {
        this.draggableSnapshot.capture(this.draggableEl, event);
        // NOTE: The default ghost element will appear
        // next to the clrDraggable in the DOM as a sibling element.
        this.viewContainerRef.createComponent(this.componentFactory, 0, this.injector, [
            [this.draggableEl.cloneNode(true)],
        ]);
    }
    /**
     * @return {?}
     */
    destroyDefaultGhost() {
        this.viewContainerRef.clear();
        this.draggableSnapshot.discard();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.dragHandleRegistrar.defaultHandleEl = this.draggableEl;
        this.subscriptions.push(this.dragEventListener.dragStarted.subscribe((event) => {
            this.globalDragMode.enter();
            this.dragOn = true;
            if (!this.customGhost) {
                this.createDefaultGhost(event);
            }
            this.dragStartEmitter.emit(new ClrDragEvent(event));
        }));
        this.subscriptions.push(this.dragEventListener.dragMoved.subscribe((event) => {
            this.dragMoveEmitter.emit(new ClrDragEvent(event));
        }));
        this.subscriptions.push(this.dragEventListener.dragEnded.subscribe((event) => {
            this.globalDragMode.exit();
            this.dragOn = false;
            if (!this.customGhost) {
                this.destroyDefaultGhost();
            }
            this.dragEndEmitter.emit(new ClrDragEvent(event));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach((sub) => sub.unsubscribe());
        this.dragEventListener.detachDragListeners();
    }
}
ClrDraggable.decorators = [
    { type: Directive, args: [{
                selector: '[clrDraggable]',
                providers: [
                    DragEventListenerService,
                    DragHandleRegistrarService,
                    DraggableSnapshotService,
                    GlobalDragModeService,
                    DomAdapter,
                ],
                host: { '[class.draggable]': 'true', '[class.being-dragged]': 'dragOn' },
            },] }
];
/** @nocollapse */
ClrDraggable.ctorParameters = () => [
    { type: ElementRef },
    { type: DragEventListenerService },
    { type: DragHandleRegistrarService },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: DraggableSnapshotService },
    { type: GlobalDragModeService }
];
ClrDraggable.propDecorators = {
    customGhost: [{ type: ContentChild, args: [ClrIfDragged,] }],
    dataTransfer: [{ type: Input, args: ['clrDraggable',] }],
    group: [{ type: Input, args: ['clrGroup',] }],
    dragStartEmitter: [{ type: Output, args: ['clrDragStart',] }],
    dragMoveEmitter: [{ type: Output, args: ['clrDragMove',] }],
    dragEndEmitter: [{ type: Output, args: ['clrDragEnd',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDroppable {
    /**
     * @param {?} el
     * @param {?} eventBus
     * @param {?} domAdapter
     * @param {?} renderer
     */
    constructor(el, eventBus, domAdapter, renderer) {
        this.el = el;
        this.eventBus = eventBus;
        this.domAdapter = domAdapter;
        this.renderer = renderer;
        this.isDraggableMatch = false;
        this._isDraggableOver = false;
        this._dropTolerance = { top: 0, right: 0, bottom: 0, left: 0 };
        this.dragStartEmitter = new EventEmitter();
        this.dragMoveEmitter = new EventEmitter();
        this.dragEndEmitter = new EventEmitter();
        this.dragLeaveEmitter = new EventEmitter();
        this.dragEnterEmitter = new EventEmitter();
        this.dropEmitter = new EventEmitter();
        this.droppableEl = this.el.nativeElement;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isDraggableOver(value) {
        // We need to add/remove this draggable-over class via Renderer2
        // because isDraggableOver is set outside of NgZone.
        if (value) {
            this.renderer.addClass(this.droppableEl, 'draggable-over');
        }
        else {
            this.renderer.removeClass(this.droppableEl, 'draggable-over');
        }
        this._isDraggableOver = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set group(value) {
        this._group = value;
    }
    /**
     * @param {?=} top
     * @param {?=} right
     * @param {?=} bottom
     * @param {?=} left
     * @return {?}
     */
    dropToleranceGenerator(top = 0, right = top, bottom = top, left = right) {
        return { top, right, bottom, left };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dropTolerance(value) {
        // If user provides an object here and wants to manipulate/update properties individually,
        // the object must be immutable as we generate new object based user's given object.
        if (typeof value === 'number') {
            this._dropTolerance = this.dropToleranceGenerator(value);
        }
        else if (typeof value === 'string') {
            /** @type {?} */
            const toleranceValues = value
                .trim()
                .split(/\s+/)
                .map(tolerance => parseInt(tolerance, 10));
            this._dropTolerance = this.dropToleranceGenerator(...toleranceValues);
        }
        else if (value) {
            // The value could be passed in as {left: 20, top: 30 }
            // In this case, the rest of the direction properties should be 0.
            // That's why we initialize properties with 0 first, then override with user's given value.
            this._dropTolerance = Object.assign({}, this.dropToleranceGenerator(0), value);
        }
    }
    /**
     * @param {?} subscription
     * @return {?}
     */
    unsubscribeFrom(subscription) {
        if (subscription) {
            subscription.unsubscribe();
        }
    }
    /**
     * @param {?} draggableGroup
     * @return {?}
     */
    checkGroupMatch(draggableGroup) {
        // Both Draggable and Droppable have clrGroup input.
        // The clrGroup input can be both a string key or array of string keys in Draggable and Droppable.
        // It's not match if Draggable has no defined value assigned to clrGroup, but Droppable has a defined clrGroup.
        if (!draggableGroup && this._group) {
            return false;
        }
        // The same is true the other way round.
        if (!this._group && draggableGroup) {
            return false;
        }
        // It's match if both Draggable and Droppable have no assigned value for clrGroup.
        if (!this._group && !draggableGroup) {
            return true;
        }
        // It's match if both Draggable and Droppable have simple string keys that are matching.
        // It's match if Draggable's simple clrGroup key is matching with one of the clrGroup keys of Droppable. The
        // same is true the other way round.
        // it's match if one of the clrGroup keys of Droppable is matching with one of the clrGroup keys of Draggable.
        if (typeof draggableGroup === 'string') {
            if (typeof this._group === 'string') {
                return this._group === draggableGroup;
            }
            else {
                return this._group.indexOf(draggableGroup) > -1;
            }
        }
        else {
            if (typeof this._group === 'string') {
                return draggableGroup.indexOf(this._group) > -1;
            }
            else {
                return ((/** @type {?} */ (this._group))).some(groupKey => draggableGroup.indexOf(groupKey) > -1);
            }
        }
    }
    /**
     * @param {?} point
     * @return {?}
     */
    isInDropArea(point) {
        if (!point) {
            return false;
        }
        if (!this.clientRect) {
            this.clientRect = this.domAdapter.clientRect(this.droppableEl);
        }
        if (point.pageX >= this.clientRect.left - this._dropTolerance.left &&
            point.pageX <= this.clientRect.right + this._dropTolerance.right &&
            point.pageY >= this.clientRect.top - this._dropTolerance.top &&
            point.pageY <= this.clientRect.bottom + this._dropTolerance.bottom) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} dragStartEvent
     * @return {?}
     */
    onDragStart(dragStartEvent) {
        // Check draggable and droppable have a matching group key.
        this.isDraggableMatch = this.checkGroupMatch(dragStartEvent.group);
        // Subscribe to dragMoved and dragEnded only if draggable and droppable have a matching group key.
        if (this.isDraggableMatch) {
            this.dragStartEmitter.emit(new ClrDragEvent(dragStartEvent));
            this.dragMoveSubscription = this.eventBus.dragMoved.subscribe((dragMoveEvent) => {
                this.onDragMove(dragMoveEvent);
            });
            this.dragEndSubscription = this.eventBus.dragEnded.subscribe((dragEndEvent) => {
                this.onDragEnd(dragEndEvent);
            });
        }
    }
    /**
     * @param {?} dragMoveEvent
     * @return {?}
     */
    onDragMove(dragMoveEvent) {
        /** @type {?} */
        const isInDropArea = this.isInDropArea(dragMoveEvent.dropPointPosition);
        if (!this._isDraggableOver && isInDropArea) {
            this.isDraggableOver = true;
            /** @type {?} */
            const dragEnterEvent = Object.assign({}, dragMoveEvent, { type: DragEventType.DRAG_ENTER });
            this.eventBus.broadcast(dragEnterEvent);
            this.dragEnterEmitter.emit(new ClrDragEvent(dragEnterEvent));
        }
        else if (this._isDraggableOver && !isInDropArea) {
            this.isDraggableOver = false;
            /** @type {?} */
            const dragLeaveEvent = Object.assign({}, dragMoveEvent, { type: DragEventType.DRAG_LEAVE });
            this.eventBus.broadcast(dragLeaveEvent);
            this.dragLeaveEmitter.emit(new ClrDragEvent(dragLeaveEvent));
        }
        this.dragMoveEmitter.emit(new ClrDragEvent(dragMoveEvent));
    }
    /**
     * @param {?} dragEndEvent
     * @return {?}
     */
    onDragEnd(dragEndEvent) {
        if (this._isDraggableOver) {
            if (dragEndEvent.ghostElement) {
                // By this point, the draggable ghost component is destroyed,
                // but the element would be active until its animation completes.
                // As such, once the ghost is dropped over, we will give it "dropped" class.
                // This process cannot be done in the ghost component
                // because any subscription to the drop event is ineffective or invalid
                // as the component had been already destroyed.
                this.renderer.addClass(dragEndEvent.ghostElement, 'dropped');
            }
            /** @type {?} */
            const dropEvent = Object.assign({}, dragEndEvent, { type: DragEventType.DROP });
            this.eventBus.broadcast(dropEvent);
            this.dropEmitter.emit(new ClrDragEvent(dropEvent));
            this.isDraggableOver = false;
        }
        this.dragEndEmitter.emit(new ClrDragEvent(dragEndEvent));
        this.unsubscribeFrom(this.dragMoveSubscription);
        this.unsubscribeFrom(this.dragEndSubscription);
        this.isDraggableMatch = false;
        delete this.clientRect;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dragStartSubscription = this.eventBus.dragStarted.subscribe((dragStartEvent) => {
            this.onDragStart(dragStartEvent);
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribeFrom(this.dragStartSubscription);
        this.unsubscribeFrom(this.dragMoveSubscription);
        this.unsubscribeFrom(this.dragEndSubscription);
    }
}
ClrDroppable.decorators = [
    { type: Directive, args: [{
                selector: '[clrDroppable]',
                providers: [DomAdapter],
                host: { '[class.droppable]': 'true', '[class.draggable-match]': 'isDraggableMatch' },
            },] }
];
/** @nocollapse */
ClrDroppable.ctorParameters = () => [
    { type: ElementRef },
    { type: DragAndDropEventBusService },
    { type: DomAdapter },
    { type: Renderer2 }
];
ClrDroppable.propDecorators = {
    group: [{ type: Input, args: ['clrGroup',] }],
    dropTolerance: [{ type: Input, args: ['clrDropTolerance',] }],
    dragStartEmitter: [{ type: Output, args: ['clrDragStart',] }],
    dragMoveEmitter: [{ type: Output, args: ['clrDragMove',] }],
    dragEndEmitter: [{ type: Output, args: ['clrDragEnd',] }],
    dragLeaveEmitter: [{ type: Output, args: ['clrDragLeave',] }],
    dragEnterEmitter: [{ type: Output, args: ['clrDragEnter',] }],
    dropEmitter: [{ type: Output, args: ['clrDrop',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class ClrDragHandle {
    /**
     * @param {?} el
     * @param {?} dragHandleRegistrar
     */
    constructor(el, dragHandleRegistrar) {
        this.el = el;
        this.dragHandleRegistrar = dragHandleRegistrar;
        if (!this.dragHandleRegistrar) {
            // ClrDragHandleRegistrar is provided in ClrDraggable so we expect it to be present here
            // as clrDragHandle is required to be used only inside of a clrDraggable directive.
            throw new Error('The clrDragHandle directive can only be used inside of a clrDraggable directive.');
        }
        this.dragHandleRegistrar.registerCustomHandle(this.el.nativeElement);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.dragHandleRegistrar.unregisterCustomHandle();
    }
}
ClrDragHandle.decorators = [
    { type: Directive, args: [{ selector: '[clrDragHandle]', host: { '[class.drag-handle]': 'true' } },] }
];
/** @nocollapse */
ClrDragHandle.ctorParameters = () => [
    { type: ElementRef },
    { type: DragHandleRegistrarService, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_DRAG_AND_DROP_DIRECTIVES = [
    ClrDraggable,
    ClrDroppable,
    ClrIfDragged,
    ClrDragHandle,
    ClrDraggableGhost,
];
class ClrDragAndDropModule {
}
ClrDragAndDropModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [CLR_DRAG_AND_DROP_DIRECTIVES],
                entryComponents: [ClrDraggableGhost],
                exports: [CLR_DRAG_AND_DROP_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class RootDropdownService {
    constructor() {
        this._changes = new Subject();
    }
    /**
     * @return {?}
     */
    get changes() {
        return this._changes.asObservable();
    }
    /**
     * @return {?}
     */
    closeMenus() {
        this._changes.next(false);
    }
}
RootDropdownService.decorators = [
    { type: Injectable }
];
/**
 * @param {?} existing
 * @return {?}
 */
function clrRootDropdownFactory(existing) {
    return existing || new RootDropdownService();
}
/** @type {?} */
const ROOT_DROPDOWN_PROVIDER = {
    provide: RootDropdownService,
    useFactory: clrRootDropdownFactory,
    deps: [[new Optional(), new SkipSelf(), RootDropdownService]],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDropdown {
    /**
     * @param {?} parent
     * @param {?} ifOpenService
     * @param {?} cdr
     * @param {?} dropdownService
     */
    constructor(parent, ifOpenService, cdr, dropdownService) {
        this.parent = parent;
        this.ifOpenService = ifOpenService;
        this.cdr = cdr;
        this.subscriptions = [];
        this.isMenuClosable = true;
        this.subscriptions.push(dropdownService.changes.subscribe(value => (this.ifOpenService.open = value)));
        this.subscriptions.push(ifOpenService.openChange.subscribe(value => this.cdr.markForCheck()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.forEach(sub => sub.unsubscribe());
    }
}
ClrDropdown.decorators = [
    { type: Component, args: [{
                selector: 'clr-dropdown',
                template: '<ng-content></ng-content>',
                host: {
                    '[class.dropdown]': 'true',
                    // FIXME: remove this as soon as we stop supporting this old <div class="dropdown-menu"> syntax
                    '[class.open]': 'ifOpenService.open',
                },
                providers: [IfOpenService, ROOT_DROPDOWN_PROVIDER, { provide: POPOVER_HOST_ANCHOR, useExisting: ElementRef }]
            }] }
];
/** @nocollapse */
ClrDropdown.ctorParameters = () => [
    { type: ClrDropdown, decorators: [{ type: SkipSelf }, { type: Optional }] },
    { type: IfOpenService },
    { type: ChangeDetectorRef },
    { type: RootDropdownService }
];
ClrDropdown.propDecorators = {
    isMenuClosable: [{ type: Input, args: ['clrCloseMenuOnItemClick',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDropdownItem {
    /**
     * @param {?} dropdown
     * @param {?} el
     * @param {?} _dropdownService
     * @param {?} renderer
     */
    constructor(dropdown, el, _dropdownService, renderer) {
        this.dropdown = dropdown;
        this.el = el;
        this._dropdownService = _dropdownService;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.renderer.listen(this.el.nativeElement, 'click', () => this.onDropdownItemClick());
    }
    /**
     * @return {?}
     */
    onDropdownItemClick() {
        if (this.dropdown.isMenuClosable && !this.el.nativeElement.classList.contains('disabled')) {
            this._dropdownService.closeMenus();
        }
    }
}
ClrDropdownItem.decorators = [
    { type: Directive, args: [{ selector: '[clrDropdownItem]', host: { '[class.dropdown-item]': 'true' } },] }
];
/** @nocollapse */
ClrDropdownItem.ctorParameters = () => [
    { type: ClrDropdown },
    { type: ElementRef },
    { type: RootDropdownService },
    { type: Renderer2 }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDropdownMenu extends AbstractPopover {
    /**
     * @param {?} injector
     * @param {?} parentHost
     * @param {?} nested
     */
    constructor(injector, parentHost, nested) {
        if (!parentHost) {
            throw new Error('clr-dropdown-menu should only be used inside of a clr-dropdown');
        }
        super(injector, parentHost);
        if (!nested) {
            // Default positioning for normal dropdown is bottom-left
            this.anchorPoint = Point.BOTTOM_LEFT;
            this.popoverPoint = Point.LEFT_TOP;
        }
        else {
            // Default positioning for nested dropdown is right-top
            this.anchorPoint = Point.RIGHT_TOP;
            this.popoverPoint = Point.LEFT_TOP;
        }
        this.popoverOptions.allowMultipleOpen = true;
        this.closeOnOutsideClick = true;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    set position(position) {
        // set the popover values based on menu position
        switch (position) {
            case 'top-right':
                this.anchorPoint = Point.TOP_RIGHT;
                this.popoverPoint = Point.RIGHT_BOTTOM;
                break;
            case 'top-left':
                this.anchorPoint = Point.TOP_LEFT;
                this.popoverPoint = Point.LEFT_BOTTOM;
                break;
            case 'bottom-right':
                this.anchorPoint = Point.BOTTOM_RIGHT;
                this.popoverPoint = Point.RIGHT_TOP;
                break;
            case 'bottom-left':
                this.anchorPoint = Point.BOTTOM_LEFT;
                this.popoverPoint = Point.LEFT_TOP;
                break;
            case 'right-top':
                this.anchorPoint = Point.RIGHT_TOP;
                this.popoverPoint = Point.LEFT_TOP;
                break;
            case 'right-bottom':
                this.anchorPoint = Point.RIGHT_BOTTOM;
                this.popoverPoint = Point.LEFT_BOTTOM;
                break;
            case 'left-top':
                this.anchorPoint = Point.LEFT_TOP;
                this.popoverPoint = Point.RIGHT_TOP;
                break;
            case 'left-bottom':
                this.anchorPoint = Point.LEFT_BOTTOM;
                this.popoverPoint = Point.RIGHT_BOTTOM;
                break;
            default:
                this.anchorPoint = Point.BOTTOM_LEFT;
                this.popoverPoint = Point.LEFT_TOP;
                break;
        }
    }
}
ClrDropdownMenu.decorators = [
    { type: Component, args: [{
                selector: 'clr-dropdown-menu',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    '[class.dropdown-menu]': 'true',
                }
            }] }
];
/** @nocollapse */
ClrDropdownMenu.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [POPOVER_HOST_ANCHOR,] }] },
    { type: ClrDropdownMenu, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
ClrDropdownMenu.propDecorators = {
    position: [{ type: Input, args: ['clrPosition',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrDropdownTrigger {
    /**
     * @param {?} dropdown
     * @param {?} ifOpenService
     */
    constructor(dropdown, ifOpenService) {
        this.ifOpenService = ifOpenService;
        this.isRootLevelToggle = true;
        // if the containing dropdown has a parent, then this is not the root level one
        if (dropdown.parent) {
            this.isRootLevelToggle = false;
        }
    }
    /**
     * @return {?}
     */
    get active() {
        return this.ifOpenService.open;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropdownTriggerClick(event) {
        this.ifOpenService.toggleWithEvent(event);
    }
}
ClrDropdownTrigger.decorators = [
    { type: Directive, args: [{
                // We support both selectors for legacy reasons
                selector: '[clrDropdownTrigger],[clrDropdownToggle]',
                host: {
                    '[class.dropdown-toggle]': 'isRootLevelToggle',
                    '[class.dropdown-item]': '!isRootLevelToggle',
                    '[class.expandable]': '!isRootLevelToggle',
                    '[class.active]': 'active',
                },
            },] }
];
/** @nocollapse */
ClrDropdownTrigger.ctorParameters = () => [
    { type: ClrDropdown },
    { type: IfOpenService }
];
ClrDropdownTrigger.propDecorators = {
    onDropdownTriggerClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_DROPDOWN_DIRECTIVES = [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem];
class ClrDropdownModule {
}
ClrDropdownModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrCommonPopoverModule],
                declarations: [CLR_DROPDOWN_DIRECTIVES],
                exports: [CLR_DROPDOWN_DIRECTIVES, ClrConditionalModule, ClrIconModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
// @TODO Make this an enum
/** @type {?} */
const ALERT_TYPES = ['info', 'warning', 'danger', 'success'];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AlertIconAndTypesService {
    /**
     * @param {?} commonStrings
     */
    constructor(commonStrings) {
        this.commonStrings = commonStrings;
        this.defaultIconShape = 'info-circle';
        this._alertIconShape = '';
        this._alertType = 'info';
    }
    /**
     * @return {?}
     */
    get alertType() {
        return this._alertType;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set alertType(val) {
        if (ALERT_TYPES.indexOf(val) > -1) {
            this._alertType = val;
        }
    }
    /**
     * @return {?}
     */
    get alertIconShape() {
        if ('' === this._alertIconShape) {
            return this.iconInfoFromType(this._alertType).shape;
        }
        return this._alertIconShape;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set alertIconShape(val) {
        if (!val) {
            this._alertIconShape = '';
        }
        else if (val !== this._alertIconShape) {
            this._alertIconShape = val;
        }
    }
    /**
     * @return {?}
     */
    get alertIconTitle() {
        return this.iconInfoFromType(this._alertType).title;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    iconInfoFromType(type) {
        /** @type {?} */
        const returnObj = { shape: '', cssClass: '', title: '' };
        switch (type) {
            case 'warning':
                returnObj.shape = 'exclamation-triangle';
                returnObj.cssClass = 'alert-warning';
                returnObj.title = this.commonStrings.warning;
                break;
            case 'danger':
                returnObj.shape = 'exclamation-circle';
                returnObj.cssClass = 'alert-danger';
                returnObj.title = this.commonStrings.danger;
                break;
            case 'success':
                returnObj.shape = 'check-circle';
                returnObj.cssClass = 'alert-success';
                returnObj.title = this.commonStrings.success;
                break;
            default:
                returnObj.shape = this.defaultIconShape;
                returnObj.cssClass = 'alert-info';
                returnObj.title = this.commonStrings.info;
                break;
        }
        return returnObj;
    }
}
AlertIconAndTypesService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AlertIconAndTypesService.ctorParameters = () => [
    { type: ClrCommonStrings }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class MultiAlertService {
    constructor() {
        this.allAlerts = new QueryList();
        this._current = 0;
        /**
         * The Observable that lets other classes subscribe to changes
         */
        this._change = new Subject();
    }
    /**
     * @return {?}
     */
    get changes() {
        return this._change.asObservable();
    }
    /**
     * @return {?}
     */
    get current() {
        return this._current;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set current(index) {
        if (index !== this._current) {
            this._current = index;
            this._change.next(index);
        }
    }
    /**
     * @return {?}
     */
    get activeAlerts() {
        return this.allAlerts.filter(alert => !alert._closed);
    }
    /**
     * @return {?}
     */
    get currentAlert() {
        return this.activeAlerts[this.current];
    }
    /**
     * @param {?} alert
     * @return {?}
     */
    set currentAlert(alert) {
        this.current = this.activeAlerts.indexOf(alert);
    }
    /**
     * @return {?}
     */
    get count() {
        return this.activeAlerts.length;
    }
    /**
     * @param {?} alerts
     * @return {?}
     */
    manage(alerts) {
        this.allAlerts = alerts;
    }
    /**
     * @return {?}
     */
    next() {
        this.current = this.current === this.activeAlerts.length - 1 ? 0 : this.current + 1;
    }
    /**
     * @return {?}
     */
    previous() {
        if (this.activeAlerts.length === 0) {
            return;
        }
        this.current = this.current === 0 ? this.activeAlerts.length - 1 : this.current - 1;
    }
    /**
     * @return {?}
     */
    close() {
        this.previous();
    }
}
MultiAlertService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrAlert {
    /**
     * @param {?} iconService
     * @param {?} cdr
     * @param {?} multiAlertService
     * @param {?} commonStrings
     */
    constructor(iconService, cdr, multiAlertService, commonStrings) {
        this.iconService = iconService;
        this.cdr = cdr;
        this.multiAlertService = multiAlertService;
        this.commonStrings = commonStrings;
        this.isSmall = false;
        this.closable = true;
        this.isAppLevel = false;
        this._closed = false;
        this._closedChanged = new EventEmitter(false);
        this.previouslyHidden = false;
        this.hidden = false;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set alertType(val) {
        this.iconService.alertType = val;
    }
    /**
     * @return {?}
     */
    get alertType() {
        return this.iconService.alertType;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set alertIconShape(value) {
        this.iconService.alertIconShape = value;
    }
    /**
     * @return {?}
     */
    get alertClass() {
        return this.iconService.iconInfoFromType(this.iconService.alertType).cssClass;
    }
    /**
     * @return {?}
     */
    detectChangesIfNeeded() {
        if (this.previouslyHidden !== this.hidden) {
            this.previouslyHidden = this.hidden;
            this.cdr.detectChanges();
        }
    }
    /**
     * @return {?}
     */
    get isHidden() {
        if (this.multiAlertService) {
            if (this.multiAlertService.currentAlert === this) {
                if (this.hidden === true) {
                    this.previouslyHidden = true;
                    this.hidden = false;
                }
            }
            else if (this.hidden === false) {
                this.previouslyHidden = false;
                this.hidden = true;
            }
            this.detectChangesIfNeeded();
        }
        return this.hidden;
    }
    /**
     * @return {?}
     */
    close() {
        if (!this.closable) {
            return;
        }
        this._closed = true;
        if (this.multiAlertService) {
            this.multiAlertService.close();
        }
        this._closedChanged.emit(true);
    }
    /**
     * @return {?}
     */
    open() {
        this._closed = false;
        this._closedChanged.emit(false);
    }
}
ClrAlert.decorators = [
    { type: Component, args: [{
                selector: 'clr-alert',
                providers: [AlertIconAndTypesService],
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n    *ngIf=\"!_closed\"\n    class=\"alert\"\n    [ngClass]=\"alertClass\"\n    [class.alert-hidden]=\"isHidden\"\n    [class.alert-sm]=\"isSmall\"\n    [class.alert-app-level]=\"isAppLevel\"\n    role=\"alert\"\n    aria-live=\"assertive\">\n    <div class=\"alert-items\">\n        <ng-content></ng-content>\n    </div>\n    <button type=\"button\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n        <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n    </button>\n</div>\n",
                styles: [':host { display: block; }']
            }] }
];
/** @nocollapse */
ClrAlert.ctorParameters = () => [
    { type: AlertIconAndTypesService },
    { type: ChangeDetectorRef },
    { type: MultiAlertService, decorators: [{ type: Optional }] },
    { type: ClrCommonStrings }
];
ClrAlert.propDecorators = {
    isSmall: [{ type: Input, args: ['clrAlertSizeSmall',] }],
    closable: [{ type: Input, args: ['clrAlertClosable',] }],
    isAppLevel: [{ type: Input, args: ['clrAlertAppLevel',] }],
    _closed: [{ type: Input, args: ['clrAlertClosed',] }],
    _closedChanged: [{ type: Output, args: ['clrAlertClosedChange',] }],
    alertType: [{ type: Input, args: ['clrAlertType',] }],
    alertIconShape: [{ type: Input, args: ['clrAlertIcon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrAlertItem {
    /**
     * @param {?} iconService
     */
    constructor(iconService) {
        this.iconService = iconService;
    }
}
ClrAlertItem.decorators = [
    { type: Component, args: [{
                selector: 'clr-alert-item',
                template: `
        <div class="alert-icon-wrapper">
            <clr-icon class="alert-icon" 
              [attr.shape]="iconService.alertIconShape" 
              [attr.title]="iconService.alertIconTitle"></clr-icon>
        </div>
        <ng-content></ng-content>
    `,
                host: { class: 'alert-item' }
            }] }
];
/** @nocollapse */
ClrAlertItem.ctorParameters = () => [
    { type: AlertIconAndTypesService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrAlerts {
    /**
     * @param {?} multiAlertService
     */
    constructor(multiAlertService) {
        this.multiAlertService = multiAlertService;
        this.currentAlertIndexChange = new EventEmitter(false);
        this.currentAlertChange = new EventEmitter(false);
    }
    /**
     * Input/Output to support two way binding on current alert index
     * @param {?} index
     * @return {?}
     */
    set _inputCurrentIndex(index) {
        if (Number.isInteger(index) && index >= 0) {
            this.multiAlertService.current = index;
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set currentAlertIndex(index) {
        this.multiAlertService.current = index;
    }
    /**
     * @return {?}
     */
    get currentAlertIndex() {
        return this.multiAlertService.current;
    }
    /**
     * Input/Output to support two way binding on current alert instance
     * @param {?} alert
     * @return {?}
     */
    set currentAlert(alert) {
        if (alert) {
            this.multiAlertService.currentAlert = alert;
        }
    }
    /**
     * @return {?}
     */
    get currentAlert() {
        return this.multiAlertService.currentAlert;
    }
    /**
     * Ensure we are only dealing with alerts that have not been closed yet
     * @return {?}
     */
    get alerts() {
        return this.allAlerts.filter(alert => {
            return alert.isHidden === false;
        });
    }
    /**
     * @return {?}
     */
    get currentAlertType() {
        if (this.multiAlertService.currentAlert) {
            return this.multiAlertService.currentAlert.alertType;
        }
        return '';
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.multiAlertService.manage(this.allAlerts);
        this.multiAlertService.changes.subscribe(index => {
            this.currentAlertIndexChange.next(index);
            this.currentAlertChange.next(this.multiAlertService.currentAlert);
        });
    }
}
ClrAlerts.decorators = [
    { type: Component, args: [{
                selector: 'clr-alerts',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-alerts-pager\n        *ngIf=\"multiAlertService.count > 1\"\n        [clrCurrentAlertIndex]=\"currentAlertIndex\">\n</clr-alerts-pager>\n<ng-content select=\"clr-alert\"></ng-content>\n",
                providers: [MultiAlertService],
                host: {
                    '[class.alerts]': 'true',
                    '[class.alert-danger]': "this.currentAlertType == 'danger'",
                    '[class.alert-info]': "this.currentAlertType == 'info'",
                    '[class.alert-success]': "this.currentAlertType == 'success'",
                    '[class.alert-warning]': "this.currentAlertType == 'warning'",
                },
                styles: [':host { display: block }']
            }] }
];
/** @nocollapse */
ClrAlerts.ctorParameters = () => [
    { type: MultiAlertService }
];
ClrAlerts.propDecorators = {
    allAlerts: [{ type: ContentChildren, args: [ClrAlert,] }],
    _inputCurrentIndex: [{ type: Input, args: ['clrCurrentAlertIndex',] }],
    currentAlertIndexChange: [{ type: Output, args: ['clrCurrentAlertIndexChange',] }],
    currentAlert: [{ type: Input, args: ['clrCurrentAlert',] }],
    currentAlertChange: [{ type: Output, args: ['clrCurrentAlertChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrAlertsPager {
    /**
     * @param {?} multiAlertService
     * @param {?} commonStrings
     */
    constructor(multiAlertService, commonStrings) {
        this.multiAlertService = multiAlertService;
        this.commonStrings = commonStrings;
        this.currentAlertChange = new EventEmitter(false);
        this.currentAlertIndexChange = new EventEmitter();
    }
    /**
     * Input/Output to support two way binding on current alert instance
     * @param {?} alert
     * @return {?}
     */
    set currentAlert(alert) {
        if (alert) {
            this.multiAlertService.currentAlert = alert;
        }
    }
    /**
     * @return {?}
     */
    get currentAlert() {
        return this.multiAlertService.currentAlert;
    }
    /**
     * Input/Output to support two way binding on current alert index
     * @param {?} index
     * @return {?}
     */
    set currentAlertIndex(index) {
        this.multiAlertService.current = index;
    }
    /**
     * @return {?}
     */
    get currentAlertIndex() {
        return this.multiAlertService.current;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.multiAlertServiceChanges = this.multiAlertService.changes.subscribe(index => {
            this.currentAlertIndexChange.emit(index);
            this.currentAlertChange.emit(this.multiAlertService.activeAlerts[index]);
        });
    }
    /**
     * @return {?}
     */
    pageUp() {
        this.multiAlertService.next();
    }
    /**
     * @return {?}
     */
    pageDown() {
        this.multiAlertService.previous();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.multiAlertServiceChanges.unsubscribe();
    }
}
ClrAlertsPager.decorators = [
    { type: Component, args: [{
                selector: 'clr-alerts-pager',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"alerts-pager-control\">\n    <div class=\"alerts-page-down\">\n        <button class=\"alerts-pager-button\" (click)=\"pageDown()\">\n            <clr-icon shape=\"caret left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n        </button>\n    </div>\n    <div class=\"alerts-pager-text\">\n        {{this.multiAlertService.current+1}} / {{this.multiAlertService.count}}\n    </div>\n    <div class=\"alerts-page-up\">\n        <button class=\"alerts-pager-button\" (click)=\"pageUp()\">\n            <clr-icon shape=\"caret right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n",
                host: { '[class.alerts-pager]': 'true' }
            }] }
];
/** @nocollapse */
ClrAlertsPager.ctorParameters = () => [
    { type: MultiAlertService },
    { type: ClrCommonStrings }
];
ClrAlertsPager.propDecorators = {
    currentAlert: [{ type: Input, args: ['clrCurrentAlert',] }],
    currentAlertChange: [{ type: Output, args: ['clrCurrentAlertChange',] }],
    currentAlertIndex: [{ type: Input, args: ['clrCurrentAlertIndex',] }],
    currentAlertIndexChange: [{ type: Output, args: ['clrCurrentAlertIndexChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_ALERT_DIRECTIVES = [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager];
class ClrAlertModule {
}
ClrAlertModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule, ClrDropdownModule],
                declarations: [CLR_ALERT_DIRECTIVES],
                exports: [CLR_ALERT_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrEmphasisModule {
}
ClrEmphasisModule.decorators = [
    { type: NgModule, args: [{ exports: [ClrAlertModule] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
class ResponsiveNavCodes {
}
ResponsiveNavCodes.NAV_LEVEL_1 = 1;
ResponsiveNavCodes.NAV_LEVEL_2 = 2;
ResponsiveNavCodes.NAV_CLOSE_ALL = 'NAV_CLOSE_ALL';
ResponsiveNavCodes.NAV_OPEN = 'NAV_OPEN';
ResponsiveNavCodes.NAV_CLOSE = 'NAV_CLOSE';
ResponsiveNavCodes.NAV_TOGGLE = 'NAV_TOGGLE';
ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU = 'open-hamburger-menu';
ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU = 'open-overflow-menu';
ResponsiveNavCodes.NAV_CLASS_TRIGGER_1 = 'header-hamburger-trigger';
ResponsiveNavCodes.NAV_CLASS_TRIGGER_2 = 'header-overflow-trigger';
ResponsiveNavCodes.NAV_CLASS_LEVEL_1 = 'clr-nav-level-1';
ResponsiveNavCodes.NAV_CLASS_LEVEL_2 = 'clr-nav-level-2';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
class ResponsiveNavControlMessage {
    /**
     * @param {?} _controlCode
     * @param {?} _navLevel
     */
    constructor(_controlCode, _navLevel) {
        this._controlCode = _controlCode;
        this._navLevel = _navLevel;
    }
    /**
     * @return {?}
     */
    get controlCode() {
        return this._controlCode;
    }
    /**
     * @return {?}
     */
    get navLevel() {
        return this._navLevel;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ResponsiveNavigationService {
    constructor() {
        this.responsiveNavList = [];
        this.registerNavSubject = new Subject();
        this.controlNavSubject = new Subject();
        this.closeAllNavs(); // We start with all navs closed
    }
    /**
     * @return {?}
     */
    get registeredNavs() {
        return this.registerNavSubject.asObservable();
    }
    /**
     * @return {?}
     */
    get navControl() {
        return this.controlNavSubject.asObservable();
    }
    /**
     * @param {?} navLevel
     * @return {?}
     */
    registerNav(navLevel) {
        if (!navLevel || this.isNavRegistered(navLevel)) {
            return;
        }
        this.responsiveNavList.push(navLevel);
        this.registerNavSubject.next(this.responsiveNavList);
    }
    /**
     * @param {?} navLevel
     * @return {?}
     */
    isNavRegistered(navLevel) {
        if (this.responsiveNavList.indexOf(navLevel) > -1) {
            console.error('Multiple clr-nav-level ' + navLevel + ' attributes found. Please make sure that only one exists');
            return true;
        }
        return false;
    }
    /**
     * @param {?} navLevel
     * @return {?}
     */
    unregisterNav(navLevel) {
        /** @type {?} */
        const index = this.responsiveNavList.indexOf(navLevel);
        if (index > -1) {
            this.responsiveNavList.splice(index, 1);
            this.registerNavSubject.next(this.responsiveNavList);
        }
    }
    /**
     * @param {?} controlCode
     * @param {?} navLevel
     * @return {?}
     */
    sendControlMessage(controlCode, navLevel) {
        /** @type {?} */
        const message = new ResponsiveNavControlMessage(controlCode, navLevel);
        this.controlNavSubject.next(message);
    }
    /**
     * @return {?}
     */
    closeAllNavs() {
        /** @type {?} */
        const message = new ResponsiveNavControlMessage(ResponsiveNavCodes.NAV_CLOSE_ALL, -999);
        this.controlNavSubject.next(message);
    }
}
ResponsiveNavigationService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
ResponsiveNavigationService.ctorParameters = () => [];
/** @nocollapse */ ResponsiveNavigationService.ngInjectableDef = defineInjectable({ factory: function ResponsiveNavigationService_Factory() { return new ResponsiveNavigationService(); }, token: ResponsiveNavigationService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrMainContainer {
    /**
     * @param {?} elRef
     * @param {?} responsiveNavService
     */
    constructor(elRef, responsiveNavService) {
        this.elRef = elRef;
        this.responsiveNavService = responsiveNavService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._classList = this.elRef.nativeElement.classList;
        this._subscription = this.responsiveNavService.navControl.subscribe({
            next: (message) => {
                this.processMessage(message);
            },
        });
    }
    /**
     * @param {?} message
     * @return {?}
     */
    processMessage(message) {
        /** @type {?} */
        let navClass = ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
        if (message.controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL) {
            this._classList.remove(ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
            this._classList.remove(ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
        }
        else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
            this.controlNav(message.controlCode, navClass);
        }
        else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
            navClass = ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
            this.controlNav(message.controlCode, navClass);
        }
    }
    /**
     * @param {?} controlCode
     * @param {?} navClass
     * @return {?}
     */
    controlNav(controlCode, navClass) {
        if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
            this._classList.add(navClass);
        }
        else if (controlCode === ResponsiveNavCodes.NAV_CLOSE) {
            this._classList.remove(navClass);
        }
        else if (controlCode === ResponsiveNavCodes.NAV_TOGGLE) {
            this._classList.toggle(navClass);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
ClrMainContainer.decorators = [
    { type: Directive, args: [{ selector: 'clr-main-container', host: { '[class.main-container]': 'true' } },] }
];
/** @nocollapse */
ClrMainContainer.ctorParameters = () => [
    { type: ElementRef },
    { type: ResponsiveNavigationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_LAYOUT_DIRECTIVES = [ClrMainContainer];
class ClrMainContainerModule {
}
ClrMainContainerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule],
                declarations: [CLR_LAYOUT_DIRECTIVES],
                exports: [CLR_LAYOUT_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class MainContainerWillyWonka extends WillyWonka {
}
MainContainerWillyWonka.decorators = [
    { type: Directive, args: [{ selector: 'clr-main-container' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NavDetectionOompaLoompa extends OompaLoompa {
    /**
     * @param {?} cdr
     * @param {?} willyWonka
     * @param {?} responsiveNavService
     */
    constructor(cdr, willyWonka, responsiveNavService) {
        if (!willyWonka) {
            throw new Error('clr-header should only be used inside of a clr-main-container');
        }
        super(cdr, willyWonka);
        this.responsiveNavService = responsiveNavService;
    }
    // NavDetectionOompaLoompa is the addition of the nav levels
    // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
    /**
     * @return {?}
     */
    get flavor() {
        return this.responsiveNavService.responsiveNavList.reduce((sum, navLevel) => sum + navLevel, 0);
    }
}
NavDetectionOompaLoompa.decorators = [
    { type: Directive, args: [{ selector: 'clr-header' },] }
];
/** @nocollapse */
NavDetectionOompaLoompa.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: MainContainerWillyWonka, decorators: [{ type: Optional }] },
    { type: ResponsiveNavigationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrHeader {
    /**
     * @param {?} responsiveNavService
     */
    constructor(responsiveNavService) {
        this.responsiveNavService = responsiveNavService;
        this.isNavLevel1OnPage = false;
        this.isNavLevel2OnPage = false;
        this.responsiveNavCodes = ResponsiveNavCodes;
        this._subscription = this.responsiveNavService.registeredNavs.subscribe({
            next: (navLevelList) => {
                this.initializeNavTriggers(navLevelList);
            },
        });
    }
    // reset triggers. handles cases when an application has different nav levels on different pages.
    /**
     * @return {?}
     */
    resetNavTriggers() {
        this.isNavLevel1OnPage = false;
        this.isNavLevel2OnPage = false;
    }
    // decides which triggers to show on the header
    /**
     * @param {?} navList
     * @return {?}
     */
    initializeNavTriggers(navList) {
        this.resetNavTriggers();
        if (navList.length > 2) {
            console.error('More than 2 Nav Levels detected.');
            return;
        }
        navList.forEach(navLevel => {
            if (navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                this.isNavLevel1OnPage = true;
            }
            else if (navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                this.isNavLevel2OnPage = true;
            }
        });
    }
    // closes the nav that is open
    /**
     * @return {?}
     */
    closeOpenNav() {
        this.responsiveNavService.closeAllNavs();
    }
    // toggles the nav that is open
    /**
     * @param {?} navLevel
     * @return {?}
     */
    toggleNav(navLevel) {
        this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_TOGGLE, navLevel);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subscription.unsubscribe();
    }
}
ClrHeader.decorators = [
    { type: Component, args: [{
                selector: 'clr-header',
                template: `
        <button
            type="button"
            *ngIf="isNavLevel1OnPage"
            class="header-hamburger-trigger"
            (click)="toggleNav(responsiveNavCodes.NAV_LEVEL_1)">
            <span></span>
        </button>
        <ng-content></ng-content>
        <button
            type="button"
            *ngIf="isNavLevel2OnPage"
            class="header-overflow-trigger"
            (click)="toggleNav(responsiveNavCodes.NAV_LEVEL_2)">
            <span></span>
        </button>
        <div class="header-backdrop" (click)="closeOpenNav()"></div>
    `,
                host: { '[class.header]': 'true' }
            }] }
];
/** @nocollapse */
ClrHeader.ctorParameters = () => [
    { type: ResponsiveNavigationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrNavLevel {
    /**
     * @param {?} responsiveNavService
     * @param {?} elementRef
     */
    constructor(responsiveNavService, elementRef) {
        this.responsiveNavService = responsiveNavService;
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.level !== ResponsiveNavCodes.NAV_LEVEL_1 && this.level !== ResponsiveNavCodes.NAV_LEVEL_2) {
            console.error('Nav Level can only be 1 or 2');
            return;
        }
        this.responsiveNavService.registerNav(this.level);
        this.addNavClass(this.level);
    }
    /**
     * @param {?} level
     * @return {?}
     */
    addNavClass(level) {
        /** @type {?} */
        const navHostClassList = this.elementRef.nativeElement.classList;
        if (level === ResponsiveNavCodes.NAV_LEVEL_1) {
            navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_1);
        }
        else if (level === ResponsiveNavCodes.NAV_LEVEL_2) {
            navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_2);
        }
    }
    /**
     * @return {?}
     */
    get level() {
        return this._level;
    }
    // getter to access the responsive navigation codes from the template
    /**
     * @return {?}
     */
    get responsiveNavCodes() {
        return ResponsiveNavCodes;
    }
    /**
     * @return {?}
     */
    open() {
        this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, this.level);
    }
    /**
     * @return {?}
     */
    close() {
        this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, this.level);
    }
    // TODO: Figure out whats the best way to do this. Possible methods
    // 1. HostListener (current solution)
    // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
    // why
    /**
     * @param {?} target
     * @return {?}
     */
    onMouseClick(target) {
        /** @type {?} */
        let current = target;
        // Get the element in the DOM on which the mouse was clicked
        /** @type {?} */
        const navHost = this.elementRef.nativeElement;
        // Start checking if current and navHost are equal.
        // If not traverse to the parentNode and check again.
        while (current) {
            if (current === navHost) {
                return;
            }
            else if (current.classList.contains('nav-link')) {
                this.close();
                return;
            }
            current = current.parentNode;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.responsiveNavService.unregisterNav(this.level);
    }
}
ClrNavLevel.decorators = [
    { type: Directive, args: [{ selector: '[clr-nav-level]' },] }
];
/** @nocollapse */
ClrNavLevel.ctorParameters = () => [
    { type: ResponsiveNavigationService },
    { type: ElementRef }
];
ClrNavLevel.propDecorators = {
    _level: [{ type: Input, args: ['clr-nav-level',] }],
    onMouseClick: [{ type: HostListener, args: ['click', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_NAVIGATION_DIRECTIVES = [
    ClrHeader,
    ClrNavLevel,
    NavDetectionOompaLoompa,
    MainContainerWillyWonka,
];
class ClrNavigationModule {
}
ClrNavigationModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule, ClrDropdownModule],
                declarations: [CLR_NAVIGATION_DIRECTIVES],
                exports: [CLR_NAVIGATION_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TemplateRefContainer {
}
TemplateRefContainer.decorators = [
    { type: Component, args: [{
                template: `
      <ng-template>
        <ng-content></ng-content>
      </ng-template>
    `
            }] }
];
TemplateRefContainer.propDecorators = {
    template: [{ type: ViewChild, args: [TemplateRef,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const TEMPLATE_REF_DIRECTIVES = [TemplateRefContainer];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTemplateRefModule {
}
ClrTemplateRefModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [TEMPLATE_REF_DIRECTIVES],
                entryComponents: [TEMPLATE_REF_DIRECTIVES],
                exports: [TEMPLATE_REF_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TabsWillyWonka extends WillyWonka {
}
TabsWillyWonka.decorators = [
    { type: Directive, args: [{ selector: 'clr-tabs' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ActiveOompaLoompa extends OompaLoompa {
    /**
     * @param {?} cdr
     * @param {?} willyWonka
     * @param {?} id
     * @param {?} ifActive
     */
    constructor(cdr, willyWonka, id, ifActive) {
        if (!willyWonka) {
            throw new Error('clrTabLink and clr-tab-content should only be used inside of a clr-tabs');
        }
        super(cdr, willyWonka);
        this.ifActive = ifActive;
        this.id = id;
    }
    /**
     * @return {?}
     */
    get flavor() {
        return this.ifActive.current === this.id;
    }
}
ActiveOompaLoompa.decorators = [
    { type: Directive, args: [{ selector: '[clrTabLink], clr-tab-content' },] }
];
/** @nocollapse */
ActiveOompaLoompa.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: TabsWillyWonka, decorators: [{ type: Optional }] },
    { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
    { type: IfActiveService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// TODO: if we find more components that could use this, consider moving this to utils
class AriaService {
}
AriaService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class TabsService {
    constructor() {
        this._children = [];
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    register(tab) {
        this._children.push(tab);
    }
    /**
     * @return {?}
     */
    get children() {
        return this._children;
    }
    /**
     * @return {?}
     */
    get activeTab() {
        return this.children.find((tab) => {
            return tab.active;
        });
    }
    /**
     * @return {?}
     */
    get overflowTabs() {
        return this.children.filter((tab) => {
            return tab.tabLink.inOverflow === true;
        });
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    unregister(tab) {
        /** @type {?} */
        const index = this.children.indexOf(tab);
        if (index > -1) {
            this.children.splice(index, 1);
        }
    }
}
TabsService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let nbTabContentComponents = 0;
class ClrTabContent {
    /**
     * @param {?} ifActiveService
     * @param {?} id
     * @param {?} ariaService
     */
    constructor(ifActiveService, id, ariaService) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.ariaService = ariaService;
        if (!this.tabContentId) {
            this.tabContentId = 'clr-tab-content-' + nbTabContentComponents++;
        }
    }
    /**
     * @return {?}
     */
    get ariaLabelledBy() {
        return this.ariaService.ariaLabelledBy;
    }
    /**
     * @return {?}
     */
    get tabContentId() {
        return this.ariaService.ariaControls;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    set tabContentId(id) {
        this.ariaService.ariaControls = id;
    }
    /**
     * @return {?}
     */
    get active() {
        return this.ifActiveService.current === this.id;
    }
}
ClrTabContent.decorators = [
    { type: Component, args: [{
                selector: 'clr-tab-content',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    '[id]': 'tabContentId',
                    '[attr.aria-labelledby]': 'ariaLabelledBy',
                    '[attr.aria-hidden]': '!active',
                    '[attr.aria-expanded]': 'active',
                    '[attr.data-hidden]': '!active',
                    role: 'tabpanel',
                }
            }] }
];
/** @nocollapse */
ClrTabContent.ctorParameters = () => [
    { type: IfActiveService },
    { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
    { type: AriaService }
];
ClrTabContent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['tabContentProjectedRef',] }],
    tabContentId: [{ type: Input, args: ['id',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let nbTabsComponent = 0;
/** @type {?} */
const TABS_ID = new InjectionToken('TABS_ID');
/**
 * @return {?}
 */
function tokenFactory$1() {
    return 'clr-tabs-' + nbTabsComponent++;
}
/** @type {?} */
const TABS_ID_PROVIDER = {
    provide: TABS_ID,
    useFactory: tokenFactory$1,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let nbTabLinkComponents = 0;
class ClrTabLink {
    /**
     * @param {?} ifActiveService
     * @param {?} id
     * @param {?} ariaService
     * @param {?} el
     * @param {?} cfr
     * @param {?} viewContainerRef
     * @param {?} tabsId
     */
    constructor(ifActiveService, id, ariaService, el, cfr, viewContainerRef, tabsId) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.ariaService = ariaService;
        this.el = el;
        this.cfr = cfr;
        this.viewContainerRef = viewContainerRef;
        this.tabsId = tabsId;
        if (!this.tabLinkId) {
            this.tabLinkId = 'clr-tab-link-' + nbTabLinkComponents++;
        }
        // Tab links can be rendered in one of two places: in the main area or inside the overflow dropdown menu.
        // Here, we create a container so that its template can be used to create embeddedView on the fly.
        // See TabsService's renderView() method and how it's used in Tabs class for an example.
        /** @type {?} */
        const factory = this.cfr.resolveComponentFactory(TemplateRefContainer);
        this.templateRefContainer = this.viewContainerRef.createComponent(factory, 1, undefined, [
            [this.el.nativeElement],
        ]).instance;
    }
    /**
     * @return {?}
     */
    get ariaControls() {
        return this.ariaService.ariaControls;
    }
    /**
     * @return {?}
     */
    get tabLinkId() {
        return this.ariaService.ariaLabelledBy;
    }
    /**
     * @param {?} id
     * @return {?}
     */
    set tabLinkId(id) {
        this.ariaService.ariaLabelledBy = id;
    }
    /**
     * @return {?}
     */
    activate() {
        this.ifActiveService.current = this.id;
    }
    /**
     * @return {?}
     */
    get active() {
        return this.ifActiveService.current === this.id;
    }
}
ClrTabLink.decorators = [
    { type: Directive, args: [{
                selector: '[clrTabLink]',
                host: {
                    '[id]': 'tabLinkId',
                    '[attr.aria-selected]': 'active',
                    '[attr.aria-hidden]': 'false',
                    '[attr.aria-controls]': 'ariaControls',
                    '[class.btn]': 'true',
                    '[class.btn-link]': '!inOverflow',
                    '[class.nav-link]': '!inOverflow',
                    '[class.nav-item]': '!inOverflow',
                    '[class.active]': 'active',
                    role: 'tab',
                    type: 'button',
                },
            },] }
];
/** @nocollapse */
ClrTabLink.ctorParameters = () => [
    { type: IfActiveService },
    { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
    { type: AriaService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef },
    { type: Number, decorators: [{ type: Inject, args: [TABS_ID,] }] }
];
ClrTabLink.propDecorators = {
    inOverflow: [{ type: Input, args: ['clrTabLinkInOverflow',] }],
    tabLinkId: [{ type: Input, args: ['id',] }],
    activate: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTab {
    /**
     * @param {?} ifActiveService
     * @param {?} id
     * @param {?} tabsService
     */
    constructor(ifActiveService, id, tabsService) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.tabsService = tabsService;
        tabsService.register(this);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.tabsService.unregister(this);
    }
    /**
     * @return {?}
     */
    get active() {
        return this.ifActiveService.current === this.id;
    }
}
ClrTab.decorators = [
    { type: Component, args: [{
                selector: 'clr-tab',
                template: `
        <ng-content></ng-content>
    `,
                providers: [IF_ACTIVE_ID_PROVIDER, AriaService]
            }] }
];
/** @nocollapse */
ClrTab.ctorParameters = () => [
    { type: IfActiveService },
    { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
    { type: TabsService }
];
ClrTab.propDecorators = {
    tabLink: [{ type: ContentChild, args: [ClrTabLink,] }],
    tabContent: [{ type: ContentChild, args: [ClrTabContent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTabOverflowContent extends AbstractPopover {
    /**
     * @param {?} injector
     * @param {?} parentHost
     */
    constructor(injector, parentHost) {
        super(injector, parentHost);
        this.anchorPoint = Point.BOTTOM_RIGHT;
        this.popoverPoint = Point.RIGHT_TOP;
        this.closeOnOutsideClick = true;
    }
}
ClrTabOverflowContent.decorators = [
    { type: Component, args: [{
                selector: 'clr-tab-overflow-content',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    '[class.dropdown-menu]': 'true',
                }
            }] }
];
/** @nocollapse */
ClrTabOverflowContent.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef, decorators: [{ type: SkipSelf }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTabs {
    /**
     * @param {?} ifActiveService
     * @param {?} ifOpenService
     * @param {?} tabsService
     * @param {?} tabsId
     * @param {?} commonStrings
     */
    constructor(ifActiveService, ifOpenService, tabsService, tabsId, commonStrings) {
        this.ifActiveService = ifActiveService;
        this.ifOpenService = ifOpenService;
        this.tabsService = tabsService;
        this.tabsId = tabsId;
        this.commonStrings = commonStrings;
    }
    /**
     * @return {?}
     */
    get activeTabInOverflow() {
        return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
    }
    /**
     * @return {?}
     */
    get tabIds() {
        return this.tabsService.children.map(tab => tab.tabLink.tabLinkId).join(' ');
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (typeof this.ifActiveService.current === 'undefined') {
            this.tabLinkDirectives.first.activate();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleOverflow(event) {
        this.ifOpenService.toggleWithEvent(event);
    }
}
ClrTabs.decorators = [
    { type: Component, args: [{
                selector: 'clr-tabs',
                template: `
        <ul class="nav" role="tablist" [attr.aria-owns]="tabIds">
            <!--tab links-->
            <ng-container *ngFor="let link of tabLinkDirectives">
                <ng-container *ngIf="link.tabsId === tabsId && !link.inOverflow"
                              [ngTemplateOutlet]="link.templateRefContainer.template">
                </ng-container>
            </ng-container>
            <ng-container *ngIf="tabsService.overflowTabs.length > 0">
                <div class="tabs-overflow bottom-right" [class.open]="ifOpenService.open"
                     (click)="toggleOverflow($event)">
                    <li role="presentation" class="nav-item">
                        <button class="btn btn-link nav-link dropdown-toggle" type="button" [class.active]="activeTabInOverflow">
                            <clr-icon shape="ellipsis-horizontal"
                              [class.is-info]="ifOpenService.open"
                              [attr.title]="commonStrings.more"></clr-icon>
                        </button>
                    </li>
                    <!--tab links in overflow menu-->
                    <clr-tab-overflow-content>
                        <ng-container *ngFor="let link of tabLinkDirectives">
                            <ng-container *ngIf="link.tabsId === tabsId && link.inOverflow"
                                          [ngTemplateOutlet]="link.templateRefContainer.template">
                            </ng-container>
                        </ng-container>
                    </clr-tab-overflow-content>
                </div>
            </ng-container>
        </ul>
        <!--tab content-->
        <ng-content></ng-content>
    `,
                providers: [IfActiveService, IfOpenService, TabsService, TABS_ID_PROVIDER]
            }] }
];
/** @nocollapse */
ClrTabs.ctorParameters = () => [
    { type: IfActiveService },
    { type: IfOpenService },
    { type: TabsService },
    { type: Number, decorators: [{ type: Inject, args: [TABS_ID,] }] },
    { type: ClrCommonStrings }
];
ClrTabs.propDecorators = {
    tabLinkDirectives: [{ type: ContentChildren, args: [ClrTabLink, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_TABS_DIRECTIVES = [
    ClrTabContent,
    ClrTab,
    ClrTabs,
    ClrTabOverflowContent,
    ClrTabLink,
    TabsWillyWonka,
    ActiveOompaLoompa,
];
class ClrTabsModule {
}
ClrTabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrCommonPopoverModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule],
                declarations: [CLR_TABS_DIRECTIVES],
                exports: [CLR_TABS_DIRECTIVES, ClrConditionalModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VerticalNavGroupRegistrationService {
    constructor() {
        this.navGroupCount = 0;
    }
    /**
     * @return {?}
     */
    registerNavGroup() {
        this.navGroupCount++;
    }
    /**
     * @return {?}
     */
    unregisterNavGroup() {
        this.navGroupCount--;
    }
}
VerticalNavGroupRegistrationService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VerticalNavIconService {
    constructor() {
        this._icons = 0;
    }
    /**
     * @return {?}
     */
    get hasIcons() {
        return this._icons > 0;
    }
    /**
     * @return {?}
     */
    registerIcon() {
        this._icons++;
    }
    /**
     * @return {?}
     */
    unregisterIcon() {
        this._icons--;
    }
}
VerticalNavIconService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VerticalNavService {
    constructor() {
        this._animateOnCollapsed = new Subject();
        this._collapsedChanged = new Subject();
        this._collapsed = false;
        this._collapsible = false;
    }
    /**
     * @return {?}
     */
    get animateOnCollapsed() {
        return this._animateOnCollapsed.asObservable();
    }
    /**
     * @return {?}
     */
    get collapsedChanged() {
        return this._collapsedChanged.asObservable();
    }
    /**
     * @return {?}
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collapsed(value) {
        value = !!value;
        if (this.collapsible && this._collapsed !== value) {
            this.updateCollapseBehavior(value);
        }
    }
    /**
     * @return {?}
     */
    get collapsible() {
        return this._collapsible;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collapsible(value) {
        value = !!value;
        if (this._collapsible !== value) {
            if (!value && this.collapsed) {
                this.updateCollapseBehavior(false);
            }
            this._collapsible = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateCollapseBehavior(value) {
        this._animateOnCollapsed.next(value);
        this._collapsed = value;
        this._collapsedChanged.next(value);
    }
}
VerticalNavService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrVerticalNav {
    /**
     * @param {?} _navService
     * @param {?} _navIconService
     * @param {?} _navGroupRegistrationService
     * @param {?} commonStrings
     */
    constructor(_navService, _navIconService, _navGroupRegistrationService, commonStrings) {
        this._navService = _navService;
        this._navIconService = _navIconService;
        this._navGroupRegistrationService = _navGroupRegistrationService;
        this.commonStrings = commonStrings;
        this._collapsedChanged = new EventEmitter(true);
        this._sub = this._navService.collapsedChanged.subscribe(value => {
            this._collapsedChanged.emit(value);
        });
    }
    /**
     * @return {?}
     */
    get collapsible() {
        return this._navService.collapsible;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collapsible(value) {
        this._navService.collapsible = value;
    }
    /**
     * @return {?}
     */
    get collapsed() {
        return this._navService.collapsed;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set collapsed(value) {
        this._navService.collapsed = value;
    }
    /**
     * @return {?}
     */
    get hasNavGroups() {
        return this._navGroupRegistrationService.navGroupCount > 0;
    }
    /**
     * @return {?}
     */
    get hasIcons() {
        return this._navIconService.hasIcons;
    }
    /**
     * @return {?}
     */
    toggleByButton() {
        this.collapsed = !this.collapsed;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._sub.unsubscribe();
    }
}
ClrVerticalNav.decorators = [
    { type: Component, args: [{
                selector: 'clr-vertical-nav',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<button type=\"button\" class=\"nav-trigger\"\n        [class.on-collapse]=\"collapsed\"\n        (click)=\"toggleByButton()\"\n        *ngIf=\"collapsible\">\n    <clr-icon shape=\"angle-double\"\n              class=\"nav-trigger-icon\"\n              [attr.dir]=\"(this.collapsed) ? 'right' : 'left'\"\n              [attr.title]=\"(this.collapsed) ? commonStrings.expand : commonStrings.collapse\"></clr-icon>\n</button>\n<!-- Click handler on .nav-content is bad but required :-( -->\n<div class=\"nav-content\">\n    <ng-content></ng-content>\n    <button (click)=\"collapsed = false\" class=\"nav-btn\" *ngIf=\"collapsible && collapsed\"></button>\n</div>\n",
                providers: [VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService],
                host: {
                    class: 'clr-vertical-nav',
                    '[class.is-collapsed]': 'collapsed',
                    '[class.has-nav-groups]': 'hasNavGroups',
                    '[class.has-icons]': 'hasIcons',
                }
            }] }
];
/** @nocollapse */
ClrVerticalNav.ctorParameters = () => [
    { type: VerticalNavService },
    { type: VerticalNavIconService },
    { type: VerticalNavGroupRegistrationService },
    { type: ClrCommonStrings }
];
ClrVerticalNav.propDecorators = {
    collapsible: [{ type: Input, args: ['clrVerticalNavCollapsible',] }],
    collapsed: [{ type: Input, args: ['clrVerticalNavCollapsed',] }],
    _collapsedChanged: [{ type: Output, args: ['clrVerticalNavCollapsedChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class VerticalNavGroupService {
    constructor() {
        this._expandChange = new Subject();
    }
    /**
     * @return {?}
     */
    get expandChange() {
        return this._expandChange.asObservable();
    }
    /**
     * @return {?}
     */
    expand() {
        this._expandChange.next(true);
    }
}
VerticalNavGroupService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const EXPANDED_STATE = 'expanded';
/** @type {?} */
const COLLAPSED_STATE = 'collapsed';
class ClrVerticalNavGroup {
    /**
     * @param {?} _itemExpand
     * @param {?} _navGroupRegistrationService
     * @param {?} _navGroupService
     * @param {?} _navService
     * @param {?} commonStrings
     */
    constructor(_itemExpand, _navGroupRegistrationService, _navGroupService, _navService, commonStrings) {
        this._itemExpand = _itemExpand;
        this._navGroupRegistrationService = _navGroupRegistrationService;
        this._navGroupService = _navGroupService;
        this._navService = _navService;
        this.commonStrings = commonStrings;
        this.wasExpanded = false;
        this.expandedChange = new EventEmitter(true);
        this._subscriptions = [];
        this._expandAnimationState = COLLAPSED_STATE;
        this._navGroupRegistrationService.registerNavGroup();
        // FIXME: This subscription handles a corner case
        // Vertical Nav collapse requires the animation to run first and then
        // remove the nodes from the DOM. If the user directly sets the input
        // on the clrIfExpanded directive, we have no chance to run the animation
        // and wait for it to complete. This subscription makes sure that the
        // animation states are correct for that edge case.
        this._subscriptions.push(this._itemExpand.expandChange.subscribe(value => {
            if (value && this.expandAnimationState === COLLAPSED_STATE) {
                if (this._navService.collapsed) {
                    this._navService.collapsed = false;
                }
                this.expandAnimationState = EXPANDED_STATE;
            }
            else if (!value && this.expandAnimationState === EXPANDED_STATE) {
                this.expandAnimationState = COLLAPSED_STATE;
            }
        }));
        // 1. If the nav is collapsing, close the open nav group + save its state
        // 2. If the nav is expanding, expand the nav group if the previous state was expanded
        this._subscriptions.push(this._navService.animateOnCollapsed.subscribe((goingToCollapse) => {
            if (goingToCollapse && this.expanded) {
                this.wasExpanded = true;
                this.expandAnimationState = COLLAPSED_STATE;
            }
            else if (!goingToCollapse && this.wasExpanded) {
                this.expandGroup();
                this.wasExpanded = false;
            }
        }));
        // If a link is clicked, expand the nav group
        this._subscriptions.push(this._navGroupService.expandChange.subscribe((expand) => {
            if (expand && !this.expanded) {
                this.expandGroup();
            }
        }));
    }
    /**
     * @return {?}
     */
    get expanded() {
        return this._itemExpand.expanded;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expanded(value) {
        if (this._itemExpand.expanded !== value) {
            this._itemExpand.expanded = value;
            this.expandedChange.emit(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set userExpandedInput(value) {
        value = !!value;
        if (this.expanded !== value) {
            // We have to call toggleExpand because some cases require animations to occur first
            // Directly setting the Expand service value skips the animation and can result in
            // nodes in the DOM but the nav group still being collapsed
            this.toggleExpand();
        }
    }
    /**
     * @return {?}
     */
    expandGroup() {
        this.expanded = true;
        // Expanded animation occurs after Expand.expand is set to true
        this.expandAnimationState = EXPANDED_STATE;
    }
    /**
     * @return {?}
     */
    collapseGroup() {
        // If a Vertical Nav Group toggle button is clicked while the Vertical Nav is in Collapsed state,
        // the Vertical Nav should be expanded first.
        this.expandAnimationState = COLLAPSED_STATE;
    }
    // closes a group after the collapse animation
    /**
     * @param {?} $event
     * @return {?}
     */
    expandAnimationDone($event) {
        if ($event.toState === COLLAPSED_STATE) {
            this.expanded = false;
        }
    }
    /**
     * @return {?}
     */
    get expandAnimationState() {
        return this._expandAnimationState;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expandAnimationState(value) {
        if (value !== this._expandAnimationState) {
            this._expandAnimationState = value;
        }
    }
    /**
     * @return {?}
     */
    toggleExpand() {
        if (this.expanded) {
            this.collapseGroup();
        }
        else {
            // If nav is collasped, first open the nav
            if (this._navService.collapsed) {
                this._navService.collapsed = false;
            }
            // then expand the nav group
            this.expandGroup();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // This makes sure that if someone marks a nav group expanded in a collapsed nav
        // the expanded property is switched back to collapsed state.
        if (this._navService.collapsed && this.expanded) {
            this.wasExpanded = true;
            this.expandAnimationState = COLLAPSED_STATE;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._subscriptions.forEach((sub) => sub.unsubscribe());
        this._navGroupRegistrationService.unregisterNavGroup();
    }
}
ClrVerticalNavGroup.decorators = [
    { type: Component, args: [{
                selector: 'clr-vertical-nav-group',
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"nav-group-content\">\n    <ng-content select=\"[clrVerticalNavLink]\"></ng-content>\n    <button\n        class=\"nav-group-trigger\"\n        type=\"button\"\n        (click)=\"toggleExpand()\">\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <div class=\"nav-group-text\">\n            <ng-content></ng-content>\n        </div>\n        <clr-icon shape=\"caret\"\n                  class=\"nav-group-trigger-icon\"\n                  [attr.dir]=\"(this.expanded) ? 'down' : 'right'\"\n                  [attr.title]=\"(this.expanded) ? commonStrings.collapse : commonStrings.expand\">\n        </clr-icon>\n    </button>\n</div>\n<!--TODO: This animation needs to be added to the clr-vertical-nav-group-children component-->\n<div class=\"nav-group-children\"\n     [@clrExpand]=\"expandAnimationState\"\n     (@clrExpand.done)=\"expandAnimationDone($event)\">\n    <ng-content select=\"[clrIfExpanded], clr-vertical-nav-group-children\"></ng-content>\n</div>\n",
                providers: [Expand, VerticalNavGroupService],
                animations: [
                    trigger('clrExpand', [
                        state(EXPANDED_STATE, style({ height: '*' })),
                        state(COLLAPSED_STATE, style({ height: 0, 'overflow-y': 'hidden', visibility: 'hidden' })),
                        transition(`${EXPANDED_STATE} <=> ${COLLAPSED_STATE}`, animate('0.2s ease-in-out')),
                    ]),
                ],
                host: { class: 'nav-group' }
            }] }
];
/** @nocollapse */
ClrVerticalNavGroup.ctorParameters = () => [
    { type: Expand },
    { type: VerticalNavGroupRegistrationService },
    { type: VerticalNavGroupService },
    { type: VerticalNavService },
    { type: ClrCommonStrings }
];
ClrVerticalNavGroup.propDecorators = {
    expanded: [{ type: HostBinding, args: ['class.is-expanded',] }],
    userExpandedInput: [{ type: Input, args: ['clrVerticalNavGroupExpanded',] }],
    expandedChange: [{ type: Output, args: ['clrVerticalNavGroupExpandedChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrVerticalNavGroupChildren {
}
ClrVerticalNavGroupChildren.decorators = [
    { type: Component, args: [{
                selector: 'clr-vertical-nav-group-children',
                template: `
        <ng-content></ng-content>
    `
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrVerticalNavIcon {
    /**
     * @param {?} _verticalNavIconService
     */
    constructor(_verticalNavIconService) {
        this._verticalNavIconService = _verticalNavIconService;
        this._verticalNavIconService.registerIcon();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._verticalNavIconService.unregisterIcon();
    }
}
ClrVerticalNavIcon.decorators = [
    { type: Directive, args: [{ selector: '[clrVerticalNavIcon]', host: { class: 'nav-icon' } },] }
];
/** @nocollapse */
ClrVerticalNavIcon.ctorParameters = () => [
    { type: VerticalNavIconService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrVerticalNavLink {
    /**
     * @param {?} _navGroupService
     */
    constructor(_navGroupService) {
        this._navGroupService = _navGroupService;
    }
    /**
     * @return {?}
     */
    expandParentNavGroup() {
        if (this._navGroupService) {
            this._navGroupService.expand();
        }
    }
}
ClrVerticalNavLink.decorators = [
    { type: Component, args: [{
                selector: '[clrVerticalNavLink]',
                template: `
        <ng-content select="[clrVerticalNavIcon]"></ng-content>
        <span class="nav-text">
            <ng-content></ng-content>    
        </span>
    `,
                host: { class: 'nav-link' }
            }] }
];
/** @nocollapse */
ClrVerticalNavLink.ctorParameters = () => [
    { type: VerticalNavGroupService, decorators: [{ type: Optional }] }
];
ClrVerticalNavLink.propDecorators = {
    expandParentNavGroup: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_VERTICAL_NAV_DIRECTIVES = [
    ClrVerticalNav,
    ClrVerticalNavLink,
    ClrVerticalNavGroup,
    ClrVerticalNavGroupChildren,
    ClrVerticalNavIcon,
];
class ClrVerticalNavModule {
}
ClrVerticalNavModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule, ClrIfExpandModule],
                declarations: [CLR_VERTICAL_NAV_DIRECTIVES],
                exports: [CLR_VERTICAL_NAV_DIRECTIVES, ClrIfExpandModule, ClrIconModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrLayoutModule {
}
ClrLayoutModule.decorators = [
    { type: NgModule, args: [{ exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ScrollingService {
    /**
     * @param {?} _document
     */
    constructor(_document) {
        this._document = _document;
    }
    /**
     * @return {?}
     */
    stopScrolling() {
        this._document.body.classList.add('no-scrolling');
    }
    /**
     * @return {?}
     */
    resumeScrolling() {
        if (this._document.body.classList.contains('no-scrolling')) {
            this._document.body.classList.remove('no-scrolling');
        }
    }
}
ScrollingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ScrollingService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrModal {
    /**
     * @param {?} _scrollingService
     * @param {?} commonStrings
     * @param {?} modalId
     */
    constructor(_scrollingService, commonStrings, modalId) {
        this._scrollingService = _scrollingService;
        this.commonStrings = commonStrings;
        this.modalId = modalId;
        this._open = false;
        this._openChanged = new EventEmitter(false);
        this.closable = true;
        this.staticBackdrop = false;
        this.skipAnimation = 'false';
        // presently this is only used by wizards
        this.bypassScrollService = false;
        this.stopClose = false;
        this.altClose = new EventEmitter(false);
    }
    /**
     * @return {?}
     */
    get sizeClass() {
        if (this.size) {
            return 'modal-' + this.size;
        }
        else {
            return '';
        }
    }
    // Detect when _open is set to true and set no-scrolling to true
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this.bypassScrollService && changes && changes.hasOwnProperty('_open')) {
            if (changes._open.currentValue) {
                this._scrollingService.stopScrolling();
            }
            else {
                this._scrollingService.resumeScrolling();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._scrollingService.resumeScrolling();
    }
    /**
     * @return {?}
     */
    open() {
        if (this._open) {
            return;
        }
        this._open = true;
        this._openChanged.emit(true);
    }
    /**
     * @return {?}
     */
    close() {
        if (this.stopClose) {
            this.altClose.emit(false);
            return;
        }
        if (!this.closable || !this._open) {
            return;
        }
        this._open = false;
        // todo: remove this after animation bug is fixed https://github.com/angular/angular/issues/15798
        // this was handled by the fadeDone event below, but that AnimationEvent is not firing in Angular 4.0.
        this._openChanged.emit(false);
        // SPECME
        this.focusTrap.setPreviousFocus(); // Handles moving focus back to the element that had it before.
    }
    /**
     * @param {?} e
     * @return {?}
     */
    fadeDone(e) {
        if (e.toState === 'void') {
            this._openChanged.emit(false);
        }
    }
}
ClrModal.decorators = [
    { type: Component, args: [{
                selector: 'clr-modal',
                viewProviders: [ScrollingService],
                template: "\n<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div clrFocusTrap class=\"modal\" *ngIf=\"_open\">\n    <!--fixme: revisit when ngClass works with exit animation-->\n    <div [@fadeDown]=\"skipAnimation\" (@fadeDown.done)=\"fadeDone($event)\"\n         class=\"modal-dialog\"\n         [class.modal-sm]=\"size == 'sm'\"\n         [class.modal-lg]=\"size == 'lg'\"\n         [class.modal-xl]=\"size == 'xl'\"\n         role=\"dialog\"\n         [attr.aria-hidden]=\"!_open\"\n         [attr.aria-labelledby]=\"modalId\">\n\n      <div class=\"modal-content-wrapper\">\n        <!-- only used in wizards -->\n        <ng-content select=\".modal-nav\"></ng-content>\n\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <button type=\"button\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n              <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n            </button>\n            <div class=\"modal-title-wrapper\" id=\"{{modalId}}\">\n              <ng-content select=\".modal-title\"></ng-content>\n            </div>\n          </div>\n          <ng-content select=\".modal-body\"></ng-content>\n          <ng-content select=\".modal-footer\"></ng-content>\n        </div>\n      </div>\n    </div>\n\n    <div [@fade] class=\"modal-backdrop\"\n         aria-hidden=\"true\"\n         (click)=\"staticBackdrop || close()\"></div>\n</div>\n\n",
                animations: [
                    trigger('fadeDown', [
                        transition('* => false', [style({ opacity: 0, transform: 'translate(0, -25%)' }), animate('0.2s ease-in-out')]),
                        transition('false => *', [animate('0.2s ease-in-out', style({ opacity: 0, transform: 'translate(0, -25%)' }))]),
                    ]),
                    trigger('fade', [
                        transition('void => *', [style({ opacity: 0 }), animate('0.2s ease-in-out', style({ opacity: 0.85 }))]),
                        transition('* => void', [animate('0.2s ease-in-out', style({ opacity: 0 }))]),
                    ]),
                ],
                providers: [UNIQUE_ID_PROVIDER],
                styles: [`
        :host { display: none; }
        :host.open { display: inline; }
    `]
            }] }
];
/** @nocollapse */
ClrModal.ctorParameters = () => [
    { type: ScrollingService },
    { type: ClrCommonStrings },
    { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] }
];
ClrModal.propDecorators = {
    focusTrap: [{ type: ViewChild, args: [FocusTrapDirective,] }],
    _open: [{ type: HostBinding, args: ['class.open',] }, { type: Input, args: ['clrModalOpen',] }],
    _openChanged: [{ type: Output, args: ['clrModalOpenChange',] }],
    closable: [{ type: Input, args: ['clrModalClosable',] }],
    size: [{ type: Input, args: ['clrModalSize',] }],
    staticBackdrop: [{ type: Input, args: ['clrModalStaticBackdrop',] }],
    skipAnimation: [{ type: Input, args: ['clrModalSkipAnimation',] }],
    bypassScrollService: [{ type: Input, args: ['clrModalOverrideScrollService',] }],
    stopClose: [{ type: Input, args: ['clrModalPreventClose',] }],
    altClose: [{ type: Output, args: ['clrModalAlternateClose',] }],
    close: [{ type: HostListener, args: ['body:keyup.escape',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_MODAL_DIRECTIVES = [ClrModal];
class ClrModalModule {
}
ClrModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrIconModule, ClrFocusTrapModule],
                declarations: [CLR_MODAL_DIRECTIVES],
                exports: [CLR_MODAL_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const SIGNPOST_POSITIONS = {
    'top-left': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_RIGHT, offsetY: -10, offsetX: 0 },
    'top-middle': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_CENTER, offsetY: -10, offsetX: 0 },
    'top-right': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_LEFT, offsetY: -10, offsetX: 0 },
    'right-top': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_BOTTOM, offsetY: 2, offsetX: 14 },
    'right-middle': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
    'right-bottom': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_TOP, offsetY: -1, offsetX: 14 },
    'bottom-right': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_LEFT, offsetY: 9, offsetX: -1 },
    'bottom-middle': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_CENTER, offsetY: 9, offsetX: 12 },
    'bottom-left': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_RIGHT, offsetY: 9, offsetX: 0 },
    'left-bottom': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_TOP, offsetY: 0, offsetX: -14 },
    'left-middle': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_CENTER, offsetY: 4, offsetX: -14 },
    'left-top': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_BOTTOM, offsetY: 0, offsetX: -14 },
    default: { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// aka where the arrow / pointer is at in relation to the anchor
/** @type {?} */
const POSITIONS = [
    'top-left',
    'top-middle',
    'top-right',
    'right-top',
    'right-middle',
    'right-bottom',
    'bottom-right',
    'bottom-middle',
    'bottom-left',
    'left-bottom',
    'left-middle',
    'left-top',
];
class ClrSignpostContent extends AbstractPopover {
    /**
     * @param {?} injector
     * @param {?} parentHost
     * @param {?} commonStrings
     */
    constructor(injector, parentHost, commonStrings) {
        if (!parentHost) {
            throw new Error('clr-signpost-content should only be used inside of a clr-signpost');
        }
        super(injector, parentHost);
        this.commonStrings = commonStrings;
        // Defaults
        this.position = 'right-middle';
        this.closeOnOutsideClick = true;
    }
    /**
     * *******
     *
     * \@description
     * Close function that uses the signpost instance to toggle the state of the content popover.
     *
     * @return {?}
     */
    close() {
        this.ifOpenService.open = false;
    }
    /**
     * @return {?}
     */
    get position() {
        return this._position;
    }
    /**
     * ******
     *
     * \@description
     * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
     * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
     * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
     * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
     * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
     * There are 12 possible positions to place a ClrSignpostContent container:
     * - top-left
     * - top-middle
     * - top-right
     * - right-top
     * - right-middle
     * - right-bottom
     * - bottom-right
     * - bottom-middle
     * - bottom-left
     * - left-bottom
     * - left-middle
     * - left-top
     *
     * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
     * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
     * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
     * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
     *
     * @param {?} position
     * @return {?}
     */
    set position(position) {
        // Ugh
        this.renderer.removeClass(this.el.nativeElement, this.position);
        if (position && POSITIONS.indexOf(position) > -1) {
            this._position = position;
        }
        else {
            this._position = 'right-middle';
        }
        // Ugh
        this.renderer.addClass(this.el.nativeElement, this.position);
        /** @type {?} */
        const setPosition = SIGNPOST_POSITIONS[this.position];
        this.anchorPoint = setPosition.anchorPoint;
        this.popoverPoint = setPosition.popoverPoint;
        this.popoverOptions.offsetY = setPosition.offsetY;
        this.popoverOptions.offsetX = setPosition.offsetX;
    }
}
ClrSignpostContent.decorators = [
    { type: Component, args: [{
                selector: 'clr-signpost-content',
                template: `
        <div class="signpost-flex-wrap">
            <div class="popover-pointer"></div>
            <div class="signpost-content-header">
                <button type="button" class="signpost-action close" (click)="close()">
                    <clr-icon shape="close" [attr.title]="commonStrings.close"></clr-icon>
                </button>
            </div>
            <div class="signpost-content-body">
                <ng-content></ng-content>
            </div>
        </div>
    `,
                host: { '[class.signpost-content]': 'true' }
            }] }
];
/** @nocollapse */
ClrSignpostContent.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [POPOVER_HOST_ANCHOR,] }] },
    { type: ClrCommonStrings }
];
ClrSignpostContent.propDecorators = {
    position: [{ type: Input, args: ['clrPosition',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_SIGNPOST_DIRECTIVES = [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger];
class ClrSignpostModule {
}
ClrSignpostModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrCommonPopoverModule, ClrIconModule],
                declarations: [CLR_SIGNPOST_DIRECTIVES],
                exports: [CLR_SIGNPOST_DIRECTIVES, ClrConditionalModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTooltip {
}
ClrTooltip.decorators = [
    { type: Component, args: [{
                selector: 'clr-tooltip',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    '[class.tooltip]': 'true',
                },
                providers: [IfOpenService, { provide: POPOVER_HOST_ANCHOR, useExisting: ElementRef }]
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const POSITIONS$1 = ['bottom-left', 'bottom-right', 'top-left', 'top-right', 'right', 'left'];
/** @type {?} */
const SIZES = ['xs', 'sm', 'md', 'lg'];
class ClrTooltipContent extends AbstractPopover {
    /**
     * @param {?} injector
     * @param {?} parentHost
     */
    constructor(injector, parentHost) {
        if (!parentHost) {
            throw new Error('clr-tooltip-content should only be used inside of a clr-tooltip');
        }
        super(injector, parentHost);
        // Defaults
        this.position = 'right';
        this.size = 'sm';
    }
    /**
     * @return {?}
     */
    get position() {
        return this._position;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    set position(position) {
        // Ugh
        this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.position);
        if (position && POSITIONS$1.indexOf(position) > -1) {
            this._position = position;
        }
        else {
            this._position = 'right';
        }
        // Ugh
        this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.position);
        // set the popover values based on direction
        switch (position) {
            case 'top-right':
                this.anchorPoint = Point.TOP_CENTER;
                this.popoverPoint = Point.LEFT_BOTTOM;
                break;
            case 'top-left':
                this.anchorPoint = Point.TOP_CENTER;
                this.popoverPoint = Point.RIGHT_BOTTOM;
                break;
            case 'bottom-right':
                this.anchorPoint = Point.BOTTOM_CENTER;
                this.popoverPoint = Point.LEFT_TOP;
                break;
            case 'bottom-left':
                this.anchorPoint = Point.BOTTOM_CENTER;
                this.popoverPoint = Point.RIGHT_TOP;
                break;
            case 'right':
                this.anchorPoint = Point.RIGHT_CENTER;
                this.popoverPoint = Point.LEFT_TOP;
                break;
            case 'left':
                this.anchorPoint = Point.LEFT_CENTER;
                this.popoverPoint = Point.RIGHT_TOP;
                break;
            default:
                this.anchorPoint = Point.RIGHT_CENTER;
                this.popoverPoint = Point.LEFT_TOP;
                break;
        }
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    set size(size) {
        // Ugh
        this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.size);
        if (size && SIZES.indexOf(size) > -1) {
            this._size = size;
        }
        else {
            this._size = 'sm';
        }
        // Ugh
        this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.size);
    }
}
ClrTooltipContent.decorators = [
    { type: Component, args: [{
                selector: 'clr-tooltip-content',
                template: `
        <ng-content></ng-content>
    `,
                host: {
                    '[class.tooltip-content]': 'true',
                    // I'm giving up on animation, they did not work before and will not work now.
                    // Too many conflicts with Clarity UI.
                    '[style.opacity]': '1',
                }
            }] }
];
/** @nocollapse */
ClrTooltipContent.ctorParameters = () => [
    { type: Injector },
    { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [POPOVER_HOST_ANCHOR,] }] }
];
ClrTooltipContent.propDecorators = {
    position: [{ type: Input, args: ['clrPosition',] }],
    size: [{ type: Input, args: ['clrSize',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrTooltipTrigger {
    /**
     * @param {?} ifOpenService
     */
    constructor(ifOpenService) {
        this.ifOpenService = ifOpenService;
    }
    /**
     * @return {?}
     */
    showTooltip() {
        this.ifOpenService.open = true;
    }
    /**
     * @return {?}
     */
    hideTooltip() {
        this.ifOpenService.open = false;
    }
}
ClrTooltipTrigger.decorators = [
    { type: Directive, args: [{ selector: '[clrTooltipTrigger]', host: { '[attr.tabindex]': '0', '[class.tooltip-trigger]': 'true' } },] }
];
/** @nocollapse */
ClrTooltipTrigger.ctorParameters = () => [
    { type: IfOpenService }
];
ClrTooltipTrigger.propDecorators = {
    showTooltip: [{ type: HostListener, args: ['mouseenter',] }, { type: HostListener, args: ['focus',] }],
    hideTooltip: [{ type: HostListener, args: ['mouseleave',] }, { type: HostListener, args: ['blur',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_TOOLTIP_DIRECTIVES = [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent];
class ClrTooltipModule {
}
ClrTooltipModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrCommonPopoverModule],
                declarations: [CLR_TOOLTIP_DIRECTIVES],
                exports: [CLR_TOOLTIP_DIRECTIVES, ClrConditionalModule, ClrIconModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrPopoverModule {
}
ClrPopoverModule.decorators = [
    { type: NgModule, args: [{ exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ButtonHubService {
    constructor() {
        this.buttonsReady = false;
        this._previousBtnClicked = new Subject();
        this._nextBtnClicked = new Subject();
        this._dangerBtnClicked = new Subject();
        this._cancelBtnClicked = new Subject();
        this._finishBtnClicked = new Subject();
        this._customBtnClicked = new Subject();
    }
    /**
     * @return {?}
     */
    get previousBtnClicked() {
        return this._previousBtnClicked.asObservable();
    }
    /**
     * @return {?}
     */
    get nextBtnClicked() {
        return this._nextBtnClicked.asObservable();
    }
    /**
     * @return {?}
     */
    get dangerBtnClicked() {
        return this._dangerBtnClicked.asObservable();
    }
    /**
     * @return {?}
     */
    get cancelBtnClicked() {
        return this._cancelBtnClicked.asObservable();
    }
    /**
     * @return {?}
     */
    get finishBtnClicked() {
        return this._finishBtnClicked.asObservable();
    }
    /**
     * @return {?}
     */
    get customBtnClicked() {
        return this._customBtnClicked.asObservable();
    }
    /**
     * @param {?} buttonType
     * @return {?}
     */
    buttonClicked(buttonType) {
        if ('previous' === buttonType) {
            this._previousBtnClicked.next();
        }
        else if ('next' === buttonType) {
            this._nextBtnClicked.next();
        }
        else if ('finish' === buttonType) {
            this._finishBtnClicked.next();
        }
        else if ('danger' === buttonType) {
            this._dangerBtnClicked.next();
        }
        else if ('cancel' === buttonType) {
            this._cancelBtnClicked.next();
        }
        else {
            this._customBtnClicked.next(buttonType);
        }
    }
}
ButtonHubService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * PageCollectionService manages the collection of pages assigned to the wizard and offers
 * a number of functions useful across the wizards providers and subcomponents -- all related
 * to essentially lookups on the collection of pages.
 *
 * The easiest way to access PageCollectionService is via the wizard. The
 * following example would allow you to access your instance of the wizard from your host
 * component and thereby access the page collection via YourHostComponent.wizard.pageCollection.
 *
 * \@example
 * <clr-wizard #wizard ...>
 *
 * \@example
 * export class YourHostComponent {
 * \@ViewChild("wizard") wizard: Wizard;
 *   ...
 * }
 *
 * The heart of the page collection is the query list of pages, which it is assigned as a
 * reference to the Wizard.pages QueryList when the wizard is created.
 *
 */
class PageCollectionService {
    constructor() {
        // used by the navService to navigate back to first possible step after
        // pages are reset
        /**
         *
         * \@memberof PageCollectionService
         */
        this._pagesReset = new Subject();
    }
    /**
     * Converts the PageCollectionService.pages QueryList to an array and returns it.
     *
     * Useful for many instances when you would prefer a QueryList to act like an array.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    get pagesAsArray() {
        return this.pages ? this.pages.toArray() : [];
    }
    /**
     * Returns the length of the pages query list.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    get pagesCount() {
        return this.pages ? this.pages.length : 0;
    }
    /**
     * Returns the next-to-last page in the query list of pages. Operates as a getter
     * so that it isn't working with stale data.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    get penultimatePage() {
        /** @type {?} */
        const pageCount = this.pagesCount;
        if (pageCount < 2) {
            return;
        }
        return this.pagesAsArray[pageCount - 2];
    }
    /**
     * Returns the last page in the query list of pages. Operates as a getter
     * so that it isn't working with stale data.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    get lastPage() {
        /** @type {?} */
        const pageCount = this.pagesCount;
        if (pageCount < 1) {
            return;
        }
        return this.pagesAsArray[pageCount - 1];
    }
    /**
     * Returns the first page in the query list of pages. Operates as a getter
     * so that it isn't working with stale data.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    get firstPage() {
        if (!this.pagesCount) {
            return;
        }
        return this.pagesAsArray[0];
    }
    /**
     * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
     * object that matches the ID passed. Note that IDs here should include the prefix
     * "clr-wizard-page-".
     *
     * Returns the next-to-last page in the query list of pages. Operates as a getter
     * so that it isn't working with stale data.
     *
     * \@memberof PageCollectionService
     * @param {?} id
     * @return {?}
     */
    getPageById(id) {
        /** @type {?} */
        const foundPages = this.pages.filter((page) => id === page.id);
        return this.checkResults(foundPages, id);
    }
    /**
     * Accepts s number as a parameter and treats that number as the index of the page
     * you're looking for in the collection of pages. Returns a  wizard page object.
     *
     * \@memberof PageCollectionService
     * @param {?} index
     * @return {?}
     */
    getPageByIndex(index) {
        /** @type {?} */
        const pageCount = this.pagesCount;
        /** @type {?} */
        const pagesLastIndex = pageCount > 1 ? pageCount - 1 : 0;
        if (index < 0) {
            throw new Error('Cannot retrieve page with index of ' + index);
        }
        if (index > pagesLastIndex) {
            throw new Error('Page index is greater than length of pages array.');
        }
        return this.pagesAsArray[index];
    }
    /**
     * Takes a wizard page object as a parameter and returns its index in the
     * collection of pages.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    getPageIndex(page) {
        /** @type {?} */
        const index = this.pagesAsArray.indexOf(page);
        if (index < 0) {
            throw new Error('Requested page cannot be found in collection of pages.');
        }
        return index;
    }
    /**
     * Consolidates guard logic that prevents a couple of unfortunate edge cases with
     * look ups on the collection of pages.
     *
     * \@memberof PageCollectionService
     * @param {?} results
     * @param {?} requestedPageId
     * @return {?}
     */
    checkResults(results, requestedPageId) {
        /** @type {?} */
        const foundPagesCount = results.length || 0;
        if (foundPagesCount > 1) {
            throw new Error('More than one page has the requested id ' + requestedPageId + '.');
        }
        else if (foundPagesCount < 1) {
            throw new Error('No page can be found with the id ' + requestedPageId + '.');
        }
        else {
            return results[0];
        }
    }
    /**
     * Accepts two numeric indexes and returns an array of wizard page objects that include
     * all wizard pages in the page collection from the first index to the second.
     *
     * \@memberof PageCollectionService
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    pageRange(start, end) {
        /** @type {?} */
        let pages = [];
        if (start < 0 || end < 0) {
            return [];
        }
        if (start === null || typeof start === undefined || isNaN(start)) {
            return [];
        }
        if (end === null || typeof end === undefined || isNaN(end)) {
            return [];
        }
        if (end > this.pagesCount) {
            end = this.pagesCount;
        }
        pages = this.pagesAsArray;
        if (end - start === 0) {
            // just return the one page they want
            return [this.getPageByIndex(start)];
        }
        // slice end does not include item referenced by end index, which is weird for users
        // incrementing end index here to correct that so users and other methods
        // don't have to think about it
        end = end + 1;
        // slice does not return the last one in the range but it does include the first one
        // does not modify original array
        return pages.slice(start, end);
    }
    /**
     * Accepts two wizard page objects and returns those page objects with all other page
     * objects between them in the page collection. It doesn't care which page is ahead of the
     * other in the parameters. It will be smart enough to figure that out  on its own.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @param {?} otherPage
     * @return {?}
     */
    getPageRangeFromPages(page, otherPage) {
        /** @type {?} */
        const pageIndex = this.getPageIndex(page);
        /** @type {?} */
        const otherPageIndex = this.getPageIndex(otherPage);
        /** @type {?} */
        let startIndex;
        /** @type {?} */
        let endIndex;
        if (pageIndex <= otherPageIndex) {
            startIndex = pageIndex;
            endIndex = otherPageIndex;
        }
        else {
            startIndex = otherPageIndex;
            endIndex = pageIndex;
        }
        return this.pageRange(startIndex, endIndex);
    }
    /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately before it in the page collection. Returns null if there is
     * no page before the page it is passed.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    getPreviousPage(page) {
        /** @type {?} */
        const myPageIndex = this.getPageIndex(page);
        /** @type {?} */
        const previousPageIndex = myPageIndex - 1;
        if (previousPageIndex < 0) {
            return null;
        }
        return this.getPageByIndex(previousPageIndex);
    }
    /**
     * Accepts a wizard page object as a parameter and returns a Boolean that says if
     * the page you sent it is complete.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    previousPageIsCompleted(page) {
        /** @type {?} */
        let previousPage;
        if (!page) {
            return false;
        }
        previousPage = this.getPreviousPage(page);
        if (null === previousPage) {
            // page is the first page. no previous page.
            return true;
        }
        return previousPage.completed;
    }
    /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately after it in the page collection. Returns null if there is
     * no page after the page it is passed.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    getNextPage(page) {
        /** @type {?} */
        const myPageIndex = this.getPageIndex(page);
        /** @type {?} */
        const nextPageIndex = myPageIndex + 1;
        if (nextPageIndex >= this.pagesAsArray.length) {
            return null;
        }
        return this.getPageByIndex(nextPageIndex);
    }
    /**
     * Takes a wizard page object as a parameter and generates a step item id from the
     * page ID. Returns the generated step item ID as a string.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    getStepItemIdForPage(page) {
        /** @type {?} */
        const pageId = page.id;
        /** @type {?} */
        const pageIdParts = pageId.split('-').reverse();
        pageIdParts[1] = 'step';
        return pageIdParts.reverse().join('-');
    }
    /**
     * Generally only used internally to mark that a specific page has been "committed".
     * This involves marking the page complete and firing the ClrWizardPage.onCommit
     * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
     * mark completed as a parameter.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    commitPage(page) {
        /** @type {?} */
        const pageHasOverrides = page.stopNext || page.preventDefault;
        page.completed = true;
        if (!pageHasOverrides) {
            // prevent loop of event emission; alternate flows work off
            // of event emitters this is how they break that cycle.
            page.onCommit.emit(page.id);
        }
    }
    /**
     * An observable that the navigation service listens to in order to know when
     * the page collection completed states have been reset to false so that way it
     * can also reset the navigation to make the first page in the page collection
     * current/active.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    get pagesReset() {
        return this._pagesReset.asObservable();
    }
    /**
     * Sets all completed states of the pages in the page collection to false and
     * notifies the navigation service to likewise reset the navigation.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    reset() {
        this.pagesAsArray.forEach((page) => {
            page.completed = false;
        });
        this._pagesReset.next(true);
    }
    /**
     * Rolls through all the pages in the page collection to make sure there are no
     * incomplete pages sandwiched between completed pages in the workflow. Identifies
     * the first incomplete page index and sets all pages behind it to a completed
     * state of false.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    updateCompletedStates() {
        /** @type {?} */
        const firstIncompleteIndex = this.findFirstIncompletePageIndex();
        if (firstIncompleteIndex === this.pagesAsArray.length - 1) {
            // all complete no need to do anything
            return;
        }
        this.pagesAsArray.forEach((page, index) => {
            if (index > firstIncompleteIndex) {
                page.completed = false;
            }
        });
    }
    /**
     * Retrieves the index of the first incomplete page in the page collection.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    findFirstIncompletePageIndex() {
        /** @type {?} */
        let returnIndex = null;
        this.pagesAsArray.forEach((page, index) => {
            if (null === returnIndex && false === page.completed) {
                returnIndex = index;
            }
        });
        // fallthrough, all completed, return last page
        if (null === returnIndex) {
            returnIndex = this.pagesCount - 1;
        }
        return returnIndex;
    }
    /**
     * @return {?}
     */
    findFirstIncompletePage() {
        /** @type {?} */
        const myIncompleteIndex = this.findFirstIncompletePageIndex();
        return this.pagesAsArray[myIncompleteIndex];
    }
}
PageCollectionService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Performs navigation functions for a wizard and manages the current page. Presented as a
 * separate service to encapsulate the behavior of navigating and completing the wizard so
 * that it can be shared across the wizard and its sub-components.
 *
 * The easiest way to access the navigation service is there a reference on your wizard. The
 * Following example would allow you to access your instance of the wizard from your host
 * component and thereby access the navigation service via YourHostComponent.wizard.navService.
 *
 * \@example
 * <clr-wizard #wizard ...>
 *
 * \@example
 * export class YourHostComponent {
 * \@ViewChild("wizard") wizard: Wizard;
 *   ...
 * }
 *
 */
class WizardNavigationService {
    /**
     * Creates an instance of WizardNavigationService. Also sets up subscriptions
     * that listen to the button service to determine when a button has been clicked
     * in the wizard. Is also responsible for taking action when the page collection
     * requests that navigation be reset to its pristine state.
     *
     * \@memberof WizardNavigationService
     * @param {?} pageCollection
     * @param {?} buttonService
     */
    constructor(pageCollection, buttonService) {
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        /**
         *
         * \@memberof WizardNavigationService
         */
        this._currentChanged = new Subject();
        /**
         * A Boolean flag used by the ClrWizardPage to avoid a race condition when pages are
         * loading and there is no current page defined.
         *
         * \@memberof WizardNavigationService
         */
        this.navServiceLoaded = false;
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.forceForward (clrWizardForceForwardNavigation) input. When true,
         * navigating backwards in the stepnav menu will reset any skipped pages' completed
         * state to false.
         *
         * This is useful when a wizard executes validation on a page-by-page basis when
         * the next button is clicked.
         *
         * \@memberof WizardNavigationService
         */
        this.forceForwardNavigation = false;
        /**
         * \@memberof WizardNavigationService
         */
        this._movedToNextPage = new Subject();
        /**
         * \@memberof WizardNavigationService
         */
        this._wizardFinished = new Subject();
        /**
         * \@memberof WizardNavigationService
         */
        this._movedToPreviousPage = new Subject();
        /**
         * \@memberof WizardNavigationService
         */
        this._cancelWizard = new Subject();
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.stopCancel (clrWizardPreventDefaultCancel) input. When true, the cancel
         * routine is subverted and must be reinstated in the host component calling Wizard.close()
         * at some point.
         *
         * \@memberof WizardNavigationService
         */
        this.wizardHasAltCancel = false;
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.stopNext (clrWizardPreventDefaultNext) input. When true, the next and finish
         * routines are subverted and must be reinstated in the host component calling Wizard.next(),
         * Wizard.forceNext(), Wizard.finish(), or Wizard.forceFinish().
         *
         * \@memberof WizardNavigationService
         */
        this.wizardHasAltNext = false;
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.stopNavigation (clrWizardPreventNavigation) input. When true, all
         * navigational elements in the wizard are disabled.
         *
         * This is intended to freeze the wizard in place. Events are not fired so this is
         * not a way to implement alternate functionality for navigation.
         *
         * \@memberof WizardNavigationService
         */
        this.wizardStopNavigation = false;
        /**
         * A boolean flag shared with the stepnav items that prevents user clicks on
         * stepnav items from navigating the wizard.
         *
         * \@memberof WizardNavigationService
         */
        this.wizardDisableStepnav = false;
        this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(() => {
            /** @type {?} */
            const currentPage = this.currentPage;
            if (this.currentPageIsFirst || currentPage.previousStepDisabled) {
                return;
            }
            currentPage.previousButtonClicked.emit(currentPage);
            if (!currentPage.preventDefault) {
                this.previous();
            }
        });
        this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(() => {
            this.checkAndCommitCurrentPage('next');
        });
        this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(() => {
            this.checkAndCommitCurrentPage('danger');
        });
        this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(() => {
            this.checkAndCommitCurrentPage('finish');
        });
        this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe((type) => {
            if (!this.wizardStopNavigation) {
                this.currentPage.customButtonClicked.emit(type);
            }
        });
        this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(() => {
            if (this.wizardStopNavigation) {
                return;
            }
            if (this.currentPage.preventDefault) {
                this.currentPage.pageOnCancel.emit(this.currentPage);
            }
            else {
                this.cancel();
            }
        });
        this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(() => {
            this.setFirstPageCurrent();
        });
    }
    /**
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    ngOnDestroy() {
        this.previousButtonSubscription.unsubscribe();
        this.nextButtonSubscription.unsubscribe();
        this.dangerButtonSubscription.unsubscribe();
        this.finishButtonSubscription.unsubscribe();
        this.customButtonSubscription.unsubscribe();
        this.cancelButtonSubscription.unsubscribe();
        this.pagesResetSubscription.unsubscribe();
    }
    /**
     * An Observable that is predominantly used amongst the subcomponents and services
     * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
     * (clrWizardPageOnLoad) output instead of this Observable.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get currentPageChanged() {
        // TODO: MAKE SURE EXTERNAL OUTPUTS SAY 'CHANGE' NOT 'CHANGED'
        // A BREAKING CHANGE SO AWAITING MINOR RELEASE
        return this._currentChanged.asObservable();
    }
    /**
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get currentPageTitle() {
        // when the querylist of pages is empty. this is the first place it fails...
        if (!this.currentPage) {
            return null;
        }
        return this.currentPage.title;
    }
    /**
     * Returns a Boolean that tells you whether or not the current page is the first
     * page in the Wizard.
     *
     * This is helpful for determining whether a page is navigable.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get currentPageIsFirst() {
        return this.pageCollection.firstPage === this.currentPage;
    }
    /**
     * Returns a Boolean that tells you whether or not the current page is the
     * last page in the Wizard.
     *
     * This is used to determine which buttons should display in the wizard footer.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get currentPageIsLast() {
        return this.pageCollection.lastPage === this.currentPage;
    }
    /**
     * Returns the ClrWizardPage object of the current page or null.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get currentPage() {
        if (!this._currentPage) {
            return null;
        }
        return this._currentPage;
    }
    /**
     * Accepts a ClrWizardPage object, since that object to be the current/active
     * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
     * event for that page.
     *
     * Note that all of this work is bypassed if the ClrWizardPage object is already
     * the current page.
     *
     * \@memberof WizardNavigationService
     * @param {?} page
     * @return {?}
     */
    set currentPage(page) {
        if (this._currentPage !== page && !this.wizardStopNavigation) {
            this._currentPage = page;
            page.onLoad.emit(page.id);
            this._currentChanged.next(page);
        }
    }
    /**
     * An observable used internally to alert the wizard that forward navigation
     * has occurred. It is recommended that you use the Wizard.onMoveNext
     * (clrWizardOnNext) output instead of this one.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get movedToNextPage() {
        return this._movedToNextPage.asObservable();
    }
    /**
     * An observable used internally to alert the wizard that the nav service
     * has approved completion of the wizard.
     *
     * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
     * output instead of this one.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get wizardFinished() {
        return this._wizardFinished.asObservable();
    }
    /**
     * This is a public function that can be used to programmatically advance
     * the user to the next page.
     *
     * When invoked, this method will move the wizard to the next page after
     * successful validation. Note that this method goes through all checks
     * and event emissions as if Wizard.next(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.next(false).
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    next() {
        if (this.currentPageIsLast) {
            this.checkAndCommitCurrentPage('finish');
            return;
        }
        this.checkAndCommitCurrentPage('next');
        if (!this.wizardHasAltNext && !this.wizardStopNavigation) {
            this._movedToNextPage.next(true);
        }
    }
    /**
     * Bypasses checks and most event emissions to force a page to navigate forward.
     *
     * Comparable to calling Wizard.next() or Wizard.forceNext().
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    forceNext() {
        /** @type {?} */
        const currentPage = this.currentPage;
        /** @type {?} */
        const nextPage = this.pageCollection.getNextPage(currentPage);
        // catch errant null or undefineds that creep in
        if (!nextPage) {
            throw new Error('The wizard has no next page to go to.');
        }
        if (this.wizardStopNavigation) {
            return;
        }
        if (!currentPage.completed) {
            // this is a state that alt next flows can get themselves in...
            this.pageCollection.commitPage(currentPage);
        }
        this.currentPage = nextPage;
    }
    /**
     * Accepts a button/action type as a parameter. Encapsulates all logic for
     * event emissions, state of the current page, and wizard and page level overrides.
     *
     * Avoid calling this function directly unless you really know what you're doing.
     *
     * \@memberof WizardNavigationService
     * @param {?} buttonType
     * @return {?}
     */
    checkAndCommitCurrentPage(buttonType) {
        /** @type {?} */
        const currentPage = this.currentPage;
        /** @type {?} */
        let iAmTheLastPage;
        /** @type {?} */
        let isNext;
        /** @type {?} */
        let isDanger;
        /** @type {?} */
        let isDangerNext;
        /** @type {?} */
        let isDangerFinish;
        /** @type {?} */
        let isFinish;
        if (!currentPage.readyToComplete || this.wizardStopNavigation) {
            return;
        }
        iAmTheLastPage = this.currentPageIsLast;
        isNext = buttonType === 'next';
        isDanger = buttonType === 'danger';
        isDangerNext = isDanger && !iAmTheLastPage;
        isDangerFinish = isDanger && iAmTheLastPage;
        isFinish = buttonType === 'finish' || isDangerFinish;
        if (isFinish && !iAmTheLastPage) {
            return;
        }
        currentPage.primaryButtonClicked.emit(buttonType);
        if (isFinish) {
            currentPage.finishButtonClicked.emit(currentPage);
        }
        else if (isDanger) {
            currentPage.dangerButtonClicked.emit();
        }
        else if (isNext) {
            currentPage.nextButtonClicked.emit();
        }
        if (currentPage.stopNext || currentPage.preventDefault) {
            currentPage.onCommit.emit(currentPage.id);
            return;
        }
        // order is very important with these emitters!
        if (isFinish) {
            // mark page as complete
            if (!this.wizardHasAltNext) {
                this.pageCollection.commitPage(currentPage);
            }
            this._wizardFinished.next();
        }
        if (this.wizardHasAltNext) {
            this.pageCollection.commitPage(currentPage);
            if (isNext || isDangerNext) {
                this._movedToNextPage.next(true);
            }
            // jump out here, no matter what type we're looking at
            return;
        }
        if (isNext || isDangerNext) {
            this.forceNext();
        }
    }
    /**
     * This is a public function that can be used to programmatically conclude
     * the wizard.
     *
     * When invoked, this method will  initiate the work involved with finalizing
     * and finishing the wizard workflow. Note that this method goes through all
     * checks and event emissions as if Wizard.finish(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.finish(false).
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    finish() {
        this.checkAndCommitCurrentPage('finish');
    }
    /**
     * Notifies the wizard when backwards navigation has occurred via the
     * previous button.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get movedToPreviousPage() {
        return this._movedToPreviousPage.asObservable();
    }
    /**
     * Programmatically moves the wizard to the page before the current page.
     *
     * In most instances, it makes more sense to call Wizard.previous()
     * which does the same thing.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    previous() {
        /** @type {?} */
        let previousPage;
        if (this.currentPageIsFirst || this.wizardStopNavigation) {
            return;
        }
        previousPage = this.pageCollection.getPreviousPage(this.currentPage);
        if (!previousPage) {
            return;
        }
        this._movedToPreviousPage.next(true);
        if (this.forceForwardNavigation) {
            this.currentPage.completed = false;
        }
        this.currentPage = previousPage;
    }
    /**
     * Notifies the wizard that a user is trying to cancel it.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    get notifyWizardCancel() {
        return this._cancelWizard.asObservable();
    }
    /**
     * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
     * this route goes through all checks and event emissions as if a cancel button had
     * been clicked.
     *
     * In most cases, users looking for a hook into the cancel routine are actually looking
     * for a way to close the wizard from their host component because they have prevented
     * the default cancel action.
     *
     * In this instance, it is recommended that you use Wizard.close() to avoid any event
     * emission loop resulting from an event handler calling back into routine that will
     * again evoke the events it handles.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    cancel() {
        this._cancelWizard.next();
    }
    /**
     * Performs all required checks to determine if a user can navigate to a page. Checking at each
     * point if a page is navigable -- completed where the page immediately after the last completed
     * page.
     *
     * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
     * ClrWizardPage object that you want to make the current page.
     *
     * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
     * is the Wizard will mark all pages between the current page and the page you want to navigate
     * to as completed. This is useful for informational wizards that do not require user action,
     * allowing an easy means for users to jump ahead.
     *
     * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
     *
     * \@memberof WizardNavigationService
     * @param {?} pageToGoToOrId
     * @param {?=} lazyComplete
     * @return {?}
     */
    goTo(pageToGoToOrId, lazyComplete = false) {
        /** @type {?} */
        let pageToGoTo;
        /** @type {?} */
        let currentPage;
        /** @type {?} */
        let myPages;
        /** @type {?} */
        let pagesToCheck;
        /** @type {?} */
        let okayToMove = true;
        /** @type {?} */
        let goingForward;
        /** @type {?} */
        let currentPageIndex;
        /** @type {?} */
        let goToPageIndex;
        myPages = this.pageCollection;
        pageToGoTo = typeof pageToGoToOrId === 'string' ? myPages.getPageById(pageToGoToOrId) : pageToGoToOrId;
        currentPage = this.currentPage;
        // no point in going to the current page. you're there already!
        // also hard block on any navigation when stopNavigation is true
        if (pageToGoTo === currentPage || this.wizardStopNavigation) {
            return;
        }
        currentPageIndex = myPages.getPageIndex(currentPage);
        goToPageIndex = myPages.getPageIndex(pageToGoTo);
        goingForward = goToPageIndex > currentPageIndex;
        pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
        okayToMove = lazyComplete || this.canGoTo(pagesToCheck);
        if (!okayToMove) {
            return;
        }
        if (goingForward && lazyComplete) {
            pagesToCheck.forEach((page) => {
                if (page !== pageToGoTo) {
                    page.completed = true;
                }
            });
        }
        else if (!goingForward && this.forceForwardNavigation) {
            pagesToCheck.forEach((page) => {
                page.completed = false;
            });
        }
        this.currentPage = pageToGoTo;
    }
    /**
     * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
     * those objects to determine if navigation can be accomplished.
     *
     * \@memberof WizardNavigationService
     * @param {?} pagesToCheck
     * @return {?}
     */
    canGoTo(pagesToCheck) {
        /** @type {?} */
        let okayToMove = true;
        /** @type {?} */
        const myPages = this.pageCollection;
        // previous page can be important when moving because if it's completed it
        // allows us to move to the page even if it's incomplete...
        /** @type {?} */
        let previousPagePasses;
        if (!pagesToCheck || pagesToCheck.length < 1) {
            return false;
        }
        pagesToCheck.forEach((page) => {
            /** @type {?} */
            let previousPage;
            if (!okayToMove) {
                return;
            }
            if (page.completed) {
                // default is true. just jump out instead of complicating it.
                return;
            }
            // so we know our page is not completed...
            previousPage = myPages.getPageIndex(page) > 0 ? myPages.getPreviousPage(page) : null;
            previousPagePasses = previousPage === null || previousPage.completed === true;
            // we are false if not the current page AND previous page is not completed
            // (but must have a previous page)
            if (!page.current && !previousPagePasses) {
                okayToMove = false;
            }
            // falls through to true as default
        });
        return okayToMove;
    }
    /**
     * Looks through the collection of pages to find the first one that is incomplete
     * and makes that page the current/active page.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    setLastEnabledPageCurrent() {
        /** @type {?} */
        const allPages = this.pageCollection.pagesAsArray;
        /** @type {?} */
        let lastCompletedPageIndex = null;
        allPages.forEach((page, index) => {
            if (page.completed) {
                lastCompletedPageIndex = index;
            }
        });
        if (lastCompletedPageIndex === null) {
            // always is at least the first item...
            lastCompletedPageIndex = 0;
        }
        else if (lastCompletedPageIndex + 1 < allPages.length) {
            lastCompletedPageIndex = lastCompletedPageIndex + 1;
        }
        this.currentPage = allPages[lastCompletedPageIndex];
    }
    /**
     * Finds the first page in the collection of pages and makes that page the
     * current/active page.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    setFirstPageCurrent() {
        this.currentPage = this.pageCollection.pagesAsArray[0];
    }
    /**
     * Updates the stepnav on the left side of the wizard when pages are dynamically
     * added or removed from the collection of pages.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    updateNavigation() {
        /** @type {?} */
        let toSetCurrent;
        /** @type {?} */
        let currentPageRemoved;
        this.pageCollection.updateCompletedStates();
        currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
        if (currentPageRemoved) {
            toSetCurrent = this.pageCollection.findFirstIncompletePage();
            this.currentPage = toSetCurrent;
        }
    }
}
WizardNavigationService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
WizardNavigationService.ctorParameters = () => [
    { type: PageCollectionService },
    { type: ButtonHubService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class HeaderActionService {
    // this service communicates information about the presence/display of header actions
    // across the wizard
    /**
     * @param {?} navService
     */
    constructor(navService) {
        this.navService = navService;
    }
    /**
     * @return {?}
     */
    get wizardHasHeaderActions() {
        /** @type {?} */
        const wizardHdrActions = this.wizardHeaderActions;
        if (!wizardHdrActions) {
            return false;
        }
        return wizardHdrActions.toArray().length > 0;
    }
    /**
     * @return {?}
     */
    get currentPageHasHeaderActions() {
        return this.navService.currentPage ? this.navService.currentPage.hasHeaderActions : false;
    }
    /**
     * @return {?}
     */
    get showWizardHeaderActions() {
        return !this.currentPageHasHeaderActions && this.wizardHasHeaderActions;
    }
    /**
     * @return {?}
     */
    get displayHeaderActionsWrapper() {
        return this.currentPageHasHeaderActions || this.wizardHasHeaderActions;
    }
}
HeaderActionService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
HeaderActionService.ctorParameters = () => [
    { type: WizardNavigationService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let wizardHeaderActionIndex = 0;
class ClrWizardHeaderAction {
    constructor() {
        // title is explanatory text added to the header action
        this.title = '';
        // If our host has an ID attribute, we use this instead of our index.
        this._id = (wizardHeaderActionIndex++).toString();
        this.disabled = false;
        this.headerActionClicked = new EventEmitter(false);
    }
    /**
     * @return {?}
     */
    get id() {
        return `clr-wizard-header-action-${this._id}`;
    }
    /**
     * @return {?}
     */
    click() {
        if (this.disabled) {
            return;
        }
        // passing the header action id allows users to have one method that
        // routes to many different actions based on the type of header action
        // clicked. this is further aided by users being able to specify ids
        // for their header actions.
        this.headerActionClicked.emit(this._id);
    }
}
ClrWizardHeaderAction.decorators = [
    { type: Component, args: [{
                selector: 'clr-wizard-header-action',
                template: `
        <button 
            type="button"
            class="btn clr-wizard-header-action btn-link"
            [id]="id"
            [class.disabled]="disabled"
            (click)="click()"
            [title]="title">
            <ng-content></ng-content>
        </button>
    `,
                host: { class: 'clr-wizard-header-action-wrapper' }
            }] }
];
ClrWizardHeaderAction.propDecorators = {
    title: [{ type: Input, args: ['title',] }],
    _id: [{ type: Input, args: ['id',] }],
    disabled: [{ type: Input, args: ['clrWizardHeaderActionDisabled',] }],
    headerActionClicked: [{ type: Output, args: ['actionClicked',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrWizardPageButtons {
    /**
     * @param {?} pageButtonsTemplateRef
     */
    constructor(pageButtonsTemplateRef) {
        this.pageButtonsTemplateRef = pageButtonsTemplateRef;
    }
}
ClrWizardPageButtons.decorators = [
    { type: Directive, args: [{ selector: '[clrPageButtons]' },] }
];
/** @nocollapse */
ClrWizardPageButtons.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrWizardPageHeaderActions {
    /**
     * @param {?} pageHeaderActionsTemplateRef
     */
    constructor(pageHeaderActionsTemplateRef) {
        this.pageHeaderActionsTemplateRef = pageHeaderActionsTemplateRef;
    }
}
ClrWizardPageHeaderActions.decorators = [
    { type: Directive, args: [{ selector: '[clrPageHeaderActions]' },] }
];
/** @nocollapse */
ClrWizardPageHeaderActions.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrWizardPageNavTitle {
    /**
     * @param {?} pageNavTitleTemplateRef
     */
    constructor(pageNavTitleTemplateRef) {
        this.pageNavTitleTemplateRef = pageNavTitleTemplateRef;
    }
}
ClrWizardPageNavTitle.decorators = [
    { type: Directive, args: [{ selector: '[clrPageNavTitle]' },] }
];
/** @nocollapse */
ClrWizardPageNavTitle.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrWizardPageTitle {
    /**
     * @param {?} pageTitleTemplateRef
     */
    constructor(pageTitleTemplateRef) {
        this.pageTitleTemplateRef = pageTitleTemplateRef;
    }
}
ClrWizardPageTitle.decorators = [
    { type: Directive, args: [{ selector: '[clrPageTitle]' },] }
];
/** @nocollapse */
ClrWizardPageTitle.ctorParameters = () => [
    { type: TemplateRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
let wizardPageIndex = 0;
/**
 * The ClrWizardPage component is responsible for displaying the content of each step
 * in the wizard workflow.
 *
 * ClrWizardPage component has hooks into the navigation service (ClrWizardPage.navService),
 * page collection (ClrWizardPage.pageCollection), and button service
 * (ClrWizardPage.buttonService). These three providers are shared across the components
 * within each instance of a Wizard.
 *
 */
class ClrWizardPage {
    /**
     * Creates an instance of ClrWizardPage.
     *
     * \@memberof WizardPage
     * @param {?} navService
     * @param {?} pageCollection
     * @param {?} buttonService
     */
    constructor(navService, pageCollection, buttonService) {
        this.navService = navService;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._nextStepDisabled = false;
        /**
         * Emits when the value of ClrWizardPage.nextStepDisabled changes.
         * Should emit the new value of nextStepDisabled.
         *
         * \@memberof WizardPage
         *
         */
        this.nextStepDisabledChange = new EventEmitter();
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._previousStepDisabled = false;
        /**
         * Emits when the value of ClrWizardPage.previousStepDisabled changes.
         * Should emit the new value of previousStepDisabled.
         *
         * \@memberof WizardPage
         *
         */
        this.previousStepDisabledChange = new EventEmitter();
        /**
         * Overrides all actions from the page level, so you can use an alternate function for
         * validation or data-munging with a ClrWizardPage.onCommit (clrWizardPageOnCommit output),
         * ClrWizardPage.onCancel (clrWizardPageOnCancel output), or one
         * of the granular page-level button click event emitters.
         *
         * \@memberof WizardPage
         *
         */
        this.preventDefault = false;
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._stopCancel = false;
        /**
         *
         * \@memberof WizardPage
         *
         */
        this.stopCancelChange = new EventEmitter();
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._stopNext = false;
        /**
         * An event emitter carried over from a legacy version of ClrWizardPage.
         * Fires an event on ClrWizardPage whenever the next or finish buttons
         * are clicked and the page is the current page of the Wizard.
         *
         * Note that this does not automatically emit an event when a custom
         * button is used in place of a next or finish button.
         *
         * \@memberof WizardPage
         *
         */
        this.onCommit = new EventEmitter(false);
        /**
         * Emits an event when ClrWizardPage becomes the current page of the
         * Wizard.
         *
         * \@memberof WizardPage
         *
         */
        this.onLoad = new EventEmitter();
        /**
         * Emits an event when the ClrWizardPage invokes the cancel routine for the wizard.
         *
         * Can be used in conjunction with the ClrWizardPage.stopCancel
         * (clrWizardPagePreventDefaultCancel) or ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) inputs to implement custom cancel
         * functionality at the page level. This is useful if you would like to do
         * validation, save data, or warn users before cancelling the wizard.
         *
         * Note that this requires you to call Wizard.close() from the host component.
         * This constitues a full replacement of the cancel functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.pageOnCancel = new EventEmitter();
        /**
         * Emits an event when the finish button is clicked and the ClrWizardPage is
         * the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom finish
         * functionality at the page level. This is useful if you would like to do
         * validation, save data, or warn users before allowing them to complete
         * the wizard.
         *
         * Note that this requires you to call Wizard.finish() or Wizard.forceFinish()
         * from the host component. This combination creates a full replacement of
         * the finish functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.finishButtonClicked = new EventEmitter();
        /**
         * Emits an event when the previous button is clicked and the ClrWizardPage is
         * the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom backwards
         * navigation at the page level. This is useful if you would like to do
         * validation, save data, or warn users before allowing them to go
         * backwards in the wizard.
         *
         * Note that this requires you to call Wizard.previous()
         * from the host component. This combination creates a full replacement of
         * the backwards navigation functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.previousButtonClicked = new EventEmitter();
        /**
         * Emits an event when the next button is clicked and the ClrWizardPage is
         * the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom forwards
         * navigation at the page level. This is useful if you would like to do
         * validation, save data, or warn users before allowing them to go
         * to the next page in the wizard.
         *
         * Note that this requires you to call Wizard.forceNext() or Wizard.next()
         * from the host component. This combination creates a full replacement of
         * the forward navigation functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.nextButtonClicked = new EventEmitter();
        /**
         * Emits an event when a danger button is clicked and the ClrWizardPage is
         * the wizard's current page. By default, a danger button will act as
         * either a "next" or "finish" button depending on if the ClrWizardPage is the
         * last page or not.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom forwards
         * or finish navigation at the page level when the danger button is clicked.
         * This is useful if you would like to do validation, save data, or warn
         * users before allowing them to go to the next page in the wizard or
         * finish the wizard.
         *
         * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
         * Wizard.forceNext() or Wizard.next() from the host component. This
         * combination creates a full replacement of the forward navigation and
         * finish functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.dangerButtonClicked = new EventEmitter();
        /**
         * Emits an event when a next, finish, or danger button is clicked and the
         * ClrWizardPage is the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom forwards
         * or finish navigation at the page level, regardless of the type of
         * primary button.
         *
         * This is useful if you would like to do validation, save data, or warn
         * users before allowing them to go to the next page in the wizard or
         * finish the wizard.
         *
         * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
         * Wizard.forceNext() or Wizard.next() from the host component. This
         * combination creates a full replacement of the forward navigation and
         * finish functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.primaryButtonClicked = new EventEmitter();
        this.customButtonClicked = new EventEmitter();
        /**
         * An input value that is used internally to generate the ClrWizardPage ID as
         * well as the step nav item ID.
         *
         * Typed as any because it should be able to accept numbers as well as
         * strings. Passing an index for wizard whose pages are created with an
         * ngFor loop is a common use case.
         *
         * \@memberof WizardPage
         *
         */
        this._id = (wizardPageIndex++).toString();
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._complete = false;
    }
    /**
     * A getter that tells whether or not the wizard should be allowed
     * to move to the next page.
     *
     * Useful for in-page validation because it prevents forward navigation
     * and visibly disables the next button.
     *
     * Does not require that you re-implement navigation routines like you
     * would if you were using ClrWizardPage.preventDefault or
     * Wizard.preventDefault.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get nextStepDisabled() {
        return this._nextStepDisabled;
    }
    /**
     * Sets whether the page should allow forward navigation.
     *
     * \@memberof WizardPage
     *
     * @param {?} val
     * @return {?}
     */
    set nextStepDisabled(val) {
        /** @type {?} */
        const valBool = !!val;
        if (valBool !== this._nextStepDisabled) {
            this._nextStepDisabled = valBool;
            this.nextStepDisabledChange.emit(valBool);
        }
    }
    /**
     * A getter that tells whether or not the wizard should be allowed
     * to move to the previous page.
     *
     * Useful for in-page validation because it prevents backward navigation
     * and visibly disables the previous button.
     *
     * Does not require that you re-implement navigation routines like you
     * would if you were using ClrWizardPage.preventDefault or
     * Wizard.preventDefault.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get previousStepDisabled() {
        return this._previousStepDisabled;
    }
    /**
     * Sets whether the page should allow backward navigation.
     *
     * \@memberof WizardPage
     *
     * @param {?} val
     * @return {?}
     */
    set previousStepDisabled(val) {
        /** @type {?} */
        const valBool = !!val;
        if (valBool !== this._previousStepDisabled) {
            this._previousStepDisabled = valBool;
            this.previousStepDisabledChange.emit(valBool);
        }
    }
    /**
     * A getter that retrieves whether the page is preventing the cancel action.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get stopCancel() {
        return this._stopCancel;
    }
    /**
     * Overrides the cancel action from the page level. Allows you to use an
     * alternate function for validation or data-munging before cancelling the
     * wizard when combined with the ClrWizardPage.onCancel
     * (the clrWizardPageOnCancel output).
     *
     * Requires that you manually close the wizard from your host component,
     * usually with a call to Wizard.forceNext() or wizard.next();
     *
     * \@memberof ClrWizardPage
     * @param {?} val
     * @return {?}
     */
    set stopCancel(val) {
        /** @type {?} */
        const valBool = !!val;
        if (valBool !== this._stopCancel) {
            this._stopCancel = valBool;
            this.stopCancelChange.emit(valBool);
        }
    }
    /**
     * A getter that tells you whether the page is preventing the next action.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get stopNext() {
        return this._stopNext;
    }
    /**
     * Overrides forward navigation from the page level. Allows you to use an
     * alternate function for validation or data-munging before moving the
     * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
     * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
     * (clrWizardPageNext) outputs.
     *
     * Requires that you manually tell the wizard to navigate forward from
     * the hostComponent, usually with a call to Wizard.forceNext() or
     * wizard.next();
     *
     * \@memberof ClrWizardPage
     * @param {?} val
     * @return {?}
     */
    set stopNext(val) {
        /** @type {?} */
        const valBool = !!val;
        if (valBool !== this._stopNext) {
            this._stopNext = valBool;
        }
    }
    /**
     * A read-only getter that generates an ID string for the wizard page from
     * either the value passed to the ClrWizardPage "id" input or a wizard page
     * counter shared across all wizard pages in the application.
     *
     * Note that the value passed into the ID input Will be prefixed with
     * "clr-wizard-page-".
     *
     * \@readonly
     *
     * \@memberof ClrWizardPage
     * @return {?}
     */
    get id() {
        // covers things like null, undefined, false, and empty string
        // while allowing zero to pass
        /** @type {?} */
        const idIsNonZeroFalsy = !this._id && this._id !== 0;
        // in addition to non-zero falsy we also want to make sure _id is not a negative
        // number.
        if (idIsNonZeroFalsy || this._id < 0) {
            // guard here in the event that input becomes undefined or null by accident
            this._id = (wizardPageIndex++).toString();
        }
        return `clr-wizard-page-${this._id}`;
    }
    /**
     * A read-only getter that serves as a convenience for those who would rather
     * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
     * ClrWizardPage.readyToComplete is more logical and declarative.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get readyToComplete() {
        return !this.nextStepDisabled;
    }
    /**
     * A page is marked as completed if it is both readyToComplete and completed,
     * as in the next or finish action has been executed while this page was current.
     *
     * Note there is and open question about how to handle pages that are marked
     * complete but who are no longer readyToComplete. This might indicate an error
     * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
     * and only returns that the page is incomplete.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get completed() {
        return this._complete && this.readyToComplete;
        // FOR V2: UNWIND COMPLETED, READYTOCOMPLETE, AND ERRORS
        // SUCH THAT ERRORS IS ITS OWN INPUT. IF A STEP IS
        // INCOMPLETE AND ERRORED, ERRORED WILL NOT SHOW.
        // FIRST QUESTION: AM I GREY OR COLORED?
        // SECOND QUESTION: AM I GREEN OR RED?
    }
    /**
     * A ClrWizardPage can be manually set to completed using this boolean setter.
     * It is recommended that users rely on the convenience functions in the wizard
     * and navigation service instead of manually setting pages’ completion state.
     *
     * \@memberof ClrWizardPage
     * @param {?} value
     * @return {?}
     */
    set completed(value) {
        this._complete = value;
    }
    /**
     * Checks with the navigation service to see if it is the current page.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get current() {
        return this.navService.currentPage === this;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return !this.enabled;
    }
    /**
     * A read-only getter that returns whether or not the page is navigable
     * in the wizard. A wizard page can be navigated to if it is completed
     * or the page before it is completed.
     *
     * This getter handles the logic for enabling or disabling the links in
     * the step nav on the left Side of the wizard.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get enabled() {
        return this.current || this.completed || this.previousCompleted;
    }
    /**
     * A read-only getter that returns whether or not the page before this
     * ClrWizardPage is completed. This is useful for determining whether or not
     * a page is navigable if it is not current or already completed.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get previousCompleted() {
        /** @type {?} */
        const previousPage = this.pageCollection.getPreviousPage(this);
        if (!previousPage) {
            return true;
        }
        return previousPage.completed;
    }
    /**
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get title() {
        return this.pageTitle.pageTitleTemplateRef;
    }
    /**
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get navTitle() {
        if (this.pageNavTitle) {
            return this.pageNavTitle.pageNavTitleTemplateRef;
        }
        return this.pageTitle.pageTitleTemplateRef;
    }
    /**
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get headerActions() {
        if (!this._headerActions) {
            return;
        }
        return this._headerActions.pageHeaderActionsTemplateRef;
    }
    /**
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get hasHeaderActions() {
        return !!this._headerActions;
    }
    /**
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get buttons() {
        if (!this._buttons) {
            return;
        }
        return this._buttons.pageButtonsTemplateRef;
    }
    /**
     * A read-only getter that returns a boolean that says whether or
     * not the ClrWizardPage includes buttons. Used to determine if the
     * Wizard should override the default button set defined as
     * its direct children.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get hasButtons() {
        return !!this._buttons;
    }
    /**
     * Uses the nav service to make the ClrWizardPage the current page in the
     * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
     * (clrWizardPageOnLoad) output.
     *
     * In most cases, it is better to use the default navigation functions
     * in Wizard.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    makeCurrent() {
        this.navService.currentPage = this;
    }
    /**
     * Links the nav service and establishes the current page if one is not defined.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const navService = this.navService;
        if (!navService.currentPage && !navService.navServiceLoaded) {
            this.makeCurrent();
            this.navService.navServiceLoaded = true;
        }
    }
    /**
     * A read-only getter that returns the id used by the step nav item associated with the page.
     *
     * ClrWizardPage needs this ID string for aria information.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    get stepItemId() {
        return this.pageCollection.getStepItemIdForPage(this);
    }
}
ClrWizardPage.decorators = [
    { type: Component, args: [{
                selector: 'clr-wizard-page',
                template: '<ng-content></ng-content>',
                host: {
                    '[id]': 'id',
                    role: 'tabpanel',
                    '[attr.aria-hidden]': '!current',
                    '[attr.aria-labelledby]': 'stepItemId',
                    '[class.active]': 'current',
                    '[class.clr-wizard-page]': 'true',
                }
            }] }
];
/** @nocollapse */
ClrWizardPage.ctorParameters = () => [
    { type: WizardNavigationService },
    { type: PageCollectionService },
    { type: ButtonHubService }
];
ClrWizardPage.propDecorators = {
    pageTitle: [{ type: ContentChild, args: [ClrWizardPageTitle,] }],
    pageNavTitle: [{ type: ContentChild, args: [ClrWizardPageNavTitle,] }],
    _buttons: [{ type: ContentChild, args: [ClrWizardPageButtons,] }],
    _headerActions: [{ type: ContentChild, args: [ClrWizardPageHeaderActions,] }],
    nextStepDisabled: [{ type: Input, args: ['clrWizardPageNextDisabled',] }],
    nextStepDisabledChange: [{ type: Output, args: ['clrWizardPageNextDisabledChange',] }],
    previousStepDisabled: [{ type: Input, args: ['clrWizardPagePreviousDisabled',] }],
    previousStepDisabledChange: [{ type: Output, args: ['clrWizardPagePreviousDisabledChange',] }],
    preventDefault: [{ type: Input, args: ['clrWizardPagePreventDefault',] }],
    stopCancel: [{ type: Input, args: ['clrWizardPagePreventDefaultCancel',] }],
    stopCancelChange: [{ type: Output, args: ['clrWizardPagePreventDefaultCancelChange',] }],
    stopNext: [{ type: Input, args: ['clrWizardPagePreventDefaultNext',] }],
    onCommit: [{ type: Output, args: ['clrWizardPageOnCommit',] }],
    onLoad: [{ type: Output, args: ['clrWizardPageOnLoad',] }],
    pageOnCancel: [{ type: Output, args: ['clrWizardPageOnCancel',] }],
    finishButtonClicked: [{ type: Output, args: ['clrWizardPageFinish',] }],
    previousButtonClicked: [{ type: Output, args: ['clrWizardPagePrevious',] }],
    nextButtonClicked: [{ type: Output, args: ['clrWizardPageNext',] }],
    dangerButtonClicked: [{ type: Output, args: ['clrWizardPageDanger',] }],
    primaryButtonClicked: [{ type: Output, args: ['clrWizardPagePrimary',] }],
    customButtonClicked: [{ type: Output, args: ['clrWizardPageCustomButton',] }],
    _id: [{ type: Input, args: ['id',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * The Wizard component
 *
 */
class ClrWizard {
    /**
     * Creates an instance of Wizard.
     *
     * \@memberof Wizard
     *
     * @param {?} navService
     * @param {?} pageCollection
     * @param {?} buttonService
     * @param {?} headerActionService
     * @param {?} elementRef
     * @param {?} differs
     */
    constructor(navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
        this.navService = navService;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        this.headerActionService = headerActionService;
        this.elementRef = elementRef;
        /**
         * Contains the size defined by the clrWizardSize input
         *
         * \@memberof Wizard
         *
         */
        this.size = 'xl';
        this._forceForward = false;
        /**
         * Tells the modal part of the wizard whether it should have a close "X"
         * in the top right corner. Set with the clrWizardClosable input.
         *
         * \@memberof Wizard
         *
         */
        this.closable = true;
        /**
         * Toggles open/close of the wizard component. Set using the clrWizardOpen
         * input.
         *
         * \@memberof Wizard
         *
         */
        this._open = false;
        /**
         * Emits when the wizard is opened or closed. Emits through the
         * clrWizardOpenChange output. Works in conjunction with the
         * clrWizardOpen binding so you can use...
         *
         * <clr-wizard [(clrWizardOpen)]="blah"
         * ...or...
         * <clr-wizard [clrWizardOpen]="something" (clrWizardOpenChange)="doSomethign($event)">
         *
         * ...for two-way binding.
         *
         * \@memberof Wizard
         *
         */
        this._openChanged = new EventEmitter(false);
        /**
         * Emits when the wizard is canceled. Can be observed through the clrWizardOnCancel
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultCancel input to create
         * wizard-level custom cancel routines.
         *
         * \@memberof Wizard
         *
         */
        this.onCancel = new EventEmitter(false);
        /**
         * Emits when the wizard is completed. Can be observed through the clrWizardOnFinish
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultNext input to create
         * wizard-level custom completion routines.
         *
         * \@memberof Wizard
         *
         */
        this.wizardFinished = new EventEmitter(false);
        /**
         * Emits when the wizard is reset. See .reset(). Can be observed through
         * the clrWizardOnReset output.
         *
         * \@memberof Wizard
         *
         */
        this.onReset = new EventEmitter(false);
        /**
         * Emits when the current page has changed. Can be observed through the clrWizardCurrentPageChanged
         * output. This can happen on .next() or .previous().
         * Useful for non-blocking validation.
         *
         * \@memberof Wizard
         *
         */
        this.currentPageChanged = new EventEmitter(false);
        /**
         * Emits when the wizard moves to the next page. Can be observed through the clrWizardOnNext
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultNext input to create
         * wizard-level custom navigation routines, which are useful for validation.
         *
         * \@memberof Wizard
         *
         */
        this.onMoveNext = new EventEmitter(false);
        /**
         * Emits when the wizard moves to the previous page. Can be observed through the
         * clrWizardOnPrevious output.
         *
         * Can be useful for validation.
         *
         * \@memberof Wizard
         *
         */
        this.onMovePrevious = new EventEmitter(false);
        this._stopNext = false;
        this._stopCancel = false;
        this._stopNavigation = false;
        this._disableStepnav = false;
        /**
         * Used only to communicate to the underlying modal that animations are not
         * wanted. Primary use is for the display of static/inline wizards.
         *
         * Set using clrWizardPreventModalAnimation input. But you should never set it.
         *
         * \@memberof Wizard
         *
         */
        this._stopModalAnimations = false;
        this.goNextSubscription = this.navService.movedToNextPage.subscribe(() => {
            this.onMoveNext.emit();
        });
        this.goPreviousSubscription = this.navService.movedToPreviousPage.subscribe(() => {
            this.onMovePrevious.emit();
        });
        this.cancelSubscription = this.navService.notifyWizardCancel.subscribe(() => {
            this.checkAndCancel();
        });
        this.wizardFinishedSubscription = this.navService.wizardFinished.subscribe(() => {
            if (!this.stopNext) {
                this.forceFinish();
            }
            this.wizardFinished.emit();
        });
        this.differ = differs.find([]).create(null);
    }
    /**
     * Resets page completed states when navigating backwards. Can be set using
     * the clrWizardForceForwardNavigation input.
     *
     * \@memberof Wizard
     *
     * @param {?} value
     * @return {?}
     */
    set forceForward(value) {
        this._forceForward = !!value;
        this.navService.forceForwardNavigation = value;
    }
    /**
     * @return {?}
     */
    get forceForward() {
        return this._forceForward;
    }
    /**
     * @param {?} open
     * @return {?}
     */
    set clrWizardOpen(open) {
        if (open) {
            this.buttonService.buttonsReady = true;
        }
        this._open = open;
    }
    /**
     * Prevents ClrWizard from moving to the next page or closing itself on finishing.
     * Set using the clrWizardPreventDefaultNext input.
     *
     * Note that using stopNext will require you to create your own calls to
     * .next() and .finish() in your host component to make the ClrWizard work as
     * expected.
     *
     * Primarily used for validation.
     *
     * \@memberof Wizard
     *
     * @param {?} value
     * @return {?}
     */
    set stopNext(value) {
        this._stopNext = !!value;
        this.navService.wizardHasAltNext = value;
    }
    /**
     * @return {?}
     */
    get stopNext() {
        return this._stopNext;
    }
    /**
     * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
     * Set using the clrWizardPreventDefaultCancel input.
     *
     * Note that using stopCancel will require you to create your own calls to
     * .close() in your host component to make the ClrWizard work as expected.
     *
     * Useful for doing checks or prompts before closing a ClrWizard.
     *
     * \@memberof Wizard
     *
     * @param {?} value
     * @return {?}
     */
    set stopCancel(value) {
        this._stopCancel = !!value;
        this.navService.wizardHasAltCancel = value;
    }
    /**
     * @return {?}
     */
    get stopCancel() {
        return this._stopCancel;
    }
    /**
     * Prevents ClrWizard from performing any form of navigation away from the current
     * page. Set using the clrWizardPreventNavigation input.
     *
     * Note that stopNavigation is meant to freeze the wizard in place, typically
     * during a long validation or background action where you want the wizard to
     * display loading content but not allow the user to execute navigation in
     * the stepnav, close X, or the  back, finish, or next buttons.
     *
     * \@memberof Wizard
     *
     * @param {?} value
     * @return {?}
     */
    set stopNavigation(value) {
        this._stopNavigation = !!value;
        this.navService.wizardStopNavigation = value;
    }
    /**
     * @return {?}
     */
    get stopNavigation() {
        return this._stopNavigation;
    }
    /**
     * Prevents clicks on the links in the stepnav from working.
     *
     * A more granular bypassing of navigation which can be useful when your
     * ClrWizard is in a state of completion and you don't want users to be
     * able to jump backwards and change things.
     *
     * \@memberof Wizard
     *
     * @param {?} value
     * @return {?}
     */
    set disableStepnav(value) {
        this._disableStepnav = !!value;
        this.navService.wizardDisableStepnav = value;
    }
    /**
     * @return {?}
     */
    get disableStepnav() {
        return this._disableStepnav;
    }
    /**
     * @return {?}
     */
    get stopModalAnimations() {
        if (this._stopModalAnimations) {
            return 'true';
        }
        return 'false';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.currentPageSubscription = this.navService.currentPageChanged.subscribe((page) => {
            this.currentPageChanged.emit();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.goNextSubscription) {
            this.goNextSubscription.unsubscribe();
        }
        if (this.goPreviousSubscription) {
            this.goPreviousSubscription.unsubscribe();
        }
        if (this.cancelSubscription) {
            this.cancelSubscription.unsubscribe();
        }
        if (this.currentPageSubscription) {
            this.currentPageSubscription.unsubscribe();
        }
        if (this.wizardFinishedSubscription) {
            this.wizardFinishedSubscription.unsubscribe();
        }
    }
    /**
     * Sets up references that are needed by the providers.
     *
     * \@name ngAfterContentInit
     * \@memberof Wizard
     *
     * @return {?}
     */
    ngAfterContentInit() {
        this.pageCollection.pages = this.pages;
        this.headerActionService.wizardHeaderActions = this.headerActions;
        // Only trigger buttons ready if default is open (inlined)
        if (this._open) {
            this.buttonService.buttonsReady = true;
        }
    }
    /**
     * Used for keeping track of when pages are added or removed from this.pages
     *
     * \@name ngDoCheck
     * \@memberof Wizard
     *
     * @return {?}
     */
    ngDoCheck() {
        /** @type {?} */
        const changes = this.differ.diff(this.pages);
        if (changes) {
            changes.forEachAddedItem((r) => {
                this.navService.updateNavigation();
            });
            changes.forEachRemovedItem((r) => {
                this.navService.updateNavigation();
            });
        }
    }
    /**
     * Convenient property for determining whether a wizard is static/in-line or not.
     *
     * \@name isStatic
     *
     * \@memberof Wizard
     *
     * @return {?}
     */
    get isStatic() {
        return this.elementRef.nativeElement.classList.contains('clr-wizard--inline');
    }
    /**
     * As a getter, current page is a convenient way to retrieve the current page from
     * the WizardNavigationService.
     *
     * As a setter, current page accepts a ClrWizardPage and passes it to WizardNavigationService
     * to be made the current page. currentPage performs checks to make sure it can navigate
     * to the designated page.
     *
     * \@name currentPage
     *
     * \@memberof Wizard
     *
     * @return {?}
     */
    get currentPage() {
        return this.navService.currentPage;
    }
    /**
     * @param {?} page
     * @return {?}
     */
    set currentPage(page) {
        this.navService.goTo(page, true);
    }
    /**
     * Convenient property for determining if the current page is the last page of
     * the wizard.
     *
     * \@name isLast
     *
     * \@memberof Wizard
     *
     * @return {?}
     */
    get isLast() {
        return this.navService.currentPageIsLast;
    }
    /**
     * Convenient property for determining if the current page is the first page of
     * the wizard.
     *
     * \@name isFirst
     *
     * \@memberof Wizard
     *
     * @return {?}
     */
    get isFirst() {
        return this.navService.currentPageIsFirst;
    }
    /**
     * Performs the actions needed to open the wizard. If there is no current
     * page defined, sets the first page in the wizard to be current.
     *
     * \@name open
     * \@memberof ClrWizard
     * @return {?}
     */
    open() {
        this._open = true;
        if (!this.currentPage) {
            this.navService.setFirstPageCurrent();
        }
        // Only render buttons when wizard is opened, to avoid chocolate errors
        this.buttonService.buttonsReady = true;
        this._openChanged.emit(true);
    }
    /**
     * Does the work involved with closing the wizard. Call this directly instead
     * of cancel() to implement alternative cancel functionality.
     *
     * \@name close
     * \@memberof ClrWizard
     * @return {?}
     */
    close() {
        if (this.stopNavigation) {
            return;
        }
        this._open = false;
        this._openChanged.emit(false);
    }
    /**
     * Convenient function that can be used to open and close the wizard. It operates
     * by checking a Boolean parameter. If true, the wizard is opened. If false,
     * it is closed.
     *
     * There is no default value for this parameter, so by default the wizard will
     * close if invoked with no parameter.
     *
     * \@name toggle
     *
     * \@memberof ClrWizard
     * @param {?} value
     * @return {?}
     */
    toggle(value) {
        if (value) {
            this.open();
        }
        else {
            this.close();
        }
    }
    /**
     * Moves the wizard to the previous page.
     *
     * \@name previous
     * \@memberof ClrWizard
     * @return {?}
     */
    previous() {
        this.navService.previous();
    }
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will move to the next page regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * Generally, with alternative navigation, users are supplying their own checks
     * and validation. So there is no point in superseding their business logic
     * with our default behavior.
     *
     * If false, the wizard will execute default checks and emit events as normal.
     * This is useful for custom buttons or programmatic workflows that are not
     * executing the wizards default checks and emissions. It is another way to
     * navigate without having to rewrite the wizard’s default functionality
     * from scratch.
     *
     * By default, next() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * \@name next
     * \@memberof ClrWizard
     * @param {?=} skipChecksAndEmits
     * @return {?}
     */
    next(skipChecksAndEmits = true) {
        if (skipChecksAndEmits) {
            this.forceNext();
        }
        else {
            this.navService.next();
        }
    }
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will  complete and close regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * If false, the wizard will execute default checks and emit events before
     * completing and closing.
     *
     * By default, finish() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * \@name finish
     * \@memberof ClrWizard
     * @param {?=} skipChecksAndEmits
     * @return {?}
     */
    finish(skipChecksAndEmits = true) {
        if (skipChecksAndEmits) {
            this.forceFinish();
        }
        else {
            this.navService.finish();
        }
    }
    /**
     * Does the work of finishing up the wizard and closing it but doesn't do the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.finish(true) or ClrWizard.finish()
     * without a parameter.
     *
     * \@name forceFinish
     * \@memberof ClrWizard
     * @return {?}
     */
    forceFinish() {
        if (this.stopNavigation) {
            return;
        }
        this.close();
    }
    /**
     * Does the work of moving the wizard to the next page without the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.next(true) or ClrWizard.next()
     * without a parameter.
     *
     * \@name forceNext
     * \@memberof ClrWizard
     * @return {?}
     */
    forceNext() {
        this.navService.forceNext();
    }
    /**
     * Initiates the functionality that cancels and closes the wizard.
     *
     * Do not use this for an override of the cancel the functionality
     * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
     * or clrWizardPagePreventDefault because it will initiate the same checks
     * and event emissions that invoked your event handler.
     *
     * Use ClrWizard.close() instead.
     *
     * \@name cancel
     * \@memberof ClrWizard
     * @return {?}
     */
    cancel() {
        this.navService.cancel();
    }
    /**
     * Overrides behavior of the underlying modal to avoid collisions with
     * alternative cancel functionality.
     *
     * In most cases, use ClrWizard.cancel() instead.
     *
     * \@name modalCancel
     * \@memberof ClrWizard
     * @return {?}
     */
    modalCancel() {
        this.checkAndCancel();
    }
    /**
     * Checks for alternative cancel flows defined at the current page or
     * wizard level. Performs a canceled if not. Emits events that initiate
     * the alternative cancel outputs (clrWizardPageOnCancel and
     * clrWizardOnCancel) if so.
     *
     * \@name checkAndCancel
     * \@memberof ClrWizard
     * @return {?}
     */
    checkAndCancel() {
        /** @type {?} */
        const currentPage = this.currentPage;
        /** @type {?} */
        const currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
        if (this.stopNavigation) {
            return;
        }
        currentPage.pageOnCancel.emit();
        if (!currentPageHasOverrides) {
            this.onCancel.emit();
        }
        if (!this.stopCancel && !currentPageHasOverrides) {
            this.close();
        }
    }
    /**
     * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
     * to navigate to the page with that ID. Navigation will invoke the wizard’s default
     * checks and event emissions.
     *
     * Probably less useful than calling directly to ClrWizard.navService.goTo() because the
     * nav service method can accept either a string ID or a page object.
     *
     * The format of the expected ID parameter can be found in the return of the
     * ClrWizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
     * numeric ID or the ID specified for the ClrWizardPage component’s “id” input.
     *
     * \@name goTo
     *
     * \@memberof ClrWizard
     * @param {?} pageId
     * @return {?}
     */
    goTo(pageId) {
        if (!pageId) {
            return;
        }
        this.navService.goTo(pageId);
    }
    /**
     * A convenience function that calls to PageCollectionService.reset() and emits the
     * ClrWizard.onReset event.
     *
     * Reset sets all WizardPages to incomplete and sets the first page in the ClrWizard to
     * be the current page, essentially resetting the wizard navigation.
     *
     * Users would then use the onReset event to reset the data or model in their
     * host component.
     *
     * It could be useful to call a reset without firing the onReset event. To do this,
     * just call ClrWizard.pageCollection.reset() directly.
     *
     * \@name reset
     * \@memberof ClrWizard
     * @return {?}
     */
    reset() {
        this.pageCollection.reset();
        this.onReset.next();
    }
}
ClrWizard.decorators = [
    { type: Component, args: [{
                selector: 'clr-wizard',
                providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
                template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-modal\n    [clrModalOpen]=\"_open\"\n    [clrModalSize]=\"size\"\n    [clrModalClosable]=\"closable\"\n    [clrModalStaticBackdrop]=\"true\"\n    [clrModalSkipAnimation]=\"stopModalAnimations\"\n    [clrModalOverrideScrollService]=\"isStatic\"\n    [clrModalPreventClose]=\"true\"\n    (clrModalAlternateClose)=\"modalCancel()\">\n\n    <nav class=\"modal-nav clr-wizard-stepnav-wrapper\">\n        <h3 class=\"clr-wizard-title\"><ng-content select=\"clr-wizard-title\"></ng-content></h3>\n        <clr-wizard-stepnav></clr-wizard-stepnav>\n    </nav>\n\n    <h3 class=\"modal-title\">\n        <span class=\"modal-title-text\">\n            <ng-template [ngTemplateOutlet]=\"navService.currentPageTitle\"></ng-template>\n        </span>\n\n        <div class=\"modal-header-actions-wrapper\" *ngIf=\"headerActionService.displayHeaderActionsWrapper\">\n            <div *ngIf=\"headerActionService.showWizardHeaderActions\">\n                <ng-content select=\"clr-wizard-header-action\"></ng-content>\n            </div>\n            <div *ngIf=\"headerActionService.currentPageHasHeaderActions\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.headerActions\"></ng-template>\n            </div>\n        </div>\n    </h3>\n\n    <div class=\"modal-body\">\n        <main clr-wizard-pages-wrapper class=\"clr-wizard-content\">\n            <ng-content></ng-content>\n        </main>\n    </div>\n    <div class=\"modal-footer clr-wizard-footer\">\n        <div class=\"clr-wizard-footer-buttons\">\n            <div *ngIf=\"navService.currentPage && !navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-content select=\"clr-wizard-button\"></ng-content>\n            </div>\n            <div *ngIf=\"navService.currentPage && navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.buttons\"></ng-template>\n            </div>\n        </div>\n    </div>\n</clr-modal>\n",
                host: {
                    '[class.clr-wizard]': 'true',
                    '[class.wizard-md]': "size == 'md'",
                    '[class.wizard-lg]': "size == 'lg'",
                    '[class.wizard-xl]': "size == 'xl'",
                    '[class.lastPage]': 'navService.currentPageIsLast',
                }
            }] }
];
/** @nocollapse */
ClrWizard.ctorParameters = () => [
    { type: WizardNavigationService },
    { type: PageCollectionService },
    { type: ButtonHubService },
    { type: HeaderActionService },
    { type: ElementRef },
    { type: IterableDiffers }
];
ClrWizard.propDecorators = {
    size: [{ type: Input, args: ['clrWizardSize',] }],
    forceForward: [{ type: Input, args: ['clrWizardForceForwardNavigation',] }],
    closable: [{ type: Input, args: ['clrWizardClosable',] }],
    clrWizardOpen: [{ type: Input, args: ['clrWizardOpen',] }],
    _openChanged: [{ type: Output, args: ['clrWizardOpenChange',] }],
    onCancel: [{ type: Output, args: ['clrWizardOnCancel',] }],
    wizardFinished: [{ type: Output, args: ['clrWizardOnFinish',] }],
    onReset: [{ type: Output, args: ['clrWizardOnReset',] }],
    pages: [{ type: ContentChildren, args: [ClrWizardPage,] }],
    headerActions: [{ type: ContentChildren, args: [ClrWizardHeaderAction,] }],
    currentPageChanged: [{ type: Output, args: ['clrWizardCurrentPageChanged',] }],
    onMoveNext: [{ type: Output, args: ['clrWizardOnNext',] }],
    onMovePrevious: [{ type: Output, args: ['clrWizardOnPrevious',] }],
    stopNext: [{ type: Input, args: ['clrWizardPreventDefaultNext',] }],
    stopCancel: [{ type: Input, args: ['clrWizardPreventDefaultCancel',] }],
    stopNavigation: [{ type: Input, args: ['clrWizardPreventNavigation',] }],
    disableStepnav: [{ type: Input, args: ['clrWizardDisableStepnav',] }],
    _stopModalAnimations: [{ type: Input, args: ['clrWizardPreventModalAnimation',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const DEFAULT_BUTTON_TYPES = {
    cancel: 'cancel',
    previous: 'previous',
    next: 'next',
    finish: 'finish',
    danger: 'danger',
};
/** @type {?} */
const CUSTOM_BUTTON_TYPES = {
    cancel: 'custom-cancel',
    previous: 'custom-previous',
    next: 'custom-next',
    finish: 'custom-finish',
    danger: 'custom-danger',
};
class ClrWizardButton {
    /**
     * @param {?} navService
     * @param {?} buttonService
     */
    constructor(navService, buttonService) {
        this.navService = navService;
        this.buttonService = buttonService;
        this.type = '';
        this.disabled = false;
        this.hidden = false;
        // EventEmitter which is emitted when a button is clicked.
        this.wasClicked = new EventEmitter(false);
    }
    /**
     * @param {?=} valueToCheck
     * @param {?=} typeToLookUp
     * @return {?}
     */
    checkDefaultAndCustomType(valueToCheck = '', typeToLookUp) {
        if (DEFAULT_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
            return true;
        }
        if (CUSTOM_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
            return true;
        }
        return false;
    }
    /**
     * @return {?}
     */
    get isCancel() {
        return this.checkDefaultAndCustomType(this.type, 'cancel');
    }
    /**
     * @return {?}
     */
    get isNext() {
        return this.checkDefaultAndCustomType(this.type, 'next');
    }
    /**
     * @return {?}
     */
    get isPrevious() {
        return this.checkDefaultAndCustomType(this.type, 'previous');
    }
    /**
     * @return {?}
     */
    get isFinish() {
        return this.checkDefaultAndCustomType(this.type, 'finish');
    }
    /**
     * @return {?}
     */
    get isDanger() {
        return this.checkDefaultAndCustomType(this.type, 'danger');
    }
    /**
     * @return {?}
     */
    get isPrimaryAction() {
        return this.isNext || this.isDanger || this.isFinish;
    }
    /**
     * @return {?}
     */
    get _disabledAttribute() {
        if (this.isDisabled) {
            return '';
        }
        return null;
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        // dealing with negatives here. cognitively easier to think of it like this...
        /** @type {?} */
        const disabled = true;
        /** @type {?} */
        const nav = this.navService;
        /** @type {?} */
        const page = this.navService.currentPage;
        // Ensure we don't change the response until buttons are ready to avoid chocolate
        if (!this.buttonService.buttonsReady) {
            return !disabled;
        }
        if (this.disabled || nav.wizardStopNavigation || !page) {
            return true;
        }
        if (this.isCancel) {
            return !disabled;
        }
        if (this.isPrevious && (nav.currentPageIsFirst || page.previousStepDisabled)) {
            return disabled;
        }
        if (this.isDanger && !page.readyToComplete) {
            return disabled;
        }
        if (this.isNext && (nav.currentPageIsLast || !page.readyToComplete)) {
            return disabled;
        }
        if (this.isFinish && (!nav.currentPageIsLast || !page.readyToComplete)) {
            return disabled;
        }
        return !disabled;
    }
    /**
     * @return {?}
     */
    get isHidden() {
        // dealing with negatives here. cognitively easier to think of it like this...
        /** @type {?} */
        const hidden = true;
        /** @type {?} */
        const nav = this.navService;
        // Ensure we don't change the response until buttons are ready to avoid chocolate
        if (!this.buttonService.buttonsReady) {
            return !hidden;
        }
        if (this.hidden) {
            return true;
        }
        if (this.isCancel) {
            return !hidden;
        }
        if (this.isPrevious && nav.currentPageIsFirst) {
            return hidden;
        }
        if (this.isNext && nav.currentPageIsLast) {
            return hidden;
        }
        if (this.isFinish && !nav.currentPageIsLast) {
            return hidden;
        }
        return !hidden;
    }
    /**
     * @return {?}
     */
    click() {
        if (this.isDisabled) {
            return;
        }
        this.wasClicked.emit(this.type);
        this.buttonService.buttonClicked(this.type);
    }
}
ClrWizardButton.decorators = [
    { type: Component, args: [{
                selector: 'clr-wizard-button',
                template: `
        <button
            type="button"
            class="btn clr-wizard-btn"
            [class.btn-link]="isCancel"
            [class.clr-wizard-btn--tertiary]="isCancel"
            [class.btn-outline]="isPrevious"
            [class.clr-wizard-btn--secondary]="isPrevious"
            [class.btn-primary]="isPrimaryAction"
            [class.clr-wizard-btn--primary]="isPrimaryAction"
            [class.btn-success]="isFinish"
            [class.btn-danger]="isDanger"
            [class.disabled]="isDisabled"
            [attr.disabled]="_disabledAttribute"
            (click)="click()">
            <ng-content></ng-content>
        </button>
    `,
                host: { class: 'clr-wizard-btn-wrapper', '[attr.aria-hidden]': 'isHidden' },
                styles: ['[aria-hidden="true"] { display: none; }']
            }] }
];
/** @nocollapse */
ClrWizardButton.ctorParameters = () => [
    { type: WizardNavigationService },
    { type: ButtonHubService }
];
ClrWizardButton.propDecorators = {
    type: [{ type: Input, args: ['type',] }],
    disabled: [{ type: Input, args: ['clrWizardButtonDisabled',] }],
    hidden: [{ type: Input, args: ['clrWizardButtonHidden',] }],
    wasClicked: [{ type: Output, args: ['clrWizardButtonClicked',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrWizardCustomTags {
}
ClrWizardCustomTags.decorators = [
    { type: Directive, args: [{ selector: 'clr-wizard-title, clr-wizard-pagetitle' },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrWizardStepnav {
    /**
     * @param {?} pageService
     */
    constructor(pageService) {
        this.pageService = pageService;
    }
}
ClrWizardStepnav.decorators = [
    { type: Component, args: [{
                selector: 'clr-wizard-stepnav',
                template: `
        <ol class="clr-wizard-stepnav-list" role="tablist">
            <li *ngFor="let page of pageService.pages" clr-wizard-stepnav-item 
            [page]="page" class="clr-wizard-stepnav-item"></li>
        </ol>
    `,
                host: { class: 'clr-wizard-stepnav' }
            }] }
];
/** @nocollapse */
ClrWizardStepnav.ctorParameters = () => [
    { type: PageCollectionService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrWizardStepnavItem {
    /**
     * @param {?} navService
     * @param {?} pageCollection
     */
    constructor(navService, pageCollection) {
        this.navService = navService;
        this.pageCollection = pageCollection;
    }
    /**
     * @return {?}
     */
    pageGuard() {
        if (!this.page) {
            throw new Error('Wizard stepnav item is not associated with a wizard page.');
        }
    }
    /**
     * @return {?}
     */
    get id() {
        this.pageGuard();
        return this.pageCollection.getStepItemIdForPage(this.page);
    }
    /**
     * @return {?}
     */
    get isDisabled() {
        this.pageGuard();
        return this.page.disabled || this.navService.wizardStopNavigation || this.navService.wizardDisableStepnav;
    }
    /**
     * @return {?}
     */
    get isCurrent() {
        this.pageGuard();
        return this.page.current;
    }
    /**
     * @return {?}
     */
    get isComplete() {
        this.pageGuard();
        return this.page.completed;
    }
    /**
     * @return {?}
     */
    get canNavigate() {
        this.pageGuard();
        return this.pageCollection.previousPageIsCompleted(this.page);
    }
    /**
     * @return {?}
     */
    click() {
        this.pageGuard();
        // if we click on our own stepnav or a disabled stepnav, we don't want to do anything
        if (this.isDisabled || this.isCurrent) {
            return;
        }
        this.navService.goTo(this.page);
    }
}
ClrWizardStepnavItem.decorators = [
    { type: Component, args: [{
                selector: '[clr-wizard-stepnav-item]',
                template: `
        <button type="button" class="btn btn-link clr-wizard-stepnav-link" (click)="click()">
            <ng-template [ngTemplateOutlet]="page.navTitle"></ng-template>
        </button>
    `,
                host: {
                    '[id]': 'id',
                    '[attr.aria-selected]': 'isCurrent',
                    '[attr.aria-controls]': 'id',
                    role: 'tab',
                    '[class.clr-nav-link]': 'true',
                    '[class.nav-item]': 'true',
                    '[class.active]': 'isCurrent',
                    '[class.disabled]': 'isDisabled',
                    '[class.no-click]': '!canNavigate',
                    '[class.complete]': 'isComplete',
                }
            }] }
];
/** @nocollapse */
ClrWizardStepnavItem.ctorParameters = () => [
    { type: WizardNavigationService },
    { type: PageCollectionService }
];
ClrWizardStepnavItem.propDecorators = {
    page: [{ type: Input, args: ['page',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_WIZARD_DIRECTIVES = [
    ClrWizard,
    ClrWizardPage,
    ClrWizardStepnav,
    ClrWizardStepnavItem,
    ClrWizardButton,
    ClrWizardHeaderAction,
    ClrWizardCustomTags,
    ClrWizardPageTitle,
    ClrWizardPageNavTitle,
    ClrWizardPageButtons,
    ClrWizardPageHeaderActions,
];
class ClrWizardModule {
}
ClrWizardModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ClrModalModule, ClrAlertModule],
                declarations: [CLR_WIZARD_DIRECTIVES],
                exports: [CLR_WIZARD_DIRECTIVES],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClarityModule {
}
ClarityModule.decorators = [
    { type: NgModule, args: [{
                exports: [
                    ClrEmphasisModule,
                    ClrDataModule,
                    ClrIconModule,
                    ClrModalModule,
                    ClrLoadingModule,
                    ClrIfExpandModule,
                    ClrConditionalModule,
                    ClrFocusTrapModule,
                    ClrButtonModule,
                    ClrFormsModule,
                    ClrLayoutModule,
                    ClrPopoverModule,
                    ClrWizardModule,
                    ClrDragAndDropModule,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Private counter to generate unique IDs for the checkboxes, to bind the labels to them.
 * @type {?}
 */
let latestId = 0;
/**
 * @deprecated ClrCheckbox will be renamed to ClrCheckboxDeprecated in 0.12, and will be replaced with a new
 * implementation in 0.13, so if you import it you will need to update your references.
 */
class ClrCheckboxDeprecated {
    constructor() {
        // If our host has an ID attribute, we use this instead of our index.
        this._id = (latestId++).toString();
        // If host provides an clrAriaLabeledBy input, we apply it to the checkbox
        this.clrAriaLabeledBy = null;
        // If our host has a name attribute, we apply it to the checkbox.
        this.name = null;
        // If the host is disabled we apply it to the checkbox
        this.disabled = false;
        // Support for inline checkboxes, adds the necessary class to the host
        this.inline = false;
        this._checked = false;
        this._indeterminate = false;
        this.indeterminateChange = new EventEmitter(false);
        this.change = new EventEmitter(false);
        /*
             * These callbacks will be given to us through the ControlValueAccessor interface,
             * and we need to call them when the user interacts with the checkbox.
             */
        this.onChangeCallback = (_) => { };
        this.onTouchedCallback = () => { };
    }
    /**
     * @return {?}
     */
    get id() {
        return `clr-checkbox-${this._id}`;
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        if (value !== this._checked) {
            if (this._indeterminate) {
                this.setIndeterminate(false);
            }
            this.setChecked(value);
        }
    }
    /**
     * @return {?}
     */
    get indeterminate() {
        return this._indeterminate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set indeterminate(value) {
        if (this._indeterminate !== value) {
            if (this._checked) {
                this.setChecked(false);
            }
            this.setIndeterminate(value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setIndeterminate(value) {
        this._indeterminate = value;
        this.indeterminateChange.emit(this._indeterminate);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setChecked(value) {
        this._checked = value;
        this.change.emit(this._checked);
    }
    /**
     * @return {?}
     */
    toggle() {
        this.checked = !this.checked;
        this.onChangeCallback(this.checked);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value === null) {
            value = false;
        }
        if (value !== this.checked) {
            this.checked = value;
        }
    }
    /**
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this.onChangeCallback = onChange;
    }
    /**
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    /**
     * @return {?}
     */
    touch() {
        this.onTouchedCallback();
    }
    /**
     * @return {?}
     */
    checkIndeterminateState() {
        if (!this.disabled) {
            this.toggle();
        }
    }
}
ClrCheckboxDeprecated.decorators = [
    { type: Component, args: [{
                selector: 'clr-checkbox',
                template: `
        <!--
            FIXME: We are not subscribed to the change event but the click event here.
            The reason for that is because checkboxes behave differently on IE & Edge.
            https://stackoverflow.com/a/19447939
            
            To fix that, we listen to every click event and then toggle the checkbox manually
            to make it behave the same way across the browsers we support.
            
            This works for cases when users toggle the checkbox using the keyboard too:
            https://stackoverflow.com/questions/27878940/spacebar-triggering-click-event-on-checkbox
        -->
        <input type="checkbox" [attr.aria-labelledby]="clrAriaLabeledBy"
               [id]="id" [name]="name" [checked]="checked"
               [indeterminate]="indeterminate" [disabled]="disabled"
               (blur)="touch()" (click)="checkIndeterminateState()">
        <label [attr.for]="id">
            <ng-content></ng-content>
        </label>
    `,
                host: { '[class.checkbox]': '!inline', '[class.checkbox-inline]': 'inline', '[class.disabled]': 'disabled' },
                /*
                     * This provider lets us declare our checkbox as a ControlValueAccessor,
                     * which allows us to use [(ngModel)] directly on our component,
                     * with all the automatic features wiring that come with it.
                     */
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => ClrCheckboxDeprecated), multi: true }]
            }] }
];
ClrCheckboxDeprecated.propDecorators = {
    _id: [{ type: Input, args: ['id',] }],
    clrAriaLabeledBy: [{ type: Input, args: ['clrAriaLabeledBy',] }],
    name: [{ type: Input, args: ['name',] }],
    disabled: [{ type: Input, args: ['clrDisabled',] }],
    inline: [{ type: Input, args: ['clrInline',] }],
    checked: [{ type: Input, args: ['clrChecked',] }],
    indeterminate: [{ type: Input, args: ['clrIndeterminate',] }],
    indeterminateChange: [{ type: Output, args: ['clrIndeterminateChange',] }],
    change: [{ type: Output, args: ['clrCheckedChange',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const CLR_CHECKBOX_DIRECTIVES = [ClrCheckboxDeprecated];
class ClrCheckboxDeprecatedModule {
}
ClrCheckboxDeprecatedModule.decorators = [
    { type: NgModule, args: [{ imports: [CommonModule], declarations: [CLR_CHECKBOX_DIRECTIVES], exports: [CLR_CHECKBOX_DIRECTIVES] },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ClrFormsDeprecatedModule {
}
ClrFormsDeprecatedModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [ClrCheckboxDeprecatedModule, ClrDatepickerModule],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function collapse() {
    return [
        state('true', style({ height: 0, 'overflow-y': 'hidden' })),
        transition('true => false', [animate('0.2s ease-in-out', style({ height: '*', 'overflow-y': 'hidden' }))]),
        transition('false => true', [style({ height: '*', 'overflow-y': 'hidden' }), animate('0.2s ease-in-out')]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?=} opacity
 * @return {?}
 */
function fade(opacity = 1) {
    return [
        transition('void => *', [style({ opacity: 0 }), animate('0.2s ease-in-out', style({ opacity: opacity }))]),
        transition('* => void', [animate('0.2s ease-in-out', style({ opacity: 0 }))]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} direction
 * @return {?}
 */
function fadeSlide(direction) {
    /** @type {?} */
    let transform = null;
    if (direction === 'up') {
        transform = 'translate(0, 25%)';
    }
    else if (direction === 'down') {
        transform = 'translate(0, -25%)';
    }
    else if (direction === 'left') {
        transform = 'translate(25%, 0)';
    }
    else if (direction === 'right') {
        transform = 'translate(-25%, 0)';
    }
    else {
        throw new Error('Unknown direction ' + direction + ' for slide animation.');
    }
    return [
        transition('void => *', [style({ opacity: 0, transform: transform }), animate('0.2s ease-in-out')]),
        transition('* => void', [animate('0.2s ease-in-out', style({ opacity: 0, transform: transform }))]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} direction
 * @return {?}
 */
function slide(direction) {
    /** @type {?} */
    let transform = null;
    if (direction === 'up') {
        transform = 'translate(0, 25%)';
    }
    else if (direction === 'down') {
        transform = 'translate(0, -25%)';
    }
    else if (direction === 'left') {
        transform = 'translate(25%, 0)';
    }
    else if (direction === 'right') {
        transform = 'translate(-25%, 0)';
    }
    else {
        throw new Error('Unknown direction ' + direction + ' for slide animation.');
    }
    return [
        transition('void => *', [style({ transform: transform }), animate('0.2s ease-in-out')]),
        transition('* => void', [animate('0.2s ease-in-out', style({ transform: transform }))]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { FocusTrapTracker as ÇlrFocusTrapTracker, ClarityModule, ClrButtonModule, ClrButton, ClrButtonGroup, CLR_BUTTON_GROUP_DIRECTIVES, ClrButtonGroupModule, ClrLoadingButton, CLR_LOADING_BUTTON_DIRECTIVES, ClrLoadingButtonModule, ClrDataModule, ClrDatagrid, ClrDatagridActionBar, ClrDatagridActionOverflow, ClrDatagridColumn, ClrDatagridColumnToggle, ClrDatagridHideableColumn, ClrDatagridFilter, ClrDatagridItems, ClrDatagridRow, ClrDatagridRowDetail, ClrDatagridCell, ClrDatagridFooter, ClrDatagridPagination, ClrDatagridPlaceholder, ClrDatagridSortOrder, DatagridStringFilter, DatagridPropertyStringFilter, DatagridPropertyComparator, CLR_DATAGRID_DIRECTIVES, ClrDatagridModule, ClrTreeNode, CLR_TREE_VIEW_DIRECTIVES, ClrTreeViewModule, ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackInput, ClrStackSelect, CLR_STACK_VIEW_DIRECTIVES, ClrStackViewModule, ClrStackViewCustomTags, ClrEmphasisModule, ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, CLR_ALERT_DIRECTIVES, ClrAlertModule, ClrIfError, ClrControlError, ClrForm, ClrControlHelper, ClrLabel, ClrLayout, ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper, ClrCheckboxModule, ClrDateContainer, ClrDateInput, ClrDatepickerViewManager, ClrDaypicker, ClrMonthpicker, ClrYearpicker, ClrCalendar, ClrDay, CLR_DATEPICKER_DIRECTIVES, ClrDatepickerModule, ClrInput, ClrInputContainer, ClrInputModule, ClrPassword, ToggleServiceProvider, ToggleService, ClrPasswordContainer, ClrPasswordModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper, ClrRadioModule, ClrSelect, ClrSelectContainer, ClrSelectModule, ClrTextarea, ClrTextareaContainer, ClrTextareaModule, ClrFormsModule, ClrCheckboxDeprecated, CLR_CHECKBOX_DIRECTIVES, ClrCheckboxDeprecatedModule, ClrFormsDeprecatedModule, ClrIconCustomTag, CLR_ICON_DIRECTIVES, ClrIconModule, ClrLayoutModule, ClrMainContainer, CLR_LAYOUT_DIRECTIVES, ClrMainContainerModule, MainContainerWillyWonka, NavDetectionOompaLoompa, ClrHeader, ClrNavLevel, CLR_NAVIGATION_DIRECTIVES, ClrNavigationModule, ClrTabs, ClrTab, ClrTabContent, ClrTabOverflowContent, ClrTabLink, CLR_TABS_DIRECTIVES, ClrTabsModule, ClrVerticalNavGroupChildren, ClrVerticalNavGroup, ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavIcon, CLR_VERTICAL_NAV_DIRECTIVES, ClrVerticalNavModule, ClrModal, CLR_MODAL_DIRECTIVES, ClrModalModule, ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem, CLR_MENU_POSITIONS, CLR_DROPDOWN_DIRECTIVES, ClrDropdownModule, ClrPopoverModule, ClrSignpost, ClrSignpostContent, ClrSignpostTrigger, CLR_SIGNPOST_DIRECTIVES, ClrSignpostModule, ClrTooltip, ClrTooltipTrigger, ClrTooltipContent, CLR_TOOLTIP_DIRECTIVES, ClrTooltipModule, collapse, fade, fadeSlide, slide, ClrLoadingState, ClrLoading, LoadingListener, CLR_LOADING_DIRECTIVES, ClrLoadingModule, CONDITIONAL_DIRECTIVES, ClrIfActive, ClrIfOpen, EXPAND_DIRECTIVES, ClrIfExpanded, ClrCommonStrings, ClrDraggable, ClrDroppable, ClrIfDragged, ClrDragHandle, ClrDraggableGhost, ClrDragEvent, CLR_DRAG_AND_DROP_DIRECTIVES, ClrDragAndDropModule, ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, DEFAULT_BUTTON_TYPES, CUSTOM_BUTTON_TYPES, ClrWizardButton, ClrWizardHeaderAction, ClrWizardCustomTags, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions, CLR_WIZARD_DIRECTIVES, ClrWizardModule, ButtonInGroupService as ɵdl, DatagridRowExpandAnimation as ɵdb, ActionableOompaLoompa as ɵcy, DatagridWillyWonka as ɵcw, ExpandableOompaLoompa as ɵda, ClrDatagridColumnToggleButton as ɵci, ClrDatagridColumnToggleTitle as ɵch, DatagridDetailRegisterer as ɵck, ClrDatagridItemsTrackBy as ɵcj, ClrDatagridPageSize as ɵcl, ColumnToggleButtonsService as ɵca, CustomFilter as ɵcf, DisplayModeService as ɵcc, DragDispatcher as ɵce, FiltersProvider as ɵbr, ExpandableRowsCount as ɵbx, HideableColumnService as ɵby, Items as ɵbq, Page as ɵbs, RowActionService as ɵbw, Selection as ɵbp, Sort as ɵbu, StateDebouncer as ɵbt, StateProvider as ɵbz, TableSizeService as ɵcb, DatagridCellRenderer as ɵcv, DatagridColumnResizer as ɵct, DatagridHeaderRenderer as ɵcs, DatagridMainRenderer as ɵcq, domAdapterFactory as ɵcp, DatagridRenderOrganizer as ɵbv, DatagridRowRenderer as ɵcu, DatagridFilterRegistrar as ɵcd, WrappedCell as ɵcm, WrappedColumn as ɵcn, WrappedRow as ɵco, StackControl as ɵdd, AbstractTreeSelection as ɵde, clrTreeSelectionProviderFactory as ɵdg, TreeSelectionService as ɵdf, AlertIconAndTypesService as ɵo, MultiAlertService as ɵp, IfErrorService as ɵt, ControlClassService as ɵba, ControlIdService as ɵq, FocusService as ɵbh, LayoutService as ɵr, MarkControlService as ɵu, IS_NEW_FORMS_LAYOUT as ɵv, IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER as ɵw, NgControlService as ɵs, WrappedFormControl as ɵz, DateFormControlService as ɵbf, DateIOService as ɵbi, DateNavigationService as ɵbe, DatepickerEnabledService as ɵbj, DatepickerFocusService as ɵbl, LocaleHelperService as ɵbg, ViewManagerService as ɵbk, ResponsiveNavigationService as ɵdm, ActiveOompaLoompa as ɵdw, TabsWillyWonka as ɵdv, AriaService as ɵdq, TabsService as ɵdu, TABS_ID as ɵdr, TABS_ID_PROVIDER as ɵdt, tokenFactory$1 as ɵds, VerticalNavGroupRegistrationService as ɵdz, VerticalNavGroupService as ɵea, VerticalNavIconService as ɵdy, VerticalNavService as ɵdx, AbstractPopover as ɵi, POPOVER_DIRECTIVES as ɵb, POPOVER_HOST_ANCHOR as ɵh, PopoverDirectiveOld as ɵc, ClrCommonPopoverModule as ɵa, ROOT_DROPDOWN_PROVIDER as ɵg, RootDropdownService as ɵe, clrRootDropdownFactory as ɵf, OompaLoompa as ɵcz, WillyWonka as ɵcx, ClrConditionalModule as ɵj, IF_ACTIVE_ID as ɵk, IF_ACTIVE_ID_PROVIDER as ɵm, IfActiveService as ɵn, tokenFactory as ɵl, IfOpenService as ɵd, DomAdapter as ɵcr, DragAndDropEventBusService as ɵeg, DragEventListenerService as ɵef, DragHandleRegistrarService as ɵeh, DraggableSnapshotService as ɵei, GlobalDragModeService as ɵej, ClrIfExpandModule as ɵdc, Expand as ɵcg, FocusTrapDirective as ɵbd, ClrFocusTrapModule as ɵbb, FOCUS_TRAP_DIRECTIVES as ɵbc, EmptyAnchor as ɵy, ClrHostWrappingModule as ɵx, UNIQUE_ID as ɵdh, UNIQUE_ID_PROVIDER as ɵdj, uniqueIdFactory as ɵdi, OUSTIDE_CLICK_DIRECTIVES as ɵbn, OutsideClick as ɵbo, ClrOutsideClickModule as ɵbm, ScrollingService as ɵdk, TEMPLATE_REF_DIRECTIVES as ɵdo, TemplateRefContainer as ɵdp, ClrTemplateRefModule as ɵdn, ButtonHubService as ɵed, HeaderActionService as ɵee, PageCollectionService as ɵec, WizardNavigationService as ɵeb };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xyLWFuZ3VsYXIuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BjbHIvYW5ndWxhci9pY29uL2ljb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9pY29uL2ljb24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vcG9wb3Zlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvY29tbW9uL3BvcG92ZXItb2xkLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvY29tbW9uL2luZGV4LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vcG9wb3Zlci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9sb2FkaW5nL2xvYWRpbmcudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vcHJvdmlkZXJzL2J1dHRvbi1pbi1ncm91cC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvYnV0dG9uL2J1dHRvbi1ncm91cC9idXR0b24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2Ryb3Bkb3duL21lbnUtcG9zaXRpb25zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLWdyb3VwL2J1dHRvbi1ncm91cC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tbG9hZGluZy9sb2FkaW5nLWJ1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tbG9hZGluZy9sb2FkaW5nLWJ1dHRvbi5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZW1wdHktYW5jaG9yLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9lcnJvci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9oZWxwZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2xhYmVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9uZXctZm9ybXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvbWFyay1jb250cm9sLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vZm9ybS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9sYXlvdXQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vY29tbW9uLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LXdyYXBwZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3dyYXBwZWQtY29udHJvbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY2hlY2tib3gvY2hlY2tib3gtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY2hlY2tib3gvY2hlY2tib3gubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5kaXJlY3RpdmUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jb25kaXRpb25hbC9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC10cmFja2VyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZm9jdXMtdHJhcC9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9rZXktY29kZXMva2V5LWNvZGVzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci91dGlscy9jb25zdGFudHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3V0aWxzL2RhdGUtdXRpbHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL21vZGVsL2RheS12aWV3Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC9jYWxlbmRhci5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvbW9kZWwvZGF5Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC9jYWxlbmRhci12aWV3Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL2NhbGVuZGFyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL2RhdGUtaW8uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZXBpY2tlci1lbmFibGVkLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL2RhdGUtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlLWlucHV0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vYWJzdHJhY3QtcG9wb3Zlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL3ZpZXctbWFuYWdlci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLXZpZXctbWFuYWdlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvZGF5LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXlwaWNrZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL21vbnRocGlja2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC95ZWFyLXJhbmdlLm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci95ZWFycGlja2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2lucHV0L2lucHV0LWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2lucHV0L2lucHV0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvaW5wdXQvaW5wdXQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcGFzc3dvcmQvcGFzc3dvcmQtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcGFzc3dvcmQvcGFzc3dvcmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9wYXNzd29yZC9wYXNzd29yZC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby13cmFwcGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcmFkaW8vcmFkaW8udHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9zZWxlY3Qvc2VsZWN0LWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3NlbGVjdC9zZWxlY3QudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9zZWxlY3Qvc2VsZWN0Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3RleHRhcmVhL3RleHRhcmVhLWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3RleHRhcmVhL3RleHRhcmVhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvdGV4dGFyZWEvdGV4dGFyZWEubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZm9ybXMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaWYtZXhwYW5kZWQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9vdXRzaWRlLWNsaWNrL291dHNpZGUtY2xpY2sudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9vdXRzaWRlLWNsaWNrL2luZGV4LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvb3V0c2lkZS1jbGljay9vdXRzaWRlLWNsaWNrLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9hbmltYXRpb24taGFjay9yb3ctZXhwYW5kLWFuaW1hdGlvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2N1c3RvbS1maWx0ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9wYWdlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZmlsdGVycy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvdXRpbHMvZGF0YWdyaWQtZmlsdGVyLXJlZ2lzdHJhci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtZmlsdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9idWlsdC1pbi9maWx0ZXJzL2RhdGFncmlkLXN0cmluZy1maWx0ZXItaW1wbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY2hvY29sYXRlL29vbXBhLWxvb21wYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2Nob2NvbGF0ZS93aWxseS13b25rYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvY2hvY29sYXRlL2RhdGFncmlkLXdpbGx5LXdvbmthLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9jaG9jb2xhdGUvYWN0aW9uYWJsZS1vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9jaG9jb2xhdGUvZXhwYW5kYWJsZS1vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL25lc3RlZC1wcm9wZXJ0eS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYnVpbHQtaW4vY29tcGFyYXRvcnMvZGF0YWdyaWQtcHJvcGVydHktY29tcGFyYXRvci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1wcm9wZXJ0eS1zdHJpbmctZmlsdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9lbnVtcy9zb3J0LW9yZGVyLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9kcmFnLWRpc3BhdGNoZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zb3J0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC93cmFwcGVkLWNvbHVtbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvaXRlbXMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWl0ZW1zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1wbGFjZWhvbGRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4udHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LXRyaWdnZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3dyYXBwZWQtY2VsbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY2VsbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZW51bXMvZGlzcGxheS1tb2RlLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2VudW1zL3JlbmRlci1zdGVwLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9yZW5kZXItb3JnYW5pemVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZGlzcGxheS1tb2RlLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zZWxlY3Rpb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3dyYXBwZWQtcm93LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1yb3cudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3N0YXRlLnByb3ZpZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvdGFibGUtc2l6ZS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtYWN0aW9uLWJhci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtYWN0aW9uLW92ZXJmbG93LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLWJ1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS10aXRsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLXRvZ2dsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtZGV0YWlsLXJlZ2lzdGVyZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWZvb3Rlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWl0ZW1zLXRyYWNrYnkudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLXBhZ2Utc2l6ZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtcGFnaW5hdGlvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtcm93LWRldGFpbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL2NvbnN0YW50cy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL2NlbGwtcmVuZGVyZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9jb2x1bW4tcmVzaXplci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL2hlYWRlci1yZW5kZXJlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL25vb3AtZG9tLWFkYXB0ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9tYWluLXJlbmRlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvcm93LXJlbmRlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stYmxvY2sudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stdmlldy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1oZWFkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stY29udHJvbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1pbnB1dC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1zZWxlY3QudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stdmlldy1jdXN0b20tdGFncy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay12aWV3Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L2Fic3RyYWN0LXRyZWUtc2VsZWN0aW9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvcHJvdmlkZXJzL3RyZWUtc2VsZWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy9wcm92aWRlcnMvdHJlZS1zZWxlY3Rpb24ucHJvdmlkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy90cmVlLW5vZGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy90cmVlLXZpZXcubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1ldmVudC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2RyYWctYW5kLWRyb3AtZXZlbnQtYnVzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL3Byb3ZpZGVycy9kcmFnLWV2ZW50LWxpc3RlbmVyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL3Byb3ZpZGVycy9kcmFnZ2FibGUtc25hcHNob3Quc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZ2dhYmxlLWdob3N0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9pZi1kcmFnZ2VkLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9wcm92aWRlcnMvZHJhZy1oYW5kbGUtcmVnaXN0cmFyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL3Byb3ZpZGVycy9nbG9iYWwtZHJhZy1tb2RlLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWdnYWJsZS9kcmFnZ2FibGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2Ryb3BwYWJsZS9kcm9wcGFibGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWctaGFuZGxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnLWFuZC1kcm9wLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vcHJvdmlkZXJzL2Ryb3Bkb3duLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2Ryb3Bkb3duL2Ryb3Bkb3duLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi1pdGVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi1tZW51LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi10cmlnZ2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC91dGlscy9hbGVydC10eXBlcy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2VtcGhhc2lzL2FsZXJ0L3Byb3ZpZGVycy9pY29uLWFuZC10eXBlcy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvcHJvdmlkZXJzL211bHRpLWFsZXJ0LnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9hbGVydC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2VtcGhhc2lzL2FsZXJ0L2FsZXJ0LWl0ZW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9hbGVydHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9hbGVydHMtcGFnZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9hbGVydC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9lbXBoYXNpcy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L3Jlc3BvbnNpdmUtbmF2LWNvZGVzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9yZXNwb25zaXZlLW5hdi1jb250cm9sLW1lc3NhZ2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9tYWluLWNvbnRhaW5lci9tYWluLWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9tYWluLWNvbnRhaW5lci9tYWluLWNvbnRhaW5lci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L2Nob2NvbGF0ZS9tYWluLWNvbnRhaW5lci13aWxseS13b25rYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvY2hvY29sYXRlL25hdi1kZXRlY3Rpb24tb29tcGEtbG9vbXBhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9oZWFkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L25hdi1sZXZlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvbmF2aWdhdGlvbi5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy90ZW1wbGF0ZS1yZWYvdGVtcGxhdGUtcmVmLWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL3RlbXBsYXRlLXJlZi9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL3RlbXBsYXRlLXJlZi90ZW1wbGF0ZS1yZWYubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvY2hvY29sYXRlL3RhYnMtd2lsbHktd29ua2EudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy9jaG9jb2xhdGUvYWN0aXZlLW9vbXBhLWxvb21wYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3Byb3ZpZGVycy9hcmlhLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy9wcm92aWRlcnMvdGFicy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFiLWNvbnRlbnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy90YWJzLWlkLnByb3ZpZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFiLWxpbmsuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFiLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFiLW92ZXJmbG93LWNvbnRlbnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy90YWJzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvdGFicy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtZ3JvdXAtcmVnaXN0cmF0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtaWNvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi9wcm92aWRlcnMvdmVydGljYWwtbmF2LnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1ncm91cC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYtZ3JvdXAudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi1ncm91cC1jaGlsZHJlbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2LWljb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi1saW5rLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L2xheW91dC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9zY3JvbGxpbmcvc2Nyb2xsaW5nLXNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9tb2RhbC9tb2RhbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL21vZGFsL21vZGFsLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvc2lnbnBvc3Qvc2lnbnBvc3QtcG9zaXRpb25zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9zaWducG9zdC9zaWducG9zdC1jb250ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9zaWducG9zdC9zaWducG9zdC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3Rvb2x0aXAvdG9vbHRpcC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvdG9vbHRpcC90b29sdGlwLWNvbnRlbnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3Rvb2x0aXAvdG9vbHRpcC10cmlnZ2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci90b29sdGlwL3Rvb2x0aXAubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9wb3BvdmVyLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC9wcm92aWRlcnMvYnV0dG9uLWh1Yi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC9wcm92aWRlcnMvaGVhZGVyLWFjdGlvbnMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtaGVhZGVyLWFjdGlvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtcGFnZS1idXR0b25zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1wYWdlLWhlYWRlci1hY3Rpb25zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1wYWdlLW5hdnRpdGxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1wYWdlLXRpdGxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1wYWdlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtYnV0dG9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1jdXN0b20tdGFncy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtc3RlcG5hdi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3dpemFyZC93aXphcmQtc3RlcG5hdi1pdGVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9jbHItYW5ndWxhci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy1kZXByZWNhdGVkL2NoZWNrYm94L2NoZWNrYm94LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMtZGVwcmVjYXRlZC9jaGVja2JveC9jaGVja2JveC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy1kZXByZWNhdGVkL2Zvcm1zLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2FuaW1hdGlvbnMvY29sbGFwc2UvY29sbGFwc2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9hbmltYXRpb25zL2ZhZGUvZmFkZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2FuaW1hdGlvbnMvZmFkZS1zbGlkZS9mYWRlLXNsaWRlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvYW5pbWF0aW9ucy9zbGlkZS9zbGlkZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWljb24nIH0pXG5leHBvcnQgY2xhc3MgQ2xySWNvbkN1c3RvbVRhZyB7XG4gIC8vIE5vIGJlaGF2aW9yXG4gIC8vIFRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gXCJkZWNsYXJlXCIgdGhlIHRhZyBpbiBBbmd1bGFyXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWNvbkN1c3RvbVRhZyB9IGZyb20gJy4vaWNvbic7XG5cbmV4cG9ydCBjb25zdCBDTFJfSUNPTl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJJY29uQ3VzdG9tVGFnXTtcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0NMUl9JQ09OX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbQ0xSX0lDT05fRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJJY29uTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qXG4gKiBEbyBOT1QgQW5ndWxhciB0aGlzIHVwLiBJdCBhc3N1bWVzIHdlJ3JlIGluIHRoZSBET00sIHBsYXlzIHdpdGggbmF0aXZlIGVsZW1lbnRzLCAuLi5cbiAqIEl0IGNvdWxkIHBvdGVudGlhbGx5IGJlIHVzZWQgYXMgcGFydCBvZiBAY2xyL3VpIGFzIGEgdmFuaWxsYSBKYXZhc2NyaXB0IGhlbHBlci5cbiAqL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBQb3BvdmVyT3B0aW9ucyB9IGZyb20gJy4vcG9wb3Zlci1vcHRpb25zLmludGVyZmFjZSc7XG5leHBvcnQgZW51bSBQb2ludCB7XG4gIFJJR0hUX0NFTlRFUixcbiAgUklHSFRfVE9QLFxuICBSSUdIVF9CT1RUT00sXG4gIFRPUF9DRU5URVIsXG4gIFRPUF9SSUdIVCxcbiAgVE9QX0xFRlQsXG4gIEJPVFRPTV9DRU5URVIsXG4gIEJPVFRPTV9SSUdIVCxcbiAgQk9UVE9NX0xFRlQsXG4gIExFRlRfQ0VOVEVSLFxuICBMRUZUX1RPUCxcbiAgTEVGVF9CT1RUT00sXG59XG5cbmNvbnN0IFBPU0lUSU9OX1JFTEFUSVZFID0gJ3JlbGF0aXZlJztcbmNvbnN0IFBPU0lUSU9OX0FCU09MVVRFID0gJ2Fic29sdXRlJztcbmNvbnN0IFBPU0lUSU9OX0ZJWEVEID0gJ2ZpeGVkJztcblxuY29uc3QgT1ZFUkZMT1dfU0NST0xMID0gJ3Njcm9sbCc7XG5jb25zdCBPVkVSRkxPV19BVVRPID0gJ2F1dG8nO1xuXG5leHBvcnQgY2xhc3MgUG9wb3ZlciB7XG4gIHByaXZhdGUgX3Njcm9sbDogU3ViamVjdDx2b2lkPjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IGFueSkge1xuICAgIC8vIEJyb3dzZXJzIGRvbid0IGFncmVlIHdpdGggd2hhdCB0byBkbyBpZiBzb21lIG9mIHRoZXNlIGFyZSBub3Qgc3BlY2lmaWVkLCBzbyB3ZSBzZXQgdGhlbSBhbGwgdG8gYmUgc2FmZS5cbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gUE9TSVRJT05fQUJTT0xVVEU7XG4gICAgZWxlbWVudC5zdHlsZS50b3AgPSAwO1xuICAgIGVsZW1lbnQuc3R5bGUuYm90dG9tID0gJ2F1dG8nO1xuICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IDA7XG4gICAgZWxlbWVudC5zdHlsZS5yaWdodCA9ICdhdXRvJztcbiAgfVxuXG4gIC8vIFRPRE86IG5lZWQgYSB3YXkgdG8gYWNjb3VudCBmb3IgcGFyYW1ldGVycyB0aGF0IGNoYW5nZSBkeW5hbWljYWxseSAocG9zaXRpb25pbmcpLlxuICBwdWJsaWMgYW5jaG9yKFxuICAgIGFuY2hvcjogYW55LFxuICAgIGFuY2hvckFsaWduOiBQb2ludCxcbiAgICBwb3BvdmVyQWxpZ246IFBvaW50LFxuICAgIHsgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwLCB1c2VBbmNob3JQYXJlbnQgPSBmYWxzZSB9OiBQb3BvdmVyT3B0aW9ucyA9IHt9XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgLy8gVE9ETzogd2UgYXJlIGFzc3VtaW5nIGhlcmUgdGhhdCB0aGUgcG9wb3ZlciBpcyBpbnNpZGUgb3IgbmV4dCB0byB0aGUgYW5jaG9yLlxuICAgIC8vIFdlJ2QgbmVlZCB0byBnbyB1cCB0aGUgcG9wb3ZlciB0cmVlIHRvbyBvdGhlcndpc2VcblxuICAgIHRoaXMuYWRkU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoYW5jaG9yKTtcbiAgICBpZiAodXNlQW5jaG9yUGFyZW50KSB7XG4gICAgICBhbmNob3IgPSBhbmNob3IucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgLy8gZXhwbGljaXRseSBvdmVycmlkZSBhbmNob3IncyBzdHlsZSB0byBzdGF0aWNcbiAgICBhbmNob3Iuc3R5bGUucG9zaXRpb24gPSAnc3RhdGljJztcblxuICAgIGNvbnN0IGFuY2hvclJlY3QgPSBhbmNob3IuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcG9wb3ZlclJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAvLyBwb3NpdGlvbiBvZiBsZWZ0IHRvcCBjb3JuZXIgb2YgYW5jaG9yICsgdGhlIG9mZnNldFxuICAgIGxldCBsZWZ0RGlmZjogbnVtYmVyID0gYW5jaG9yUmVjdC5sZWZ0IC0gcG9wb3ZlclJlY3QubGVmdCArIG9mZnNldFg7XG4gICAgbGV0IHRvcERpZmY6IG51bWJlciA9IGFuY2hvclJlY3QudG9wIC0gcG9wb3ZlclJlY3QudG9wICsgb2Zmc2V0WTtcblxuICAgIC8vIGZpcnN0LCBhZGp1c3QgcG9zaXRpb25pbmcgYmFzZWQgb24gYW5jaG9yJ3MgYWxpZ24gcG9pbnRcbiAgICBzd2l0Y2ggKGFuY2hvckFsaWduKSB7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfVE9QOlxuICAgICAgY2FzZSBQb2ludC5UT1BfTEVGVDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlRPUF9DRU5URVI6XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX1JJR0hUOlxuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfVE9QOlxuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9CT1RUT006XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fTEVGVDpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX1JJR0hUOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0O1xuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfQk9UVE9NOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0O1xuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cblxuICAgIC8vIHNlY29uZCwgYWRqdXN0IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHBvcG92ZXIncyBhbGlnbiBwb2ludFxuICAgIHN3aXRjaCAocG9wb3ZlckFsaWduKSB7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfVE9QOlxuICAgICAgY2FzZSBQb2ludC5UT1BfTEVGVDpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlRPUF9DRU5URVI6XG4gICAgICAgIGxlZnREaWZmIC09IHBvcG92ZXJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlRPUF9SSUdIVDpcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9UT1A6XG4gICAgICAgIGxlZnREaWZmIC09IHBvcG92ZXJSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9CT1RUT006XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0xFRlQ6XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmIC09IHBvcG92ZXJSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9SSUdIVDpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmIC09IHBvcG92ZXJSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfQk9UVE9NOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIGxlZnREaWZmIC09IHBvcG92ZXJSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuXG4gICAgLy8gVGhpcmQsIGFkanVzdCB3aXRoIHBvcG92ZXIncyBtYXJnaW5zIGJhc2VkIG9uIHRoZSB0d28gYWxpZ24gcG9pbnRzLlxuICAgIC8vIEhlcmUsIHdlIG1ha2UgYW4gYXNzdW1wdGlvbiB0aGF0IHBvcG92ZXIgaXMgcHJpbWFyaWx5IHBvc2l0aW9uZWQgb3V0c2lkZSB0aGVcbiAgICAvLyBhbmNob3Igd2l0aCBtaW5vciBvZmZzZXQuIFdpdGhvdXQgdGhpcyBhc3N1bXB0aW9uLCBpdCdzIGltcG9zc2libGUgdG8gYXBwbHlcbiAgICAvLyB0aGUgcG9wb3ZlcidzIG1hcmdpbnMgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIEZvciBleGFtcGxlLCBhc3N1bWUgdGhhdCBhIHBvcG92ZXJcbiAgICAvLyBhbmQgaXRzIGFuY2hvciBhcmUgZXhhY3RseSB0aGUgc2FtZSBzaXplLiBpZiBhIHBvcG92ZXIgaXMgcG9zaXRpb25lZCBpbnNpZGUgdGhlXG4gICAgLy8gYW5jaG9yICh3aGljaCBpcyB0ZWNobmljYWxseSBwb3NzaWJsZSksIHRoZW4gaXQgYmVjb21lcyBpbXBvc3NpYmxlIHRvIGtub3cgd2hhdCB0byBkb1xuICAgIC8vIGlmIHRoZSBwb3BvdmVyIGhhcyBhIG5vbi16ZXJvIG1hcmdpbiB2YWx1ZSBhbGwgYXJvdW5kIChiZWNhdXNlIGFwcGx5aW5nIHRoZSBtYXJnaW4gaW5cbiAgICAvLyBhbGwgZm91ciBkaXJlY3Rpb25zIHdpbGwgcmVzdWx0IGluIG5vIG1hcmdpbiB2aXN1YWxseSwgd2hpY2ggaXNuJ3Qgd2hhdCB3ZSB3YW50KS5cbiAgICAvLyBUaGVyZWZvcmUsIG91ciBsb2dpYyBtYWtlcyBhc3N1bXB0aW9ucyBhYm91dCBtYXJnaW5zIG9mIGludGVyZXN0IGdpdmVuIHRoZSBwb2ludHMsXG4gICAgLy8gYW5kIG9ubHkgY292ZXJzIHRoZSBjYXNlcyB3aGVyZSBwb3BvdmVyIGlzIG91dHNpZGUgdGhlIGFuY2hvci5cblxuICAgIGNvbnN0IHBvcG92ZXJDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQpO1xuICAgIGNvbnN0IG1hcmdpbkxlZnQgPSBwYXJzZUludChwb3BvdmVyQ29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0LCAxMCk7XG4gICAgY29uc3QgbWFyZ2luUmlnaHQgPSBwYXJzZUludChwb3BvdmVyQ29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCwgMTApO1xuICAgIGNvbnN0IG1hcmdpblRvcCA9IHBhcnNlSW50KHBvcG92ZXJDb21wdXRlZFN0eWxlLm1hcmdpblRvcCwgMTApO1xuICAgIGNvbnN0IG1hcmdpbkJvdHRvbSA9IHBhcnNlSW50KHBvcG92ZXJDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSwgMTApO1xuXG4gICAgc3dpdGNoIChhbmNob3JBbGlnbikge1xuICAgICAgY2FzZSBQb2ludC5MRUZUX1RPUDpcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0xFRlQ6XG4gICAgICBjYXNlIFBvaW50LlRPUF9SSUdIVDpcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfVE9QOlxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5CT1RUT01fUklHSFQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5SSUdIVF9CT1RUT00pIHtcbiAgICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5CT1RUT01fTEVGVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LkxFRlRfQk9UVE9NKSB7XG4gICAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Ub3A7XG4gICAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5UT1BfTEVGVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LkxFRlRfVE9QKSB7XG4gICAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5UT1BfUklHSFQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5SSUdIVF9UT1ApIHtcbiAgICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9CT1RUT006XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9MRUZUOlxuICAgICAgY2FzZSBQb2ludC5CT1RUT01fUklHSFQ6XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX0JPVFRPTTpcbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuQk9UVE9NX0xFRlQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5MRUZUX0JPVFRPTSkge1xuICAgICAgICAgIHRvcERpZmYgLT0gbWFyZ2luQm90dG9tO1xuICAgICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuQk9UVE9NX1JJR0hUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuUklHSFRfQk9UVE9NKSB7XG4gICAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuVE9QX0xFRlQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5MRUZUX1RPUCkge1xuICAgICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuVE9QX1JJR0hUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuUklHSFRfVE9QKSB7XG4gICAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlRPUF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgLT0gbWFyZ2luQm90dG9tO1xuICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHtNYXRoLnJvdW5kKGxlZnREaWZmKX1weCkgdHJhbnNsYXRlWSgke01hdGgucm91bmQodG9wRGlmZil9cHgpYDtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHVibGljIHJlbGVhc2UoKSB7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgIHRoaXMucmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgaXNQb3NpdGlvbmVkKGNvbnRhaW5lcjogYW55KSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikucG9zaXRpb247XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSBQT1NJVElPTl9SRUxBVElWRSB8fCBwb3NpdGlvbiA9PT0gUE9TSVRJT05fQUJTT0xVVEUgfHwgcG9zaXRpb24gPT09IFBPU0lUSU9OX0ZJWEVEO1xuICB9XG5cbiAgLypcbiAgICAgKiBDb250YWluZXJzIHVwIHRvIHRoZSBmaXJzdCBwb3NpdGlvbmVkIG9uZSB3aWxsIGhhdmUgYW4gZXZlbnQgb24gc2Nyb2xsXG4gICAgICovXG5cbiAgcHJpdmF0ZSBzY3JvbGxhYmxlRWxlbWVudHM6IEhUTUxFbGVtZW50W10gPSBbXTtcblxuICBwcml2YXRlIGVtaXRTY3JvbGxFdmVudCgpIHtcbiAgICB0aGlzLl9zY3JvbGwubmV4dCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBib3VuZE9uU2Nyb2xsTGlzdGVuZXI6IGFueSA9IHRoaXMuZW1pdFNjcm9sbEV2ZW50LmJpbmQodGhpcyk7XG5cbiAgcHJpdmF0ZSBhZGRTY3JvbGxFdmVudExpc3RlbmVycyhlOiBhbnkpIHtcbiAgICB0aGlzLl9zY3JvbGwgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIGNvbnN0IGFuY2hvcjogYW55ID0gZTtcbiAgICBsZXQgY3VycmVudDogYW55ID0gZTtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgaWYgKHRoaXMuc2Nyb2xscyhjdXJyZW50KSkge1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuYm91bmRPblNjcm9sbExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudHMucHVzaChjdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50ICE9PSBhbmNob3IgJiYgdGhpcy5pc1Bvc2l0aW9uZWQoY3VycmVudCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIHRoaXMuc2Nyb2xsYWJsZUVsZW1lbnRzKSB7XG4gICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuYm91bmRPblNjcm9sbExpc3RlbmVyKTtcbiAgICB9XG4gICAgdGhpcy5zY3JvbGxhYmxlRWxlbWVudHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fc2Nyb2xsKSB7XG4gICAgICB0aGlzLl9zY3JvbGwuY29tcGxldGUoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zY3JvbGw7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzY3JvbGxzKGNvbnRhaW5lcjogYW55KTogYm9vbGVhbiB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIChcbiAgICAgIGNvbXB1dGVkU3R5bGVzLm92ZXJmbG93WCA9PT0gT1ZFUkZMT1dfU0NST0xMIHx8XG4gICAgICBjb21wdXRlZFN0eWxlcy5vdmVyZmxvd1ggPT09IE9WRVJGTE9XX0FVVE8gfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzLm92ZXJmbG93WSA9PT0gT1ZFUkZMT1dfU0NST0xMIHx8XG4gICAgICBjb21wdXRlZFN0eWxlcy5vdmVyZmxvd1kgPT09IE9WRVJGTE9XX0FVVE9cbiAgICApO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVtYmVkZGVkVmlld1JlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFBvaW50LCBQb3BvdmVyIH0gZnJvbSAnLi9wb3BvdmVyJztcbmltcG9ydCB7IFBvcG92ZXJPcHRpb25zIH0gZnJvbSAnLi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcblxubGV0IG9wZW5Db3VudDogbnVtYmVyID0gMDtcbmNvbnN0IHdhaXRpbmc6IEFycmF5PCgpID0+IHZvaWQ+ID0gW107IC8vIHBlbmRpbmcgY3JlYXRlIGZ1bmN0aW9uc1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUG9wb3Zlck9sZF0nIH0pXG5leHBvcnQgY2xhc3MgUG9wb3ZlckRpcmVjdGl2ZU9sZCB7XG4gIHByaXZhdGUgX3BvcG92ZXJJbnN0YW5jZTogUG9wb3ZlcjtcbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgQElucHV0KCdjbHJQb3BvdmVyT2xkQW5jaG9yJykgYW5jaG9yRWxlbTogYW55O1xuICBASW5wdXQoJ2NsclBvcG92ZXJPbGRBbmNob3JQb2ludCcpIGFuY2hvclBvaW50OiBQb2ludDtcbiAgQElucHV0KCdjbHJQb3BvdmVyT2xkUG9wb3ZlclBvaW50JykgcG9wb3ZlclBvaW50OiBQb2ludDtcbiAgQElucHV0KCdjbHJQb3BvdmVyT2xkT3B0aW9ucycpIHBvcG92ZXJPcHRpb25zOiBQb3BvdmVyT3B0aW9ucyA9IHt9O1xuICBAT3V0cHV0KCdjbHJQb3BvdmVyT2xkQ2hhbmdlJykgY2xyUG9wb3Zlck9sZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIHByaXZhdGUgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZikge31cblxuICBASW5wdXQoKVxuICBzZXQgY2xyUG9wb3Zlck9sZChvcGVuOiBib29sZWFuKSB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGlmICh0aGlzLnBvcG92ZXJPcHRpb25zLmFsbG93TXVsdGlwbGVPcGVuKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlUG9wb3ZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wZW5Db3VudCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuY3JlYXRlUG9wb3ZlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhaXRpbmcucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBvcG92ZXIoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgIHRoaXMuZGVzdHJveVBvcG92ZXIoKTtcblxuICAgICAgaWYgKCF0aGlzLnBvcG92ZXJPcHRpb25zLmFsbG93TXVsdGlwbGVPcGVuKSB7XG4gICAgICAgIGlmICh3YWl0aW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBjcmVhdGVQb3BvdmVyRm4gPSB3YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgICAgY3JlYXRlUG9wb3ZlckZuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjcmVhdGVQb3BvdmVyKCkge1xuICAgIGNvbnN0IGVtYmVkZGVkVmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPGFueT4gPSA8RW1iZWRkZWRWaWV3UmVmPGFueT4+dGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgIHRoaXMudGVtcGxhdGVSZWZcbiAgICApO1xuXG4gICAgLy8gVE9ETzogTm90IHN1cmUgb2YgdGhlIHJpc2tzIGFzc29jaWF0ZWQgd2l0aCB1c2luZyB0aGlzLiBGaW5kIGFuIGFsdGVybmF0aXZlLlxuICAgIC8vIE5lZWRlZCBmb3IgZmluZCB0aGUgY29ycmVjdCBoZWlnaHQgYW5kIHdpZHRoIG9mIGR5bmFtaWNhbGx5IGNyZWF0ZWQgdmlld3NcbiAgICAvLyBpbnNpZGUgb2YgdGhlIHBvcG92ZXIuIEZvciBFZzogQnV0dG9uIEdyb3Vwc1xuICAgIGVtYmVkZGVkVmlld1JlZi5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICAvLyBmaWx0ZXIgb3V0IG90aGVyIG5vZGVzIGluIHRoZSB2aWV3IHJlZiBzbyB3ZSBhcmUgb25seSBsZWZ0IHdpdGggZWxlbWVudCBub2Rlc1xuICAgIGNvbnN0IGVsZW1lbnROb2RlczogSFRNTEVsZW1lbnRbXSA9IGVtYmVkZGVkVmlld1JlZi5yb290Tm9kZXMuZmlsdGVyKChub2RlOiBhbnkpID0+IHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xuICAgIH0pO1xuXG4gICAgLy8gd2UgdGFrZSB0aGUgZmlyc3QgZWxlbWVudCBub2RlIGluIHRoZSBlbWJlZGRlZCB2aWV3OyB1c3VhbGx5IHRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBhbnl3YXlzXG4gICAgdGhpcy5fcG9wb3Zlckluc3RhbmNlID0gbmV3IFBvcG92ZXIoZWxlbWVudE5vZGVzWzBdKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9wb3BvdmVySW5zdGFuY2VcbiAgICAgIC5hbmNob3IodGhpcy5hbmNob3JFbGVtLCB0aGlzLmFuY2hvclBvaW50LCB0aGlzLnBvcG92ZXJQb2ludCwgdGhpcy5wb3BvdmVyT3B0aW9ucylcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsclBvcG92ZXJPbGRDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgICB9KTtcbiAgICBvcGVuQ291bnQrKztcbiAgfVxuXG4gIGRlc3Ryb3lQb3BvdmVyKCkge1xuICAgIGlmICh0aGlzLl9wb3BvdmVySW5zdGFuY2UpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5fcG9wb3Zlckluc3RhbmNlLnJlbGVhc2UoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wb3BvdmVySW5zdGFuY2U7XG4gICAgICBvcGVuQ291bnQtLTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lQb3BvdmVyKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBvcG92ZXJEaXJlY3RpdmVPbGQgfSBmcm9tICcuL3BvcG92ZXItb2xkLmRpcmVjdGl2ZSc7XG5cbmV4cG9ydCAqIGZyb20gJy4vcG9wb3Zlci1vcHRpb25zLmludGVyZmFjZSc7XG5leHBvcnQgKiBmcm9tICcuL3BvcG92ZXItb2xkLmRpcmVjdGl2ZSc7XG5cbmV4cG9ydCBjb25zdCBQT1BPVkVSX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1BvcG92ZXJEaXJlY3RpdmVPbGRdO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUE9QT1ZFUl9ESVJFQ1RJVkVTIH0gZnJvbSAnLi9pbmRleCc7XG5cbkBOZ01vZHVsZSh7IGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBkZWNsYXJhdGlvbnM6IFtQT1BPVkVSX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbUE9QT1ZFUl9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsckNvbW1vblBvcG92ZXJNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ2xyTG9hZGluZ1N0YXRlIH0gZnJvbSAnLi9sb2FkaW5nJztcblxuLyoqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGNsYXNzIGJlY2F1c2Ugd2UgbmVlZCBpdCB0byBzdGlsbCBiZSBhIHZhbGlkIHRva2VuIGZvciBkZXBlbmRlbmN5IGluamVjdGlvbiBhZnRlciB0cmFuc3BpbGluZy5cbiAqIFRoaXMgZG9lcyBub3QgbWVhbiB5b3Ugc2hvdWxkIGV4dGVuZCBpdCwgc2ltcGx5IGltcGxlbWVudGluZyBpdCBpcyBmaW5lLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTG9hZGluZ0xpc3RlbmVyIHtcbiAgYWJzdHJhY3QgbG9hZGluZ1N0YXRlQ2hhbmdlKHN0YXRlOiBDbHJMb2FkaW5nU3RhdGUpOiB2b2lkO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuL2xvYWRpbmctbGlzdGVuZXInO1xuXG5leHBvcnQgZW51bSBDbHJMb2FkaW5nU3RhdGUge1xuICBERUZBVUxULFxuICBMT0FESU5HLFxuICBTVUNDRVNTLFxuICBFUlJPUixcbn1cblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckxvYWRpbmddJyB9KVxuZXhwb3J0IGNsYXNzIENsckxvYWRpbmcgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAvLyBXZSBmaW5kIHRoZSBmaXJzdCBwYXJlbnQgdGhhdCBoYW5kbGVzIHNvbWV0aGluZyBsb2FkaW5nXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgbGlzdGVuZXI6IExvYWRpbmdMaXN0ZW5lcikge31cblxuICBwcml2YXRlIF9sb2FkaW5nU3RhdGU6IENsckxvYWRpbmdTdGF0ZSA9IENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUO1xuXG4gIHB1YmxpYyBnZXQgbG9hZGluZ1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkaW5nU3RhdGU7XG4gIH1cblxuICBASW5wdXQoJ2NsckxvYWRpbmcnKVxuICBwdWJsaWMgc2V0IGxvYWRpbmdTdGF0ZSh2YWx1ZTogYm9vbGVhbiB8IENsckxvYWRpbmdTdGF0ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdmFsdWUgPSBDbHJMb2FkaW5nU3RhdGUuTE9BRElORztcbiAgICB9IGVsc2UgaWYgKCF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBDbHJMb2FkaW5nU3RhdGUuREVGQVVMVDtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09IHRoaXMuX2xvYWRpbmdTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2xvYWRpbmdTdGF0ZSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmxpc3RlbmVyKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyLmxvYWRpbmdTdGF0ZUNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5sb2FkaW5nU3RhdGUgPSBDbHJMb2FkaW5nU3RhdGUuREVGQVVMVDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckJ1dHRvbiB9IGZyb20gJy4uL2J1dHRvbi1ncm91cC9idXR0b24nO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQnV0dG9uSW5Hcm91cFNlcnZpY2Uge1xuICBwcml2YXRlIF9jaGFuZ2VzOiBTdWJqZWN0PENsckJ1dHRvbj4gPSBuZXcgU3ViamVjdDxDbHJCdXR0b24+KCk7XG5cbiAgZ2V0IGNoYW5nZXMoKTogT2JzZXJ2YWJsZTxDbHJCdXR0b24+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHVwZGF0ZUJ1dHRvbkdyb3VwKGJ1dHRvbjogQ2xyQnV0dG9uKTogdm9pZCB7XG4gICAgdGhpcy5fY2hhbmdlcy5uZXh0KGJ1dHRvbik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPcHRpb25hbCwgT3V0cHV0LCBTa2lwU2VsZiwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJMb2FkaW5nU3RhdGUgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmcnO1xuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcbmltcG9ydCB7IEJ1dHRvbkluR3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2J1dHRvbi1pbi1ncm91cC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWJ1dHRvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjYnV0dG9uUHJvamVjdGVkUmVmPlxuICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBbY2xhc3NdPVwiY2xhc3NOYW1lc1wiIFxuICAgICAgICAgICAgICAgIChjbGljayk9XCJlbWl0Q2xpY2soKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIudHlwZV09XCJ0eXBlXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgIFthdHRyLmRpc2FibGVkXT1cImRpc2FibGVkXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzcGlubmVyIHNwaW5uZXItaW5saW5lXCIgKm5nSWY9XCJsb2FkaW5nXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTG9hZGluZ0xpc3RlbmVyLCB1c2VFeGlzdGluZzogQ2xyQnV0dG9uIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJCdXR0b24gaW1wbGVtZW50cyBMb2FkaW5nTGlzdGVuZXIge1xuICBwcml2YXRlIF9lbmFibGVTZXJ2aWNlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQFZpZXdDaGlsZCgnYnV0dG9uUHJvamVjdGVkUmVmJykgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPENsckJ1dHRvbj47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQFNraXBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHB1YmxpYyBidXR0b25Jbkdyb3VwU2VydmljZTogQnV0dG9uSW5Hcm91cFNlcnZpY2VcbiAgKSB7fVxuXG4gIHByaXZhdGUgX2luTWVudTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBpbk1lbnUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2luTWVudTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xySW5NZW51JylcbiAgc2V0IGluTWVudSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5faW5NZW51ICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5faW5NZW51ID0gdmFsdWU7XG4gICAgICAvLyBXZSBjaGVjayBpZiB0aGUgc2VydmljZSBmbGFnIGlzIGVuYWJsZWRcbiAgICAgIC8vIGFuZCBpZiB0aGUgc2VydmljZSBleGlzdHMgYmVjYXVzZSB0aGUgc2VydmljZSBpcyBvcHRpb25hbFxuICAgICAgaWYgKHRoaXMuX2VuYWJsZVNlcnZpY2UgJiYgdGhpcy5idXR0b25Jbkdyb3VwU2VydmljZSkge1xuICAgICAgICB0aGlzLmJ1dHRvbkluR3JvdXBTZXJ2aWNlLnVwZGF0ZUJ1dHRvbkdyb3VwKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NsYXNzTmFtZXM6IHN0cmluZyA9ICdidG4nO1xuXG4gIGdldCBjbGFzc05hbWVzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NsYXNzTmFtZXM7XG4gIH1cblxuICBASW5wdXQoJ2NsYXNzJylcbiAgc2V0IGNsYXNzTmFtZXModmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzOiBzdHJpbmdbXSA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gICAgICBpZiAoY2xhc3NOYW1lcy5pbmRleE9mKCdidG4nKSA9PT0gLTEpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdidG4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsYXNzTmFtZXMgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9uYW1lOiBzdHJpbmcgPSBudWxsO1xuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cblxuICBASW5wdXQoJ25hbWUnKVxuICBzZXQgbmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF90eXBlOiBzdHJpbmcgPSBudWxsO1xuXG4gIGdldCB0eXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gIH1cblxuICBASW5wdXQoJ3R5cGUnKVxuICBzZXQgdHlwZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3R5cGUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9kaXNhYmxlZDogYW55ID0gbnVsbDtcblxuICBnZXQgZGlzYWJsZWQoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gIH1cblxuICBASW5wdXQoJ2Rpc2FibGVkJylcbiAgc2V0IGRpc2FibGVkKHZhbHVlOiBhbnkpIHtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGxvYWRpbmc6IGJvb2xlYW47XG5cbiAgbG9hZGluZ1N0YXRlQ2hhbmdlKHN0YXRlOiBDbHJMb2FkaW5nU3RhdGUpOiB2b2lkIHtcbiAgICB0aGlzLmxvYWRpbmcgPSBzdGF0ZSA9PT0gQ2xyTG9hZGluZ1N0YXRlLkxPQURJTkc7XG4gIH1cblxuICBAT3V0cHV0KCdjbGljaycpIF9jbGljazogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgZW1pdENsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMuX2NsaWNrLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZW5hYmxlU2VydmljZSA9IHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBDTFJfTUVOVV9QT1NJVElPTlM6IHN0cmluZ1tdID0gW1xuICAnYm90dG9tLWxlZnQnLFxuICAnYm90dG9tLXJpZ2h0JyxcbiAgJ3RvcC1sZWZ0JyxcbiAgJ3RvcC1yaWdodCcsXG4gICdsZWZ0LWJvdHRvbScsXG4gICdsZWZ0LXRvcCcsXG4gICdyaWdodC1ib3R0b20nLFxuICAncmlnaHQtdG9wJyxcbl07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBTa2lwU2VsZiwgT3B0aW9uYWwsIEluamVjdGFibGVQcm92aWRlciwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG4vLyBAVE9ETyBQdXQgdGhlIFJlcXVpcmVkIHR5cGUgYmFjayBpbiB3aGVuIG91ciBtaW5pbXVtbHkgc3VwcG9ydGVkIHZlcnNpb24gb2YgQW5ndWxhciB1c2VzXG4vLyBUUyAyLjggb3IgZ3JlYXRlciAoc2hvdWxkIGJlIEFuZ3VsYXIgNylcbi8vIGV4cG9ydCBjbGFzcyBDbHJDb21tb25TdHJpbmdzU2VydmljZSBpbXBsZW1lbnRzIFJlcXVpcmVkPENsckNvbW1vblN0cmluZ3M+IHtcbmV4cG9ydCBjbGFzcyBDbHJDb21tb25TdHJpbmdzU2VydmljZSBpbXBsZW1lbnRzIENsckNvbW1vblN0cmluZ3Mge1xuICBvcGVuID0gJ09wZW4nO1xuICBjbG9zZSA9ICdDbG9zZSc7XG4gIHNob3cgPSAnU2hvdyc7XG4gIGhpZGUgPSAnSGlkZSc7XG4gIGV4cGFuZCA9ICdFeHBhbmQnO1xuICBjb2xsYXBzZSA9ICdDb2xsYXBzZSc7XG4gIG1vcmUgPSAnTW9yZSc7XG4gIHNlbGVjdCA9ICdTZWxlY3QnO1xuICBzZWxlY3RBbGwgPSAnU2VsZWN0IEFsbCc7XG4gIHByZXZpb3VzID0gJ1ByZXZpb3VzJztcbiAgbmV4dCA9ICdOZXh0JztcbiAgY3VycmVudCA9ICdKdW1wIHRvIGN1cnJlbnQnO1xuICBpbmZvID0gJ0luZm8nO1xuICBzdWNjZXNzID0gJ1N1Y2Nlc3MnO1xuICB3YXJuaW5nID0gJ1dhcm5pbmcnO1xuICBkYW5nZXIgPSAnRXJyb3InO1xuICByb3dBY3Rpb25zID0gJ0F2YWlsYWJsZSBhY3Rpb25zJztcbiAgcGlja0NvbHVtbnMgPSAnU2hvdyBvciBoaWRlIGNvbHVtbnMnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3RyaW5nc0ZhY3RvcnkoZXhpc3Rpbmc/OiBDbHJDb21tb25TdHJpbmdzKTogQ2xyQ29tbW9uU3RyaW5ncyB7XG4gIGNvbnN0IGRlZmF1bHRzID0gbmV3IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlKCk7XG4gIGlmIChleGlzdGluZykge1xuICAgIHJldHVybiB7IC4uLmRlZmF1bHRzLCAuLi5leGlzdGluZyB9O1xuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cblxuZXhwb3J0IGNvbnN0IENPTU1PTl9TVFJJTkdTX1BST1ZJREVSOiBJbmplY3RhYmxlUHJvdmlkZXIgPSB7XG4gIHVzZUZhY3Rvcnk6IGNvbW1vblN0cmluZ3NGYWN0b3J5LFxuICAvLyBXZSBoYXZlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBmb3Igbm93LCB3ZSBjYW4gYWRkcmVzcyBpdCBsYXRlciBvbmNlIHRoZXNlXG4gIC8vIHRyZWUtc2hha2VhYmxlIHByb3ZpZGVycyBoYXZlIHByb3BlciBkb2N1bWVudGF0aW9uLlxuICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgZm9yd2FyZFJlZigoKSA9PiBDbHJDb21tb25TdHJpbmdzKV1dLFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDT01NT05fU1RSSU5HU19QUk9WSURFUiB9IGZyb20gJy4vY29tbW9uLXN0cmluZ3Muc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAuLi5DT01NT05fU1RSSU5HU19QUk9WSURFUixcbn0pXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2xyQ29tbW9uU3RyaW5ncyB7XG4gIC8qKlxuICAgKiBPcGVuIGJ1dHRvblxuICAgKi9cbiAgb3Blbj86IHN0cmluZztcbiAgLyoqXG4gICAqIENsb3NlIGJ1dHRvblxuICAgKi9cbiAgY2xvc2U/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTaG93IGJ1dHRvblxuICAgKi9cbiAgc2hvdz86IHN0cmluZztcbiAgLyoqXG4gICAqIEhpZGUgYnV0dG9uXG4gICAqL1xuICBoaWRlPzogc3RyaW5nO1xuICAvKipcbiAgICogRXhwYW5kYWJsZSBjb21wb25lbnRzOiBleHBhbmQgY2FyZXRcbiAgICovXG4gIGV4cGFuZD86IHN0cmluZztcbiAgLyoqXG4gICAqIEV4cGFuZGFibGUgY29tcG9uZW50czogY29sbGFwc2UgY2FyZXRcbiAgICovXG4gIGNvbGxhcHNlPzogc3RyaW5nO1xuICAvKipcbiAgICogT3ZlcmZsb3cgbWVudXM6IGVsbGlwc2lzIGJ1dHRvblxuICAgKi9cbiAgbW9yZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFNlbGVjdGFibGUgY29tcG9uZW50czogY2hlY2tib3ggb3IgcmFkaW9cbiAgICovXG4gIHNlbGVjdD86IHN0cmluZztcbiAgLyoqXG4gICAqIFNlbGVjdGFibGUgY29tcG9uZW50czogY2hlY2tib3ggdG8gc2VsZWN0IGFsbFxuICAgKi9cbiAgc2VsZWN0QWxsPzogc3RyaW5nO1xuICAvKipcbiAgICogUGFnaW5hdGlvbjogcHJldmlvdXMgYnV0dG9uXG4gICAqL1xuICBwcmV2aW91cz86IHN0cmluZztcbiAgLyoqXG4gICAqIFBhZ2luYXRpb246IG5leHQgYnV0dG9uXG4gICAqL1xuICBuZXh0Pzogc3RyaW5nO1xuICAvKipcbiAgICogUGFnaW5hdGlvbjogZ28gdG8gY3VycmVudFxuICAgKi9cbiAgY3VycmVudD86IHN0cmluZztcbiAgLyoqXG4gICAqIEFsZXJ0IGxldmVsczogaW5mb1xuICAgKi9cbiAgaW5mbz86IHN0cmluZztcbiAgLyoqXG4gICAqIEFsZXJ0IGxldmVsczogc3VjY2Vzc1xuICAgKi9cbiAgc3VjY2Vzcz86IHN0cmluZztcbiAgLyoqXG4gICAqIEFsZXJ0IGxldmVsczogd2FybmluZ1xuICAgKi9cbiAgd2FybmluZz86IHN0cmluZztcbiAgLyoqXG4gICAqIEFsZXJ0IGxldmVsczogZGFuZ2VyXG4gICAqL1xuICBkYW5nZXI/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBEYXRhZ3JpZDogcm93IGFjdGlvbnNcbiAgICovXG4gIHJvd0FjdGlvbnM/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBEYXRhZ3JpZDogcGljayBjb2x1bW5zXG4gICAqL1xuICBwaWNrQ29sdW1ucz86IHN0cmluZztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuaW1wb3J0IHsgQ0xSX01FTlVfUE9TSVRJT05TIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9kcm9wZG93bi9tZW51LXBvc2l0aW9ucyc7XG5pbXBvcnQgeyBCdXR0b25Jbkdyb3VwU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9idXR0b24taW4tZ3JvdXAuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBDbHJCdXR0b24gfSBmcm9tICcuL2J1dHRvbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1idXR0b24tZ3JvdXAnLFxuICB0ZW1wbGF0ZVVybDogJ2J1dHRvbi1ncm91cC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbQnV0dG9uSW5Hcm91cFNlcnZpY2VdLFxuICBob3N0OiB7ICdbY2xhc3MuYnRuLWdyb3VwXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJCdXR0b25Hcm91cCB7XG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyQnV0dG9uKSBidXR0b25zOiBRdWVyeUxpc3Q8Q2xyQnV0dG9uPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgYnV0dG9uR3JvdXBOZXdTZXJ2aWNlOiBCdXR0b25Jbkdyb3VwU2VydmljZSxcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7fVxuXG4gIGlubGluZUJ1dHRvbnM6IENsckJ1dHRvbltdID0gW107XG4gIG1lbnVCdXR0b25zOiBDbHJCdXR0b25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiAxLiBJbml0aWFsaXplcyB0aGUgaW5pdGlhbCBCdXR0b24gR3JvdXAgVmlld1xuICAgKiAyLiBTdWJzY3JpYmVzIHRvIGNoYW5nZXMgb24gdGhlIENvbnRlbnRDaGlsZHJlblxuICAgKiAgICBpbiBjYXNlIHRoZSB1c2VyIGNvbnRlbnQgcHJvamVjdGlvbiBjaGFuZ2VzXG4gICAqL1xuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5pbml0aWFsaXplQnV0dG9ucygpO1xuICAgIHRoaXMuYnV0dG9uR3JvdXBOZXdTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKGJ1dHRvbiA9PiB0aGlzLnJlYXJyYW5nZUJ1dHRvbihidXR0b24pKTtcbiAgICB0aGlzLmJ1dHRvbnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplQnV0dG9ucygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBidXR0b24gaW50byB0aGUgb3RoZXIgVmlld0NvbnRhaW5lclxuICAgKiB3aGVuIGFuIHVwZGF0ZSBpcyByZWNlaXZlZC5cbiAgICpcbiAgICogQHBhcmFtIGJ1dHRvblxuICAgKi9cbiAgcmVhcnJhbmdlQnV0dG9uKGJ1dHRvbjogQ2xyQnV0dG9uKTogdm9pZCB7XG4gICAgbGV0IGZyb21WaWV3OiBDbHJCdXR0b25bXTtcbiAgICBsZXQgdG9WaWV3OiBDbHJCdXR0b25bXTtcbiAgICBpZiAoYnV0dG9uLmluTWVudSkge1xuICAgICAgZnJvbVZpZXcgPSB0aGlzLmlubGluZUJ1dHRvbnM7XG4gICAgICB0b1ZpZXcgPSB0aGlzLm1lbnVCdXR0b25zO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tVmlldyA9IHRoaXMubWVudUJ1dHRvbnM7XG4gICAgICB0b1ZpZXcgPSB0aGlzLmlubGluZUJ1dHRvbnM7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4OiBudW1iZXIgPSBmcm9tVmlldy5pbmRleE9mKGJ1dHRvbik7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIGZyb21WaWV3LnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjb25zdCBtb3ZlSW5kZXggPSB0aGlzLmdldE1vdmVJbmRleChidXR0b24pO1xuICAgICAgaWYgKG1vdmVJbmRleCA8PSB0b1ZpZXcubGVuZ3RoKSB7XG4gICAgICAgIHRvVmlldy5zcGxpY2UobW92ZUluZGV4LCAwLCBidXR0b24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdXRob3I6IEV1ZGVzXG4gICAqXG4gICAqIEZpbmRzIHRoZSBvcmRlciBvZiBhIGJ1dHRvbiB3LnIudCBvdGhlciBidXR0b25zXG4gICAqXG4gICAqIEBwYXJhbSBidXR0b25Ub01vdmVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldE1vdmVJbmRleChidXR0b25Ub01vdmU6IENsckJ1dHRvbik6IG51bWJlciB7XG4gICAgY29uc3QgdGVtcEFycjogQ2xyQnV0dG9uW10gPSB0aGlzLmJ1dHRvbnMuZmlsdGVyKGJ1dHRvbiA9PiBidXR0b24uaW5NZW51ID09PSBidXR0b25Ub01vdmUuaW5NZW51KTtcbiAgICByZXR1cm4gdGVtcEFyci5pbmRleE9mKGJ1dHRvblRvTW92ZSk7XG4gIH1cblxuICBpbml0aWFsaXplQnV0dG9ucygpOiB2b2lkIHtcbiAgICBjb25zdCB0ZW1wSW5saW5lQnV0dG9uczogQ2xyQnV0dG9uW10gPSBbXTtcbiAgICBjb25zdCB0ZW1wSW5NZW51QnV0dG9uczogQ2xyQnV0dG9uW10gPSBbXTtcbiAgICB0aGlzLmJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgaWYgKGJ1dHRvbi5pbk1lbnUpIHtcbiAgICAgICAgdGVtcEluTWVudUJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcElubGluZUJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaW5saW5lQnV0dG9ucyA9IHRlbXBJbmxpbmVCdXR0b25zO1xuICAgIHRoaXMubWVudUJ1dHRvbnMgPSB0ZW1wSW5NZW51QnV0dG9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVyZmxvdyBNZW51XG4gICAqXG4gICAqL1xuXG4gIC8vIEluZGljYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJmbG93IG1lbnVcbiAgcHJpdmF0ZSBfbWVudVBvc2l0aW9uOiBzdHJpbmc7XG5cbiAgZ2V0IG1lbnVQb3NpdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9tZW51UG9zaXRpb247XG4gIH1cblxuICBASW5wdXQoJ2Nsck1lbnVQb3NpdGlvbicpXG4gIHNldCBtZW51UG9zaXRpb24ocG9zOiBzdHJpbmcpIHtcbiAgICBpZiAocG9zICYmIENMUl9NRU5VX1BPU0lUSU9OUy5pbmRleE9mKHBvcykgPiAtMSkge1xuICAgICAgdGhpcy5fbWVudVBvc2l0aW9uID0gcG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tZW51UG9zaXRpb24gPSAnYm90dG9tLWxlZnQnO1xuICAgIH1cbiAgICAvLyBzZXQgdGhlIHBvcG92ZXIgdmFsdWVzIGJhc2VkIG9uIG1lbnUgcG9zaXRpb25cbiAgICBzd2l0Y2ggKHRoaXMuX21lbnVQb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9SSUdIVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuVE9QX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9SSUdIVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQtdG9wJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodC1ib3R0b20nOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQtdG9wJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0LWJvdHRvbSc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9vcGVuTWVudTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBvcGVuTWVudSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fb3Blbk1lbnU7XG4gIH1cblxuICBzZXQgb3Blbk1lbnUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9vcGVuTWVudSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGFuY2hvclBvaW50OiBQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUOyAvLyBkZWZhdWx0IGlmIG1lbnVQb3NpdGlvbiBpc24ndCBzZXRcbiAgcHVibGljIHBvcG92ZXJQb2ludDogUG9pbnQgPSBQb2ludC5MRUZUX1RPUDsgLy8gZGVmYXVsdCBpZiBtZW51UG9zaXRpb24gaXNuJ3Qgc2V0XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgQ2xyRHJvcGRvd24gTWVudSB3aGVuIHRoZSBDbHJEcm9wZG93biBUb2dnbGUgaXNcbiAgICogY2xpY2tlZC4gQWxzbyBzZXQgYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHRvZ2dsZVxuICAgKiB3YXMgY2xpY2tlZCBzbyB0aGF0IHdlIGRvbid0IHRyYXZlcnNlIHRoZSBET00gdG8gZmluZCB0aGVcbiAgICogbG9jYXRpb24gb2YgdGhlIGNsaWNrLlxuICAgKi9cbiAgdG9nZ2xlTWVudSgpOiB2b2lkIHtcbiAgICB0aGlzLm9wZW5NZW51ID0gIXRoaXMub3Blbk1lbnU7XG4gICAgdGhpcy5fb3ZlcmZsb3dNZW51VG9nZ2xlQ2xpY2tlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRmxhZyB3aXRoIGluZGljYXRlcyBpZiB0aGUgb3ZlcmZsb3cgbWVudSB0b2dnbGUgd2FzIGNsaWNrZWQuXG4gICAqIElmIHRydWUsIHRoaXMgY2FuIHNhdmUgdXMgdHJhdmVyc2luZyB0aGUgRE9NIHRvIGZpbmRcbiAgICogd2hldGhlciB0aGUgY2xpY2sgd2FzIHdpdGhpbmcgdGhlIGJ1dHRvbiBncm91cCB0b2dnbGVcbiAgICogb3IgbWVudSBpbiB0aGUgb25Nb3VzZUNsaWNrIG1ldGhvZFxuICAgKi9cbiAgcHJpdmF0ZSBfb3ZlcmZsb3dNZW51VG9nZ2xlQ2xpY2tlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIFRPRE86IEdlbmVyaWMgRGlyZWN0aXZlIHRvIGhhbmRsZSB0aGlzXG4gIC8qKlxuICAgKiBDYWxsZWQgb24gbW91c2UgY2xpY2tzIGFueXdoZXJlIGluIHRoZSBET00uXG4gICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIG1vdXNlY2xpY2sgaGFwcGVuZWQgb24gdGhlIGhvc3Qgb3Igb3V0c2lkZVxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudC50YXJnZXQnXSlcbiAgb25Nb3VzZUNsaWNrKHRhcmdldDogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMub3Blbk1lbnUgJiYgIXRoaXMuX292ZXJmbG93TWVudVRvZ2dsZUNsaWNrZWQpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBvdmVyZmxvdyBtZW51IHRvZ2dsZSBjbGlja2VkIGZsYWdcbiAgICAgIHRoaXMuX292ZXJmbG93TWVudVRvZ2dsZUNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGxldCBjdXJyZW50OiBhbnkgPSB0YXJnZXQ7IC8vIEdldCB0aGUgZWxlbWVudCBpbiB0aGUgRE9NIG9uIHdoaWNoIHRoZSBtb3VzZSB3YXMgY2xpY2tlZFxuICAgICAgY29uc3QgaG9zdDogYW55ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7IC8vIEN1cnJlbnQgQnV0dG9uIEdyb3VwXG5cbiAgICAgIGlmIChjdXJyZW50LmNsYXNzTGlzdC5jb250YWlucygnZHJvcGRvd24tbWVudScpKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5NZW51ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgY2xpY2tlZCBvbiBkcm9wZG93biBtZW51IGFuZCBtZW51IGlzIGluIGhvc3RcbiAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vcGVuTWVudSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9vdmVyZmxvd01lbnVUb2dnbGVDbGlja2VkID0gZmFsc2U7IC8vIFJlc2V0IHRoZSBvdmVyZmxvdyBtZW51IHRvZ2dsZSBjbGlja2VkIGZsYWdcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXIubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyQnV0dG9uIH0gZnJvbSAnLi9idXR0b24nO1xuaW1wb3J0IHsgQ2xyQnV0dG9uR3JvdXAgfSBmcm9tICcuL2J1dHRvbi1ncm91cCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfQlVUVE9OX0dST1VQX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsckJ1dHRvbiwgQ2xyQnV0dG9uR3JvdXBdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0JVVFRPTl9HUk9VUF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9CVVRUT05fR1JPVVBfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsckJ1dHRvbkdyb3VwTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IGFuaW1hdGUsIGtleWZyYW1lcywgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckxvYWRpbmdTdGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZyc7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdidXR0b25bY2xyTG9hZGluZ10nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJzdGF0ZVwiPlxuICAgICAgICAgICAgPHNwYW4gKm5nU3dpdGNoQ2FzZT1cImJ1dHRvblN0YXRlLkxPQURJTkdcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBAc3Bpbm5lciBjbGFzcz1cInNwaW5uZXIgc3Bpbm5lci1pbmxpbmVcIj48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiAqbmdTd2l0Y2hDYXNlPVwiYnV0dG9uU3RhdGUuU1VDQ0VTU1wiPlxuICAgICAgICAgICAgICAgIDxzcGFuIEB2YWxpZGF0ZWQgKEB2YWxpZGF0ZWQuZG9uZSk9XCJ0aGlzLmxvYWRpbmdTdGF0ZUNoYW5nZSh0aGlzLmJ1dHRvblN0YXRlLkRFRkFVTFQpXCIgY2xhc3M9XCJzcGlubmVyIHNwaW5uZXItaW5saW5lIHNwaW5uZXItY2hlY2tcIj48L3NwYW4+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiAqbmdTd2l0Y2hDYXNlPVwiYnV0dG9uU3RhdGUuREVGQVVMVFwiIEBkZWZhdWx0QnV0dG9uPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgYCxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBDbHJMb2FkaW5nQnV0dG9uIH1dLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignZGVmYXVsdEJ1dHRvbicsIFtcbiAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSksIGFuaW1hdGUoJzIwMG1zIDEwMG1zIGVhc2UtaW4nLCBzdHlsZSh7IG9wYWNpdHk6IDEgfSkpXSksXG4gICAgICAvLyBUT0RPOiBzZWUgaWYgd2UgY2FuIGdldCBsZWF2ZSBhbmltYXRpb24gdG8gd29yayBiZWZvcmUgc3Bpbm5lcidzIGVudGVyIGFuaW1hdGlvblxuICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW3N0eWxlKHsgb3BhY2l0eTogMCB9KV0pLFxuICAgIF0pLFxuICAgIHRyaWdnZXIoJ3NwaW5uZXInLCBbXG4gICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbc3R5bGUoeyBvcGFjaXR5OiAwIH0pLCBhbmltYXRlKCcyMDBtcyAxMDBtcyBlYXNlLWluJywgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKV0pLFxuICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW3N0eWxlKHsgb3BhY2l0eTogMSB9KSwgYW5pbWF0ZSgnMTAwbXMgZWFzZS1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXSksXG4gICAgXSksXG4gICAgdHJpZ2dlcigndmFsaWRhdGVkJywgW1xuICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW1xuICAgICAgICBhbmltYXRlKFxuICAgICAgICAgICc2MDBtcycsXG4gICAgICAgICAga2V5ZnJhbWVzKFtcbiAgICAgICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMCwwKScsIG9mZnNldDogMCB9KSxcbiAgICAgICAgICAgIHN0eWxlKHsgb3BhY2l0eTogMSwgb2Zmc2V0OiAwLjIgfSksXG4gICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDEuMiwxLjIpJywgb2Zmc2V0OiAwLjQgfSksXG4gICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKC45LC45KScsIG9mZnNldDogMC42IH0pLFxuICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgxLDEpJywgb2Zmc2V0OiAxIH0pLFxuICAgICAgICAgIF0pXG4gICAgICAgICksXG4gICAgICBdKSxcbiAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtzdHlsZSh7IG9wYWNpdHk6IDEgfSksIGFuaW1hdGUoJzEwMG1zIGVhc2Utb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKV0pLFxuICAgIF0pLFxuICBdLFxuICBob3N0OiB7ICdbYXR0ci5kaXNhYmxlZF0nOiBcImRpc2FibGVkPyAnJyA6IG51bGxcIiB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJMb2FkaW5nQnV0dG9uIGltcGxlbWVudHMgTG9hZGluZ0xpc3RlbmVyIHtcbiAgcHVibGljIGJ1dHRvblN0YXRlID0gQ2xyTG9hZGluZ1N0YXRlO1xuICBwdWJsaWMgc3RhdGU6IENsckxvYWRpbmdTdGF0ZSA9IENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUO1xuXG4gIEBJbnB1dCgnZGlzYWJsZWQnKSBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW47XG5cbiAgQE91dHB1dCgnY2xyTG9hZGluZ0NoYW5nZScpXG4gIHB1YmxpYyBjbHJMb2FkaW5nQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Q2xyTG9hZGluZ1N0YXRlPiA9IG5ldyBFdmVudEVtaXR0ZXI8Q2xyTG9hZGluZ1N0YXRlPihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cbiAgbG9hZGluZ1N0YXRlQ2hhbmdlKHN0YXRlOiBDbHJMb2FkaW5nU3RhdGUpOiB2b2lkIHtcbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuREVGQVVMVDpcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcpO1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuTE9BRElORzpcbiAgICAgICAgdGhpcy5zZXRFeHBsaWNpdEJ1dHRvbldpZHRoKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgJycpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyTG9hZGluZ1N0YXRlLlNVQ0NFU1M6XG4gICAgICAgIHRoaXMuc2V0RXhwbGljaXRCdXR0b25XaWR0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyTG9hZGluZ1N0YXRlLkVSUk9SOlxuICAgICAgICB0aGlzLmxvYWRpbmdTdGF0ZUNoYW5nZShDbHJMb2FkaW5nU3RhdGUuREVGQVVMVCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuY2xyTG9hZGluZ0NoYW5nZS5lbWl0KHN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0RXhwbGljaXRCdXR0b25XaWR0aCgpIHtcbiAgICBpZiAodGhpcy5lbC5uYXRpdmVFbGVtZW50ICYmIHRoaXMuZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcbiAgICAgIGNvbnN0IGJvdW5kaW5nQ2xpZW50UmVjdCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCBgJHtib3VuZGluZ0NsaWVudFJlY3Qud2lkdGh9cHhgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckxvYWRpbmdCdXR0b24gfSBmcm9tICcuL2xvYWRpbmctYnV0dG9uJztcblxuZXhwb3J0IGNvbnN0IENMUl9MT0FESU5HX0JVVFRPTl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJMb2FkaW5nQnV0dG9uXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9MT0FESU5HX0JVVFRPTl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9MT0FESU5HX0JVVFRPTl9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTG9hZGluZ0J1dHRvbk1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJCdXR0b25Hcm91cE1vZHVsZSB9IGZyb20gJy4vYnV0dG9uLWdyb3VwL2J1dHRvbi1ncm91cC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ0J1dHRvbk1vZHVsZSB9IGZyb20gJy4vYnV0dG9uLWxvYWRpbmcvbG9hZGluZy1idXR0b24ubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgZXhwb3J0czogW0NsckxvYWRpbmdCdXR0b25Nb2R1bGUsIENsckJ1dHRvbkdyb3VwTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQnV0dG9uTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiAnJyxcbn0pXG5leHBvcnQgY2xhc3MgRW1wdHlBbmNob3Ige31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEVtcHR5QW5jaG9yIH0gZnJvbSAnLi9lbXB0eS1hbmNob3InO1xuXG4vKipcbiAqIEludGVybmFsIG1vZHVsZSwgcGxlYXNlIGRvIG5vdCBleHBvcnQhXG4gKi9cbkBOZ01vZHVsZSh7IGRlY2xhcmF0aW9uczogW0VtcHR5QW5jaG9yXSwgZXhwb3J0czogW0VtcHR5QW5jaG9yXSwgZW50cnlDb21wb25lbnRzOiBbRW1wdHlBbmNob3JdIH0pXG5leHBvcnQgY2xhc3MgQ2xySG9zdFdyYXBwaW5nTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNvbnRyb2wtZXJyb3InLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuY2xyLXN1YnRleHRdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNvbnRyb2xFcnJvciB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jb250cm9sLWhlbHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5jbHItc3VidGV4dF0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ29udHJvbEhlbHBlciB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ0NvbnRyb2xTZXJ2aWNlIHtcbiAgLy8gT2JzZXJ2YWJsZSB0byBzdWJzY3JpYmUgdG8gdGhlIGNvbnRyb2wsIHNpbmNlIGl0cyBub3QgYXZhaWxhYmxlIGltbWVkaWF0ZWx5IGZvciBwcm9qZWN0ZWQgY29udGVudFxuICBwcml2YXRlIF9jb250cm9sQ2hhbmdlczogU3ViamVjdDxOZ0NvbnRyb2w+ID0gbmV3IFN1YmplY3Q8TmdDb250cm9sPigpO1xuICBnZXQgY29udHJvbENoYW5nZXMoKTogT2JzZXJ2YWJsZTxOZ0NvbnRyb2w+IHtcbiAgICByZXR1cm4gdGhpcy5fY29udHJvbENoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBzZXRDb250cm9sKGNvbnRyb2w6IE5nQ29udHJvbCkge1xuICAgIHRoaXMuX2NvbnRyb2xDaGFuZ2VzLm5leHQoY29udHJvbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSWZFcnJvclNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAvLyBJbXBsZW1lbnQgb3VyIG93biBzdGF0dXMgY2hhbmdlcyBvYnNlcnZhYmxlLCBzaW5jZSBBbmd1bGFyIGNvbnRyb2xzIGRvbid0XG4gIC8vIGZpcmUgb24gZXZlbnRzIGxpa2UgYmx1ciwgYW5kIHdlIHdhbnQgdG8gcmV0dXJuIHRoZSBib29sZWFuIHN0YXRlIGluc3RlYWQgb2YgYSBzdHJpbmdcbiAgcHJpdmF0ZSBfc3RhdHVzQ2hhbmdlczogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0KCk7XG4gIGdldCBzdGF0dXNDaGFuZ2VzKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXNDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgY29udHJvbCB0byBiZSBhdmFpbGFibGVcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgICAgICB0aGlzLmxpc3RlbkZvckNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdGF0dXMgY2hhbmdlIGV2ZW50cywgb25seSBhZnRlciB0b3VjaGVkIGFuZCBlbWl0IHRoZSBjb250cm9sXG4gIHByaXZhdGUgbGlzdGVuRm9yQ2hhbmdlcygpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VuZFZhbGlkaXR5KCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHNlbmRWYWxpZGl0eSgpIHtcbiAgICBpZiAoKHRoaXMuY29udHJvbC50b3VjaGVkIHx8IHRoaXMuY29udHJvbC5kaXJ0eSkgJiYgdGhpcy5jb250cm9sLmludmFsaWQpIHtcbiAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMubmV4dCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdHVzQ2hhbmdlcy5uZXh0KGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvLyBBbGxvd3MgYSBjb250cm9sIHRvIHB1c2ggYSBzdGF0dXMgY2hlY2sgdXBzdHJlYW0sIHN1Y2ggYXMgb24gYmx1clxuICB0cmlnZ2VyU3RhdHVzQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHRoaXMuc2VuZFZhbGlkaXR5KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgc3Vic2NyaXB0aW9uc1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPcHRpb25hbCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4vaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkVycm9yXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJJZkVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmlmRXJyb3JTZXJ2aWNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NscklmRXJyb3IgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gYSBmb3JtIGNvbnRyb2wgY29udGFpbmVyIGVsZW1lbnQgbGlrZSBjbHItaW5wdXQtY29udGFpbmVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBzcGVjaWZpYyBlcnJvciB0byB0cmFjaywgY2hlY2sgaXQsIG90aGVyd2lzZSBjaGVjayBvdmVyYWxsIHZhbGlkaXR5XG4gICAgICAgIGlmICh0aGlzLmVycm9yICYmIHRoaXMuY29udHJvbCkge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yKHRoaXMuY29udHJvbC5oYXNFcnJvcih0aGlzLmVycm9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoaW52YWxpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xySWZFcnJvcicpIGVycm9yOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIGRpc3BsYXllZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBkaXNwbGF5RXJyb3IoaW52YWxpZDogYm9vbGVhbikge1xuICAgIGlmIChpbnZhbGlkICYmICF0aGlzLmRpc3BsYXllZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWludmFsaWQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB0aGlzLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmxldCBjb3VudGVyID0gMDtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbnRyb2xJZFNlcnZpY2Uge1xuICBwcml2YXRlIF9pZCA9ICdjbHItZm9ybS1jb250cm9sLScgKyArK2NvdW50ZXI7XG4gIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9pZDtcbiAgfVxuICBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgdGhpcy5faWRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9pZENoYW5nZTogQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHRoaXMuX2lkKTtcbiAgcHVibGljIGdldCBpZENoYW5nZSgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9pZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBlbnVtIExheW91dHMge1xuICBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCcsXG4gIEhPUklaT05UQUwgPSAnaG9yaXpvbnRhbCcsXG4gIENPTVBBQ1QgPSAnY29tcGFjdCcsXG59XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMYXlvdXRTZXJ2aWNlIHtcbiAgbGF5b3V0OiBMYXlvdXRzID0gTGF5b3V0cy5IT1JJWk9OVEFMO1xuICAvLyBUaGlzIGlzIGJhc2ljYWxseSBhIHJlcGxhY2VtZW50IGZvciBPYmplY3QudmFsdWVzKCksIHdoaWNoIElFMTEgYW5kIE5vZGUgPDkgZG9uJ3Qgc3VwcG9ydCA6KFxuICAvLyBTdHJpbmcgZW51bXMgY2Fubm90IGJlIHJldmVyc2UtbWFwcGVkLCBtZWFuaW5nIExheW91dHNbJ0NPTVBBQ1QnXSBkb2VzIG5vdCByZXR1cm4gJ2NvbXBhY3QnIHNvXG4gIC8vIHRoaXMgZXhpc3RzIHRvIGRlYWwgd2l0aCB0aGlzIGxpdHRsZSBjYXZlYXQgdG8gZ2V0IHRoZSBsaXN0IG9mIHRoZSB2YWx1ZXMgYXMgYW4gYXJyYXkuXG4gIHByaXZhdGUgbGF5b3V0VmFsdWVzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKExheW91dHMpLm1hcChrZXkgPT4gTGF5b3V0c1trZXldKTtcblxuICBpc1ZlcnRpY2FsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxheW91dCA9PT0gTGF5b3V0cy5WRVJUSUNBTDtcbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09IExheW91dHMuSE9SSVpPTlRBTDtcbiAgfVxuXG4gIGlzQ29tcGFjdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09IExheW91dHMuQ09NUEFDVDtcbiAgfVxuXG4gIGdldCBsYXlvdXRDbGFzcygpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2xyLWZvcm0tJHt0aGlzLmxheW91dH1gO1xuICB9XG5cbiAgaXNWYWxpZChsYXlvdXQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmxheW91dFZhbHVlcy5pbmRleE9mKGxheW91dCkgPiAtMTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPcHRpb25hbCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2xhYmVsJyB9KVxuZXhwb3J0IGNsYXNzIENsckxhYmVsIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGNvbnRyb2xJZFNlcnZpY2U6IENvbnRyb2xJZFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZlxuICApIHt9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmZvcicpXG4gIEBJbnB1dCgnZm9yJylcbiAgZm9yQXR0cjogc3RyaW5nO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBPbmx5IGFkZCB0aGUgY2xyLWNvbnRyb2wtbGFiZWwgaWYgaXQgaXMgaW5zaWRlIGEgY29udHJvbCBjb250YWluZXJcbiAgICBpZiAodGhpcy5jb250cm9sSWRTZXJ2aWNlIHx8IHRoaXMubmdDb250cm9sU2VydmljZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbHItY29udHJvbC1sYWJlbCcpO1xuICAgIH1cbiAgICAvLyBPbmx5IHNldCB0aGUgZ3JpZCBjb2x1bW4gY2xhc3NlcyBpZiB3ZSBhcmUgaW4gdGhlIHJpZ2h0IGNvbnRleHQgYW5kIGlmIHRoZXkgYXJlbid0IGFscmVhZHkgc2V0XG4gICAgaWYgKFxuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlICYmXG4gICAgICAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSAmJlxuICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50ICYmXG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2Nsci1jb2wnKSA8IDBcbiAgICApIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xyLWNvbC14cy0xMicpO1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbHItY29sLW1kLTInKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udHJvbElkU2VydmljZSAmJiAhdGhpcy5mb3JBdHRyKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLmNvbnRyb2xJZFNlcnZpY2UuaWRDaGFuZ2Uuc3Vic2NyaWJlKGlkID0+ICh0aGlzLmZvckF0dHIgPSBpZCkpKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBjb25zdCBJU19ORVdfRk9STVNfTEFZT1VUID0gbmV3IEluamVjdGlvblRva2VuPGJvb2xlYW4+KCdJU19ORVdfRk9STVNfTEFZT1VUJyk7XG5leHBvcnQgY29uc3QgSVNfTkVXX0ZPUk1TX0xBWU9VVF9UUlVFX1BST1ZJREVSID0ge1xuICBwcm92aWRlOiBJU19ORVdfRk9STVNfTEFZT1VULFxuICB1c2VWYWx1ZTogdHJ1ZSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1hcmtDb250cm9sU2VydmljZSB7XG4gIHByaXZhdGUgX2RpcnR5OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3QoKTtcblxuICBnZXQgZGlydHlDaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbWFya0FzRGlydHkoKSB7XG4gICAgdGhpcy5fZGlydHkubmV4dCgpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExheW91dFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBJU19ORVdfRk9STVNfTEFZT1VUX1RSVUVfUFJPVklERVIgfSBmcm9tICcuL3Byb3ZpZGVycy9uZXctZm9ybXMuc2VydmljZSc7XG5pbXBvcnQgeyBNYXJrQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9tYXJrLWNvbnRyb2wuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJGb3JtXScsXG4gIHByb3ZpZGVyczogW0xheW91dFNlcnZpY2UsIE1hcmtDb250cm9sU2VydmljZSwgSVNfTkVXX0ZPUk1TX0xBWU9VVF9UUlVFX1BST1ZJREVSXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm1dJzogJ3RydWUnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0taG9yaXpvbnRhbF0nOiAnbGF5b3V0U2VydmljZS5pc0hvcml6b250YWwoKScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb21wYWN0XSc6ICdsYXlvdXRTZXJ2aWNlLmlzQ29tcGFjdCgpJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRm9ybSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLCBwcml2YXRlIG1hcmtDb250cm9sU2VydmljZTogTWFya0NvbnRyb2xTZXJ2aWNlKSB7fVxuXG4gIG1hcmtBc0RpcnR5KCkge1xuICAgIHRoaXMubWFya0NvbnRyb2xTZXJ2aWNlLm1hcmtBc0RpcnR5KCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTGF5b3V0cywgTGF5b3V0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsckxheW91dF0nLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJMYXlvdXQgaW1wbGVtZW50cyBPbkluaXQge1xuICBASW5wdXQoJ2NsckxheW91dCcpIGxheW91dDogTGF5b3V0cztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBPbmx5IHNldCB0aGUgbGF5b3V0IGlmIGl0IGlzIGEgdmFsaWQgb3B0aW9uXG4gICAgaWYgKHRoaXMubGF5b3V0ICYmIHRoaXMubGF5b3V0U2VydmljZS5pc1ZhbGlkKHRoaXMubGF5b3V0KSkge1xuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmxheW91dCA9IHRoaXMubGF5b3V0O1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckNvbnRyb2xFcnJvciB9IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgQ2xyQ29udHJvbEhlbHBlciB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IENscklmRXJyb3IgfSBmcm9tICcuL2lmLWVycm9yL2lmLWVycm9yJztcbmltcG9ydCB7IENsckxhYmVsIH0gZnJvbSAnLi9sYWJlbCc7XG5pbXBvcnQgeyBDbHJGb3JtIH0gZnJvbSAnLi9mb3JtJztcbmltcG9ydCB7IENsckxheW91dCB9IGZyb20gJy4vbGF5b3V0JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsckxhYmVsLCBDbHJDb250cm9sRXJyb3IsIENsckNvbnRyb2xIZWxwZXIsIENscklmRXJyb3IsIENsckZvcm0sIENsckxheW91dF0sXG4gIGV4cG9ydHM6IFtDbHJMYWJlbCwgQ2xyQ29udHJvbEVycm9yLCBDbHJDb250cm9sSGVscGVyLCBDbHJJZkVycm9yLCBDbHJGb3JtLCBDbHJMYXlvdXRdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDb21tb25Gb3Jtc01vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItY2hlY2tib3gtd3JhcHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsckNoZWNrYm94XVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWxcIj48L2xhYmVsPlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItY2hlY2tib3gtd3JhcHBlcl0nOiAndHJ1ZScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0NvbnRyb2xJZFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDaGVja2JveFdyYXBwZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciB7XG4gIC8vIFdlIG5lZWQgYm90aCBfZHluYW1pYyBmb3IgSG9zdFdyYXBwZXIgYW5kIENvbnRlbnRDaGlsZChDbHJMYWJlbCkgaW4gY2FzZXMgd2hlcmVcbiAgLy8gdGhlIHVzZXIgcHV0cyBhIHJhZGlvIGluc2lkZSBhIHdyYXBwZXIgd2l0aG91dCBhIGxhYmVsLCBob3N0IHdyYXBwaW5nIGRvZXNuJ3QgYXBwbHlcbiAgLy8gYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0byBpbnNlcnQgYSBsYWJlbFxuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBDb21wb25lbnRGYWN0b3J5LFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdGlvblRva2VuLFxuICBJbmplY3RvcixcbiAgVHlwZSxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgRW1wdHlBbmNob3IgfSBmcm9tICcuL2VtcHR5LWFuY2hvcic7XG5cbi8qKlxuICogSG9zdFdyYXBwZXIgbXVzdCBiZSBjYWxsZWQgaW4gT25Jbml0IHRvIGVuc3VyZSB0aGF0IHRoZSBWaWV3cyBhcmUgcmVhZHkuIElmIGl0cyBjYWxsZWQgaW4gYSBjb25zdHJ1Y3RvciB0aGUgdmlldyBpc1xuICogc3RpbGwgdW5kZWZpbmVkLlxuICogVE9ETyAtIG1ha2Ugc3VyZSB0aGVzZSBjb21tZW50IGFubm90YXRpb25zIGRvIG5vdCBicmVhayBuZy1wYWNrZ3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb3N0V3JhcHBlcjxXIGV4dGVuZHMgRHluYW1pY1dyYXBwZXI+IGltcGxlbWVudHMgSW5qZWN0b3Ige1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJUeXBlOiBUeXBlPFc+LCB2Y3I6IFZpZXdDb250YWluZXJSZWYsIGluZGV4OiBudW1iZXIgPSAwKSB7XG4gICAgdGhpcy5pbmplY3RvciA9IHZjci5pbmplY3RvcjtcbiAgICAvLyBJZiB0aGUgaG9zdCBpcyBhbHJlYWR5IHdyYXBwZWQsIHdlIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKCF0aGlzLmluamVjdG9yLmdldChjb250YWluZXJUeXBlLCBudWxsKSkge1xuICAgICAgY29uc3QgY2ZyID0gdGhpcy5pbmplY3Rvci5nZXQoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKTtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5pbmplY3Rvci5nZXQoRWxlbWVudFJlZik7XG5cbiAgICAgIC8vIFdlIG5lZWQgYSBuZXcgYW5jaG9yLCBzaW5jZSB3ZSdyZSBwcm9qZWN0aW5nIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgIHZjci5jcmVhdGVDb21wb25lbnQoY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KEVtcHR5QW5jaG9yKSk7XG4gICAgICBjb25zdCBmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PFc+ID0gY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbnRhaW5lclR5cGUpO1xuICAgICAgLy8gQ3JhZnQgdGhlIGVsZW1lbnQgYXJyYXkgYmFzZWQgb24gd2hhdCBzbG90IHRvIHVzZS4gQW5ndWxhciBvbmx5IHVzZXMgdGhlIGluZGV4IHRvIGRldGVybWluZVxuICAgICAgLy8gd2hpY2ggbmctY29udGVudCB0byBwcm9qZWN0IGludG8sIHNvIGlmIHlvdSBoYXZlIG1vcmUgdGhhbiBvbmUgbmctY29udGVudCB5b3UnbGwgbmVlZCB0byBzZXRcbiAgICAgIC8vIHRoZSBpbmRleCBpbiB0aGUgY29uc3RydWN0b3IgYXBwcm9wcmlhdGVseVxuICAgICAgY29uc3QgZWxlbWVudCA9IFtdO1xuICAgICAgZWxlbWVudFtpbmRleF0gPSBbZWwubmF0aXZlRWxlbWVudF07XG4gICAgICAvLyBXZSdyZSBhc3N1bWluZyBvbmx5IG9uZSBwcm9qZWN0aW9uIHNsb3QsIGJ1dCBpbiBtb3JlIGNvbXBsZXggY2FzZXMgd2UgbWlnaHQgd2FudCB0byBwcm92aWRlXG4gICAgICAvLyBhIGRpZmZlcmVudCBhcnJheSBvZiBwcm9qZWN0ZWQgZWxlbWVudHMuXG4gICAgICBjb25zdCBjb250YWluZXJSZWYgPSB2Y3IuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBlbGVtZW50KTtcbiAgICAgIC8vIFdlIGNhbiBub3cgcmVtb3ZlIHRoZSB1c2VsZXNzIGFuY2hvclxuICAgICAgdmNyLnJlbW92ZSgwKTtcblxuICAgICAgLy8gV2Ugbm90ZSB0aGF0IHRoZSBjb250YWluZXIgd2FzIGR5bmFtaWNhbGx5IGNyZWF0ZWRcbiAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5fZHluYW1pYyA9IHRydWU7XG5cbiAgICAgIC8vIFdlIGtlZXAgdGhlIHdyYXBwZXIncyBpbmplY3RvciB0byBhY2Nlc3MgdGhlIGRlcGVuZGVuY2llcyB0aGF0IHdlcmVuJ3QgYXZhaWxhYmxlIGJlZm9yZS5cbiAgICAgIHRoaXMuaW5qZWN0b3IgPSBjb250YWluZXJSZWYuaW5qZWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgZ2V0PFQ+KHRva2VuOiBUeXBlPFQ+IHwgSW5qZWN0aW9uVG9rZW48VD4sIG5vdEZvdW5kVmFsdWU/OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb250cm9sQ2xhc3NTZXJ2aWNlIHtcbiAgY2xhc3NOYW1lID0gJyc7XG5cbiAgY29udHJvbENsYXNzKGludmFsaWQgPSBmYWxzZSwgZ3JpZCA9IGZhbHNlLCBhZGRpdGlvbmFsID0gJycpIHtcbiAgICBjb25zdCBjb250cm9sQ2xhc3NlcyA9IFt0aGlzLmNsYXNzTmFtZSwgYWRkaXRpb25hbF07XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIGNvbnRyb2xDbGFzc2VzLnB1c2goJ2Nsci1lcnJvcicpO1xuICAgIH1cbiAgICBpZiAoZ3JpZCAmJiB0aGlzLmNsYXNzTmFtZS5pbmRleE9mKCdjbHItY29sJykgPT09IC0xKSB7XG4gICAgICBjb250cm9sQ2xhc3Nlcy5wdXNoKCdjbHItY29sLW1kLTEwIGNsci1jb2wteHMtMTInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xDbGFzc2VzLmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIHJlbW92ZSB0aGUgY29sdW1uIGNsYXNzZXMgZnJvbSB0aGUgaW5wdXQgdXAgdG8gdGhlIGNvbnRhaW5lclxuICBpbml0Q29udHJvbENsYXNzKHJlbmRlcmVyLCBlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgY29uc3Qga2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICBrbGFzc2VzLmZvckVhY2goa2xhc3MgPT4ge1xuICAgICAgICBpZiAoa2xhc3Muc3RhcnRzV2l0aCgnY2xyLWNvbCcpKSB7XG4gICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwga2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBIb3N0QmluZGluZyxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkluaXQsXG4gIFR5cGUsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFJlbmRlcmVyMixcbiAgRWxlbWVudFJlZixcbiAgT25EZXN0cm95LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbWFyay1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBjbGFzcyBXcmFwcGVkRm9ybUNvbnRyb2w8VyBleHRlbmRzIER5bmFtaWNXcmFwcGVyPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlO1xuICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZTtcbiAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlO1xuICBwcml2YXRlIG1hcmtDb250cm9sU2VydmljZTogTWFya0NvbnRyb2xTZXJ2aWNlO1xuXG4gIHByb3RlY3RlZCBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcm90ZWN0ZWQgaW5kZXggPSAwO1xuICBwcm90ZWN0ZWQgY29udHJvbElkU2VydmljZTogQ29udHJvbElkU2VydmljZTtcblxuICBfaWQ6IHN0cmluZztcblxuICAvLyBJIGxvc3Qgd2F5IHRvbyBtdWNoIHRpbWUgdHJ5aW5nIHRvIG1ha2UgdGhpcyB3b3JrIHdpdGhvdXQgaW5qZWN0aW5nIHRoZSBWaWV3Q29udGFpbmVyUmVmIGFuZCB0aGUgSW5qZWN0b3IsXG4gIC8vIEknbSBnaXZpbmcgdXAuIFNvIHdlIGhhdmUgdG8gaW5qZWN0IHRoZXNlIHR3byBtYW51YWxseSBmb3Igbm93LlxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByb3RlY3RlZCB3cmFwcGVyVHlwZTogVHlwZTxXPixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2w6IE5nQ29udHJvbCxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UgPSBpbmplY3Rvci5nZXQoTmdDb250cm9sU2VydmljZSk7XG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KElmRXJyb3JTZXJ2aWNlKTtcbiAgICAgIHRoaXMuY29udHJvbENsYXNzU2VydmljZSA9IGluamVjdG9yLmdldChDb250cm9sQ2xhc3NTZXJ2aWNlKTtcbiAgICAgIHRoaXMubWFya0NvbnRyb2xTZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KE1hcmtDb250cm9sU2VydmljZSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICh0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UpIHtcbiAgICAgIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5pbml0Q29udHJvbENsYXNzKHJlbmRlcmVyLCBlbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFya0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5tYXJrQ29udHJvbFNlcnZpY2UuZGlydHlDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm5nQ29udHJvbC5jb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRyb2wuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0QmluZGluZygpXG4gIEBJbnB1dCgpXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmNvbnRyb2xJZFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuY29udHJvbElkU2VydmljZS5pZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICB0cmlnZ2VyVmFsaWRhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pZkVycm9yU2VydmljZSkge1xuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS50cmlnZ2VyU3RhdHVzQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY29udGFpbmVySW5qZWN0b3I6IEluamVjdG9yO1xuXG4gIHByb3RlY3RlZCBnZXRQcm92aWRlckZyb21Db250YWluZXI8VD4odG9rZW46IFR5cGU8VD4gfCBJbmplY3Rpb25Ub2tlbjxUPiwgbm90Rm91bmRWYWx1ZT86IFQpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVySW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuX2NvbnRhaW5lckluamVjdG9yID0gbmV3IEhvc3RXcmFwcGVyKHRoaXMud3JhcHBlclR5cGUsIHRoaXMudmNyLCB0aGlzLmluZGV4KTtcbiAgICB0aGlzLmNvbnRyb2xJZFNlcnZpY2UgPSB0aGlzLl9jb250YWluZXJJbmplY3Rvci5nZXQoQ29udHJvbElkU2VydmljZSk7XG4gICAgaWYgKHRoaXMuX2lkKSB7XG4gICAgICB0aGlzLmNvbnRyb2xJZFNlcnZpY2UuaWQgPSB0aGlzLl9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faWQgPSB0aGlzLmNvbnRyb2xJZFNlcnZpY2UuaWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmdDb250cm9sU2VydmljZSkge1xuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLnNldENvbnRyb2wodGhpcy5uZ0NvbnRyb2wpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgUmVuZGVyZXIyLCBFbGVtZW50UmVmLCBJbmplY3RvciwgU2VsZiwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENsckNoZWNrYm94V3JhcHBlciB9IGZyb20gJy4vY2hlY2tib3gtd3JhcHBlcic7XG5cbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyQ2hlY2tib3hdJyB9KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94IGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsckNoZWNrYm94V3JhcHBlcj4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHN1cGVyKHZjciwgQ2xyQ2hlY2tib3hXcmFwcGVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNoZWNrYm94LWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgPGxhYmVsICpuZ0lmPVwiIWxhYmVsICYmIGFkZEdyaWQoKVwiPjwvbGFiZWw+XG4gICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtjbGFzcy5jbHItY29udHJvbC1pbmxpbmVdPVwiY2xySW5saW5lXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jaGVja2JveC13cmFwcGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGRpdiBjbGFzcz1cImNsci1zdWJ0ZXh0LXdyYXBwZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2xdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZF0nOiAnY29udHJvbD8uZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbTmdDb250cm9sU2VydmljZSwgQ29udHJvbENsYXNzU2VydmljZSwgSWZFcnJvclNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDaGVja2JveENvbnRhaW5lciBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIHByaXZhdGUgaW5saW5lID0gZmFsc2U7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcbiAgLy8gcHJpdmF0ZSBmb3JtR3JvdXA6IEFic3RyYWN0Q29udHJvbDtcblxuICAvKlxuICAgKiBIZXJlIHdlIHdhbnQgdG8gc3VwcG9ydCB0aGUgZm9sbG93aW5nIGNhc2VzXG4gICAqIGNscklubGluZSAtIHRydWUgYnkgcHJlc2VuY2VcbiAgICogY2xySW5saW5lPVwidHJ1ZXxmYWxzZVwiIC0gdW5sZXNzIGl0IGlzIGV4cGxpY2l0bHkgZmFsc2UsIHN0cmluZ3MgYXJlIGNvbnNpZGVyZWQgdHJ1ZVxuICAgKiBbY2xySW5saW5lXT1cInRydWV8ZmFsc2VcIiAtIGV4cGVjdCBhIGJvb2xlYW5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBjbHJJbmxpbmUodmFsdWU6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5pbmxpbmUgPSB2YWx1ZSA9PT0gJ2ZhbHNlJyA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbmxpbmUgPSAhIXZhbHVlO1xuICAgIH1cbiAgfVxuICBnZXQgY2xySW5saW5lKCkge1xuICAgIHJldHVybiB0aGlzLmlubGluZTtcbiAgfVxuXG4gIC8vIEBUT0RPIFNvbHZlIGZvciBncm91cCB2YWxpZGF0aW9uLCB3aGljaCBkb2Vzbid0IHdvcmsgbm93IHdpdGggbmdNb2RlbEdyb3VwXG4gIC8vIEJsb2NrZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjAyNjhcbiAgLy8gQElucHV0KClcbiAgLy8gc2V0IGNsckZvcm1Hcm91cCh2YWx1ZTogRm9ybUdyb3VwKSB7XG4gIC8vICAgdGhpcy5mb3JtR3JvdXAgPSB2YWx1ZTtcbiAgLy8gfVxuXG4gIC8vIEBJbnB1dCgpXG4gIC8vIHNldCBjbHJGb3JtQXJyYXkodmFsdWU6IEZvcm1BcnJheSkge1xuICAvLyAgIHRoaXMuZm9ybUdyb3VwID0gdmFsdWU7XG4gIC8vIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICAvLyBAVE9ETyBwdXQgYSBzb2x1dGlvbiBpbiBmb3IgZm9ybSBncm91cCB2YWxpZGF0aW9uXG4gICAgLy8gaWYgKCF0aGlzLmZvcm1Hcm91cCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgLy8gQmVjYXVzZSBuZ01vZGVsIGRvZXMgdGhpcywgd2UgaGF2ZSB0byBkZWxheSBhIHRpY2sgdG8gZ2V0IHRoZSByZXN1bHRcbiAgICAvLyAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIC8vICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAvLyAgICAgICB0aGlzLmZvcm1Hcm91cC5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgLy8gICAgICAgICB0aGlzLmludmFsaWQgPSB0aGlzLmZvcm1Hcm91cC5pbnZhbGlkO1xuICAgIC8vICAgICAgIH0pXG4gICAgLy8gICAgICk7XG4gICAgLy8gICB9KTtcbiAgICAvLyB9XG4gIH1cblxuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSwgdGhpcy5pbmxpbmUgPyAnY2xyLWNvbnRyb2wtaW5saW5lJyA6ICcnKTtcbiAgfVxuXG4gIGFkZEdyaWQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0U2VydmljZSAmJiAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckhvc3RXcmFwcGluZ01vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvaG9zdC13cmFwcGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uRm9ybXNNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vY29tbW9uLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckNoZWNrYm94IH0gZnJvbSAnLi9jaGVja2JveCc7XG5pbXBvcnQgeyBDbHJDaGVja2JveENvbnRhaW5lciB9IGZyb20gJy4vY2hlY2tib3gtY29udGFpbmVyJztcbmltcG9ydCB7IENsckNoZWNrYm94V3JhcHBlciB9IGZyb20gJy4vY2hlY2tib3gtd3JhcHBlcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGUsIENsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJIb3N0V3JhcHBpbmdNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDbHJDaGVja2JveCwgQ2xyQ2hlY2tib3hDb250YWluZXIsIENsckNoZWNrYm94V3JhcHBlcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyQ2hlY2tib3gsIENsckNoZWNrYm94Q29udGFpbmVyLCBDbHJDaGVja2JveFdyYXBwZXJdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJDaGVja2JveFdyYXBwZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDaGVja2JveE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxubGV0IGFjdGl2ZUNvdW50ZXIgPSAwO1xuXG5leHBvcnQgY29uc3QgSUZfQUNUSVZFX0lEID0gbmV3IEluamVjdGlvblRva2VuPG51bWJlcj4oJ0lGX0FDVElWRV9JRCcpO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5GYWN0b3J5KCkge1xuICByZXR1cm4gKythY3RpdmVDb3VudGVyO1xufVxuXG5leHBvcnQgY29uc3QgSUZfQUNUSVZFX0lEX1BST1ZJREVSID0ge1xuICBwcm92aWRlOiBJRl9BQ1RJVkVfSUQsXG4gIHVzZUZhY3Rvcnk6IHRva2VuRmFjdG9yeSxcbn07XG5cbkBJbmplY3RhYmxlKClcblxuLyoqKioqKioqKlxuICogQGNsYXNzIElmQWN0aXZlU2VydmljZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQW4gaW5qZWN0YWJsZSBzZXJ2aWNlIHVzZWQgYnkgSWZBY3RpdmUgc3RydWN0dXJhbCBkaXJlY3RpdmVzIGFuZCB0aGUgY29tcG9uZW50cyB0aGF0IGltcGxlbWVudCBJZkFjdGl2ZSBpbiB0aGVpclxuICogdGVtcGxhdGVzLiBJdCBob2xkcyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHByb3ZpZGVzIGFuIE9ic2VydmFibGUgdGhhdCBib3RoIHRoZSBkaXJlY3RpdmUgYW5kIHRoZVxuICogaW1wbGVtZW50aW5nIGNvbXBvbmVudCBjYW4gc3Vic2NyaWJlIHRvIGluIG9yZGVyIHRvIHRha2UgYWN0aW9uIG9uIGN1cnJlbnQgdmFsdWUgY2hhbmdlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBJZkFjdGl2ZVNlcnZpY2Uge1xuICAvKioqKioqKipcbiAgICogQHByb3BlcnR5IF9jdXJyZW50Q2hhbmdlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIFJYSlMgU3ViamVjdCB0aGF0IHVwZGF0ZXMgYW5kIHByb3ZpZGVzIHN1YnNjcmlwdGlvbnMgdG8gZm9yIHRoZSBjdXJyZW50IGN1cnJlbnQgc3RhdGUgb2YgYSBjb21wb25lbnQgdGVtcGxhdGVcbiAgICogaW1wbGVtdGluZyB0aGUgSWZBY3RpdmUgc3RydWN0dXJhbCBkaXJlY3RpdmUuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9jdXJyZW50Q2hhbmdlOiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG5cbiAgLyoqKioqKioqKlxuICAgKiBAcHJvcGVydHkgX2N1cnJlbnRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgcHJvcGVydHkgaG9sZGluZyB0aGUgY3VycmVudCB2YWx1ZSBmb3IgY3VycmVudC9jbG9zZWQgc3RhdGUgb2YgYW4gSWZBY3RpdmUgc3RydWN0dXJhbCBkaXJlY3RpdmUuXG4gICAqL1xuICBwcml2YXRlIF9jdXJyZW50OiBudW1iZXI7XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBhbiBvYnNlcnZhYmxlIGZvciB0aGUgX2N1cnJlbnQgU3ViamVjdC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudENoYW5nZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIF9jdXJyZW50IGZvciB0aGlzIGluc3RhbmNlIG9mIElmQWN0aXZlIHN0cnVjdHVyYWwgZGlyZWN0aXZlLlxuICAgKiBBbmQsIGJyb2FkY2FzdHMgdGhlIG5ldyB2YWx1ZSB0byBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHNldCBjdXJyZW50KHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodGhpcy5fY3VycmVudCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoaXMgSWZBY3RpdmUgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSUZfQUNUSVZFX0lELCBJZkFjdGl2ZVNlcnZpY2UgfSBmcm9tICcuL2lmLWFjdGl2ZS5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklmQWN0aXZlXScgfSlcblxuLyoqKioqKioqKipcbiAqXG4gKiBAY2xhc3MgQ2xySWZBY3RpdmVcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RydWN0dXJhbCBkaXJlY3RpdmUgdGhhdCBjb250cm9scyB3aGV0aGVyIG9yIG5vdCB0aGUgYXNzb2NpYXRlZCBUZW1wbGF0ZVJlZiBpcyBpbnN0YW50aWF0ZWQgb3Igbm90LlxuICogSXQgbWFrZXMgdXNlIG9mIGEgQ29tcG9uZW50IGluc3RhbmNlIGxldmVsIHNlcnZpY2U6IElmQWN0aXZlU2VydmljZSB0byBtYWludGFpbiBzdGF0ZSBiZXR3ZWVuIGl0c2VsZiBhbmRcbiAqIHRoZSBjb21wb25lbnQgdXNpbmcgaXQgaW4gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJJZkFjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgd2FzQWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkFjdGl2ZVNlcnZpY2U6IElmQWN0aXZlU2VydmljZSxcbiAgICBASW5qZWN0KElGX0FDVElWRV9JRCkgcHJpdmF0ZSBpZDogbnVtYmVyLFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7XG4gICAgdGhpcy5jaGVja0FuZFVwZGF0ZVZpZXcoaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQpO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50Q2hhbmdlLnN1YnNjcmliZShuZXdDdXJyZW50SWQgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZFVwZGF0ZVZpZXcobmV3Q3VycmVudElkKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tBbmRVcGRhdGVWaWV3KGN1cnJlbnRJZDogbnVtYmVyKSB7XG4gICAgY29uc3QgaXNOb3dBY3RpdmUgPSBjdXJyZW50SWQgPT09IHRoaXMuaWQ7XG4gICAgLy8gb25seSBlbWl0IGlmIHRoZSBuZXcgYWN0aXZlIHN0YXRlIGlzIGNoYW5nZWQgc2luY2UgbGFzdCB0aW1lLlxuICAgIGlmIChpc05vd0FjdGl2ZSAhPT0gdGhpcy53YXNBY3RpdmUpIHtcbiAgICAgIHRoaXMudXBkYXRlVmlldyhpc05vd0FjdGl2ZSk7XG4gICAgICB0aGlzLmFjdGl2ZUNoYW5nZS5lbWl0KGlzTm93QWN0aXZlKTtcbiAgICAgIHRoaXMud2FzQWN0aXZlID0gaXNOb3dBY3RpdmU7XG4gICAgfVxuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBzZXR0ZXIgdGhhdCB1cGRhdGVzIElmQWN0aXZlU2VydmljZS5hY3RpdmUgd2l0aCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBASW5wdXQoJ2NscklmQWN0aXZlJylcbiAgcHVibGljIHNldCBhY3RpdmUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPSB0aGlzLmlkO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBhY3RpdmVDaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBlbWl0cyB3aGVuIHRoZSBhY3RpdmUgcHJvcGVydHkgaXMgc2V0IHRvIGFsbG93IGZvciAyd2F5IGJpbmRpbmcgd2hlbiB0aGUgZGlyZWN0aXZlIGlzXG4gICAqIHVzZWQgd2l0aCBkZS1zdHJ1Y3R1cmVkIC8gZGUtc3VnYXJlZCBzeW50YXguXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJJZkFjdGl2ZUNoYW5nZScpIGFjdGl2ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgLyoqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgSWZBY3RpdmVTZXJ2aWNlLmFjdGl2ZSB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50ID09PSB0aGlzLmlkO1xuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRnVuY3Rpb24gdGhhdCB0YWtlcyBhIGFueSB2YWx1ZSBhbmQgZWl0aGVyIGNyZWF0ZWQgYW4gZW1iZWRkZWQgdmlldyBmb3IgdGhlIGFzc29jaWF0ZWQgVmlld0NvbnRhaW5lclJlZiBvcixcbiAgICogQ2xlYXJzIGFsbCB2aWV3cyBmcm9tIHRoZSBWaWV3Q29udGFpbmVyUmVmXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHVwZGF0ZVZpZXcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcblxuLyoqKioqKioqKlxuICogQGNsYXNzIElmT3BlblNlcnZpY2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuIGluamVjdGFibGUgc2VydmljZSB1c2VkIGJ5IElmT3BlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXMgYW5kIHRoZSBjb21wb25lbnRzIHRoYXQgaW1wbGVtbnQgSWZPcGVuIGluIHRoZWlyXG4gKiB0ZW1wbGF0ZXMuIEl0IGhvbGRzIHRoZSB2YWx1ZSBvZiB0aGUgb3BlbiBzdGF0ZSBhbmQgcHJvdmlkZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGJvdGggdGhlIGRpcmVjdGl2ZSBhbmQgdGhlXG4gKiBpbXBsZW1lbnRpbmcgY29tcG9uZW50IGNhbiBzdWJzY3JpYmUgdG8gaW4gb3JkZXIgdG8gdGFrZSBhY3Rpb24gb24gb3BlbiB2YWx1ZSBjaGFuZ2VzLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIElmT3BlblNlcnZpY2Uge1xuICAvKioqKioqKipcbiAgICogQHByb3BlcnR5IF9vcGVuQ2hhbmdlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIFJYSlMgU3ViamVjdCB0aGF0IHVwZGF0ZXMgYW5kIHByb3ZpZGVzIHN1YnNjcmlwdGlvbnMgdG8gZm9yIHRoZSBjdXJyZW50IG9wZW4gc3RhdGUgb2YgYSBjb21wb25lbnQgdGVtcGxhdGVcbiAgICogaW1wbGVtdGluZyB0aGUgSWZPcGVuIHN0cnVjdHVyYWwgZGlyZWN0aXZlLlxuICAgKi9cbiAgcHJpdmF0ZSBfb3BlbkNoYW5nZTogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgLyoqKioqKioqKlxuICAgKiBAcHJvcGVydHkgX29wZW5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgcHJvcGVydHkgaG9sZGluZyB0aGUgY3VycmVudCB2YWx1ZSBmb3Igb3Blbi9jbG9zZWQgc3RhdGUgb2YgYW4gSWZPcGVuIHN0cnVjdHVyYWwgZGlyZWN0aXZlLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfb3BlbjogYm9vbGVhbjtcblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIGFuIG9ic2VydmFibGUgZm9yIHRoZSBfb3BlbmVkIFN1YmplY3QuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IG9wZW5DaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW5DaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHNldHRlciBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgX29wZW4gZm9yIHRoaXMgaW5zdGFuY2Ugb2YgSWZPcGVuIHN0cnVjdHVyYWwgZGlyZWN0aXZlLiBBbmQsXG4gICAqIGJyb2FkY2FzdHMgdGhlIG5ldyB2YWx1ZSB0byBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh0aGlzLl9vcGVuICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fb3BlbiA9IHZhbHVlO1xuICAgICAgdGhpcy5fb3BlbkNoYW5nZS5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBJZk9wZW4gaW5zdGFuY2UuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IG9wZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICAvKipcbiAgICogU29tZXRpbWVzLCB3ZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBldmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgdG9nZ2xpbmcgdG8gYXZvaWQgbG9vcHMuXG4gICAqIFRoaXMgaXMgZm9yIGluc3RhbmNlIHRoZSBjYXNlIG9mIGNvbXBvbmVudHMgdGhhdCBvcGVuIG9uIGEgY2xpY2ssIGJ1dCBjbG9zZSBvbiBhIGNsaWNrIG91dHNpZGUuXG4gICAqL1xuICBwdWJsaWMgb3JpZ2luYWxFdmVudDogYW55O1xuICBwdWJsaWMgdG9nZ2xlV2l0aEV2ZW50KGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuO1xuICAgIGRlbGV0ZSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gIH1cblxuICAvKipcbiAgICogIFBvcG92ZXJzIG1pZ2h0IG5lZWQgdG8gaWdub3JlIGNsaWNrIGV2ZW50cyBvbiBhbiBlbGVtZW50XG4gICAqICAoZWc6IHBvcG92ZXIgb3BlbnMgb24gZm9jdXMgb24gYW4gaW5wdXQgZmllbGQuIENsaWNrcyBzaG91bGQgYmUgaWdub3JlZCBpbiB0aGlzIGNhc2UpXG4gICAqL1xuICBwcml2YXRlIF9pZ25vcmVkRWxlbWVudENoYW5nZTogU3ViamVjdDxFbGVtZW50UmVmPiA9IG5ldyBTdWJqZWN0PEVsZW1lbnRSZWY+KCk7XG5cbiAgZ2V0IGlnbm9yZWRFbGVtZW50Q2hhbmdlKCk6IE9ic2VydmFibGU8RWxlbWVudFJlZj4ge1xuICAgIHJldHVybiB0aGlzLl9pZ25vcmVkRWxlbWVudENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHJlZ2lzdGVySWdub3JlZEVsZW1lbnQoZWxlbWVudDogRWxlbWVudFJlZikge1xuICAgIHRoaXMuX2lnbm9yZWRFbGVtZW50Q2hhbmdlLm5leHQoZWxlbWVudCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4vaWYtb3Blbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklmT3Blbl0nIH0pXG5cbi8qKioqKioqKioqXG4gKlxuICogQGNsYXNzIENscklmT3BlblxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB0aGF0IGNvbnRyb2xzIHdoZXRoZXIgb3Igbm90IHRoZSBhc3NvY2lhdGVkIFRlbXBsYXRlUmVmIGlzIGluc3RhbnRpYXRlZCBvciBub3QuXG4gKiBJdCBtYWtlcyB1c2Ugb2YgYSBDb21wb25lbnQgaW5zdGFuY2UgbGV2ZWwgc2VydmljZTogSWZPcGVuU2VydmljZSB0byBtYWludGFpbiBzdGF0ZSBiZXR3ZWVuIGl0c2VsZiBhbmQgdGhlIGNvbXBvbmVudFxuICogdXNpbmcgaXQgaW4gdGhlIGNvbXBvbmVudCB0ZW1wbGF0ZS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJJZk9wZW4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgc2V0dGVyIHRoYXQgdXBkYXRlcyBJZk9wZW5TZXJ2aWNlLm9wZW4gd2l0aCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBASW5wdXQoJ2NscklmT3BlbicpXG4gIHB1YmxpYyBzZXQgb3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gdmFsdWU7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKiBAcHJvcGVydHkgb3BlbkNoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQW4gZXZlbnQgZW1pdHRlciB0aGF0IGVtaXRzIHdoZW4gdGhlIG9wZW4gcHJvcGVydHkgaXMgc2V0IHRvIGFsbG93IGZvciAyd2F5IGJpbmRpbmcgd2hlbiB0aGUgZGlyZWN0aXZlIGlzXG4gICAqIHVzZWQgd2l0aCBkZS1zdHJ1Y3R1cmVkIC8gZGUtc3VnYXJlZCBzeW50YXguXG4gICAqL1xuICBAT3V0cHV0KCdjbHJJZk9wZW5DaGFuZ2UnKSBvcGVuQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICAvKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBJZk9wZW5TZXJ2aWNlLm9wZW4gdmFsdWUuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IG9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVmlldyhjaGFuZ2UpO1xuICAgICAgdGhpcy5vcGVuQ2hhbmdlLmVtaXQoY2hhbmdlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBib29sZWFuIHZhbHVlIGFuZCBlaXRoZXIgY3JlYXRlZCBhbiBlbWJlZGRlZCB2aWV3IGZvciB0aGUgYXNzb2NpYXRlZCBWaWV3Q29udGFpbmVyUmVmIG9yLFxuICAgKiBDbGVhcnMgYWxsIHZpZXdzIGZyb20gdGhlIFZpZXdDb250YWluZXJSZWZcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlVmlldyh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENscklmQWN0aXZlIH0gZnJvbSAnLi9pZi1hY3RpdmUuZGlyZWN0aXZlJztcbmltcG9ydCB7IENscklmT3BlbiB9IGZyb20gJy4vaWYtb3Blbi5kaXJlY3RpdmUnO1xuXG5leHBvcnQgKiBmcm9tICcuL2lmLWFjdGl2ZS5kaXJlY3RpdmUnO1xuZXhwb3J0ICogZnJvbSAnLi9pZi1vcGVuLmRpcmVjdGl2ZSc7XG5cbmV4cG9ydCBjb25zdCBDT05ESVRJT05BTF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJJZkFjdGl2ZSwgQ2xySWZPcGVuXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDT05ESVRJT05BTF9ESVJFQ1RJVkVTIH0gZnJvbSAnLi9pbmRleCc7XG5cbkBOZ01vZHVsZSh7IGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBkZWNsYXJhdGlvbnM6IFtDT05ESVRJT05BTF9ESVJFQ1RJVkVTXSwgZXhwb3J0czogW0NPTkRJVElPTkFMX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xyQ29uZGl0aW9uYWxNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvY3VzVHJhcERpcmVjdGl2ZSB9IGZyb20gJy4vZm9jdXMtdHJhcC5kaXJlY3RpdmUnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEZvY3VzVHJhcFRyYWNrZXIge1xuICBwcml2YXRlIF9wcmV2aW91c0ZvY3VzVHJhcHM6IEZvY3VzVHJhcERpcmVjdGl2ZVtdID0gW107XG4gIHByaXZhdGUgX2N1cnJlbnQ6IEZvY3VzVHJhcERpcmVjdGl2ZTtcblxuICBnZXQgY3VycmVudCgpOiBGb2N1c1RyYXBEaXJlY3RpdmUge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50O1xuICB9XG5cbiAgc2V0IGN1cnJlbnQodmFsdWU6IEZvY3VzVHJhcERpcmVjdGl2ZSkge1xuICAgIHRoaXMuX3ByZXZpb3VzRm9jdXNUcmFwcy5wdXNoKHRoaXMuX2N1cnJlbnQpO1xuICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBuYkZvY3VzVHJhcHBlcnMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNGb2N1c1RyYXBzLmxlbmd0aDtcbiAgfVxuXG4gIGFjdGl2YXRlUHJldmlvdXNUcmFwcGVyKCkge1xuICAgIHRoaXMuX2N1cnJlbnQgPSB0aGlzLl9wcmV2aW91c0ZvY3VzVHJhcHMucG9wKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERPQ1VNRU5ULCBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBQTEFURk9STV9JRCxcbiAgUmVuZGVyZXIyLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRm9jdXNUcmFwVHJhY2tlciB9IGZyb20gJy4vZm9jdXMtdHJhcC10cmFja2VyLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyRm9jdXNUcmFwXScgfSlcbmV4cG9ydCBjbGFzcyBGb2N1c1RyYXBEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHByZXZpb3VzQWN0aXZlRWxlbWVudDogYW55O1xuICBwcml2YXRlIGRvY3VtZW50OiBEb2N1bWVudDtcblxuICBwcml2YXRlIHRvcFJlYm91bmRFbDogYW55O1xuICBwcml2YXRlIGJvdHRvbVJlYm91bmRFbDogYW55O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBmb2N1c1RyYXBzVHJhY2tlcjogRm9jdXNUcmFwVHJhY2tlcixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3RcbiAgKSB7XG4gICAgdGhpcy5kb2N1bWVudCA9IHRoaXMuaW5qZWN0b3IuZ2V0KERPQ1VNRU5UKTtcbiAgICB0aGlzLmZvY3VzVHJhcHNUcmFja2VyLmN1cnJlbnQgPSB0aGlzO1xuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndGFiaW5kZXgnLCAnMCcpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Zm9jdXNpbicsIFsnJGV2ZW50J10pXG4gIG9uRm9jdXNJbihldmVudDogYW55KSB7XG4gICAgY29uc3QgbmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5mb2N1c1RyYXBzVHJhY2tlci5jdXJyZW50ID09PSB0aGlzICYmIGV2ZW50LnRhcmdldCAmJiAhbmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICBuYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVGb2N1c2FibGVPZmZTY3JlZW5FbCgpOiBhbnkge1xuICAgIC8vIE5vdCB1c2luZyBSZW5kZXJlcjIncyBjcmVhdGVFbGVtZW50IG1ldGhvZCBiZWNhdXNlIHRoYXQgbGVhZHMgdG8gRE9NIGxlYWthZ2UuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMjY5NTRcbiAgICBjb25zdCBvZmZTY3JlZW5TcGFuID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUob2ZmU2NyZWVuU3BhbiwgJ3RhYmluZGV4JywgJzAnKTtcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKG9mZlNjcmVlblNwYW4sICdvZmZzY3JlZW4tZm9jdXMtcmVib3VuZGVyJyk7XG5cbiAgICByZXR1cm4gb2ZmU2NyZWVuU3BhbjtcbiAgfVxuXG4gIHByaXZhdGUgYWRkUmVib3VuZEVscygpIHtcbiAgICAvLyBXZSB3aWxsIGFkZCB0aGVzZSBmb2N1cyByZWJvdW5kaW5nIGVsZW1lbnRzIG9ubHkgaW4gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgIC8vIDEuIEl0IHNob3VsZCBiZSBydW5uaW5nIGluc2lkZSBicm93c2VyIHBsYXRmb3JtIGFzIGl0IGFjY2Vzc2VzIGRvY3VtZW50LmJvZHkgZWxlbWVudFxuICAgIC8vIDIuIFdlIHNob3VsZCBOT1QgYWRkIHRoZW0gbW9yZSB0aGFuIG9uY2UuIEhlbmNlLCB3ZSBhcmUgY291bnRpbmcgYSBudW1iZXIgb2YgZm9jdXMgdHJhcHBlcnNcbiAgICAvLyAgICBhbmQgb25seSBhZGQgb24gdGhlIGZpcnN0IGZvY3VzIHRyYXBwZXIuXG5cbiAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLmZvY3VzVHJhcHNUcmFja2VyLm5iRm9jdXNUcmFwcGVycyA9PT0gMSkge1xuICAgICAgdGhpcy50b3BSZWJvdW5kRWwgPSB0aGlzLmNyZWF0ZUZvY3VzYWJsZU9mZlNjcmVlbkVsKCk7XG4gICAgICB0aGlzLmJvdHRvbVJlYm91bmRFbCA9IHRoaXMuY3JlYXRlRm9jdXNhYmxlT2ZmU2NyZWVuRWwoKTtcbiAgICAgIC8vIEFkZCByZWJvdW5kQmVmb3JlVHJhcEVsIHRvIHRoZSBkb2N1bWVudCBib2R5IGFzIHRoZSBmaXJzdCBjaGlsZFxuICAgICAgdGhpcy5yZW5kZXJlci5pbnNlcnRCZWZvcmUodGhpcy5kb2N1bWVudC5ib2R5LCB0aGlzLnRvcFJlYm91bmRFbCwgdGhpcy5kb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgLy8gQWRkIHJlYm91bmRBZnRlclRyYXBFbCB0byB0aGUgZG9jdW1lbnQgYm9keSBhcyB0aGUgbGFzdCBjaGlsZFxuICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLmRvY3VtZW50LmJvZHksIHRoaXMuYm90dG9tUmVib3VuZEVsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVJlYm91bmRFbHMoKSB7XG4gICAgaWYgKFxuICAgICAgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJlxuICAgICAgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5uYkZvY3VzVHJhcHBlcnMgPT09IDEgJiZcbiAgICAgIHRoaXMudG9wUmVib3VuZEVsICYmXG4gICAgICB0aGlzLmJvdHRvbVJlYm91bmRFbFxuICAgICkge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDaGlsZCh0aGlzLmRvY3VtZW50LmJvZHksIHRoaXMudG9wUmVib3VuZEVsKTtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQodGhpcy5kb2N1bWVudC5ib2R5LCB0aGlzLmJvdHRvbVJlYm91bmRFbCk7XG5cbiAgICAgIC8vIFRoZXNlIGFyZSBoZXJlIHRvIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAvLyB3ZSBjb21wbGV0ZWx5IGRlbGV0ZSBhbGwgdHJhY2VzIG9mIHRoZSByZW1vdmVkIERPTSBvYmplY3RzLlxuICAgICAgZGVsZXRlIHRoaXMudG9wUmVib3VuZEVsO1xuICAgICAgZGVsZXRlIHRoaXMuYm90dG9tUmVib3VuZEVsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXRQcmV2aW91c0ZvY3VzKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudCAmJiB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cykge1xuICAgICAgdGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gPEhUTUxFbGVtZW50PnRoaXMuZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFJlYm91bmRFbHMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucmVtb3ZlUmVib3VuZEVscygpO1xuICAgIHRoaXMuc2V0UHJldmlvdXNGb2N1cygpO1xuICAgIHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIuYWN0aXZhdGVQcmV2aW91c1RyYXBwZXIoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9jdXNUcmFwRGlyZWN0aXZlIH0gZnJvbSAnLi9mb2N1cy10cmFwLmRpcmVjdGl2ZSc7XG5cbmV4cG9ydCBjb25zdCBGT0NVU19UUkFQX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0ZvY3VzVHJhcERpcmVjdGl2ZV07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRk9DVVNfVFJBUF9ESVJFQ1RJVkVTIH0gZnJvbSAnLi9pbmRleCc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtGT0NVU19UUkFQX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbRk9DVVNfVFJBUF9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRm9jdXNUcmFwTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE3IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgY29uc3QgVVBfQVJST1c6IG51bWJlciA9IDM4O1xuZXhwb3J0IGNvbnN0IERPV05fQVJST1c6IG51bWJlciA9IDQwO1xuZXhwb3J0IGNvbnN0IFJJR0hUX0FSUk9XOiBudW1iZXIgPSAzOTtcbmV4cG9ydCBjb25zdCBMRUZUX0FSUk9XOiBudW1iZXIgPSAzNztcbmV4cG9ydCBjb25zdCBFTlRFUjogbnVtYmVyID0gMTM7XG5leHBvcnQgY29uc3QgU1BBQ0U6IG51bWJlciA9IDMyO1xuZXhwb3J0IGNvbnN0IFRBQjogbnVtYmVyID0gOTtcbmV4cG9ydCBjb25zdCBFU0M6IG51bWJlciA9IDI3O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGVuLTAwMSBzaG9ydCBsb2NhbGUgZGF0ZSBmb3JtYXQuIFNldHRpbmcgYXMgZGVmYXVsdC5cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTE9DQUxFX0ZPUk1BVDogc3RyaW5nID0gJ2RkL01NL3knO1xuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYXRlX2Zvcm1hdF9ieV9jb3VudHJ5XG5leHBvcnQgY29uc3QgTElUVExFX0VORElBTl9SRUdFWDogUmVnRXhwID0gL2QrLittKy4reSsvaTtcbmV4cG9ydCBjb25zdCBNSURETEVfRU5ESUFOX1JFR0VYOiBSZWdFeHAgPSAvbSsuK2QrLit5Ky9pO1xuLy8gTm8gbmVlZCBmb3IgQklHX0VORElBTl9SRUdFWCBiZWNhdXNlIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzYXRpc2Z5IHRoZSBhYm92ZSAyXG4vLyBpcyBhdXRvbWF0aWNhbGx5IEJJR19FTkRJQU5cblxuZXhwb3J0IGNvbnN0IERFTElNSVRFUl9SRUdFWDogUmVnRXhwID0gL2QrfG0rfHkrL2k7XG5cbmV4cG9ydCBjb25zdCBVU0VSX0lOUFVUX1JFR0VYOiBSZWdFeHAgPSAvXFxkKy9nO1xuXG5leHBvcnQgY29uc3QgTU9CSUxFX1VTRVJBR0VOVF9SRUdFWDogUmVnRXhwID0gL01vYmkvaTtcblxuZXhwb3J0IGNvbnN0IFJUTF9SRUdFWDogUmVnRXhwID0gL1xcdTIwMGYvZztcblxuZXhwb3J0IGNvbnN0IFlFQVI6IHN0cmluZyA9ICdZWVlZJztcbmV4cG9ydCBjb25zdCBNT05USDogc3RyaW5nID0gJ01NJztcbmV4cG9ydCBjb25zdCBEQVRFOiBzdHJpbmcgPSAnREQnO1xuXG5leHBvcnQgdHlwZSBGb3JtYXRUeXBlID0gJ0xJVFRMRV9FTkRJQU4nIHwgJ01JRERMRV9FTkRJQU4nIHwgJ0JJR19FTkRJQU4nO1xuXG5leHBvcnQgdHlwZSBJbnB1dERhdGVEaXNwbGF5Rm9ybWF0ID0ge1xuICByZWFkb25seSBuYW1lOiBGb3JtYXRUeXBlO1xuICByZWFkb25seSBmb3JtYXQ6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXTtcbn07XG5cbmV4cG9ydCBjb25zdCBMSVRUTEVfRU5ESUFOOiBJbnB1dERhdGVEaXNwbGF5Rm9ybWF0ID0ge1xuICBuYW1lOiAnTElUVExFX0VORElBTicsXG4gIGZvcm1hdDogW0RBVEUsIE1PTlRILCBZRUFSXSxcbn07XG5cbmV4cG9ydCBjb25zdCBNSURETEVfRU5ESUFOOiBJbnB1dERhdGVEaXNwbGF5Rm9ybWF0ID0ge1xuICBuYW1lOiAnTUlERExFX0VORElBTicsXG4gIGZvcm1hdDogW01PTlRILCBEQVRFLCBZRUFSXSxcbn07XG5cbmV4cG9ydCBjb25zdCBCSUdfRU5ESUFOOiBJbnB1dERhdGVEaXNwbGF5Rm9ybWF0ID0ge1xuICBuYW1lOiAnQklHX0VORElBTicsXG4gIGZvcm1hdDogW1lFQVIsIE1PTlRILCBEQVRFXSxcbn07XG5cbmV4cG9ydCBjb25zdCBOT19PRl9EQVlTX0lOX0FfV0VFSzogbnVtYmVyID0gNztcbmV4cG9ydCBjb25zdCBOT19PRl9ST1dTX0lOX0NBTEVOREFSX1ZJRVc6IG51bWJlciA9IDY7XG5leHBvcnQgY29uc3QgVE9UQUxfREFZU19JTl9EQVlTX1ZJRVc6IG51bWJlciA9IE5PX09GX0RBWVNfSU5fQV9XRUVLICogTk9fT0ZfUk9XU19JTl9DQUxFTkRBUl9WSUVXO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBXZWVrRGF5IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiBhIG1vbnRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpOiBudW1iZXIge1xuICAvLyBJZiB3ZSBnbyB0byB0aGUgbmV4dCBtb250aCwgYnV0IHVzZSBhIGRheSBvZiAwLCBpdCByZXR1cm5zIHRoZSBsYXN0IGRheSBmcm9tIHRoZSBwcmV2aW91cyBtb250aFxuICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAwKS5nZXREYXRlKCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF5IGZvciB0aGUgY29ycmVzcG9uZGluZyBkYXRlIHdoZXJlIDAgcmVwcmVzZW50cyBTdW5kYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXkoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpOiBXZWVrRGF5IHtcbiAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXRlKS5nZXREYXkoKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBpbiBhIHllYXIgYW5kIGlmIGl0IGlzIGEgMiBkaWdpdCB5ZWFyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIDQgZGlnaXQgeWVhci5cbiAqIFdpbmRvdyBvZiA4MCB5ZWFycyBiZWZvcmUgYW5kIDIwIHllYXJzIGFmdGVyIHRoZSBwcmVzZW50IHllYXIuXG4gKiBDcmVkaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9nbG9iYWxpemVqcy9nbG9iYWxpemUvYmxvYi9lMWIzMWNkNmE0ZjFjZmY3NWIxODViNjhiN2EzMjIyMGFhYzUxOTZmL3NyYy9kYXRlL3BhcnNlLmpzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRvRm91ckRpZ2l0WWVhcih5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoeWVhciA+IDk5OTkgfHwgKHllYXIgPiAxMDAgJiYgeWVhciA8IDk5OSkgfHwgeWVhciA8IDEwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5ZWFyID4gOTk5KSB7XG4gICAgcmV0dXJuIHllYXI7XG4gIH1cbiAgY29uc3QgY3VyclllYXI6IG51bWJlciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3QgY2VudHVyeTogbnVtYmVyID0gTWF0aC5mbG9vcihjdXJyWWVhciAvIDEwMCkgKiAxMDA7XG4gIGxldCByZXN1bHQ6IG51bWJlciA9IHllYXIgKyBjZW50dXJ5O1xuICBpZiAocmVzdWx0ID4gY3VyclllYXIgKyAyMCkge1xuICAgIHJlc3VsdCA9IHJlc3VsdCAtIDEwMDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vZGF5Lm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIERheVZpZXdNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBkYXlNb2RlbDogRGF5TW9kZWwsXG4gICAgcHVibGljIGlzVG9kYXlzRGF0ZTogYm9vbGVhbiA9IGZhbHNlLFxuICAgIHB1YmxpYyBpc0Rpc2FibGVkOiBib29sZWFuID0gZmFsc2UsXG4gICAgcHVibGljIGlzU2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBwdWJsaWMgaXNGb2N1c2FibGU6IGJvb2xlYW4gPSBmYWxzZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRhYiBpbmRleCBiYXNlZCBvbiB0aGUgaXNGb2N1c2FibGUgZmxhZy5cbiAgICovXG4gIGdldCB0YWJJbmRleCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmlzRm9jdXNhYmxlID8gMCA6IC0xO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IGdldE51bWJlck9mRGF5c0luVGhlTW9udGggfSBmcm9tICcuLi91dGlscy9kYXRlLXV0aWxzJztcblxuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL2RheS5tb2RlbCc7XG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhck1vZGVsIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHllYXI6IG51bWJlciwgcHVibGljIHJlYWRvbmx5IG1vbnRoOiBudW1iZXIpIHtcbiAgICB0aGlzLmluaXRpYWxpemVEYXlzSW5DYWxlbmRhcigpO1xuICB9XG5cbiAgZGF5czogRGF5TW9kZWxbXTtcblxuICAvKipcbiAgICogUG9wdWxhdGVzIHRoZSBkYXlzIGFycmF5IHdpdGggdGhlIERheU1vZGVscyBpbiB0aGUgY3VycmVudCBDYWxlbmRhci5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZURheXNJbkNhbGVuZGFyKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vT2ZEYXlzSW5DYWxlbmRhcjogbnVtYmVyID0gZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICAgIHRoaXMuZGF5cyA9IEFycmF5KG5vT2ZEYXlzSW5DYWxlbmRhcilcbiAgICAgIC5maWxsKG51bGwpXG4gICAgICAubWFwKChkYXRlLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IERheU1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCwgaW5kZXggKyAxKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY2FsZW5kYXIgcGFzc2VkIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGNhbGVuZGFyLlxuICAgKi9cbiAgaXNFcXVhbChjYWxlbmRhcjogQ2FsZW5kYXJNb2RlbCkge1xuICAgIGlmIChjYWxlbmRhcikge1xuICAgICAgcmV0dXJuIHRoaXMueWVhciA9PT0gY2FsZW5kYXIueWVhciAmJiB0aGlzLm1vbnRoID09PSBjYWxlbmRhci5tb250aDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIERheU1vZGVsIGlzIGluIHRoZSBDYWxlbmRhclxuICAgKi9cbiAgaXNEYXlJbkNhbGVuZGFyKGRheTogRGF5TW9kZWwpOiBib29sZWFuIHtcbiAgICBpZiAoZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy55ZWFyID09PSBkYXkueWVhciAmJiB0aGlzLm1vbnRoID09PSBkYXkubW9udGg7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIENhbGVuZGFyTW9kZWwgb2YgdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgcHJldmlvdXNNb250aCgpOiBDYWxlbmRhck1vZGVsIHtcbiAgICBpZiAodGhpcy5tb250aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhck1vZGVsKHRoaXMueWVhciAtIDEsIDExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhck1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIENhbGVuZGFyTW9kZWwgb2YgdGhlIG5leHQgbW9udGguXG4gICAqL1xuICBuZXh0TW9udGgoKTogQ2FsZW5kYXJNb2RlbCB7XG4gICAgaWYgKHRoaXMubW9udGggPT09IDExKSB7XG4gICAgICByZXR1cm4gbmV3IENhbGVuZGFyTW9kZWwodGhpcy55ZWFyICsgMSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnllYXIsIHRoaXMubW9udGggKyAxKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ2FsZW5kYXJNb2RlbCB9IGZyb20gJy4vY2FsZW5kYXIubW9kZWwnO1xuXG5leHBvcnQgY2xhc3MgRGF5TW9kZWwge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgeWVhcjogbnVtYmVyLCBwdWJsaWMgcmVhZG9ubHkgbW9udGg6IG51bWJlciwgcHVibGljIHJlYWRvbmx5IGRhdGU6IG51bWJlcikge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ2FsZW5kYXIgZm9yIHRoZSBjdXJyZW50IERheU1vZGVsLlxuICAgKi9cbiAgZ2V0IGNhbGVuZGFyKCk6IENhbGVuZGFyTW9kZWwge1xuICAgIHJldHVybiBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGFzc2VkIENhbGVuZGFyRGF0ZSBpcyBlcXVhbCB0byBpdHNlbGYuXG4gICAqL1xuICBpc0VxdWFsKGRheTogRGF5TW9kZWwpIHtcbiAgICBpZiAoZGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy55ZWFyID09PSBkYXkueWVhciAmJiB0aGlzLm1vbnRoID09PSBkYXkubW9udGggJiYgdGhpcy5kYXRlID09PSBkYXkuZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBDYWxlbmRhckRhdGUgaW50byB0aGUgSmF2YXNjcmlwdCBEYXRlIG9iamVjdC5cbiAgICovXG4gIHRvRGF0ZSgpOiBEYXRlIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgRGF5TW9kZWwgd2hpY2ggaXMgaW5jcmVtZW50ZWQgYmFzZWQgb24gdGhlIHZhbHVlIHBhc3NlZC5cbiAgICovXG4gIGluY3JlbWVudEJ5KHZhbHVlOiBudW1iZXIpOiBEYXlNb2RlbCB7XG4gICAgLy8gQ3JlYXRpbmcgbmV3IEphdmFzY3JpcHQgRGF0ZSBvYmplY3QgdG8gaW5jcmVtZW50IGJlY2F1c2VcbiAgICAvLyBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgdGFrZSBjYXJlIG9mIHN3aXRjaGluZyB0byBuZXh0IG9yIHByZXZpb3VzXG4gICAgLy8gbW9udGhzICYgeWVhcnMgd2l0aG91dCB3ZSBoYXZpbmcgdG8gd29ycnkgYWJvdXQgaXQuXG4gICAgY29uc3QgZGF0ZTogRGF0ZSA9IG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXRlICsgdmFsdWUpO1xuICAgIHJldHVybiBuZXcgRGF5TW9kZWwoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9uZXMgdGhlIGN1cnJlbnQgZGF5IG1vZGVsLlxuICAgKi9cbiAgY2xvbmUoKTogRGF5TW9kZWwge1xuICAgIHJldHVybiBuZXcgRGF5TW9kZWwodGhpcy55ZWFyLCB0aGlzLm1vbnRoLCB0aGlzLmRhdGUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IE5PX09GX0RBWVNfSU5fQV9XRUVLLCBOT19PRl9ST1dTX0lOX0NBTEVOREFSX1ZJRVcsIFRPVEFMX0RBWVNfSU5fREFZU19WSUVXIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERheSB9IGZyb20gJy4uL3V0aWxzL2RhdGUtdXRpbHMnO1xuXG5pbXBvcnQgeyBDYWxlbmRhck1vZGVsIH0gZnJvbSAnLi9jYWxlbmRhci5tb2RlbCc7XG5pbXBvcnQgeyBEYXlWaWV3TW9kZWwgfSBmcm9tICcuL2RheS12aWV3Lm1vZGVsJztcbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi9kYXkubW9kZWwnO1xuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgY2FsZW5kYXI6IENhbGVuZGFyTW9kZWwsXG4gICAgcHJpdmF0ZSBzZWxlY3RlZERheTogRGF5TW9kZWwsXG4gICAgcHJpdmF0ZSBmb2N1c2FibGVEYXk6IERheU1vZGVsLFxuICAgIHByaXZhdGUgdG9kYXk6IERheU1vZGVsLFxuICAgIHB1YmxpYyBmaXJzdERheU9mV2VlazogbnVtYmVyXG4gICkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZUNhbGVuZGFyVmlldygpO1xuICB9XG5cbiAgcHJpdmF0ZSBjdXJyTW9udGhEYXlWaWV3czogRGF5Vmlld01vZGVsW10gPSBbXTtcblxuICBwcml2YXRlIF9jYWxlbmRhclZpZXc6IERheVZpZXdNb2RlbFtdW107XG5cbiAgLyoqXG4gICAqIERheVZpZXdNb2RlbCBtYXRyaXguIFNpemUgNng3XG4gICAqL1xuICBnZXQgY2FsZW5kYXJWaWV3KCk6IERheVZpZXdNb2RlbFtdW10ge1xuICAgIHJldHVybiB0aGlzLl9jYWxlbmRhclZpZXc7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgNng3IG1hdHJpeCBvZiBEYXlWaWV3TW9kZWwgYmFzZWQgb24gdGhlIENhbGVuZGFyLlxuICAgKiBUaGUgNng3IG1hdHJpeCBpcyBzdHJ1Y3R1cmVkIGFjY29yZGluZyB0byB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiA2IHJvd3MgdG8gYWNjb21tb2RhdGUgbW9udGhzIHdoaWNoIG1pZ2h0IGhhdmUgZGF0ZXMgc3Bhbm5pbmcgb3ZlciA2IHdlZWtzLlxuICAgKiA3IGNvbHVtbnMgYmVjYXVzZSB0aGVyZSBhcmUgNyBkYXlzIGluIGEgd2VlayA6UCA6RFxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplQ2FsZW5kYXJWaWV3KCk6IHZvaWQge1xuICAgIC8vIEdlbmVyYXRlIHByZXYgYW5kIG5leHQgbW9udGggY2FsZW5kYXIgbW9kZWxzLlxuICAgIGNvbnN0IHByZXZNb250aENhbGVuZGFyOiBDYWxlbmRhck1vZGVsID0gdGhpcy5jYWxlbmRhci5wcmV2aW91c01vbnRoKCk7XG4gICAgY29uc3QgbmV4dE1vbnRoQ2FsZW5kYXI6IENhbGVuZGFyTW9kZWwgPSB0aGlzLmNhbGVuZGFyLm5leHRNb250aCgpO1xuXG4gICAgLy8gR2V0IG5vIG9mIGRheXMgZnJvbSBwcmV2IGFuZCBuZXh0IG1vbnRocy5cbiAgICBjb25zdCBkYXlzRnJvbVByZXZNb250aEluQ2FsVmlldzogbnVtYmVyID0gdGhpcy5udW1EYXlzRnJvbVByZXZNb250aEluQ2FsVmlldyhcbiAgICAgIHRoaXMuY2FsZW5kYXIueWVhcixcbiAgICAgIHRoaXMuY2FsZW5kYXIubW9udGhcbiAgICApO1xuICAgIGNvbnN0IGRheXNGcm9tTmV4dE1vbnRoSW5DYWxWaWV3OiBudW1iZXIgPVxuICAgICAgVE9UQUxfREFZU19JTl9EQVlTX1ZJRVcgLSAodGhpcy5jYWxlbmRhci5kYXlzLmxlbmd0aCArIGRheXNGcm9tUHJldk1vbnRoSW5DYWxWaWV3KTtcblxuICAgIC8vIEdlbmVyYXRlIHByZXYsIGN1cnIgYW5kIG5leHQgZGF5IHZpZXcgbW9kZWxzXG4gICAgbGV0IHByZXZNb250aERheVZpZXdzOiBEYXlWaWV3TW9kZWxbXSA9IFtdO1xuICAgIGxldCBuZXh0TW9udGhEYXlWaWV3czogRGF5Vmlld01vZGVsW10gPSBbXTtcblxuICAgIGlmIChkYXlzRnJvbVByZXZNb250aEluQ2FsVmlldyA+IDApIHtcbiAgICAgIHByZXZNb250aERheVZpZXdzID0gdGhpcy5nZW5lcmF0ZURheVZpZXdNb2RlbHMoXG4gICAgICAgIHByZXZNb250aENhbGVuZGFyLmRheXMuc2xpY2UoLTEgKiBkYXlzRnJvbVByZXZNb250aEluQ2FsVmlldyksXG4gICAgICAgIHRydWUsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuY3Vyck1vbnRoRGF5Vmlld3MgPSB0aGlzLmdlbmVyYXRlRGF5Vmlld01vZGVscyh0aGlzLmNhbGVuZGFyLmRheXMsIGZhbHNlLCB0cnVlKTtcblxuICAgIGlmIChkYXlzRnJvbU5leHRNb250aEluQ2FsVmlldyA+IDApIHtcbiAgICAgIG5leHRNb250aERheVZpZXdzID0gdGhpcy5nZW5lcmF0ZURheVZpZXdNb2RlbHMoXG4gICAgICAgIG5leHRNb250aENhbGVuZGFyLmRheXMuc2xpY2UoMCwgZGF5c0Zyb21OZXh0TW9udGhJbkNhbFZpZXcpLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBjYWxlbmRhciB2aWV3IGFuZCBpbml0aWFsaXplIGZsYWdzXG4gICAgdGhpcy5fY2FsZW5kYXJWaWV3ID0gdGhpcy5nZW5lcmF0ZUNhbGVuZGFyVmlldyhwcmV2TW9udGhEYXlWaWV3cywgdGhpcy5jdXJyTW9udGhEYXlWaWV3cywgbmV4dE1vbnRoRGF5Vmlld3MpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNlbGVjdGVkRGF5KCk7XG4gICAgdGhpcy5pbml0aWFsaXplRm9jdXNhYmxlRGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgRGF5Vmlld01vZGVsIGFycmF5IGJhc2VkIG9uIHRoZSBEYXlNb2RlbCBwYXNzZWRcbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVEYXlWaWV3TW9kZWxzKGRheXM6IERheU1vZGVsW10sIGlzRGlzYWJsZWQ6IGJvb2xlYW4sIGlzQ3VycmVudENhbGVuZGFyOiBib29sZWFuKTogRGF5Vmlld01vZGVsW10ge1xuICAgIGNvbnN0IGRheVZpZXdzOiBEYXlWaWV3TW9kZWxbXSA9IGRheXMubWFwKGRheSA9PiB7XG4gICAgICByZXR1cm4gbmV3IERheVZpZXdNb2RlbChkYXksIGZhbHNlLCBpc0Rpc2FibGVkLCBmYWxzZSwgZmFsc2UpO1xuICAgIH0pO1xuICAgIGlmIChpc0N1cnJlbnRDYWxlbmRhciAmJiB0aGlzLmNhbGVuZGFyLmlzRGF5SW5DYWxlbmRhcih0aGlzLnRvZGF5KSkge1xuICAgICAgZGF5Vmlld3NbdGhpcy50b2RheS5kYXRlIC0gMV0uaXNUb2RheXNEYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGRheVZpZXdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGZpcnN0IGRheSBvZiB0aGUgY3VycmVudCBtb250aCB0byBmaWd1cmUgb3V0IGhvdyBtYW55IGRhdGVzIG9mIHByZXZpb3VzIG1vbnRoXG4gICAqIGFyZSBuZWVkZWQgdG8gY29tcGxldGUgdGhlIENhbGVuZGFyIFZpZXcgYmFzZWQgb24gdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICogZWc6IEFzc3VtaW5nIGxvY2FsZSBlbi1VUywgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBpcyBTdW5kYXksXG4gICAqIGlmIGZpcnN0IGRheSBvZiB0aGUgY3VycmVudCBtb250aCBsYW5kcyBvbiBXZWRuZXNkYXksIHRoZW5cbiAgICogKHRoaXMuZ2V0RGF5IGZ1bmN0aW9uIHdvdWxkIHJldHVybiAzIHNpbmNlXG4gICAqIGZpcnN0IGRheSBvZiB0aGUgd2VlayBpcyAwKSwgd2UgbmVlZCB0aGUgMyBkYXlzIGZyb20gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgcHJpdmF0ZSBudW1EYXlzRnJvbVByZXZNb250aEluQ2FsVmlldyhjdXJyZW50WWVhcjogbnVtYmVyLCBjdXJyZW50TW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgY29uc3QgZmlyc3REYXlPZkN1cnJNb250aDogbnVtYmVyID0gZ2V0RGF5KGN1cnJlbnRZZWFyLCBjdXJyZW50TW9udGgsIDEpO1xuXG4gICAgaWYgKGZpcnN0RGF5T2ZDdXJyTW9udGggPj0gdGhpcy5maXJzdERheU9mV2Vlaykge1xuICAgICAgcmV0dXJuIGZpcnN0RGF5T2ZDdXJyTW9udGggLSB0aGlzLmZpcnN0RGF5T2ZXZWVrO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTk9fT0ZfREFZU19JTl9BX1dFRUsgKyBmaXJzdERheU9mQ3Vyck1vbnRoIC0gdGhpcy5maXJzdERheU9mV2VlaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBEYXkgcGFzc2VkIGlzIGluIHRoZSBDYWxlbmRhclZpZXcuXG4gICAqL1xuICBwcml2YXRlIGlzRGF5SW5DYWxlbmRhclZpZXcoZGF5OiBEYXlNb2RlbCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5jYWxlbmRhci5pc0RheUluQ2FsZW5kYXIoZGF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2luZyB0aGUgRGF5Vmlld01vZGVscyBmcm9tIHRoZSBwcmV2aW91cywgY3VycmVudCBhbmQgbmV4dCBtb250aCwgdGhpcyBmdW5jdGlvblxuICAgKiBnZW5lcmF0ZXMgdGhlIENhbGVuZGFyVmlldy5cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVDYWxlbmRhclZpZXcocHJldjogRGF5Vmlld01vZGVsW10sIGN1cnI6IERheVZpZXdNb2RlbFtdLCBuZXh0OiBEYXlWaWV3TW9kZWxbXSk6IERheVZpZXdNb2RlbFtdW10ge1xuICAgIGNvbnN0IGNvbWJpbmF0aW9uQXJyOiBEYXlWaWV3TW9kZWxbXSA9IFsuLi5wcmV2LCAuLi5jdXJyLCAuLi5uZXh0XTtcblxuICAgIGNvbnN0IGNhbGVuZGFyVmlldzogRGF5Vmlld01vZGVsW11bXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTk9fT0ZfUk9XU19JTl9DQUxFTkRBUl9WSUVXOyBpKyspIHtcbiAgICAgIGNhbGVuZGFyVmlld1tpXSA9IGNvbWJpbmF0aW9uQXJyLnNsaWNlKGkgKiBOT19PRl9EQVlTX0lOX0FfV0VFSywgKGkgKyAxKSAqIE5PX09GX0RBWVNfSU5fQV9XRUVLKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGVuZGFyVmlldztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzZWxlY3RlZCBkYXkgaWYgdGhlIGRheSBpcyBpbiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVTZWxlY3RlZERheSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERheSAmJiB0aGlzLmlzRGF5SW5DYWxlbmRhclZpZXcodGhpcy5zZWxlY3RlZERheSkpIHtcbiAgICAgIHRoaXMuY3Vyck1vbnRoRGF5Vmlld3NbdGhpcy5zZWxlY3RlZERheS5kYXRlIC0gMV0uaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBmb2N1c2FibGUgZGF5IGlmIHRoZSBkYXkgaXMgaW4gdGhlIGNhbGVuZGFyLiBJZiBmb2N1c2FibGUgZGF5IGlzIG5vdCBzZXQsIHRoZW5cbiAgICogd2UgY2hlY2sgZm9yIHRoZSBzZWxlY3RlZCBkYXkuIElmIHNlbGVjdGVkIGRheSBpcyBub3Qgc2V0IHRoZW4gY2hlY2sgaWYgdG9kYXkgaXMgaW4gdGhlIGN1cnJlbnRcbiAgICogY2FsZW5kYXIuIElmIG5vdCB0aGVuIGp1c3Qgc2V0IHRoZSAxNXRoIG9mIHRoZSBjdXJyZW50IGNhbGVuZGFyIG1vbnRoLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplRm9jdXNhYmxlRGF5KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmZvY3VzYWJsZURheSAmJiB0aGlzLmlzRGF5SW5DYWxlbmRhclZpZXcodGhpcy5mb2N1c2FibGVEYXkpKSB7XG4gICAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcodGhpcy5mb2N1c2FibGVEYXksIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZERheSAmJiB0aGlzLmlzRGF5SW5DYWxlbmRhclZpZXcodGhpcy5zZWxlY3RlZERheSkpIHtcbiAgICAgIHRoaXMuc2V0Rm9jdXNhYmxlRmxhZyh0aGlzLnNlbGVjdGVkRGF5LCB0cnVlKTtcbiAgICAgIHRoaXMuZm9jdXNhYmxlRGF5ID0gdGhpcy5zZWxlY3RlZERheS5jbG9uZSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0RheUluQ2FsZW5kYXJWaWV3KHRoaXMudG9kYXkpKSB7XG4gICAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcodGhpcy50b2RheSwgdHJ1ZSk7XG4gICAgICB0aGlzLmZvY3VzYWJsZURheSA9IHRoaXMudG9kYXkuY2xvbmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mb2N1c2FibGVEYXkgPSBuZXcgRGF5TW9kZWwodGhpcy5jYWxlbmRhci55ZWFyLCB0aGlzLmNhbGVuZGFyLm1vbnRoLCAxNSk7XG4gICAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcodGhpcy5mb2N1c2FibGVEYXksIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0Rm9jdXNhYmxlRmxhZyhkYXk6IERheU1vZGVsLCBmbGFnOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKGRheSkge1xuICAgICAgdGhpcy5jdXJyTW9udGhEYXlWaWV3c1tkYXkuZGF0ZSAtIDFdLmlzRm9jdXNhYmxlID0gZmxhZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZm9jdXNhYmxlIGRheSBpbiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICB1cGRhdGVGb2N1c2FibGVEYXkoZGF5OiBEYXlNb2RlbCk6IHZvaWQge1xuICAgIHRoaXMuc2V0Rm9jdXNhYmxlRmxhZyh0aGlzLmZvY3VzYWJsZURheSwgZmFsc2UpO1xuICAgIHRoaXMuc2V0Rm9jdXNhYmxlRmxhZyhkYXksIHRydWUpO1xuICAgIHRoaXMuZm9jdXNhYmxlRGF5ID0gZGF5O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IENhbGVuZGFyTW9kZWwgfSBmcm9tICcuLi9tb2RlbC9jYWxlbmRhci5tb2RlbCc7XG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4uL21vZGVsL2RheS5tb2RlbCc7XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIGlzIHJlc3BvbnNpYmxlIGZvcjpcbiAqIDEuIEluaXRpYWxpemluZyB0aGUgZGlzcGxheWVkIGNhbGVuZGFyLlxuICogMi4gTW92aW5nIHRoZSBjYWxlbmRhciB0byB0aGUgbmV4dCwgcHJldmlvdXMgb3IgY3VycmVudCBtb250aHNcbiAqIDMuIE1hbmFnaW5nIHRoZSBmb2N1c2VkIGFuZCBzZWxlY3RlZCBkYXkgbW9kZWxzLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfZGlzcGxheWVkQ2FsZW5kYXI6IENhbGVuZGFyTW9kZWw7XG5cbiAgZ2V0IGRpc3BsYXllZENhbGVuZGFyKCk6IENhbGVuZGFyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhcjtcbiAgfVxuXG4gIC8vIG5vdCBhIHNldHRlciBiZWNhdXNlIGkgd2FudCB0aGlzIHRvIHJlbWFpbiBwcml2YXRlXG4gIHByaXZhdGUgc2V0RGlzcGxheWVkQ2FsZW5kYXIodmFsdWU6IENhbGVuZGFyTW9kZWwpIHtcbiAgICBpZiAoIXRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLmlzRXF1YWwodmFsdWUpKSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhciA9IHZhbHVlO1xuICAgICAgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2UubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBWYXJpYWJsZSB0byBzdG9yZSB0b2RheSdzIGRhdGUuXG4gICAqL1xuICBwcml2YXRlIF90b2RheXNGdWxsRGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gIHByaXZhdGUgX3RvZGF5OiBEYXlNb2RlbDtcblxuICBwcml2YXRlIGluaXRpYWxpemVUb2RheXNEYXRlKCk6IHZvaWQge1xuICAgIHRoaXMuX3RvZGF5c0Z1bGxEYXRlID0gbmV3IERhdGUoKTtcbiAgICB0aGlzLl90b2RheSA9IG5ldyBEYXlNb2RlbChcbiAgICAgIHRoaXMuX3RvZGF5c0Z1bGxEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICB0aGlzLl90b2RheXNGdWxsRGF0ZS5nZXRNb250aCgpLFxuICAgICAgdGhpcy5fdG9kYXlzRnVsbERhdGUuZ2V0RGF0ZSgpXG4gICAgKTtcbiAgfVxuXG4gIGdldCB0b2RheSgpOiBEYXlNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX3RvZGF5O1xuICB9XG5cbiAgcHVibGljIHNlbGVjdGVkRGF5OiBEYXlNb2RlbDtcblxuICBwcml2YXRlIF9zZWxlY3RlZERheUNoYW5nZTogU3ViamVjdDxEYXlNb2RlbD4gPSBuZXcgU3ViamVjdDxEYXlNb2RlbD4oKTtcblxuICBnZXQgc2VsZWN0ZWREYXlDaGFuZ2UoKTogT2JzZXJ2YWJsZTxEYXlNb2RlbD4ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZERheUNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGF0IHRoZSBzZWxlY3RlZCBkYXkgaGFzIGNoYW5nZWQgc28gdGhhdCB0aGUgZGF0ZSBjYW4gYmUgZW1pdHRlZCB0byB0aGUgdXNlci5cbiAgICogTm90ZTogT25seSB0byBiZSBjYWxsZWQgZnJvbSBkYXkudHNcbiAgICovXG4gIG5vdGlmeVNlbGVjdGVkRGF5Q2hhbmdlZChkYXlNb2RlbDogRGF5TW9kZWwpIHtcbiAgICBpZiAoZGF5TW9kZWwuaXNFcXVhbCh0aGlzLnNlbGVjdGVkRGF5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkRGF5ID0gZGF5TW9kZWw7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXlDaGFuZ2UubmV4dChkYXlNb2RlbCk7XG4gIH1cblxuICBwdWJsaWMgZm9jdXNlZERheTogRGF5TW9kZWw7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjYWxlbmRhciBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgZGF5LlxuICAgKi9cbiAgaW5pdGlhbGl6ZUNhbGVuZGFyKCk6IHZvaWQge1xuICAgIHRoaXMuZm9jdXNlZERheSA9IG51bGw7IC8vIENhbiBiZSByZW1vdmVkIGxhdGVyIG9uIHRoZSBzdG9yZSBmb2N1c1xuICAgIHRoaXMuaW5pdGlhbGl6ZVRvZGF5c0RhdGUoKTtcbiAgICBpZiAodGhpcy5zZWxlY3RlZERheSkge1xuICAgICAgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnNlbGVjdGVkRGF5LnllYXIsIHRoaXMuc2VsZWN0ZWREYXkubW9udGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhciA9IG5ldyBDYWxlbmRhck1vZGVsKHRoaXMudG9kYXkueWVhciwgdGhpcy50b2RheS5tb250aCk7XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlTW9udGgobW9udGg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIobmV3IENhbGVuZGFyTW9kZWwodGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIueWVhciwgbW9udGgpKTtcbiAgfVxuXG4gIGNoYW5nZVllYXIoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zZXREaXNwbGF5ZWRDYWxlbmRhcihuZXcgQ2FsZW5kYXJNb2RlbCh5ZWFyLCB0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhci5tb250aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBkaXNwbGF5ZWQgY2FsZW5kYXIgdG8gdGhlIG5leHQgbW9udGguXG4gICAqL1xuICBtb3ZlVG9OZXh0TW9udGgoKTogdm9pZCB7XG4gICAgdGhpcy5zZXREaXNwbGF5ZWRDYWxlbmRhcih0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhci5uZXh0TW9udGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGRpc3BsYXllZCBjYWxlbmRhciB0byB0aGUgcHJldmlvdXMgbW9udGguXG4gICAqL1xuICBtb3ZlVG9QcmV2aW91c01vbnRoKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIodGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIucHJldmlvdXNNb250aCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgZGlzcGxheWVkIGNhbGVuZGFyIHRvIHRoZSBjdXJyZW50IG1vbnRoIGFuZCB5ZWFyLlxuICAgKi9cbiAgbW92ZVRvQ3VycmVudE1vbnRoKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5kaXNwbGF5ZWRDYWxlbmRhci5pc0RheUluQ2FsZW5kYXIodGhpcy50b2RheSkpIHtcbiAgICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIobmV3IENhbGVuZGFyTW9kZWwodGhpcy50b2RheS55ZWFyLCB0aGlzLnRvZGF5Lm1vbnRoKSk7XG4gICAgfVxuICAgIHRoaXMuX2ZvY3VzT25DYWxlbmRhckNoYW5nZS5uZXh0KCk7XG4gIH1cblxuICBpbmNyZW1lbnRGb2N1c0RheSh2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5mb2N1c2VkRGF5ID0gdGhpcy5mb2N1c2VkRGF5LmluY3JlbWVudEJ5KHZhbHVlKTtcbiAgICBpZiAodGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIuaXNEYXlJbkNhbGVuZGFyKHRoaXMuZm9jdXNlZERheSkpIHtcbiAgICAgIHRoaXMuX2ZvY3VzZWREYXlDaGFuZ2UubmV4dCh0aGlzLmZvY3VzZWREYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKHRoaXMuZm9jdXNlZERheS5jYWxlbmRhcik7XG4gICAgfVxuICAgIHRoaXMuX2ZvY3VzT25DYWxlbmRhckNoYW5nZS5uZXh0KCk7XG4gIH1cblxuICBwcml2YXRlIF9kaXNwbGF5ZWRDYWxlbmRhckNoYW5nZTogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JzZXJ2YWJsZSBsZXRzIHRoZSBzdWJzY3JpYmVyIGtub3cgdGhhdCB0aGUgZGlzcGxheWVkIGNhbGVuZGFyIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgZ2V0IGRpc3BsYXllZENhbGVuZGFyQ2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhckNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZvY3VzT25DYWxlbmRhckNoYW5nZTogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JzZXJ2YWJsZSBsZXRzIHRoZSBzdWJzY3JpYmVyIGtub3cgdGhhdCB0aGUgZm9jdXMgc2hvdWxkIGJlIGFwcGxpZWQgb24gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgZ2V0IGZvY3VzT25DYWxlbmRhckNoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNPbkNhbGVuZGFyQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZm9jdXNlZERheUNoYW5nZTogU3ViamVjdDxEYXlNb2RlbD4gPSBuZXcgU3ViamVjdDxEYXlNb2RlbD4oKTtcblxuICAvKipcbiAgICogVGhpcyBvYnNlcnZhYmxlIGxldHMgdGhlIHN1YnNjcmliZXIga25vdyB0aGF0IHRoZSBmb2N1c2VkIGRheSBpbiB0aGUgZGlzcGxheWVkIGNhbGVuZGFyIGhhcyBjaGFuZ2VkLlxuICAgKi9cbiAgZ2V0IGZvY3VzZWREYXlDaGFuZ2UoKTogT2JzZXJ2YWJsZTxEYXlNb2RlbD4ge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c2VkRGF5Q2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgTmdab25lLCBQTEFURk9STV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIGZvY3VzZXMgdGhlIGRheSB0aGF0IGlzIGZvY3VzYWJsZSBpbiB0aGUgY2FsZW5kYXIuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0KSB7fVxuXG4gIC8vIENyZWRpdDogTWF0ZXJpYWw6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9ibG9iL21hc3Rlci9zcmMvbGliL2RhdGVwaWNrZXIvY2FsZW5kYXIudHNcbiAgZm9jdXNDZWxsKGVsUmVmOiBFbGVtZW50UmVmKTogdm9pZCB7XG4gICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIHRoaXMuX25nWm9uZS5vblN0YWJsZVxuICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzRWwgPSBlbFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ1t0YWJpbmRleD1cIjBcIl0nKTtcbiAgICAgICAgICAgIGlmIChmb2N1c0VsKSB7XG4gICAgICAgICAgICAgIGZvY3VzRWwuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7XG4gIEZvcm1hdFdpZHRoLFxuICBGb3JtU3R5bGUsXG4gIGdldExvY2FsZURhdGVGb3JtYXQsXG4gIGdldExvY2FsZURheU5hbWVzLFxuICBnZXRMb2NhbGVGaXJzdERheU9mV2VlayxcbiAgZ2V0TG9jYWxlTW9udGhOYW1lcyxcbiAgVHJhbnNsYXRpb25XaWR0aCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgTE9DQUxFX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIGV4dHJhY3RzIHRoZSBBbmd1bGFyIENMRFIgZGF0YSBuZWVkZWQgYnkgdGhlIGRhdGVwaWNrZXIuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBMb2NhbGVIZWxwZXJTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoQEluamVjdChMT0NBTEVfSUQpIHB1YmxpYyBsb2NhbGU6IHN0cmluZykge1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZURhdGEoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZpcnN0RGF5T2ZXZWVrOiBudW1iZXIgPSAwO1xuICBwcml2YXRlIF9sb2NhbGVEYXlzTmFycm93OiBSZWFkb25seUFycmF5PHN0cmluZz47XG4gIHByaXZhdGUgX2xvY2FsZU1vbnRoc0FiYnJldmlhdGVkOiBSZWFkb25seUFycmF5PHN0cmluZz47XG4gIHByaXZhdGUgX2xvY2FsZU1vbnRoc1dpZGU6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPjtcbiAgcHJpdmF0ZSBfbG9jYWxlRGF0ZUZvcm1hdDogc3RyaW5nO1xuXG4gIGdldCBmaXJzdERheU9mV2VlaygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9maXJzdERheU9mV2VlaztcbiAgfVxuXG4gIGdldCBsb2NhbGVEYXlzTmFycm93KCk6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZURheXNOYXJyb3c7XG4gIH1cblxuICBnZXQgbG9jYWxlTW9udGhzQWJicmV2aWF0ZWQoKTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlTW9udGhzQWJicmV2aWF0ZWQ7XG4gIH1cblxuICBnZXQgbG9jYWxlTW9udGhzV2lkZSgpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVNb250aHNXaWRlO1xuICB9XG5cbiAgZ2V0IGxvY2FsZURhdGVGb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlRGF0ZUZvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbG9jYWxlIGRhdGEuXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVMb2NhbGVEYXRhKCk6IHZvaWQge1xuICAgIC8vIE9yZGVyIGluIHdoaWNoIHRoZXNlIGZ1bmN0aW9ucyBpcyBjYWxsZWQgaXMgdmVyeSBpbXBvcnRhbnQuXG4gICAgdGhpcy5pbml0aWFsaXplRmlyc3REYXlPZldlZWsoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMb2NhbGVEYXRlRm9ybWF0KCk7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlTW9udGhzQWJicmV2aWF0ZWQoKTtcbiAgICB0aGlzLmluaXRpYWxpemVMb2NhbGVNb250aHNXaWRlKCk7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlRGF5c05hcnJvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgZGF5IG5hbWVzIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLk5hcnJvdyBmb3JtYXQgYmFzZWQgb24gdGhlIGxvY2FsZS5cbiAgICogZWc6IFtTLCBNLCBULi4uXSBmb3IgZW4tVVMuXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVMb2NhbGVEYXlzTmFycm93KCk6IHZvaWQge1xuICAgIC8vIEdldCBsb2NhbGUgZGF5IG5hbWVzIHN0YXJ0aW5nIHdpdGggU3VuZGF5XG4gICAgY29uc3QgdGVtcEFycjogc3RyaW5nW10gPSBnZXRMb2NhbGVEYXlOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLlN0YW5kYWxvbmUsIFRyYW5zbGF0aW9uV2lkdGguTmFycm93KS5zbGljZSgpO1xuICAgIC8vIEdldCBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIGxvY2FsZVxuICAgIGNvbnN0IGZpcnN0RGF5T2ZXZWVrOiBudW1iZXIgPSB0aGlzLmZpcnN0RGF5T2ZXZWVrO1xuICAgIC8vIFJlYXJyYW5nZSB0aGUgdGVtcEFyciB0byBzdGFydCB3aXRoIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgYmFzZWQgb24gdGhlIGxvY2FsZS5cbiAgICBpZiAoZmlyc3REYXlPZldlZWsgPiAwKSB7XG4gICAgICBjb25zdCBwcmV2RGF5czogc3RyaW5nW10gPSB0ZW1wQXJyLnNwbGljZSgwLCBmaXJzdERheU9mV2Vlayk7XG4gICAgICB0ZW1wQXJyLnB1c2goLi4ucHJldkRheXMpO1xuICAgIH1cbiAgICB0aGlzLl9sb2NhbGVEYXlzTmFycm93ID0gdGVtcEFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgYXJyYXkgb2YgbW9udGggbmFtZXMgaW4gdGhlIFRyYW5zbGF0aW9uV2lkdGguQWJicmV2aWF0ZWQgZm9ybWF0LlxuICAgKiBlLmcuIGBbSmFuLCBGZWIsIC4uLl1gIGZvciBlbi1VU1xuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlTW9udGhzQWJicmV2aWF0ZWQoKTogdm9pZCB7XG4gICAgdGhpcy5fbG9jYWxlTW9udGhzQWJicmV2aWF0ZWQgPSBnZXRMb2NhbGVNb250aE5hbWVzKFxuICAgICAgdGhpcy5sb2NhbGUsXG4gICAgICBGb3JtU3R5bGUuU3RhbmRhbG9uZSxcbiAgICAgIFRyYW5zbGF0aW9uV2lkdGguQWJicmV2aWF0ZWRcbiAgICApLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGFycmF5IG9mIG1vbnRoIG5hbWVzIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLldpZGUgZm9ybWF0LlxuICAgKiBlLmcuIGBbSmFudWFyeSwgRmVicnVhcnksIC4uLl1gIGZvciBlbi1VU1xuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlTW9udGhzV2lkZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9sb2NhbGVNb250aHNXaWRlID0gZ2V0TG9jYWxlTW9udGhOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLlN0YW5kYWxvbmUsIFRyYW5zbGF0aW9uV2lkdGguV2lkZSkuc2xpY2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBsb2NhbGUuXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVGaXJzdERheU9mV2VlaygpOiB2b2lkIHtcbiAgICB0aGlzLl9maXJzdERheU9mV2VlayA9IGdldExvY2FsZUZpcnN0RGF5T2ZXZWVrKHRoaXMubG9jYWxlKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZURhdGVGb3JtYXQoKTogdm9pZCB7XG4gICAgdGhpcy5fbG9jYWxlRGF0ZUZvcm1hdCA9IGdldExvY2FsZURhdGVGb3JtYXQodGhpcy5sb2NhbGUsIEZvcm1hdFdpZHRoLlNob3J0KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERPV05fQVJST1csIExFRlRfQVJST1csIFJJR0hUX0FSUk9XLCBVUF9BUlJPVyB9IGZyb20gJy4uLy4uL3V0aWxzL2tleS1jb2Rlcy9rZXktY29kZXMnO1xuXG5pbXBvcnQgeyBDYWxlbmRhclZpZXdNb2RlbCB9IGZyb20gJy4vbW9kZWwvY2FsZW5kYXItdmlldy5tb2RlbCc7XG5pbXBvcnQgeyBDYWxlbmRhck1vZGVsIH0gZnJvbSAnLi9tb2RlbC9jYWxlbmRhci5tb2RlbCc7XG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vbW9kZWwvZGF5Lm1vZGVsJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9jYWxlSGVscGVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xvY2FsZS1oZWxwZXIuc2VydmljZSc7XG5pbXBvcnQgeyBOT19PRl9EQVlTX0lOX0FfV0VFSyB9IGZyb20gJy4vdXRpbHMvY29uc3RhbnRzJztcblxuQENvbXBvbmVudCh7IHNlbGVjdG9yOiAnY2xyLWNhbGVuZGFyJywgdGVtcGxhdGVVcmw6ICcuL2NhbGVuZGFyLmh0bWwnIH0pXG5leHBvcnQgY2xhc3MgQ2xyQ2FsZW5kYXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9zdWJzOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2xvY2FsZUhlbHBlclNlcnZpY2U6IExvY2FsZUhlbHBlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZGF0ZU5hdmlnYXRpb25TZXJ2aWNlOiBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZGF0ZXBpY2tlckZvY3VzU2VydmljZTogRGF0ZXBpY2tlckZvY3VzU2VydmljZSxcbiAgICBwcml2YXRlIF9lbFJlZjogRWxlbWVudFJlZlxuICApIHtcbiAgICB0aGlzLmdlbmVyYXRlQ2FsZW5kYXJWaWV3KCk7XG4gICAgdGhpcy5pbml0aWFsaXplU3Vic2NyaXB0aW9ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGVuZGFyIFZpZXcgTW9kZWwgdG8gZ2VuZXJhdGUgdGhlIENhbGVuZGFyLlxuICAgKi9cbiAgY2FsZW5kYXJWaWV3TW9kZWw6IENhbGVuZGFyVmlld01vZGVsO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb2NhbGUgZGF5cyBhY2NvcmRpbmcgdG8gdGhlIFRyYW5zbGF0aW9uV2lkdGguTmFycm93IGZvcm1hdC5cbiAgICovXG4gIGdldCBsb2NhbGVEYXlzTmFycm93KCk6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZUhlbHBlclNlcnZpY2UubG9jYWxlRGF5c05hcnJvdztcbiAgfVxuXG4gIGdldCBjYWxlbmRhcigpOiBDYWxlbmRhck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyO1xuICB9XG5cbiAgZ2V0IHNlbGVjdGVkRGF5KCk6IERheU1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdGVkRGF5O1xuICB9XG5cbiAgZ2V0IGZvY3VzZWREYXkoKTogRGF5TW9kZWwge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZm9jdXNlZERheTtcbiAgfVxuXG4gIGdldCB0b2RheSgpOiBEYXlNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS50b2RheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHN1YnNjcmlwdGlvbnMgdG86XG4gICAqIDEuIHVwZGF0ZSB0aGUgY2FsZW5kYXIgdmlldyBtb2RlbC5cbiAgICogMi4gdXBkYXRlIHRoZSBmb2N1c2FibGUgZGF5IGluIHRoZSBjYWxlbmRhciB2aWV3IG1vZGVsLlxuICAgKiAzLiBmb2N1cyBvbiB0aGUgZm9jdXNhYmxlIGRheSBpbiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVTdWJzY3JpcHRpb25zKCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnMucHVzaChcbiAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhckNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2FsZW5kYXJWaWV3KCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLl9zdWJzLnB1c2goXG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZm9jdXNlZERheUNoYW5nZS5zdWJzY3JpYmUoKGZvY3VzZWREYXk6IERheU1vZGVsKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJWaWV3TW9kZWwudXBkYXRlRm9jdXNhYmxlRGF5KGZvY3VzZWREYXkpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fc3Vicy5wdXNoKFxuICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzT25DYWxlbmRhckNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBDYWxlbmRhciBWaWV3IGJhc2VkIG9uIHRoZSBjYWxlbmRhciByZXRyaWV2ZWQgZnJvbSB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLlxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZUNhbGVuZGFyVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLmNhbGVuZGFyVmlld01vZGVsID0gbmV3IENhbGVuZGFyVmlld01vZGVsKFxuICAgICAgdGhpcy5jYWxlbmRhcixcbiAgICAgIHRoaXMuc2VsZWN0ZWREYXksXG4gICAgICB0aGlzLmZvY3VzZWREYXksXG4gICAgICB0aGlzLnRvZGF5LFxuICAgICAgdGhpcy5fbG9jYWxlSGVscGVyU2VydmljZS5maXJzdERheU9mV2Vla1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZWdhdGVzIEtleWJvYXJkIGFycm93IG5hdmlnYXRpb24gdG8gdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZS5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgdGhpcy5mb2N1c2VkRGF5KSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSBVUF9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5pbmNyZW1lbnRGb2N1c0RheSgtMSAqIE5PX09GX0RBWVNfSU5fQV9XRUVLKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBET1dOX0FSUk9XOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmluY3JlbWVudEZvY3VzRGF5KE5PX09GX0RBWVNfSU5fQV9XRUVLKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmluY3JlbWVudEZvY3VzRGF5KC0xKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5pbmNyZW1lbnRGb2N1c0RheSgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhazsgLy8gTm8gZGVmYXVsdCBjYXNlLiBUU0xpbnQgeC0oXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgb24gdGhlIGZvY3VzYWJsZSBkYXkgd2hlbiB0aGUgQ2FsZW5kYXIgVmlldyBpcyBpbml0aWFsaXplZC5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBzdWJzY3JpcHRpb25zLlxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vicy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRm9jdXNTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfZm9jdXNlZDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gIGdldCBmb2N1c0NoYW5nZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuICBzZXQgZm9jdXNlZChzdGF0ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2ZvY3VzZWQubmV4dChzdGF0ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZUZvcm1Db250cm9sU2VydmljZSB7XG4gIHByaXZhdGUgX3RvdWNoZWRDaGFuZ2U6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGdldCB0b3VjaGVkQ2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl90b3VjaGVkQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGlydHlDaGFuZ2U6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGdldCBkaXJ0eUNoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHlDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBtYXJrQXNUb3VjaGVkKCk6IHZvaWQge1xuICAgIHRoaXMuX3RvdWNoZWRDaGFuZ2UubmV4dCgpO1xuICB9XG5cbiAgbWFya0FzRGlydHkoKTogdm9pZCB7XG4gICAgdGhpcy5fZGlydHlDaGFuZ2UubmV4dCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHtcbiAgQklHX0VORElBTixcbiAgREVGQVVMVF9MT0NBTEVfRk9STUFULFxuICBERUxJTUlURVJfUkVHRVgsXG4gIElucHV0RGF0ZURpc3BsYXlGb3JtYXQsXG4gIExJVFRMRV9FTkRJQU4sXG4gIExJVFRMRV9FTkRJQU5fUkVHRVgsXG4gIE1JRERMRV9FTkRJQU4sXG4gIE1JRERMRV9FTkRJQU5fUkVHRVgsXG4gIFJUTF9SRUdFWCxcbiAgVVNFUl9JTlBVVF9SRUdFWCxcbn0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGdldE51bWJlck9mRGF5c0luVGhlTW9udGgsIHBhcnNlVG9Gb3VyRGlnaXRZZWFyIH0gZnJvbSAnLi4vdXRpbHMvZGF0ZS11dGlscyc7XG5cbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL2xvY2FsZS1oZWxwZXIuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlSU9TZXJ2aWNlIHtcbiAgcHVibGljIGNsZHJMb2NhbGVEYXRlRm9ybWF0OiBzdHJpbmcgPSBERUZBVUxUX0xPQ0FMRV9GT1JNQVQ7XG4gIHByaXZhdGUgbG9jYWxlRGlzcGxheUZvcm1hdDogSW5wdXREYXRlRGlzcGxheUZvcm1hdCA9IExJVFRMRV9FTkRJQU47XG4gIHByaXZhdGUgZGVsaW1pdGVyczogW3N0cmluZywgc3RyaW5nXSA9IFsnLycsICcvJ107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbG9jYWxlSGVscGVyU2VydmljZTogTG9jYWxlSGVscGVyU2VydmljZSkge1xuICAgIHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQgPSB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZURhdGVGb3JtYXQ7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlRGlzcGxheUZvcm1hdCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlRGlzcGxheUZvcm1hdCgpOiB2b2lkIHtcbiAgICBjb25zdCBmb3JtYXQ6IHN0cmluZyA9IHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoTElUVExFX0VORElBTl9SRUdFWC50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9IExJVFRMRV9FTkRJQU47XG4gICAgfSBlbHNlIGlmIChNSURETEVfRU5ESUFOX1JFR0VYLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID0gTUlERExFX0VORElBTjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXZlcnl0aGluZyBlbHNlIGlzIHNldCB0byBCSUctRU5ESUFOIEZPUk1BVFxuICAgICAgdGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID0gQklHX0VORElBTjtcbiAgICB9XG4gICAgdGhpcy5leHRyYWN0RGVsaW1pdGVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0RGVsaW1pdGVycygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGRyTG9jYWxlRGF0ZUZvcm1hdCkge1xuICAgICAgLy8gU2FuaXRpemUgRGF0ZSBGb3JtYXQuIFJlbW92ZSBSVEwgY2hhcmFjdGVycy5cbiAgICAgIC8vIEZJWE1FOiBXaGVuIHdlIHN1cHBvcnQgUlRMLCByZW1vdmUgdGhpcyBhbmQgaGFuZGxlIGl0IGNvcnJlY3RseS5cbiAgICAgIGNvbnN0IGxvY2FsZUZvcm1hdDogc3RyaW5nID0gdGhpcy5jbGRyTG9jYWxlRGF0ZUZvcm1hdC5yZXBsYWNlKFJUTF9SRUdFWCwgJycpO1xuICAgICAgY29uc3QgZGVsaW1pdGVyczogc3RyaW5nW10gPSBsb2NhbGVGb3JtYXQuc3BsaXQoREVMSU1JVEVSX1JFR0VYKTtcblxuICAgICAgLy8gTk9URTogVGhlIHNwbGl0IGZyb20gdGhlIENMRFIgZGF0ZSBmb3JtYXQgc2hvdWxkIGFsd2F5cyByZXN1bHRcbiAgICAgIC8vIGluIGFuIGFyYXJ5IHdpdGggNCBlbGVtZW50cy4gVGhlIDFzdCBhbmQgdGhlIDJuZCB2YWx1ZXMgYXJlIHRoZSBkZWxpbWl0ZXJzXG4gICAgICAvLyB3ZSB3aWxsIHVzZSBpbiBvcmRlci5cbiAgICAgIC8vIEVnOiBcImRkL01NL3lcIi5zcGxpdCgvZCt8bSt8eSsvaSkgcmVzdWx0cyBpbiBbXCJcIiwgXCIvXCIsIFwiL1wiLCBcIlwiXVxuICAgICAgaWYgKGRlbGltaXRlcnMgJiYgZGVsaW1pdGVycy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJzID0gW2RlbGltaXRlcnNbMV0sIGRlbGltaXRlcnNbMl1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCBkYXRlIGZvcm1hdCByZWNlaXZlZC4gRGVsaW1pdGVycyBleHRyYWN0ZWQ6ICcsIGRlbGltaXRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvTG9jYWxlRGlzcGxheUZvcm1hdFN0cmluZyhkYXRlOiBEYXRlKTogc3RyaW5nIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRlTm86IG51bWJlciA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgY29uc3QgbW9udGhObzogbnVtYmVyID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgIGNvbnN0IGRhdGVTdHI6IHN0cmluZyA9IGRhdGVObyA+IDkgPyBkYXRlTm8udG9TdHJpbmcoKSA6ICcwJyArIGRhdGVObztcbiAgICAgIGNvbnN0IG1vbnRoU3RyOiBzdHJpbmcgPSBtb250aE5vID4gOSA/IG1vbnRoTm8udG9TdHJpbmcoKSA6ICcwJyArIG1vbnRoTm87XG4gICAgICBpZiAodGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0ID09PSBMSVRUTEVfRU5ESUFOKSB7XG4gICAgICAgIHJldHVybiBkYXRlU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzBdICsgbW9udGhTdHIgKyB0aGlzLmRlbGltaXRlcnNbMV0gKyBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTUlERExFX0VORElBTikge1xuICAgICAgICByZXR1cm4gbW9udGhTdHIgKyB0aGlzLmRlbGltaXRlcnNbMF0gKyBkYXRlU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSArIHRoaXMuZGVsaW1pdGVyc1swXSArIG1vbnRoU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZGF0ZVN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVyVGV4dCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZvcm1hdDogW3N0cmluZywgc3RyaW5nLCBzdHJpbmddID0gdGhpcy5sb2NhbGVEaXNwbGF5Rm9ybWF0LmZvcm1hdDtcbiAgICByZXR1cm4gZm9ybWF0WzBdICsgdGhpcy5kZWxpbWl0ZXJzWzBdICsgZm9ybWF0WzFdICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZm9ybWF0WzJdO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgbW9udGggZW50ZXJlZCBieSB0aGUgdXNlciBpcyB2YWxpZCBvciBub3QuXG4gICAqIE5vdGU6IE1vbnRoIGlzIDAgYmFzZWQuXG4gICAqL1xuICBwcml2YXRlIGlzVmFsaWRNb250aChtb250aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG1vbnRoID4gLTEgJiYgbW9udGggPCAxMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGRhdGUgaXMgdmFsaWQgZGVwZW5kaW5nIG9uIHRoZSB5ZWFyIGFuZCBtb250aCBwcm92aWRlZC5cbiAgICovXG4gIHByaXZhdGUgaXNWYWxpZERhdGUoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXRlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZGF0ZSA+IDAgJiYgZGF0ZSA8PSBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoKHllYXIsIG1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIHBhcmFtZXRlcnMgcHJvdmlkZWQgYW5kIHJldHVybnMgdGhlIGRhdGUuXG4gICAqIElmIHRoZSBwYXJhbWV0ZXJzIGFyZSBub3RcbiAgICogdmFsaWQgdGhlbiByZXR1cm4gbnVsbC5cbiAgICogTk9URTogKE1vbnRoIGhlcmUgaXMgMSBiYXNlZCBzaW5jZSB0aGUgdXNlciBoYXMgcHJvdmlkZWQgdGhhdCBhcyBhbiBpbnB1dClcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVBbmRHZXREYXRlKHllYXI6IHN0cmluZywgbW9udGg6IHN0cmluZywgZGF0ZTogc3RyaW5nKTogRGF0ZSB7XG4gICAgLy8gSSBkb24ndCBrbm93IHdoYXRzIHdyb25nIHdpdGggdGhlIFRTIGNvbXBpbGVyLiBJdCB0aHJvd3MgYW4gZXJyb3IgaWYgSSB3cml0ZVxuICAgIC8vIHRoZSBiZWxvdyBpZiBzdGF0ZW1lbnQuIFRoZSBlcnJvciBpczpcbiAgICAvLyBPcGVyYXRvciAnIT09JyBjYW5ub3QgYmUgYXBwbGllZCB0byB0eXBlcyAnMicgYW5kICc0J1xuICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzEyNzk0I2lzc3VlY29tbWVudC0yNzAzNDI5MzZcbiAgICAvKlxuICAgICAgICBpZiAoeWVhci5sZW5ndGggIT09IDIgfHwgeWVhci5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICAvLyBJbnN0ZWFkIEkgaGF2ZSB0byB3cml0ZSB0aGUgbG9naWMgbGlrZSB0aGlzIHgtKFxuICAgIGNvbnN0IHk6IG51bWJlciA9ICt5ZWFyO1xuICAgIGNvbnN0IG06IG51bWJlciA9ICttb250aCAtIDE7IC8vIG1vbnRoIGlzIDAgYmFzZWRcbiAgICBjb25zdCBkOiBudW1iZXIgPSArZGF0ZTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZE1vbnRoKG0pIHx8ICF0aGlzLmlzVmFsaWREYXRlKHksIG0sIGQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXIgPSBwYXJzZVRvRm91ckRpZ2l0WWVhcih5KTtcbiAgICByZXR1cm4gcmVzdWx0ICE9PSAtMSA/IG5ldyBEYXRlKHJlc3VsdCwgbSwgZCkgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgaW5wdXQgcHJvdmlkZWQgYnkgdGhlIHVzZXIgaXMgdmFsaWQuXG4gICAqL1xuICBpc1ZhbGlkSW5wdXQoZGF0ZTogc3RyaW5nKTogRGF0ZSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0ZVBhcnRzOiBzdHJpbmdbXSA9IGRhdGUubWF0Y2goVVNFUl9JTlBVVF9SRUdFWCk7XG4gICAgaWYgKCFkYXRlUGFydHMgfHwgZGF0ZVBhcnRzLmxlbmd0aCAhPT0gMykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFtmaXJzdFBhcnQsIHNlY29uZFBhcnQsIHRoaXJkUGFydF0gPSBkYXRlUGFydHM7XG4gICAgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTElUVExFX0VORElBTikge1xuICAgICAgLy8gc2Vjb25kUGFydCBpcyBtb250aCAmJiBmaXJzdFBhcnQgaXMgZGF0ZVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbmRHZXREYXRlKHRoaXJkUGFydCwgc2Vjb25kUGFydCwgZmlyc3RQYXJ0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTUlERExFX0VORElBTikge1xuICAgICAgLy8gZmlyc3RQYXJ0IGlzIG1vbnRoICYmIHNlY29uZFBhcnQgaXMgZGF0ZVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbmRHZXREYXRlKHRoaXJkUGFydCwgZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2Vjb25kUGFydCBpcyBtb250aCAmJiB0aGlyZFBhcnQgaXMgZGF0ZVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBbmRHZXREYXRlKGZpcnN0UGFydCwgc2Vjb25kUGFydCwgdGhpcmRQYXJ0KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLy8gaVBhZCBtaW5pIHNjcmVlbiB3aWR0aFxuLy8gaHR0cDovL3N0ZXBoZW4uaW8vbWVkaWFxdWVyaWVzLyNpUGFkTWluaVxuZXhwb3J0IGNvbnN0IERBVEVQSUNLRVJfRU5BQkxFX0JSRUFLUE9JTlQ6IG51bWJlciA9IDc2ODtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERBVEVQSUNLRVJfRU5BQkxFX0JSRUFLUE9JTlQgfSBmcm9tICcuLi8uLi8uLi91dGlscy9icmVha3BvaW50cy9icmVha3BvaW50cyc7XG5pbXBvcnQgeyBNT0JJTEVfVVNFUkFHRU5UX1JFR0VYIH0gZnJvbSAnLi4vdXRpbHMvY29uc3RhbnRzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVwaWNrZXJFbmFibGVkU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnkpIHtcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQpIHtcbiAgICAgIHRoaXMuX2lzVXNlckFnZW50TW9iaWxlID0gTU9CSUxFX1VTRVJBR0VOVF9SRUdFWC50ZXN0KF9kb2N1bWVudC5kZWZhdWx0Vmlldy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHRoaXMuX2lubmVyV2lkdGggPSBfZG9jdW1lbnQuZGVmYXVsdFZpZXcuaW5uZXJXaWR0aDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pc1VzZXJBZ2VudE1vYmlsZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pbm5lcldpZHRoOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSBhY3RpdmUgb3Igbm90LlxuICAgKiBJZiB0aGUgdXNlciBhZ2VudCBpcyBtb2JpbGUgYW5kIHRoZSBzY3JlZW4gd2lkdGggaXMgbGVzcyB0aGFuIERBVEVQSUNLRVJfQUNUSVZFX0JSRUFLUE9JTlRcbiAgICogdGhlbiB0aGUgY2FsZW5kYXIgaXMgaW5hY3RpdmUuXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvQnJvd3Nlcl9kZXRlY3Rpb25fdXNpbmdfdGhlX3VzZXJfYWdlbnRcbiAgICAvLyBXaGF0IHRoZXkgcmVjb21tZW5kIGlzOlxuICAgIC8vXCJJbiBzdW1tYXJ5LCB3ZSByZWNvbW1lbmQgbG9va2luZyBmb3IgdGhlIHN0cmluZyAnTW9iaSdcbiAgICAvLyBhbnl3aGVyZSBpbiB0aGUgVXNlciBBZ2VudCB0byBkZXRlY3QgYSBtb2JpbGUgZGV2aWNlLlwiXG4gICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICBpZiAodGhpcy5faW5uZXJXaWR0aCA8IERBVEVQSUNLRVJfRU5BQkxFX0JSRUFLUE9JTlQgJiYgdGhpcy5faXNVc2VyQWdlbnRNb2JpbGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbmplY3QsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IEZvY3VzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlSU9TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1pby5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZW5hYmxlZC5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IElTX05FV19GT1JNU19MQVlPVVQgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25ldy1mb3Jtcy5zZXJ2aWNlJztcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjb250YWlucyB0d28gdGVtcGxhdGUgZm9yIHRoZSBvbGQgYW5kIG5ldyBmb3JtcyBsYXlvdXRzLlxuICogV2hlbiBpdCBpcyB0aW1lIHRvIHJlbW92ZSB0aGUgb2xkIGZvcm1zIGxheW91dHMgc3VwcG9ydCwgcmVtb3ZlIHRoZSBuZy10ZW1wbGF0ZXNcbiAqIGFuZCBuZy1jb250YWluZXIsIGFuZCBqdXN0IGtlZXAgdGhlIGlubmVyIGNvbnRlbnQgb2YgdGhlICNuZXdMYXlvdXQgYXMgdGhlIHRlbXBsYXRlXG4gKiBhbmQgbW92ZSB0aGUgbmctY29udGVudCBmb3IgY2xyRGF0ZS5cbiAqL1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGF0ZS1jb250YWluZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZSAjb2xkTGF5b3V0PlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjbHJEYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJkYXRlcGlja2VyLXRyaWdnZXJcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZURhdGVwaWNrZXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAqbmdJZj1cImlzRW5hYmxlZFwiPlxuICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2FsZW5kYXJcIiBjbGFzcz1cImRhdGVwaWNrZXItdHJpZ2dlci1pY29uXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5vcGVuXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxjbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXIgKmNscklmT3BlbiBjbHJGb2N1c1RyYXA+PC9jbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBcbiAgICA8bmctdGVtcGxhdGUgI25ld0xheW91dD5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtd3JhcHBlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtZ3JvdXBcIiBbY2xhc3MuY2xyLWZvY3VzXT1cImZvY3VzXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY2xyRGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJkYXRlcGlja2VyLXRyaWdnZXJcIiAoY2xpY2spPVwidG9nZ2xlRGF0ZXBpY2tlcigkZXZlbnQpXCIgKm5nSWY9XCJpc0VuYWJsZWRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLm9wZW5cIiBbZGlzYWJsZWRdPVwiY29udHJvbD8uZGlzYWJsZWRcIj5cbiAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2FsZW5kYXJcIiBjbGFzcz1cImNsci1pbnB1dC1ncm91cC1pY29uLWFjdGlvblwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxjbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXIgKmNscklmT3BlbiBjbHJGb2N1c1RyYXA+PC9jbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXI+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGNsci1pY29uIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiPjwvY2xyLWljb24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgXG4gICAgPG5nLXRlbXBsYXRlICNjbHJEYXRlPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsckRhdGVdXCI+PC9uZy1jb250ZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIm5ld0Zvcm1zTGF5b3V0OyB0aGVuIG5ld0xheW91dCBlbHNlIG9sZExheW91dFwiPjwvbmctY29udGFpbmVyPlxuICAgIGAsXG4gIHByb3ZpZGVyczogW1xuICAgIENvbnRyb2xJZFNlcnZpY2UsXG4gICAgSWZPcGVuU2VydmljZSxcbiAgICBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIElmRXJyb3JTZXJ2aWNlLFxuICAgIENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgRm9jdXNTZXJ2aWNlLFxuICAgIE5nQ29udHJvbFNlcnZpY2UsXG4gICAgRGF0ZUlPU2VydmljZSxcbiAgICBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlLFxuICAgIERhdGVGb3JtQ29udHJvbFNlcnZpY2UsXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGUtY29udGFpbmVyXSc6ICchbmV3Rm9ybXNMYXlvdXQnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZF0nOiAnY29udHJvbD8uZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAnbmV3Rm9ybXNMYXlvdXQnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRlQ29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIF9keW5hbWljOiBib29sZWFuID0gZmFsc2U7XG4gIGludmFsaWQgPSBmYWxzZTtcbiAgZm9jdXMgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9pZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJFbmFibGVkU2VydmljZTogRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlLFxuICAgIHByaXZhdGUgZGF0ZUZvcm1Db250cm9sU2VydmljZTogRGF0ZUZvcm1Db250cm9sU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncyxcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBwcml2YXRlIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KElTX05FV19GT1JNU19MQVlPVVQpXG4gICAgcHVibGljIG5ld0Zvcm1zTGF5b3V0OiBib29sZWFuLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX2lmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUob3BlbiA9PiB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplQ2FsZW5kYXIoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHN0YXRlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBjb250cm9sXG4gICAqL1xuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY29udHJvbCBuZWVkcyB0byBhZGQgZ3JpZCBjbGFzc2VzXG4gICAqL1xuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgRGF0ZXBpY2tlciBpcyBlbmFibGVkIG9yIG5vdC4gSWYgZGlzYWJsZWQsIGhpZGVzIHRoZSBkYXRlcGlja2VyIHRyaWdnZXIuXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UuaXNFbmFibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgdXNlciBpbnB1dCBhbmQgSW5pdGlhbGl6ZXMgdGhlIENhbGVuZGFyIGV2ZXJ5dGltZSB0aGUgZGF0ZXBpY2tlciBwb3BvdmVyIGlzIG9wZW4uXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVDYWxlbmRhcigpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5pdGlhbGl6ZUNhbGVuZGFyKCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgRGF0ZXBpY2tlciBQb3BvdmVyLlxuICAgKi9cbiAgdG9nZ2xlRGF0ZXBpY2tlcihldmVudDogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX2lmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UubWFya0FzVG91Y2hlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gc3Vic2NyaXB0aW9ucy5cbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBQTEFURk9STV9JRCxcbiAgUmVuZGVyZXIyLFxuICBTZWxmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEZvY3VzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvZm9jdXMuc2VydmljZSc7XG5cbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuXG5pbXBvcnQgeyBDbHJEYXRlQ29udGFpbmVyIH0gZnJvbSAnLi9kYXRlLWNvbnRhaW5lcic7XG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vbW9kZWwvZGF5Lm1vZGVsJztcbmltcG9ydCB7IERhdGVGb3JtQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWZvcm0tY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVJT1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLWlvLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1lbmFibGVkLnNlcnZpY2UnO1xuaW1wb3J0IHsgSVNfTkVXX0ZPUk1TX0xBWU9VVCB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmV3LWZvcm1zLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRGF0ZV0nLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRlLWlucHV0XSc6ICchbmV3Rm9ybXNMYXlvdXQnLFxuICAgICdbY2xhc3MuY2xyLWlucHV0XSc6ICduZXdGb3Jtc0xheW91dCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVJbnB1dCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJEYXRlQ29udGFpbmVyPiBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgcHJvdGVjdGVkIGluZGV4ID0gNDtcblxuICAvL1dlIG5lZWQgdGhpcyB2YXJpYWJsZSBiZWNhdXNlIGlmIHRoZSBkYXRlIGlucHV0IGhhcyBhIHZhbHVlIGluaXRpYWxpemVkXG4gIC8vd2UgZG8gbm90IG91dHB1dCBpdC4gVGhpcyB2YXJpYWJsZSBpcyBmYWxzZSBkdXJpbmcgaW5pdGlhbCBsb2FkLiBXZSBtYWtlIHN1cmUgdGhhdFxuICAvL2R1cmluZyBpbml0aWFsIGxvYWQgZGF5TW9kZWxPdXRwdXR0ZWQgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIGVudGVyZWQgYnkgdGhlIHVzZXIgc28gdGhhdCBpbml0aWFsaXplZFxuICAvL3ZhbHVlIGlzbid0IGVtaXR0ZWQgYmFjayB0byB0aGUgdXNlci4gQWZ0ZXIgaW5pdGlhbCBsb2FkLFxuICAvL3dlIHNldCB0aGlzIHRvIHRydWUgYW5kIHRoZSBkYXlNb2RlbE91dHB1dHRlZCBpcyBzZXQgb25seVxuICAvL3doZW4gdGhlIE91dHB1dCBpcyBlbWl0dGVkIHRvIHRoZSB1c2VyLlxuICBwcml2YXRlIHByZXZpb3VzT3V0cHV0SW5pdGlhbGl6ZWRGbGFnOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgcHJldmlvdXNPdXRwdXQ6IERheU1vZGVsO1xuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVByZXZpb3VzT3V0cHV0KGRheU1vZGVsOiBEYXlNb2RlbCkge1xuICAgIGlmICghdGhpcy5wcmV2aW91c091dHB1dEluaXRpYWxpemVkRmxhZykge1xuICAgICAgdGhpcy5wcmV2aW91c091dHB1dCA9IGRheU1vZGVsO1xuICAgICAgdGhpcy5wcmV2aW91c091dHB1dEluaXRpYWxpemVkRmxhZyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCkgY2xyTmV3TGF5b3V0OiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJvdGVjdGVkIGVsOiBFbGVtZW50UmVmLFxuICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByb3RlY3RlZCBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250YWluZXI6IENsckRhdGVDb250YWluZXIsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGF0ZUlPU2VydmljZTogRGF0ZUlPU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2U6IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRhdGVGb3JtQ29udHJvbFNlcnZpY2U6IERhdGVGb3JtQ29udHJvbFNlcnZpY2UsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBmb2N1c1NlcnZpY2U6IEZvY3VzU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSVNfTkVXX0ZPUk1TX0xBWU9VVClcbiAgICBwdWJsaWMgbmV3Rm9ybXNMYXlvdXQ6IGJvb2xlYW5cbiAgKSB7XG4gICAgc3VwZXIodmNyLCBDbHJEYXRlQ29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAxLiBQb3B1bGF0ZSBzZXJ2aWNlcyBpZiB0aGUgZGF0ZSBjb250YWluZXIgaXMgbm90IHByZXNlbnQuXG4gICAqIDIuIEluaXRpYWxpemUgU3Vic2NyaXB0aW9ucy5cbiAgICogMy4gUHJvY2VzcyBVc2VyIElucHV0LlxuICAgKi9cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLnBvcHVsYXRlQ29udGFpbmVyU2VydmljZXMoKTtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplU3Vic2NyaXB0aW9ucygpO1xuICAgIHRoaXMucHJvY2Vzc0luaXRpYWxJbnB1dHMoKTtcbiAgICBpZiAodGhpcy5jbHJOZXdMYXlvdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5uZXdGb3Jtc0xheW91dCA9ICEhdGhpcy5jbHJOZXdMYXlvdXQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIGlucHV0cyBpbml0aWFsaXplZCBieSB0aGUgdXNlciB3aGljaCB3ZXJlIG1pc3NlZFxuICAgKiBiZWNhdXNlIG9mIGxhdGUgc3Vic2NyaXB0aW9ucyBvciBsaWZlY3ljbGUgbWV0aG9kIGNhbGxzLlxuICAgKi9cbiAgcHJpdmF0ZSBwcm9jZXNzSW5pdGlhbElucHV0cygpOiB2b2lkIHtcbiAgICB0aGlzLnByb2Nlc3NVc2VyRGF0ZU9iamVjdCh0aGlzLmRhdGVWYWx1ZU9uSW5pdGlhbExvYWQpO1xuXG4gICAgLy8gSGFuZGxlIEluaXRhbCBWYWx1ZSBmcm9tIFJlYWN0aXZlIEZvcm1zXG4gICAgLy8gVE9ETzogV2UgYXJlIHJlcGVhdGluZyB0aGlzIGxvZ2ljIGF0IG11bHRpcGxlIHBsYWNlcy4gVGhpcyBtYWtlcyBtZSB0aGlua1xuICAgIC8vIGlmIHRoaXMgY2xhc3Mgc2hvdWxkIGhhdmUgaW1wbGVtZW50ZWQgdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZS5cbiAgICAvLyBXaWxsIGV4cGxvcmUgdGhhdCBsYXRlciBhbmQgc2VlIGlmIGl0cyBhIGNsZWFuZXIgc29sdXRpb24uXG4gICAgaWYgKHRoaXMuY29udHJvbCAmJiB0aGlzLmNvbnRyb2wudmFsdWUpIHtcbiAgICAgIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh0aGlzLmNvbnRyb2wudmFsdWUpO1xuICAgICAgdGhpcy5pbml0aWFsaXplUHJldmlvdXNPdXRwdXQodGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdGVkRGF5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgdGhlIGluaXRpYWwgaW5wdXQgc2V0IGJ5IHRoZSB1c2VyIG9uIHRvIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBJIGRvbid0IGtub3cgd2h5IEkgaGF2ZSB0byBkbyB0aGlzIGJ1dCBhZnRlciB1c2luZyB0aGUgbmV3IEhvc3RXcmFwcGluZyBNb2R1bGUgSSBoYXZlIHRvIGRlbGF5IHRoZSBwcm9jZXNzaW5nXG4gICAgLy8gb2YgdGhlIGluaXRpYWwgSW5wdXQgc2V0IGJ5IHRoZSB1c2VyIHRvIGhlcmUuICBJZiBJIGRvIG5vdCAyIGlzc3VlcyBvY2N1cjpcbiAgICAvLyAxLiB0aGUgSW5wdXQgc2V0dGVyIGlzIGNhbGxlZCBiZWZvcmUgbmdPbkluaXQuIG5nT25Jbml0IGluaXRpYWxpemVzIHRoZSBzZXJ2aWNlcyB3aXRob3V0IHdoaWNoIHRoZSBzZXR0ZXJcbiAgICAvLyBmYWlsc1xuICAgIC8vIDIuIFRoZSBSZW5kZXJlciBkb2Vzbid0IHdvcmsgYmVmb3JlIG5nQWZ0ZXJWaWV3SW5pdFxuICAgIC8vKEl0IHVzZWQgdG8gYmVmb3JlIHRoZSBuZXcgSG9zdFdyYXBwaW5nIE1vZHVsZSBmb3Igc29tZSByZWFzb24pLlxuICAgIC8vIEkgbmVlZCB0aGUgcmVuZGVyZXIgdG8gc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBvbiB0aGUgaW5wdXQgdG8gbWFrZSBzdXJlIHRoYXQgaWYgdGhlIHVzZXIgaGFzIHN1cHBsaWVkIGEgRGF0ZVxuICAgIC8vIGlucHV0IG9iamVjdCwgIHdlIHJlZmxlY3QgaXQgd2l0aCB0aGUgcmlnaHQgZGF0ZSBvbiB0aGUgaW5wdXQgZmllbGQgdXNpbmcgdGhlIElPIHNlcnZpY2UuICBJIGFtIG5vdCBzdXJlIGlmXG4gICAgLy8gdGhlc2UgYXJlIG1ham9yIGlzc3VlcyBvciBub3QgYnV0IGp1c3Qgbm90aW5nIHRoZW0gZG93biBoZXJlLlxuICAgIGlmICh0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UpIHtcbiAgICAgIGNvbnN0IHNlbERheTogRGF5TW9kZWwgPSB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXk7XG4gICAgICBpZiAoc2VsRGF5KSB7XG4gICAgICAgIGNvbnN0IGRhdGVTdHI6IHN0cmluZyA9IHRoaXMuX2RhdGVJT1NlcnZpY2UudG9Mb2NhbGVEaXNwbGF5Rm9ybWF0U3RyaW5nKHNlbERheS50b0RhdGUoKSk7XG4gICAgICAgIHRoaXMud3JpdGVEYXRlU3RyVG9JbnB1dEZpZWxkKGRhdGVTdHIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmluaXRpYWxMb2FkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGVzIHRoZSBzZXJ2aWNlcyBmcm9tIHRoZSBjb250YWluZXIgY29tcG9uZW50LlxuICAgKi9cbiAgcHJpdmF0ZSBwb3B1bGF0ZUNvbnRhaW5lclNlcnZpY2VzKCk6IHZvaWQge1xuICAgIHRoaXMuX2RhdGVJT1NlcnZpY2UgPSB0aGlzLmdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcihEYXRlSU9TZXJ2aWNlKTtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UgPSB0aGlzLmdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcihEYXRlTmF2aWdhdGlvblNlcnZpY2UpO1xuICAgIHRoaXMuX2RhdGVwaWNrZXJFbmFibGVkU2VydmljZSA9IHRoaXMuZ2V0UHJvdmlkZXJGcm9tQ29udGFpbmVyKERhdGVwaWNrZXJFbmFibGVkU2VydmljZSk7XG4gICAgdGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXIoRGF0ZUZvcm1Db250cm9sU2VydmljZSk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBkYXRlIHN0cmluZyB2YWx1ZSB0byB0aGUgaW5wdXQgZmllbGRcbiAgICovXG4gIHByaXZhdGUgd3JpdGVEYXRlU3RyVG9JbnB1dEZpZWxkKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsTG9hZDogYm9vbGVhbiA9IHRydWU7XG4gIHByaXZhdGUgZGF0ZVZhbHVlT25Jbml0aWFsTG9hZDogRGF0ZTtcblxuICAvKipcbiAgICogSmF2YXNjcmlwdCBEYXRlIG9iamVjdCBpbnB1dCBzZXQgYnkgdGhlIHVzZXIuXG4gICAqL1xuICBASW5wdXQoJ2NsckRhdGUnKVxuICBzZXQgZGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGlmICh0aGlzLmluaXRpYWxMb2FkKSB7XG4gICAgICAvLyBTdG9yZSBkYXRlIHZhbHVlIHBhc3NlZCBieSB0aGUgdXNlciB0byBwcm9jZXNzIGFmdGVyIHRoZSBzZXJ2aWNlcyBoYXZlIGJlZW4gaW5pdGlhbGl6ZWQgYnlcbiAgICAgIC8vIHRoZSBuZ09uSW5pdCBob29rLlxuICAgICAgdGhpcy5kYXRlVmFsdWVPbkluaXRpYWxMb2FkID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvY2Vzc1VzZXJEYXRlT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2Vzc2VzIGEgZGF0ZSBvYmplY3QgdG8gY2hlY2sgaWYgaXRzIHZhbGlkIG9yIG5vdC5cbiAgICovXG4gIHByaXZhdGUgcHJvY2Vzc1VzZXJEYXRlT2JqZWN0KHZhbHVlOiBEYXRlKSB7XG4gICAgaWYgKHRoaXMuX2RhdGVJT1NlcnZpY2UpIHtcbiAgICAgIC8vIFRoZSBkYXRlIG9iamVjdCBpcyBjb252ZXJ0ZWQgYmFjayB0byBzdHJpbmcgYmVjYXVzZSBpbiBKYXZhc2NyaXB0IHlvdSBjYW4gY3JlYXRlIGEgZGF0ZSBvYmplY3RcbiAgICAgIC8vIGxpa2UgdGhpczogbmV3IERhdGUoXCJUZXN0XCIpLiBUaGlzIGlzIGEgZGF0ZSBvYmplY3QgYnV0IGl0IGlzIGludmFsaWQuIENvbnZlcnRpbmcgdGhlIGRhdGUgb2JqZWN0XG4gICAgICAvLyB0aGF0IHRoZSB1c2VyIHBhc3NlZCBoZWxwcyB1cyB0byB2ZXJpZnkgdGhlIHZhbGlkaXR5IG9mIHRoZSBkYXRlIG9iamVjdC5cbiAgICAgIGNvbnN0IGRhdGVTdHI6IHN0cmluZyA9IHRoaXMuX2RhdGVJT1NlcnZpY2UudG9Mb2NhbGVEaXNwbGF5Rm9ybWF0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHRoaXMudXBkYXRlSW5wdXRWYWx1ZShkYXRlU3RyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUlucHV0VmFsdWUoZGF0ZVN0cjogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgZGF0ZTogRGF0ZSA9IHRoaXMuX2RhdGVJT1NlcnZpY2UuaXNWYWxpZElucHV0KGRhdGVTdHIpO1xuICAgIGlmIChkYXRlKSB7XG4gICAgICBjb25zdCBkYXlNb2RlbDogRGF5TW9kZWwgPSBuZXcgRGF5TW9kZWwoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgIGlmICghZGF5TW9kZWwuaXNFcXVhbCh0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkpKSB7XG4gICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheSA9IGRheU1vZGVsO1xuICAgICAgICB0aGlzLndyaXRlRGF0ZVN0clRvSW5wdXRGaWVsZChkYXRlU3RyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdGVkRGF5ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkYXRlIGZvcm1hdCBmb3IgdGhlIHBsYWNlaG9sZGVyIGFjY29yZGluZyB0byB3aGljaCB0aGUgaW5wdXQgc2hvdWxkIGJlIGVudGVyZWQgYnkgdGhlIHVzZXIuXG4gICAqL1xuICBASG9zdEJpbmRpbmcoJ2F0dHIucGxhY2Vob2xkZXInKVxuICBnZXQgcGxhY2Vob2xkZXJUZXh0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucGxhY2Vob2xkZXIgPyB0aGlzLnBsYWNlaG9sZGVyIDogdGhpcy5fZGF0ZUlPU2VydmljZS5wbGFjZWhvbGRlclRleHQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5wdXQgdHlwZSB0byB0ZXh0IHdoZW4gdGhlIGRhdGVwaWNrZXIgaXMgZW5hYmxlZC4gUmV2ZXJ0cyBiYWNrIHRvIHRoZSBuYXRpdmUgZGF0ZSBpbnB1dFxuICAgKiB3aGVuIHRoZSBkYXRlcGlja2VyIGlzIGRpc2FibGVkLiBEYXRlcGlja2VyIGlzIGRpc2FibGVkIG9uIG1vYmlsZXMuXG4gICAqL1xuICBASG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpXG4gIGdldCBpbnB1dFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLl9kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UuaXNFbmFibGVkID8gJ3RleHQnIDogJ2RhdGUnO1xuICB9XG5cbiAgLy9cbiAgLy8gT3V0cHV0IE1hbmFnZW1lbnRcbiAgLy8gTm90ZTogRm9yIG5vdyB3ZSB3aWxsIG5vdCBlbWl0IGJvdGggY2xyRGF0ZUNoYW5nZSBhbmQgbmdDb250cm9sIG91dHB1dHNcbiAgLy8gYXQgdGhlIHNhbWUgdGltZS4gVGhpcyByZXF1aXJlcyB1cyB0byBsaXN0ZW4gdG8ga2V5ZG93biBhbmQgYmx1ciBldmVudHMgdG8gZmlndXJlIG91dFxuICAvLyBleGFjdGx5IHdoZW4gdGhlIE91dHB1dCBzaG91bGQgYmUgZW1pdHRlZC5cbiAgLy8gT3VyIHJlY29tbWVuZGF0aW9uIHJpZ2h0IG5vdyBpcyB0byBlaXRoZXIgdXNlIGNsckRhdGUgb3IgdXNlIG5nTW9kZWwvRm9ybUNvbnRyb2wuXG4gIC8vIERvIG5vdCB1c2UgYm90aCBvZiB0aGVtIHRvZ2V0aGVyLlxuICAvL1xuXG4gIEBPdXRwdXQoJ2NsckRhdGVDaGFuZ2UnKSBfZGF0ZVVwZGF0ZWQ6IEV2ZW50RW1pdHRlcjxEYXRlPiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZT4oZmFsc2UpO1xuXG4gIHByaXZhdGUgZW1pdERhdGVPdXRwdXQoZGF5TW9kZWw6IERheU1vZGVsKTogdm9pZCB7XG4gICAgaWYgKGRheU1vZGVsICYmICFkYXlNb2RlbC5pc0VxdWFsKHRoaXMucHJldmlvdXNPdXRwdXQpKSB7XG4gICAgICB0aGlzLl9kYXRlVXBkYXRlZC5lbWl0KGRheU1vZGVsLnRvRGF0ZSgpKTtcbiAgICAgIHRoaXMucHJldmlvdXNPdXRwdXQgPSBkYXlNb2RlbDtcbiAgICB9IGVsc2UgaWYgKCFkYXlNb2RlbCAmJiB0aGlzLnByZXZpb3VzT3V0cHV0KSB7XG4gICAgICB0aGlzLl9kYXRlVXBkYXRlZC5lbWl0KG51bGwpO1xuICAgICAgdGhpcy5wcmV2aW91c091dHB1dCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICBzZXRGb2N1c1N0YXRlcygpIHtcbiAgICBpZiAodGhpcy5mb2N1c1NlcnZpY2UpIHtcbiAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLmZvY3VzZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICB0cmlnZ2VyVmFsaWRhdGlvbigpIHtcbiAgICBzdXBlci50cmlnZ2VyVmFsaWRhdGlvbigpO1xuICAgIGlmICh0aGlzLmZvY3VzU2VydmljZSkge1xuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB0aGlzIG1ldGhvZCB3aGVuIHRoZSB1c2VyIGNoYW5nZXMgdGhlIGlucHV0IGZvY3VzZXMgb3V0IG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2NoYW5nZScsIFsnJGV2ZW50LnRhcmdldCddKVxuICBvblZhbHVlQ2hhbmdlKHRhcmdldDogSFRNTElucHV0RWxlbWVudCkge1xuICAgIGNvbnN0IHZhbHVlOiBzdHJpbmcgPSB0YXJnZXQudmFsdWU7XG4gICAgY29uc3QgZGF0ZTogRGF0ZSA9IHRoaXMuX2RhdGVJT1NlcnZpY2UuaXNWYWxpZElucHV0KHZhbHVlKTtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgY29uc3QgZGF5TW9kZWw6IERheU1vZGVsID0gbmV3IERheU1vZGVsKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBkYXlNb2RlbDtcbiAgICAgIHRoaXMuZW1pdERhdGVPdXRwdXQoZGF5TW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBudWxsO1xuICAgICAgdGhpcy5lbWl0RGF0ZU91dHB1dChudWxsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBEYXRlSU8gU3Vic2NyaXB0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlICYmIHRoaXMuX2RhdGVJT1NlcnZpY2UpIHtcbiAgICAgIC8vIFRoaXMgc3Vic2NyaXB0aW9uIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGRhdGUgZnJvbSB0aGUgcG9wb3Zlci5cbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXlDaGFuZ2Uuc3Vic2NyaWJlKChkYXlNb2RlbDogRGF5TW9kZWwpID0+IHtcbiAgICAgICAgICBjb25zdCBkYXRlU3RyOiBzdHJpbmcgPSB0aGlzLl9kYXRlSU9TZXJ2aWNlLnRvTG9jYWxlRGlzcGxheUZvcm1hdFN0cmluZyhkYXlNb2RlbC50b0RhdGUoKSk7XG4gICAgICAgICAgdGhpcy53cml0ZURhdGVTdHJUb0lucHV0RmllbGQoZGF0ZVN0cik7XG4gICAgICAgICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgbmdNb2RlbENoYW5nZSBpcyBmaXJlZFxuICAgICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0byBkbyB0aGlzLlxuICAgICAgICAgIC8vIE5PVEU6IEl0cyBpbXBvcnRhbnQgdG8gdXNlIE5nQ29udHJvbCBhbmQgbm90IE5nTW9kZWwgYmVjYXVzZVxuICAgICAgICAgIC8vIE5nTW9kZWwgb25seSB3b3JrcyB3aXRoIHRlbXBsYXRlIGRyaXZlbiBmb3Jtc1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC5jb250cm9sLnNldFZhbHVlKGRhdGVTdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXREYXRlT3V0cHV0KGRheU1vZGVsKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFdlIGRvIG5vdCBlbWl0IGFuIE91dHB1dCBmcm9tIHRoaXMgc3Vic2NyaXB0aW9uIGJlY2F1c2VcbiAgICAgIC8vIHdlIG9ubHkgZW1pdCB0aGUgT3V0cHV0IHdoZW4gdGhlIHVzZXIgaGFzIGZvY3VzZWQgb3V0IG9mIHRoZSBpbnB1dC5cbiAgICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgICAgdGhpcy5jb250cm9sLnZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUoKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGU6IERhdGUgPSB0aGlzLl9kYXRlSU9TZXJ2aWNlLmlzVmFsaWRJbnB1dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICBjb25zdCBkYXlNb2RlbDogRGF5TW9kZWwgPSBuZXcgRGF5TW9kZWwoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLnNlbGVjdGVkRGF5ID0gZGF5TW9kZWw7XG4gICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByZXZpb3VzT3V0cHV0KGRheU1vZGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheSA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByZXZpb3VzT3V0cHV0KG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplUHJldmlvdXNPdXRwdXQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLnRvdWNoZWRDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5jb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wuY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgIHRoaXMuZGF0ZUZvcm1Db250cm9sU2VydmljZS5kaXJ0eUNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC5jb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyVmlld0NoZWNrZWQsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3RhYmxlLFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBSZW5kZXJlcjIsXG4gIFNraXBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IEVTQyB9IGZyb20gJy4uLy4uL3V0aWxzL2tleS1jb2Rlcy9rZXktY29kZXMnO1xuXG5pbXBvcnQgeyBQb2ludCwgUG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlcic7XG5pbXBvcnQgeyBQb3BvdmVyT3B0aW9ucyB9IGZyb20gJy4vcG9wb3Zlci1vcHRpb25zLmludGVyZmFjZSc7XG5cbi8vIExpdGVyYWxseSBhbnkgYW5ub3RhdGlvbiB3b3VsZCB3b3JrIGhlcmUsIGJ1dCB3cml0aW5nIG91ciBvd24gQEhvbmV5QmFkZ2VyIGFubm90YXRpb24gZmVlbHMgb3ZlcmtpbGwuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQb3BvdmVyIGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoaW5qZWN0b3I6IEluamVjdG9yLCBAU2tpcFNlbGYoKSBwcm90ZWN0ZWQgcGFyZW50SG9zdDogRWxlbWVudFJlZikge1xuICAgIHRoaXMuZWwgPSBpbmplY3Rvci5nZXQoRWxlbWVudFJlZik7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KElmT3BlblNlcnZpY2UpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBpbmplY3Rvci5nZXQoUmVuZGVyZXIyKTtcbiAgICAvLyBEZWZhdWx0IGFuY2hvciBpcyB0aGUgcGFyZW50IGhvc3RcbiAgICB0aGlzLmFuY2hvckVsZW0gPSBwYXJlbnRIb3N0Lm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICB0aGlzLnBvcG92ZXJJbnN0YW5jZSA9IG5ldyBQb3BvdmVyKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5hbmNob3IoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFU0NMaXN0ZW5lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMuZGV0YWNoRVNDTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4pIHtcbiAgICAgIHRoaXMuYW5jaG9yKCk7XG4gICAgICB0aGlzLmF0dGFjaEVTQ0xpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGVsOiBFbGVtZW50UmVmO1xuICBwcm90ZWN0ZWQgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZTtcbiAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjI7XG5cbiAgcHJpdmF0ZSBwb3BvdmVySW5zdGFuY2U6IFBvcG92ZXI7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSB1cGRhdGVBbmNob3IgPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgYW5jaG9yRWxlbTogYW55O1xuICBwcm90ZWN0ZWQgYW5jaG9yUG9pbnQ6IFBvaW50O1xuICBwcm90ZWN0ZWQgcG9wb3ZlclBvaW50OiBQb2ludDtcbiAgcHJvdGVjdGVkIHBvcG92ZXJPcHRpb25zOiBQb3BvdmVyT3B0aW9ucyA9IHt9O1xuXG4gIHByb3RlY3RlZCBpZ25vcmVkRWxlbWVudDogYW55O1xuXG4gIHByb3RlY3RlZCBhbmNob3IoKSB7XG4gICAgdGhpcy51cGRhdGVBbmNob3IgPSB0cnVlO1xuICAgIC8vIFVnaFxuICAgIHRoaXMuaWdub3JlID0gdGhpcy5pZk9wZW5TZXJ2aWNlLm9yaWdpbmFsRXZlbnQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVsZWFzZSgpIHtcbiAgICB0aGlzLmRldGFjaE91dHNpZGVDbGlja0xpc3RlbmVyKCk7XG4gICAgdGhpcy5wb3BvdmVySW5zdGFuY2UucmVsZWFzZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUFuY2hvcikge1xuICAgICAgdGhpcy51cGRhdGVBbmNob3IgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9wb3Zlckluc3RhbmNlXG4gICAgICAgIC5hbmNob3IodGhpcy5hbmNob3JFbGVtLCB0aGlzLmFuY2hvclBvaW50LCB0aGlzLnBvcG92ZXJQb2ludCwgdGhpcy5wb3BvdmVyT3B0aW9ucylcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgLy8gaWYgYSBzY3JvbGwgZXZlbnQgaXMgZGV0ZWN0ZWQsIGNsb3NlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB0aGlzLmF0dGFjaE91dHNpZGVDbGlja0xpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgdGhpcy5kZXRhY2hFU0NMaXN0ZW5lcigpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKlxuICAgICAqIEZhbGxiYWNrIHRvIGhpZGUgd2hlbiAqY2xySWZPcGVuIGlzIG5vdCBiZWluZyB1c2VkXG4gICAgICovXG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pcy1vZmYtc2NyZWVuJylcbiAgZ2V0IGlzT2ZmU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuXG4gIC8qXG4gICAgICogVW50aWwgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvODc4NSBpcyBzdXBwb3J0ZWQsIHdlIGRvbid0IGhhdmUgYW55IHdheSB0byBpbnN0YW50aWF0ZVxuICAgICAqIGEgc2VwYXJhdGUgZGlyZWN0aXZlIG9uIHRoZSBob3N0LiBTbyBsZXQncyBkbyBkaXJ0eSBidXQgcGVyZm9ybWFudCBmb3Igbm93LlxuICAgICAqL1xuICBwdWJsaWMgY2xvc2VPbk91dHNpZGVDbGljayA9IGZhbHNlO1xuICBwcml2YXRlIGhvc3RDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIGRvY3VtZW50Q2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBkb2N1bWVudEVTQ0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIGlnbm9yZWRFbGVtZW50Q2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBpZ25vcmU6IGFueTtcblxuICBwcml2YXRlIGF0dGFjaEVTQ0xpc3RlbmVyKCk6IHZvaWQge1xuICAgIHRoaXMuZG9jdW1lbnRFU0NMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleUNvZGUgPT09IEVTQykge1xuICAgICAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXRhY2hFU0NMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kb2N1bWVudEVTQ0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRvY3VtZW50RVNDTGlzdGVuZXIoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvY3VtZW50RVNDTGlzdGVuZXI7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhdHRhY2hPdXRzaWRlQ2xpY2tMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrKSB7XG4gICAgICB0aGlzLmhvc3RDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCBldmVudCA9PiAodGhpcy5pZ25vcmUgPSBldmVudCkpO1xuICAgICAgaWYgKHRoaXMuaWdub3JlZEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihcbiAgICAgICAgICB0aGlzLmlnbm9yZWRFbGVtZW50LFxuICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgZXZlbnQgPT4gKHRoaXMuaWdub3JlID0gZXZlbnQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSB0aGlzLmlnbm9yZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmlnbm9yZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRldGFjaE91dHNpZGVDbGlja0xpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2spIHtcbiAgICAgIGlmICh0aGlzLmhvc3RDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuaG9zdENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaG9zdENsaWNrTGlzdGVuZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5pZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWdub3JlZEVsZW1lbnRDbGlja0xpc3RlbmVyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5jb25zdCBlbnVtIERhdGVwaWNrZXJWaWV3RW51bSB7XG4gIE1PTlRIVklFVyA9ICdNT05USFZJRVcnLFxuICBZRUFSVklFVyA9ICdZRUFSVklFVycsXG4gIERBWVZJRVcgPSAnREFZVklFVycsXG59XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIG1hbmFnZXMgd2hpY2ggdmlldyBpcyB2aXNpYmxlIGluIHRoZSBkYXRlcGlja2VyIHBvcG92ZXIuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWaWV3TWFuYWdlclNlcnZpY2Uge1xuICBwcml2YXRlIF9jdXJyZW50VmlldzogRGF0ZXBpY2tlclZpZXdFbnVtID0gRGF0ZXBpY2tlclZpZXdFbnVtLkRBWVZJRVc7XG5cbiAgZ2V0IGlzRGF5VmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFZpZXcgPT09IERhdGVwaWNrZXJWaWV3RW51bS5EQVlWSUVXO1xuICB9XG5cbiAgZ2V0IGlzWWVhclZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBEYXRlcGlja2VyVmlld0VudW0uWUVBUlZJRVc7XG4gIH1cblxuICBnZXQgaXNNb250aFZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBEYXRlcGlja2VyVmlld0VudW0uTU9OVEhWSUVXO1xuICB9XG5cbiAgY2hhbmdlVG9Nb250aFZpZXcoKTogdm9pZCB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSBEYXRlcGlja2VyVmlld0VudW0uTU9OVEhWSUVXO1xuICB9XG5cbiAgY2hhbmdlVG9ZZWFyVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IERhdGVwaWNrZXJWaWV3RW51bS5ZRUFSVklFVztcbiAgfVxuXG4gIGNoYW5nZVRvRGF5VmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IERhdGVwaWNrZXJWaWV3RW51bS5EQVlWSUVXO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFic3RyYWN0UG9wb3ZlciB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL2Fic3RyYWN0LXBvcG92ZXInO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcblxuaW1wb3J0IHsgRGF0ZXBpY2tlckZvY3VzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBWaWV3TWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92aWV3LW1hbmFnZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kYXRlcGlja2VyLXZpZXctbWFuYWdlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRlcGlja2VyLXZpZXctbWFuYWdlci5odG1sJyxcbiAgcHJvdmlkZXJzOiBbVmlld01hbmFnZXJTZXJ2aWNlLCBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlXSxcbiAgaG9zdDogeyAnW2NsYXNzLmRhdGVwaWNrZXJdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVwaWNrZXJWaWV3TWFuYWdlciBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKEBTa2lwU2VsZigpIHBhcmVudDogRWxlbWVudFJlZiwgX2luamVjdG9yOiBJbmplY3RvciwgcHJpdmF0ZSBfdmlld01hbmFnZXJTZXJ2aWNlOiBWaWV3TWFuYWdlclNlcnZpY2UpIHtcbiAgICBzdXBlcihfaW5qZWN0b3IsIHBhcmVudCk7XG4gICAgdGhpcy5jb25maWd1cmVQb3BvdmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIFBvcG92ZXIgRGlyZWN0aW9uIGFuZCBDbG9zZSBpbmRpY2F0b3JzXG4gICAqL1xuICBwcml2YXRlIGNvbmZpZ3VyZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjdXJyZW50IHZpZXcgaXMgdGhlIG1vbnRocGlja2VyLlxuICAgKi9cbiAgZ2V0IGlzTW9udGhWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuaXNNb250aFZpZXc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudCB2aWV3IGlzIHRoZSB5ZWFycGlja2VyLlxuICAgKi9cbiAgZ2V0IGlzWWVhclZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5pc1llYXJWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGN1cnJlbnQgdmlldyBpcyB0aGUgZGF5cGlja2VyLlxuICAgKi9cbiAgZ2V0IGlzRGF5VmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld01hbmFnZXJTZXJ2aWNlLmlzRGF5VmlldztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBEYXlWaWV3TW9kZWwgfSBmcm9tICcuL21vZGVsL2RheS12aWV3Lm1vZGVsJztcbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi9tb2RlbC9kYXkubW9kZWwnO1xuaW1wb3J0IHsgRGF0ZUZvcm1Db250cm9sU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtZm9ybS1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGF5JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3M9XCJkYXktYnRuXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW2NsYXNzLmlzLXRvZGF5XT1cImRheVZpZXcuaXNUb2RheXNEYXRlXCJcbiAgICAgICAgICAgIFtjbGFzcy5pcy1kaXNhYmxlZF09XCJkYXlWaWV3LmlzRGlzYWJsZWRcIlxuICAgICAgICAgICAgW2NsYXNzLmlzLXNlbGVjdGVkXT1cImRheVZpZXcuaXNTZWxlY3RlZFwiXG4gICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJkYXlWaWV3LnRhYkluZGV4XCJcbiAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3REYXkoKVwiXG4gICAgICAgICAgICAoZm9jdXMpPVwib25EYXlWaWV3Rm9jdXMoKVwiPlxuICAgICAgICAgICAge3tkYXlWaWV3LmRheU1vZGVsLmRhdGV9fVxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuZGF5XSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXkge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9pZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgZGF0ZUZvcm1Db250cm9sU2VydmljZTogRGF0ZUZvcm1Db250cm9sU2VydmljZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIERheVZpZXdNb2RlbCBpbnB1dCB3aGljaCBpcyB1c2VkIHRvIGJ1aWxkIHRoZSBEYXkgVmlldy5cbiAgICovXG4gIEBJbnB1dCgnY2xyRGF5VmlldycpIGRheVZpZXc6IERheVZpZXdNb2RlbDtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZm9jdXNlZERheSBpbiB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHdoZW4gdGhlIENsckRheSBpcyBmb2N1c2VkLlxuICAgKi9cbiAgb25EYXlWaWV3Rm9jdXMoKSB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzZWREYXkgPSB0aGlzLmRheVZpZXcuZGF5TW9kZWw7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2VsZWN0ZWREYXkgd2hlbiB0aGUgQ2xyRGF5IGlzIHNlbGVjdGVkIGFuZCBjbG9zZXMgdGhlIGRhdGVwaWNrZXIgcG9wb3Zlci5cbiAgICovXG4gIHNlbGVjdERheSgpOiB2b2lkIHtcbiAgICBjb25zdCBkYXk6IERheU1vZGVsID0gdGhpcy5kYXlWaWV3LmRheU1vZGVsO1xuICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5ub3RpZnlTZWxlY3RlZERheUNoYW5nZWQoZGF5KTtcbiAgICB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UubWFya0FzRGlydHkoKTtcbiAgICB0aGlzLl9pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7IHNlbGVjdG9yOiAnY2xyLWRheXBpY2tlcicsIHRlbXBsYXRlVXJsOiAnLi9kYXlwaWNrZXIuaHRtbCcsIGhvc3Q6IHsgJ1tjbGFzcy5kYXlwaWNrZXJdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJEYXlwaWNrZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF92aWV3TWFuYWdlclNlcnZpY2U6IFZpZXdNYW5hZ2VyU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9sb2NhbGVIZWxwZXJTZXJ2aWNlOiBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge31cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIFZpZXdNYW5hZ2VyU2VydmljZSB0byBjaGFuZ2UgdG8gdGhlIG1vbnRocGlja2VyIHZpZXcuXG4gICAqL1xuICBjaGFuZ2VUb01vbnRoVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuY2hhbmdlVG9Nb250aFZpZXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgVmlld01hbmFnZXJTZXJ2aWNlIHRvIGNoYW5nZSB0byB0aGUgeWVhcnBpY2tlciB2aWV3LlxuICAgKi9cbiAgY2hhbmdlVG9ZZWFyVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuY2hhbmdlVG9ZZWFyVmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vbnRoIHZhbHVlIG9mIHRoZSBjYWxlbmRhciBpbiB0aGUgVHJhbnNsYXRpb25XaWR0aC5BYmJyZXZpYXRlZCBmb3JtYXQuXG4gICAqL1xuICBnZXQgY2FsZW5kYXJNb250aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZU1vbnRoc0FiYnJldmlhdGVkW3RoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhci5tb250aF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgeWVhciB2YWx1ZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBnZXQgY2FsZW5kYXJZZWFyKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhci55ZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gbW92ZSB0byB0aGUgbmV4dCBtb250aC5cbiAgICovXG4gIG5leHRNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UubW92ZVRvTmV4dE1vbnRoKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZSB0byBtb3ZlIHRvIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICovXG4gIHByZXZpb3VzTW9udGgoKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLm1vdmVUb1ByZXZpb3VzTW9udGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHRvIG1vdmUgdG8gdGhlIGN1cnJlbnQgbW9udGguXG4gICAqL1xuICBjdXJyZW50TW9udGgoKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLm1vdmVUb0N1cnJlbnRNb250aCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBET1dOX0FSUk9XLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICcuLi8uLi91dGlscy9rZXktY29kZXMva2V5LWNvZGVzJztcblxuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckZvY3VzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBMb2NhbGVIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbG9jYWxlLWhlbHBlci5zZXJ2aWNlJztcbmltcG9ydCB7IFZpZXdNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZpZXctbWFuYWdlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLW1vbnRocGlja2VyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImNhbGVuZGFyLWJ0biBtb250aFwiXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgbW9udGggb2YgbW9udGhOYW1lczsgbGV0IG1vbnRoSW5kZXggPSBpbmRleFwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2hhbmdlTW9udGgobW9udGhJbmRleClcIlxuICAgICAgICAgICAgW2NsYXNzLmlzLXNlbGVjdGVkXT1cIm1vbnRoSW5kZXggPT09IGNhbGVuZGFyTW9udGhJbmRleFwiXG4gICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJnZXRUYWJJbmRleChtb250aEluZGV4KVwiPlxuICAgICAgICAgICAge3ttb250aH19XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLm1vbnRocGlja2VyXSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTW9udGhwaWNrZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfdmlld01hbmFnZXJTZXJ2aWNlOiBWaWV3TWFuYWdlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbG9jYWxlSGVscGVyU2VydmljZTogTG9jYWxlSGVscGVyU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlOiBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2VsUmVmOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID0gdGhpcy5jYWxlbmRhck1vbnRoSW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZm9jdXNlZCBtb250aC5cbiAgICovXG4gIHByaXZhdGUgX2ZvY3VzZWRNb250aEluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1vbnRocyBhcnJheSB3aGljaCBpcyB1c2VkIHRvIHJlbmRlcmVkIHRoZSBtb250aHBpY2tlciB2aWV3LlxuICAgKiBNb250aHMgYXJlIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLldpZGUgZm9ybWF0LlxuICAgKi9cbiAgZ2V0IG1vbnRoTmFtZXMoKTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlSGVscGVyU2VydmljZS5sb2NhbGVNb250aHNXaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1vbnRoIHZhbHVlIG9mIHRoZSBDYWxlbmRhci5cbiAgICovXG4gIGdldCBjYWxlbmRhck1vbnRoSW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyLm1vbnRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gdXBkYXRlIHRoZSBtb250aCB2YWx1ZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAqIEFsc28gY2hhbmdlcyB0aGUgdmlldyB0byB0aGUgZGF5cGlja2VyLlxuICAgKi9cbiAgY2hhbmdlTW9udGgobW9udGhJbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmNoYW5nZU1vbnRoKG1vbnRoSW5kZXgpO1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb0RheVZpZXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGUgbW9udGggcGFzc2VkIHRvIHRoZSBmb2N1c2VkIG1vbnRoIGFuZCByZXR1cm5zIHRoZSB0YWIgaW5kZXguXG4gICAqL1xuICBnZXRUYWJJbmRleChtb250aEluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBtb250aEluZGV4ID09PSB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA/IDAgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBLZXlib2FyZCBhcnJvdyBuYXZpZ2F0aW9uIGZvciB0aGUgbW9udGhwaWNrZXIuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgLy8gTk9URTogRGlkbid0IG1vdmUgdGhpcyB0byB0aGUgZGF0ZSBuYXZpZ2F0aW9uIHNlcnZpY2UgYmVjYXVzZVxuICAgIC8vIHRoZSBsb2dpYyBpcyBmYWlybHkgc2ltcGxlIGFuZCBpdCBkaWRuJ3QgbWFrZSBzZW5zZSBmb3IgbWVcbiAgICAvLyB0byBjcmVhdGUgZXh0cmEgb2JzZXJ2YWJsZXMganVzdCB0byBtb3ZlIHRoaXMgbG9naWMgdG8gdGhlIHNlcnZpY2UuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb25zdCBrZXlDb2RlOiBudW1iZXIgPSBldmVudC5rZXlDb2RlO1xuICAgICAgaWYgKGtleUNvZGUgPT09IFVQX0FSUk9XICYmIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID4gMCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleC0tO1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IERPV05fQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPCAxMSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCsrO1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IFJJR0hUX0FSUk9XICYmIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4IDwgNikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA9IHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ICsgNjtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBMRUZUX0FSUk9XICYmIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID4gNSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA9IHRoaXMuX2ZvY3VzZWRNb250aEluZGV4IC0gNjtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIG9uIHRoZSBjdXJyZW50IGNhbGVuZGFyIG1vbnRoIHdoZW4gdGhlIFZpZXcgaXMgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmNvbnN0IFlFQVJTX1RPX0RJU1BMQVk6IG51bWJlciA9IDEwO1xuXG5leHBvcnQgY2xhc3MgWWVhclJhbmdlTW9kZWwge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHllYXI6IG51bWJlcikge1xuICAgIHRoaXMuZ2VuZXJhdGVZZWFyUmFuZ2UoKTtcbiAgfVxuXG4gIHllYXJSYW5nZTogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlLlxuICAgKi9cbiAgZ2V0IG1pZGRsZVllYXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyUmFuZ2VbTWF0aC5mbG9vcih0aGlzLnllYXJSYW5nZS5sZW5ndGggLyAyKV07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB5ZWFyIHJhbmdlIGJhc2VkIG9uIHRoZSB5ZWFyIHBhcmFtZXRlci5cbiAgICogZWc6IElmIDIwMTggaXMgcGFzc2VkIHRoZSBvdXRwdXQgd2lsbCBiZSBbMjAxMCwgMjAxMSwgLi4uLCAyMDE5XVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVllYXJSYW5nZSgpIHtcbiAgICBjb25zdCByZW1haW5kZXI6IG51bWJlciA9IHRoaXMueWVhciAlIFlFQVJTX1RPX0RJU1BMQVk7XG4gICAgY29uc3QgZmxvb3I6IG51bWJlciA9IHRoaXMueWVhciAtIHJlbWFpbmRlcjtcbiAgICBjb25zdCBjZWlsOiBudW1iZXIgPSBmbG9vciArIFlFQVJTX1RPX0RJU1BMQVk7XG4gICAgdGhpcy55ZWFyUmFuZ2UgPSB0aGlzLmdlbmVyYXRlUmFuZ2UoZmxvb3IsIGNlaWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlIGEgcmFuZ2Ugb2YgbnVtYmVycyBmcm9tIGZsb29yIHRvIGNlaWwuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlUmFuZ2UoZmxvb3I6IG51bWJlciwgY2VpbDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjZWlsIC0gZmxvb3IgfSwgKHYsIGspID0+IGsgKyBmbG9vcik7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCBmb3IgdGhlIG5leHQgZGVjYWRlLlxuICAgKi9cbiAgbmV4dERlY2FkZSgpOiBZZWFyUmFuZ2VNb2RlbCB7XG4gICAgcmV0dXJuIG5ldyBZZWFyUmFuZ2VNb2RlbCh0aGlzLnllYXIgKyAxMCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCBmb3IgdGhlIHByZXZpb3VzIGRlY2FkZS5cbiAgICovXG4gIHByZXZpb3VzRGVjYWRlKCk6IFllYXJSYW5nZU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IFllYXJSYW5nZU1vZGVsKHRoaXMueWVhciAtIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGZvciB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqL1xuICBjdXJyZW50RGVjYWRlKCk6IFllYXJSYW5nZU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IFllYXJSYW5nZU1vZGVsKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBpbiB0aGUgWWVhclJhbmdlTW9kZWwuXG4gICAqL1xuICBpblJhbmdlKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyUmFuZ2UuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRE9XTl9BUlJPVywgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFVQX0FSUk9XIH0gZnJvbSAnLi4vLi4vdXRpbHMva2V5LWNvZGVzL2tleS1jb2Rlcyc7XG5cbmltcG9ydCB7IFllYXJSYW5nZU1vZGVsIH0gZnJvbSAnLi9tb2RlbC95ZWFyLXJhbmdlLm1vZGVsJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXllYXJwaWNrZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwieWVhci1zd2l0Y2hlcnNcIj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJjYWxlbmRhci1idG4gc3dpdGNoZXJcIiB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cInByZXZpb3VzRGVjYWRlKClcIj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJhbmdsZVwiIGRpcj1cImxlZnRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLnByZXZpb3VzXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNhbGVuZGFyLWJ0biBzd2l0Y2hlclwiIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwiY3VycmVudERlY2FkZSgpXCI+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZXZlbnRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmN1cnJlbnRcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY2FsZW5kYXItYnRuIHN3aXRjaGVyXCIgdHlwZT1cImJ1dHRvblwiIChjbGljayk9XCJuZXh0RGVjYWRlKClcIj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJhbmdsZVwiIGRpcj1cInJpZ2h0XCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5uZXh0XCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInllYXJzXCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IHllYXIgb2YgeWVhclJhbmdlTW9kZWwueWVhclJhbmdlXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImNhbGVuZGFyLWJ0biB5ZWFyXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJnZXRUYWJJbmRleCh5ZWFyKVwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmlzLXNlbGVjdGVkXT1cInllYXIgPT09IGNhbGVuZGFyWWVhclwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImNoYW5nZVllYXIoeWVhcilcIj5cbiAgICAgICAgICAgICAgICB7e3llYXJ9fVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnllYXJwaWNrZXJdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJZZWFycGlja2VyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX3ZpZXdNYW5hZ2VyU2VydmljZTogVmlld01hbmFnZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2U6IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZWxSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7XG4gICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IG5ldyBZZWFyUmFuZ2VNb2RlbCh0aGlzLmNhbGVuZGFyWWVhcik7XG4gICAgdGhpcy5fZm9jdXNlZFllYXIgPSB0aGlzLmNhbGVuZGFyWWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBZZWFyUmFuZ2VNb2RlbCB3aGljaCBpcyB1c2VkIHRvIGJ1aWxkIHRoZSBZZWFyUGlja2VyIHZpZXcuXG4gICAqL1xuICB5ZWFyUmFuZ2VNb2RlbDogWWVhclJhbmdlTW9kZWw7XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGZvY3VzZWQgeWVhci5cbiAgICovXG4gIHByaXZhdGUgX2ZvY3VzZWRZZWFyOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHllYXIgd2hpY2ggdGhlIHVzZXIgaXMgY3VycmVudGx5IG9uLlxuICAgKi9cbiAgZ2V0IGNhbGVuZGFyWWVhcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZGlzcGxheWVkQ2FsZW5kYXIueWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBmb2N1cyB5ZWFyIGJ5IHRoZSB2YWx1ZSBwYXNzZWQuIFVwZGF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGlmIHRoZVxuICAgKiBuZXcgdmFsdWUgaXMgbm90IGluIHRoZSBjdXJyZW50IGRlY2FkZS5cbiAgICovXG4gIHByaXZhdGUgaW5jcmVtZW50Rm9jdXNZZWFyQnkodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2ZvY3VzZWRZZWFyID0gdGhpcy5fZm9jdXNlZFllYXIgKyB2YWx1ZTtcbiAgICBpZiAoIXRoaXMueWVhclJhbmdlTW9kZWwuaW5SYW5nZSh0aGlzLl9mb2N1c2VkWWVhcikpIHtcbiAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwubmV4dERlY2FkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwucHJldmlvdXNEZWNhZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gdXBkYXRlIHRoZSB5ZWFyIHZhbHVlIG9mIHRoZSBjYWxlbmRhci5cbiAgICogQWxzbyBjaGFuZ2VzIHRoZSB2aWV3IHRvIHRoZSBkYXlwaWNrZXIuXG4gICAqL1xuICBjaGFuZ2VZZWFyKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5jaGFuZ2VZZWFyKHllYXIpO1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb0RheVZpZXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCB0byB0aGUgcHJldmlvdXMgZGVjYWRlLlxuICAgKi9cbiAgcHJldmlvdXNEZWNhZGUoKTogdm9pZCB7XG4gICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwucHJldmlvdXNEZWNhZGUoKTtcbiAgICAvLyBZZWFyIGluIHRoZSB5ZWFycGlja2VyIGlzIG5vdCBmb2N1c2VkIGJlY2F1c2Ugd2hpbGUgbmF2aWdhdGluZyB0byBhIGRpZmZlcmVudCBkZWNhZGUsXG4gICAgLy8geW91IHdhbnQgdGhlIGZvY3VzIHRvIHJlbWFpbiBvbiB0aGUgZGVjYWRlIHN3aXRjaGVyIGFycm93cy5cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCB0byB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqL1xuICBjdXJyZW50RGVjYWRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy55ZWFyUmFuZ2VNb2RlbC5pblJhbmdlKHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS50b2RheS55ZWFyKSkge1xuICAgICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwuY3VycmVudERlY2FkZSgpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgdG8gdGhlIG5leHQgZGVjYWRlLlxuICAgKi9cbiAgbmV4dERlY2FkZSgpOiB2b2lkIHtcbiAgICB0aGlzLnllYXJSYW5nZU1vZGVsID0gdGhpcy55ZWFyUmFuZ2VNb2RlbC5uZXh0RGVjYWRlKCk7XG4gICAgLy8gWWVhciBpbiB0aGUgeWVhcnBpY2tlciBpcyBub3QgZm9jdXNlZCBiZWNhdXNlIHdoaWxlIG5hdmlnYXRpbmcgdG8gYSBkaWZmZXJlbnQgZGVjYWRlLFxuICAgIC8vIHlvdSB3YW50IHRoZSBmb2N1cyB0byByZW1haW4gb24gdGhlIGRlY2FkZSBzd2l0Y2hlciBhcnJvd3MuXG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdGhlIHllYXIgcGFzc2VkIHRvIHRoZSBmb2N1c2VkIHllYXIgYW5kIHJldHVybnMgdGhlIHRhYiBpbmRleC5cbiAgICovXG4gIGdldFRhYkluZGV4KHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLnllYXJSYW5nZU1vZGVsLmluUmFuZ2UodGhpcy5fZm9jdXNlZFllYXIpKSB7XG4gICAgICBpZiAodGhpcy55ZWFyUmFuZ2VNb2RlbC5pblJhbmdlKHRoaXMuY2FsZW5kYXJZZWFyKSkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkWWVhciA9IHRoaXMuY2FsZW5kYXJZZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZFllYXIgPSB0aGlzLnllYXJSYW5nZU1vZGVsLm1pZGRsZVllYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mb2N1c2VkWWVhciA9PT0geWVhciA/IDAgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBLZXlib2FyZCBhcnJvdyBuYXZpZ2F0aW9uIGZvciB0aGUgeWVhcnBpY2tlci5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBOT1RFOiBEaWRuJ3QgbW92ZSB0aGlzIHRvIHRoZSBkYXRlIG5hdmlnYXRpb24gc2VydmljZSBiZWNhdXNlXG4gICAgLy8gdGhlIGxvZ2ljIGlzIGZhaXJseSBzaW1wbGUgYW5kIGl0IGRpZG4ndCBtYWtlIHNlbnNlIGZvciBtZVxuICAgIC8vIHRvIGNyZWF0ZSBleHRyYSBvYnNlcnZhYmxlcyBqdXN0IHRvIG1vdmUgdGhpcyBsb2dpYyB0byB0aGUgc2VydmljZS5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGtleUNvZGU6IG51bWJlciA9IGV2ZW50LmtleUNvZGU7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gVVBfQVJST1cpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c1llYXJCeSgtMSk7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IERPV05fQVJST1cpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c1llYXJCeSgxKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gUklHSFRfQVJST1cpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c1llYXJCeSg1KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gTEVGVF9BUlJPVykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmluY3JlbWVudEZvY3VzWWVhckJ5KC01KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyBvbiB0aGUgY3VycmVudCBjYWxlbmRhciB5ZWFyIHdoZW4gdGhlIFZpZXcgaXMgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJGb2N1c1RyYXBNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAubW9kdWxlJztcbmltcG9ydCB7IENsckhvc3RXcmFwcGluZ01vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvaG9zdC13cmFwcGluZy5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJDYWxlbmRhciB9IGZyb20gJy4vY2FsZW5kYXInO1xuaW1wb3J0IHsgQ2xyRGF0ZUNvbnRhaW5lciB9IGZyb20gJy4vZGF0ZS1jb250YWluZXInO1xuaW1wb3J0IHsgQ2xyRGF0ZUlucHV0IH0gZnJvbSAnLi9kYXRlLWlucHV0JztcbmltcG9ydCB7IENsckRhdGVwaWNrZXJWaWV3TWFuYWdlciB9IGZyb20gJy4vZGF0ZXBpY2tlci12aWV3LW1hbmFnZXInO1xuaW1wb3J0IHsgQ2xyRGF5IH0gZnJvbSAnLi9kYXknO1xuaW1wb3J0IHsgQ2xyRGF5cGlja2VyIH0gZnJvbSAnLi9kYXlwaWNrZXInO1xuaW1wb3J0IHsgQ2xyTW9udGhwaWNrZXIgfSBmcm9tICcuL21vbnRocGlja2VyJztcbmltcG9ydCB7IENsclllYXJwaWNrZXIgfSBmcm9tICcuL3llYXJwaWNrZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX0RBVEVQSUNLRVJfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbXG4gIENsckRheSxcbiAgQ2xyRGF0ZUNvbnRhaW5lcixcbiAgQ2xyRGF0ZUlucHV0LFxuICBDbHJEYXRlcGlja2VyVmlld01hbmFnZXIsXG4gIENsck1vbnRocGlja2VyLFxuICBDbHJZZWFycGlja2VyLFxuICBDbHJEYXlwaWNrZXIsXG4gIENsckNhbGVuZGFyLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySG9zdFdyYXBwaW5nTW9kdWxlLCBDbHJDb25kaXRpb25hbE1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyRm9jdXNUcmFwTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0RBVEVQSUNLRVJfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfREFURVBJQ0tFUl9ESVJFQ1RJVkVTXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyRGF0ZUNvbnRhaW5lcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVwaWNrZXJNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWlucHV0LWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWlucHV0LXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xySW5wdXRdXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2xdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZF0nOiAnY29udHJvbD8uZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbSWZFcnJvclNlcnZpY2UsIE5nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xJZFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJJbnB1dENvbnRhaW5lciBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGludmFsaWQgPSBmYWxzZTtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpKTtcbiAgfVxuXG4gIGFkZEdyaWQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0U2VydmljZSAmJiAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xySW5wdXRDb250YWluZXIgfSBmcm9tICcuL2lucHV0LWNvbnRhaW5lcic7XG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklucHV0XScsIGhvc3Q6IHsgJ1tjbGFzcy5jbHItaW5wdXRdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJJbnB1dCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJJbnB1dENvbnRhaW5lcj4ge1xuICBwcm90ZWN0ZWQgaW5kZXggPSAxO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgY29udHJvbDogTmdDb250cm9sLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgZWw6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgc3VwZXIodmNyLCBDbHJJbnB1dENvbnRhaW5lciwgaW5qZWN0b3IsIGNvbnRyb2wsIHJlbmRlcmVyLCBlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgQ2xySW5wdXRDb250YWluZXIgfSBmcm9tICcuL2lucHV0LWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NscklucHV0LCBDbHJJbnB1dENvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xySW5wdXQsIENscklucHV0Q29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xySW5wdXRDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJJbnB1dE1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBGb2N1c1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2ZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbi8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lICovXG5leHBvcnQgY29uc3QgVG9nZ2xlU2VydmljZSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxhbnk+KHVuZGVmaW5lZCk7XG4vKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIFRvZ2dsZVNlcnZpY2VQcm92aWRlcigpIHtcbiAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xufVxuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcGFzc3dvcmQtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtd3JhcHBlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWlucHV0LWdyb3VwXCIgW2NsYXNzLmNsci1mb2N1c109XCJmb2N1c1wiPlxuICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJQYXNzd29yZF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiIXNob3cgJiYgY2xyVG9nZ2xlXCJcbiAgICAgICAgICAgIHNoYXBlPVwiZXllXCIgXG4gICAgICAgICAgICBjbGFzcz1cImNsci1pbnB1dC1ncm91cC1pY29uLWFjdGlvblwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLnNob3dcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSgpXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJzaG93ICYmIGNsclRvZ2dsZVwiIFxuICAgICAgICAgICAgc2hhcGU9XCJleWUtaGlkZVwiXG4gICAgICAgICAgICBjbGFzcz1cImNsci1pbnB1dC1ncm91cC1pY29uLWFjdGlvblwiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmhpZGVcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSgpXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgPC9kaXY+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICBJZkVycm9yU2VydmljZSxcbiAgICBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIENvbnRyb2xJZFNlcnZpY2UsXG4gICAgQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBGb2N1c1NlcnZpY2UsXG4gICAgeyBwcm92aWRlOiBUb2dnbGVTZXJ2aWNlLCB1c2VGYWN0b3J5OiBUb2dnbGVTZXJ2aWNlUHJvdmlkZXIgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUGFzc3dvcmRDb250YWluZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcbiAgc2hvdyA9IGZhbHNlO1xuICBmb2N1cyA9IGZhbHNlO1xuICBwcml2YXRlIF90b2dnbGUgPSB0cnVlO1xuXG4gIEBJbnB1dCgnY2xyVG9nZ2xlJylcbiAgc2V0IGNsclRvZ2dsZShzdGF0ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3RvZ2dsZSA9IHN0YXRlO1xuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXQgY2xyVG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl90b2dnbGU7XG4gIH1cbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgcHVibGljIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBASW5qZWN0KFRvZ2dsZVNlcnZpY2UpIHByaXZhdGUgdG9nZ2xlU2VydmljZTogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+LFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLmZvY3VzQ2hhbmdlLnN1YnNjcmliZShzdGF0ZSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXMgPSBzdGF0ZTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgICB0aGlzLnRvZ2dsZVNlcnZpY2UubmV4dCh0aGlzLnNob3cpO1xuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCkpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdCxcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgUmVuZGVyZXIyLFxuICBTZWxmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDbHJQYXNzd29yZENvbnRhaW5lciwgVG9nZ2xlU2VydmljZSB9IGZyb20gJy4vcGFzc3dvcmQtY29udGFpbmVyJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhc3N3b3JkXScsIGhvc3Q6IHsgJ1tjbGFzcy5jbHItaW5wdXRdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJQYXNzd29yZCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJQYXNzd29yZENvbnRhaW5lcj4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByb3RlY3RlZCBpbmRleCA9IDE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChUb2dnbGVTZXJ2aWNlKVxuICAgIHByaXZhdGUgdG9nZ2xlU2VydmljZTogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+XG4gICkge1xuICAgIHN1cGVyKHZjciwgQ2xyUGFzc3dvcmRDb250YWluZXIsIGluamVjdG9yLCBjb250cm9sLCByZW5kZXJlciwgZWwpO1xuXG4gICAgaWYgKCF0aGlzLmZvY3VzU2VydmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHJQYXNzd29yZCByZXF1aXJlcyBiZWluZyB3cmFwcGVkIGluIDxjbHItcGFzc3dvcmQtY29udGFpbmVyPicpO1xuICAgIH1cblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy50b2dnbGVTZXJ2aWNlLnN1YnNjcmliZSh0b2dnbGUgPT4ge1xuICAgICAgICByZW5kZXJlci5zZXRQcm9wZXJ0eShlbC5uYXRpdmVFbGVtZW50LCAndHlwZScsIHRvZ2dsZSA/ICd0ZXh0JyA6ICdwYXNzd29yZCcpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICB0cmlnZ2VyRm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmZvY3VzU2VydmljZS5mb2N1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgdHJpZ2dlclZhbGlkYXRpb24oKSB7XG4gICAgc3VwZXIudHJpZ2dlclZhbGlkYXRpb24oKTtcbiAgICBpZiAodGhpcy5mb2N1c1NlcnZpY2UpIHtcbiAgICAgIHRoaXMuZm9jdXNTZXJ2aWNlLmZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJQYXNzd29yZCB9IGZyb20gJy4vcGFzc3dvcmQnO1xuaW1wb3J0IHsgQ2xyUGFzc3dvcmRDb250YWluZXIgfSBmcm9tICcuL3Bhc3N3b3JkLWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclBhc3N3b3JkLCBDbHJQYXNzd29yZENvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyUGFzc3dvcmQsIENsclBhc3N3b3JkQ29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyUGFzc3dvcmRDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJQYXNzd29yZE1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmFkaW8td3JhcHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclJhZGlvXVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWxcIj48L2xhYmVsPlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItcmFkaW8td3JhcHBlcl0nOiAndHJ1ZScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0NvbnRyb2xJZFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJSYWRpb1dyYXBwZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciB7XG4gIC8vIFdlIG5lZWQgYm90aCBfZHluYW1pYyBmb3IgSG9zdFdyYXBwZXIgYW5kIENvbnRlbnRDaGlsZChDbHJMYWJlbCkgaW4gY2FzZXMgd2hlcmVcbiAgLy8gdGhlIHVzZXIgcHV0cyBhIHJhZGlvIGluc2lkZSBhIHdyYXBwZXIgd2l0aG91dCBhIGxhYmVsLCBob3N0IHdyYXBwaW5nIGRvZXNuJ3QgYXBwbHlcbiAgLy8gYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0byBpbnNlcnQgYSBsYWJlbFxuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBPcHRpb25hbCwgUmVuZGVyZXIyLCBTZWxmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyUmFkaW9XcmFwcGVyIH0gZnJvbSAnLi4vcmFkaW8vcmFkaW8td3JhcHBlcic7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJSYWRpb10nIH0pXG5leHBvcnQgY2xhc3MgQ2xyUmFkaW8gZXh0ZW5kcyBXcmFwcGVkRm9ybUNvbnRyb2w8Q2xyUmFkaW9XcmFwcGVyPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgY29udHJvbDogTmdDb250cm9sLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgZWw6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgc3VwZXIodmNyLCBDbHJSYWRpb1dyYXBwZXIsIGluamVjdG9yLCBjb250cm9sLCByZW5kZXJlciwgZWwpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5wdXQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IENsckxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmFkaW8tY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW2NsYXNzLmNsci1jb250cm9sLWlubGluZV09XCJjbHJJbmxpbmVcIiBbbmdDbGFzc109XCJjb250cm9sQ2xhc3MoKVwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXJhZGlvLXdyYXBwZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2xyLXN1YnRleHQtd3JhcHBlclwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW05nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2UsIElmRXJyb3JTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUmFkaW9Db250YWluZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGludmFsaWQgPSBmYWxzZTtcbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuICBwcml2YXRlIGlubGluZSA9IGZhbHNlO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgLypcbiAgICogSGVyZSB3ZSB3YW50IHRvIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBjYXNlc1xuICAgKiBjbHJJbmxpbmUgLSB0cnVlIGJ5IHByZXNlbmNlXG4gICAqIGNscklubGluZT1cInRydWV8ZmFsc2VcIiAtIHVubGVzcyBpdCBpcyBleHBsaWNpdGx5IGZhbHNlLCBzdHJpbmdzIGFyZSBjb25zaWRlcmVkIHRydWVcbiAgICogW2NscklubGluZV09XCJ0cnVlfGZhbHNlXCIgLSBleHBlY3QgYSBib29sZWFuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgY2xySW5saW5lKHZhbHVlOiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaW5saW5lID0gdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5saW5lID0gISF2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNscklubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmxpbmU7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2Uuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoaW52YWxpZCA9PiB7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCksIHRoaXMuaW5saW5lID8gJ2Nsci1jb250cm9sLWlubGluZScgOiAnJyk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJIb3N0V3JhcHBpbmdNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBpbmcubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJSYWRpbyB9IGZyb20gJy4vcmFkaW8nO1xuaW1wb3J0IHsgQ2xyUmFkaW9Db250YWluZXIgfSBmcm9tICcuL3JhZGlvLWNvbnRhaW5lcic7XG5pbXBvcnQgeyBDbHJSYWRpb1dyYXBwZXIgfSBmcm9tICcuL3JhZGlvLXdyYXBwZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xySG9zdFdyYXBwaW5nTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xyUmFkaW8sIENsclJhZGlvQ29udGFpbmVyLCBDbHJSYWRpb1dyYXBwZXJdLFxuICBleHBvcnRzOiBbQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsclJhZGlvLCBDbHJSYWRpb0NvbnRhaW5lciwgQ2xyUmFkaW9XcmFwcGVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyUmFkaW9XcmFwcGVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUmFkaW9Nb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXNlbGVjdC1jb250YWluZXInLFxuICB0ZW1wbGF0ZTogYCAgICBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgW25nQ2xhc3NdPVwid3JhcHBlckNsYXNzKClcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyU2VsZWN0XVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gKm5nSWY9XCJpbnZhbGlkXCIgY2xhc3M9XCJjbHItdmFsaWRhdGUtaWNvblwiIHNoYXBlPVwiZXhjbGFtYXRpb24tY2lyY2xlXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcblxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbSWZFcnJvclNlcnZpY2UsIE5nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xJZFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTZWxlY3RDb250YWluZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgQENvbnRlbnRDaGlsZChTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yKSBtdWx0aXBsZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgcHJpdmF0ZSBtdWx0aSA9IGZhbHNlO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5tdWx0aSA9IGNvbnRyb2wudmFsdWVBY2Nlc3NvciBpbnN0YW5jZW9mIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICB3cmFwcGVyQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGkgPyAnY2xyLW11bHRpc2VsZWN0LXdyYXBwZXInIDogJ2Nsci1zZWxlY3Qtd3JhcHBlcic7XG4gIH1cblxuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFZpZXdDb250YWluZXJSZWYsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIE9wdGlvbmFsLCBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyU2VsZWN0Q29udGFpbmVyIH0gZnJvbSAnLi9zZWxlY3QtY29udGFpbmVyJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclNlbGVjdF0nLCBob3N0OiB7ICdbY2xhc3MuY2xyLXNlbGVjdF0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsclNlbGVjdCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJTZWxlY3RDb250YWluZXI+IHtcbiAgcHJvdGVjdGVkIGluZGV4ID0gMTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHN1cGVyKHZjciwgQ2xyU2VsZWN0Q29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uRm9ybXNNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vY29tbW9uLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsclNlbGVjdCB9IGZyb20gJy4vc2VsZWN0JztcbmltcG9ydCB7IENsclNlbGVjdENvbnRhaW5lciB9IGZyb20gJy4vc2VsZWN0LWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclNlbGVjdCwgQ2xyU2VsZWN0Q29udGFpbmVyXSxcbiAgZXhwb3J0czogW0NsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJTZWxlY3QsIENsclNlbGVjdENvbnRhaW5lcl0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsclNlbGVjdENvbnRhaW5lcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclNlbGVjdE1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJZkVycm9yU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGV4dGFyZWEtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItdGV4dGFyZWEtd3JhcHBlclwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJUZXh0YXJlYV1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtJZkVycm9yU2VydmljZSwgTmdDb250cm9sU2VydmljZSwgQ29udHJvbElkU2VydmljZSwgQ29udHJvbENsYXNzU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRleHRhcmVhQ29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2Uuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoaW52YWxpZCA9PiB7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCkpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBWaWV3Q29udGFpbmVyUmVmLCBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBPcHRpb25hbCwgU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcbmltcG9ydCB7IENsclRleHRhcmVhQ29udGFpbmVyIH0gZnJvbSAnLi90ZXh0YXJlYS1jb250YWluZXInO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyVGV4dGFyZWFdJywgaG9zdDogeyAnW2NsYXNzLmNsci10ZXh0YXJlYV0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsclRleHRhcmVhIGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsclRleHRhcmVhQ29udGFpbmVyPiB7XG4gIHByb3RlY3RlZCBpbmRleCA9IDE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENsclRleHRhcmVhQ29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uRm9ybXNNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vY29tbW9uLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsclRleHRhcmVhIH0gZnJvbSAnLi90ZXh0YXJlYSc7XG5pbXBvcnQgeyBDbHJUZXh0YXJlYUNvbnRhaW5lciB9IGZyb20gJy4vdGV4dGFyZWEtY29udGFpbmVyJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRm9ybXNNb2R1bGUsIENsckljb25Nb2R1bGUsIENsckNvbW1vbkZvcm1zTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xyVGV4dGFyZWEsIENsclRleHRhcmVhQ29udGFpbmVyXSxcbiAgZXhwb3J0czogW0NsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJUZXh0YXJlYSwgQ2xyVGV4dGFyZWFDb250YWluZXJdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJUZXh0YXJlYUNvbnRhaW5lcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRleHRhcmVhTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJDaGVja2JveE1vZHVsZSB9IGZyb20gJy4vY2hlY2tib3gvY2hlY2tib3gubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi9jb21tb24vY29tbW9uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJEYXRlcGlja2VyTW9kdWxlIH0gZnJvbSAnLi9kYXRlcGlja2VyL2RhdGVwaWNrZXIubW9kdWxlJztcbmltcG9ydCB7IENscklucHV0TW9kdWxlIH0gZnJvbSAnLi9pbnB1dC9pbnB1dC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyUGFzc3dvcmRNb2R1bGUgfSBmcm9tICcuL3Bhc3N3b3JkL3Bhc3N3b3JkLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJSYWRpb01vZHVsZSB9IGZyb20gJy4vcmFkaW8vcmFkaW8ubW9kdWxlJztcbmltcG9ydCB7IENsclNlbGVjdE1vZHVsZSB9IGZyb20gJy4vc2VsZWN0L3NlbGVjdC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVGV4dGFyZWFNb2R1bGUgfSBmcm9tICcuL3RleHRhcmVhL3RleHRhcmVhLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBleHBvcnRzOiBbXG4gICAgQ2xyQ29tbW9uRm9ybXNNb2R1bGUsXG4gICAgQ2xyQ2hlY2tib3hNb2R1bGUsXG4gICAgQ2xyRGF0ZXBpY2tlck1vZHVsZSxcbiAgICBDbHJJbnB1dE1vZHVsZSxcbiAgICBDbHJQYXNzd29yZE1vZHVsZSxcbiAgICBDbHJSYWRpb01vZHVsZSxcbiAgICBDbHJTZWxlY3RNb2R1bGUsXG4gICAgQ2xyVGV4dGFyZWFNb2R1bGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsckZvcm1zTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcbmltcG9ydCB7IENsckxvYWRpbmdTdGF0ZSB9IGZyb20gJy4uLy4uL2xvYWRpbmcvbG9hZGluZyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBFeHBhbmQgaW1wbGVtZW50cyBMb2FkaW5nTGlzdGVuZXIge1xuICBwdWJsaWMgZXhwYW5kYWJsZTogbnVtYmVyID0gMDtcblxuICAvLyBwcml2YXRlIF9yZXBsYWNlOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX3JlcGxhY2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICBwdWJsaWMgZ2V0IHJlcGxhY2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX3JlcGxhY2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cbiAgc2V0UmVwbGFjZShyZXBsYWNlVmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9yZXBsYWNlLm5leHQocmVwbGFjZVZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgX2xvYWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IGxvYWRpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRpbmc7XG4gIH1cblxuICBzZXQgbG9hZGluZyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2xvYWRpbmcpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmcgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9leHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGFuZGVkO1xuICB9XG5cbiAgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fZXhwYW5kZWQpIHtcbiAgICAgIHRoaXMuX2V4cGFuZGVkID0gdmFsdWU7XG4gICAgICB0aGlzLl9hbmltYXRlLm5leHQoKTtcbiAgICAgIHRoaXMuX2V4cGFuZENoYW5nZS5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gdGhlIGRhdGFncmlkIFJvd0V4cGFuZC5cbiAgLy8gSSBzcGVudCBzb21lIHRpbWUgZG9pbmcgdGhpcyBidXQgcmFuIGludG8gYSBjb3VwbGUgb2YgaXNzdWVzXG4gIC8vIFdpbGwgdGFrZSBjYXJlIG9mIHRoaXMgbGF0ZXIuXG4gIHByaXZhdGUgX2FuaW1hdGU6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICBwdWJsaWMgZ2V0IGFuaW1hdGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9leHBhbmRDaGFuZ2U6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICBwdWJsaWMgZ2V0IGV4cGFuZENoYW5nZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fZXhwYW5kQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbG9hZGluZ1N0YXRlQ2hhbmdlKHN0YXRlOiBDbHJMb2FkaW5nU3RhdGUpOiB2b2lkIHtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIENsckxvYWRpbmdTdGF0ZS5MT0FESU5HOlxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hbmltYXRlLm5leHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBFeHBhbmQgfSBmcm9tICcuL3Byb3ZpZGVycy9leHBhbmQnO1xuXG4vKipcbiAqIFRPRE86IG1ha2UgdGhpcyBhIHJldXNhYmxlIGRpcmVjdGl2ZSBvdXRzaWRlIG9mIERhdGFncmlkLCBsaWtlIFtjbHJMb2FkaW5nXS5cbiAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklmRXhwYW5kZWRdJyB9KVxuZXhwb3J0IGNsYXNzIENscklmRXhwYW5kZWQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX2V4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xySWZFeHBhbmRlZCcpXG4gIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdGhpcy5leHBhbmQuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2V4cGFuZGVkID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xySWZFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLCBwcml2YXRlIGV4cGFuZDogRXhwYW5kKSB7XG4gICAgZXhwYW5kLmV4cGFuZGFibGUrKztcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBleHBhbmQuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmQuZXhwYW5kZWQpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gYWxsIHRoZSBzZXJ2aWNlcyBhbmQgcXVlcmllcyBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIHByaXZhdGUgdXBkYXRlVmlldygpIHtcbiAgICBpZiAodGhpcy5leHBhbmQuZXhwYW5kZWQgJiYgdGhpcy5jb250YWluZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmV4cGFuZC5leHBhbmRlZCkge1xuICAgICAgLy8gU2hvdWxkIHdlIHBhc3MgYSBjb250ZXh0PyBJIGRvbid0IHNlZSBhbnl0aGluZyB1c2VmdWwgdG8gcGFzcyByaWdodCBub3csXG4gICAgICAvLyBidXQgd2UgY2FuIGNvbWUgYmFjayB0byBpdCBpbiB0aGUgZnV0dXJlIGFzIGEgc29sdXRpb24gZm9yIGFkZGl0aW9uYWwgZmVhdHVyZXMuXG4gICAgICB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IE1vdmUgd2hlbiB3ZSBtb3ZlIHRoZSBhbmltYXRpb24gbG9naWMgdG8gRGF0YWdyaWQgUm93IEV4cGFuZFxuICAgICAgLy8gV2UgY2xlYXIgYmVmb3JlIHRoZSBhbmltYXRpb24gaXMgb3Zlci4gTm90IGlkZWFsLCBidXQgZG9pbmcgYmV0dGVyIHdvdWxkIGludm9sdmUgYSBtdWNoIGhlYXZpZXJcbiAgICAgIC8vIHByb2Nlc3MgZm9yIHZlcnkgbGl0dGxlIGdhaW4uIE9uY2UgQW5ndWxhciBhbmltYXRpb25zIGFyZSBkeW5hbWljIGVub3VnaCwgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgIC8vIGdldCB0aGUgb3B0aW1hbCBiZWhhdmlvci5cbiAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmV4cGFuZC5leHBhbmRhYmxlLS07XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJJZkV4cGFuZGVkIH0gZnJvbSAnLi9pZi1leHBhbmRlZCc7XG5cbmV4cG9ydCAqIGZyb20gJy4vaWYtZXhwYW5kZWQnO1xuXG5leHBvcnQgY29uc3QgRVhQQU5EX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NscklmRXhwYW5kZWRdO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEVYUEFORF9ESVJFQ1RJVkVTIH0gZnJvbSAnLi9pbmRleCc7XG5cbkBOZ01vZHVsZSh7IGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBkZWNsYXJhdGlvbnM6IFtFWFBBTkRfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtFWFBBTkRfRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJJZkV4cGFuZE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckxvYWRpbmcgfSBmcm9tICcuL2xvYWRpbmcnO1xuXG5leHBvcnQgY29uc3QgQ0xSX0xPQURJTkdfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyTG9hZGluZ107XG5cbkBOZ01vZHVsZSh7IGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBkZWNsYXJhdGlvbnM6IFtDTFJfTE9BRElOR19ESVJFQ1RJVkVTXSwgZXhwb3J0czogW0NMUl9MT0FESU5HX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xyTG9hZGluZ01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyT3V0c2lkZUNsaWNrXScgfSlcbmV4cG9ydCBjbGFzcyBPdXRzaWRlQ2xpY2sge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmKSB7fVxuXG4gIEBJbnB1dCgnY2xyU3RyaWN0Jykgc3RyaWN0ID0gZmFsc2U7XG5cbiAgQE91dHB1dCgnY2xyT3V0c2lkZUNsaWNrJykgb3V0c2lkZUNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50J10pXG4gIGRvY3VtZW50Q2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7IC8vIEdldCB0aGUgZWxlbWVudCBpbiB0aGUgRE9NIG9uIHdoaWNoIHRoZSBtb3VzZSB3YXMgY2xpY2tlZFxuICAgIGNvbnN0IGhvc3QgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7IC8vIEdldCB0aGUgY3VycmVudCBhY3Rpb25NZW51IG5hdGl2ZSBIVE1MIGVsZW1lbnRcblxuICAgIGlmICh0YXJnZXQgPT09IGhvc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0cmljdCAmJiBob3N0LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vdXRzaWRlQ2xpY2suZW1pdChldmVudCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE91dHNpZGVDbGljayB9IGZyb20gJy4vb3V0c2lkZS1jbGljayc7XG5cbmV4cG9ydCAqIGZyb20gJy4vb3V0c2lkZS1jbGljayc7XG5cbmV4cG9ydCBjb25zdCBPVVNUSURFX0NMSUNLX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW091dHNpZGVDbGlja107XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgT1VTVElERV9DTElDS19ESVJFQ1RJVkVTIH0gZnJvbSAnLi9pbmRleCc7XG5cbkBOZ01vZHVsZSh7IGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBkZWNsYXJhdGlvbnM6IFtPVVNUSURFX0NMSUNLX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbT1VTVElERV9DTElDS19ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsck91dHNpZGVDbGlja01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vKlxuICogSWYgd2Ugc29tZWRheSB3YW50IHRvIGJlIGFibGUgdG8gcmVuZGVyIHRoZSBkYXRhZ3JpZCBpbiBhIHdlYndvcmtlcixcbiAqIHRoaXMgaXMgd2hlcmUgd2Ugd291bGQgdGVzdCBpZiB3ZSdyZSBpbiBoZWFkbGVzcyBtb2RlLiBSaWdodCBub3cgaXQncyBub3QgdGVzdGluZyBhbnl0aGluZywgYnV0IGFueSBhY2Nlc3NcbiAqIHRvIG5hdGl2ZSBET00gZWxlbWVudHMnIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgaW4gdGhlIERhdGFncmlkIGhhcHBlbnMgaGVyZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEb21BZGFwdGVyIHtcbiAgdXNlckRlZmluZWRXaWR0aChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkYXRhZ3JpZC1jZWxsLXdpZHRoLXplcm8nKTtcbiAgICBjb25zdCB1c2VyRGVmaW5lZFdpZHRoID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpLCAxMCk7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkYXRhZ3JpZC1jZWxsLXdpZHRoLXplcm8nKTtcbiAgICByZXR1cm4gdXNlckRlZmluZWRXaWR0aDtcbiAgfVxuXG4gIHNjcm9sbEJhcldpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIHNjcm9sbFdpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFdpZHRoIHx8IDA7XG4gIH1cblxuICBjb21wdXRlZEhlaWdodChlbGVtZW50OiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpLCAxMCk7XG4gIH1cblxuICBjbGllbnRSZWN0KGVsZW1lbnQ6IGFueSk6IENsaWVudFJlY3Qge1xuICAgIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC50b3AsIDEwKSxcbiAgICAgIGJvdHRvbTogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QuYm90dG9tLCAxMCksXG4gICAgICBsZWZ0OiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC5sZWZ0LCAxMCksXG4gICAgICByaWdodDogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QucmlnaHQsIDEwKSxcbiAgICAgIHdpZHRoOiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC53aWR0aCwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC5oZWlnaHQsIDEwKSxcbiAgICB9O1xuICB9XG5cbiAgbWluV2lkdGgoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdtaW4td2lkdGgnKSwgMTApO1xuICB9XG5cbiAgZm9jdXMoZWxlbWVudDogYW55KTogdm9pZCB7XG4gICAgZWxlbWVudC5mb2N1cygpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qXG4gKiBUaGlzIGlzIGEgaGFjayB0aGF0IHdlIGhhdmUgdG8gd3JpdGUgZm9yIG5vdyBiZWNhdXNlIG9mIGJ1Z3MgYW5kIGxpbWl0YXRpb25zIGluIEFuZ3VsYXIsXG4gKiBwbGVhc2UgZG8gbm90IHVzZSB0aGlzIGFzIGFuIGV4YW1wbGUuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRnLXJvdycgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFJvd0V4cGFuZEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGV4cGFuZDogRXhwYW5kXG4gICkge1xuICAgIGlmIChleHBhbmQgJiYgZXhwYW5kLmFuaW1hdGUpIHtcbiAgICAgIGV4cGFuZC5hbmltYXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGFscmVhZHkgaGFkIGFuIGFuaW1hdGlvbiB3YWl0aW5nLCBzbyB3ZSBqdXN0IGhhdmUgdG8gcnVuIGluLCBub3QgcHJlcGFyZSBhZ2FpblxuICAgICAgICBpZiAodGhpcy5vbGRIZWlnaHQpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJ1bm5pbmc6IGFueTtcbiAgcHJpdmF0ZSBvbGRIZWlnaHQ6IG51bWJlcjtcblxuICAvKlxuICAgICAqIERpcnR5IG1hbnVhbCBhbmltYXRpb24gaGFuZGxpbmcsIGJ1dCB3ZSBoYXZlIG5vIHdheSB0byB1c2UgZHluYW1pYyBoZWlnaHRzIGluIEFuZ3VsYXIncyBjdXJyZW50IEFQSS5cbiAgICAgKiBUaGV5J3JlIHdvcmtpbmcgb24gaXQsIGJ1dCBoYXZlIG5vIEVUQS5cbiAgICAgKi9cbiAgcHJpdmF0ZSBhbmltYXRlKCkge1xuICAgIC8vIENoZWNrIGlmIHdlIGRvIGhhdmUgd2ViLWFuaW1hdGlvbnMgYXZhaWxhYmxlLiBJZiBub3QsIGp1c3Qgc2tpcCB0aGUgYW5pbWF0aW9uLlxuICAgIGlmICghdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFuaW1hdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXZSBoYWQgYW4gYW5pbWF0aW9uIHJ1bm5pbmcsIHdlIHNraXAgdG8gdGhlIGVuZFxuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVubmluZy5maW5pc2goKTtcbiAgICB9XG5cbiAgICB0aGlzLm9sZEhlaWdodCA9IHRoaXMuZG9tQWRhcHRlci5jb21wdXRlZEhlaWdodCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIC8vIFdlIHNldCB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGltbWVkaWF0ZWx5IHRvIGF2b2lkIGEgZmxpY2tlciBiZWZvcmUgdGhlIGFuaW1hdGlvbiBzdGFydHMuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCB0aGlzLm9sZEhlaWdodCArICdweCcpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnb3ZlcmZsb3cteScsICdoaWRkZW4nKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmV4cGFuZC5sb2FkaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuKCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHJ1bigpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIG51bGwpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHRoaXMuZG9tQWRhcHRlci5jb21wdXRlZEhlaWdodCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIHRoaXMucnVubmluZyA9IHRoaXMuZWwubmF0aXZlRWxlbWVudC5hbmltYXRlKFxuICAgICAgeyBoZWlnaHQ6IFt0aGlzLm9sZEhlaWdodCArICdweCcsIG5ld0hlaWdodCArICdweCddLCBlYXNpbmc6ICdlYXNlLWluLW91dCcgfSxcbiAgICAgIHsgZHVyYXRpb246IDIwMCB9XG4gICAgKTtcbiAgICB0aGlzLnJ1bm5pbmcub25maW5pc2ggPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ292ZXJmbG93LXknLCBudWxsKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJ1bm5pbmc7XG4gICAgfTtcbiAgICBkZWxldGUgdGhpcy5vbGRIZWlnaHQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDdXN0b21GaWx0ZXIge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKlxuICogVGhpcyBwcm92aWRlciBpbXBsZW1lbnRzIHNvbWUgZm9ybSBvZiBzeW5jaHJvbm91cyBkZWJvdW5jaW5nIHRocm91Z2ggYSBsb2NrIHBhdHRlcm5cbiAqIHRvIGF2b2lkIGVtaXR0aW5nIG11bHRpcGxlIHN0YXRlIGNoYW5nZXMgZm9yIGEgc2luZ2xlIHVzZXIgYWN0aW9uLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RhdGVEZWJvdW5jZXIge1xuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIGdsb2JhbCBzdGF0ZSBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2UgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKlxuICAgICAqIFRoaXMgaXMgdGhlIGxvY2ssIHRvIG9ubHkgZW1pdCBvbmNlIGFsbCB0aGUgY2hhbmdlcyBoYXZlIGZpbmlzaGVkIHByb2Nlc3NpbmdcbiAgICAgKi9cbiAgcHJpdmF0ZSBuYkNoYW5nZXMgPSAwO1xuXG4gIHB1YmxpYyBjaGFuZ2VTdGFydCgpIHtcbiAgICB0aGlzLm5iQ2hhbmdlcysrO1xuICB9XG5cbiAgcHVibGljIGNoYW5nZURvbmUoKSB7XG4gICAgaWYgKC0tdGhpcy5uYkNoYW5nZXMgPT09IDApIHtcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdGF0ZURlYm91bmNlciB9IGZyb20gJy4vc3RhdGUtZGVib3VuY2VyLnByb3ZpZGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBhZ2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHN0YXRlRGVib3VuY2VyOiBTdGF0ZURlYm91bmNlcikge31cblxuICAvKipcbiAgICogUGFnZSBzaXplLCBhIHZhbHVlIG9mIDAgbWVhbnMgbm8gcGFnaW5hdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBfc2l6ZSA9IDA7XG4gIHB1YmxpYyBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG4gIHB1YmxpYyBzZXQgc2l6ZShzaXplOiBudW1iZXIpIHtcbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5fc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0gb2xkU2l6ZSkge1xuICAgICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFllYXAuIFRoYXQncyB0aGUgZm9ybXVsYSB0byBrZWVwIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIG9sZCBwYWdlIHN0aWxsXG4gICAgICAgIC8vIGRpc3BsYXllZCBpbiB0aGUgbmV3IG9uZS5cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IE1hdGguZmxvb3Iob2xkU2l6ZSAvIHNpemUgKiAodGhpcy5fY3VycmVudCAtIDEpKSArIDE7XG4gICAgICB9XG4gICAgICAvLyBXZSBhbHdheXMgZW1pdCBhbiBldmVudCBldmVuIGlmIHRoZSBjdXJyZW50IHBhZ2UgaW5kZXggZGlkbid0IGNoYW5nZSwgYmVjYXVzZVxuICAgICAgLy8gdGhlIHNpemUgY2hhbmdpbmcgbWVhbnMgdGhlIGl0ZW1zIGluc2lkZSB0aGUgcGFnZSBhcmUgZGlmZmVyZW50XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dCh0aGlzLl9jdXJyZW50KTtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2UubmV4dCh0aGlzLl9zaXplKTtcbiAgICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb3RhbCBpdGVtcyAobmVlZGVkIHRvIGd1ZXNzIHRoZSBsYXN0IHBhZ2UpXG4gICAqL1xuICBwcml2YXRlIF90b3RhbEl0ZW1zID0gMDtcbiAgcHVibGljIGdldCB0b3RhbEl0ZW1zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsSXRlbXM7XG4gIH1cbiAgcHVibGljIHNldCB0b3RhbEl0ZW1zKHRvdGFsOiBudW1iZXIpIHtcbiAgICB0aGlzLl90b3RhbEl0ZW1zID0gdG90YWw7XG4gICAgLy8gSWYgd2UgaGF2ZSBsZXNzIGl0ZW1zIHRoYW4gYmVmb3JlLCB3ZSBtaWdodCBuZWVkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBwYWdlXG4gICAgaWYgKHRoaXMuY3VycmVudCA+IHRoaXMubGFzdCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5sYXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMYXN0IHBhZ2VcbiAgICovXG4gIHByaXZhdGUgX2xhc3Q6IG51bWJlcjtcbiAgcHVibGljIGdldCBsYXN0KCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX2xhc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXN0O1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGFzdCBwYWdlIGlzbid0IGtub3duLCB3ZSBjb21wdXRlIGl0IGZyb20gdGhlIGxhc3QgaXRlbSdzIGluZGV4XG4gICAgaWYgKHRoaXMuc2l6ZSA+IDAgJiYgdGhpcy50b3RhbEl0ZW1zKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMudG90YWxJdGVtcyAvIHRoaXMuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG4gIHB1YmxpYyBzZXQgbGFzdChwYWdlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9sYXN0ID0gcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gcGFnZSBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2UgPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2l6ZUNoYW5nZSA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcblxuICBwdWJsaWMgZ2V0IHNpemVDaGFuZ2UoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZUNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHBhZ2VcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnQgPSAxO1xuICBwdWJsaWMgZ2V0IGN1cnJlbnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuICBwdWJsaWMgc2V0IGN1cnJlbnQocGFnZTogbnVtYmVyKSB7XG4gICAgaWYgKHBhZ2UgIT09IHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBwYWdlO1xuICAgICAgdGhpcy5fY2hhbmdlLm5leHQocGFnZSk7XG4gICAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZURvbmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdG8gdGhlIHByZXZpb3VzIHBhZ2UgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgcHJldmlvdXMoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCA+IDEpIHtcbiAgICAgIHRoaXMuY3VycmVudC0tO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0byB0aGUgbmV4dCBwYWdlIGlmIGl0IGV4aXN0c1xuICAgKi9cbiAgcHVibGljIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCA8IHRoaXMubGFzdCkge1xuICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCBwYWdlLCBzdGFydGluZyBhdCAwXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpcnN0SXRlbSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuY3VycmVudCAtIDEpICogdGhpcy5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHBhZ2UsIHN0YXJ0aW5nIGF0IDBcbiAgICovXG4gIHB1YmxpYyBnZXQgbGFzdEl0ZW0oKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1zIC0gMTtcbiAgICB9XG4gICAgbGV0IGxhc3RJblBhZ2UgPSB0aGlzLmN1cnJlbnQgKiB0aGlzLnNpemUgLSAxO1xuICAgIGlmICh0aGlzLnRvdGFsSXRlbXMpIHtcbiAgICAgIGxhc3RJblBhZ2UgPSBNYXRoLm1pbihsYXN0SW5QYWdlLCB0aGlzLnRvdGFsSXRlbXMgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RJblBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBwYWdlIHNpemUgdG8gMFxuICAgKi9cbiAgcHVibGljIHJlc2V0UGFnZVNpemUoKTogdm9pZCB7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wYWdlJztcbmltcG9ydCB7IFN0YXRlRGVib3VuY2VyIH0gZnJvbSAnLi9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRmlsdGVyc1Byb3ZpZGVyPFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFnZTogUGFnZSwgcHJpdmF0ZSBzdGF0ZURlYm91bmNlcjogU3RhdGVEZWJvdW5jZXIpIHt9XG4gIC8qKlxuICAgKiBUaGlzIHN1YmplY3QgaXMgdGhlIGxpc3Qgb2YgZmlsdGVycyB0aGF0IGNoYW5nZWQgbGFzdCwgbm90IHRoZSB3aG9sZSBsaXN0LlxuICAgKiBXZSBlbWl0IGEgbGlzdCByYXRoZXIgdGhhbiBqdXN0IG9uZSBmaWx0ZXIgdG8gYWxsb3cgYmF0Y2ggY2hhbmdlcyB0byBzZXZlcmFsIGF0IG9uY2UuXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2UgPSBuZXcgU3ViamVjdDxDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdPigpO1xuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8Q2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXT4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBvZiBhbGwgZmlsdGVycywgd2hldGhlciB0aGV5J3JlIGFjdGl2ZSBvciBub3RcbiAgICovXG4gIHByaXZhdGUgX2FsbDogUmVnaXN0ZXJlZEZpbHRlcjxULCBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj5bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhdCBsZWFzdCBvbmUgZmlsdGVyIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICovXG4gIHB1YmxpYyBoYXNBY3RpdmVGaWx0ZXJzKCk6IGJvb2xlYW4ge1xuICAgIC8vIFdlIGRvIG5vdCB1c2UgZ2V0QWN0aXZlRmlsdGVycygpIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBtdWNoIG1vcmUgb2Z0ZW5cbiAgICAvLyBhbmQgc3RvcHBpbmcgdGhlIGxvb3AgZWFybHkgbWlnaHQgYmUgcmVsZXZhbnQuXG4gICAgZm9yIChjb25zdCB7IGZpbHRlciB9IG9mIHRoaXMuX2FsbCkge1xuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjdXJyZW50bHkgYWN0aXZlIGZpbHRlcnNcbiAgICovXG4gIHB1YmxpYyBnZXRBY3RpdmVGaWx0ZXJzKCk6IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+W10ge1xuICAgIGNvbnN0IHJldDogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSA9IFtdO1xuICAgIGZvciAoY29uc3QgeyBmaWx0ZXIgfSBvZiB0aGlzLl9hbGwpIHtcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgcmV0LnB1c2goZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBmaWx0ZXIsIGFuZCByZXR1cm5zIGEgZGVyZWdpc3RyYXRpb24gZnVuY3Rpb25cbiAgICovXG4gIHB1YmxpYyBhZGQ8RiBleHRlbmRzIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PihmaWx0ZXI6IEYpOiBSZWdpc3RlcmVkRmlsdGVyPFQsIEY+IHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FsbC5sZW5ndGg7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZmlsdGVyLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVzZXRQYWdlQW5kRW1pdEZpbHRlckNoYW5nZShbZmlsdGVyXSkpO1xuICAgIGxldCBoYXNVbnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBjb25zdCByZWdpc3RlcmVkID0gbmV3IFJlZ2lzdGVyZWRGaWx0ZXIoZmlsdGVyLCAoKSA9PiB7XG4gICAgICBpZiAoaGFzVW5yZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5fYWxsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBpZiAoZmlsdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5yZXNldFBhZ2VBbmRFbWl0RmlsdGVyQ2hhbmdlKFtdKTtcbiAgICAgIH1cbiAgICAgIGhhc1VucmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5fYWxsLnB1c2gocmVnaXN0ZXJlZCk7XG4gICAgaWYgKGZpbHRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLnJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoW2ZpbHRlcl0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0ZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGFuIGl0ZW0gaWYgaXQgaXMgYWNjZXB0ZWQgYnkgYWxsIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyc1xuICAgKi9cbiAgcHVibGljIGFjY2VwdHMoaXRlbTogVCk6IGJvb2xlYW4ge1xuICAgIGZvciAoY29uc3QgeyBmaWx0ZXIgfSBvZiB0aGlzLl9hbGwpIHtcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmlzQWN0aXZlKCkgJiYgIWZpbHRlci5hY2NlcHRzKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoZmlsdGVyczogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSkge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICAvLyBmaWx0ZXJpbmcgbWF5IGNoYW5nZSB0aGUgcGFnZSBudW1iZXIgc3VjaCB0aGF0IGN1cnJlbnQgcGFnZSBudW1iZXIgZG9lc24ndCBleGlzdCBpbiB0aGUgZmlsdGVyZWQgZGF0YXNldC5cbiAgICAvLyBTbyBoZXJlIHdlIGFsd2F5cyBzZXQgdGhlIGN1cnJlbnQgcGFnZSB0byAxIHNvIHRoYXQgaXQnbGwgZmV0Y2ggZmlyc3QgcGFnZSdzIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gZmlsdGVyLlxuICAgIHRoaXMuX3BhZ2UuY3VycmVudCA9IDE7XG4gICAgdGhpcy5fY2hhbmdlLm5leHQoZmlsdGVycyk7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRiBleHRlbmRzIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEYsIHB1YmxpYyB1bnJlZ2lzdGVyOiAoKSA9PiB2b2lkKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIsIFJlZ2lzdGVyZWRGaWx0ZXIgfSBmcm9tICcuLi9wcm92aWRlcnMvZmlsdGVycyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhcjxULCBGIGV4dGVuZHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmaWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4pIHt9XG5cbiAgcHVibGljIHJlZ2lzdGVyZWQ6IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRj47XG5cbiAgcHVibGljIGdldCBmaWx0ZXIoKTogRiB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZCAmJiB0aGlzLnJlZ2lzdGVyZWQuZmlsdGVyO1xuICB9XG5cbiAgcHVibGljIHNldEZpbHRlcihmaWx0ZXI6IEYgfCBSZWdpc3RlcmVkRmlsdGVyPFQsIEY+KSB7XG4gICAgLy8gSWYgd2UgcHJldmlvdXNseSBoYWQgYW5vdGhlciBmaWx0ZXIsIHdlIHVucmVnaXN0ZXIgaXRcbiAgICB0aGlzLmRlbGV0ZUZpbHRlcigpO1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBSZWdpc3RlcmVkRmlsdGVyKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWQgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IHRoaXMuZmlsdGVycy5hZGQoZmlsdGVyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlRmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZC51bnJlZ2lzdGVyKCk7XG4gICAgICBkZWxldGUgdGhpcy5yZWdpc3RlcmVkO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlbGV0ZUZpbHRlcigpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuaW1wb3J0IHsgUG9wb3Zlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDdXN0b21GaWx0ZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9jdXN0b20tZmlsdGVyJztcbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciwgUmVnaXN0ZXJlZEZpbHRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2ZpbHRlcnMnO1xuaW1wb3J0IHsgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXIgfSBmcm9tICcuL3V0aWxzL2RhdGFncmlkLWZpbHRlci1yZWdpc3RyYXInO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBDdXN0b20gZmlsdGVyIHRoYXQgY2FuIGJlIGFkZGVkIGluIGFueSBjb2x1bW4gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2JqZWN0IHByb3BlcnR5IHN0cmluZyBmaWx0ZXIuXG4gKiBUaGUgcmVhc29uIHRoaXMgaXMgbm90IGp1c3QgYW4gaW5wdXQgb24gRGF0YWdyaWRDb2x1bW4gaXMgYmVjYXVzZSB3ZSBuZWVkIHRoZSBmaWx0ZXIncyB0ZW1wbGF0ZSB0byBiZSBwcm9qZWN0ZWQsXG4gKiBzaW5jZSBpdCBjYW4gYmUgYW55dGhpbmcgKG5vdCBqdXN0IGEgdGV4dCBpbnB1dCkuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1maWx0ZXInLFxuICAvLyBXZSByZWdpc3RlciB0aGlzIGNvbXBvbmVudCBhcyBhIEN1c3RvbUZpbHRlciwgZm9yIHRoZSBwYXJlbnQgY29sdW1uIHRvIGRldGVjdCBpdC5cbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDdXN0b21GaWx0ZXIsIHVzZUV4aXN0aW5nOiBDbHJEYXRhZ3JpZEZpbHRlciB9XSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiAjYW5jaG9yIGNsYXNzPVwiZGF0YWdyaWQtZmlsdGVyLXRvZ2dsZVwiIChjbGljayk9XCJ0b2dnbGUoKVwiXG4gICAgICAgICAgICBbY2xhc3MuZGF0YWdyaWQtZmlsdGVyLW9wZW5dPVwib3BlblwiIFtjbGFzcy5kYXRhZ3JpZC1maWx0ZXJlZF09XCJhY3RpdmVcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbKGNsclBvcG92ZXJPbGQpXT1cIm9wZW5cIiBbY2xyUG9wb3Zlck9sZEFuY2hvcl09XCJhbmNob3JcIiBbY2xyUG9wb3Zlck9sZEFuY2hvclBvaW50XT1cImFuY2hvclBvaW50XCJcbiAgICAgICAgICAgICBbY2xyUG9wb3Zlck9sZFBvcG92ZXJQb2ludF09XCJwb3BvdmVyUG9pbnRcIiBbY2xyUG9wb3Zlck9sZE9wdGlvbnNdPVwicG9wb3Zlck9wdGlvbnNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1maWx0ZXJcIj5cbiAgICAgICAgICAgICAgICA8IS0tIEZJWE1FOiB0aGlzIHdob2xlIGZpbHRlciBwYXJ0IG5lZWRzIGEgZmluYWwgZGVzaWduIGJlZm9yZSB3ZSBjYW4gdHJ5IHRvIGhhdmUgYSBjbGVhbmVyIERPTSAtLT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtZmlsdGVyLWNsb3NlLXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIChjbGljayk9XCJvcGVuID0gZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNsb3NlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5jbG9zZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgIFxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkRmlsdGVyPFQgPSBhbnk+IGV4dGVuZHMgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXI8VCwgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+XG4gIGltcGxlbWVudHMgQ3VzdG9tRmlsdGVyIHtcbiAgY29uc3RydWN0b3IoX2ZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPiwgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MpIHtcbiAgICBzdXBlcihfZmlsdGVycyk7XG4gIH1cblxuICBwdWJsaWMgYW5jaG9yUG9pbnQ6IFBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICBwdWJsaWMgcG9wb3ZlclBvaW50OiBQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgcHVibGljIHBvcG92ZXJPcHRpb25zOiBQb3BvdmVyT3B0aW9ucyA9IHsgYWxsb3dNdWx0aXBsZU9wZW46IHRydWUgfTtcbiAgLyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIHRoZSBmaWx0ZXIgZHJvcGRvd24gaXMgb3BlbiBvciBub3RcbiAgICovXG4gIHByaXZhdGUgX29wZW4gPSBmYWxzZTtcbiAgcHVibGljIGdldCBvcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0ZpbHRlck9wZW4nKVxuICBwdWJsaWMgc2V0IG9wZW4ob3BlbjogYm9vbGVhbikge1xuICAgIGNvbnN0IGJvb2xPcGVuID0gISFvcGVuO1xuICAgIGlmIChib29sT3BlbiAhPT0gdGhpcy5fb3Blbikge1xuICAgICAgdGhpcy5fb3BlbiA9IGJvb2xPcGVuO1xuICAgICAgdGhpcy5vcGVuQ2hhbmdlZC5lbWl0KGJvb2xPcGVuKTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ0ZpbHRlck9wZW5DaGFuZ2UnKSBwdWJsaWMgb3BlbkNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBASW5wdXQoJ2NsckRnRmlsdGVyJylcbiAgcHVibGljIHNldCBjdXN0b21GaWx0ZXIoZmlsdGVyOiBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPiB8IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+KSB7XG4gICAgdGhpcy5zZXRGaWx0ZXIoZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGZpbHRlciBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLmZpbHRlciAmJiB0aGlzLmZpbHRlci5pc0FjdGl2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3dzL2hpZGVzIHRoZSBmaWx0ZXIgZHJvcGRvd25cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ZpbHRlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3N0cmluZy1maWx0ZXIuaW50ZXJmYWNlJztcblxuZXhwb3J0IGNsYXNzIERhdGFncmlkU3RyaW5nRmlsdGVySW1wbDxUID0gYW55PiBpbXBsZW1lbnRzIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIGZpbHRlckZuOiBDbHJEYXRhZ3JpZFN0cmluZ0ZpbHRlckludGVyZmFjZTxUPikge31cblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgcmVxdWlyZWQgYXMgcGFydCBvZiB0aGUgRmlsdGVyIGludGVyZmFjZVxuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlcyA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcbiAgLy8gV2UgZG8gbm90IHdhbnQgdG8gZXhwb3NlIHRoZSBTdWJqZWN0IGl0c2VsZiwgYnV0IHRoZSBPYnNlcnZhYmxlIHdoaWNoIGlzIHJlYWQtb25seVxuICBwdWJsaWMgZ2V0IGNoYW5nZXMoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSYXcgaW5wdXQgdmFsdWVcbiAgICovXG4gIHByaXZhdGUgX3Jhd1ZhbHVlOiBzdHJpbmcgPSAnJztcbiAgcHVibGljIGdldCB2YWx1ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9yYXdWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogSW5wdXQgdmFsdWUgY29udmVydGVkIHRvIGxvd2VyY2FzZVxuICAgKi9cbiAgcHJpdmF0ZSBfbG93ZXJDYXNlVmFsdWU6IHN0cmluZyA9ICcnO1xuICBwdWJsaWMgZ2V0IGxvd2VyQ2FzZVZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9sb3dlckNhc2VWYWx1ZTtcbiAgfVxuICAvKipcbiAgICogQ29tbW9uIHNldHRlciBmb3IgdGhlIGlucHV0IHZhbHVlXG4gICAqL1xuICBwdWJsaWMgc2V0IHZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX3Jhd1ZhbHVlKSB7XG4gICAgICB0aGlzLl9yYXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5fbG93ZXJDYXNlVmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgIHRoaXMuX2NoYW5nZXMubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgZmlsdGVyIGlzIGN1cnJlbnRseSBhY3RpdmUsIG1lYW5pbmcgdGhlIGlucHV0IGlzIG5vdCBlbXB0eVxuICAgKi9cbiAgcHVibGljIGlzQWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMudmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGVzdHMgaWYgYW4gaXRlbSBtYXRjaGVzIGEgc2VhcmNoIHRleHRcbiAgICovXG4gIHB1YmxpYyBhY2NlcHRzKGl0ZW06IFQpOiBib29sZWFuIHtcbiAgICAvLyBXZSBhbHdheXMgdGVzdCB3aXRoIHRoZSBsb3dlcmNhc2UgdmFsdWUgb2YgdGhlIGlucHV0LCB0byBzdGF5IGNhc2UgaW5zZW5zaXRpdmVcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJGbi5hY2NlcHRzKGl0ZW0sIHRoaXMubG93ZXJDYXNlVmFsdWUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkRmlsdGVyIH0gZnJvbSAnLi4vLi4vZGF0YWdyaWQtZmlsdGVyJztcbmltcG9ydCB7IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9zdHJpbmctZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDdXN0b21GaWx0ZXIgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvY3VzdG9tLWZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIsIFJlZ2lzdGVyZWRGaWx0ZXIgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvZmlsdGVycyc7XG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbHMvZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXIgfSBmcm9tICcuLi8uLi91dGlscy9kYXRhZ3JpZC1maWx0ZXItcmVnaXN0cmFyJztcblxuaW1wb3J0IHsgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsIH0gZnJvbSAnLi9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLWltcGwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctc3RyaW5nLWZpbHRlcicsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ3VzdG9tRmlsdGVyLCB1c2VFeGlzdGluZzogRGF0YWdyaWRTdHJpbmdGaWx0ZXIgfV0sXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxjbHItZGctZmlsdGVyIFtjbHJEZ0ZpbHRlcl09XCJyZWdpc3RlcmVkXCIgWyhjbHJEZ0ZpbHRlck9wZW4pXT1cIm9wZW5cIj5cbiAgICAgICAgICAgIDwhLS1cbiAgICAgICAgICAgICAgICBFdmVuIHRob3VnaCB0aGlzICpuZ0lmIGxvb2tzIHVzZWxlc3MgYmVjYXVzZSB0aGUgZmlsdGVyIGNvbnRhaW5lciBhbHJlYWR5IGhhcyBvbmUsXG4gICAgICAgICAgICAgICAgaXQgcHJldmVudHMgTmdDb250cm9sU3RhdHVzIGFuZCBvdGhlciBkaXJlY3RpdmVzIGF1dG9tYXRpY2FsbHkgYWRkZWQgYnkgQW5ndWxhclxuICAgICAgICAgICAgICAgIG9uIGlucHV0cyB3aXRoIE5nTW9kZWwgZnJvbSBmcmVha2luZyBvdXQgYmVjYXVzZSBvZiB0aGVpciBob3N0IGJpbmRpbmcgY2hhbmdpbmdcbiAgICAgICAgICAgICAgICBtaWQtY2hhbmdlIGRldGVjdGlvbiB3aGVuIHRoZSBpbnB1dCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAgICAtLT5cbiAgICAgICAgICAgIDxpbnB1dCAjaW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwic2VhcmNoXCIgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiICpuZ0lmPVwib3BlblwiXG4gICAgICAgICAgICAgICAgKGtleXVwLmVudGVyKT1cImNsb3NlKClcIiAoa2V5dXAuZXNjYXBlKT1cImNsb3NlKClcIi8+XG4gICAgICAgIDwvY2xyLWRnLWZpbHRlcj5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFN0cmluZ0ZpbHRlcjxUID0gYW55PiBleHRlbmRzIERhdGFncmlkRmlsdGVyUmVnaXN0cmFyPFQsIERhdGFncmlkU3RyaW5nRmlsdGVySW1wbDxUPj5cbiAgaW1wbGVtZW50cyBDdXN0b21GaWx0ZXIsIEFmdGVyVmlld0luaXQge1xuICBjb25zdHJ1Y3RvcihmaWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4sIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcikge1xuICAgIHN1cGVyKGZpbHRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEN1c3RvbWl6YWJsZSBmaWx0ZXIgbG9naWMgYmFzZWQgb24gYSBzZWFyY2ggdGV4dFxuICAgKi9cbiAgQElucHV0KCdjbHJEZ1N0cmluZ0ZpbHRlcicpXG4gIHNldCBjdXN0b21TdHJpbmdGaWx0ZXIoXG4gICAgdmFsdWU6IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlPFQ+IHwgUmVnaXN0ZXJlZEZpbHRlcjxULCBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGw8VD4+XG4gICkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ2lzdGVyZWRGaWx0ZXIpIHtcbiAgICAgIHRoaXMuc2V0RmlsdGVyKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRGaWx0ZXIobmV3IERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGZpbHRlciBkcm9wZG93biBpcyBvcGVuXG4gICAqL1xuICBwdWJsaWMgb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBXZSBuZWVkIHRoZSBhY3R1YWwgaW5wdXQgZWxlbWVudCB0byBhdXRvbWF0aWNhbGx5IGZvY3VzIG9uIGl0XG4gICAqL1xuICBAVmlld0NoaWxkKCdpbnB1dCcpIHB1YmxpYyBpbnB1dDogRWxlbWVudFJlZjtcblxuICAvKipcbiAgICogV2UgZ3JhYiB0aGUgQ2xyRGF0YWdyaWRGaWx0ZXIgd2Ugd3JhcCB0byByZWdpc3RlciB0aGlzIFN0cmluZ0ZpbHRlciB0byBpdC5cbiAgICovXG4gIEBWaWV3Q2hpbGQoQ2xyRGF0YWdyaWRGaWx0ZXIpIHB1YmxpYyBmaWx0ZXJDb250YWluZXI6IENsckRhdGFncmlkRmlsdGVyPFQ+O1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5maWx0ZXJDb250YWluZXIub3BlbkNoYW5nZWQuc3Vic2NyaWJlKChvcGVuOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAob3Blbikge1xuICAgICAgICAvLyBXZSBuZWVkIHRoZSB0aW1lb3V0IGJlY2F1c2UgYXQgdGhlIHRpbWUgdGhpcyBleGVjdXRlcywgdGhlIGlucHV0IGlzbid0XG4gICAgICAgIC8vIGRpc3BsYXllZCB5ZXQuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZG9tQWRhcHRlci5mb2N1cyh0aGlzLmlucHV0Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21tb24gc2V0dGVyIGZvciB0aGUgaW5wdXQgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyLnZhbHVlO1xuICB9XG4gIEBJbnB1dCgnY2xyRmlsdGVyVmFsdWUnKVxuICBwdWJsaWMgc2V0IHZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAoIXRoaXMuZmlsdGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5maWx0ZXIudmFsdWUpIHtcbiAgICAgIHRoaXMuZmlsdGVyLnZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLmZpbHRlclZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckZpbHRlclZhbHVlQ2hhbmdlJykgZmlsdGVyVmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcHVibGljIGNsb3NlKCkge1xuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRDaGVja2VkLCBDaGFuZ2VEZXRlY3RvclJlZiwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFdpbGx5V29ua2EgfSBmcm9tICcuL3dpbGx5LXdvbmthJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE9vbXBhTG9vbXBhIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgLy8gRklYTUU6IFJlcXVlc3QgSW5qZWN0b3Igb25jZSB3ZSBtb3ZlIHRvIEFuZ3VsYXIgNC4yKywgaXQnbGwgYWxsb3cgZWFzaWVyIHJlZmFjdG9yc1xuICBjb25zdHJ1Y3RvcihjZHI6IENoYW5nZURldGVjdG9yUmVmLCB3aWxseVdvbmthOiBXaWxseVdvbmthKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB3aWxseVdvbmthLmNob2NvbGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMubGF0ZXN0Rmxhdm9yICE9PSB0aGlzLmZsYXZvcikge1xuICAgICAgICBjZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIGxhdGVzdEZsYXZvcjogYW55O1xuXG4gIGFic3RyYWN0IGdldCBmbGF2b3IoKTogYW55O1xuXG4gIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICB0aGlzLmxhdGVzdEZsYXZvciA9IHRoaXMuZmxhdm9yO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSb3dBY3Rpb25TZXJ2aWNlIHtcbiAgcHJpdmF0ZSBhY3Rpb25hYmxlQ291bnQgPSAwO1xuXG4gIHB1YmxpYyByZWdpc3RlcigpIHtcbiAgICB0aGlzLmFjdGlvbmFibGVDb3VudCsrO1xuICB9XG5cbiAgcHVibGljIHVucmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5hY3Rpb25hYmxlQ291bnQtLTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmYWxzZSBtZWFucyBubyByb3dzIHdpdGggYWN0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhhc0FjdGlvbmFibGVSb3coKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9uYWJsZUNvdW50ID4gMDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3Q2hlY2tlZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKlxuICogQWZ0ZXIgYSBjb252ZXJzYXRpb24gd2l0aCB0aGUgQW5ndWxhciBjb3JlIHRlYW0sIGl0IHR1cm5zIG91dCB3ZSBkb24ndCBoYXZlIG11Y2ggb2YgYSBjaG9pY2UgZm9yIG91clxuICogZGVjbGFyYXRpdmUgQVBJLCB3ZSBuZWVkIHRvIGZpZ2h0IGFnYWluc3QgY2hhbmdlIGRldGVjdGlvbiBhbmQgaXRzIG9uZS13YXkgZmxvdy4gVGhpcyBpc1xuICogY3VycmVudGx5IHRoZSBsZWFzdCBkaXJ0eSBzb2x1dGlvbiB0byBkbyB3aGF0IHdlIHdhbnQuXG4gKlxuICogRG8gbm90IG1vZGlmeSBvciBldmVuIHVzZSB0aGlzIGNsYXNzIHVubGVzcyB5b3Uga25vdyBleGFjdGx5IHdoYXQgeW91J3JlIGRvaW5nLlxuICogSXQgaGFzIHRoZSBwb3RlbnRpYWwgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3BzIG9yIGtpbGwgYXBwIHBlcmZvcm1hbmNlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFdpbGx5V29ua2EgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkIHtcbiAgcHJpdmF0ZSBfY2hvY29sYXRlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBwdWJsaWMgZ2V0IGNob2NvbGF0ZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hvY29sYXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgIHRoaXMuX2Nob2NvbGF0ZS5uZXh0KCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgV2lsbHlXb25rYSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2Nob2NvbGF0ZS93aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kYXRhZ3JpZCcgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFdpbGx5V29ua2EgZXh0ZW5kcyBXaWxseVdvbmthIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT29tcGFMb29tcGEgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IFJvd0FjdGlvblNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvcm93LWFjdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IERhdGFncmlkV2lsbHlXb25rYSB9IGZyb20gJy4vZGF0YWdyaWQtd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGF0YWdyaWQsIGNsci1kZy1yb3cnIH0pXG5leHBvcnQgY2xhc3MgQWN0aW9uYWJsZU9vbXBhTG9vbXBhIGV4dGVuZHMgT29tcGFMb29tcGEge1xuICBwcml2YXRlIHJvd0FjdGlvbnM6IFJvd0FjdGlvblNlcnZpY2U7XG5cbiAgY29uc3RydWN0b3IoY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgQE9wdGlvbmFsKCkgd2lsbHlXb25rYTogRGF0YWdyaWRXaWxseVdvbmthLCByb3dBY3Rpb25zOiBSb3dBY3Rpb25TZXJ2aWNlKSB7XG4gICAgaWYgKCF3aWxseVdvbmthKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1kZy1yb3cgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItZGF0YWdyaWQnKTtcbiAgICB9XG4gICAgc3VwZXIoY2RyLCB3aWxseVdvbmthKTtcbiAgICB0aGlzLnJvd0FjdGlvbnMgPSByb3dBY3Rpb25zO1xuICB9XG5cbiAgZ2V0IGZsYXZvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dBY3Rpb25zLmhhc0FjdGlvbmFibGVSb3c7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEV4cGFuZGFibGVSb3dzQ291bnQge1xuICBwcml2YXRlIGV4cGFuZGFibGVDb3VudCA9IDA7XG5cbiAgcHVibGljIHJlZ2lzdGVyKCkge1xuICAgIHRoaXMuZXhwYW5kYWJsZUNvdW50Kys7XG4gIH1cblxuICBwdWJsaWMgdW5yZWdpc3RlcigpIHtcbiAgICB0aGlzLmV4cGFuZGFibGVDb3VudC0tO1xuICB9XG5cbiAgLyoqXG4gICAqIGZhbHNlIG1lYW5zIG5vIHJvd3Mgd2l0aCBhY3Rpb25cbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzRXhwYW5kYWJsZVJvdygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlQ291bnQgPiAwO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT29tcGFMb29tcGEgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuLi9wcm92aWRlcnMvZ2xvYmFsLWV4cGFuZGFibGUtcm93cyc7XG5pbXBvcnQgeyBEYXRhZ3JpZFdpbGx5V29ua2EgfSBmcm9tICcuL2RhdGFncmlkLXdpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRhdGFncmlkLCBjbHItZGctcm93JyB9KVxuZXhwb3J0IGNsYXNzIEV4cGFuZGFibGVPb21wYUxvb21wYSBleHRlbmRzIE9vbXBhTG9vbXBhIHtcbiAgcHJpdmF0ZSBleHBhbmRhYmxlQ291bnQ6IEV4cGFuZGFibGVSb3dzQ291bnQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSB3aWxseVdvbmthOiBEYXRhZ3JpZFdpbGx5V29ua2EsXG4gICAgZXhwYW5kYWJsZUNvdW50OiBFeHBhbmRhYmxlUm93c0NvdW50XG4gICkge1xuICAgIGlmICghd2lsbHlXb25rYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItZGctcm93IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLWRhdGFncmlkJyk7XG4gICAgfVxuICAgIHN1cGVyKGNkciwgd2lsbHlXb25rYSk7XG4gICAgdGhpcy5leHBhbmRhYmxlQ291bnQgPSBleHBhbmRhYmxlQ291bnQ7XG4gIH1cblxuICBnZXQgZmxhdm9yKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGVDb3VudC5oYXNFeHBhbmRhYmxlUm93O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG4vKipcbiAqIEdlbmVyaWMgYWNjZXNzb3IgZm9yIGRlZXAgb2JqZWN0IHByb3BlcnRpZXNcbiAqIHRoYXQgY2FuIGJlIHNwZWNpZmllZCBhcyBzaW1wbGUgZG90LXNlcGFyYXRlZCBzdHJpbmdzLlxuICovXG5leHBvcnQgY2xhc3MgTmVzdGVkUHJvcGVydHk8VCA9IGFueT4ge1xuICBwcml2YXRlIHNwbGl0UHJvcDogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcm9wOiBzdHJpbmcpIHtcbiAgICBpZiAocHJvcC5pbmRleE9mKCcuJykgPj0gMCkge1xuICAgICAgdGhpcy5zcGxpdFByb3AgPSBwcm9wLnNwbGl0KCcuJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2FmZSBnZXR0ZXIgZm9yIGEgZGVlcCBvYmplY3QgcHJvcGVydHksIHdpbGwgbm90IHRocm93IGFuIGVycm9yIGJ1dCByZXR1cm5cbiAgLy8gdW5kZWZpbmVkIGlmIG9uZSBvZiB0aGUgaW50ZXJtZWRpYXRlIHByb3BlcnRpZXMgaXMgbnVsbCBvciB1bmRlZmluZWQuXG4gIHB1YmxpYyBnZXRQcm9wVmFsdWUoaXRlbTogVCk6IGFueSB7XG4gICAgaWYgKHRoaXMuc3BsaXRQcm9wKSB7XG4gICAgICBsZXQgdmFsdWUgPSBpdGVtO1xuICAgICAgZm9yIChjb25zdCBuZXN0ZWRQcm9wIG9mIHRoaXMuc3BsaXRQcm9wKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlW25lc3RlZFByb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVtuZXN0ZWRQcm9wXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGl0ZW1bdGhpcy5wcm9wXTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvY29tcGFyYXRvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTmVzdGVkUHJvcGVydHkgfSBmcm9tICcuLi9uZXN0ZWQtcHJvcGVydHknO1xuXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRQcm9wZXJ0eUNvbXBhcmF0b3I8VCA9IGFueT4gaW1wbGVtZW50cyBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2U8VD4ge1xuICBwcml2YXRlIG5lc3RlZFByb3A6IE5lc3RlZFByb3BlcnR5PFQ+O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwcm9wOiBzdHJpbmcpIHtcbiAgICB0aGlzLm5lc3RlZFByb3AgPSBuZXcgTmVzdGVkUHJvcGVydHkocHJvcCk7XG4gIH1cblxuICBwdWJsaWMgY29tcGFyZShhOiBULCBiOiBUKTogbnVtYmVyIHtcbiAgICBsZXQgcHJvcEEgPSB0aGlzLm5lc3RlZFByb3AuZ2V0UHJvcFZhbHVlKGEpO1xuICAgIGxldCBwcm9wQiA9IHRoaXMubmVzdGVkUHJvcC5nZXRQcm9wVmFsdWUoYik7XG5cbiAgICBpZiAodHlwZW9mIHByb3BBID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvcEEgPSBwcm9wQS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcHJvcEIgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm9wQiA9IHByb3BCLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9wQSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcEEgPT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcEIgPT09ICd1bmRlZmluZWQnIHx8IHByb3BCID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcEIgPT09ICd1bmRlZmluZWQnIHx8IHByb3BCID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcEEgPCBwcm9wQikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKHByb3BBID4gcHJvcEIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9zdHJpbmctZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBOZXN0ZWRQcm9wZXJ0eSB9IGZyb20gJy4uL25lc3RlZC1wcm9wZXJ0eSc7XG5cbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyPFQgPSBhbnk+IGltcGxlbWVudHMgQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2U8VD4ge1xuICBwcml2YXRlIG5lc3RlZFByb3A6IE5lc3RlZFByb3BlcnR5PFQ+O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwcm9wOiBzdHJpbmcsIHB1YmxpYyBleGFjdCA9IGZhbHNlKSB7XG4gICAgdGhpcy5uZXN0ZWRQcm9wID0gbmV3IE5lc3RlZFByb3BlcnR5KHByb3ApO1xuICB9XG5cbiAgYWNjZXB0cyhpdGVtOiBULCBzZWFyY2g6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByb3BWYWx1ZSA9IHRoaXMubmVzdGVkUHJvcC5nZXRQcm9wVmFsdWUoaXRlbSk7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLmV4YWN0KSB7XG4gICAgICByZXR1cm4gKCcnICsgcHJvcFZhbHVlKS50b0xvd2VyQ2FzZSgpID09PSBzZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoJycgKyBwcm9wVmFsdWUpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpID49IDA7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qKlxuICogRW51bWVyYXRpb24gcmVwcmVzZW50aW5nIHRoZSBzb3J0aW5nIG9yZGVyIG9mIGEgZGF0YWdyaWQgY29sdW1uLiBJdCBpcyBhIGNvbnN0YW50IEVudW0sXG4gKiBpLmUuIGVhY2ggdmFsdWUgbmVlZHMgdG8gYmUgdHJlYXRlZCBhcyBhIGBudW1iZXJgLCBzdGFydGluZyBhdCBpbmRleCAwLlxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBlbnVtIENsckRhdGFncmlkU29ydE9yZGVyIHtcbiAgVU5TT1JURUQgPSAwLFxuICBBU0MgPSAxLFxuICBERVNDID0gLTEsXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGFibGUsIE5nWm9uZSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnRGlzcGF0Y2hlciB7XG4gIHByaXZhdGUgX2xpc3RlbmVyczogRnVuY3Rpb25bXTtcblxuICAvLyBXaWxsIGJlIGxpc3RlbmluZyB0byBEcmFnIGV2ZW50cyBvbiB0aGUgZm9sbG93aW5nIGVsZW1lbnRcbiAgaGFuZGxlUmVmOiBFbGVtZW50UmVmO1xuXG4gIC8vIEV4dHJhIGVsZW1lbnQgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgZHJhZyBtb3ZlbWVudHMuXG4gIGhhbmRsZVRyYWNrZXJSZWY6IEVsZW1lbnRSZWY7XG5cbiAgcHJpdmF0ZSBfb25EcmFnU3RhcnQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHJpdmF0ZSBfb25EcmFnTW92ZTogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwcml2YXRlIF9vbkRyYWdFbmQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICBnZXQgb25EcmFnU3RhcnQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fb25EcmFnU3RhcnQ7XG4gIH1cblxuICBnZXQgb25EcmFnTW92ZSgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9vbkRyYWdNb3ZlO1xuICB9XG5cbiAgZ2V0IG9uRHJhZ0VuZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9vbkRyYWdFbmQ7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBhZGREcmFnTGlzdGVuZXIoKSB7XG4gICAgY29uc3QgaGFuZGxlRWwgPSB0aGlzLmhhbmRsZVJlZi5uYXRpdmVFbGVtZW50O1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtcbiAgICAgIHRoaXMuY3VzdG9tRHJhZ0V2ZW50KGhhbmRsZUVsLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJyksXG4gICAgICB0aGlzLmN1c3RvbURyYWdFdmVudChoYW5kbGVFbCwgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJyksXG4gICAgXTtcbiAgfVxuXG4gIGN1c3RvbURyYWdFdmVudChlbGVtZW50OiBIVE1MRWxlbWVudCwgc3RhcnRPbkV2ZW50OiBzdHJpbmcsIG1vdmVPbkV2ZW50OiBzdHJpbmcsIGVuZE9uRXZlbnQ6IHN0cmluZyk6IEZ1bmN0aW9uIHtcbiAgICBsZXQgZHJhZ01vdmVMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgICBsZXQgZHJhZ0VuZExpc3RlbmVyOiAoKSA9PiB2b2lkO1xuXG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmxpc3RlbihlbGVtZW50LCBzdGFydE9uRXZlbnQsIChzdGFydEV2ZW50OiBhbnkpID0+IHtcbiAgICAgIHRoaXMubm90aWZ5RHJhZ1N0YXJ0KHN0YXJ0RXZlbnQpO1xuXG4gICAgICBkcmFnTW92ZUxpc3RlbmVyID0gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCBtb3ZlT25FdmVudCwgKG1vdmVFdmVudDogYW55KSA9PiB7XG4gICAgICAgICAgdGhpcy5ub3RpZnlEcmFnTW92ZShtb3ZlRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkcmFnRW5kTGlzdGVuZXIgPSB0aGlzLl9yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgZW5kT25FdmVudCwgKGVuZEV2ZW50OiBhbnkpID0+IHtcbiAgICAgICAgLy8gVW5zdWJzY3JpYmluZyBmcm9tIG1vdXNlTW92ZUxpc3RlbmVyXG4gICAgICAgIGRyYWdNb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlEcmFnRW5kKGVuZEV2ZW50KTtcbiAgICAgICAgLy8gVW5zdWJzY3JpYmluZyBmcm9tIGl0c2VsZlxuICAgICAgICBkcmFnRW5kTGlzdGVuZXIoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgbm90aWZ5RHJhZ1N0YXJ0KGV2ZW50OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5fb25EcmFnU3RhcnQubmV4dChldmVudCk7XG4gIH1cblxuICBub3RpZnlEcmFnTW92ZShldmVudDogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMuX29uRHJhZ01vdmUubmV4dChldmVudCk7XG4gIH1cblxuICBub3RpZnlEcmFnRW5kKGV2ZW50OiBhbnkpIHtcbiAgICByZXR1cm4gdGhpcy5fb25EcmFnRW5kLm5leHQoZXZlbnQpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMubWFwKGV2ZW50ID0+IGV2ZW50KCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbXBhcmF0b3IuaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlRGVib3VuY2VyIH0gZnJvbSAnLi9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU29ydDxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RhdGVEZWJvdW5jZXI6IFN0YXRlRGVib3VuY2VyKSB7fVxuXG4gIC8qKlxuICAgKiBDdXJyZW50bHkgYWN0aXZlIGNvbXBhcmF0b3JcbiAgICovXG4gIHByaXZhdGUgX2NvbXBhcmF0b3I6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPjtcbiAgcHVibGljIGdldCBjb21wYXJhdG9yKCk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBhcmF0b3I7XG4gIH1cbiAgcHVibGljIHNldCBjb21wYXJhdG9yKHZhbHVlOiBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2U8VD4pIHtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZVN0YXJ0KCk7XG4gICAgdGhpcy5fY29tcGFyYXRvciA9IHZhbHVlO1xuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzY2VuZGluZyBvcmRlciBpZiBmYWxzZSwgZGVzY2VuZGluZyBpZiB0cnVlXG4gICAqL1xuICBwcml2YXRlIF9yZXZlcnNlOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgcmV2ZXJzZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZTtcbiAgfVxuICBwdWJsaWMgc2V0IHJldmVyc2UodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZVN0YXJ0KCk7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHZhbHVlO1xuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBzb3J0IGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PFNvcnQ8VD4+KCk7XG4gIHByaXZhdGUgZW1pdENoYW5nZSgpIHtcbiAgICB0aGlzLl9jaGFuZ2UubmV4dCh0aGlzKTtcbiAgfVxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8U29ydDxUPj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGNvbXBhcmF0b3IgYXMgdGhlIGN1cnJlbnQgb25lLCBvciB0b2dnbGVzIHJldmVyc2UgaWYgdGhlIGNvbXBhcmF0b3IgaXMgYWxyZWFkeSB1c2VkLiBUaGVcbiAgICogb3B0aW9uYWwgZm9yY2VSZXZlcnNlIGlucHV0IHBhcmFtZXRlciBhbGxvd3MgdG8gb3ZlcnJpZGUgdGhhdCB0b2dnbGluZyBiZWhhdmlvciBieSBzb3J0aW5nIGluXG4gICAqIHJldmVyc2Ugb3JkZXIgaWYgYHRydWVgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgU29ydFxuICAgKi9cbiAgcHVibGljIHRvZ2dsZShzb3J0Qnk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiwgZm9yY2VSZXZlcnNlPzogYm9vbGVhbikge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICAvLyBXZSBtb2RpZnkgcHJpdmF0ZSBwcm9wZXJ0aWVzIGRpcmVjdGx5LCB0byBiYXRjaCB0aGUgY2hhbmdlIGV2ZW50XG4gICAgaWYgKHRoaXMuY29tcGFyYXRvciA9PT0gc29ydEJ5KSB7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gdHlwZW9mIGZvcmNlUmV2ZXJzZSAhPT0gJ3VuZGVmaW5lZCcgPyBmb3JjZVJldmVyc2UgfHwgIXRoaXMuX3JldmVyc2UgOiAhdGhpcy5fcmV2ZXJzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29tcGFyYXRvciA9IHNvcnRCeTtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSB0eXBlb2YgZm9yY2VSZXZlcnNlICE9PSAndW5kZWZpbmVkJyA/IGZvcmNlUmV2ZXJzZSA6IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZURvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgc29ydGluZyBvcmRlclxuICAgKi9cbiAgcHVibGljIGNsZWFyKCkge1xuICAgIHRoaXMuY29tcGFyYXRvciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdHdvIG9iamVjdHMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGNvbXBhcmF0b3JcbiAgICovXG4gIHB1YmxpYyBjb21wYXJlKGE6IFQsIGI6IFQpOiBudW1iZXIge1xuICAgIHJldHVybiAodGhpcy5yZXZlcnNlID8gLTEgOiAxKSAqIHRoaXMuY29tcGFyYXRvci5jb21wYXJlKGEsIGIpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVtYmVkZGVkVmlld1JlZiwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGctd3JhcHBlZC1jb2x1bW4nLFxuICB0ZW1wbGF0ZTogYCAgICAgICAgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjY29sdW1uUG9ydGFsPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIFdyYXBwZWRDb2x1bW4gaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgQWZ0ZXJWaWV3SW5pdCB7XG4gIF9keW5hbWljID0gZmFsc2U7XG5cbiAgQFZpZXdDaGlsZCgnY29sdW1uUG9ydGFsJykgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPHZvaWQ+O1xuICBjb2x1bW5WaWV3OiBFbWJlZGRlZFZpZXdSZWY8dm9pZD47IC8vIHRoZSBjb2x1bW5zIHByb2plY3RlZCB2aWV3IChpbiBtZW1vcnkpXG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIENyZWF0ZSB0aGUgY2VsbHMgdmlldyBpbiBtZW1vcnksIG5vdCB0aGUgRE9NLlxuICAgIHRoaXMuY29sdW1uVmlldyA9IHRoaXMudGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KG51bGwpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEhvc3RXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwZXInO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvciB9IGZyb20gJy4vYnVpbHQtaW4vY29tcGFyYXRvcnMvZGF0YWdyaWQtcHJvcGVydHktY29tcGFyYXRvcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyIH0gZnJvbSAnLi9idWlsdC1pbi9maWx0ZXJzL2RhdGFncmlkLXByb3BlcnR5LXN0cmluZy1maWx0ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsIH0gZnJvbSAnLi9idWlsdC1pbi9maWx0ZXJzL2RhdGFncmlkLXN0cmluZy1maWx0ZXItaW1wbCc7XG5pbXBvcnQgeyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgfSBmcm9tICcuL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbCc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFNvcnRPcmRlciB9IGZyb20gJy4vZW51bXMvc29ydC1vcmRlci5lbnVtJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb21wYXJhdG9yLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDdXN0b21GaWx0ZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9jdXN0b20tZmlsdGVyJztcbmltcG9ydCB7IERyYWdEaXNwYXRjaGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJhZy1kaXNwYXRjaGVyJztcbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2ZpbHRlcnMnO1xuaW1wb3J0IHsgU29ydCB9IGZyb20gJy4vcHJvdmlkZXJzL3NvcnQnO1xuaW1wb3J0IHsgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXIgfSBmcm9tICcuL3V0aWxzL2RhdGFncmlkLWZpbHRlci1yZWdpc3RyYXInO1xuaW1wb3J0IHsgV3JhcHBlZENvbHVtbiB9IGZyb20gJy4vd3JhcHBlZC1jb2x1bW4nO1xuXG5sZXQgbmJDb3VudDogbnVtYmVyID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1jb2x1bW4tZmxleFwiPlxuICAgICAgICAgICAgPCEtLSBJJ20gcmVhbGx5IG5vdCBoYXBweSB3aXRoIHRoYXQgc2VsZWN0IHNpbmNlIGl0J3Mgbm90IHZlcnkgc2NhbGFibGUgLS0+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItZGctZmlsdGVyLCBjbHItZGctc3RyaW5nLWZpbHRlclwiPjwvbmctY29udGVudD5cblxuICAgICAgICAgICAgPGNsci1kZy1zdHJpbmctZmlsdGVyXG4gICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZmllbGQgJiYgIWN1c3RvbUZpbHRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtjbHJEZ1N0cmluZ0ZpbHRlcl09XCJyZWdpc3RlcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgWyhjbHJGaWx0ZXJWYWx1ZSldPVwiZmlsdGVyVmFsdWVcIj48L2Nsci1kZy1zdHJpbmctZmlsdGVyPlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgI2NvbHVtblRpdGxlPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkYXRhZ3JpZC1jb2x1bW4tdGl0bGVcIiAqbmdJZj1cInNvcnRhYmxlXCIgKGNsaWNrKT1cInNvcnQoKVwiIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sdW1uVGl0bGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi10aXRsZVwiICpuZ0lmPVwiIXNvcnRhYmxlXCI+XG4gICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sdW1uVGl0bGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi1zZXBhcmF0b3JcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uICNjb2x1bW5IYW5kbGUgY2xhc3M9XCJkYXRhZ3JpZC1jb2x1bW4taGFuZGxlXCIgdGFiaW5kZXg9XCItMVwiIHR5cGU9XCJidXR0b25cIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8ZGl2ICNjb2x1bW5IYW5kbGVUcmFja2VyIGNsYXNzPVwiZGF0YWdyaWQtY29sdW1uLWhhbmRsZS10cmFja2VyXCI+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0YWdyaWQtY29sdW1uXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLWNvbHVtbi0taGlkZGVuXSc6ICdoaWRkZW4nLFxuICAgICdbYXR0ci5hcmlhLXNvcnRdJzogJ2FyaWFTb3J0JyxcbiAgICByb2xlOiAnY29sdW1uaGVhZGVyJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW48VCA9IGFueT4gZXh0ZW5kcyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhcjxULCBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGw8VD4+XG4gIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9zb3J0OiBTb3J0PFQ+LFxuICAgIGZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPixcbiAgICBwcml2YXRlIF9kcmFnRGlzcGF0Y2hlcjogRHJhZ0Rpc3BhdGNoZXIsXG4gICAgcHJpdmF0ZSB2Y3I6IFZpZXdDb250YWluZXJSZWZcbiAgKSB7XG4gICAgc3VwZXIoZmlsdGVycyk7XG4gICAgdGhpcy5fc29ydFN1YnNjcmlwdGlvbiA9IF9zb3J0LmNoYW5nZS5zdWJzY3JpYmUoc29ydCA9PiB7XG4gICAgICAvLyBXZSdyZSBvbmx5IGxpc3RlbmluZyB0byBtYWtlIHN1cmUgd2UgZW1pdCBhbiBldmVudCB3aGVuIHRoZSBjb2x1bW4gZ29lcyBmcm9tIHNvcnRlZCB0byB1bnNvcnRlZFxuICAgICAgaWYgKHRoaXMuc29ydE9yZGVyICE9PSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRCAmJiBzb3J0LmNvbXBhcmF0b3IgIT09IHRoaXMuX3NvcnRCeSkge1xuICAgICAgICB0aGlzLl9zb3J0T3JkZXIgPSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRDtcbiAgICAgICAgdGhpcy5zb3J0T3JkZXJDaGFuZ2UuZW1pdCh0aGlzLl9zb3J0T3JkZXIpO1xuICAgICAgfVxuICAgICAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIFNUQVJUXG4gICAgICBpZiAodGhpcy5zb3J0ZWQgJiYgc29ydC5jb21wYXJhdG9yICE9PSB0aGlzLl9zb3J0QnkpIHtcbiAgICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc29ydGVkQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgfVxuICAgICAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIEVORFxuICAgIH0pO1xuXG4gICAgdGhpcy5jb2x1bW5JZCA9ICdkZy1jb2wtJyArIG5iQ291bnQudG9TdHJpbmcoKTsgLy8gQXBwcm94aW1hdGUgYSBHVUlEXG4gICAgbmJDb3VudCsrO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjb2x1bW5JZFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBDbHJEYXRhZ3JpZENvbHVtbiBjbGFzcyB2YXJpYWJsZSB0aGF0IGhvbGRzIHRoZSBudW1iZXIgb2YgQ2xyRGF0YWdyaWRDb2x1bW4gaW5zdGFuY2VzIGZvciBhIERhdGFncmlkLlxuICAgKiBJdCBpcyB1c2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIGlkIGZvciB0aGUgQ2xyRGF0YWdyaWRDb2x1bW4gaW5zdGFuY2UuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgY29sdW1uSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogQHByb3BlcnR5IGhpZGRlblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBwcm9wZXJ0eSB0aGF0IGFsbG93cyB0aGUgY29sdW1uIHRvIGJlIGhpZGRlbiAvIHNob3duIHdpdGggY3NzXG4gICAqIE5vdGUgdGhlIGRlZmF1bHQgYWxsb3dzIHRoZSBDbHJEYXRhZ3JpZENvbHVtbiB0byBoYXZlIGFuICpuZ0lmIG9uIGl0LiAoRUhDQUlXQyAtIHdpbGwgb2NjdXIgaWYgaXRzIG5vdFxuICAgKiBpbml0aWFsaXplZClcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaGlkZGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuaGlkZWFibGUgJiYgdGhpcy5oaWRlYWJsZS5oaWRkZW47XG4gIH1cblxuICBAVmlld0NoaWxkKCdjb2x1bW5IYW5kbGUnKVxuICBzZXQgaGFuZGxlRWxSZWYodmFsdWU6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLl9kcmFnRGlzcGF0Y2hlci5oYW5kbGVSZWYgPSB2YWx1ZTtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ2NvbHVtbkhhbmRsZVRyYWNrZXInKVxuICBzZXQgaGFuZGxlVHJhY2tlckVsUmVmKHZhbHVlOiBFbGVtZW50UmVmKSB7XG4gICAgdGhpcy5fZHJhZ0Rpc3BhdGNoZXIuaGFuZGxlVHJhY2tlclJlZiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbiB0byB0aGUgc29ydCBzZXJ2aWNlIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX3NvcnRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zb3J0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKlxuICAgICAqIFNpbXBsZSBvYmplY3QgcHJvcGVydHkgc2hvcnRjdXQsIGFjdGl2YXRlcyBib3RoIHNvcnRpbmcgYW5kIGZpbHRlcmluZ1xuICAgICAqIGJhc2VkIG9uIG5hdGl2ZSBjb21wYXJpc29uIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgb24gdGhlIGl0ZW1zLlxuICAgICAqL1xuICBwcml2YXRlIF9maWVsZDogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGZpZWxkKCkge1xuICAgIHJldHVybiB0aGlzLl9maWVsZDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdGaWVsZCcpXG4gIHB1YmxpYyBzZXQgZmllbGQoZmllbGQ6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9maWVsZCA9IGZpZWxkO1xuICAgICAgaWYgKCF0aGlzLmN1c3RvbUZpbHRlcikge1xuICAgICAgICB0aGlzLnNldEZpbHRlcihuZXcgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsKG5ldyBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyKGZpZWxkKSkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3J0QnkpIHtcbiAgICAgICAgdGhpcy5fc29ydEJ5ID0gbmV3IERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yKGZpZWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlIHRvIHVzZSB3aGVuIHNvcnRpbmcgdGhlIGNvbHVtblxuICAgKi9cblxuICBwcml2YXRlIF9zb3J0Qnk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPjtcblxuICBwdWJsaWMgZ2V0IHNvcnRCeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydEJ5O1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NvcnRCeScpXG4gIHB1YmxpYyBzZXQgc29ydEJ5KGNvbXBhcmF0b3I6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3NvcnRCeSA9IG5ldyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcihjb21wYXJhdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy5fc29ydEJ5ID0gY29tcGFyYXRvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9maWVsZCkge1xuICAgICAgICAgIHRoaXMuX3NvcnRCeSA9IG5ldyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcih0aGlzLl9maWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3NvcnRCeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZVxuICAgKi9cbiAgcHVibGljIGdldCBzb3J0YWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9zb3J0Qnk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBzb3J0ZWRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgc29vbiwgaW4gZmF2b3Igb2YgdGhlIHNvcnRPcmRlciBtZWNoYW5pc21cbiAgICovXG4gIHByaXZhdGUgX3NvcnRlZCA9IGZhbHNlO1xuICBwdWJsaWMgZ2V0IHNvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAqL1xuICBASW5wdXQoJ2NsckRnU29ydGVkJylcbiAgcHVibGljIHNldCBzb3J0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAoIXZhbHVlICYmIHRoaXMuc29ydGVkKSB7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NvcnQuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmICF0aGlzLnNvcnRlZCkge1xuICAgICAgdGhpcy5zb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAqL1xuICBAT3V0cHV0KCdjbHJEZ1NvcnRlZENoYW5nZScpIHB1YmxpYyBzb3J0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIEVORFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaG93IHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHNvcnRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydE9yZGVyOiBDbHJEYXRhZ3JpZFNvcnRPcmRlciA9IENsckRhdGFncmlkU29ydE9yZGVyLlVOU09SVEVEO1xuICBwdWJsaWMgZ2V0IHNvcnRPcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydE9yZGVyO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NvcnRPcmRlcicpXG4gIHB1YmxpYyBzZXQgc29ydE9yZGVyKHZhbHVlOiBDbHJEYXRhZ3JpZFNvcnRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBpZiB0aGUgaW5jb21pbmcgb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb25lXG4gICAgaWYgKHRoaXMuX3NvcnRPcmRlciA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAvLyB0aGUgVW5zb3J0ZWQgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIGN1cnJlbnQgc3RhdGUgaXMgZWl0aGVyIEFzYyBvciBEZXNjXG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRDpcbiAgICAgICAgdGhpcy5fc29ydC5jbGVhcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuQVNDOlxuICAgICAgICB0aGlzLnNvcnQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuREVTQzpcbiAgICAgICAgdGhpcy5zb3J0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFyaWFTb3J0KCkge1xuICAgIHN3aXRjaCAodGhpcy5fc29ydE9yZGVyKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRDpcbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuQVNDOlxuICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XG4gICAgICBjYXNlIENsckRhdGFncmlkU29ydE9yZGVyLkRFU0M6XG4gICAgICAgIHJldHVybiAnZGVzY2VuZGluZyc7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdTb3J0T3JkZXJDaGFuZ2UnKSBwdWJsaWMgc29ydE9yZGVyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJEYXRhZ3JpZFNvcnRPcmRlcj4oKTtcblxuICAvKipcbiAgICogU29ydHMgdGhlIGRhdGFncmlkIGJhc2VkIG9uIHRoaXMgY29sdW1uXG4gICAqL1xuICBwdWJsaWMgc29ydChyZXZlcnNlPzogYm9vbGVhbikge1xuICAgIGlmICghdGhpcy5zb3J0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NvcnQudG9nZ2xlKHRoaXMuX3NvcnRCeSwgcmV2ZXJzZSk7XG5cbiAgICAvLyBzZXR0aW5nIHRoZSBwcml2YXRlIHZhcmlhYmxlIHRvIG5vdCByZXRyaWdnZXIgdGhlIHNldHRlciBsb2dpY1xuICAgIHRoaXMuX3NvcnRPcmRlciA9IHRoaXMuX3NvcnQucmV2ZXJzZSA/IENsckRhdGFncmlkU29ydE9yZGVyLkRFU0MgOiBDbHJEYXRhZ3JpZFNvcnRPcmRlci5BU0M7XG4gICAgdGhpcy5zb3J0T3JkZXJDaGFuZ2UuZW1pdCh0aGlzLl9zb3J0T3JkZXIpO1xuXG4gICAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIFNUQVJUXG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNvcnRlZENoYW5nZS5lbWl0KHRydWUpO1xuICAgIC8vIGRlcHJlY2F0ZWQ6IHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlclxuICAgKi9cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hc2MnKVxuICBwdWJsaWMgZ2V0IGFzYygpIHtcbiAgICAvLyBkZXByZWNhdGVkOiBpZiBjb25kaXRpb24gdG8gYmUgcmVtb3ZlZCAtIFNUQVJUXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvcnRPcmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRlZCAmJiAhdGhpcy5fc29ydC5yZXZlcnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3J0T3JkZXIgPT09IENsckRhdGFncmlkU29ydE9yZGVyLkFTQztcbiAgICB9XG4gICAgLy8gZGVwcmVjYXRlZDogaWYgY29uZGl0aW9uIHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXJcbiAgICovXG4gIEBIb3N0QmluZGluZygnY2xhc3MuZGVzYycpXG4gIHB1YmxpYyBnZXQgZGVzYygpIHtcbiAgICAvLyBkZXByZWNhdGVkOiBpZiBjb25kaXRpb24gdG8gYmUgcmVtb3ZlZCAtIFNUQVJUXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvcnRPcmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRlZCAmJiB0aGlzLl9zb3J0LnJldmVyc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNvcnRPcmRlciA9PT0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuREVTQztcbiAgICB9XG4gICAgLy8gZGVwcmVjYXRlZDogaWYgY29uZGl0aW9uIHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSBmaWx0ZXIgZm9yIHRoaXMgY29sdW1uIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBwcm9qZWN0ZWQgY29udGVudFxuICAgKi9cbiAgcHVibGljIGN1c3RvbUZpbHRlciA9IGZhbHNlO1xuXG4gIEBDb250ZW50Q2hpbGQoQ3VzdG9tRmlsdGVyKVxuICBwdWJsaWMgc2V0IHByb2plY3RlZEZpbHRlcihjdXN0b206IGFueSkge1xuICAgIGlmIChjdXN0b20pIHtcbiAgICAgIHRoaXMuZGVsZXRlRmlsdGVyKCk7XG4gICAgICB0aGlzLmN1c3RvbUZpbHRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBmaWx0ZXJWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIudmFsdWU7XG4gIH1cblxuICBASW5wdXQoJ2NsckZpbHRlclZhbHVlJylcbiAgcHVibGljIHNldCB1cGRhdGVGaWx0ZXJWYWx1ZShuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICBuZXdWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuZmlsdGVyLnZhbHVlKSB7XG4gICAgICB0aGlzLmZpbHRlci52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXQgZmlsdGVyVmFsdWUobmV3VmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMudXBkYXRlRmlsdGVyVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLmZpbHRlclZhbHVlQ2hhbmdlLmVtaXQodGhpcy5maWx0ZXIudmFsdWUpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyRmlsdGVyVmFsdWVDaGFuZ2UnKSBmaWx0ZXJWYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKioqKioqKioqKipcbiAgICpcbiAgICogQHByb3BlcnR5IGhpZGVhYmxlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBXaGVuIGEgY29sdW1uIGlzIGhpZGVhYmxlIHRoaXMgaXMgZGVmaW5lZCB3aXRoIGFuIGluc3RhbmNlIG9mIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbC5cbiAgICogV2hlbiBpdHMgbm90IGhpZGVhYmxlIHNob3VsZCBiZSB1bmRlZmluZWQuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgaGlkZWFibGU6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbDtcblxuICBwcml2YXRlIHdyYXBwZWRJbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy53cmFwcGVkSW5qZWN0b3IgPSBuZXcgSG9zdFdyYXBwZXIoV3JhcHBlZENvbHVtbiwgdGhpcy52Y3IpO1xuICB9XG5cbiAgcHVibGljIGdldCBfdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5qZWN0b3IuZ2V0KFdyYXBwZWRDb2x1bW4sIHRoaXMudmNyKS5jb2x1bW5WaWV3O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcGFnZSc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9zb3J0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEl0ZW1zPFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LCBwcml2YXRlIF9zb3J0OiBTb3J0PFQ+LCBwcml2YXRlIF9wYWdlOiBQYWdlKSB7fVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGRhdGEgaXMgY3VycmVudGx5IGxvYWRpbmdcbiAgICovXG4gIHB1YmxpYyBsb2FkaW5nID0gZmFsc2U7XG5cbiAgLy8gVE9ETzogVmVyaWZ5IHRoYXQgdHJhY2tCeSBpcyByZWdpc3RlcmVkIGZvciB0aGUgKm5nRm9yIGNhc2UgdG9vXG4gIC8qKlxuICAgKiBUcmFja2luZyBmdW5jdGlvbiB0byBpZGVudGlmeSBvYmplY3RzLiBEZWZhdWx0IGlzIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAgICovXG4gIHB1YmxpYyB0cmFja0J5OiBUcmFja0J5RnVuY3Rpb248VD4gPSAoaW5kZXg6IG51bWJlciwgaXRlbTogVCkgPT4gaXRlbTtcblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9ucyB0byB0aGUgb3RoZXIgcHJvdmlkZXJzIGNoYW5nZXMuXG4gICAqL1xuICBwcml2YXRlIF9maWx0ZXJzU3ViOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX3NvcnRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfcGFnZVN1YjogU3Vic2NyaXB0aW9uO1xuICAvKipcbiAgICogQ2xlYW5zIHVwIG91ciBzdWJzY3JpcHRpb25zIHRvIG90aGVyIHByb3ZpZGVyc1xuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlcnNTdWIpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnNTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnRTdWIpIHtcbiAgICAgIHRoaXMuX3NvcnRTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhZ2VTdWIpIHtcbiAgICAgIHRoaXMuX3BhZ2VTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgdXNlIHNtYXJ0IGl0ZW1zIGZvciB0aGlzIGRhdGFncmlkIG9yIGxldCB0aGUgdXNlciBoYW5kbGVcbiAgICogZXZlcnl0aGluZy5cbiAgICovXG4gIHByaXZhdGUgX3NtYXJ0ID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgc21hcnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3NtYXJ0O1xuICB9XG4gIHB1YmxpYyBzbWFydGVuVXAoKSB7XG4gICAgdGhpcy5fc21hcnQgPSB0cnVlO1xuICAgIC8qXG4gICAgICAgICAqIFRoZXNlIG9ic2VydmVycyB0cmlnZ2VyIGEgY2hhaW4gb2YgZnVuY3Rpb246IGZpbHRlciAtPiBzb3J0IC0+IHBhZ2luYXRlXG4gICAgICAgICAqIEFuIG9ic2VydmVyIHVwIHRoZSBjaGFpbiByZS10cmlnZ2VycyBhbGwgdGhlIG9wZXJhdGlvbnMgdGhhdCBmb2xsb3cgaXQuXG4gICAgICAgICAqL1xuICAgIHRoaXMuX2ZpbHRlcnNTdWIgPSB0aGlzLl9maWx0ZXJzLmNoYW5nZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZmlsdGVySXRlbXMoKSk7XG4gICAgdGhpcy5fc29ydFN1YiA9IHRoaXMuX3NvcnQuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UsIGlmIHRoZSBkYXRhZ3JpZCB3ZW50IGZyb20gc29ydGVkIHRvIHVuc29ydGVkLCB3ZSBoYXZlIHRvIHJlLWZpbHRlclxuICAgICAgLy8gdG8gZ2V0IHRoZSBvcmlnaW5hbCBvcmRlciBiYWNrXG4gICAgICBpZiAoIXRoaXMuX3NvcnQuY29tcGFyYXRvcikge1xuICAgICAgICB0aGlzLl9maWx0ZXJJdGVtcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcGFnZVN1YiA9IHRoaXMuX3BhZ2UuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9jaGFuZ2VQYWdlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYWxsIGl0ZW1zIGluIHRoZSBkYXRhZ3JpZFxuICAgKi9cbiAgcHJpdmF0ZSBfYWxsOiBUW107XG4gIHB1YmxpYyBnZXQgYWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9hbGw7XG4gIH1cbiAgcHVibGljIHNldCBhbGwoaXRlbXM6IFRbXSkge1xuICAgIHRoaXMuX2FsbCA9IGl0ZW1zO1xuICAgIHRoaXMuZW1pdEFsbENoYW5nZXMoaXRlbXMpO1xuICAgIGlmICh0aGlzLnNtYXJ0KSB7XG4gICAgICB0aGlzLl9maWx0ZXJJdGVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWQgPSBpdGVtcztcbiAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSByZWNvbXB1dGUgdGhlIGxpc3Qgb2YgZGlzcGxheWVkIGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5zbWFydCkge1xuICAgICAgdGhpcy5fZmlsdGVySXRlbXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgdGVtcG9yYXJ5IHN0ZXAsIHdoaWNoIHdlIHByZXNlcnZlIHRvIGF2b2lkIHJlLWZpbHRlcmluZyBvciByZS1zb3J0aW5nIGlmIG5vdCBuZWNlc3NhcnlcbiAgICovXG4gIHByaXZhdGUgX2ZpbHRlcmVkOiBUW107XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgaXRlbXMgY3VycmVudGx5IGRpc3BsYXllZFxuICAgKi9cbiAgcHJpdmF0ZSBfZGlzcGxheWVkOiBUW10gPSBbXTtcbiAgcHVibGljIGdldCBkaXNwbGF5ZWQoKTogVFtdIHtcbiAgICAvLyBJZGVhbGx5IHdlIGNvdWxkIHJldHVybiBhbiBpbW11dGFibGUgYXJyYXksIGJ1dCB3ZSBkb24ndCBoYXZlIGl0IGluIENsYXJpdHkgeWV0LlxuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIGl0ZW1zIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PFRbXT4oKTtcbiAgcHJpdmF0ZSBlbWl0Q2hhbmdlKCkge1xuICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuZGlzcGxheWVkKTtcbiAgfVxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8VFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FsbENoYW5nZXMgPSBuZXcgU3ViamVjdDxUW10+KCk7XG4gIHByaXZhdGUgZW1pdEFsbENoYW5nZXMoaXRlbXM6IFRbXSk6IHZvaWQge1xuICAgIHRoaXMuX2FsbENoYW5nZXMubmV4dChpdGVtcyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFsbENoYW5nZXMoKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gdGhpcy5fYWxsQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgd2UgZG9uJ3QgaGF2ZSBkYXRhIHRvIHByb2Nlc3MgeWV0LCB0byBhYm9ydCBlYXJseSBvcGVyYXRpb25zXG4gICAqL1xuICBwcml2YXRlIGdldCB1bmluaXRpYWxpemVkKCkge1xuICAgIHJldHVybiAhdGhpcy5fYWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnNQcm92aWRlciBpdGVtcyBmcm9tIHRoZSByYXcgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfZmlsdGVySXRlbXMoKSB7XG4gICAgaWYgKHRoaXMudW5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZmlsdGVycy5oYXNBY3RpdmVGaWx0ZXJzKCkpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcmVkID0gdGhpcy5fYWxsLmZpbHRlcihpdGVtID0+IHRoaXMuX2ZpbHRlcnMuYWNjZXB0cyhpdGVtKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdvcmsgb24gYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5LCB0byBub3QgbW9kaWZ5IHRoZSB1c2VyJ3MgbW9kZWxcbiAgICAgIHRoaXMuX2ZpbHRlcmVkID0gdGhpcy5fYWxsLnNsaWNlKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2UudG90YWxJdGVtcyA9IHRoaXMuX2ZpbHRlcmVkLmxlbmd0aDtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBpdGVtcyBpbiB0aGUgZmlsdGVyZWQgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydEl0ZW1zKCkge1xuICAgIGlmICh0aGlzLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnQuY29tcGFyYXRvcikge1xuICAgICAgdGhpcy5fZmlsdGVyZWQuc29ydCgoYSwgYikgPT4gdGhpcy5fc29ydC5jb21wYXJlKGEsIGIpKTtcbiAgICB9XG4gICAgdGhpcy5fY2hhbmdlUGFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgc29ydGVkIGxpc3RcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZVBhZ2UoKSB7XG4gICAgaWYgKHRoaXMudW5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFnZS5zaXplID4gMCkge1xuICAgICAgdGhpcy5fZGlzcGxheWVkID0gdGhpcy5fZmlsdGVyZWQuc2xpY2UodGhpcy5fcGFnZS5maXJzdEl0ZW0sIHRoaXMuX3BhZ2UubGFzdEl0ZW0gKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzcGxheWVkID0gdGhpcy5fZmlsdGVyZWQ7XG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ0Zvck9mLCBOZ0Zvck9mQ29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIERvQ2hlY2ssXG4gIElucHV0LFxuICBJdGVyYWJsZURpZmZlcixcbiAgSXRlcmFibGVEaWZmZXJzLFxuICBUZW1wbGF0ZVJlZixcbiAgVHJhY2tCeUZ1bmN0aW9uLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBPbkRlc3Ryb3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vcHJvdmlkZXJzL2l0ZW1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRGdJdGVtc11bY2xyRGdJdGVtc09mXScsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkSXRlbXM8VD4gaW1wbGVtZW50cyBEb0NoZWNrLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGl0ZXJhYmxlUHJveHk6IE5nRm9yT2Y8VD47XG4gIHByaXZhdGUgX3Jhd0l0ZW1zOiBUW107XG4gIHByaXZhdGUgZGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJEZ0l0ZW1zT2YnKVxuICBwdWJsaWMgc2V0IHJhd0l0ZW1zKGl0ZW1zOiBUW10pIHtcbiAgICB0aGlzLl9yYXdJdGVtcyA9IGl0ZW1zID8gaXRlbXMgOiBbXTsgLy8gbG9jYWwgY29weSBmb3IgbmdPbkNoYW5nZSBkaWZmaW5nXG4gIH1cblxuICBASW5wdXQoJ2NsckRnSXRlbXNUcmFja0J5JylcbiAgc2V0IHRyYWNrQnkodmFsdWU6IFRyYWNrQnlGdW5jdGlvbjxUPikge1xuICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0ZvclRyYWNrQnkgPSB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LFxuICAgIHByaXZhdGUgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLFxuICAgIHByaXZhdGUgaXRlbXM6IEl0ZW1zLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIGl0ZW1zLnNtYXJ0ZW5VcCgpO1xuICAgIHRoaXMuaXRlcmFibGVQcm94eSA9IG5ldyBOZ0Zvck9mPFQ+KHRoaXMudmNyLCB0aGlzLnRlbXBsYXRlLCB0aGlzLmRpZmZlcnMpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgaXRlbXMuY2hhbmdlLnN1YnNjcmliZShuZXdJdGVtcyA9PiB7XG4gICAgICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0Zvck9mID0gbmV3SXRlbXM7XG4gICAgICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0RvQ2hlY2soKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAoIXRoaXMuZGlmZmVyKSB7XG4gICAgICB0aGlzLmRpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKHRoaXMuX3Jhd0l0ZW1zKS5jcmVhdGUodGhpcy5pdGVyYWJsZVByb3h5Lm5nRm9yVHJhY2tCeSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpZmZlcikge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYodGhpcy5fcmF3SXRlbXMpO1xuICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gVE9ETzogbm90IHZlcnkgZWZmaWNpZW50IHJpZ2h0IG5vdyxcbiAgICAgICAgLy8gYnV0IHByZW1hdHVyZSBvcHRpbWl6YXRpb24gaXMgdGhlIHJvb3Qgb2YgYWxsIGV2aWwuXG4gICAgICAgIHRoaXMuaXRlbXMuYWxsID0gdGhpcy5fcmF3SXRlbXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vcHJvdmlkZXJzL2l0ZW1zJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXBsYWNlaG9sZGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJkYXRhZ3JpZC1wbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbY2xhc3MuZGF0YWdyaWQtZW1wdHldPVwiZW1wdHlEYXRhZ3JpZFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1wbGFjZWhvbGRlci1pbWFnZVwiICpuZ0lmPVwiZW1wdHlEYXRhZ3JpZFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50ICpuZ0lmPVwiZW1wdHlEYXRhZ3JpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmRhdGFncmlkLXBsYWNlaG9sZGVyLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRQbGFjZWhvbGRlcjxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaXRlbXM6IEl0ZW1zPFQ+KSB7fVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGUgZGF0YWdyaWQgaXMgZW1wdHksIG1lYW5pbmcgaXQgZG9lc24ndCBjb250YWluIGFueSBpdGVtc1xuICAgKi9cbiAgcHVibGljIGdldCBlbXB0eURhdGFncmlkKCkge1xuICAgIHJldHVybiAhdGhpcy5pdGVtcy5sb2FkaW5nICYmICghdGhpcy5pdGVtcy5kaXNwbGF5ZWQgfHwgdGhpcy5pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoID09PSAwKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgUE9QT1ZFUl9IT1NUX0FOQ0hPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxFbGVtZW50UmVmPignUE9QT1ZFUl9IT1NUX0FOQ0hPUicpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIE9uRGVzdHJveSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJTaWducG9zdFRyaWdnZXJdJywgaG9zdDogeyBjbGFzczogJ3NpZ25wb3N0LXRyaWdnZXInIH0gfSlcblxuLyoqKioqKioqKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBEaXJlY3RpdmUgYWRkZWQgdG8gdGhlIENsclNpZ25wb3N0IFRyaWdnZXIgYnV0dG9uIHRoYXQgd2lsbCBjYWxsIHRoZSBDbHJTaWducG9zdC50b2dnbGUoKSBmdW5jdGlvbiB0byBoaWRlL3Nob3cgdGhlXG4gKiBDbHJTaWducG9zdENvbnRlbnQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xyU2lnbnBvc3RUcmlnZ2VyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsOiBFbGVtZW50UmVmKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUoKGlzT3BlbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdhY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBjbGljayBoYW5kbGVyIGZvciB0aGUgQ2xyU2lnbnBvc3QgdHJpZ2dlciBidXR0b24gdXNlZCB0byBoaWRlL3Nob3cgQ2xyU2lnbnBvc3RDb250ZW50LlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICBvblNpZ25wb3N0VHJpZ2dlckNsaWNrKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbmltcG9ydCB7IENsclNpZ25wb3N0VHJpZ2dlciB9IGZyb20gJy4vc2lnbnBvc3QtdHJpZ2dlcic7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc2lnbnBvc3QnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXVzZUN1c3RvbVRyaWdnZXJcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInNpZ25wb3N0LWFjdGlvbiBidG4gYnRuLXNtYWxsIGJ0bi1saW5rXCJcbiAgICAgICAgICAgICAgICBjbHJTaWducG9zdFRyaWdnZXI+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiaW5mb1wiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MuaW5mb1wiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLnNpZ25wb3N0XSc6ICd0cnVlJyB9LFxuICBwcm92aWRlcnM6IFtJZk9wZW5TZXJ2aWNlLCB7IHByb3ZpZGU6IFBPUE9WRVJfSE9TVF9BTkNIT1IsIHVzZUV4aXN0aW5nOiBFbGVtZW50UmVmIH1dLFxufSlcblxuLyoqKioqKioqKlxuICpcbiAqIEBjbGFzcyBDbHJTaWducG9zdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ2xhc3MgdXNlZCB0byBjb25maWd1cmUgYW5kIGNvbnRyb2wgdGhlIHN0YXRlIG9mIGEgQ2xyU2lnbnBvc3QgYW5kIGl0cyBhc3NvY2lhdGVkIENsclNpZ25wb3N0Q29udGVudC5cbiAqIEl0IHN1cHBvcnRzIHRoZSBjbHJQb3NpdGlvbiB3aXRoIGEgJ3JpZ2h0LW1pZGRsZScgZGVmYXVsdC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJTaWducG9zdCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzKSB7fVxuXG4gIC8qKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSB1c2VDdXN0b21UcmlnZ2VyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGbGFnIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gdXNlIHRoZSBkZWZhdWx0IHRyaWdnZXIgb3IgYSB1c2VyIHN1cHBsaWVkIHRyaWdnZXIgZWxlbWVudC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyB1c2VDdXN0b21UcmlnZ2VyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IHNpZ25Qb3N0VHJpZ2dlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVXNlcyBDb250ZW50Q2hpbGQgdG8gY2hlY2sgZm9yIGEgdXNlciBzdXBwbGllZCBlbGVtZW50IHdpdGggdGhlIENsclNpZ25wb3N0VHJpZ2dlciBvbiBpdC5cbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyU2lnbnBvc3RUcmlnZ2VyKVxuICBzZXQgY3VzdG9tVHJpZ2dlcih0cmlnZ2VyOiBDbHJTaWducG9zdFRyaWdnZXIpIHtcbiAgICB0aGlzLnVzZUN1c3RvbVRyaWdnZXIgPSAhIXRyaWdnZXI7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4uL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbCc7XG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQW4gQEluamVjdGFibGUgcHJvdmlkZXIgY2xhc3MgdGhhdCBlbmFibGVzXG4gKlxuICogMS4gTWFuYWdpbmcsIHRyYWNrIGhpZGVhYmlsaXR5IG9mIERhdGFncmlkQ29sdW1uc1xuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhpZGVhYmxlQ29sdW1uU2VydmljZSB7XG4gIC8qKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBkZ0hpZGRlbkNvbHVtbk1hcFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQW4gYXJyYXkgb2YgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbi5cbiAgICogTk9URTogYmVjYXVzZSB3ZSBjYW4gaGF2ZSBjb2x1bW5zIHcvbyB0aGUgKmNsckRnSGlkZWFibGVDb2x1bW4gZGlyZWN0aXZlXG4gICAqIHRoaXMgYXJyYXkgd2lsbCBoYXZlIGVtcHR5IHNwYWNlcyBhLmsuYSBudWxscy4gVGhpcyBpcyBuZWVkZWQgdG8gYmUgYWJsZSB0byBtYXBcbiAgICogRGF0YWdyaWRDZWxscyB0byBEYXRhZ3JpZENvbHVtbnMgaW4gdGhlIFJvd1JlbmRlcmVyLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfY29sdW1uTGlzdDogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10gPSBbXTtcblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAcHJvcGVydHkgZGdIaWRkZW5Db2x1bW5NYXBDaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgYmVoYXZpb3Igc3ViamVjdCB0aGF0IGNhbiBicm9hZGNhc3QgdXBkYXRlcyB0byB0aGUgY29sdW1uIGxpc3QuXG4gICAqIE5PVEU6IEkgYW0gdXNpbmcgQmVoYXZpb3JTdWJqZWN0IGJlY2F1c2UgPGNsci1kZy1jb2x1bW4tdG9nZ2xlPiBpcyBub3QgZ2V0dGluZyB0aGUgbGF0ZXN0IF9jb2x1bW5MaXN0Q2hhbmdlXG4gICAqIG9uIHBhZ2UgbG9hZC5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2NvbHVtbkxpc3RDaGFuZ2U6IEJlaGF2aW9yU3ViamVjdDxEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFxuICAgIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdXG4gID4odGhpcy5fY29sdW1uTGlzdCk7XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQHByb3BlcnR5IGNhbkhpZGVOZXh0Q29sdW1uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXJ2aWNlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGJ5IGNsci1kZy1jb2x1bW4tdG9nZ2xlIGNvbXBvbmVudC4gVXNlIHRoaXMgaWYgeW91IG5lZWQgdG8gYXNrIGlmIHlvdSBjYW4gaGlkZVxuICAgKiBhIGNvbHVtbi4gSXQgYWN0cyBhcyBhIGd1YXJkIGFnYWluc3QgaGlkaW5nIGFsbCB0aGUgY29sdW1ucyBtYWtpbmcgc3VyZSB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgY29sdW1uIGRpc3BsYXllZC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY2FuSGlkZU5leHRDb2x1bW4oKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaGlkZGVuQ29sdW1ucyA9IHRoaXMuX2NvbHVtbkxpc3QuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4gIT09IHVuZGVmaW5lZCkuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uaGlkZGVuKTtcbiAgICByZXR1cm4gdGhpcy5fY29sdW1uTGlzdC5sZW5ndGggLSBoaWRkZW5Db2x1bW5zLmxlbmd0aCA+IDE7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAcHJvcGVydHkgY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRm9yIHdoZW4geW91IG5lZWQgdG8ga25vdyBpZiB0aGUgZGF0YWdyaWQncyBjb2x1bW5zIGFyZSBhbGwgc2hvd2luZy5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuX2NvbHVtbkxpc3Quc29tZShjb2x1bW4gPT4gY29sdW1uICYmIGNvbHVtbi5oaWRkZW4pO1xuICB9XG5cbiAgLyoqKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBjb2x1bW5MaXN0Q2hhbmdlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHB1YmxpYyBwcm9wZXJ0eSB0aGF0IGVuYWJsZXMgc3Vic2NyaWJlcnMgdG8gaGVhciB1cGRhdGVzIHRvIHRoZSBjb2x1bW4gbWFwLlxuICAgKiBVc2UgdGhpcyBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmcgd2hlbmV2ZXIgdGhlIERhdGFncmlkJ3MgY29sdW1uIGxpc3QgaXMgY2hhbmdlZCAoaS5lICpuZ0lmIG9uIGEgY29sdW1uKS5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY29sdW1uTGlzdENoYW5nZSgpOiBPYnNlcnZhYmxlPERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkxpc3RDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBsaXN0IG9mIGNvbHVtbnMuIEkgbmVlZGVkIGFuIGFycmF5IG9mIHRvIGl0ZXJhdGUgb24gaW4gdGhlIFJvd1JlbmRlcmVyXG4gICAqIGJ1dCBzdWJzY3JpYmluZyB0byB0aGUgX2NvbHVtbkxpc3RDaGFuZ2UgY2hhbmdlcyBkaWQgbm90IHNlZW0gbGlrZSB0aGUgY29ycmVjdCB3YXkgdG8gZ2V0IGl0LlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldENvbHVtbnMoKTogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10ge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5MaXN0O1xuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY3VycmVudCBfY29sdW1uTGlzdDpcbiAgICogLSBpZiBpdCBoYXMgYSBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIGFuZCBpcyBoaWRkZW4gdGhlbiBzaG93IGl0LlxuICAgKiAtIGlmIGl0J3MgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiB3YXMgcHJldmlvdXNseSB0aGUgbGFzdCBjb2x1bW4gdmlzaWJsZSwgdHVybiB0aGF0IGZsYWcgb2ZmLlxuICAgKlxuICAgKi9cbiAgcHVibGljIHNob3dIaWRkZW5Db2x1bW5zKCkge1xuICAgIHRoaXMuX2NvbHVtbkxpc3QuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uaGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgIGNvbHVtbi5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4pIHtcbiAgICAgICAgY29sdW1uLmxhc3RWaXNpYmxlQ29sdW1uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbnM6IERhdGFncmlkQ29sdW1uW11cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbidzIHx8IG51bGwgYmFzZWQgY29sdW1uIGFycmF5IHBhc3NlZCBhcyBwYXJhbS5cbiAgICogSXMgZGVwZW5kZW50IG9uIHRoZSBvcmRlciBpbiBAQ29udGVudENoaWxkcmVuIGluIERhdGFncmlkLlxuICAgKlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUNvbHVtbkxpc3QoY29sdW1uczogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10pIHtcbiAgICB0aGlzLl9jb2x1bW5MaXN0ID0gY29sdW1uczsgLy8gY2xlYXIgdGhlIGxpc3RcbiAgICB0aGlzLnVwZGF0ZUZvckxhc3RWaXNpYmxlQ29sdW1uKCk7IC8vIFVwZGF0ZSBvdXIgdmlzaWJpbGl0eSBzdGF0ZSBmb3IgVUlcbiAgICB0aGlzLl9jb2x1bW5MaXN0Q2hhbmdlLm5leHQodGhpcy5fY29sdW1uTGlzdCk7IC8vIEJyb2FkY2FzdCBpdFxuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmlzaWJsZSBjb3VudCBmb3IgYWxsIGNvbHVtbnMuXG4gICAqIFdoZW4gaXQgaXMgZ3JlYXRlciB0aGFuIDEgaXQgbWFya3MgZXZlcnl0aGluZyBhcyBmYWxzZSBmb3IgdGhlIGxhc3RWaXNpYmxlQ29sdW1uLlxuICAgKiBXaGVuIHZpc2libGUgY291bnQgaXMgbm90ID4gMSAoaS5lKSAxLiAsIGl0IGZpbmRzIHRoZSBvbmx5IGNvbHVtbiB0aGF0IGlzIG5vdCBoaWRkZW4gYW5kIG1hcmtzIGl0IGFzIHRoZVxuICAgKiBsYXN0VmlzaWJsZUNvbHVtbi5cbiAgICpcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVGb3JMYXN0VmlzaWJsZUNvbHVtbigpOiB2b2lkIHtcbiAgICAvLyBUaGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbHVtbiBzaG93aW5nLCBtYWtlIHN1cmUgbm90aGluZyBpcyBtYXJrZWQgbGFzdFZpc2libGVDb2x1bW5cbiAgICBpZiAodGhpcy5jYW5IaWRlTmV4dENvbHVtbikge1xuICAgICAgdGhpcy5fY29sdW1uTGlzdC5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4pIHtcbiAgICAgICAgICBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSB2aXNpYmxlQ291bnQgaXMgZG93biB0byBvbmx5IG9uZSBjb2x1bW4gc2hvd2luZy4gRmluZCBpdCBhbmQgZmxhZyBpdCBhcyB0aGUgbGFzdFZpc2libGVDb2x1bW5cbiAgICAgIHRoaXMuX2NvbHVtbkxpc3QubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIGlmIChjb2x1bW4gJiYgIWNvbHVtbi5oaWRkZW4pIHtcbiAgICAgICAgICBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJuIGEgSGlkZWFibGVDb2x1bW4gaW4gdGhpcy5fY29sdW1uTGlzdCBmb3IgdGhlIGdpdmVuIGlkLlxuICAgKlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldENvbHVtbkJ5SWQoaWQ6IHN0cmluZyk6IHVuZGVmaW5lZCB8IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB7XG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29sdW1uTGlzdC5maW5kKGNvbHVtbiA9PiBjb2x1bW4gJiYgY29sdW1uLmlkID09PSBpZCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbWJlZGRlZFZpZXdSZWYsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2RnLXdyYXBwZWQtY2VsbCcsXG4gIHRlbXBsYXRlOiBgICAgICAgICBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNjZWxsUG9ydGFsPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIFdyYXBwZWRDZWxsIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIEFmdGVyVmlld0luaXQge1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAVmlld0NoaWxkKCdjZWxsUG9ydGFsJykgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPHZvaWQ+O1xuICBjZWxsVmlldzogRW1iZWRkZWRWaWV3UmVmPHZvaWQ+OyAvLyB0aGUgY2VsbHMgcHJvamVjdGVkIHZpZXdcblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5jZWxsVmlldyA9IHRoaXMudGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KG51bGwpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyU2lnbnBvc3QgfSBmcm9tICcuLi8uLi9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0JztcbmltcG9ydCB7IEhvc3RXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwZXInO1xuXG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBXcmFwcGVkQ2VsbCB9IGZyb20gJy4vd3JhcHBlZC1jZWxsJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNlbGwnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0YWdyaWQtY2VsbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1zaWducG9zdC10cmlnZ2VyXSc6ICdzaWducG9zdC5sZW5ndGggPiAwJyxcbiAgICByb2xlOiAnY2VsbCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ2VsbCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLyoqKioqKioqKlxuICAgKiBAcHJvcGVydHkgc2lnbnBvc3RcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEBDb250ZW50Q2hpbGQgaXMgdXNlZCB0byBkZXRlY3QgdGhlIHByZXNlbmNlIG9mIGEgU2lnbnBvc3QgaW4gdGhlIHByb2plY3RlZCBjb250ZW50LlxuICAgKiBPbiB0aGUgaG9zdCwgd2Ugc2V0IHRoZSAuZGF0YWdyaWQtc2lnbnBvc3QtdHJpZ2dlciBjbGFzcyBvbiB0aGUgY2VsbCB3aGVuIHNpZ25wb3N0Lmxlbmd0aCBpcyBncmVhdGVyIHRoYW4gMC5cbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyU2lnbnBvc3QpIHNpZ25wb3N0OiBRdWVyeUxpc3Q8Q2xyU2lnbnBvc3Q+O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaWRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIGlkZW50aWZpZXIgZm9yIGFuIGluc3RhbmNlIG9mIHRoaXMgY2VsbCB0aGF0IG1hcHMgaXQgdG8gYSBzcGVjaWZpYyBjb2x1bW5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG5cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIHRoaXMubWFwSGlkZWFibGVDb2x1bW4odGhpcy5faWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoaWRkZW5TdGF0ZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwcml2YXRlIF9lbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge31cblxuICBwcml2YXRlIG1hcEhpZGVhYmxlQ29sdW1uKGNvbHVtbklkOiBzdHJpbmcpIHtcbiAgICBpZiAoIWNvbHVtbklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGlkZWFibGVDb2x1bW4gPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5CeUlkKHRoaXMuX2lkKTtcblxuICAgIHRoaXMuc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW4uaGlkZGVuKTtcbiAgICB0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uID0gaGlkZWFibGVDb2x1bW4uaGlkZGVuQ2hhbmdlU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW4uaGlkZGVuKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW5WYWx1ZTogYm9vbGVhbikge1xuICAgIGlmIChoaWRlYWJsZUNvbHVtblZhbHVlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtY2VsbC0taGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1jZWxsLS1oaWRkZW4nKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHdyYXBwZWRJbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy53cmFwcGVkSW5qZWN0b3IgPSBuZXcgSG9zdFdyYXBwZXIoV3JhcHBlZENlbGwsIHRoaXMudmNyKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBfdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5qZWN0b3IuZ2V0KFdyYXBwZWRDZWxsLCB0aGlzLnZjcikuY2VsbFZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGVudW0gRGF0YWdyaWREaXNwbGF5TW9kZSB7XG4gIERJU1BMQVksXG4gIENBTENVTEFURSxcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGVudW0gRGF0YWdyaWRSZW5kZXJTdGVwIHtcbiAgQUxJR05fQ09MVU1OUyxcbiAgQ0FMQ1VMQVRFX01PREVfT04sXG4gIENBTENVTEFURV9NT0RFX09GRixcbiAgQ0xFQVJfV0lEVEhTLCAvLyBOb3RlIHRoaXMgaXMgbGlzdGVuZWQgdG8gYnkgYm90aCBjZWxscyBhbmQgY29sdW1uc1xuICBDT01QVVRFX0NPTFVNTl9XSURUSFMsXG4gIERFVEVDVF9TVFJJQ1RfV0lEVEhTLFxuICBVUERBVEVfUk9XX1dJRFRILFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIge1xuICBwcm90ZWN0ZWQgX3JlbmRlclN0ZXA6IFN1YmplY3Q8RGF0YWdyaWRSZW5kZXJTdGVwPiA9IG5ldyBTdWJqZWN0PERhdGFncmlkUmVuZGVyU3RlcD4oKTtcbiAgcHVibGljIGdldCByZW5kZXJTdGVwKCk6IE9ic2VydmFibGU8RGF0YWdyaWRSZW5kZXJTdGVwPiB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0ZXAuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgZmlsdGVyUmVuZGVyU3RlcHMoc3RlcDogRGF0YWdyaWRSZW5kZXJTdGVwKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyU3RlcC5waXBlKGZpbHRlcih0ZXN0U3RlcCA9PiBzdGVwID09PSB0ZXN0U3RlcCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhbHJlYWR5U2l6ZWQgPSBmYWxzZTtcblxuICBwdWJsaWMgd2lkdGhzOiB7IHB4OiBudW1iZXI7IHN0cmljdDogYm9vbGVhbiB9W10gPSBbXTtcblxuICBwdWJsaWMgcmVzaXplKCkge1xuICAgIHRoaXMud2lkdGhzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5DQUxDVUxBVEVfTU9ERV9PTik7XG4gICAgaWYgKHRoaXMuYWxyZWFkeVNpemVkKSB7XG4gICAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkNMRUFSX1dJRFRIUyk7XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuREVURUNUX1NUUklDVF9XSURUSFMpO1xuICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuQ09NUFVURV9DT0xVTU5fV0lEVEhTKTtcbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkFMSUdOX0NPTFVNTlMpO1xuICAgIHRoaXMuYWxyZWFkeVNpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkNBTENVTEFURV9NT0RFX09GRik7XG4gICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5VUERBVEVfUk9XX1dJRFRIKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFncmlkRGlzcGxheU1vZGUgfSBmcm9tICcuLi9lbnVtcy9kaXNwbGF5LW1vZGUuZW51bSc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlclN0ZXAgfSBmcm9tICcuLi9lbnVtcy9yZW5kZXItc3RlcC5lbnVtJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi4vcmVuZGVyL3JlbmRlci1vcmdhbml6ZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGlzcGxheU1vZGVTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcm90ZWN0ZWQgX3ZpZXc6IEJlaGF2aW9yU3ViamVjdDxEYXRhZ3JpZERpc3BsYXlNb2RlPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0YWdyaWREaXNwbGF5TW9kZT4oXG4gICAgRGF0YWdyaWREaXNwbGF5TW9kZS5ESVNQTEFZXG4gICk7XG5cbiAgY29uc3RydWN0b3IocmVuZGVyT3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcikge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgcmVuZGVyT3JnYW5pemVyXG4gICAgICAgIC5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuQ0FMQ1VMQVRFX01PREVfT04pXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdmlldy5uZXh0KERhdGFncmlkRGlzcGxheU1vZGUuQ0FMQ1VMQVRFKSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICByZW5kZXJPcmdhbml6ZXJcbiAgICAgICAgLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5DQUxDVUxBVEVfTU9ERV9PRkYpXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdmlldy5uZXh0KERhdGFncmlkRGlzcGxheU1vZGUuRElTUExBWSkpXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgdmlldygpOiBPYnNlcnZhYmxlPERhdGFncmlkRGlzcGxheU1vZGU+IHtcbiAgICByZXR1cm4gdGhpcy5fdmlldy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFRyYWNrQnlGdW5jdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciB9IGZyb20gJy4vZmlsdGVycyc7XG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vaXRlbXMnO1xuXG5sZXQgbmJTZWxlY3Rpb246IG51bWJlciA9IDA7XG5cbmV4cG9ydCBlbnVtIFNlbGVjdGlvblR5cGUge1xuICBOb25lLFxuICBTaW5nbGUsXG4gIE11bHRpLFxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uPFQgPSBhbnk+IHtcbiAgcHVibGljIGlkOiBzdHJpbmc7XG4gIHByaXZhdGUgcHJldlNlbGVjdGlvblJlZnM6IFRbXSA9IFtdOyAvLyBSZWZzIG9mIHNlbGVjdGVkIGl0ZW1zXG4gIHByaXZhdGUgcHJldlNpbmdsZVNlbGVjdGlvblJlZjogVDsgLy8gUmVmIG9mIHNpbmdsZSBzZWxlY3RlZCBpdGVtXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaXRlbXM6IEl0ZW1zPFQ+LCBwcml2YXRlIF9maWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4pIHtcbiAgICB0aGlzLmlkID0gJ2Nsci1kZy1zZWxlY3Rpb24nICsgbmJTZWxlY3Rpb24rKztcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5fZmlsdGVycy5jaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5faXRlbXMuYWxsQ2hhbmdlcy5zdWJzY3JpYmUodXBkYXRlZEl0ZW1zID0+IHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNlbGVjdGlvblR5cGUpIHtcbiAgICAgICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTm9uZToge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTZWxlY3Rpb25UeXBlLlNpbmdsZToge1xuICAgICAgICAgICAgbGV0IG5ld1NpbmdsZTogYW55O1xuICAgICAgICAgICAgY29uc3QgdHJhY2tCeTogVHJhY2tCeUZ1bmN0aW9uPFQ+ID0gdGhpcy5faXRlbXMudHJhY2tCeTtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25VcGRhdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50U2luZ2xlIGhhcyBiZWVuIHNldCBiZWZvcmUgZGF0YSB3YXMgbG9hZGVkLCB3ZSBsb29rIHVwIGFuZCBzYXZlIHRoZSByZWYgZnJvbSBjdXJyZW50IGRhdGEgc2V0XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2luZ2xlICYmICF0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmFsbCAmJiB0aGlzLl9pdGVtcy50cmFja0J5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gdGhpcy5jdXJyZW50U2luZ2xlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYgPSB0aGlzLl9pdGVtcy50cmFja0J5KGxvb2t1cCwgdGhpcy5jdXJyZW50U2luZ2xlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVkSXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVmID0gdHJhY2tCeShpbmRleCwgaXRlbSk7XG4gICAgICAgICAgICAgIC8vIElmIG9uZSBvZiB0aGUgdXBkYXRlZCBpdGVtcyBpcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZFNpbmdsZSwgc2V0IGl0IGFzIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYgPT09IHJlZikge1xuICAgICAgICAgICAgICAgIG5ld1NpbmdsZSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyBzbWFydCBkYXRhZ3JpZHMsIHdlIGV4cGVjdCBhbGwgaXRlbXMgdG8gYmUgcHJlc2VudCBpbiB0aGUgdXBkYXRlZEl0ZW1zIGFycmF5LlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBzaG91bGQgZGVsZXRlIHRoZSBjdXJyZW50U2luZ2xlIGlmIGl0IHVzZWQgdG8gYmUgZGVmaW5lZCBidXQgZG9lc24ndCBleGlzdCBhbnltb3JlLlxuICAgICAgICAgICAgLy8gTm8gZXhwbGljaXQgXCJkZWxldGVcIiBpcyByZXF1aXJlZCwgc2luY2UgbmV3U2luZ2xlIHdvdWxkIGJlIHVuZGVmaW5lZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgLy8gTWFya2luZyBpdCBhcyBzZWxlY3Rpb25VcGRhdGVkIGhlcmUgd2lsbCBzZXQgY3VycmVudFNpbmdsZSB0byB1bmRlZmluZWQgYmVsb3cgaW4gdGhlIHNldFRpbWVvdXQuXG4gICAgICAgICAgICBpZiAodGhpcy5faXRlbXMuc21hcnQgJiYgIW5ld1NpbmdsZSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25VcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogRGlzY3Vzc2VkIHRoaXMgd2l0aCBFdWRlcyBhbmQgdGhpcyBpcyBmaW5lIGZvciBub3cuXG4gICAgICAgICAgICAvLyBCdXQgd2UgbmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHBhdHRlcm4gZm9yIHRoZVxuICAgICAgICAgICAgLy8gY2hpbGQgdHJpZ2dlcmluZyB0aGUgcGFyZW50IGNoYW5nZSBkZXRlY3Rpb24gcHJvYmxlbS5cbiAgICAgICAgICAgIC8vIFVzaW5nIHNldFRpbWVvdXQgZm9yIG5vdyB0byBmaXggdGhpcy5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNpbmdsZSA9IG5ld1NpbmdsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTXVsdGk6IHtcbiAgICAgICAgICAgIGxldCBsZWZ0T3ZlcjogYW55W10gPSB0aGlzLmN1cnJlbnQuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrQnk6IFRyYWNrQnlGdW5jdGlvbjxhbnk+ID0gdGhpcy5faXRlbXMudHJhY2tCeTtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25VcGRhdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGhhcyBiZWVuIHNldCBiZWZvcmUgZGF0YSB3YXMgbG9hZGVkLCB3ZSBsb29rIHVwIGFuZCBzYXZlIHRoZSByZWYgZnJvbSBjdXJyZW50IGRhdGEgc2V0XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lmxlbmd0aCA+IDAgJiYgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5sZW5ndGggIT09IHRoaXMuY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmFsbCAmJiB0aGlzLl9pdGVtcy50cmFja0J5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gaXRlbSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLnB1c2godGhpcy5faXRlbXMudHJhY2tCeShsb29rdXAsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSB3b3JrIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMjM0MlxuICAgICAgICAgICAgLy8gY3VycmVudGx5LCB0aGUgc2VsZWN0aW9uIGlzIGNsZWFyZWQgd2hlbiBmaWx0ZXIgaXMgYXBwbGllZCwgc28gdGhlIGxvZ2ljIGluc2lkZVxuICAgICAgICAgICAgLy8gdGhlIGlmIHN0YXRlbWVudCBiZWxvdyByZXN1bHRzIGluIGJyb2tlbiBiZWhhdmlvci5cbiAgICAgICAgICAgIGlmIChsZWZ0T3Zlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRyYWNrQnkoaW5kZXgsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIC8vIExvb2sgaW4gY3VycmVudCBzZWxlY3RlZCByZWZzIGFycmF5IGlmIGl0ZW0gaXMgc2VsZWN0ZWQsIGFuZCB1cGRhdGUgYWN0dWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHRoaXMucHJldlNlbGVjdGlvblJlZnMuaW5kZXhPZihyZWYpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGxlZnRPdmVyW3NlbGVjdGVkSW5kZXhdID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBhbnkgdW5tYXRjaGVkIGl0ZW1zIGlmIHdlJ3JlIHVzaW5nIHNtYXJ0IGRhdGFncmlkcyB3aGVyZSB3ZSBleHBlY3QgYWxsIGl0ZW1zIHRvIGJlXG4gICAgICAgICAgICAgIC8vIHByZXNlbnRcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLnNtYXJ0KSB7XG4gICAgICAgICAgICAgICAgbGVmdE92ZXIgPSBsZWZ0T3Zlci5maWx0ZXIoc2VsZWN0ZWQgPT4gdXBkYXRlZEl0ZW1zLmluZGV4T2Yoc2VsZWN0ZWQpID4gLTEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQubGVuZ3RoICE9PSBsZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRPRE86IERpc2N1c3NlZCB0aGlzIHdpdGggRXVkZXMgYW5kIHRoaXMgaXMgZmluZSBmb3Igbm93LlxuICAgICAgICAgICAgICAvLyBCdXQgd2UgbmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHBhdHRlcm4gZm9yIHRoZVxuICAgICAgICAgICAgICAvLyBjaGlsZCB0cmlnZ2VyaW5nIHRoZSBwYXJlbnQgY2hhbmdlIGRldGVjdGlvbiBwcm9ibGVtLlxuICAgICAgICAgICAgICAvLyBVc2luZyBzZXRUaW1lb3V0IGZvciBub3cgdG8gZml4IHRoaXMuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25VcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBsZWZ0T3ZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgY2xlYXJTZWxlY3Rpb24oKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcyA9IFtdO1xuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2VsZWN0aW9uVHlwZTogU2VsZWN0aW9uVHlwZSA9IFNlbGVjdGlvblR5cGUuTm9uZTtcbiAgcHVibGljIGdldCBzZWxlY3Rpb25UeXBlKCk6IFNlbGVjdGlvblR5cGUge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25UeXBlO1xuICB9XG4gIHB1YmxpYyBzZXQgc2VsZWN0aW9uVHlwZSh2YWx1ZTogU2VsZWN0aW9uVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5zZWxlY3Rpb25UeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3NlbGVjdGlvblR5cGUgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IFNlbGVjdGlvblR5cGUuTm9uZSkge1xuICAgICAgZGVsZXRlIHRoaXMuY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVDdXJyZW50KFtdLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJvd1NlbGVjdGlvbk1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGdldCBfc2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5NdWx0aSB8fCB0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZTtcbiAgfVxuICAvKipcbiAgICogSWdub3JlIGl0ZW1zIGNoYW5nZXMgaW4gdGhlIHNhbWUgY2hhbmdlIGRldGVjdGlvbiBjeWNsZS5cbiAgICovXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICBwcml2YXRlIGRlYm91bmNlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gdGhlIG90aGVyIHByb3ZpZGVycyBjaGFuZ2VzLlxuICAgKi9cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgb3VyIHN1YnNjcmlwdGlvbnMgdG8gb3RoZXIgcHJvdmlkZXJzXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiBzaW5nbGUgc2VsZWN0aW9uIHR5cGVcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnRTaW5nbGU6IFQ7XG4gIHB1YmxpYyBnZXQgY3VycmVudFNpbmdsZSgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFNpbmdsZTtcbiAgfVxuICBwdWJsaWMgc2V0IGN1cnJlbnRTaW5nbGUodmFsdWU6IFQpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMuX2N1cnJlbnRTaW5nbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFNpbmdsZSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLl9pdGVtcy5hbGwgJiYgdGhpcy5faXRlbXMudHJhY2tCeSAmJiB2YWx1ZSkge1xuICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gdmFsdWUpO1xuICAgICAgdGhpcy5wcmV2U2luZ2xlU2VsZWN0aW9uUmVmID0gdGhpcy5faXRlbXMudHJhY2tCeShsb29rdXAsIHZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgLy8gSWdub3JlIGl0ZW1zIGNoYW5nZXMgaW4gdGhlIHNhbWUgY2hhbmdlIGRldGVjdGlvbiBjeWNsZS5cbiAgICAvLyBAVE9ETyBUaGlzIGNhbiBsaWtlbHkgYmUgcmVtb3ZlZCFcbiAgICB0aGlzLmRlYm91bmNlID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+ICh0aGlzLmRlYm91bmNlID0gZmFsc2UpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnQ6IFRbXTtcbiAgcHVibGljIGdldCBjdXJyZW50KCk6IFRbXSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gIH1cbiAgcHVibGljIHNldCBjdXJyZW50KHZhbHVlOiBUW10pIHtcbiAgICB0aGlzLnVwZGF0ZUN1cnJlbnQodmFsdWUsIHRydWUpO1xuICB9XG5cbiAgcHVibGljIHVwZGF0ZUN1cnJlbnQodmFsdWU6IFRbXSwgZW1pdDogYm9vbGVhbikge1xuICAgIHRoaXMuX2N1cnJlbnQgPSB2YWx1ZTtcbiAgICBpZiAoZW1pdCkge1xuICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgICAvLyBJZ25vcmUgaXRlbXMgY2hhbmdlcyBpbiB0aGUgc2FtZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgICAgLy8gQFRPRE8gVGhpcyBjYW4gbGlrZWx5IGJlIHJlbW92ZWQhXG4gICAgICB0aGlzLmRlYm91bmNlID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gKHRoaXMuZGVib3VuY2UgPSBmYWxzZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gc2VsZWN0aW9uIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PFRbXSB8IFQ+KCk7XG4gIHByaXZhdGUgZW1pdENoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5TaW5nbGUpIHtcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuY3VycmVudFNpbmdsZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk11bHRpKSB7XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dCh0aGlzLmN1cnJlbnQpO1xuICAgIH1cbiAgfVxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8VFtdIHwgVD4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqL1xuICBwdWJsaWMgaXNTZWxlY3RlZChpdGVtOiBUKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuU2luZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2luZ2xlID09PSBpdGVtO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5NdWx0aSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudC5pbmRleE9mKGl0ZW0pID49IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGFuIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgc2VsZWN0SXRlbShpdGVtOiBUKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50LnB1c2goaXRlbSk7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLnRyYWNrQnkpIHtcbiAgICAgIC8vIFB1c2ggc2VsZWN0ZWQgcmVmIG9udG8gYXJyYXlcbiAgICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMuX2l0ZW1zLmFsbC5maW5kSW5kZXgobWF5YmUgPT4gbWF5YmUgPT09IGl0ZW0pO1xuICAgICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5wdXNoKHRoaXMuX2l0ZW1zLnRyYWNrQnkobG9va3VwLCBpdGVtKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0cyBhbiBpdGVtXG4gICAqL1xuICBwcml2YXRlIGRlc2VsZWN0SXRlbShpbmRleE9mSXRlbTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50LnNwbGljZShpbmRleE9mSXRlbSwgMSk7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLnRyYWNrQnkgJiYgaW5kZXhPZkl0ZW0gPCB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLmxlbmd0aCkge1xuICAgICAgLy8gS2VlcCBzZWxlY3RlZCByZWZzIGFycmF5IGluIHN5bmNcbiAgICAgIHRoaXMucHJldlNlbGVjdGlvblJlZnMuc3BsaWNlKGluZGV4T2ZJdGVtLCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyBvciBkZXNlbGVjdHMgYW4gaXRlbVxuICAgKi9cbiAgcHVibGljIHNldFNlbGVjdGVkKGl0ZW06IFQsIHNlbGVjdGVkOiBib29sZWFuKSB7XG4gICAgc3dpdGNoICh0aGlzLl9zZWxlY3Rpb25UeXBlKSB7XG4gICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTm9uZTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNlbGVjdGlvblR5cGUuU2luZ2xlOlxuICAgICAgICAvLyBpbiBzaW5nbGUgc2VsZWN0aW9uLCBzZXQgY3VycmVudFNpbmdsZSBtZXRob2Qgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTXVsdGk6XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmICFzZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuZGVzZWxlY3RJdGVtKGluZGV4KTtcbiAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IDAgJiYgc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFsbCBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW1zIGFyZSBzZWxlY3RlZFxuICAgKi9cbiAgcHVibGljIGlzQWxsU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgIT09IFNlbGVjdGlvblR5cGUuTXVsdGkgfHwgIXRoaXMuX2l0ZW1zLmRpc3BsYXllZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkaXNwbGF5ZWRJdGVtczogVFtdID0gdGhpcy5faXRlbXMuZGlzcGxheWVkO1xuICAgIGNvbnN0IG5iRGlzcGxheWVkID0gdGhpcy5faXRlbXMuZGlzcGxheWVkLmxlbmd0aDtcbiAgICBpZiAobmJEaXNwbGF5ZWQgPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRlbXA6IFRbXSA9IGRpc3BsYXllZEl0ZW1zLmZpbHRlcihpdGVtID0+IHRoaXMuY3VycmVudC5pbmRleE9mKGl0ZW0pID4gLTEpO1xuICAgIHJldHVybiB0ZW1wLmxlbmd0aCA9PT0gZGlzcGxheWVkSXRlbXMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgb3IgZGVzZWxlY3RzIGFsbCBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlQWxsKCkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk5vbmUgfHwgdGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5TaW5nbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLypcbiAgICAgICAgICogSWYgZXZlcnkgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtIGlzIGFscmVhZHkgc2VsZWN0ZWQsIHdlIGNsZWFyIHRoZW0uXG4gICAgICAgICAqIElmIGF0IGxlYXN0IG9uZSBpdGVtIGlzbid0IHNlbGVjdGVkLCB3ZSBzZWxlY3QgZXZlcnkgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtLlxuICAgICAgICAgKi9cbiAgICBpZiAodGhpcy5pc0FsbFNlbGVjdGVkKCkpIHtcbiAgICAgIHRoaXMuX2l0ZW1zLmRpc3BsYXllZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLmN1cnJlbnQuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgdGhpcy5kZXNlbGVjdEl0ZW0oY3VycmVudEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2l0ZW1zLmRpc3BsYXllZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSkgPCAwKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRW1iZWRkZWRWaWV3UmVmLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkZy13cmFwcGVkLXJvdycsXG4gIHRlbXBsYXRlOiBgICAgICAgICBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNyb3dQb3J0YWw+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgV3JhcHBlZFJvdyBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBBZnRlclZpZXdJbml0IHtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcblxuICBAVmlld0NoaWxkKCdyb3dQb3J0YWwnKSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8dm9pZD47XG4gIHJvd1ZpZXc6IEVtYmVkZGVkVmlld1JlZjx2b2lkPjsgLy8gdGhlIHJvd3MgcHJvamVjdGVkIHZpZXcgKGluIG1lbW9yeSlcblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBjZWxscyB2aWV3IGluIG1lbW9yeSwgbm90IHRoZSBET00uXG4gICAgdGhpcy5yb3dWaWV3ID0gdGhpcy50ZW1wbGF0ZVJlZi5jcmVhdGVFbWJlZGRlZFZpZXcobnVsbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kJztcbmltcG9ydCB7IEhvc3RXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwZXInO1xuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDZWxsIH0gZnJvbSAnLi9kYXRhZ3JpZC1jZWxsJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcbmltcG9ydCB7IERhdGFncmlkRGlzcGxheU1vZGUgfSBmcm9tICcuL2VudW1zL2Rpc3BsYXktbW9kZS5lbnVtJztcbmltcG9ydCB7IERpc3BsYXlNb2RlU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2Rpc3BsYXktbW9kZS5zZXJ2aWNlJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJvd0FjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi9wcm92aWRlcnMvc2VsZWN0aW9uJztcbmltcG9ydCB7IFdyYXBwZWRSb3cgfSBmcm9tICcuL3dyYXBwZWQtcm93JztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbmxldCBuYlJvdzogbnVtYmVyID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXJvdycsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRhZ3JpZC1yb3cuaHRtbCcsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLXJvd10nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQnLFxuICAgICdbYXR0ci5hcmlhLW93bnNdJzogJ2lkJyxcbiAgICByb2xlOiAncm93Z3JvdXAnLFxuICB9LFxuICBwcm92aWRlcnM6IFtFeHBhbmQsIHsgcHJvdmlkZTogTG9hZGluZ0xpc3RlbmVyLCB1c2VFeGlzdGluZzogRXhwYW5kIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFJvdzxUID0gYW55PiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQge1xuICBwdWJsaWMgaWQ6IHN0cmluZztcbiAgcHVibGljIHJhZGlvSWQ6IHN0cmluZztcbiAgcHVibGljIGNoZWNrYm94SWQ6IHN0cmluZztcblxuICAvKiByZWZlcmVuY2UgdG8gdGhlIGVudW0gc28gdGhhdCB0ZW1wbGF0ZSBjYW4gYWNjZXNzICovXG4gIHB1YmxpYyBTRUxFQ1RJT05fVFlQRSA9IFNlbGVjdGlvblR5cGU7XG5cbiAgLyoqXG4gICAqIE1vZGVsIG9mIHRoZSByb3csIHRvIHVzZSBmb3Igc2VsZWN0aW9uXG4gICAqL1xuICBASW5wdXQoJ2NsckRnSXRlbScpIGl0ZW06IFQ7XG5cbiAgcHVibGljIHJlcGxhY2VkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBzZWxlY3Rpb246IFNlbGVjdGlvbjxUPixcbiAgICBwdWJsaWMgcm93QWN0aW9uU2VydmljZTogUm93QWN0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgZ2xvYmFsRXhwYW5kYWJsZTogRXhwYW5kYWJsZVJvd3NDb3VudCxcbiAgICBwdWJsaWMgZXhwYW5kOiBFeHBhbmQsXG4gICAgcHVibGljIGhpZGVhYmxlQ29sdW1uU2VydmljZTogSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgZGlzcGxheU1vZGU6IERpc3BsYXlNb2RlU2VydmljZSxcbiAgICBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICBuYlJvdysrO1xuICAgIHRoaXMuaWQgPSAnY2xyLWRnLXJvdycgKyBuYlJvdztcbiAgICB0aGlzLnJhZGlvSWQgPSAnY2xyLWRnLXJvdy1yZCcgKyBuYlJvdztcbiAgICB0aGlzLmNoZWNrYm94SWQgPSAnY2xyLWRnLXJvdy1jYicgKyBuYlJvdztcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgY29tYmluZUxhdGVzdCh0aGlzLmV4cGFuZC5yZXBsYWNlLCB0aGlzLmV4cGFuZC5leHBhbmRDaGFuZ2UpLnN1YnNjcmliZShcbiAgICAgICAgKFtleHBhbmRSZXBsYWNlVmFsdWUsIGV4cGFuZENoYW5nZVZhbHVlXSkgPT4ge1xuICAgICAgICAgIGlmIChleHBhbmRSZXBsYWNlVmFsdWUgJiYgZXhwYW5kQ2hhbmdlVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2VkIGFuZCBleHBhbmRpbmdcbiAgICAgICAgICAgIHRoaXMucmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1yb3ctcmVwbGFjZWQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gSGFuZGxlcyB0aGVzZSBjYXNlczogbm90IHJlcGxhY2VkIGFuZCBjb2xsYXBzaW5nICYgcmVwbGFjZWQgYW5kXG4gICAgICAgICAgICAvLyBjb2xsYXBzaW5nIGFuZCBub3QgcmVwbGFjZWQgYW5kIGV4cGFuZGluZy5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtcm93LXJlcGxhY2VkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgX3NlbGVjdGVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIHJvdyBpcyBzZWxlY3RlZFxuICAgKi9cbiAgcHVibGljIGdldCBzZWxlY3RlZCgpIHtcbiAgICBpZiAodGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5Ob25lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbi5pc1NlbGVjdGVkKHRoaXMuaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NlbGVjdGVkJylcbiAgcHVibGljIHNldCBzZWxlY3RlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk5vbmUpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNldFNlbGVjdGVkKHRoaXMuaXRlbSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnU2VsZWN0ZWRDaGFuZ2UnKSBzZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBwdWJsaWMgdG9nZ2xlKHNlbGVjdGVkID0gIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICBpZiAoc2VsZWN0ZWQgIT09IHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2VkLmVtaXQoc2VsZWN0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgZXhwYW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kLmV4cGFuZGVkO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0V4cGFuZGVkJylcbiAgcHVibGljIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZXhwYW5kLmV4cGFuZGVkID0gdmFsdWU7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ0V4cGFuZGVkQ2hhbmdlJykgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBwdWJsaWMgdG9nZ2xlRXhwYW5kKCkge1xuICAgIGlmICh0aGlzLmV4cGFuZC5leHBhbmRhYmxlKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqKioqXG4gICAqIHByb3BlcnR5IGRnQ2VsbHNcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgUXVlcnkgTGlzdCBvZiB0aGUgQ2xyRGF0YWdyaWQgY2VsbHMgaW4gdGhpcyByb3cuXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkQ2VsbCkgZGdDZWxsczogUXVlcnlMaXN0PENsckRhdGFncmlkQ2VsbD47XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGluZ3MgZ2V0IHN0YXJ0ZWRcbiAgICBjb25zdCBjb2x1bW5zTGlzdCA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbnMoKTtcbiAgICB0aGlzLnVwZGF0ZUNlbGxzRm9yQ29sdW1ucyhjb2x1bW5zTGlzdCk7XG5cbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgQ2VsbHMgbGlzdCBjaGFuZ2VzIHBlciByb3ctcmVuZGVyZXJcbiAgICB0aGlzLmRnQ2VsbHMuY2hhbmdlcy5zdWJzY3JpYmUoY2VsbExpc3QgPT4ge1xuICAgICAgY29uc3QgY29sdW1uTGlzdCA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbnMoKTtcbiAgICAgIGlmIChjZWxsTGlzdC5sZW5ndGggPT09IGNvbHVtbkxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXNlZCB0byBzZXQgdGhpbmdzIHVwIHRoZSBmaXJzdCB0aW1lIGJ1dCBvbmx5IGFmdGVyIGFsbCB0aGUgY29sdW1ucyBhcmUgcmVhZHkuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jb2x1bW5MaXN0Q2hhbmdlLnN1YnNjcmliZShjb2x1bW5MaXN0ID0+IHtcbiAgICAgICAgLy8gUHJldmVudHMgY2VsbCB1cGRhdGVzIHdoZW4gY29scyBhbmQgY2VsbHMgYXJyYXkgYXJlIG5vdCBhbGlnbmVkIC0gb25seSBzZWVtcyB0byBydW4gb24gaW5pdCAvIGZpcnN0IHRpbWUuXG4gICAgICAgIGlmIChjb2x1bW5MaXN0Lmxlbmd0aCA9PT0gdGhpcy5kZ0NlbGxzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRpc3BsYXlNb2RlLnZpZXcuc3Vic2NyaWJlKHZpZXdDaGFuZ2UgPT4ge1xuICAgICAgICAvLyBMaXN0ZW4gZm9yIHZpZXcgY2hhbmdlcyBhbmQgbW92ZSBjZWxscyBhcm91bmQgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGRpc3BsYXlUeXBlXG4gICAgICAgIC8vIHJlbW92ZSBjZWxsIHZpZXdzIGZyb20gZGlzcGxheSB2aWV3XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9zY3JvbGxhYmxlQ2VsbHMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZUNlbGxzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBjZWxsIHZpZXdzIGZyb20gY2FsY3VsYXRlZCB2aWV3XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9jYWxjdWxhdGVkQ2VsbHMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlZENlbGxzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3Q2hhbmdlID09PSBEYXRhZ3JpZERpc3BsYXlNb2RlLkNBTENVTEFURSkge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUNlbGxzID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5kZ0NlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVkQ2VsbHMuaW5zZXJ0KGNlbGwuX3ZpZXcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUNlbGxzID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRnQ2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGVDZWxscy5pbnNlcnQoY2VsbC5fdmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAxLiBNYXBzIHRoZSBuZXcgY29sdW1uTGlzdENoYW5nZSB0byB0aGUgZGdDZWxscyBsaXN0IGJ5IGluZGV4XG4gICAqIDIuIFNldHMgdGhlIGhpZGRlbiBzdGF0ZSBvbiB0aGUgY2VsbFxuICAgKiBUYWtlIGEgQ29sdW1uIGxpc3QgYW5kIHVzZSBpbmRleCB0byBhY2Nlc3MgdGhlIGNvbHVtbnMgZm9yIGhpZGVhYmxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3Q6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdKSB7XG4gICAgLy8gTWFwIGNlbGxzIHRvIGNvbHVtbnMgd2l0aCBBcnJheS5pbmRleFxuICAgIHRoaXMuZGdDZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudENvbHVtbiA9IGNvbHVtbkxpc3RbaW5kZXhdOyAvLyBBY2NvdW50cyBmb3IgbnVsbCBzcGFjZS5cbiAgICAgIGlmIChjdXJyZW50Q29sdW1uKSB7XG4gICAgICAgIGNlbGwuaWQgPSBjdXJyZW50Q29sdW1uLmlkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHVibGljIGRpc3BsYXlDZWxscyA9IGZhbHNlO1xuXG4gIEBWaWV3Q2hpbGQoJ3N0aWNreUNlbGxzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9zdGlja3lDZWxsczogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgnc2Nyb2xsYWJsZUNlbGxzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9zY3JvbGxhYmxlQ2VsbHM6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ2NhbGN1bGF0ZWRDZWxscycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfY2FsY3VsYXRlZENlbGxzOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIHByaXZhdGUgd3JhcHBlZEluamVjdG9yOiBJbmplY3RvcjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLndyYXBwZWRJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcihXcmFwcGVkUm93LCB0aGlzLnZjcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0IF92aWV3KCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZWRJbmplY3Rvci5nZXQoV3JhcHBlZFJvdywgdGhpcy52Y3IpLnJvd1ZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSB7XG4gIGJ1dHRvbnM6IFRlbXBsYXRlUmVmPGFueT4gPSBudWxsO1xuICBzZWxlY3RBbGxEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3NlbGVjdEFsbEJ1dHRvbkNsaWNrZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwdWJsaWMgZ2V0IHNlbGVjdEFsbEJ1dHRvbkNsaWNrZWQoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdEFsbEJ1dHRvbkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgYnV0dG9uQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxCdXR0b25DbGlja2VkLm5leHQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvciB9IGZyb20gJy4uL2J1aWx0LWluL2NvbXBhcmF0b3JzL2RhdGFncmlkLXByb3BlcnR5LWNvbXBhcmF0b3InO1xuaW1wb3J0IHsgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlciB9IGZyb20gJy4uL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtcHJvcGVydHktc3RyaW5nLWZpbHRlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGwgfSBmcm9tICcuLi9idWlsdC1pbi9maWx0ZXJzL2RhdGFncmlkLXN0cmluZy1maWx0ZXItaW1wbCc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFN0YXRlSW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9zdGF0ZS5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcGFnZSc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9zb3J0JztcbmltcG9ydCB7IFN0YXRlRGVib3VuY2VyIH0gZnJvbSAnLi9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXIgYWdncmVnYXRlcyBzdGF0ZSBjaGFuZ2VzIGZyb20gdGhlIHZhcmlvdXMgcHJvdmlkZXJzIG9mIHRoZSBEYXRhZ3JpZFxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RhdGVQcm92aWRlcjxUPiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LFxuICAgIHByaXZhdGUgc29ydDogU29ydDxUPixcbiAgICBwcml2YXRlIHBhZ2U6IFBhZ2UsXG4gICAgcHJpdmF0ZSBkZWJvdW5jZXI6IFN0YXRlRGVib3VuY2VyXG4gICkge31cblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIGdsb2JhbCBzdGF0ZSBjaGFuZ2VzXG4gICAqL1xuICBjaGFuZ2U6IE9ic2VydmFibGU8Q2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZTxUPj4gPSB0aGlzLmRlYm91bmNlci5jaGFuZ2UucGlwZShtYXAoKCkgPT4gdGhpcy5zdGF0ZSkpO1xuXG4gIC8qXG4gICAgICogQnkgbWFraW5nIHRoaXMgYSBnZXR0ZXIsIHdlIG9wZW4gdGhlIHBvc3NpYmlsaXR5IGZvciBhIHNldHRlciBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEl0J3MgYmVlbiByZXF1ZXN0ZWQgYSBjb3VwbGUgdGltZXMuXG4gICAgICovXG4gIGdldCBzdGF0ZSgpOiBDbHJEYXRhZ3JpZFN0YXRlSW50ZXJmYWNlPFQ+IHtcbiAgICBjb25zdCBzdGF0ZTogQ2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZTxUPiA9IHt9O1xuICAgIGlmICh0aGlzLnBhZ2Uuc2l6ZSA+IDApIHtcbiAgICAgIHN0YXRlLnBhZ2UgPSB7IGZyb206IHRoaXMucGFnZS5maXJzdEl0ZW0sIHRvOiB0aGlzLnBhZ2UubGFzdEl0ZW0sIHNpemU6IHRoaXMucGFnZS5zaXplIH07XG4gICAgfVxuICAgIGlmICh0aGlzLnNvcnQuY29tcGFyYXRvcikge1xuICAgICAgaWYgKHRoaXMuc29ydC5jb21wYXJhdG9yIGluc3RhbmNlb2YgRGF0YWdyaWRQcm9wZXJ0eUNvbXBhcmF0b3IpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWFsIGNhc2UgZm9yIHRoZSBkZWZhdWx0IG9iamVjdCBwcm9wZXJ0eSBjb21wYXJhdG9yLFxuICAgICAgICAgICAgICAgICAqIHdlIGdpdmUgdGhlIHByb3BlcnR5IG5hbWUgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIGNvbXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgIHN0YXRlLnNvcnQgPSB7IGJ5OiAoPERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yPFQ+PnRoaXMuc29ydC5jb21wYXJhdG9yKS5wcm9wLCByZXZlcnNlOiB0aGlzLnNvcnQucmV2ZXJzZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuc29ydCA9IHsgYnk6IHRoaXMuc29ydC5jb21wYXJhdG9yLCByZXZlcnNlOiB0aGlzLnNvcnQucmV2ZXJzZSB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZUZpbHRlcnMgPSB0aGlzLmZpbHRlcnMuZ2V0QWN0aXZlRmlsdGVycygpO1xuICAgIGlmIChhY3RpdmVGaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YXRlLmZpbHRlcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGFjdGl2ZUZpbHRlcnMpIHtcbiAgICAgICAgaWYgKGZpbHRlciBpbnN0YW5jZW9mIERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCkge1xuICAgICAgICAgIGNvbnN0IHN0cmluZ0ZpbHRlciA9IGZpbHRlci5maWx0ZXJGbjtcbiAgICAgICAgICBpZiAoc3RyaW5nRmlsdGVyIGluc3RhbmNlb2YgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlcikge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFNwZWNpYWwgY2FzZSBhZ2FpbiBmb3IgdGhlIGRlZmF1bHQgb2JqZWN0IHByb3BlcnR5IGZpbHRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdlIGdpdmUgdGhlIHByb3BlcnR5IG5hbWUgaW5zdGVhZCBvZiB0aGUgZnVsbCBmaWx0ZXIgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdGF0ZS5maWx0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICBwcm9wZXJ0eTogc3RyaW5nRmlsdGVyLnByb3AsXG4gICAgICAgICAgICAgIHZhbHVlOiBmaWx0ZXIudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveSwgUExBVEZPUk1fSUQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4vLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vLi4vcmVuZGVyL3JlbmRlci1vcmdhbml6ZXInO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogSW50ZXJuYWwgZGF0YWdyaWQgc2VydmljZSB0aGF0IGhvbGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBjbHItZGctdGFibGUgZWxlbWVudCBhbmQgZXhwb3NlcyBhIG1ldGhvZCB0byBnZXQgaGVpZ2h0LlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGFibGVTaXplU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgX3RhYmxlUmVmOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBjb2x1bW5zOiBFbGVtZW50W107XG5cbiAgcHVibGljIGdldCB0YWJsZVJlZigpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX3RhYmxlUmVmO1xuICB9XG5cbiAgcHVibGljIHNldCB0YWJsZVJlZihlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuX3RhYmxlUmVmID0gZWxlbWVudDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHJlbmRlck9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgcmVuZGVyT3JnYW5pemVyLnJlbmRlclN0ZXAuc3Vic2NyaWJlKHN0ZXAgPT4ge1xuICAgICAgICBpZiAoc3RlcCA9PT0gRGF0YWdyaWRSZW5kZXJTdGVwLlVQREFURV9ST1dfV0lEVEgpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVJvd1dpZHRoKCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBwdWJsaWMgc2V0IHRhYmxlKHRhYmxlOiBFbGVtZW50UmVmKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgdGFibGUubmF0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy50YWJsZVJlZiA9IHRhYmxlLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRhdGFncmlkLXRhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB3aGVuIHJlc2l6aW5nIGNvbHVtbnMgdG8gc2hvdyB0aGUgY29sdW1uIGJvcmRlciBiZWluZyBkcmFnZ2VkLlxuICBnZXRDb2x1bW5EcmFnSGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLnRhYmxlUmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLnRhYmxlUmVmLmNsaWVudEhlaWdodH1weGA7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHVwZGF0ZVJvd1dpZHRoKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy50YWJsZVJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbmV3V2lkdGg6IG51bWJlciA9IDA7XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZSh0aGlzLnRhYmxlUmVmLCAnd2lkdGgnKTtcbiAgICB0aGlzLmNvbHVtbnMgPSBBcnJheS5mcm9tKHRoaXMudGFibGVSZWYucXVlcnlTZWxlY3RvckFsbCgnLmRhdGFncmlkLWNvbHVtbicpKTtcbiAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIG5ld1dpZHRoICs9IGl0ZW0uY2xpZW50V2lkdGg7XG4gICAgfSk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnRhYmxlUmVmLCAnd2lkdGgnLCBuZXdXaWR0aCArICdweCcpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW4gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEl0ZW1zIH0gZnJvbSAnLi9kYXRhZ3JpZC1pdGVtcyc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1wbGFjZWhvbGRlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFJvdyB9IGZyb20gJy4vZGF0YWdyaWQtcm93JztcbmltcG9ydCB7IERhdGFncmlkRGlzcGxheU1vZGUgfSBmcm9tICcuL2VudW1zL2Rpc3BsYXktbW9kZS5lbnVtJztcbmltcG9ydCB7IENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvY29sdW1uLXRvZ2dsZS1idXR0b25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGlzcGxheU1vZGVTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGlzcGxheS1tb2RlLnNlcnZpY2UnO1xuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZmlsdGVycyc7XG5pbXBvcnQgeyBFeHBhbmRhYmxlUm93c0NvdW50IH0gZnJvbSAnLi9wcm92aWRlcnMvZ2xvYmFsLWV4cGFuZGFibGUtcm93cyc7XG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vcHJvdmlkZXJzL2l0ZW1zJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlJztcbmltcG9ydCB7IFJvd0FjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgU2VsZWN0aW9uLCBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi9wcm92aWRlcnMvc2VsZWN0aW9uJztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL3Byb3ZpZGVycy9zb3J0JztcbmltcG9ydCB7IFN0YXRlRGVib3VuY2VyIH0gZnJvbSAnLi9wcm92aWRlcnMvc3RhdGUtZGVib3VuY2VyLnByb3ZpZGVyJztcbmltcG9ydCB7IFN0YXRlUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9zdGF0ZS5wcm92aWRlcic7XG5pbXBvcnQgeyBUYWJsZVNpemVTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdGFibGUtc2l6ZS5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi9yZW5kZXIvcmVuZGVyLW9yZ2FuaXplcic7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGF0YWdyaWQnLFxuICB0ZW1wbGF0ZVVybDogJy4vZGF0YWdyaWQuaHRtbCcsXG4gIHByb3ZpZGVyczogW1xuICAgIFNlbGVjdGlvbixcbiAgICBTb3J0LFxuICAgIEZpbHRlcnNQcm92aWRlcixcbiAgICBQYWdlLFxuICAgIEl0ZW1zLFxuICAgIERhdGFncmlkUmVuZGVyT3JnYW5pemVyLFxuICAgIFJvd0FjdGlvblNlcnZpY2UsXG4gICAgRXhwYW5kYWJsZVJvd3NDb3VudCxcbiAgICBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgU3RhdGVEZWJvdW5jZXIsXG4gICAgU3RhdGVQcm92aWRlcixcbiAgICBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSxcbiAgICBUYWJsZVNpemVTZXJ2aWNlLFxuICAgIERpc3BsYXlNb2RlU2VydmljZSxcbiAgXSxcbiAgaG9zdDogeyAnW2NsYXNzLmRhdGFncmlkLWhvc3RdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkPFQgPSBhbnk+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb2x1bW5TZXJ2aWNlOiBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyLFxuICAgIHB1YmxpYyBpdGVtczogSXRlbXM8VD4sXG4gICAgcHVibGljIGV4cGFuZGFibGVSb3dzOiBFeHBhbmRhYmxlUm93c0NvdW50LFxuICAgIHB1YmxpYyBzZWxlY3Rpb246IFNlbGVjdGlvbjxUPixcbiAgICBwdWJsaWMgcm93QWN0aW9uU2VydmljZTogUm93QWN0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIHN0YXRlUHJvdmlkZXI6IFN0YXRlUHJvdmlkZXI8VD4sXG4gICAgcHJpdmF0ZSBkaXNwbGF5TW9kZTogRGlzcGxheU1vZGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge31cblxuICAvKiByZWZlcmVuY2UgdG8gdGhlIGVudW0gc28gdGhhdCB0ZW1wbGF0ZSBjYW4gYWNjZXNzICovXG4gIHB1YmxpYyBTRUxFQ1RJT05fVFlQRSA9IFNlbGVjdGlvblR5cGU7XG5cbiAgLyoqXG4gICAqIEZyZWV6ZXMgdGhlIGRhdGFncmlkIHdoaWxlIGRhdGEgaXMgbG9hZGluZ1xuICAgKi9cbiAgcHVibGljIGdldCBsb2FkaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLmxvYWRpbmc7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnTG9hZGluZycpXG4gIHB1YmxpYyBzZXQgbG9hZGluZyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuaXRlbXMubG9hZGluZyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE91dHB1dCBlbWl0dGVkIHdoZW5ldmVyIHRoZSBkYXRhIG5lZWRzIHRvIGJlIHJlZnJlc2hlZCwgYmFzZWQgb24gdXNlciBhY3Rpb24gb3IgZXh0ZXJuYWwgb25lc1xuICAgKi9cbiAgQE91dHB1dCgnY2xyRGdSZWZyZXNoJykgcHVibGljIHJlZnJlc2ggPSBuZXcgRXZlbnRFbWl0dGVyPENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2U8VD4+KGZhbHNlKTtcblxuICAvKipcbiAgICogUHVibGljIG1ldGhvZCB0byByZS10cmlnZ2VyIHRoZSBjb21wdXRhdGlvbiBvZiBkaXNwbGF5ZWQgaXRlbXMgbWFudWFsbHlcbiAgICovXG4gIHB1YmxpYyBkYXRhQ2hhbmdlZCgpIHtcbiAgICB0aGlzLml0ZW1zLnJlZnJlc2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBncmFiIHRoZSBzbWFydCBpdGVyYXRvciBmcm9tIHByb2plY3RlZCBjb250ZW50XG4gICAqL1xuICBAQ29udGVudENoaWxkKENsckRhdGFncmlkSXRlbXMpIHB1YmxpYyBpdGVyYXRvcjogQ2xyRGF0YWdyaWRJdGVtczxUPjtcblxuICAvKipcbiAgICogQXJyYXkgb2YgYWxsIHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBASW5wdXQoJ2NsckRnU2VsZWN0ZWQnKVxuICBzZXQgc2VsZWN0ZWQodmFsdWU6IFRbXSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9IFNlbGVjdGlvblR5cGUuTXVsdGk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPSBTZWxlY3Rpb25UeXBlLk5vbmU7XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0aW9uLnVwZGF0ZUN1cnJlbnQodmFsdWUsIGZhbHNlKTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnU2VsZWN0ZWRDaGFuZ2UnKSBzZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRbXT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBTZWxlY3RlZCBpdGVtIGluIHNpbmdsZS1zZWxlY3QgbW9kZVxuICAgKi9cbiAgQElucHV0KCdjbHJEZ1NpbmdsZVNlbGVjdGVkJylcbiAgc2V0IHNpbmdsZVNlbGVjdGVkKHZhbHVlOiBUKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9IFNlbGVjdGlvblR5cGUuU2luZ2xlO1xuICAgIC8vIHRoZSBjbHJEZ1NpbmdsZVNlbGVjdGVkIGlzIHVwZGF0ZWQgaW4gb25lIG9mIHR3byBjYXNlczpcbiAgICAvLyAxLiBhbiBleHBsaWNpdCB2YWx1ZSBpcyBwYXNzZWRcbiAgICAvLyAyLiBpcyBiZWluZyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdoZXJlIHByZXZpb3VzbHkgaXQgaGFkIGEgdmFsdWVcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmN1cnJlbnRTaW5nbGUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLmN1cnJlbnRTaW5nbGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLmN1cnJlbnRTaW5nbGUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnU2luZ2xlU2VsZWN0ZWRDaGFuZ2UnKSBzaW5nbGVTZWxlY3RlZENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFQ+KGZhbHNlKTtcblxuICAvKipcbiAgICogU2VsZWN0aW9uL0Rlc2VsZWN0aW9uIG9uIHJvdyBjbGljayBtb2RlXG4gICAqL1xuICBASW5wdXQoJ2NsckRnUm93U2VsZWN0aW9uJylcbiAgc2V0IHJvd1NlbGVjdGlvbk1vZGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnNlbGVjdGlvbi5yb3dTZWxlY3Rpb25Nb2RlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIGFsbCBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW1zIGFyZSBzZWxlY3RlZFxuICAgKi9cbiAgcHVibGljIGdldCBhbGxTZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uaXNBbGxTZWxlY3RlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMvZGVzZWxlY3RzIGFsbCBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW1zXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHNldCBhbGxTZWxlY3RlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIC8qXG4gICAgICAgICAqIFRoaXMgaXMgYSBzZXR0ZXIgYnV0IHdlIGlnbm9yZSB0aGUgdmFsdWUuXG4gICAgICAgICAqIEl0J3Mgc3RyYW5nZSwgYnV0IGl0IGxldHMgdXMgaGF2ZSBhbiBpbmRldGVybWluYXRlIHN0YXRlIHdoZXJlIG9ubHlcbiAgICAgICAgICogc29tZSBvZiB0aGUgaXRlbXMgYXJlIHNlbGVjdGVkLlxuICAgICAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGlvbi50b2dnbGVBbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b20gcGxhY2Vob2xkZXIgZGV0ZWN0aW9uXG4gICAqL1xuICBAQ29udGVudENoaWxkKENsckRhdGFncmlkUGxhY2Vob2xkZXIpIHB1YmxpYyBwbGFjZWhvbGRlcjogQ2xyRGF0YWdyaWRQbGFjZWhvbGRlcjxUPjtcblxuICAvKipcbiAgICogSGlkZWFibGUgQ29sdW1uIGRhdGEgc291cmNlIC8gZGV0ZWN0aW9uLlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJEYXRhZ3JpZENvbHVtbikgcHVibGljIGNvbHVtbnM6IFF1ZXJ5TGlzdDxDbHJEYXRhZ3JpZENvbHVtbjxUPj47XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIGRhdGFncmlkIGlzIHVzZXItbWFuYWdlZCB3aXRob3V0IHRoZSBzbWFydCBpdGVyYXRvciwgd2UgZ2V0IHRoZSBpdGVtcyBkaXNwbGF5ZWRcbiAgICogYnkgcXVlcnlpbmcgdGhlIHByb2plY3RlZCBjb250ZW50LiBUaGlzIGlzIG5lZWRlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBtb2RlbHMgY3VycmVudGx5XG4gICAqIGRpc3BsYXllZCwgdHlwaWNhbGx5IGZvciBzZWxlY3Rpb24uXG4gICAqL1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRSb3cpIHJvd3M6IFF1ZXJ5TGlzdDxDbHJEYXRhZ3JpZFJvdzxUPj47XG4gIEBWaWV3Q2hpbGQoJ3Njcm9sbGFibGVDb2x1bW5zJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIHNjcm9sbGFibGVDb2x1bW5zOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuaXRlbXMuc21hcnQpIHtcbiAgICAgIHRoaXMuaXRlbXMuYWxsID0gdGhpcy5yb3dzLm1hcCgocm93OiBDbHJEYXRhZ3JpZFJvdzxUPikgPT4gcm93Lml0ZW0pO1xuICAgIH1cblxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucm93cy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5pdGVtcy5zbWFydCkge1xuICAgICAgICAgIHRoaXMuaXRlbXMuYWxsID0gdGhpcy5yb3dzLm1hcCgocm93OiBDbHJEYXRhZ3JpZFJvdzxUPikgPT4gcm93Lml0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgdGhpcy5fZGlzcGxheWVkUm93cy5pbnNlcnQocm93Ll92aWV3KTtcbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmNvbHVtbnMuY2hhbmdlcy5zdWJzY3JpYmUoKGNvbHVtbnM6IENsckRhdGFncmlkQ29sdW1uPFQ+W10pID0+IHtcbiAgICAgICAgdGhpcy5jb2x1bW5TZXJ2aWNlLnVwZGF0ZUNvbHVtbkxpc3QodGhpcy5jb2x1bW5zLm1hcChjb2wgPT4gY29sLmhpZGVhYmxlKSk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBHZXQgQ29sdW1uU2VydmljZSByZWFkeSBmb3IgSGlkZWFibGVDb2x1bW5zLlxuICAgIHRoaXMuY29sdW1uU2VydmljZS51cGRhdGVDb2x1bW5MaXN0KHRoaXMuY29sdW1ucy5tYXAoY29sID0+IGNvbC5oaWRlYWJsZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE91ciBzZXR1cCBoYXBwZW5zIGluIHRoZSB2aWV3IG9mIHNvbWUgb2Ygb3VyIGNvbXBvbmVudHMsIHNvIHdlIHdhaXQgZm9yIGl0IHRvIGJlIGRvbmUgYmVmb3JlIHN0YXJ0aW5nXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgLy8gVE9ETzogZGV0ZXJtaW5lIGlmIHdlIGNhbiBnZXQgcmlkIG9mIHByb3ZpZGVyIHdpcmluZyBpbiB2aWV3IGluaXQgc28gdGhhdCBzdWJzY3JpcHRpb25zIGNhbiBiZSBkb25lIGVhcmxpZXJcbiAgICB0aGlzLnJlZnJlc2guZW1pdCh0aGlzLnN0YXRlUHJvdmlkZXIuc3RhdGUpO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaCh0aGlzLnN0YXRlUHJvdmlkZXIuY2hhbmdlLnN1YnNjcmliZShzdGF0ZSA9PiB0aGlzLnJlZnJlc2guZW1pdChzdGF0ZSkpKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLnNlbGVjdGlvbi5jaGFuZ2Uuc3Vic2NyaWJlKHMgPT4ge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5TaW5nbGUpIHtcbiAgICAgICAgICB0aGlzLnNpbmdsZVNlbGVjdGVkQ2hhbmdlZC5lbWl0KDxUPnMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuTXVsdGkpIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlZC5lbWl0KDxUW10+cyk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICAvLyBBIHN1YnNjcmlwdGlvbiB0aGF0IGxpc3RlbnMgZm9yIGRpc3BsYXlNb2RlIGNoYW5nZXMgb24gdGhlIGRhdGFncmlkXG4gICAgdGhpcy5kaXNwbGF5TW9kZS52aWV3LnN1YnNjcmliZSh2aWV3Q2hhbmdlID0+IHtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcHJvamVjdGVkIGNvbHVtbnMgZnJvbSB0aGUgcHJvamVjdGVkRGlzcGxheUNvbHVtbnMgY29udGFpbmVyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJvamVjdGVkRGlzcGxheUNvbHVtbnMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMuX3Byb2plY3RlZERpc3BsYXlDb2x1bW5zLmRldGFjaCgpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGFueSBwcm9qZWN0ZWQgY29sdW1ucyBmcm9tIHRoZSBwcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnMgY29udGFpbmVyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fcHJvamVjdGVkQ2FsY3VsYXRpb25Db2x1bW5zLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICB0aGlzLl9wcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnMuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgYW55IHByb2plY3RlZCByb3dzIGZyb20gdGhlIGNhbGN1bGF0aW9uUm93cyBjb250YWluZXJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9jYWxjdWxhdGlvblJvd3MubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0aW9uUm93cy5kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBhbnkgcHJvamVjdGVkIHJvd3MgZnJvbSB0aGUgZGlzcGxheWVkUm93cyBjb250YWluZXJcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9kaXNwbGF5ZWRSb3dzLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICB0aGlzLl9kaXNwbGF5ZWRSb3dzLmRldGFjaCgpO1xuICAgICAgfVxuICAgICAgaWYgKHZpZXdDaGFuZ2UgPT09IERhdGFncmlkRGlzcGxheU1vZGUuRElTUExBWSkge1xuICAgICAgICAvLyBTZXQgc3RhdGUsIHN0eWxlIGZvciB0aGUgZGF0YWdyaWQgdG8gRElTUExBWSBhbmQgaW5zZXJ0IHJvdyAmIGNvbHVtbnMgaW50byBjb250YWluZXJzXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtY2FsY3VsYXRlLW1vZGUnKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICB0aGlzLl9wcm9qZWN0ZWREaXNwbGF5Q29sdW1ucy5pbnNlcnQoY29sdW1uLl92aWV3KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgdGhpcy5fZGlzcGxheWVkUm93cy5pbnNlcnQocm93Ll92aWV3KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXQgc3RhdGUsIHN0eWxlIGZvciB0aGUgZGF0YWdyaWQgdG8gQ0FMQ1VMQVRFIGFuZCBpbnNlcnQgcm93ICYgY29sdW1ucyBpbnRvIGNvbnRhaW5lcnNcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1jYWxjdWxhdGUtbW9kZScpO1xuICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICAgIHRoaXMuX3Byb2plY3RlZENhbGN1bGF0aW9uQ29sdW1ucy5pbnNlcnQoY29sdW1uLl92aWV3KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRpb25Sb3dzLmluc2VydChyb3cuX3ZpZXcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpcHRpb25zIHRvIGFsbCB0aGUgc2VydmljZXMgYW5kIHF1ZXJpZXMgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICByZXNpemUoKTogdm9pZCB7XG4gICAgdGhpcy5vcmdhbml6ZXIucmVzaXplKCk7XG4gIH1cblxuICBAVmlld0NoaWxkKCdwcm9qZWN0ZWREaXNwbGF5Q29sdW1ucycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfcHJvamVjdGVkRGlzcGxheUNvbHVtbnM6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ3Byb2plY3RlZENhbGN1bGF0aW9uQ29sdW1ucycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfcHJvamVjdGVkQ2FsY3VsYXRpb25Db2x1bW5zOiBWaWV3Q29udGFpbmVyUmVmO1xuICBAVmlld0NoaWxkKCdkaXNwbGF5ZWRSb3dzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9kaXNwbGF5ZWRSb3dzOiBWaWV3Q29udGFpbmVyUmVmO1xuICBAVmlld0NoaWxkKCdjYWxjdWxhdGlvblJvd3MnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgX2NhbGN1bGF0aW9uUm93czogVmlld0NvbnRhaW5lclJlZjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctYWN0aW9uLWJhcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuZGF0YWdyaWQtYWN0aW9uLWJhcl0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRBY3Rpb25CYXIge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcblxuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctYWN0aW9uLW92ZXJmbG93JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiAoY2xpY2spPVwidG9nZ2xlKCRldmVudClcIiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJkYXRhZ3JpZC1hY3Rpb24tdG9nZ2xlXCIgI2FuY2hvcj5cbiAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImVsbGlwc2lzLXZlcnRpY2FsXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5yb3dBY3Rpb25zXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbKGNsclBvcG92ZXJPbGQpXT1cIm9wZW5cIiBbY2xyUG9wb3Zlck9sZEFuY2hvcl09XCJhbmNob3JcIiBbY2xyUG9wb3Zlck9sZEFuY2hvclBvaW50XT1cImFuY2hvclBvaW50XCJcbiAgICAgICAgICAgICAgICAgICAgIFtjbHJQb3BvdmVyT2xkUG9wb3ZlclBvaW50XT1cInBvcG92ZXJQb2ludFwiPlxuICAgICAgICAgICAgPGRpdiAjbWVudSBjbGFzcz1cImRhdGFncmlkLWFjdGlvbi1vdmVyZmxvd1wiIChjbHJPdXRzaWRlQ2xpY2spPVwiY2xvc2UoJGV2ZW50KVwiIFtjbHJTdHJpY3RdPVwidHJ1ZVwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQWN0aW9uT3ZlcmZsb3cgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwdWJsaWMgYW5jaG9yUG9pbnQ6IFBvaW50ID0gUG9pbnQuUklHSFRfQ0VOVEVSO1xuICBwdWJsaWMgcG9wb3ZlclBvaW50OiBQb2ludCA9IFBvaW50LkxFRlRfQ0VOVEVSO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcm93QWN0aW9uU2VydmljZTogUm93QWN0aW9uU2VydmljZSwgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MpIHtcbiAgICB0aGlzLnJvd0FjdGlvblNlcnZpY2UucmVnaXN0ZXIoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucm93QWN0aW9uU2VydmljZS51bnJlZ2lzdGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIHdoZXRoZXIgdGhlIGFjdGlvbiBvdmVyZmxvdyBtZW51IGlzIG9wZW4gb3Igbm90XG4gICAqL1xuICBwcml2YXRlIF9vcGVuID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb3BlbjtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdBY3Rpb25PdmVyZmxvd09wZW4nKVxuICBwdWJsaWMgc2V0IG9wZW4ob3BlbjogYm9vbGVhbikge1xuICAgIGNvbnN0IGJvb2xPcGVuID0gISFvcGVuO1xuICAgIGlmIChib29sT3BlbiAhPT0gdGhpcy5fb3Blbikge1xuICAgICAgdGhpcy5fb3BlbiA9IGJvb2xPcGVuO1xuICAgICAgdGhpcy5vcGVuQ2hhbmdlZC5lbWl0KGJvb2xPcGVuKTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ0FjdGlvbk92ZXJmbG93T3BlbkNoYW5nZScpIHB1YmxpYyBvcGVuQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8qXG4gICAgICogV2UgbmVlZCB0byByZW1lbWJlciB0aGUgY2xpY2sgdGhhdCBvcGVucyB0aGUgbWVudSwgdG8gbWFrZSBzdXJlIGl0IGRvZXNuJ3QgY2xvc2UgdGhlIG1lbnUgaW5zdGFudGx5XG4gICAgICogd2hlbiB0aGUgZXZlbnQgYnViYmxlcyB1cCB0aGUgRE9NIGFsbCB0aGUgd2F5IHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggd2UgYWxzbyBsaXN0ZW4gdG8uXG4gICAgICovXG4gIHByaXZhdGUgb3BlbmluZ0V2ZW50OiBhbnk7XG5cbiAgLyoqXG4gICAqIFNob3dzL2hpZGVzIHRoZSBhY3Rpb24gb3ZlcmZsb3cgbWVudVxuICAgKi9cbiAgcHVibGljIHRvZ2dsZShldmVudDogYW55KSB7XG4gICAgdGhpcy5vcGVuaW5nRXZlbnQgPSBldmVudDtcbiAgICB0aGlzLm9wZW4gPSAhdGhpcy5vcGVuO1xuICB9XG5cbiAgcHVibGljIGNsb3NlKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgLypcbiAgICAgICAgICogQmVjYXVzZSB0aGlzIGxpc3RlbmVyIGlzIGFkZGVkIHN5bmNob25vdXNseSwgYmVmb3JlIHRoZSBldmVudCBmaW5pc2hlcyBidWJibGluZyB1cCB0aGUgRE9NLFxuICAgICAgICAgKiB3ZSBlbmQgdXAgZmlyaW5nIG9uIHRoZSB2ZXJ5IGNsaWNrIHRoYXQganVzdCBvcGVuZWQgdGhlIG1lbnUsIHBcbiAgICAgICAgICogb3RlbnRpYWxseSBjbG9zaW5nIGl0IGltbWVkaWF0ZWx5IGV2ZXJ5IHRpbWUuIFNvIHdlIGp1c3QgaWdub3JlIGl0LlxuICAgICAgICAgKi9cbiAgICBpZiAoZXZlbnQgPT09IHRoaXMub3BlbmluZ0V2ZW50KSB7XG4gICAgICBkZWxldGUgdGhpcy5vcGVuaW5nRXZlbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlbiA9IGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4tdG9nZ2xlLWJ1dHRvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVCdXR0b25zLmJ1dHRvbkNsaWNrZWQoKVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwidG9nZ2xlQnV0dG9ucy5zZWxlY3RBbGxEaXNhYmxlZFwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIHRvZ2dsZUJ1dHRvbnM6IENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4tdG9nZ2xlLXRpdGxlJyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIENvbnRlbnRDaGlsZHJlbiwgT25EZXN0cm95LCBPbkluaXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlcic7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLWJ1dHRvbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLXRpdGxlJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcbmltcG9ydCB7IENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvY29sdW1uLXRvZ2dsZS1idXR0b25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbi10b2dnbGUnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgI2FuY2hvclxuICAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVVSSgpXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmsgY29sdW1uLXRvZ2dsZS0tYWN0aW9uXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJ2aWV3LWNvbHVtbnNcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLnBpY2tDb2x1bW5zXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4tc3dpdGNoXCJcbiAgICAgICAgICAgICAqY2xyUG9wb3Zlck9sZD1cIm9wZW47IGFuY2hvcjogYW5jaG9yOyBhbmNob3JQb2ludDogYW5jaG9yUG9pbnQ7IHBvcG92ZXJQb2ludDogcG9wb3ZlclBvaW50XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhdGl0bGVcIj5TaG93IENvbHVtbnM8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItZGctY29sdW1uLXRvZ2dsZS10aXRsZVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tbGlua1wiXG4gICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVVSSgpXCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJjbG9zZVwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MuY2xvc2VcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJzd2l0Y2gtY29udGVudCBsaXN0LXVuc3R5bGVkXCI+XG4gICAgICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgY29sdW1uc1wiPlxuICAgICAgICAgICAgICAgICAgICA8Y2xyLWNoZWNrYm94LXdyYXBwZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xyQ2hlY2tib3ggdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImNvbHVtbi5sYXN0VmlzaWJsZUNvbHVtblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ01vZGVsXT1cIiFjb2x1bW4uaGlkZGVuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwidG9nZ2xlQ29sdW1uKCRldmVudCwgY29sdW1uKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsPjxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2x1bW4udGVtcGxhdGVcIj48L25nLXRlbXBsYXRlPjwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDwvY2xyLWNoZWNrYm94LXdyYXBwZXI+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoLWZvb3RlclwiICpuZ0lmPVwiYnV0dG9ucy5sZW5ndGggPiAwXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGUtYnV0dG9uXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3dpdGNoLWZvb3RlclwiICpuZ0lmPVwiYnV0dG9ucy5sZW5ndGggPT09IDBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rIHA2IHRleHQtdXBwZXJjYXNlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiYWxsQ29sdW1uc1Zpc2libGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3RBbGwoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiPlNlbGVjdCBBbGxcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmNvbHVtbi1zd2l0Y2gtd3JhcHBlcl0nOiAndHJ1ZScsICdbY2xhc3MuYWN0aXZlXSc6ICdvcGVuJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIF9hbGxDb2x1bW5zVmlzaWJsZTogYm9vbGVhbjtcblxuICAvKioqXG4gICAqIFBvcG92ZXIgaW5pdFxuICAgKi9cbiAgcHVibGljIGFuY2hvclBvaW50OiBQb2ludCA9IFBvaW50LlRPUF9MRUZUO1xuICBwdWJsaWMgcG9wb3ZlclBvaW50OiBQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICBwdWJsaWMgb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKioqXG4gICAqIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCBpbml0XG4gICAqL1xuICBwdWJsaWMgY29sdW1uczogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10gPSBbXTtcblxuICBwdWJsaWMgZ2V0IGFsbENvbHVtbnNWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9hbGxDb2x1bW5zVmlzaWJsZTtcbiAgfVxuXG4gIHB1YmxpYyBzZXQgYWxsQ29sdW1uc1Zpc2libGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9hbGxDb2x1bW5zVmlzaWJsZSA9IHZhbHVlO1xuICB9XG5cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlKSB0aXRsZTogQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZTtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbikgYnV0dG9uczogUXVlcnlMaXN0PENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uPjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaGlkZWFibGVDb2x1bW5TZXJ2aWNlOiBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb2x1bW5Ub2dnbGVCdXR0b25zOiBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jb2x1bW5MaXN0Q2hhbmdlLnN1YnNjcmliZShjb2x1bW5MaXN0ID0+IHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIGxpc3Qgb2YgY29sdW1uc1xuICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UudXBkYXRlRm9yTGFzdFZpc2libGVDb2x1bW4oKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zVmlzaWJsZSA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNoZWNrRm9yQWxsQ29sdW1uc1Zpc2libGU7XG4gICAgICAgIHRoaXMuY29sdW1uVG9nZ2xlQnV0dG9ucy5zZWxlY3RBbGxEaXNhYmxlZCA9IHRoaXMuYWxsQ29sdW1uc1Zpc2libGU7XG5cbiAgICAgICAgLy8gQWRkIG9ubHkgdGhlIGhpZGRlbiBjb2x1bW5zIHRvIHRoZSB0b2dnbGVyLlxuICAgICAgICBjb2x1bW5MaXN0LmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICBpZiAoY29sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY29sdW1uVG9nZ2xlQnV0dG9ucy5zZWxlY3RBbGxCdXR0b25DbGlja2VkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VsZWN0QWxsKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgc2VsZWN0QWxsKCkge1xuICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLnNob3dIaWRkZW5Db2x1bW5zKCk7XG4gICAgdGhpcy5hbGxDb2x1bW5zVmlzaWJsZSA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNoZWNrRm9yQWxsQ29sdW1uc1Zpc2libGU7XG4gICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkID0gdGhpcy5hbGxDb2x1bW5zVmlzaWJsZTtcbiAgfVxuXG4gIHRvZ2dsZUNvbHVtbihldmVudDogYm9vbGVhbiwgY29sdW1uOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwpIHtcbiAgICBjb2x1bW4uaGlkZGVuID0gIWV2ZW50O1xuICAgIHRoaXMuYWxsQ29sdW1uc1Zpc2libGUgPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jaGVja0ZvckFsbENvbHVtbnNWaXNpYmxlO1xuICAgIHRoaXMuY29sdW1uVG9nZ2xlQnV0dG9ucy5zZWxlY3RBbGxEaXNhYmxlZCA9IHRoaXMuYWxsQ29sdW1uc1Zpc2libGU7XG4gICAgdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UudXBkYXRlRm9yTGFzdFZpc2libGVDb2x1bW4oKTtcbiAgfVxuXG4gIHRvZ2dsZVVJKCkge1xuICAgIHRoaXMub3BlbiA9ICF0aGlzLm9wZW47XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEV4cGFuZGFibGVSb3dzQ291bnQgfSBmcm9tICcuL3Byb3ZpZGVycy9nbG9iYWwtZXhwYW5kYWJsZS1yb3dzJztcblxuLypcbiAqIEkgZG9uJ3QgdGhpbmsgdGhpcyBkZXNlcnZlcyB0byBiZSBpbiBJZkV4cGFuZGVkIGl0c2VsZixcbiAqIHNvIEknbSBhZGRpbmcgYSBzZWNvbmQgZGlyZWN0aXZlIG9uIHRoZSBzYW1lIHNlbGVjdG9yIGZvciBub3cganVzdCBmb3IgdGhlIGRhdGFncmlkXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkV4cGFuZGVkXScgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZERldGFpbFJlZ2lzdGVyZXIge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIGV4cGFuZGFibGVSb3dzQ291bnQ6IEV4cGFuZGFibGVSb3dzQ291bnQpIHtcbiAgICBpZiAodGhpcy5leHBhbmRhYmxlUm93c0NvdW50KSB7XG4gICAgICB0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQucmVnaXN0ZXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5leHBhbmRhYmxlUm93c0NvdW50KSB7XG4gICAgICB0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQudW5yZWdpc3RlcigpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uLXRvZ2dsZSc7XG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIFNlbGVjdGlvblR5cGUgfSBmcm9tICcuL3Byb3ZpZGVycy9zZWxlY3Rpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctZm9vdGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgKm5nSWY9XCIoc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNFTEVDVElPTl9UWVBFLk11bHRpKSAmJiAoc2VsZWN0aW9uLmN1cnJlbnQubGVuZ3RoID4gMClcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZFwiPlxuICAgICAgICAgICAgICA8Y2xyLWNoZWNrYm94LXdyYXBwZXIgY2xhc3M9XCJkYXRhZ3JpZC1mb290ZXItc2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IGNsckNoZWNrYm94IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9XCJjaGVja2VkXCIgZGlzYWJsZWQ+XG4gICAgICAgICAgICAgICAgPGxhYmVsPnt7c2VsZWN0aW9uLmN1cnJlbnQubGVuZ3RofX08L2xhYmVsPlxuICAgICAgICAgICAgPC9jbHItY2hlY2tib3gtd3JhcHBlcj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1jb2x1bW4tdG9nZ2xlXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8Y2xyLWRnLWNvbHVtbi10b2dnbGUgKm5nSWY9XCIhdG9nZ2xlICYmIGFjdGl2ZVRvZ2dsZXJcIj48L2Nsci1kZy1jb2x1bW4tdG9nZ2xlPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtZm9vdGVyLWRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItZGctcGFnaW5hdGlvblwiPjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1mb290ZXJdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZEZvb3RlcjxUID0gYW55PiBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBzZWxlY3Rpb246IFNlbGVjdGlvbjxUPixcbiAgICBwdWJsaWMgaGlkZWFibGVDb2x1bW5TZXJ2aWNlOiBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWZcbiAgKSB7fVxuXG4gIHB1YmxpYyBhY3RpdmVUb2dnbGVyOiBib29sZWFuO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgLyogcmVmZXJlbmNlIHRvIHRoZSBlbnVtIHNvIHRoYXQgdGVtcGxhdGUgY2FuIGFjY2VzcyAqL1xuICBwdWJsaWMgU0VMRUNUSU9OX1RZUEUgPSBTZWxlY3Rpb25UeXBlO1xuXG4gIEBDb250ZW50Q2hpbGQoQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGUpIHRvZ2dsZTogQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGU7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jb2x1bW5MaXN0Q2hhbmdlLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICBjb25zdCBoaWRkZW5Db2x1bW5zSW5TdWIgPSBjaGFuZ2UuZmlsdGVyKGNvbCA9PiBjb2wpO1xuICAgICAgICBpZiAoaGlkZGVuQ29sdW1uc0luU3ViLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLmFjdGl2ZVRvZ2dsZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBjb25zdCBoaWRkZW5Db2x1bW5zID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpLmZpbHRlcihjb2wgPT4gY29sKTtcblxuICAgIGlmIChoaWRkZW5Db2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWN0aXZlVG9nZ2xlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHtcbiAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgdXRpbGl0eSBjbGFzcyBmb3IgdGhhdCBhZGRzIGhpZGUvc2hvdyBmdW5jdGlvbmFsaXR5IHRvIGEgY29sdW1uLCBpdHMgY2VsbHMgYW5kIGVuYWJsZXMgYSB0b2dnbGVyIGluIHRoZVxuICogRGF0YWdyaWRDb2x1bW5Ub2dnbGUgQ29tcG9uZW50LlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB7XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaGlkZGVuQ2hhbmdlc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBzdHJlYW0gb2Ygc3RhdGUgY2hhbmdlcyBhbiBpbnN0YW5jZSBvZiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgd2lsbCBicm9hZGNhc3QgdG8gc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIGhpZGRlbkNoYW5nZXNTdGF0ZTogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgaW5pdCBmdW5jdGlvbiBmb3IgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIGluc3RhbmNlcyB0aGF0IGRvZXMgdGhlIGZvbGxvd2luZzpcbiAgICpcbiAgICogMS4gU2V0IHZhbHVlcyBmb3IgdGhlIHByaXZhdGUgdmFyaWFibGVzIHRoYXQgZW5hYmxlIGEgaGlkZWFibGUgY29sdW1uXG4gICAqIDIuIEJyb2FkY2FzdCB0aGUgbmV4dCBoaWRkZW4gY2hhbmdlIGZvciBhbnlvbmUgKGFscmVhZHkpIHN1YnNjcmliZWQgdG8gdGhpcyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxcbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LCBwcml2YXRlIF9pZDogc3RyaW5nLCBwcml2YXRlIF9oaWRkZW46IGJvb2xlYW4gPSBmYWxzZSkge31cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBUZW1wbGF0ZVJlZiBvZiB0aGUgRGF0YWdyaWRDb2x1bW4gdGhhdCBpcyBoaWRlYWJsZS4gVGhpcyBpcyBjdXJyZW50bHkgdXNlZCB0b1xuICAgKiBwb3B1bGF0ZSB0aGUgRGF0YWdyaWRDb2x1bW5Ub2dnbGUgVUkgd2l0aCB0aGUgY29ycmVjdCBDb2x1bW4gbmFtZS5cbiAgICpcbiAgICovXG4gIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIHB1YmxpYyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGlkIG9mIGEgSGlkZWFibGVDT2x1bW4gaW5zdGFuY2UuIFVzZWQgYnkgdGhlIEhpZGVhYmxlQ09sdW1uU2VydmljZSBmb3IgcGFzc2luZ1xuICAgKiBzdGF0ZSBhbmQgYWN0aW9ucyBiZXR3ZWVuIERhdGVHcmlkQ29sdW1ucywgRGF0YUdyaWRDZWxscyAmIHRoZSBEYXRhZ3JpZENvbHVtblRvZ2dsZSBDb21wb25lbnRzLlxuICAgKlxuICAgKi9cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgdGhlIGhpZGRlbiB2YWx1ZSBvZiBhIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCBpbnN0YW5jZS5cbiAgICpcbiAgICovXG4gIGdldCBoaWRkZW4oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHNldHRlciBmb3Igc2V0dGluZyB0aGUgaGlkZGVuIHN0YXRlIG9mIGEgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIGluc3RhbmNlLlxuICAgKiBJdCBhbHNvIGJyb2FkY2FzdHMgdGhlIGNoYW5nZSBhZnRlciBpdHMgc2V0LlxuICAgKlxuICAgKi9cbiAgc2V0IGhpZGRlbih2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLl9oaWRkZW4gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2hpZGRlbiA9IHZhbHVlO1xuICAgIHRoaXMuaGlkZGVuQ2hhbmdlc1N0YXRlLm5leHQodmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBPYnNlcnZhYmxlIGZvciB0aGUgSGlkZWFibGVDb2x1bW5zIGhpZGRlbiBjaGFuZ2VzLlxuICAgKlxuICAgKi9cbiAgZ2V0IGhpZGRlbkNoYW5nZVN0YXRlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLmhpZGRlbkNoYW5nZXNTdGF0ZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8vIEZsYWcgdGhpcyB0cnVlIHdoZW4gdGhlIHNlcnZpY2Ugb25seSBoYXMgb25lIHZpc2libGUgY29sdW1uIG9wZW4uXG5cbiAgcHVibGljIGxhc3RWaXNpYmxlQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW4gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbic7XG5pbXBvcnQgeyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgfSBmcm9tICcuL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbCc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJEZ0hpZGVhYmxlQ29sdW1uXScgfSlcblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHN0cnVjdHVyYWwgZGlyZWN0aXZlIG1lYW50IHRvIGJlIHVzZWQgaW5zaWRlIGEgY2xyLWRnLWNvbHVtbiBjb21wb25lbnQuXG4gKlxuICogPGNsci1kZy1jb2x1bW4+XG4gKiAgICAgICA8bmctY29udGFpbmVyICpjbHJEZ0hpZGVhYmxlQ29sdW1uPVwieyBoaWRkZW46IHRydWUgfVwiPlxuICogICAgICAgICAgIFVzZXIgSURcbiAqICAgICAgIDwvbmctY29udGFpbmVyPlxuICogICA8L2Nsci1kZy1jb2x1bW4+XG4gKlxuICogSXQgc2V0cyB1cCBzdGF0ZSBhbmQgcHJvcGVydGllcyBzbyB0aGF0IGNvbHVtbnMgY2FuIGJlIG1hbmdlcyBmb3IgaGlkZS9zaG93IGJ5IGEgc2VydmljZSBhbmQgYW4gaW50ZXJuYWxcbiAqIGRhdGFncmlkIHRvZ2dsZSBjb21wb25lbnQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiB7XG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVXNlZCB0byBpbml0aWFsaXplIHRoZSBjb2x1bW4gd2l0aCBlaXRoZXIgaGlkZGVuIG9yIHZpc2libGUgc3RhdGUuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9oaWRkZW46IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXR0ZXIgZm4gZm9yIHRoZSBASW5wdXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoaXMgc3RydWN0dXJhbCBkaXJlY3RpdmUuXG4gICAqIEl0IGFsbG93cyB0aGUgdXNlciB0byBwcmUtY29uZmlndXJlIHRoZSBjb2x1bW4ncyBoaWRlL3Nob3cgc3RhdGUuIHsgaGlkZGVuOiB0cnVlIH1cbiAgICogSXQncyBtb3JlIHZlcmJvc2UgYnV0IGhhcyBtb3JlIENsYXJpdHkuXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICpjbHJEZ0hpZGVhYmxlQ29sdW1uXG4gICAqICpjbHJEZ0hpZGVhYmxlQ29sdW1uPXtoaWRkZW46IGZhbHNlfVxuICAgKiAqY2xyRGdIaWRlYWJsZUNvbHVtbj17aGlkZGVuOiB0cnVlfVxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJEZ0hpZGVhYmxlQ29sdW1uJylcbiAgc2V0IGNsckRnSGlkZWFibGVDb2x1bW4odmFsdWU6IHsgaGlkZGVuOiBib29sZWFuIH0pIHtcbiAgICB0aGlzLmNsckRnSGlkZGVuID0gdmFsdWUgJiYgdmFsdWUuaGlkZGVuID8gdmFsdWUuaGlkZGVuIDogZmFsc2U7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnSGlkZGVuJylcbiAgc2V0IGNsckRnSGlkZGVuKGhpZGRlbjogYm9vbGVhbikge1xuICAgIHRoaXMuX2hpZGRlbiA9IGhpZGRlbiA/IGhpZGRlbiA6IGZhbHNlO1xuICAgIGlmICh0aGlzLmRnQ29sdW1uLmhpZGVhYmxlKSB7XG4gICAgICB0aGlzLmRnQ29sdW1uLmhpZGVhYmxlLmhpZGRlbiA9IHRoaXMuX2hpZGRlbjtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ0hpZGRlbkNoYW5nZScpIHB1YmxpYyBoaWRkZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHVuaXF1ZSBpZGVudGlmaWVyIHBhc3NlZCBpbnRvIHRoZSBkaXJlY3RpdmUgZnJvbSB0aGUgcGFyZW50IChBIERhdGFncmlkQ29sdW1uKS5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBjb2x1bW5JZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQW4gaW5zdGFuY2Ugb2YgdGhlIERhdGFncmlkSGlkZWFibGVDb2x1bW4gVXRpbGl0eSBjbGFzcyB0aGF0IGlzIHVzZWQgdG86XG4gICAqIDEuIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBIaWRlYWJsZUNvbHVtbiB0aGF0IHdpbGwgbWFuYWdlIHRoZSBUZW1wbGF0ZVJlZiwgc3RhdGUgYW5kIGNvbW11bmljYXRpb25cbiAgICogMi4gTWFuYWdlIHRoZSBoaWRkZW4vc2hvd24gc3RhdGUgZm9yIHRoZSBjb2x1bW4gdG8gd2hpY2ggdGhpcyBkaXJlY3RpdmUgaXMgYXBwbGllZFxuICAgKiAzLiB0cmFjayB0aGUgaWQgb2YgdGhlIGhpZGRlbiBjb2x1bW4gc28gaXQgY2FuIGJlIHVzZWQgaW4gY2VsbHMgYXMgd2VsbCBhcyBvbiB0aGUgY29sdW1uXG4gICAqL1xuICBwdWJsaWMgY29sdW1uOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWw7XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVc2VkIHRoZSBEYXRhZ3JpZENvbHVtbiB0byBnZXQgYW5kIHNldCBhbiBpZCBmb3IgdGhpcyBIaWRkZW5Db2x1bW5cbiAgICpcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgZGdDb2x1bW46IENsckRhdGFncmlkQ29sdW1uPGFueT5cbiAgKSB7XG4gICAgdGhpcy5jb2x1bW5JZCA9IGRnQ29sdW1uLmNvbHVtbklkO1xuXG4gICAgLy8gVXNlIHRoZSB0ZW1wbGF0ZVJlZiB0byBjcmVhdGUgdGhpcyB2aWV3XG4gICAgdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlUmVmKTtcblxuICAgIC8vIENyZWF0ZSBpbnN0YW5jZSBvZiB0aGUgdXRpbGl0eSBjbGFzcyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uLlxuICAgIC8vIE5vdGUgdGhpcyBpcyBvbiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIERhdGFncmlkQ29sdW1uLlxuICAgIHRoaXMuZGdDb2x1bW4uaGlkZWFibGUgPSBuZXcgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsKHRoaXMudGVtcGxhdGVSZWYsIHRoaXMuY29sdW1uSWQsIHRoaXMuX2hpZGRlbik7XG4gICAgdGhpcy5kZ0NvbHVtbi5oaWRlYWJsZS5oaWRkZW5DaGFuZ2VTdGF0ZS5zdWJzY3JpYmUoc3RhdGUgPT4gdGhpcy5oaWRkZW5DaGFuZ2UuZW1pdChzdGF0ZSkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPcHRpb25hbCwgVHJhY2tCeUZ1bmN0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEl0ZW1zIH0gZnJvbSAnLi9wcm92aWRlcnMvaXRlbXMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbbmdGb3JUcmFja0J5XScsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkSXRlbXNUcmFja0J5PFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSBfaXRlbXM6IEl0ZW1zPFQ+KSB7fVxuXG4gIEBJbnB1dCgnbmdGb3JUcmFja0J5JylcbiAgc2V0IHRyYWNrQnkodmFsdWU6IFRyYWNrQnlGdW5jdGlvbjxUPikge1xuICAgIGlmICh0aGlzLl9pdGVtcykge1xuICAgICAgdGhpcy5faXRlbXMudHJhY2tCeSA9IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcGFnZS1zaXplJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPGRpdiBjbGFzcz1cImNsci1zZWxlY3Qtd3JhcHBlclwiPlxuICAgICAgPHNlbGVjdCBbY2xhc3MuY2xyLXBhZ2Utc2l6ZS1zZWxlY3RdPVwidHJ1ZVwiIFsobmdNb2RlbCldPVwicGFnZS5zaXplXCI+XG4gICAgICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IG9wdGlvbiBvZiBwYWdlU2l6ZU9wdGlvbnNcIiBbbmdWYWx1ZV09XCJvcHRpb25cIj57e29wdGlvbn19PC9vcHRpb24+XG4gICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbiAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRQYWdlU2l6ZSB7XG4gIEBJbnB1dCgnY2xyUGFnZVNpemVPcHRpb25zJykgcGFnZVNpemVPcHRpb25zOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZTogUGFnZSkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIXRoaXMucGFnZVNpemVPcHRpb25zIHx8IHRoaXMucGFnZVNpemVPcHRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5wYWdlU2l6ZU9wdGlvbnMgPSBbdGhpcy5wYWdlLnNpemVdO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlJztcbmltcG9ydCB7IENsckRhdGFncmlkUGFnZVNpemUgfSBmcm9tICcuL2RhdGFncmlkLXBhZ2Utc2l6ZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1wYWdpbmF0aW9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwicGFnaW5hdGlvbi1zaXplXCIgKm5nSWY9XCJfcGFnZVNpemVDb21wb25lbnRcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1wYWdlLXNpemVcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInBhZ2luYXRpb24tZGVzY3JpcHRpb25cIj5cbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicGFnaW5hdGlvbi1saXN0XCIgKm5nSWY9XCJwYWdlLmxhc3QgPiAxXCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwicGFnaW5hdGlvbi1maXJzdFwiIFtkaXNhYmxlZF09XCJwYWdlLmN1cnJlbnQgPD0gMVwiIChjbGljayk9XCJwYWdlLmN1cnJlbnQgPSAxXCI+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInN0ZXAtZm9yd2FyZC0yIGRvd25cIj48L2Nsci1pY29uPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwicGFnaW5hdGlvbi1wcmV2aW91c1wiIFtkaXNhYmxlZF09XCJwYWdlLmN1cnJlbnQgPD0gMVwiIChjbGljayk9XCJwYWdlLmN1cnJlbnQgPSBwYWdlLmN1cnJlbnQgLSAxXCI+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImFuZ2xlIGxlZnRcIj48L2Nsci1pY29uPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8aW5wdXQgI2N1cnJlbnRQYWdlSW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInBhZ2luYXRpb24tY3VycmVudFwiIFtzaXplXT1cInBhZ2UubGFzdC50b1N0cmluZygpLmxlbmd0aFwiIFt2YWx1ZV09XCJwYWdlLmN1cnJlbnRcIlxuICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cInVwZGF0ZUN1cnJlbnRQYWdlKCRldmVudClcIiAoYmx1cik9XCJ1cGRhdGVDdXJyZW50UGFnZSgkZXZlbnQpXCIvPiZuYnNwOy8mbmJzcDs8c3Bhbj57e3BhZ2UubGFzdH19PC9zcGFuPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cInBhZ2luYXRpb24tbmV4dFwiIFtkaXNhYmxlZF09XCJwYWdlLmN1cnJlbnQgPj0gcGFnZS5sYXN0XCIgKGNsaWNrKT1cInBhZ2UuY3VycmVudCA9IHBhZ2UuY3VycmVudCArIDFcIj5cbiAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiYW5nbGUgcmlnaHRcIj48L2Nsci1pY29uPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwicGFnaW5hdGlvbi1sYXN0XCIgW2Rpc2FibGVkXT1cInBhZ2UuY3VycmVudCA+PSBwYWdlLmxhc3RcIiAoY2xpY2spPVwicGFnZS5jdXJyZW50ID0gcGFnZS5sYXN0XCI+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInN0ZXAtZm9yd2FyZC0yIHVwXCI+PC9jbHItaWNvbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5wYWdpbmF0aW9uXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFBhZ2luYXRpb24gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIEBDb250ZW50Q2hpbGQoQ2xyRGF0YWdyaWRQYWdlU2l6ZSkgX3BhZ2VTaXplQ29tcG9uZW50OiBDbHJEYXRhZ3JpZFBhZ2VTaXplO1xuICBAVmlld0NoaWxkKCdjdXJyZW50UGFnZUlucHV0JykgY3VycmVudFBhZ2VJbnB1dFJlZjogRWxlbWVudFJlZjtcblxuICBwcml2YXRlIGRlZmF1bHRTaXplID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZTogUGFnZSkge31cblxuICAvKioqKioqKioqKlxuICAgKiBTdWJzY3JpcHRpb24gdG8gdGhlIFBhZ2Ugc2VydmljZSBmb3IgcGFnZSBjaGFuZ2VzLlxuICAgKiBOb3RlOiB0aGlzIG9ubHkgZW1pdHMgYWZ0ZXIgdGhlIGRhdGFncmlkIGlzIGluaXRpYWxpemVkL3N0YWJhbGl6ZWQgYW5kIHRoZSBwYWdlIGNoYW5nZXMuXG4gICAqL1xuICBuZ09uSW5pdCgpIHtcbiAgICAvKlxuICAgICAqIERlZmF1bHQgcGFnZSBzaXplIGlzIDEwLlxuICAgICAqIFRoZSByZWFzb24gd2Ugc2V0IGl0IGluIHRoaXMgY29uc3RydWN0b3IgYW5kIG5vdCBpbiB0aGUgcHJvdmlkZXIgaXRzZWxmIGlzIGJlY2F1c2VcbiAgICAgKiB3ZSBkb24ndCB3YW50IHBhZ2luYXRpb24gKHBhZ2Ugc2l6ZSAwKSBpZiB0aGlzIGNvbXBvbmVudCBpc24ndCBwcmVzZW50IGluIHRoZSBkYXRhZ3JpZC5cbiAgICAgKi9cbiAgICBpZiAodGhpcy5kZWZhdWx0U2l6ZSkge1xuICAgICAgdGhpcy5wYWdlLnNpemUgPSAxMDtcbiAgICB9XG4gICAgdGhpcy5fcGFnZVN1YnNjcmlwdGlvbiA9IHRoaXMucGFnZS5jaGFuZ2Uuc3Vic2NyaWJlKGN1cnJlbnQgPT4gdGhpcy5jdXJyZW50Q2hhbmdlZC5lbWl0KGN1cnJlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpcHRpb24gdG8gdGhlIHBhZ2Ugc2VydmljZSBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9wYWdlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5wYWdlLnJlc2V0UGFnZVNpemUoKTtcbiAgICBpZiAodGhpcy5fcGFnZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5fcGFnZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYWdlIHNpemVcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFnZVNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLnNpemU7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnUGFnZVNpemUnKVxuICBwdWJsaWMgc2V0IHBhZ2VTaXplKHNpemU6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuZGVmYXVsdFNpemUgPSBmYWxzZTtcbiAgICAgIHRoaXMucGFnZS5zaXplID0gc2l6ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG90YWwgaXRlbXMgKG5lZWRlZCB0byBndWVzcyB0aGUgbGFzdCBwYWdlKVxuICAgKi9cbiAgcHVibGljIGdldCB0b3RhbEl0ZW1zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS50b3RhbEl0ZW1zO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1RvdGFsSXRlbXMnKVxuICBwdWJsaWMgc2V0IHRvdGFsSXRlbXModG90YWw6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgdG90YWwgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhZ2UudG90YWxJdGVtcyA9IHRvdGFsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMYXN0IHBhZ2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbGFzdFBhZ2UoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmxhc3Q7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnTGFzdFBhZ2UnKVxuICBwdWJsaWMgc2V0IGxhc3RQYWdlKGxhc3Q6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFnZS5sYXN0ID0gbGFzdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCBwYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5jdXJyZW50O1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1BhZ2UnKVxuICBwdWJsaWMgc2V0IGN1cnJlbnRQYWdlKHBhZ2U6IG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgcGFnZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucGFnZS5jdXJyZW50ID0gcGFnZTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ1BhZ2VDaGFuZ2UnKSBjdXJyZW50Q2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRvIHRoZSBwcmV2aW91cyBwYWdlIGlmIGl0IGV4aXN0c1xuICAgKi9cbiAgcHVibGljIHByZXZpb3VzKCkge1xuICAgIHRoaXMucGFnZS5wcmV2aW91cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRvIHRoZSBuZXh0IHBhZ2UgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgbmV4dCgpIHtcbiAgICB0aGlzLnBhZ2UubmV4dCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCBwYWdlLCBzdGFydGluZyBhdCAwXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpcnN0SXRlbSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2UuZmlyc3RJdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHBhZ2UsIHN0YXJ0aW5nIGF0IDBcbiAgICovXG4gIHB1YmxpYyBnZXQgbGFzdEl0ZW0oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmxhc3RJdGVtO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgYWRkcyBwYWdlIG51bWJlcnMgYmVmb3JlIGFuZCBhZnRlciB0aGUgY3VycmVudCBwYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1pZGRsZVBhZ2VzKCk6IG51bWJlcltdIHtcbiAgICBjb25zdCBtaWRkbGVQYWdlczogbnVtYmVyW10gPSBbXTtcbiAgICBpZiAodGhpcy5wYWdlLmN1cnJlbnQgPiAxKSB7XG4gICAgICBtaWRkbGVQYWdlcy5wdXNoKHRoaXMucGFnZS5jdXJyZW50IC0gMSk7XG4gICAgfVxuICAgIG1pZGRsZVBhZ2VzLnB1c2godGhpcy5wYWdlLmN1cnJlbnQpO1xuICAgIGlmICh0aGlzLnBhZ2UuY3VycmVudCA8IHRoaXMucGFnZS5sYXN0KSB7XG4gICAgICBtaWRkbGVQYWdlcy5wdXNoKHRoaXMucGFnZS5jdXJyZW50ICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBtaWRkbGVQYWdlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBvbmx5IHVwZGF0ZSB0aGUgcGFnaW5hdGlvbidzIGN1cnJlbnQgcGFnZSBvbiBibHVyIG9mIHRoZSBpbnB1dCBmaWVsZCwgb3JcbiAgICogd2hlbiB0aGV5IHByZXNzIGVudGVyLlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUN1cnJlbnRQYWdlKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChldmVudC50YXJnZXQudmFsdWUsIDEwKTtcblxuICAgIC8vIGlmIHRoZSBpbnB1dCB2YWx1ZSwgaXMgbm90IGEgbnVtYmVyLCB3ZSBkb24ndCB1cGRhdGUgdGhlIHBhZ2VcbiAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgIGlmIChwYXJzZWQgPCAxKSB7XG4gICAgICAgIHRoaXMucGFnZS5jdXJyZW50ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAocGFyc2VkID4gdGhpcy5wYWdlLmxhc3QpIHtcbiAgICAgICAgdGhpcy5wYWdlLmN1cnJlbnQgPSB0aGlzLnBhZ2UubGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFnZS5jdXJyZW50ID0gcGFyc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW5wdXQncyB2YWx1ZSB0byB0aGUgbmV3IGN1cnJlbnQgcGFnZS4gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgY29kZVxuICAgICAqIGFib3ZlIG1heSBoYXZlIGNoYW5nZWQgdGhlIHZhbHVlIGZyb20gd2hhdCB0aGUgdXNlciBlbnRlcmVkIGluLlxuICAgICAqL1xuICAgIHRoaXMuY3VycmVudFBhZ2VJbnB1dFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5wYWdlLmN1cnJlbnQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBFeHBhbmQgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvcHJvdmlkZXJzL2V4cGFuZCc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ2VsbCB9IGZyb20gJy4vZGF0YWdyaWQtY2VsbCc7XG5pbXBvcnQgeyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgfSBmcm9tICcuL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbCc7XG5pbXBvcnQgeyBFeHBhbmRhYmxlUm93c0NvdW50IH0gZnJvbSAnLi9wcm92aWRlcnMvZ2xvYmFsLWV4cGFuZGFibGUtcm93cyc7XG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBSb3dBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcm93LWFjdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4vcHJvdmlkZXJzL3NlbGVjdGlvbic7XG5cbi8qKlxuICogR2VuZXJpYyBibGFuZCBjb250YWluZXIgc2VydmluZyB2YXJpb3VzIHB1cnBvc2VzIGZvciBEYXRhZ3JpZC5cbiAqIEZvciBpbnN0YW5jZSwgaXQgY2FuIGhlbHAgc3BhbiBhIHRleHQgb3ZlciBtdWx0aXBsZSByb3dzIGluIGRldGFpbCB2aWV3LlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcm93LWRldGFpbCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhcmVwbGFjZWRSb3dcIj5cbiAgICAgICAgICAgIDwhLS0gc3BhY2UgZm9yIG11bHRpc2VsZWN0aW9uIHN0YXRlIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNlbGwgZGF0YWdyaWQtc2VsZWN0IGRhdGFncmlkLWZpeGVkLWNvbHVtblwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJzZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuTXVsdGlcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBzcGFjZSBmb3Igc2luZ2xlIHNlbGVjdGlvbiBzdGF0ZSAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1jZWxsIGRhdGFncmlkLXNlbGVjdCBkYXRhZ3JpZC1maXhlZC1jb2x1bW5cIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwic2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNFTEVDVElPTl9UWVBFLlNpbmdsZVwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8IS0tIHNwYWNlIGZvciBzaW5nbGUgcm93IGFjdGlvbjsgb25seSBkaXNwbGF5VHlwZSBpZiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBhY3Rpb25hYmxlIHJvdyBpbiBkYXRhZ3JpZCAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1jZWxsIGRhdGFncmlkLXJvdy1hY3Rpb25zIGRhdGFncmlkLWZpeGVkLWNvbHVtblwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJyb3dBY3Rpb25TZXJ2aWNlLmhhc0FjdGlvbmFibGVSb3dcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBzcGFjZSBmb3IgZXhwYW5kYWJsZSBjYXJldCBhY3Rpb247IG9ubHkgZGlzcGxheVR5cGUgaWYgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgZXhwYW5kYWJsZSByb3cgaW4gZGF0YWdyaWQgLS0+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiZXhwYW5kYWJsZVJvd3MuaGFzRXhwYW5kYWJsZVJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImRhdGFncmlkLWV4cGFuZGFibGUtY2FyZXQgZGF0YWdyaWQtZml4ZWQtY29sdW1uIGRhdGFncmlkLWNlbGxcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLXJvdy1mbGV4XSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLXJvdy1kZXRhaWxdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuZGF0YWdyaWQtY29udGFpbmVyXSc6ICdjZWxscy5sZW5ndGggPT09IDAnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFJvd0RldGFpbDxUID0gYW55PiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIC8qIHJlZmVyZW5jZSB0byB0aGUgZW51bSBzbyB0aGF0IHRlbXBsYXRlIGNhbiBhY2Nlc3MgaXQgKi9cbiAgcHVibGljIFNFTEVDVElPTl9UWVBFID0gU2VsZWN0aW9uVHlwZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgc2VsZWN0aW9uOiBTZWxlY3Rpb24sXG4gICAgcHVibGljIHJvd0FjdGlvblNlcnZpY2U6IFJvd0FjdGlvblNlcnZpY2UsXG4gICAgcHVibGljIGV4cGFuZDogRXhwYW5kLFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwdWJsaWMgZXhwYW5kYWJsZVJvd3M6IEV4cGFuZGFibGVSb3dzQ291bnRcbiAgKSB7fVxuXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRDZWxsKSBjZWxsczogUXVlcnlMaXN0PENsckRhdGFncmlkQ2VsbD47XG5cbiAgQElucHV0KCdjbHJEZ1JlcGxhY2UnKVxuICBzZXQgcmVwbGFjZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZXhwYW5kLnNldFJlcGxhY2UoISF2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHB1YmxpYyByZXBsYWNlZFJvdyA9IGZhbHNlO1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICBjb25zdCBjb2x1bW5zTGlzdCA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbnMoKTtcbiAgICB0aGlzLnVwZGF0ZUNlbGxzRm9yQ29sdW1ucyhjb2x1bW5zTGlzdCk7XG5cbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgQ2VsbHMgbGlzdCBjaGFuZ2VzIHBlciByb3ctcmVuZGVyZXJcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY2VsbHMuY2hhbmdlcy5zdWJzY3JpYmUoY2VsbExpc3QgPT4ge1xuICAgICAgICBjb25zdCBjb2x1bW5MaXN0ID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpO1xuICAgICAgICBpZiAoY2VsbExpc3QubGVuZ3RoID09PSBjb2x1bW5MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBVc2VkIHRvIHNldCB0aGluZ3MgdXAgdGhlIGZpcnN0IHRpbWUgYnV0IG9ubHkgYWZ0ZXIgYWxsIHRoZSBjb2x1bW5zIGFyZSByZWFkeS5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNvbHVtbkxpc3QgPT4ge1xuICAgICAgICAvLyBQcmV2ZW50cyBjZWxsIHVwZGF0ZXMgd2hlbiBjb2xzIGFuZCBjZWxscyBhcnJheSBhcmUgbm90IGFsaWduZWRcbiAgICAgICAgaWYgKGNvbHVtbkxpc3QubGVuZ3RoID09PSB0aGlzLmNlbGxzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZXhwYW5kLnJlcGxhY2Uuc3Vic2NyaWJlKHJlcGxhY2VDaGFuZ2UgPT4ge1xuICAgICAgICB0aGlzLnJlcGxhY2VkUm93ID0gcmVwbGFjZUNoYW5nZTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdDogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10pIHtcbiAgICB0aGlzLmNlbGxzLmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50Q29sdW1uID0gY29sdW1uTGlzdFtpbmRleF07IC8vIEFjY291bnRzIGZvciBudWxsIHNwYWNlLlxuICAgICAgaWYgKGN1cnJlbnRDb2x1bW4pIHtcbiAgICAgICAgY2VsbC5pZCA9IGN1cnJlbnRDb2x1bW4uaWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBjb25zdCBOT19MQVlPVVRfQ0xBU1MgPSAnZGF0YWdyaWQtbm8tbGF5b3V0JztcbmV4cG9ydCBjb25zdCBDT01QVVRFX1dJRFRIX0NMQVNTID0gJ2RhdGFncmlkLWNvbXB1dGluZy1jb2x1bW5zLXdpZHRoJztcbmV4cG9ydCBjb25zdCBTVFJJQ1RfV0lEVEhfQ0xBU1MgPSAnZGF0YWdyaWQtZml4ZWQtd2lkdGgnO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuXG5pbXBvcnQgeyBTVFJJQ1RfV0lEVEhfQ0xBU1MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyLW9yZ2FuaXplcic7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1jZWxsJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkQ2VsbFJlbmRlcmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBvcmdhbml6ZXIuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkNMRUFSX1dJRFRIUykuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xlYXJXaWR0aCgpKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyV2lkdGgoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFNUUklDVF9XSURUSF9DTEFTUyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIG51bGwpO1xuICB9XG5cbiAgcHVibGljIHNldFdpZHRoKHN0cmljdDogYm9vbGVhbiwgdmFsdWU6IG51bWJlcikge1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCBTVFJJQ1RfV0lEVEhfQ0xBU1MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIHZhbHVlICsgJ3B4Jyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEcmFnRGlzcGF0Y2hlciB9IGZyb20gJy4uL3Byb3ZpZGVycy9kcmFnLWRpc3BhdGNoZXInO1xuaW1wb3J0IHsgVGFibGVTaXplU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy90YWJsZS1zaXplLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuL3JlbmRlci1vcmdhbml6ZXInO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uJywgcHJvdmlkZXJzOiBbRHJhZ0Rpc3BhdGNoZXJdIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRDb2x1bW5SZXNpemVyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIsXG4gICAgcHJpdmF0ZSBkcmFnRGlzcGF0Y2hlcjogRHJhZ0Rpc3BhdGNoZXIsXG4gICAgcHJpdmF0ZSB0YWJsZTogVGFibGVTaXplU2VydmljZVxuICApIHtcbiAgICB0aGlzLmNvbHVtbkVsID0gZWwubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIGNvbHVtbkVsOiBhbnk7XG4gIGNvbHVtblJlY3RXaWR0aDogbnVtYmVyO1xuICBjb2x1bW5SZXNpemVCeTogbnVtYmVyID0gMDtcblxuICBoYW5kbGVUcmFja2VyRWw6IEVsZW1lbnRSZWY7XG5cbiAgcGFnZVN0YXJ0UG9zaXRpb25YOiBudW1iZXI7XG4gIGRyYWdEaXN0YW5jZVBvc2l0aW9uWDogbnVtYmVyOyAvLyByZWxhdGl2ZSB0byBwYWdlU3RhcnRQb3NpdGlvblxuXG4gIGRyYWdXaXRoaW5NaW5XaWR0aDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbHVtbk1pbldpZHRoOiBudW1iZXI7XG5cbiAgQE91dHB1dCgnY2xyRGdDb2x1bW5SZXNpemUnKSByZXNpemVFbWl0dGVyOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5kcmFnRGlzcGF0Y2hlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5oYW5kbGVUcmFja2VyRWwgPSB0aGlzLmRyYWdEaXNwYXRjaGVyLmhhbmRsZVRyYWNrZXJSZWYubmF0aXZlRWxlbWVudDtcbiAgICB0aGlzLmRyYWdEaXNwYXRjaGVyLmFkZERyYWdMaXN0ZW5lcigpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuZHJhZ0Rpc3BhdGNoZXIub25EcmFnU3RhcnQuc3Vic2NyaWJlKCgpID0+IHRoaXMuZHJhZ1N0YXJ0SGFuZGxlcigpKSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy5kcmFnRGlzcGF0Y2hlci5vbkRyYWdNb3ZlLnN1YnNjcmliZSgkZXZlbnQgPT4gdGhpcy5kcmFnTW92ZUhhbmRsZXIoJGV2ZW50KSkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuZHJhZ0Rpc3BhdGNoZXIub25EcmFnRW5kLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyYWdFbmRIYW5kbGVyKCkpKTtcbiAgfVxuXG4gIGRyYWdTdGFydEhhbmRsZXIoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNvbHVtbk1pbldpZHRoKSB7XG4gICAgICAvLyBzZXRzIHRoZSBtaW4gd2lkdGggb25seSBvbiB0aGUgdmVyeSBmaXJzdCBkcmFnIGF0dGVtcHRcbiAgICAgIHRoaXMuY29sdW1uTWluV2lkdGggPSB0aGlzLmRvbUFkYXB0ZXIubWluV2lkdGgodGhpcy5jb2x1bW5FbCk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5oYW5kbGVUcmFja2VyRWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmhhbmRsZVRyYWNrZXJFbCwgJ2hlaWdodCcsIHRoaXMudGFibGUuZ2V0Q29sdW1uRHJhZ0hlaWdodCgpKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGRvY3VtZW50LmJvZHksICdjdXJzb3InLCAnY29sLXJlc2l6ZScpO1xuICAgIHRoaXMuZHJhZ0Rpc3RhbmNlUG9zaXRpb25YID0gMDtcbiAgICB0aGlzLmNvbHVtblJlY3RXaWR0aCA9IHRoaXMuZG9tQWRhcHRlci5jbGllbnRSZWN0KHRoaXMuY29sdW1uRWwpLndpZHRoO1xuICAgIHRoaXMucGFnZVN0YXJ0UG9zaXRpb25YID0gdGhpcy5kb21BZGFwdGVyLmNsaWVudFJlY3QodGhpcy5jb2x1bW5FbCkucmlnaHQ7XG4gIH1cblxuICBkcmFnTW92ZUhhbmRsZXIobW92ZUV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBwYWdlTW92ZVBvc2l0aW9uID0gbW92ZUV2ZW50LnBhZ2VYIHx8IG1vdmVFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWDtcbiAgICB0aGlzLmRyYWdEaXN0YW5jZVBvc2l0aW9uWCA9IHRoaXMuZ2V0UG9zaXRpb25XaXRoaW5NYXgocGFnZU1vdmVQb3NpdGlvbiAtIHRoaXMucGFnZVN0YXJ0UG9zaXRpb25YKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuaGFuZGxlVHJhY2tlckVsLCAncmlnaHQnLCAtMSAqIHRoaXMuZHJhZ0Rpc3RhbmNlUG9zaXRpb25YICsgJ3B4Jyk7XG4gIH1cblxuICBkcmFnRW5kSGFuZGxlcigpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuaGFuZGxlVHJhY2tlckVsLCAncmlnaHQnLCAnMHB4Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmhhbmRsZVRyYWNrZXJFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgJ2N1cnNvcicsICdhdXRvJyk7XG5cbiAgICBpZiAodGhpcy5kcmFnRGlzdGFuY2VQb3NpdGlvblgpIHtcbiAgICAgIHRoaXMuY29sdW1uUmVzaXplQnkgPSB0aGlzLmRyYWdEaXN0YW5jZVBvc2l0aW9uWDtcblxuICAgICAgdGhpcy5yZXNpemVFbWl0dGVyLmVtaXQodGhpcy5jb2x1bW5SZWN0V2lkdGggKyB0aGlzLmNvbHVtblJlc2l6ZUJ5KTtcbiAgICAgIHRoaXMub3JnYW5pemVyLnJlc2l6ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldFBvc2l0aW9uV2l0aGluTWF4KGRyYWdnZWREaXN0YW5jZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoZHJhZ2dlZERpc3RhbmNlIDwgMCkge1xuICAgICAgaWYgKE1hdGguYWJzKGRyYWdnZWREaXN0YW5jZSkgPCB0aGlzLmNvbHVtblJlY3RXaWR0aCAtIHRoaXMuY29sdW1uTWluV2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1dpdGhpbk1pbldpZHRoKSB7XG4gICAgICAgICAgdGhpcy5kcmFnV2l0aGluTWluV2lkdGggPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuaGFuZGxlVHJhY2tlckVsLCAnZXhjZWVkZWQtbWF4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRyYWdnZWREaXN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnV2l0aGluTWluV2lkdGgpIHtcbiAgICAgICAgICB0aGlzLmRyYWdXaXRoaW5NaW5XaWR0aCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmhhbmRsZVRyYWNrZXJFbCwgJ2V4Y2VlZGVkLW1heCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbk1pbldpZHRoIC0gdGhpcy5jb2x1bW5SZWN0V2lkdGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmRyYWdXaXRoaW5NaW5XaWR0aCkge1xuICAgICAgICB0aGlzLmRyYWdXaXRoaW5NaW5XaWR0aCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuaGFuZGxlVHJhY2tlckVsLCAnZXhjZWVkZWQtbWF4Jyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkcmFnZ2VkRGlzdGFuY2U7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5cbmltcG9ydCB7IERhdGFncmlkQ29sdW1uUmVzaXplciB9IGZyb20gJy4vY29sdW1uLXJlc2l6ZXInO1xuaW1wb3J0IHsgU1RSSUNUX1dJRFRIX0NMQVNTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi9yZW5kZXItb3JnYW5pemVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbicgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZEhlYWRlclJlbmRlcmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyLFxuICAgIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcixcbiAgICBwcml2YXRlIGNvbHVtblJlc2l6ZXI6IERhdGFncmlkQ29sdW1uUmVzaXplclxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMub3JnYW5pemVyLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5DTEVBUl9XSURUSFMpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsZWFyV2lkdGgoKSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5vcmdhbml6ZXJcbiAgICAgICAgLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5ERVRFQ1RfU1RSSUNUX1dJRFRIUylcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRldGVjdFN0cmljdFdpZHRoKCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBoYXMgYSBzdHJpY3Qgd2lkdGgsIHNvIGl0IGRvZXNuJ3Qgc2hyaW5rIG9yIGV4cGFuZCBiYXNlZCBvbiB0aGUgY29udGVudC5cbiAgICovXG4gIHB1YmxpYyBzdHJpY3RXaWR0aDogbnVtYmVyO1xuICBwcml2YXRlIHdpZHRoU2V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBjbGVhcldpZHRoKCkge1xuICAgIC8vIHJlbW92ZSB0aGUgd2lkdGggb25seSBpZiB3ZSBzZXQgaXQsIGFuZCBpdCBpcyBub3QgY2hhbmdlZCBieSBkcmFnZ2luZy5cbiAgICBpZiAodGhpcy53aWR0aFNldCAmJiAhdGhpcy5jb2x1bW5SZXNpemVyLmNvbHVtblJlc2l6ZUJ5KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXRlY3RTdHJpY3RXaWR0aCgpIHtcbiAgICBpZiAodGhpcy5jb2x1bW5SZXNpemVyLmNvbHVtblJlc2l6ZUJ5KSB7XG4gICAgICB0aGlzLnN0cmljdFdpZHRoID0gdGhpcy5jb2x1bW5SZXNpemVyLmNvbHVtblJlY3RXaWR0aCArIHRoaXMuY29sdW1uUmVzaXplci5jb2x1bW5SZXNpemVCeTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdHJpY3RXaWR0aCA9IHRoaXMuZG9tQWRhcHRlci51c2VyRGVmaW5lZFdpZHRoKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGNvbXB1dGVXaWR0aCgpOiBudW1iZXIge1xuICAgIGxldCB3aWR0aDogbnVtYmVyID0gdGhpcy5zdHJpY3RXaWR0aDtcbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMuZG9tQWRhcHRlci5zY3JvbGxXaWR0aCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBwdWJsaWMgc2V0V2lkdGgod2lkdGg6IG51bWJlcikge1xuICAgIGlmICh0aGlzLnN0cmljdFdpZHRoKSB7XG4gICAgICBpZiAodGhpcy5jb2x1bW5SZXNpemVyLmNvbHVtblJlc2l6ZUJ5KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCB3aWR0aCArICdweCcpO1xuICAgICAgICB0aGlzLmNvbHVtblJlc2l6ZXIuY29sdW1uUmVzaXplQnkgPSAwO1xuICAgICAgICB0aGlzLndpZHRoU2V0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBEb24ndCBzZXQgd2lkdGggaWYgdGhlcmUgaXMgYSB1c2VyLWRlZmluZWQgb25lLiBKdXN0IGFkZCB0aGUgc3RyaWN0IHdpZHRoIGNsYXNzLlxuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFNUUklDVF9XSURUSF9DTEFTUyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCBTVFJJQ1RfV0lEVEhfQ0xBU1MpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCB3aWR0aCArICdweCcpO1xuICAgIHRoaXMud2lkdGhTZXQgPSB0cnVlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qXG4gKiBUaGlzIHZlcnNpb24gb2YgdGhlIERvbUFkYXB0ZXIgaXMgZm9yIHVzZSBvbiBub24tYnJvd3NlciBwbGF0Zm9ybXMsIHdoZXJlIHRoZXJlIGFyZSBub1xuICogbmF0aXZlRWxlbWVudHMgdG8gdXNlIGZvciBjYWxjdWxhdGlvbnMuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5vb3BEb21BZGFwdGVyIGltcGxlbWVudHMgRG9tQWRhcHRlciB7XG4gIHVzZXJEZWZpbmVkV2lkdGgoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHNjcm9sbEJhcldpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgc2Nyb2xsV2lkdGgoZWxlbWVudDogYW55KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb21wdXRlZEhlaWdodChlbGVtZW50OiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY2xpZW50UmVjdChlbGVtZW50OiBhbnkpOiBDbGllbnRSZWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgfTtcbiAgfVxuXG4gIG1pbldpZHRoKGVsZW1lbnQ6IGFueSk6IG51bWJlciB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmb2N1cyhlbGVtZW50OiBhbnkpOiB2b2lkIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdDaGVja2VkLFxuICBBZnRlclZpZXdJbml0LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgT25EZXN0cm95LFxuICBQTEFURk9STV9JRCxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uIH0gZnJvbSAnLi4vZGF0YWdyaWQtY29sdW1uJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuaW1wb3J0IHsgSXRlbXMgfSBmcm9tICcuLi9wcm92aWRlcnMvaXRlbXMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9wYWdlJztcbmltcG9ydCB7IFRhYmxlU2l6ZVNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvdGFibGUtc2l6ZS5zZXJ2aWNlJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGFncmlkSGVhZGVyUmVuZGVyZXIgfSBmcm9tICcuL2hlYWRlci1yZW5kZXJlcic7XG5pbXBvcnQgeyBOb29wRG9tQWRhcHRlciB9IGZyb20gJy4vbm9vcC1kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyLW9yZ2FuaXplcic7XG5cbi8vIEZpeGVzIGJ1aWxkIGVycm9yXG4vLyBAZHluYW1pYyAoaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTk2OTgjaXNzdWVjb21tZW50LTMzODM0MDIxMSlcbmV4cG9ydCBjb25zdCBkb21BZGFwdGVyRmFjdG9yeSA9IChwbGF0Zm9ybUlkOiBPYmplY3QpID0+IHtcbiAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpKSB7XG4gICAgcmV0dXJuIG5ldyBEb21BZGFwdGVyKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBOb29wRG9tQWRhcHRlcigpO1xuICB9XG59O1xuXG4vLyBGaXhlcyBidWlsZCBlcnJvclxuLy8gQGR5bmFtaWMgKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE5Njk4I2lzc3VlY29tbWVudC0zMzgzNDAyMTEpXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdjbHItZGF0YWdyaWQnLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IERvbUFkYXB0ZXIsIHVzZUZhY3Rvcnk6IGRvbUFkYXB0ZXJGYWN0b3J5LCBkZXBzOiBbUExBVEZPUk1fSURdIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZE1haW5SZW5kZXJlcjxUID0gYW55PiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBwcml2YXRlIGl0ZW1zOiBJdGVtcyxcbiAgICBwcml2YXRlIHBhZ2U6IFBhZ2UsXG4gICAgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgdGFibGVTaXplU2VydmljZTogVGFibGVTaXplU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMub3JnYW5pemVyXG4gICAgICAgIC5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuQ09NUFVURV9DT0xVTU5fV0lEVEhTKVxuICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY29tcHV0ZUhlYWRlcnNXaWR0aCgpKVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucGFnZS5zaXplQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9oZWlnaHRTZXQpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0RGF0YWdyaWRIZWlnaHQoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuaXRlbXMuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiAodGhpcy5zaG91bGRTdGFiaWxpemVDb2x1bW5zID0gdHJ1ZSkpKTtcbiAgfVxuXG4gIEBDb250ZW50Q2hpbGRyZW4oRGF0YWdyaWRIZWFkZXJSZW5kZXJlcikgcHVibGljIGhlYWRlcnM6IFF1ZXJ5TGlzdDxEYXRhZ3JpZEhlYWRlclJlbmRlcmVyPjtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJEYXRhZ3JpZENvbHVtbikgcHVibGljIGNvbHVtbnM6IFF1ZXJ5TGlzdDxDbHJEYXRhZ3JpZENvbHVtbj47XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5oZWFkZXJzLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgLy8gVE9ETzogb25seSByZS1zdGFiaWxpemUgaWYgYSBjb2x1bW4gd2FzIGFkZGVkIG9yIHJlbW92ZWQuIFJlb3JkZXJpbmcgaXMgZmluZS5cbiAgICAgICAgdGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFiaWxpemVDb2x1bW5zKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGFuZCBzZXQgVGFibGUgd2lkdGggZm9yIGhvcml6b250YWwgc2Nyb2xsaW5nIGhlcmUuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICB0aGlzLnRhYmxlU2l6ZVNlcnZpY2UudGFibGUgPSB0aGlzLmVsO1xuICB9XG5cbiAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgIGlmICh0aGlzLnNob3VsZFN0YWJpbGl6ZUNvbHVtbnMpIHtcbiAgICAgIHRoaXMuc3RhYmlsaXplQ29sdW1ucygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRDb21wdXRlSGVpZ2h0KCkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbXB1dGVEYXRhZ3JpZEhlaWdodCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaGVpZ2h0U2V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBzaG91bGRDb21wdXRlSGVpZ2h0KCk6IGJvb2xlYW4ge1xuICAgIGlmICghdGhpcy5faGVpZ2h0U2V0ICYmIHRoaXMucGFnZS5zaXplID4gMCkge1xuICAgICAgaWYgKHRoaXMuaXRlbXMuZGlzcGxheWVkLmxlbmd0aCA9PT0gdGhpcy5wYWdlLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBkYXRhZ3JpZC5cbiAgICpcbiAgICogTk9URTogV2UgaGFkIHRvIGNob29zZSB0byBzZXQgdGhlIGhlaWdodCBpbnN0ZWFkIG9mIHRoZSBtaW4taGVpZ2h0IGJlY2F1c2VcbiAgICogSUUgMTEgcmVxdWlyZXMgdGhlIGhlaWdodCBvbiB0aGUgcGFyZW50IGZvciB0aGUgY2hpbGRyZW4gZmxleCBncm93L3NocmluayBwcm9wZXJ0aWVzIHRvIHdvcmsuXG4gICAqIFdoZW4gd2UgdXNlZCBtaW4taGVpZ2h0LCAxIDEgYXV0byBkb2Vzbid0IHVzZWQgdG8gd29yayBpbiBJRTExIDotKFxuICAgKiBCdXQgdGhpcyBkb2Vzbid0IGFmZmVjdCB0aGUgZml4LiBJdCB3b3JrcyBpbiBib3RoIGZpeGVkICYgdmFyaWFibGUgaGVpZ2h0IGRhdGFncmlkcy5cbiAgICpcbiAgICogUmVmZXI6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjQzOTYyMDUvZmxleC1ncm93LW5vdC13b3JraW5nLWluLWludGVybmV0LWV4cGxvcmVyLTExLTBcbiAgICovXG4gIHByaXZhdGUgY29tcHV0ZURhdGFncmlkSGVpZ2h0KCkge1xuICAgIC8vIElFIGRvZXNuJ3QgcmV0dXJuIGNvcnJlY3QgdmFsdWUgZm9yIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShcImhlaWdodFwiKVxuICAgIGNvbnN0IHZhbHVlOiBudW1iZXIgPSB0aGlzLmRvbUFkYXB0ZXIuY2xpZW50UmVjdCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpLmhlaWdodDtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIHZhbHVlICsgJ3B4Jyk7XG4gICAgdGhpcy5faGVpZ2h0U2V0ID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXREYXRhZ3JpZEhlaWdodCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsICcnKTtcbiAgICB0aGlzLl9oZWlnaHRTZXQgPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGVhY2ggaGVhZGVyIGNvbXB1dGUgaXRzIHdpZHRoLlxuICAgKi9cbiAgcHJpdmF0ZSBjb21wdXRlSGVhZGVyc1dpZHRoKCkge1xuICAgIGNvbnN0IG5iQ29sdW1uczogbnVtYmVyID0gdGhpcy5oZWFkZXJzLmxlbmd0aDtcbiAgICBsZXQgYWxsU3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaCgoaGVhZGVyLCBpbmRleCkgPT4ge1xuICAgICAgLy8gT24gdGhlIGxhc3QgaGVhZGVyIGNvbHVtbiBjaGVjayB3aGV0aGVyIGFsbCBjb2x1bW5zIGhhdmUgc3RyaWN0IHdpZHRocy5cbiAgICAgIC8vIElmIGFsbCBjb2x1bW5zIGhhdmUgc3RyaWN0IHdpZHRocywgcmVtb3ZlIHRoZSBzdHJpY3Qgd2lkdGggZnJvbSB0aGUgbGFzdCBjb2x1bW4gYW5kIG1ha2UgaXQgdGhlIGNvbHVtbidzXG4gICAgICAvLyBtaW5pbXVtIHdpZHRoIHNvIHRoYXQgd2hlbiBhbGwgcHJldmlvdXMgY29sdW1ucyBzaHJpbmssIGl0IHdpbGwgZ2V0IGEgZmxleGlibGUgd2lkdGggYW5kIGNvdmVyIHRoZSBlbXB0eVxuICAgICAgLy8gZ2FwIGluIHRoZSBEYXRhZ3JpZC5cblxuICAgICAgaWYgKCFoZWFkZXIuc3RyaWN0V2lkdGgpIHtcbiAgICAgICAgYWxsU3RyaWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYkNvbHVtbnMgPT09IGluZGV4ICsgMSAmJiBhbGxTdHJpY3QpIHtcbiAgICAgICAgZGVsZXRlIGhlYWRlci5zdHJpY3RXaWR0aDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcmdhbml6ZXIud2lkdGhzW2luZGV4XSA9IHsgcHg6IGhlYWRlci5jb21wdXRlV2lkdGgoKSwgc3RyaWN0OiAhIWhlYWRlci5zdHJpY3RXaWR0aCB9O1xuICAgIH0pO1xuXG4gICAgdGhpcy5oZWFkZXJzLmZvckVhY2goKGhlYWRlciwgaW5kZXgpID0+IGhlYWRlci5zZXRXaWR0aCh0aGlzLm9yZ2FuaXplci53aWR0aHNbaW5kZXhdLnB4KSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHdlIHdhbnQgdG8gcmUtY29tcHV0ZSBjb2x1bW5zIHdpZHRoLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbjpcbiAgICogMSkgV2hlbiBoZWFkZXJzIGNoYW5nZSwgd2l0aCBjb2x1bW5zIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWRcbiAgICogMikgV2hlbiByb3dzIGFyZSBsYXppbHkgbG9hZGVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgKi9cbiAgcHJpdmF0ZSBjb2x1bW5zU2l6ZXNTdGFibGUgPSBmYWxzZTtcblxuICBwcml2YXRlIHNob3VsZFN0YWJpbGl6ZUNvbHVtbnMgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIHdob2xlIHJlLXJlbmRyaW5nIGN5Y2xlIHRvIHNldCBjb2x1bW4gc2l6ZXMsIGlmIG5lZWRlZC5cbiAgICovXG4gIHByaXZhdGUgc3RhYmlsaXplQ29sdW1ucygpIHtcbiAgICB0aGlzLnNob3VsZFN0YWJpbGl6ZUNvbHVtbnMgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc2l6ZSB3aGVuIHRoZSByb3dzIGFyZSBsb2FkZWQuXG4gICAgaWYgKHRoaXMuaXRlbXMuZGlzcGxheWVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMub3JnYW5pemVyLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIE9uRGVzdHJveSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5cbmltcG9ydCB7IERhdGFncmlkQ2VsbFJlbmRlcmVyIH0gZnJvbSAnLi9jZWxsLXJlbmRlcmVyJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi9yZW5kZXItb3JnYW5pemVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRnLXJvdywgY2xyLWRnLXJvdy1kZXRhaWwnIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRSb3dSZW5kZXJlciBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcikge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgb3JnYW5pemVyLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5BTElHTl9DT0xVTU5TKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zZXRXaWR0aHMoKSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgQENvbnRlbnRDaGlsZHJlbihEYXRhZ3JpZENlbGxSZW5kZXJlcikgY2VsbHM6IFF1ZXJ5TGlzdDxEYXRhZ3JpZENlbGxSZW5kZXJlcj47XG5cbiAgcHJpdmF0ZSBzZXRXaWR0aHMoKSB7XG4gICAgaWYgKHRoaXMub3JnYW5pemVyLndpZHRocy5sZW5ndGggIT09IHRoaXMuY2VsbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2VsbHMuZm9yRWFjaCgoY2VsbCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5vcmdhbml6ZXIud2lkdGhzW2luZGV4XTtcbiAgICAgIGNlbGwuc2V0V2lkdGgod2lkdGguc3RyaWN0LCB3aWR0aC5weCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5jZWxscy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnNldFdpZHRocygpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuc2V0V2lkdGhzKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xyRm9ybXNNb2R1bGUgfSBmcm9tICcuLi8uLi9mb3Jtcy9mb3Jtcy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXIubW9kdWxlJztcbmltcG9ydCB7IENscklmRXhwYW5kTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ01vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyT3V0c2lkZUNsaWNrTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvb3V0c2lkZS1jbGljay9vdXRzaWRlLWNsaWNrLm1vZHVsZSc7XG5cbmltcG9ydCB7IERhdGFncmlkUm93RXhwYW5kQW5pbWF0aW9uIH0gZnJvbSAnLi9hbmltYXRpb24taGFjay9yb3ctZXhwYW5kLWFuaW1hdGlvbic7XG5pbXBvcnQgeyBEYXRhZ3JpZFN0cmluZ0ZpbHRlciB9IGZyb20gJy4vYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyJztcbmltcG9ydCB7IEFjdGlvbmFibGVPb21wYUxvb21wYSB9IGZyb20gJy4vY2hvY29sYXRlL2FjdGlvbmFibGUtb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IERhdGFncmlkV2lsbHlXb25rYSB9IGZyb20gJy4vY2hvY29sYXRlL2RhdGFncmlkLXdpbGx5LXdvbmthJztcbmltcG9ydCB7IEV4cGFuZGFibGVPb21wYUxvb21wYSB9IGZyb20gJy4vY2hvY29sYXRlL2V4cGFuZGFibGUtb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IENsckRhdGFncmlkIH0gZnJvbSAnLi9kYXRhZ3JpZCc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEFjdGlvbkJhciB9IGZyb20gJy4vZGF0YWdyaWQtYWN0aW9uLWJhcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEFjdGlvbk92ZXJmbG93IH0gZnJvbSAnLi9kYXRhZ3JpZC1hY3Rpb24tb3ZlcmZsb3cnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDZWxsIH0gZnJvbSAnLi9kYXRhZ3JpZC1jZWxsJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGUgfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtYnV0dG9uJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGUgfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtdGl0bGUnO1xuaW1wb3J0IHsgRGF0YWdyaWREZXRhaWxSZWdpc3RlcmVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1kZXRhaWwtcmVnaXN0ZXJlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlciB9IGZyb20gJy4vZGF0YWdyaWQtZmlsdGVyJztcbmltcG9ydCB7IENsckRhdGFncmlkRm9vdGVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1mb290ZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uJztcbmltcG9ydCB7IENsckRhdGFncmlkSXRlbXMgfSBmcm9tICcuL2RhdGFncmlkLWl0ZW1zJztcbmltcG9ydCB7IENsckRhdGFncmlkSXRlbXNUcmFja0J5IH0gZnJvbSAnLi9kYXRhZ3JpZC1pdGVtcy10cmFja2J5JztcbmltcG9ydCB7IENsckRhdGFncmlkUGFnaW5hdGlvbiB9IGZyb20gJy4vZGF0YWdyaWQtcGFnaW5hdGlvbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFBhZ2VTaXplIH0gZnJvbSAnLi9kYXRhZ3JpZC1wYWdlLXNpemUnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQbGFjZWhvbGRlciB9IGZyb20gJy4vZGF0YWdyaWQtcGxhY2Vob2xkZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRSb3cgfSBmcm9tICcuL2RhdGFncmlkLXJvdyc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFJvd0RldGFpbCB9IGZyb20gJy4vZGF0YWdyaWQtcm93LWRldGFpbCc7XG5pbXBvcnQgeyBEYXRhZ3JpZENlbGxSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL2NlbGwtcmVuZGVyZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRDb2x1bW5SZXNpemVyIH0gZnJvbSAnLi9yZW5kZXIvY29sdW1uLXJlc2l6ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRIZWFkZXJSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL2hlYWRlci1yZW5kZXJlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZE1haW5SZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL21haW4tcmVuZGVyZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRSb3dSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL3Jvdy1yZW5kZXJlcic7XG5pbXBvcnQgeyBXcmFwcGVkQ2VsbCB9IGZyb20gJy4vd3JhcHBlZC1jZWxsJztcbmltcG9ydCB7IFdyYXBwZWRDb2x1bW4gfSBmcm9tICcuL3dyYXBwZWQtY29sdW1uJztcbmltcG9ydCB7IFdyYXBwZWRSb3cgfSBmcm9tICcuL3dyYXBwZWQtcm93JztcblxuZXhwb3J0IGNvbnN0IENMUl9EQVRBR1JJRF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgLy8gQ29yZVxuICBDbHJEYXRhZ3JpZCxcbiAgQ2xyRGF0YWdyaWRBY3Rpb25CYXIsXG4gIENsckRhdGFncmlkQWN0aW9uT3ZlcmZsb3csXG4gIENsckRhdGFncmlkQ29sdW1uLFxuICBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSxcbiAgQ2xyRGF0YWdyaWRIaWRlYWJsZUNvbHVtbixcbiAgQ2xyRGF0YWdyaWRGaWx0ZXIsXG4gIENsckRhdGFncmlkSXRlbXMsXG4gIENsckRhdGFncmlkSXRlbXNUcmFja0J5LFxuICBDbHJEYXRhZ3JpZFJvdyxcbiAgQ2xyRGF0YWdyaWRSb3dEZXRhaWwsXG4gIERhdGFncmlkRGV0YWlsUmVnaXN0ZXJlcixcbiAgQ2xyRGF0YWdyaWRDZWxsLFxuICBDbHJEYXRhZ3JpZEZvb3RlcixcbiAgQ2xyRGF0YWdyaWRQYWdpbmF0aW9uLFxuICBDbHJEYXRhZ3JpZFBhZ2VTaXplLFxuICBDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyLFxuICBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZUJ1dHRvbixcbiAgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVUaXRsZSxcbiAgV3JhcHBlZENlbGwsXG4gIFdyYXBwZWRDb2x1bW4sXG4gIFdyYXBwZWRSb3csXG5cbiAgLy8gUmVuZGVyZXJzXG4gIERhdGFncmlkTWFpblJlbmRlcmVyLFxuICBEYXRhZ3JpZEhlYWRlclJlbmRlcmVyLFxuICBEYXRhZ3JpZENvbHVtblJlc2l6ZXIsXG4gIERhdGFncmlkUm93UmVuZGVyZXIsXG4gIERhdGFncmlkQ2VsbFJlbmRlcmVyLFxuXG4gIC8vIENob2NvbGF0ZVxuICBEYXRhZ3JpZFdpbGx5V29ua2EsXG4gIEFjdGlvbmFibGVPb21wYUxvb21wYSxcbiAgRXhwYW5kYWJsZU9vbXBhTG9vbXBhLFxuXG4gIC8vIEFuaW1hdGlvbiBoYWNrXG4gIERhdGFncmlkUm93RXhwYW5kQW5pbWF0aW9uLFxuXG4gIC8vIEJ1aWx0LWluIHNob3J0Y3V0c1xuICBEYXRhZ3JpZFN0cmluZ0ZpbHRlcixcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgQ2xySWNvbk1vZHVsZSxcbiAgICBDbHJGb3Jtc01vZHVsZSxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBDbHJDb21tb25Qb3BvdmVyTW9kdWxlLFxuICAgIENsckxvYWRpbmdNb2R1bGUsXG4gICAgQ2xyT3V0c2lkZUNsaWNrTW9kdWxlLFxuICBdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfREFUQUdSSURfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfREFUQUdSSURfRElSRUNUSVZFUywgQ2xySWZFeHBhbmRNb2R1bGVdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtXcmFwcGVkQ2VsbCwgV3JhcHBlZENvbHVtbiwgV3JhcHBlZFJvd10sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5wdXQsIE9uSW5pdCwgT3B0aW9uYWwsIE91dHB1dCwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zdGFjay1ibG9jaycsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGR0IGNsYXNzPVwic3RhY2stYmxvY2stbGFiZWxcIlxuICAgICAgICAoY2xpY2spPVwidG9nZ2xlRXhwYW5kKClcIlxuICAgICAgICAoa2V5dXAuZW50ZXIpPVwidG9nZ2xlRXhwYW5kKClcIlxuICAgICAgICAoa2V5dXAuc3BhY2UpPVwidG9nZ2xlRXhwYW5kKClcIlxuICAgICAgICAoZm9jdXMpPVwiZm9jdXNlZCA9IHRydWVcIlxuICAgICAgICAoYmx1cik9XCJmb2N1c2VkID0gZmFsc2VcIlxuICAgICAgICBbYXR0ci5yb2xlXT1cInJvbGVcIlxuICAgICAgICBbYXR0ci50YWJpbmRleF09XCJ0YWJJbmRleFwiXG4gICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiYXJpYUV4cGFuZGVkXCI+XG4gICAgICA8Y2xyLWljb24gc2hhcGU9XCJjYXJldFwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJzdGFjay1ibG9jay1jYXJldFwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJleHBhbmRhYmxlXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5kaXJdPVwiY2FyZXREaXJlY3Rpb25cIlxuICAgICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImNhcmV0VGl0bGVcIj48L2Nsci1pY29uPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXN0YWNrLWxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgIDwvZHQ+XG4gICAgPGRkIGNsYXNzPVwic3RhY2stYmxvY2stY29udGVudFwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGQ+XG4gICAgPCEtLSBGSVhNRTogcmVtb3ZlIHRoaXMgc3RyaW5nIGNvbmNhdGVuYXRpb24gd2hlbiBib29sZWFuIHN0YXRlcyBhcmUgc3VwcG9ydGVkIC0tPlxuICAgIDxkaXYgW0Bjb2xsYXBzZV09XCInJyshZXhwYW5kZWRcIiBjbGFzcz1cInN0YWNrLWNoaWxkcmVuXCIgPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXN0YWNrLWJsb2NrXCI+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICBgLFxuICAvLyBDdXN0b20gZWxlbWVudHMgYXJlIGlubGluZSBieSBkZWZhdWx0XG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfVxuICAgIGAsXG4gIF0sXG4gIC8vIE1ha2Ugc3VyZSB0aGUgaG9zdCBoYXMgdGhlIHByb3BlciBjbGFzcyBmb3Igc3R5bGluZyBwdXJwb3Nlc1xuICBob3N0OiB7ICdbY2xhc3Muc3RhY2stYmxvY2tdJzogJ3RydWUnIH0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdjb2xsYXBzZScsIFtcbiAgICAgIHN0YXRlKCd0cnVlJywgc3R5bGUoeyBoZWlnaHQ6IDAsIGRpc3BsYXk6ICdub25lJyB9KSksXG4gICAgICB0cmFuc2l0aW9uKCd0cnVlID0+IGZhbHNlJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IGhlaWdodDogJyonLCBkaXNwbGF5OiAnKicgfSkpXSksXG4gICAgICB0cmFuc2l0aW9uKCdmYWxzZSA9PiB0cnVlJywgW3N0eWxlKHsgaGVpZ2h0OiAnKicsIGRpc3BsYXk6ICcqJyB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gICAgXSksXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrQmxvY2sgaW1wbGVtZW50cyBPbkluaXQge1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnN0YWNrLWJsb2NrLWV4cGFuZGVkJylcbiAgQElucHV0KCdjbHJTYkV4cGFuZGVkJylcbiAgZXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQE91dHB1dCgnY2xyU2JFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zdGFjay1ibG9jay1leHBhbmRhYmxlJylcbiAgQElucHV0KCdjbHJTYkV4cGFuZGFibGUnKVxuICBleHBhbmRhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9jaGFuZ2VkQ2hpbGRyZW46IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX2Z1bGx5SW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfY2hhbmdlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3RhY2stYmxvY2stY2hhbmdlZCcpXG4gIGdldCBnZXRDaGFuZ2VkVmFsdWUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZWQgfHwgKHRoaXMuX2NoYW5nZWRDaGlsZHJlbiA+IDAgJiYgIXRoaXMuZXhwYW5kZWQpO1xuICB9XG5cbiAgQElucHV0KCdjbHJTYk5vdGlmeUNoYW5nZScpXG4gIHNldCBzZXRDaGFuZ2VkVmFsdWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jaGFuZ2VkID0gdmFsdWU7XG5cbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5fZnVsbHlJbml0aWFsaXplZCkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Ll9jaGFuZ2VkQ2hpbGRyZW4rKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50Ll9jaGFuZ2VkQ2hpbGRyZW4tLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgICAqIFRoaXMgd291bGQgYmUgbW9yZSBlZmZpY2llbnQgd2l0aCBAQ29udGVudENoaWxkcmVuLCB3aXRoIHRoZSBwYXJlbnQgQ2xyU3RhY2tCbG9ja1xuICAgICAqIHF1ZXJ5aW5nIGZvciBjaGlsZHJlbiBTdGFja0Jsb2NrcywgYnV0IHRoaXMgZmVhdHVyZSBpcyBub3QgYXZhaWxhYmxlIHdoZW4gZG93bmdyYWRpbmdcbiAgICAgKiB0aGUgY29tcG9uZW50IGZvciBBbmd1bGFyIDEuXG4gICAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBTa2lwU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBwcml2YXRlIHBhcmVudDogQ2xyU3RhY2tCbG9jayxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuYWRkQ2hpbGQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAvLyBpbiBvcmRlciB0byBhY2Nlc3MgdGhlIHBhcmVudCBDbHJTdGFja0Jsb2NrJ3MgcHJvcGVydGllcyxcbiAgICAvLyB0aGUgY2hpbGQgQ2xyU3RhY2tCbG9jayAgaGFzIHRvIGJlIGZ1bGx5IGluaXRpYWxpemVkIGF0IGZpcnN0LlxuICAgIHRoaXMuX2Z1bGx5SW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgYWRkQ2hpbGQoKTogdm9pZCB7XG4gICAgdGhpcy5leHBhbmRhYmxlID0gdHJ1ZTtcbiAgfVxuXG4gIHRvZ2dsZUV4cGFuZCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5leHBhbmRhYmxlKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmRlZCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNhcmV0RGlyZWN0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kZWQgPyAnZG93bicgOiAncmlnaHQnO1xuICB9XG5cbiAgZ2V0IGNhcmV0VGl0bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/IHRoaXMuY29tbW9uU3RyaW5ncy5jb2xsYXBzZSA6IHRoaXMuY29tbW9uU3RyaW5ncy5leHBhbmQ7XG4gIH1cblxuICBnZXQgcm9sZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGUgPyAnYnV0dG9uJyA6IG51bGw7XG4gIH1cblxuICBnZXQgdGFiSW5kZXgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlID8gJzAnIDogbnVsbDtcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnY2xhc3Mub24tZm9jdXMnKVxuICBnZXQgb25TdGFja0xhYmVsRm9jdXMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZSAmJiAhdGhpcy5leHBhbmRlZCAmJiB0aGlzLmZvY3VzZWQ7XG4gIH1cblxuICBnZXQgYXJpYUV4cGFuZGVkKCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zdGFjay12aWV3JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLXN0YWNrLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICAgICAgPGRsIGNsYXNzPVwic3RhY2stdmlld1wiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L2RsPlxuICAgIGAsXG4gIC8vIEN1c3RvbSBlbGVtZW50cyBhcmUgaW5saW5lIGJ5IGRlZmF1bHQuXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfVxuICAgIGAsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrVmlldyB7XG4gIC8qKlxuICAgKiBVbmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmU6IGlubGluZSBlZGl0aW5nLlxuICAgKi9cbiAgZWRpdGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBAT3V0cHV0KCdjbHJTdGFja1NhdmUnKSBzYXZlOiBFdmVudEVtaXR0ZXI8dm9pZD4gPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KGZhbHNlKTtcblxuICBwcml2YXRlIF9lZGl0TW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGVkaXRpbmdDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIGdldCBlZGl0aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmVkaXRhYmxlICYmIHRoaXMuX2VkaXRNb2RlO1xuICB9XG5cbiAgc2V0IGVkaXRpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5lZGl0YWJsZSkge1xuICAgICAgdGhpcy5fZWRpdE1vZGUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZWRpdGluZ0NoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zYXZlLmVtaXQobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbmQgb2YgdW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlLlxuICAgKi9cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLWhlYWRlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxoNCBjbGFzcz1cInN0YWNrLWhlYWRlclwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGFjay10aXRsZVwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhY2stYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5zdGFjay1hY3Rpb25cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPCEtLSBVbmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmU6IGlubGluZSBlZGl0aW5nLiAtLT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uICpuZ0lmPVwic3RhY2tWaWV3LmVkaXRhYmxlXCIgY2xhc3M9XCJzdGFjay1hY3Rpb24gYnRuIGJ0bi1zbSBidG4tbGlua1wiIFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInN0YWNrVmlldy5lZGl0aW5nID0gIXN0YWNrVmlldy5lZGl0aW5nXCIgdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgRWRpdFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwhLS0gRW5kIG9mIHVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZS4gLS0+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvaDQ+XG4gICAgYCxcbiAgLy8gQ3VzdG9tIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICAgIDpob3N0IHsgZGlzcGxheTogYmxvY2s7IH1cbiAgICBgLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja0hlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdGFja1ZpZXc6IENsclN0YWNrVmlldykge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbi8qKlxuICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAqL1xuXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsclN0YWNrVmlldyB9IGZyb20gJy4vc3RhY2stdmlldyc7XG5cbmV4cG9ydCBjbGFzcyBTdGFja0NvbnRyb2wge1xuICBtb2RlbDogYW55O1xuICBtb2RlbENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzdGFja1ZpZXc6IENsclN0YWNrVmlldykge1xuICAgIC8vIE1ha2UgdGhlIENsclN0YWNrVmlldyBlZGl0YWJsZSwgc2luY2UgaXQgY29udGFpbnMgYSBTdGFja0NvbnRyb2xcbiAgICB0aGlzLnN0YWNrVmlldy5lZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5zdGFja1ZpZXcuZWRpdGluZ0NoYW5nZS5zdWJzY3JpYmUoKGVkaXRpbmc6IGJvb2xlYW4pID0+IHtcbiAgICAgIC8vIEVkaXQgbW9kZSB3YXMgY2xvc2VkXG4gICAgICBpZiAoIWVkaXRpbmcpIHtcbiAgICAgICAgdGhpcy5tb2RlbENoYW5nZS5lbWl0KHRoaXMubW9kZWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG4vKipcbiAqIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuXG4gKlxuICogVE9ETzogc3VwcG9ydCBtb3JlIHR5cGVzIG9mIGlucHV0czogY2hlY2tib3gsIHJhZGlvLCAuLi5cbiAqIFRPRE86IE1pcnJvciBpbnB1dCBhdHRyaWJ1dGVzIGZyb20gdGhlIGhvc3QgdG8gdGhlIGFjdHVhbCBpbnB1dDogc2l6ZSwgbWluLCBtYXgsIHBsYWNlaG9sZGVyLCAuLi5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN0YWNrQ29udHJvbCB9IGZyb20gJy4vc3RhY2stY29udHJvbCc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXcgfSBmcm9tICcuL3N0YWNrLXZpZXcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2staW5wdXQnLFxuICBpbnB1dHM6IFsnbW9kZWw6IGNsck1vZGVsJywgJ3R5cGUnXSxcbiAgb3V0cHV0czogWydtb2RlbENoYW5nZTogY2xyTW9kZWxDaGFuZ2UnXSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhc3RhY2tWaWV3LmVkaXRpbmdcIj57e21vZGVsfX08L3NwYW4+XG4gICAgICAgIDxpbnB1dCBbdHlwZV09XCJ0eXBlXCIgKm5nSWY9XCJzdGFja1ZpZXcuZWRpdGluZ1wiIFsobmdNb2RlbCldPVwibW9kZWxcIi8+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tJbnB1dCBleHRlbmRzIFN0YWNrQ29udHJvbCB7XG4gIHR5cGU6IHN0cmluZyA9ICd0ZXh0JztcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3RhY2tWaWV3OiBDbHJTdGFja1ZpZXcpIHtcbiAgICBzdXBlcihzdGFja1ZpZXcpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG4vKipcbiAqIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuXG4gKlxuICogVE9ETzogT2ZmZXIgYSBhIHdheSB0byBjdXN0b21pemUgdGhlIHZhbHVlIGRpc3BsYXllZCwgcGxhaW4gdmFsdWUgbWF5IGJlIHVucmVhZGFibGUuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdGFja0NvbnRyb2wgfSBmcm9tICcuL3N0YWNrLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLXNlbGVjdCcsXG4gIGlucHV0czogWydtb2RlbDogY2xyTW9kZWwnXSxcbiAgb3V0cHV0czogWydtb2RlbENoYW5nZTogY2xyTW9kZWxDaGFuZ2UnXSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhc3RhY2tWaWV3LmVkaXRpbmdcIj57e21vZGVsfX08L3NwYW4+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWxlY3RcIiAqbmdJZj1cInN0YWNrVmlldy5lZGl0aW5nXCIgPlxuICAgICAgICAgICAgPHNlbGVjdCBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrU2VsZWN0IGV4dGVuZHMgU3RhY2tDb250cm9sIHtcbiAgY29uc3RydWN0b3IocHVibGljIHN0YWNrVmlldzogQ2xyU3RhY2tWaWV3KSB7XG4gICAgc3VwZXIoc3RhY2tWaWV3KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1zdGFjay1sYWJlbCwgY2xyLXN0YWNrLWNvbnRlbnQnIH0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tWaWV3Q3VzdG9tVGFncyB7XG4gIC8vIE5vIGJlaGF2aW9yXG4gIC8vIFRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gXCJkZWNsYXJlXCIgdGhlIHRhZyBpbiBBbmd1bGFyXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsclN0YWNrQmxvY2sgfSBmcm9tICcuL3N0YWNrLWJsb2NrJztcbmltcG9ydCB7IENsclN0YWNrSGVhZGVyIH0gZnJvbSAnLi9zdGFjay1oZWFkZXInO1xuaW1wb3J0IHsgQ2xyU3RhY2tJbnB1dCB9IGZyb20gJy4vc3RhY2staW5wdXQnO1xuaW1wb3J0IHsgQ2xyU3RhY2tTZWxlY3QgfSBmcm9tICcuL3N0YWNrLXNlbGVjdCc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXcgfSBmcm9tICcuL3N0YWNrLXZpZXcnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3Q3VzdG9tVGFncyB9IGZyb20gJy4vc3RhY2stdmlldy1jdXN0b20tdGFncyc7XG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5cbmV4cG9ydCBjb25zdCBDTFJfU1RBQ0tfVklFV19ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyU3RhY2tWaWV3LFxuICBDbHJTdGFja0hlYWRlcixcbiAgQ2xyU3RhY2tCbG9jayxcbiAgQ2xyU3RhY2tWaWV3Q3VzdG9tVGFncyxcbiAgLyoqXG4gICAqIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuXG4gICAqL1xuICBDbHJTdGFja0lucHV0LFxuICBDbHJTdGFja1NlbGVjdCxcbiAgLyoqXG4gICAqIEVuZCBvZiB1bmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmUuXG4gICAqL1xuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgRm9ybXNNb2R1bGUsIENsckljb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfU1RBQ0tfVklFV19ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9TVEFDS19WSUVXX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja1ZpZXdNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxubGV0IE5CX0lOU1RBTkNFUyA9IDA7XG5cbmV4cG9ydCBjb25zdCBVTklRVUVfSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nPignVU5JUVVFX0lEJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVJZEZhY3RvcnkoKSB7XG4gIHJldHVybiAnY2xyLWlkLScgKyBOQl9JTlNUQU5DRVMrKztcbn1cblxuZXhwb3J0IGNvbnN0IFVOSVFVRV9JRF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogVU5JUVVFX0lELFxuICB1c2VGYWN0b3J5OiB1bmlxdWVJZEZhY3RvcnksXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RUcmVlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhcmVudDogQWJzdHJhY3RUcmVlU2VsZWN0aW9uKSB7fVxuXG4gIGFic3RyYWN0IGdldCBjaGlsZHJlbigpOiBBYnN0cmFjdFRyZWVTZWxlY3Rpb25bXTtcblxuICBhYnN0cmFjdCBzZWxlY3RlZENoYW5nZWQoKTogdm9pZDtcbiAgYWJzdHJhY3QgaW5kZXRlcm1pbmF0ZUNoYW5nZWQoKTogdm9pZDtcblxuICBwcml2YXRlIF9zZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9pbmRldGVybWluYXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHVibGljIGdldCBzZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gIH1cblxuICBwdWJsaWMgc2V0IHNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucGFyZW50Q2hhbmdlZCh2YWx1ZSkpO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRDaGFuZ2VkKCk7XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2VkKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGluZGV0ZXJtaW5hdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV0ZXJtaW5hdGU7XG4gIH1cblxuICBwdWJsaWMgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gdmFsdWU7XG4gICAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbiAgY2hpbGRDaGFuZ2VkKCk6IHZvaWQge1xuICAgIGxldCBvbmVTZWxlY3RlZENoaWxkID0gZmFsc2U7XG4gICAgY29uc3QgcHJldmlvdXNTZWxlY3RlZFZhbHVlOiBib29sZWFuID0gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgY29uc3QgcHJldmlvdXNJbmRldGVybWluYXRlVmFsdWU6IGJvb2xlYW4gPSB0aGlzLl9pbmRldGVybWluYXRlO1xuICAgIHRoaXMuX3NlbGVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9pbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZC5pbmRldGVybWluYXRlKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5zZWxlY3RlZCkge1xuICAgICAgICBvbmVTZWxlY3RlZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob25lU2VsZWN0ZWRDaGlsZCkge1xuICAgICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy5wYXJlbnQgJiZcbiAgICAgICh0aGlzLl9zZWxlY3RlZCAhPT0gcHJldmlvdXNTZWxlY3RlZFZhbHVlIHx8IHRoaXMuX2luZGV0ZXJtaW5hdGUgIT09IHByZXZpb3VzSW5kZXRlcm1pbmF0ZVZhbHVlKVxuICAgICkge1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRDaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQgIT09IHByZXZpb3VzU2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmRldGVybWluYXRlICE9PSBwcmV2aW91c0luZGV0ZXJtaW5hdGVWYWx1ZSkge1xuICAgICAgdGhpcy5pbmRldGVybWluYXRlQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG4gIHBhcmVudENoYW5nZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoc2VsZWN0ZWQgJiYgIXRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnBhcmVudENoYW5nZWQodHJ1ZSkpO1xuICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKCFzZWxlY3RlZCAmJiAodGhpcy5zZWxlY3RlZCB8fCB0aGlzLmluZGV0ZXJtaW5hdGUpKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hpbGQucGFyZW50Q2hhbmdlZChmYWxzZSkpO1xuICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZWQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRyZWVTZWxlY3Rpb25TZXJ2aWNlIHtcbiAgc2VsZWN0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBUcmVlU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vdHJlZS1zZWxlY3Rpb24uc2VydmljZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHJUcmVlU2VsZWN0aW9uUHJvdmlkZXJGYWN0b3J5KGV4aXN0aW5nOiBUcmVlU2VsZWN0aW9uU2VydmljZSkge1xuICByZXR1cm4gZXhpc3RpbmcgfHwgbmV3IFRyZWVTZWxlY3Rpb25TZXJ2aWNlKCk7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IGFuaW1hdGUsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFNraXBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuaW1wb3J0IHsgVU5JUVVFX0lELCBVTklRVUVfSURfUFJPVklERVIgfSBmcm9tICcuLi8uLi91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcblxuaW1wb3J0IHsgQWJzdHJhY3RUcmVlU2VsZWN0aW9uIH0gZnJvbSAnLi9hYnN0cmFjdC10cmVlLXNlbGVjdGlvbic7XG5pbXBvcnQgeyBjbHJUcmVlU2VsZWN0aW9uUHJvdmlkZXJGYWN0b3J5IH0gZnJvbSAnLi9wcm92aWRlcnMvdHJlZS1zZWxlY3Rpb24ucHJvdmlkZXInO1xuaW1wb3J0IHsgVHJlZVNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90cmVlLXNlbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10cmVlLW5vZGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vdHJlZS1ub2RlLmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICBFeHBhbmQsXG4gICAgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBFeHBhbmQgfSxcbiAgICB7XG4gICAgICBwcm92aWRlOiBUcmVlU2VsZWN0aW9uU2VydmljZSxcbiAgICAgIHVzZUZhY3Rvcnk6IGNsclRyZWVTZWxlY3Rpb25Qcm92aWRlckZhY3RvcnksXG4gICAgICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgVHJlZVNlbGVjdGlvblNlcnZpY2VdXSxcbiAgICB9LFxuICAgIFVOSVFVRV9JRF9QUk9WSURFUixcbiAgXSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ2NoaWxkTm9kZXNTdGF0ZScsIFtcbiAgICAgIHN0YXRlKCdleHBhbmRlZCcsIHN0eWxlKHsgaGVpZ2h0OiAnKicsICdvdmVyZmxvdy15JzogJ2hpZGRlbicgfSkpLFxuICAgICAgc3RhdGUoJ2NvbGxhcHNlZCcsIHN0eWxlKHsgaGVpZ2h0OiAwLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nIH0pKSxcbiAgICAgIHRyYW5zaXRpb24oJ2V4cGFuZGVkIDw9PiBjb2xsYXBzZWQnLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0JykpLFxuICAgIF0pLFxuICBdLFxuICBob3N0OiB7ICdbY2xhc3MuY2xyLXRyZWUtbm9kZV0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZU5vZGUgZXh0ZW5kcyBBYnN0cmFjdFRyZWVTZWxlY3Rpb24gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbm9kZUV4cGFuZDogRXhwYW5kLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQFNraXBTZWxmKClcbiAgICBwdWJsaWMgcGFyZW50OiBDbHJUcmVlTm9kZSxcbiAgICBwdWJsaWMgdHJlZVNlbGVjdGlvblNlcnZpY2U6IFRyZWVTZWxlY3Rpb25TZXJ2aWNlLFxuICAgIEBJbmplY3QoVU5JUVVFX0lEKSBwdWJsaWMgbm9kZUlkOiBzdHJpbmcsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NoaWxkcmVuOiBDbHJUcmVlTm9kZVtdID0gW107XG5cbiAgZ2V0IGNoaWxkcmVuKCk6IENsclRyZWVOb2RlW10ge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgfVxuXG4gIC8qIFJlZ2lzdHJhdGlvbiAqL1xuXG4gIGNoZWNrSWZDaGlsZE5vZGVSZWdpc3RlcmVkKG5vZGU6IENsclRyZWVOb2RlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uaW5kZXhPZihub2RlKSA+IC0xO1xuICB9XG5cbiAgLy8gVE9ETzogVGhpcyBzaG91bGQgaWRlYWxseSBiZSBpbiBBYnN0cmFjdFRyZWVTZWxlY3Rpb25cbiAgLy8gVHJpZWQgZG9pbmcgdGhpcyBidXQgcmFuIGludG8gc29tZSBpc3N1ZXMgYW5kIGFsc28gcmFuIG91dCBvZiB0aW1lLlxuICAvLyBXaWxsIGdldCB0aGlzIGRvbmUgbGF0ZXIuXG4gIHJlZ2lzdGVyKG5vZGU6IENsclRyZWVOb2RlKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNoZWNrSWZDaGlsZE5vZGVSZWdpc3RlcmVkKG5vZGUpKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICBpZiAodGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgbm9kZS5wYXJlbnRDaGFuZ2VkKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogVGhpcyBzaG91bGQgaWRlYWxseSBiZSBpbiBBYnN0cmFjdFRyZWVTZWxlY3Rpb25cbiAgLy8gVHJpZWQgZG9pbmcgdGhpcyBidXQgcmFuIGludG8gc29tZSBpc3N1ZXMgYW5kIGFsc28gcmFuIG91dCBvZiB0aW1lLlxuICAvLyBXaWxsIGdldCB0aGlzIGRvbmUgbGF0ZXIuXG4gIHVucmVnaXN0ZXIobm9kZTogQ2xyVHJlZU5vZGUpOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qIFNlbGVjdGlvbiAqL1xuXG4gIGFjdGl2YXRlU2VsZWN0aW9uKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyZWVTZWxlY3Rpb25TZXJ2aWNlICYmICF0aGlzLnRyZWVTZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGFibGUpIHtcbiAgICAgIHRoaXMudHJlZVNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0YWJsZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCdjbHJTZWxlY3RlZCcpXG4gIHB1YmxpYyBzZXQgbm9kZVNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgLy8gcmVxdWlyZWQgZm9yIHJlY3Vyc2l2ZSB0cmVlcyB0byBkaXNjYXJkIHVuc2V0IGlucHV0cy5cbiAgICB0aGlzLmFjdGl2YXRlU2VsZWN0aW9uKCk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyU2VsZWN0ZWRDaGFuZ2UnKSBub2RlU2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4odHJ1ZSk7XG5cbiAgc2VsZWN0ZWRDaGFuZ2VkKCk6IHZvaWQge1xuICAgIHRoaXMubm9kZVNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZCk7XG4gIH1cblxuICBnZXQgc2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50cmVlU2VsZWN0aW9uU2VydmljZSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJlZVNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0YWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgQElucHV0KCdjbHJJbmRldGVybWluYXRlJylcbiAgc2V0IG5vZGVJbmRldGVybWluYXRlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5pbmRldGVybWluYXRlID0gdmFsdWU7XG4gICAgdGhpcy5hY3RpdmF0ZVNlbGVjdGlvbigpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xySW5kZXRlcm1pbmF0ZUNoYW5nZScpIG5vZGVJbmRldGVybWluYXRlQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBpbmRldGVybWluYXRlQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICB0aGlzLm5vZGVJbmRldGVybWluYXRlQ2hhbmdlZC5lbWl0KHRoaXMuaW5kZXRlcm1pbmF0ZSk7XG4gIH1cblxuICAvKiBFeHBhbnNpb24gKi9cblxuICB0b2dnbGVFeHBhbmQoKTogdm9pZCB7XG4gICAgdGhpcy5ub2RlRXhwYW5kLmV4cGFuZGVkID0gIXRoaXMubm9kZUV4cGFuZC5leHBhbmRlZDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY2FyZXREaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlRXhwYW5kLmV4cGFuZGVkID8gJ2Rvd24nIDogJ3JpZ2h0JztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY2FyZXRUaXRsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGVFeHBhbmQuZXhwYW5kZWQgPyB0aGlzLmNvbW1vblN0cmluZ3MuY29sbGFwc2UgOiB0aGlzLmNvbW1vblN0cmluZ3MuZXhwYW5kO1xuICB9XG5cbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5vZGVFeHBhbmQuZXhwYW5kZWQ7XG4gIH1cblxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMubm9kZUV4cGFuZC5leHBhbmRlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMubm9kZUV4cGFuZC5leHBhbmRlZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzdGF0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGVkICYmICF0aGlzLm5vZGVFeHBhbmQubG9hZGluZyA/ICdleHBhbmRlZCcgOiAnY29sbGFwc2VkJztcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgZ2V0IHRyZWVOb2RlUm9sZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA/ICd0cmVlaXRlbScgOiAndHJlZSc7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1tdWx0aXNlbGVjdGFibGUnKVxuICBnZXQgcm9vdEFyaWFNdWx0aVNlbGVjdGFibGUoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMucGFyZW50IHx8ICF0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1zZWxlY3RlZCcpXG4gIGdldCBhcmlhU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0YWJsZSA/IHRoaXMuc2VsZWN0ZWQgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGFyaWFUcmVlTm9kZUNoaWxkcmVuUm9sZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyAnZ3JvdXAnIDogbnVsbDtcbiAgfVxuXG4gIC8qIExpZmVjeWNsZSAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnVucmVnaXN0ZXIodGhpcyk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vLi4vZm9ybXMvZm9ybXMubW9kdWxlJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENscklmRXhwYW5kTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVHJlZU5vZGUgfSBmcm9tICcuL3RyZWUtbm9kZSc7XG5cbmV4cG9ydCBjb25zdCBDTFJfVFJFRV9WSUVXX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsclRyZWVOb2RlXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgRm9ybXNNb2R1bGUsIENsckZvcm1zTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX1RSRUVfVklFV19ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9UUkVFX1ZJRVdfRElSRUNUSVZFUywgQ2xySWZFeHBhbmRNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUcmVlVmlld01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRNb2R1bGUgfSBmcm9tICcuL2RhdGFncmlkL2RhdGFncmlkLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXdNb2R1bGUgfSBmcm9tICcuL3N0YWNrLXZpZXcvc3RhY2stdmlldy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVHJlZVZpZXdNb2R1bGUgfSBmcm9tICcuL3RyZWUtdmlldy90cmVlLXZpZXcubW9kdWxlJztcblxuQE5nTW9kdWxlKHsgZXhwb3J0czogW0NsckRhdGFncmlkTW9kdWxlLCBDbHJTdGFja1ZpZXdNb2R1bGUsIENsclRyZWVWaWV3TW9kdWxlXSB9KVxuZXhwb3J0IGNsYXNzIENsckRhdGFNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERyYWdFdmVudEludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5cbi8vIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBjb252ZXJ0IGFuIGludGVybmFsIGV2ZW50XG4vLyB0byBhbiBleHRlcm5hbCBldmVudCB0byBiZSBlbWl0dGVkLlxuZXhwb3J0IGNsYXNzIENsckRyYWdFdmVudDxUPiB7XG4gIHB1YmxpYyBkcmFnUG9zaXRpb246IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuICBwdWJsaWMgZ3JvdXA6IHN0cmluZyB8IHN0cmluZ1tdO1xuICBwdWJsaWMgZHJhZ0RhdGFUcmFuc2ZlcjogVDtcbiAgcHVibGljIGRyb3BQb2ludFBvc2l0aW9uOiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfTtcblxuICBjb25zdHJ1Y3RvcihkcmFnRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikge1xuICAgIHRoaXMuZHJhZ1Bvc2l0aW9uID0gZHJhZ0V2ZW50LmRyYWdQb3NpdGlvbjtcbiAgICB0aGlzLmdyb3VwID0gZHJhZ0V2ZW50Lmdyb3VwO1xuICAgIHRoaXMuZHJhZ0RhdGFUcmFuc2ZlciA9IGRyYWdFdmVudC5kcmFnRGF0YVRyYW5zZmVyO1xuICAgIHRoaXMuZHJvcFBvaW50UG9zaXRpb24gPSBkcmFnRXZlbnQuZHJvcFBvaW50UG9zaXRpb247XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmV4cG9ydCBlbnVtIERyYWdFdmVudFR5cGUge1xuICBEUkFHX1NUQVJULFxuICBEUkFHX01PVkUsXG4gIERSQUdfRU5ELFxuICBEUkFHX0VOVEVSLFxuICBEUkFHX0xFQVZFLFxuICBEUk9QLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYWdFdmVudEludGVyZmFjZTxUPiB7XG4gIHR5cGU6IERyYWdFdmVudFR5cGU7XG4gIGdyb3VwPzogc3RyaW5nIHwgc3RyaW5nW107XG4gIGdob3N0RWxlbWVudD86IGFueTtcbiAgZHJhZ1Bvc2l0aW9uOiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfTtcbiAgZHJhZ0RhdGFUcmFuc2Zlcj86IFQ7XG4gIC8vIEZvciBkZWZhdWx0IGdob3N0cywgdGhpcyBkcm9wUG9pbnRQb3NpdGlvbiBkZW5vdGVzIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGdob3N0IGVsZW1lbnQuXG4gIC8vIFRoaXMgY2VudGVyIHBvaW50IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdob3N0IGlzIG92ZXIgZHJvcHBhYmxlIGVsZW1lbnRzIG9yIG5vdC5cbiAgZHJvcFBvaW50UG9zaXRpb24/OiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4ge1xuICBwcml2YXRlIGRyYWdTdGFydDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyYWdNb3ZlOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ0VuZDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyb3A6IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiA9IG5ldyBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4oKTtcblxuICBnZXQgZHJhZ1N0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ01vdmVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ01vdmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ0VuZGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBkcm9wcGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGJyb2FkY2FzdChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19TVEFSVDpcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQubmV4dChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEcmFnRXZlbnRUeXBlLkRSQUdfTU9WRTpcbiAgICAgICAgdGhpcy5kcmFnTW92ZS5uZXh0KGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19FTkQ6XG4gICAgICAgIHRoaXMuZHJhZ0VuZC5uZXh0KGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJPUDpcbiAgICAgICAgdGhpcy5kcm9wLm5leHQoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBEcmFnQW5kRHJvcEV2ZW50QnVzU2VydmljZSB9IGZyb20gJy4vZHJhZy1hbmQtZHJvcC1ldmVudC1idXMuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD4ge1xuICBwcml2YXRlIGRyYWdnYWJsZUVsOiBhbnk7XG5cbiAgLy8gY29udGFpbnMgdGhlIHN0YXJ0aW5nIGV2ZW50cyBzdWNoIGFzIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydFxuICBwcml2YXRlIGxpc3RlbmVyczogKCgpID0+IHZvaWQpW107XG4gIC8vIGNvbnRhaW5zIHRoZSBuZXN0ZWQgZXZlbnRzIHRoYXQgaGFwcGVucyBhZnRlci9pbnNpZGUgdGhlIHN0YXJ0aW5nIGV2ZW50c1xuICAvLyBzdWNoIGFzIHNlbGVjdHN0YXJ0LCBtb3VzZW1vdmUvdG91Y2htb3ZlLCBtb3VzZXVwL3RvdWNoZW5kXG4gIHByaXZhdGUgbmVzdGVkTGlzdGVuZXJzOiAoKCkgPT4gdm9pZClbXTtcblxuICBwcml2YXRlIGRyYWdTdGFydDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyYWdNb3ZlOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ0VuZDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuXG4gIHByaXZhdGUgaGFzRHJhZ1N0YXJ0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgZHJhZ1N0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ01vdmVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ01vdmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ0VuZGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBldmVudEJ1czogRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4pIHt9XG5cbiAgLy8gRHJhZ2dhYmxlIGNvbXBvbmVudCBzZXRzIHRoZXNlIHByb3BlcnRpZXM6XG4gIHB1YmxpYyBkcmFnRGF0YVRyYW5zZmVyPzogVDtcbiAgcHVibGljIGdyb3VwPzogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgLy8gRHJhZ2dhYmxlR2hvc3QgY29tcG9uZW50IHNldHMgdGhlc2UgcHJvcGVydGllczpcbiAgcHVibGljIGdob3N0RWxlbWVudD86IGFueTtcbiAgcHVibGljIGRyb3BQb2ludFBvc2l0aW9uPzogeyBwYWdlWDogbnVtYmVyOyBwYWdlWTogbnVtYmVyIH07XG5cbiAgcHVibGljIGF0dGFjaERyYWdMaXN0ZW5lcnMoZHJhZ2dhYmxlRWw6IE5vZGUpIHtcbiAgICB0aGlzLmRyYWdnYWJsZUVsID0gZHJhZ2dhYmxlRWw7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXG4gICAgICB0aGlzLmN1c3RvbURyYWdFdmVudCh0aGlzLmRyYWdnYWJsZUVsLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJyksXG4gICAgICB0aGlzLmN1c3RvbURyYWdFdmVudCh0aGlzLmRyYWdnYWJsZUVsLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnKSxcbiAgICBdO1xuICB9XG5cbiAgcHVibGljIGRldGFjaERyYWdMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5tYXAoZXZlbnQgPT4gZXZlbnQoKSk7XG4gICAgfVxuXG4gICAgLy8gSW4gbW9zdCBjYXNlcywgb25jZSB1c2VycyBzdGFydCBkcmFnZ2luZyB3aXRoIG1vdXNlZG93bi90b3VjaHN0YXJ0IGV2ZW50cyxcbiAgICAvLyB0aGV5IHdpbGwgZW5kIGRyYWdnaW5nIGF0IG9uZSBwb2ludCB3aXRoIG1vdXNldXAvdG91Y2hlbmQuXG4gICAgLy8gSG93ZXZlciwgdGhlcmUgbWlnaHQgYmUgYSBmZXcgY2FzZXMgd2hlcmUgbW91c2Vkb3duL3RvdWNoc3RhcnQgZXZlbnRzIGdldCByZWdpc3RlcmVkLFxuICAgIC8vIGJ1dCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgZ2V0cyByZW1vdmVkIGJlZm9yZSB1c2VyIGVuZHMgZHJhZ2dpbmcuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYXR0YWNoZWQgbGlzdGVuZXJzIHRoYXQgaGFwcGVuZWQgZHVyaW5nIHRoZSBtb3VzZWRvd24vdG91Y2hzdGFydCBldmVudHMuXG4gICAgaWYgKHRoaXMubmVzdGVkTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLm5lc3RlZExpc3RlbmVycy5tYXAoZXZlbnQgPT4gZXZlbnQoKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjdXN0b21EcmFnRXZlbnQoZWxlbWVudDogTm9kZSwgc3RhcnRPbkV2ZW50OiBzdHJpbmcsIG1vdmVPbkV2ZW50OiBzdHJpbmcsIGVuZE9uRXZlbnQ6IHN0cmluZyk6ICgpID0+IHZvaWQge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RlbihlbGVtZW50LCBzdGFydE9uRXZlbnQsICgpID0+IHtcbiAgICAgIC8vIEluaXRpYWxpemUgbmVzdGVkIGxpc3RlbmVycycgcHJvcGVydHkgd2l0aCBhIG5ldyBlbXB0eSBhcnJheTtcbiAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzID0gW107XG5cbiAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGRpc2FibGUgc2VsZWN0aW9uIGR1cmluZyBkcmFnZ2luZyAoZXNwZWNpYWxseSBpbiBFREdFL0lFMTEpLlxuICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMucHVzaChcbiAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgJ3NlbGVjdHN0YXJ0JywgKHNlbGVjdEV2ZW50OiBFdmVudCkgPT4ge1xuICAgICAgICAgIHNlbGVjdEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgc2VsZWN0RXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBMaXN0ZW4gdG8gbW91c2Vtb3ZlL3RvdWNobW92ZSBldmVudHMgb3V0c2lkZSBvZiBhbmd1bGFyIHpvbmUuXG4gICAgICB0aGlzLm5lc3RlZExpc3RlbmVycy5wdXNoKFxuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsIG1vdmVPbkV2ZW50LCAobW92ZUV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkgaXMgbmVlZGVkIGhlcmUgdG8gcHJldmVudCBuZXN0ZWQgZHJhZ2dhYmxlcyBmcm9tIGdldHRpbmcgZHJhZ2dlZFxuICAgICAgICAgICAgLy8gYWx0b2dldGhlci4gV2Ugc2hvdWxkbid0IHVzZSBFdmVudC5zdG9wUHJvcGFnYXRpb24oKSBoZXJlIGFzIHdlIGFyZSBsaXN0ZW5pbmcgdG8gdGhlIGV2ZW50c1xuICAgICAgICAgICAgLy8gb24gdGhlIGdsb2JhbCBlbGVtZW50IGxldmVsLlxuXG4gICAgICAgICAgICAvLyBXaXRoIEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBpdCByZWdpc3RlcnMgdGhlIGV2ZW50cyBzZW50IGZyb20gdGhlIGlubmVyIG1vc3QgZHJhZ2dhYmxlXG4gICAgICAgICAgICAvLyBmaXJzdC4gVGhlbiBpbW1lZGlhdGVseSBhZnRlciB0aGF0LCBpdCBzdG9wcyBsaXN0ZW5pbmcgdG8gdGhlIHNhbWUgdHlwZSBvZiBldmVudHMgb24gdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIGVsZW1lbnQuIFNvIHRoaXMgd2lsbCBoZWxwIHVzIHRvIG5vdCByZWdpc3RlciB0aGUgc2FtZSBldmVudHMgdGhhdCB3b3VsZCBjb21lIGZyb20gdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gbGV2ZWwgZHJhZ2dhYmxlcyBldmVudHVhbGx5LlxuXG4gICAgICAgICAgICBtb3ZlRXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNEcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICB0aGlzLmhhc0RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gRmlyZSBcImRyYWdzdGFydFwiXG4gICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0KG1vdmVFdmVudCwgRHJhZ0V2ZW50VHlwZS5EUkFHX1NUQVJUKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZpcmUgXCJkcmFnbW92ZVwiXG4gICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0KG1vdmVFdmVudCwgRHJhZ0V2ZW50VHlwZS5EUkFHX01PVkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gTGlzdGVuIHRvIG1vdXNldXAvdG91Y2hlbmQgZXZlbnRzLlxuICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMucHVzaChcbiAgICAgICAgdGhpcy5yZW5kZXJlci5saXN0ZW4oJ2RvY3VtZW50JywgZW5kT25FdmVudCwgKGVuZEV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmhhc0RyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAvLyBGaXJlIFwiZHJhZ2VuZFwiIG9ubHkgaWYgZHJhZ3N0YXJ0IGlzIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIHRoaXMuaGFzRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0KGVuZEV2ZW50LCBEcmFnRXZlbnRUeXBlLkRSQUdfRU5EKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXZSBtdXN0IHJlbW92ZSB0aGUgdGhlIG5lc3RlZCBsaXN0ZW5lcnMgZXZlcnkgdGltZSBkcmFnIGNvbXBsZXRlcy5cbiAgICAgICAgICBpZiAodGhpcy5uZXN0ZWRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzLm1hcChldmVudCA9PiBldmVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBicm9hZGNhc3QoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCBldmVudFR5cGU6IERyYWdFdmVudFR5cGUpOiB2b2lkIHtcbiAgICBjb25zdCBkcmFnRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPiA9IHRoaXMuZ2VuZXJhdGVEcmFnRXZlbnQoZXZlbnQsIGV2ZW50VHlwZSk7XG5cbiAgICBzd2l0Y2ggKGRyYWdFdmVudC50eXBlKSB7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19TVEFSVDpcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQubmV4dChkcmFnRXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRHJhZ0V2ZW50VHlwZS5EUkFHX01PVkU6XG4gICAgICAgIHRoaXMuZHJhZ01vdmUubmV4dChkcmFnRXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRHJhZ0V2ZW50VHlwZS5EUkFHX0VORDpcbiAgICAgICAgdGhpcy5kcmFnRW5kLm5leHQoZHJhZ0V2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHNldCBhZnRlciB0aGV5IGFyZSBicm9hZGNhc3RlZCB0byB0aGUgRHJhZ2dhYmxlR2hvc3QgY29tcG9uZW50LlxuICAgIGRyYWdFdmVudC5naG9zdEVsZW1lbnQgPSB0aGlzLmdob3N0RWxlbWVudDtcbiAgICBkcmFnRXZlbnQuZHJvcFBvaW50UG9zaXRpb24gPSB0aGlzLmRyb3BQb2ludFBvc2l0aW9uO1xuXG4gICAgdGhpcy5ldmVudEJ1cy5icm9hZGNhc3QoZHJhZ0V2ZW50KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVEcmFnRXZlbnQoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCBldmVudFR5cGU6IERyYWdFdmVudFR5cGUpOiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4ge1xuICAgIGxldCBuYXRpdmVFdmVudDogYW55O1xuXG4gICAgaWYgKCg8VG91Y2hFdmVudD5ldmVudCkuaGFzT3duUHJvcGVydHkoJ2NoYW5nZWRUb3VjaGVzJykpIHtcbiAgICAgIG5hdGl2ZUV2ZW50ID0gKDxUb3VjaEV2ZW50PmV2ZW50KS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmF0aXZlRXZlbnQgPSBldmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgZHJhZ1Bvc2l0aW9uOiB7IHBhZ2VYOiBuYXRpdmVFdmVudC5wYWdlWCwgcGFnZVk6IG5hdGl2ZUV2ZW50LnBhZ2VZIH0sXG4gICAgICBncm91cDogdGhpcy5ncm91cCxcbiAgICAgIGRyYWdEYXRhVHJhbnNmZXI6IHRoaXMuZHJhZ0RhdGFUcmFuc2ZlcixcbiAgICAgIGdob3N0RWxlbWVudDogdGhpcy5naG9zdEVsZW1lbnQsXG4gICAgfTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IERyYWdFdmVudEludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UnO1xuXG4vLyBUaGlzIHNlcnZpY2UgaXMgdXNlZCB0byBjYXB0dXJlIHRoZSBzdGF0ZSBvZiBjbHJEcmFnZ2FibGUgZWxlbWVudFxuLy8gYXQgYSBjZXJ0YWluIGV2ZW50IGFuZCBwYXNzZXMgaXQgdG8gY2xyRHJhZ2dhYmxlR2hvc3QgY29tcG9uZW50LlxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERyYWdnYWJsZVNuYXBzaG90U2VydmljZTxUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcikge31cblxuICBwcml2YXRlIGRyYWdnYWJsZUVsQ2xpZW50UmVjdDogQ2xpZW50UmVjdDtcbiAgcHJpdmF0ZSBzbmFwc2hvdERyYWdFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+O1xuXG4gIHB1YmxpYyBjYXB0dXJlKGVsOiBOb2RlLCBldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgdGhpcy5kcmFnZ2FibGVFbENsaWVudFJlY3QgPSB0aGlzLmRvbUFkYXB0ZXIuY2xpZW50UmVjdChlbCk7XG4gICAgdGhpcy5zbmFwc2hvdERyYWdFdmVudCA9IGV2ZW50O1xuICB9XG4gIHB1YmxpYyBkaXNjYXJkKCk6IHZvaWQge1xuICAgIGRlbGV0ZSB0aGlzLmRyYWdnYWJsZUVsQ2xpZW50UmVjdDtcbiAgICBkZWxldGUgdGhpcy5zbmFwc2hvdERyYWdFdmVudDtcbiAgfVxuICBnZXQgaGFzRHJhZ2dhYmxlU3RhdGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5zbmFwc2hvdERyYWdFdmVudCAmJiAhIXRoaXMuZHJhZ2dhYmxlRWxDbGllbnRSZWN0O1xuICB9XG4gIGdldCBjbGllbnRSZWN0KCk6IENsaWVudFJlY3Qge1xuICAgIHJldHVybiB0aGlzLmRyYWdnYWJsZUVsQ2xpZW50UmVjdDtcbiAgfVxuICBnZXQgZHJhZ0V2ZW50KCk6IERyYWdFdmVudEludGVyZmFjZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuc25hcHNob3REcmFnRXZlbnQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBOZ1pvbmUsIE9uRGVzdHJveSwgT3B0aW9uYWwsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERyYWdFdmVudEludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kcmFnLWV2ZW50LWxpc3RlbmVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlU25hcHNob3RTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJhZ2dhYmxlLXNuYXBzaG90LnNlcnZpY2UnO1xuXG50eXBlIFBhZ2VQb3NpdGlvbiA9IHtcbiAgcGFnZVg6IG51bWJlcjtcbiAgcGFnZVk6IG51bWJlcjtcbn07XG50eXBlIE9mZnNldFBvc2l0aW9uID0ge1xuICB0b3A6IG51bWJlcjtcbiAgbGVmdDogbnVtYmVyO1xufTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRyYWdnYWJsZS1naG9zdCcsXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmAsXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdsZWF2ZUFuaW1hdGlvbicsIFtcbiAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgc3R5bGUoeyBsZWZ0OiAnKicsIHRvcDogJyonIH0pLFxuICAgICAgICBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyB0b3A6ICd7e3RvcH19JywgbGVmdDogJ3t7bGVmdH19JyB9KSksXG4gICAgICBdKSxcbiAgICBdKSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ2dhYmxlR2hvc3Q8VD4gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGRyYWdnYWJsZUdob3N0RWw6IGFueTtcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQEhvc3RCaW5kaW5nKCdAbGVhdmVBbmltYXRpb24nKSBsZWF2ZUFuaW1Db25maWcgPSB7IHZhbHVlOiAwLCBwYXJhbXM6IHsgdG9wOiAnMHB4JywgbGVmdDogJzBweCcgfSB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkcmFnRXZlbnRMaXN0ZW5lcjogRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlPFQ+LFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZHJhZ2dhYmxlU25hcHNob3Q6IERyYWdnYWJsZVNuYXBzaG90U2VydmljZTxUPixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZVxuICApIHtcbiAgICBpZiAoIXRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIgfHwgIXRoaXMuZHJhZ2dhYmxlU25hcHNob3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsci1kcmFnZ2FibGUtZ2hvc3QgY29tcG9uZW50IGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyRHJhZ2dhYmxlIGRpcmVjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdnYWJsZUdob3N0RWwgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAvLyBOZWVkIHRvIHVzZSBSZW5kZXJlcjIgYXMgaXQgcnVucyBvdXRzaWRlIG9mIE5nWm9uZVxuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5kcmFnZ2FibGVHaG9zdEVsLCAnZHJhZ2dhYmxlLWdob3N0Jyk7XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgZ2hvc3QgZWxlbWVudCBpbiBEcmFnRXZlbnRMaXN0ZW5lciB0byBwYXNzIGluIGEgQ2xyRHJhZ0V2ZW50LlxuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZ2hvc3RFbGVtZW50ID0gdGhpcy5kcmFnZ2FibGVHaG9zdEVsO1xuXG4gICAgLy8gRGVmYXVsdCBnaG9zdCBzaXplIGdldHMgdGhlIHNpemUgb2YgQ2xyRHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgdGhpcy5zZXREZWZhdWx0R2hvc3RTaXplKHRoaXMuZHJhZ2dhYmxlR2hvc3RFbCk7XG5cbiAgICBjb25zdCBvZmZzZXQ6IE9mZnNldFBvc2l0aW9uID0ge1xuICAgICAgdG9wOiB0aGlzLmRyYWdnYWJsZVNuYXBzaG90Lmhhc0RyYWdnYWJsZVN0YXRlXG4gICAgICAgID8gdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5kcmFnRXZlbnQuZHJhZ1Bvc2l0aW9uLnBhZ2VZIC0gdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LnRvcFxuICAgICAgICA6IDAsXG4gICAgICBsZWZ0OiB0aGlzLmRyYWdnYWJsZVNuYXBzaG90Lmhhc0RyYWdnYWJsZVN0YXRlXG4gICAgICAgID8gdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5kcmFnRXZlbnQuZHJhZ1Bvc2l0aW9uLnBhZ2VYIC0gdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LmxlZnRcbiAgICAgICAgOiAwLFxuICAgIH07XG5cbiAgICBsZXQgaXNBbmltYXRpb25Db25maWd1cmVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ01vdmVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICAvLyBPbiB0aGUgZmlyc3QgZHJhZyBtb3ZlIGV2ZW50LCB3ZSBjb25maWd1cmUgdGhlIGFuaW1hdGlvbiBhcyBpdCdzIGRlcGVuZGVudCBvbiB0aGUgZmlyc3QgZHJhZyBldmVudC5cbiAgICAgICAgaWYgKCFpc0FuaW1hdGlvbkNvbmZpZ3VyZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5oYXNEcmFnZ2FibGVTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlVG9PbkxlYXZlKFxuICAgICAgICAgICAgICBgJHt0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3QudG9wfXB4YCxcbiAgICAgICAgICAgICAgYCR7dGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LmxlZnR9cHhgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGVUb09uTGVhdmUoYCR7ZXZlbnQuZHJhZ1Bvc2l0aW9uLnBhZ2VZfXB4YCwgYCR7ZXZlbnQuZHJhZ1Bvc2l0aW9uLnBhZ2VYfXB4YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzQW5pbWF0aW9uQ29uZmlndXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgZHJhZ2dhYmxlIGdob3N0LlxuICAgICAgICBjb25zdCB0b3BMZWZ0UG9zaXRpb246IFBhZ2VQb3NpdGlvbiA9IHRoaXMuZmluZFRvcExlZnRQb3NpdGlvbihldmVudC5kcmFnUG9zaXRpb24sIG9mZnNldCk7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb25TdHlsZSh0aGlzLmRyYWdnYWJsZUdob3N0RWwsIHRvcExlZnRQb3NpdGlvbi5wYWdlWCwgdG9wTGVmdFBvc2l0aW9uLnBhZ2VZKTtcbiAgICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcm9wUG9pbnRQb3NpdGlvbiA9IHRoaXMuZmluZERyb3BQb2ludFBvc2l0aW9uKHRvcExlZnRQb3NpdGlvbik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHNldERlZmF1bHRHaG9zdFNpemUoZWw6IE5vZGUpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5oYXNEcmFnZ2FibGVTdGF0ZSkge1xuICAgICAgdGhpcy5zZXRTaXplU3R5bGUoZWwsIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC53aWR0aCwgdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LmhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhbmltYXRlVG9PbkxlYXZlKHRvcDogc3RyaW5nLCBsZWZ0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4ge1xuICAgICAgdGhpcy5sZWF2ZUFuaW1Db25maWcgPSB7IHZhbHVlOiAwLCBwYXJhbXM6IHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSB9O1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kVG9wTGVmdFBvc2l0aW9uKGRyYWdQb3NpdGlvbjogUGFnZVBvc2l0aW9uLCBvZmZzZXQ6IE9mZnNldFBvc2l0aW9uKTogUGFnZVBvc2l0aW9uIHtcbiAgICByZXR1cm4geyBwYWdlWDogZHJhZ1Bvc2l0aW9uLnBhZ2VYIC0gb2Zmc2V0LmxlZnQsIHBhZ2VZOiBkcmFnUG9zaXRpb24ucGFnZVkgLSBvZmZzZXQudG9wIH07XG4gIH1cblxuICBwcml2YXRlIGZpbmREcm9wUG9pbnRQb3NpdGlvbih0b3BMZWZ0UG9zaXRpb246IFBhZ2VQb3NpdGlvbik6IFBhZ2VQb3NpdGlvbiB7XG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuaGFzRHJhZ2dhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VYOiB0b3BMZWZ0UG9zaXRpb24ucGFnZVggKyB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3Qud2lkdGggLyAyLFxuICAgICAgICBwYWdlWTogdG9wTGVmdFBvc2l0aW9uLnBhZ2VZICsgdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LmhlaWdodCAvIDIsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9wTGVmdFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0U2l6ZVN0eWxlKGVsOiBOb2RlLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICd3aWR0aCcsIGAke3dpZHRofXB4YCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJ2hlaWdodCcsIGAke2hlaWdodH1weGApO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRQb3NpdGlvblN0eWxlKGVsOiBOb2RlLCBsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJ2xlZnQnLCBgJHtsZWZ0fXB4YCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgJ3RvcCcsIGAke3RvcH1weGApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIE9uRGVzdHJveSwgT3B0aW9uYWwsIFNraXBTZWxmLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERyYWdFdmVudEludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kcmFnLWV2ZW50LWxpc3RlbmVyLnNlcnZpY2UnO1xuXG4vLyBUaGlzIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHdpbGwgYmUgdXNlZCBtYWlubHkgdG9nZXRoZXIgd2l0aCBgY2xyLWRyYWdnYWJsZS1naG9zdGAgZGlyZWN0aXZlIGluc2lkZSBvZiBjbHJEcmFnZ2FibGVcbi8vIGRpcmVjdGl2ZS4gVGhlIGRpcmVjdGl2ZSBpcyByZXNwb25zaWJsZSBmb3IgaW5zdGFudGlhdGluZyBgY2xyLWRyYWdnYWJsZS1naG9zdGAgZGlyZWN0aXZlIG9ubHkgZHVyaW5nIGRyYWdnaW5nIHNvXG4vLyB0aGF0IEFuZ3VsYXIgQ2hhbmdlIERldGVjdGlvbiBpcyBwcmV2ZW50ZWQgZnJvbSBydW5uaW5nIGlmIGEgY29tcG9uZW50IG9yIGRpcmVjdGl2ZSBpcyBwbGFjZWQgaW5zaWRlIG9mIHRoZVxuLy8gYGNsci1kcmFnZ2FibGUtZ2hvc3RgIGRpcmVjdGl2ZS5cblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklmRHJhZ2dlZF0nIH0pXG5leHBvcnQgY2xhc3MgQ2xySWZEcmFnZ2VkPFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIEBPcHRpb25hbCgpXG4gICAgQFNraXBTZWxmKClcbiAgICBwcml2YXRlIGNvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRyYWdFdmVudExpc3RlbmVyOiBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD5cbiAgKSB7XG4gICAgaWYgKCF0aGlzLmRyYWdFdmVudExpc3RlbmVyIHx8ICF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgKmNscklmRHJhZ2dlZCBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHJEcmFnZ2FibGUgZGlyZWN0aXZlLicpO1xuICAgIH1cblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnU3RhcnRlZC5zdWJzY3JpYmUoKGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnRW5kZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERyYWdFdmVudExpc3RlbmVyU2VydmljZSB9IGZyb20gJy4vZHJhZy1ldmVudC1saXN0ZW5lci5zZXJ2aWNlJztcblxuLy8gVGhpcyBwcm92aWRlciByZWdpc3RlcnMgdGhlIGRyYWcgaGFuZGxlIGVsZW1lbnQuXG4vLyBXaGVuIGl0IHJlZ2lzdGVycyBhIGVsZW1lbnQgYXMgYSBkcmFnIGhhbmRsZSwgaXQgYXR0YWNoZXMgdGhhdCBlbGVtZW50IHRvIHRoZSBsaXN0ZW5lcnMgZnJvbSBDbHJEcmFnRXZlbnRMaXN0ZW5lci5cbi8vIEFsc28sIGl0IGFkZHMgdGhlIFwiZHJhZy1oYW5kbGVcIiBjc3MgY2xhc3MgdG8gdGhlIHJlZ2lzdGVyZWQgZWxlbWVudCB0aHJvdWdoIFJlbmRlcmVyLlxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERyYWdIYW5kbGVSZWdpc3RyYXJTZXJ2aWNlPFQ+IHtcbiAgcHJpdmF0ZSBfY3VzdG9tSGFuZGxlRWw6IGFueTtcbiAgcHJpdmF0ZSBfZGVmYXVsdEhhbmRsZUVsOiBhbnk7XG5cbiAgZ2V0IGRlZmF1bHRIYW5kbGVFbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEhhbmRsZUVsO1xuICB9XG5cbiAgc2V0IGRlZmF1bHRIYW5kbGVFbChlbDogTm9kZSkge1xuICAgIHRoaXMuX2RlZmF1bHRIYW5kbGVFbCA9IGVsOyAvLyBkZWZhdWx0SGFuZGxlRWwgd2lsbCBiZSB1c3VhbGx5IHRoZSBjbHJEcmFnZ2FibGUgZWxlbWVudC5cblxuICAgIC8vIElmIHRoZSBjdXN0b21IYW5kbGVFbCBoYXMgYmVlbiByZWdpc3RlcmVkLFxuICAgIC8vIGRvbid0IG1ha2UgdGhlIGRlZmF1bHRIYW5kbGVFbCB0aGUgZHJhZyBoYW5kbGUgeWV0IHVudGlsIHRoZSBjdXN0b21IYW5kbGVFbCBpcyB1bnJlZ2lzdGVyZWQuXG4gICAgaWYgKCF0aGlzLl9jdXN0b21IYW5kbGVFbCkge1xuICAgICAgdGhpcy5tYWtlRWxlbWVudEhhbmRsZSh0aGlzLl9kZWZhdWx0SGFuZGxlRWwpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZHJhZ0V2ZW50TGlzdGVuZXI6IERyYWdFdmVudExpc3RlbmVyU2VydmljZTxUPiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIHByaXZhdGUgbWFrZUVsZW1lbnRIYW5kbGUoZWw6IE5vZGUpIHtcbiAgICBpZiAodGhpcy5fZGVmYXVsdEhhbmRsZUVsICYmIHRoaXMuX2RlZmF1bHRIYW5kbGVFbCAhPT0gZWwpIHtcbiAgICAgIC8vIEJlZm9yZSBtYWtpbmcgYW4gZWxlbWVudCB0aGUgY3VzdG9tIGhhbmRsZSBlbGVtZW50LFxuICAgICAgLy8gd2Ugc2hvdWxkIHJlbW92ZSB0aGUgZXhpc3RpbmcgZHJhZy1oYW5kbGUgY2xhc3MgZnJvbSB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2RlZmF1bHRIYW5kbGVFbCwgJ2RyYWctaGFuZGxlJyk7XG4gICAgfVxuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuYXR0YWNoRHJhZ0xpc3RlbmVycyhlbCk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhlbCwgJ2RyYWctaGFuZGxlJyk7XG4gIH1cblxuICBnZXQgY3VzdG9tSGFuZGxlRWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1c3RvbUhhbmRsZUVsO1xuICB9XG5cbiAgcHVibGljIHJlZ2lzdGVyQ3VzdG9tSGFuZGxlKGVsOiBOb2RlKSB7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kZXRhY2hEcmFnTGlzdGVuZXJzKCk7IC8vIHJlbW92ZXMgdGhlIGV4aXN0aW5nIGxpc3RlbmVyc1xuICAgIHRoaXMuX2N1c3RvbUhhbmRsZUVsID0gZWw7XG4gICAgdGhpcy5tYWtlRWxlbWVudEhhbmRsZSh0aGlzLl9jdXN0b21IYW5kbGVFbCk7XG4gIH1cblxuICBwdWJsaWMgdW5yZWdpc3RlckN1c3RvbUhhbmRsZSgpIHtcbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRldGFjaERyYWdMaXN0ZW5lcnMoKTsgLy8gcmVtb3ZlcyB0aGUgZXhpc3RpbmcgbGlzdGVuZXJzXG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9jdXN0b21IYW5kbGVFbCwgJ2RyYWctaGFuZGxlJyk7XG4gICAgZGVsZXRlIHRoaXMuX2N1c3RvbUhhbmRsZUVsO1xuICAgIC8vIGlmIGRlZmF1bHQgaGFuZGxlIGlzIHNldCwgbWFrZSB0aGF0IGhhbmRsZVxuICAgIGlmICh0aGlzLl9kZWZhdWx0SGFuZGxlRWwpIHtcbiAgICAgIHRoaXMubWFrZUVsZW1lbnRIYW5kbGUodGhpcy5fZGVmYXVsdEhhbmRsZUVsKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vLyBUaGlzIHNlcnZpY2UgY2xhc3MgYWRkcyBhbmQgcmVtb3ZlcyB0aGUgXCJpbi1kcmFnXCIgY2xhc3MgdG8gdGhlIGRvY3VtZW50IGJvZHkgZWxlbWVudFxuLy8gdGhyb3VnaCBpdHMgcHVibGljIGVudGVyKCkgYW5kIGV4aXQoKSBtZXRob2RzLlxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEdsb2JhbERyYWdNb2RlU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBlbnRlcigpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdpbi1kcmFnJyk7XG4gIH1cblxuICBleGl0KCk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2luLWRyYWcnKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50RmFjdG9yeSxcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICBDb250ZW50Q2hpbGQsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgQ2xyRHJhZ0V2ZW50IH0gZnJvbSAnLi4vZHJhZy1ldmVudCc7XG5pbXBvcnQgeyBDbHJEcmFnZ2FibGVHaG9zdCB9IGZyb20gJy4uL2RyYWdnYWJsZS1naG9zdCc7XG5pbXBvcnQgeyBDbHJJZkRyYWdnZWQgfSBmcm9tICcuLi9pZi1kcmFnZ2VkJztcbmltcG9ydCB7IERyYWdFdmVudEludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2RyYWctZXZlbnQtbGlzdGVuZXIuc2VydmljZSc7XG5pbXBvcnQgeyBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9kcmFnLWhhbmRsZS1yZWdpc3RyYXIuc2VydmljZSc7XG5pbXBvcnQgeyBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvZHJhZ2dhYmxlLXNuYXBzaG90LnNlcnZpY2UnO1xuaW1wb3J0IHsgR2xvYmFsRHJhZ01vZGVTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2dsb2JhbC1kcmFnLW1vZGUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJEcmFnZ2FibGVdJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAgRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlLFxuICAgIERyYWdIYW5kbGVSZWdpc3RyYXJTZXJ2aWNlLFxuICAgIERyYWdnYWJsZVNuYXBzaG90U2VydmljZSxcbiAgICBHbG9iYWxEcmFnTW9kZVNlcnZpY2UsXG4gICAgRG9tQWRhcHRlcixcbiAgXSxcbiAgaG9zdDogeyAnW2NsYXNzLmRyYWdnYWJsZV0nOiAndHJ1ZScsICdbY2xhc3MuYmVpbmctZHJhZ2dlZF0nOiAnZHJhZ09uJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcmFnZ2FibGU8VD4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGRyYWdnYWJsZUVsOiBhbnk7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBjb21wb25lbnRGYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PENsckRyYWdnYWJsZUdob3N0PFQ+PjtcbiAgcHVibGljIGRyYWdPbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBkcmFnRXZlbnRMaXN0ZW5lcjogRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgZHJhZ0hhbmRsZVJlZ2lzdHJhcjogRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgY2ZyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBkcmFnZ2FibGVTbmFwc2hvdDogRHJhZ2dhYmxlU25hcHNob3RTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgZ2xvYmFsRHJhZ01vZGU6IEdsb2JhbERyYWdNb2RlU2VydmljZVxuICApIHtcbiAgICB0aGlzLmRyYWdnYWJsZUVsID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5PENsckRyYWdnYWJsZUdob3N0PFQ+PihDbHJEcmFnZ2FibGVHaG9zdCk7XG4gIH1cblxuICBAQ29udGVudENoaWxkKENscklmRHJhZ2dlZCkgY3VzdG9tR2hvc3Q6IENscklmRHJhZ2dlZDxUPjtcblxuICBASW5wdXQoJ2NsckRyYWdnYWJsZScpXG4gIHNldCBkYXRhVHJhbnNmZXIodmFsdWU6IFQpIHtcbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdEYXRhVHJhbnNmZXIgPSB2YWx1ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyR3JvdXAnKVxuICBzZXQgZ3JvdXAodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5ncm91cCA9IHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0R2hvc3QoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikge1xuICAgIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2FwdHVyZSh0aGlzLmRyYWdnYWJsZUVsLCBldmVudCk7XG4gICAgLy8gTk9URTogVGhlIGRlZmF1bHQgZ2hvc3QgZWxlbWVudCB3aWxsIGFwcGVhclxuICAgIC8vIG5leHQgdG8gdGhlIGNsckRyYWdnYWJsZSBpbiB0aGUgRE9NIGFzIGEgc2libGluZyBlbGVtZW50LlxuICAgIHRoaXMudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQodGhpcy5jb21wb25lbnRGYWN0b3J5LCAwLCB0aGlzLmluamVjdG9yLCBbXG4gICAgICBbdGhpcy5kcmFnZ2FibGVFbC5jbG9uZU5vZGUodHJ1ZSldLFxuICAgIF0pO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXN0cm95RGVmYXVsdEdob3N0KCkge1xuICAgIHRoaXMudmlld0NvbnRhaW5lclJlZi5jbGVhcigpO1xuICAgIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuZGlzY2FyZCgpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyRHJhZ1N0YXJ0JykgZHJhZ1N0YXJ0RW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyYWdNb3ZlJykgZHJhZ01vdmVFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ0VuZCcpIGRyYWdFbmRFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5kcmFnSGFuZGxlUmVnaXN0cmFyLmRlZmF1bHRIYW5kbGVFbCA9IHRoaXMuZHJhZ2dhYmxlRWw7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ1N0YXJ0ZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRHJhZ01vZGUuZW50ZXIoKTtcbiAgICAgICAgdGhpcy5kcmFnT24gPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tR2hvc3QpIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZURlZmF1bHRHaG9zdChldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdTdGFydEVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGV2ZW50KSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdNb3ZlZC5zdWJzY3JpYmUoKGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgdGhpcy5kcmFnTW92ZUVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGV2ZW50KSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdFbmRlZC5zdWJzY3JpYmUoKGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgdGhpcy5nbG9iYWxEcmFnTW9kZS5leGl0KCk7XG4gICAgICAgIHRoaXMuZHJhZ09uID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5jdXN0b21HaG9zdCkge1xuICAgICAgICAgIHRoaXMuZGVzdHJveURlZmF1bHRHaG9zdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHJhZ0VuZEVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGV2ZW50KSk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRldGFjaERyYWdMaXN0ZW5lcnMoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgQ2xyRHJhZ0V2ZW50IH0gZnJvbSAnLi4vZHJhZy1ldmVudCc7XG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UsIERyYWdFdmVudFR5cGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcbmltcG9ydCB7IENsckRyb3BUb2xlcmFuY2VJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2Ryb3AtdG9sZXJhbmNlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBEcmFnQW5kRHJvcEV2ZW50QnVzU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9kcmFnLWFuZC1kcm9wLWV2ZW50LWJ1cy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsckRyb3BwYWJsZV0nLFxuICBwcm92aWRlcnM6IFtEb21BZGFwdGVyXSxcbiAgaG9zdDogeyAnW2NsYXNzLmRyb3BwYWJsZV0nOiAndHJ1ZScsICdbY2xhc3MuZHJhZ2dhYmxlLW1hdGNoXSc6ICdpc0RyYWdnYWJsZU1hdGNoJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wcGFibGU8VD4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgZHJhZ1N0YXJ0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgZHJhZ01vdmVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBkcmFnRW5kU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSBkcm9wcGFibGVFbDogYW55O1xuICBwcml2YXRlIGNsaWVudFJlY3Q6IENsaWVudFJlY3Q7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGV2ZW50QnVzOiBEcmFnQW5kRHJvcEV2ZW50QnVzU2VydmljZTxUPixcbiAgICBwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyXG4gICkge1xuICAgIHRoaXMuZHJvcHBhYmxlRWwgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICBwcml2YXRlIGlzRHJhZ2dhYmxlTWF0Y2g6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaXNEcmFnZ2FibGVPdmVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgc2V0IGlzRHJhZ2dhYmxlT3Zlcih2YWx1ZTogYm9vbGVhbikge1xuICAgIC8vIFdlIG5lZWQgdG8gYWRkL3JlbW92ZSB0aGlzIGRyYWdnYWJsZS1vdmVyIGNsYXNzIHZpYSBSZW5kZXJlcjJcbiAgICAvLyBiZWNhdXNlIGlzRHJhZ2dhYmxlT3ZlciBpcyBzZXQgb3V0c2lkZSBvZiBOZ1pvbmUuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZHJvcHBhYmxlRWwsICdkcmFnZ2FibGUtb3ZlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZHJvcHBhYmxlRWwsICdkcmFnZ2FibGUtb3ZlcicpO1xuICAgIH1cbiAgICB0aGlzLl9pc0RyYWdnYWJsZU92ZXIgPSB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgX2dyb3VwOiBzdHJpbmcgfCBzdHJpbmdbXTtcblxuICBASW5wdXQoJ2Nsckdyb3VwJylcbiAgc2V0IGdyb3VwKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgIHRoaXMuX2dyb3VwID0gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIF9kcm9wVG9sZXJhbmNlOiBDbHJEcm9wVG9sZXJhbmNlSW50ZXJmYWNlID0geyB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIGxlZnQ6IDAgfTtcblxuICBwcml2YXRlIGRyb3BUb2xlcmFuY2VHZW5lcmF0b3IodG9wID0gMCwgcmlnaHQgPSB0b3AsIGJvdHRvbSA9IHRvcCwgbGVmdCA9IHJpZ2h0KTogQ2xyRHJvcFRvbGVyYW5jZUludGVyZmFjZSB7XG4gICAgcmV0dXJuIHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0IH07XG4gIH1cblxuICBASW5wdXQoJ2NsckRyb3BUb2xlcmFuY2UnKVxuICBzZXQgZHJvcFRvbGVyYW5jZSh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIHwgQ2xyRHJvcFRvbGVyYW5jZUludGVyZmFjZSkge1xuICAgIC8vIElmIHVzZXIgcHJvdmlkZXMgYW4gb2JqZWN0IGhlcmUgYW5kIHdhbnRzIHRvIG1hbmlwdWxhdGUvdXBkYXRlIHByb3BlcnRpZXMgaW5kaXZpZHVhbGx5LFxuICAgIC8vIHRoZSBvYmplY3QgbXVzdCBiZSBpbW11dGFibGUgYXMgd2UgZ2VuZXJhdGUgbmV3IG9iamVjdCBiYXNlZCB1c2VyJ3MgZ2l2ZW4gb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLl9kcm9wVG9sZXJhbmNlID0gdGhpcy5kcm9wVG9sZXJhbmNlR2VuZXJhdG9yKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHRvbGVyYW5jZVZhbHVlcyA9IHZhbHVlXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgLm1hcCh0b2xlcmFuY2UgPT4gcGFyc2VJbnQodG9sZXJhbmNlLCAxMCkpO1xuICAgICAgdGhpcy5fZHJvcFRvbGVyYW5jZSA9IHRoaXMuZHJvcFRvbGVyYW5jZUdlbmVyYXRvciguLi50b2xlcmFuY2VWYWx1ZXMpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIC8vIFRoZSB2YWx1ZSBjb3VsZCBiZSBwYXNzZWQgaW4gYXMge2xlZnQ6IDIwLCB0b3A6IDMwIH1cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIHJlc3Qgb2YgdGhlIGRpcmVjdGlvbiBwcm9wZXJ0aWVzIHNob3VsZCBiZSAwLlxuICAgICAgLy8gVGhhdCdzIHdoeSB3ZSBpbml0aWFsaXplIHByb3BlcnRpZXMgd2l0aCAwIGZpcnN0LCB0aGVuIG92ZXJyaWRlIHdpdGggdXNlcidzIGdpdmVuIHZhbHVlLlxuICAgICAgdGhpcy5fZHJvcFRvbGVyYW5jZSA9IHsgLi4udGhpcy5kcm9wVG9sZXJhbmNlR2VuZXJhdG9yKDApLCAuLi52YWx1ZSB9O1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRyYWdTdGFydCcpIGRyYWdTdGFydEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnTW92ZScpIGRyYWdNb3ZlRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyYWdFbmQnKSBkcmFnRW5kRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyYWdMZWF2ZScpIGRyYWdMZWF2ZUVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnRW50ZXInKSBkcmFnRW50ZXJFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJvcCcpIGRyb3BFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBwcml2YXRlIHVuc3Vic2NyaWJlRnJvbShzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbik6IHZvaWQge1xuICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tHcm91cE1hdGNoKGRyYWdnYWJsZUdyb3VwOiBzdHJpbmcgfCBzdHJpbmdbXSk6IGJvb2xlYW4ge1xuICAgIC8vIEJvdGggRHJhZ2dhYmxlIGFuZCBEcm9wcGFibGUgaGF2ZSBjbHJHcm91cCBpbnB1dC5cbiAgICAvLyBUaGUgY2xyR3JvdXAgaW5wdXQgY2FuIGJlIGJvdGggYSBzdHJpbmcga2V5IG9yIGFycmF5IG9mIHN0cmluZyBrZXlzIGluIERyYWdnYWJsZSBhbmQgRHJvcHBhYmxlLlxuXG4gICAgLy8gSXQncyBub3QgbWF0Y2ggaWYgRHJhZ2dhYmxlIGhhcyBubyBkZWZpbmVkIHZhbHVlIGFzc2lnbmVkIHRvIGNsckdyb3VwLCBidXQgRHJvcHBhYmxlIGhhcyBhIGRlZmluZWQgY2xyR3JvdXAuXG4gICAgaWYgKCFkcmFnZ2FibGVHcm91cCAmJiB0aGlzLl9ncm91cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUaGUgc2FtZSBpcyB0cnVlIHRoZSBvdGhlciB3YXkgcm91bmQuXG4gICAgaWYgKCF0aGlzLl9ncm91cCAmJiBkcmFnZ2FibGVHcm91cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEl0J3MgbWF0Y2ggaWYgYm90aCBEcmFnZ2FibGUgYW5kIERyb3BwYWJsZSBoYXZlIG5vIGFzc2lnbmVkIHZhbHVlIGZvciBjbHJHcm91cC5cbiAgICBpZiAoIXRoaXMuX2dyb3VwICYmICFkcmFnZ2FibGVHcm91cCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gSXQncyBtYXRjaCBpZiBib3RoIERyYWdnYWJsZSBhbmQgRHJvcHBhYmxlIGhhdmUgc2ltcGxlIHN0cmluZyBrZXlzIHRoYXQgYXJlIG1hdGNoaW5nLlxuICAgIC8vIEl0J3MgbWF0Y2ggaWYgRHJhZ2dhYmxlJ3Mgc2ltcGxlIGNsckdyb3VwIGtleSBpcyBtYXRjaGluZyB3aXRoIG9uZSBvZiB0aGUgY2xyR3JvdXAga2V5cyBvZiBEcm9wcGFibGUuIFRoZVxuICAgIC8vIHNhbWUgaXMgdHJ1ZSB0aGUgb3RoZXIgd2F5IHJvdW5kLlxuICAgIC8vIGl0J3MgbWF0Y2ggaWYgb25lIG9mIHRoZSBjbHJHcm91cCBrZXlzIG9mIERyb3BwYWJsZSBpcyBtYXRjaGluZyB3aXRoIG9uZSBvZiB0aGUgY2xyR3JvdXAga2V5cyBvZiBEcmFnZ2FibGUuXG4gICAgaWYgKHR5cGVvZiBkcmFnZ2FibGVHcm91cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZ3JvdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cCA9PT0gZHJhZ2dhYmxlR3JvdXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXAuaW5kZXhPZihkcmFnZ2FibGVHcm91cCkgPiAtMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ncm91cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRyYWdnYWJsZUdyb3VwLmluZGV4T2YodGhpcy5fZ3JvdXApID4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dyb3VwIGFzIHN0cmluZ1tdKS5zb21lKGdyb3VwS2V5ID0+IGRyYWdnYWJsZUdyb3VwLmluZGV4T2YoZ3JvdXBLZXkpID4gLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaXNJbkRyb3BBcmVhKHBvaW50OiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfSk6IGJvb2xlYW4ge1xuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY2xpZW50UmVjdCkge1xuICAgICAgdGhpcy5jbGllbnRSZWN0ID0gdGhpcy5kb21BZGFwdGVyLmNsaWVudFJlY3QodGhpcy5kcm9wcGFibGVFbCk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgcG9pbnQucGFnZVggPj0gdGhpcy5jbGllbnRSZWN0LmxlZnQgLSB0aGlzLl9kcm9wVG9sZXJhbmNlLmxlZnQgJiZcbiAgICAgIHBvaW50LnBhZ2VYIDw9IHRoaXMuY2xpZW50UmVjdC5yaWdodCArIHRoaXMuX2Ryb3BUb2xlcmFuY2UucmlnaHQgJiZcbiAgICAgIHBvaW50LnBhZ2VZID49IHRoaXMuY2xpZW50UmVjdC50b3AgLSB0aGlzLl9kcm9wVG9sZXJhbmNlLnRvcCAmJlxuICAgICAgcG9pbnQucGFnZVkgPD0gdGhpcy5jbGllbnRSZWN0LmJvdHRvbSArIHRoaXMuX2Ryb3BUb2xlcmFuY2UuYm90dG9tXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb25EcmFnU3RhcnQoZHJhZ1N0YXJ0RXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPik6IHZvaWQge1xuICAgIC8vIENoZWNrIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGhhdmUgYSBtYXRjaGluZyBncm91cCBrZXkuXG4gICAgdGhpcy5pc0RyYWdnYWJsZU1hdGNoID0gdGhpcy5jaGVja0dyb3VwTWF0Y2goZHJhZ1N0YXJ0RXZlbnQuZ3JvdXApO1xuXG4gICAgLy8gU3Vic2NyaWJlIHRvIGRyYWdNb3ZlZCBhbmQgZHJhZ0VuZGVkIG9ubHkgaWYgZHJhZ2dhYmxlIGFuZCBkcm9wcGFibGUgaGF2ZSBhIG1hdGNoaW5nIGdyb3VwIGtleS5cbiAgICBpZiAodGhpcy5pc0RyYWdnYWJsZU1hdGNoKSB7XG4gICAgICB0aGlzLmRyYWdTdGFydEVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdTdGFydEV2ZW50KSk7XG4gICAgICB0aGlzLmRyYWdNb3ZlU3Vic2NyaXB0aW9uID0gdGhpcy5ldmVudEJ1cy5kcmFnTW92ZWQuc3Vic2NyaWJlKChkcmFnTW92ZUV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgdGhpcy5vbkRyYWdNb3ZlKGRyYWdNb3ZlRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmRyYWdFbmRTdWJzY3JpcHRpb24gPSB0aGlzLmV2ZW50QnVzLmRyYWdFbmRlZC5zdWJzY3JpYmUoKGRyYWdFbmRFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMub25EcmFnRW5kKGRyYWdFbmRFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uRHJhZ01vdmUoZHJhZ01vdmVFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgY29uc3QgaXNJbkRyb3BBcmVhID0gdGhpcy5pc0luRHJvcEFyZWEoZHJhZ01vdmVFdmVudC5kcm9wUG9pbnRQb3NpdGlvbik7XG4gICAgaWYgKCF0aGlzLl9pc0RyYWdnYWJsZU92ZXIgJiYgaXNJbkRyb3BBcmVhKSB7XG4gICAgICB0aGlzLmlzRHJhZ2dhYmxlT3ZlciA9IHRydWU7XG4gICAgICBjb25zdCBkcmFnRW50ZXJFdmVudCA9IHsgLi4uZHJhZ01vdmVFdmVudCwgdHlwZTogRHJhZ0V2ZW50VHlwZS5EUkFHX0VOVEVSIH07XG4gICAgICB0aGlzLmV2ZW50QnVzLmJyb2FkY2FzdChkcmFnRW50ZXJFdmVudCk7XG4gICAgICB0aGlzLmRyYWdFbnRlckVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdFbnRlckV2ZW50KSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9pc0RyYWdnYWJsZU92ZXIgJiYgIWlzSW5Ecm9wQXJlYSkge1xuICAgICAgdGhpcy5pc0RyYWdnYWJsZU92ZXIgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGRyYWdMZWF2ZUV2ZW50ID0geyAuLi5kcmFnTW92ZUV2ZW50LCB0eXBlOiBEcmFnRXZlbnRUeXBlLkRSQUdfTEVBVkUgfTtcbiAgICAgIHRoaXMuZXZlbnRCdXMuYnJvYWRjYXN0KGRyYWdMZWF2ZUV2ZW50KTtcbiAgICAgIHRoaXMuZHJhZ0xlYXZlRW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZHJhZ0xlYXZlRXZlbnQpKTtcbiAgICB9XG5cbiAgICB0aGlzLmRyYWdNb3ZlRW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZHJhZ01vdmVFdmVudCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBvbkRyYWdFbmQoZHJhZ0VuZEV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faXNEcmFnZ2FibGVPdmVyKSB7XG4gICAgICBpZiAoZHJhZ0VuZEV2ZW50Lmdob3N0RWxlbWVudCkge1xuICAgICAgICAvLyBCeSB0aGlzIHBvaW50LCB0aGUgZHJhZ2dhYmxlIGdob3N0IGNvbXBvbmVudCBpcyBkZXN0cm95ZWQsXG4gICAgICAgIC8vIGJ1dCB0aGUgZWxlbWVudCB3b3VsZCBiZSBhY3RpdmUgdW50aWwgaXRzIGFuaW1hdGlvbiBjb21wbGV0ZXMuXG4gICAgICAgIC8vIEFzIHN1Y2gsIG9uY2UgdGhlIGdob3N0IGlzIGRyb3BwZWQgb3Zlciwgd2Ugd2lsbCBnaXZlIGl0IFwiZHJvcHBlZFwiIGNsYXNzLlxuXG4gICAgICAgIC8vIFRoaXMgcHJvY2VzcyBjYW5ub3QgYmUgZG9uZSBpbiB0aGUgZ2hvc3QgY29tcG9uZW50XG4gICAgICAgIC8vIGJlY2F1c2UgYW55IHN1YnNjcmlwdGlvbiB0byB0aGUgZHJvcCBldmVudCBpcyBpbmVmZmVjdGl2ZSBvciBpbnZhbGlkXG4gICAgICAgIC8vIGFzIHRoZSBjb21wb25lbnQgaGFkIGJlZW4gYWxyZWFkeSBkZXN0cm95ZWQuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZHJhZ0VuZEV2ZW50Lmdob3N0RWxlbWVudCwgJ2Ryb3BwZWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHJvcEV2ZW50ID0geyAuLi5kcmFnRW5kRXZlbnQsIHR5cGU6IERyYWdFdmVudFR5cGUuRFJPUCB9O1xuICAgICAgdGhpcy5ldmVudEJ1cy5icm9hZGNhc3QoZHJvcEV2ZW50KTtcbiAgICAgIHRoaXMuZHJvcEVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyb3BFdmVudCkpO1xuICAgICAgdGhpcy5pc0RyYWdnYWJsZU92ZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kcmFnRW5kRW1pdHRlci5lbWl0KG5ldyBDbHJEcmFnRXZlbnQoZHJhZ0VuZEV2ZW50KSk7XG4gICAgdGhpcy51bnN1YnNjcmliZUZyb20odGhpcy5kcmFnTW92ZVN1YnNjcmlwdGlvbik7XG4gICAgdGhpcy51bnN1YnNjcmliZUZyb20odGhpcy5kcmFnRW5kU3Vic2NyaXB0aW9uKTtcbiAgICB0aGlzLmlzRHJhZ2dhYmxlTWF0Y2ggPSBmYWxzZTtcbiAgICBkZWxldGUgdGhpcy5jbGllbnRSZWN0O1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5kcmFnU3RhcnRTdWJzY3JpcHRpb24gPSB0aGlzLmV2ZW50QnVzLmRyYWdTdGFydGVkLnN1YnNjcmliZSgoZHJhZ1N0YXJ0RXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgdGhpcy5vbkRyYWdTdGFydChkcmFnU3RhcnRFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbSh0aGlzLmRyYWdTdGFydFN1YnNjcmlwdGlvbik7XG4gICAgdGhpcy51bnN1YnNjcmliZUZyb20odGhpcy5kcmFnTW92ZVN1YnNjcmlwdGlvbik7XG4gICAgdGhpcy51bnN1YnNjcmliZUZyb20odGhpcy5kcmFnRW5kU3Vic2NyaXB0aW9uKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERyYWdIYW5kbGVSZWdpc3RyYXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJhZy1oYW5kbGUtcmVnaXN0cmFyLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyRHJhZ0hhbmRsZV0nLCBob3N0OiB7ICdbY2xhc3MuZHJhZy1oYW5kbGVdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJEcmFnSGFuZGxlPFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZiwgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkcmFnSGFuZGxlUmVnaXN0cmFyOiBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZTxUPikge1xuICAgIGlmICghdGhpcy5kcmFnSGFuZGxlUmVnaXN0cmFyKSB7XG4gICAgICAvLyBDbHJEcmFnSGFuZGxlUmVnaXN0cmFyIGlzIHByb3ZpZGVkIGluIENsckRyYWdnYWJsZSBzbyB3ZSBleHBlY3QgaXQgdG8gYmUgcHJlc2VudCBoZXJlXG4gICAgICAvLyBhcyBjbHJEcmFnSGFuZGxlIGlzIHJlcXVpcmVkIHRvIGJlIHVzZWQgb25seSBpbnNpZGUgb2YgYSBjbHJEcmFnZ2FibGUgZGlyZWN0aXZlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2xyRHJhZ0hhbmRsZSBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHJEcmFnZ2FibGUgZGlyZWN0aXZlLicpO1xuICAgIH1cbiAgICB0aGlzLmRyYWdIYW5kbGVSZWdpc3RyYXIucmVnaXN0ZXJDdXN0b21IYW5kbGUodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZHJhZ0hhbmRsZVJlZ2lzdHJhci51bnJlZ2lzdGVyQ3VzdG9tSGFuZGxlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEcmFnZ2FibGUgfSBmcm9tICcuL2RyYWdnYWJsZS9kcmFnZ2FibGUnO1xuaW1wb3J0IHsgQ2xyRHJvcHBhYmxlIH0gZnJvbSAnLi9kcm9wcGFibGUvZHJvcHBhYmxlJztcbmltcG9ydCB7IENscklmRHJhZ2dlZCB9IGZyb20gJy4vaWYtZHJhZ2dlZCc7XG5pbXBvcnQgeyBDbHJEcmFnSGFuZGxlIH0gZnJvbSAnLi9kcmFnLWhhbmRsZSc7XG5pbXBvcnQgeyBDbHJEcmFnZ2FibGVHaG9zdCB9IGZyb20gJy4vZHJhZ2dhYmxlLWdob3N0JztcblxuZXhwb3J0IGNvbnN0IENMUl9EUkFHX0FORF9EUk9QX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICBDbHJEcmFnZ2FibGUsXG4gIENsckRyb3BwYWJsZSxcbiAgQ2xySWZEcmFnZ2VkLFxuICBDbHJEcmFnSGFuZGxlLFxuICBDbHJEcmFnZ2FibGVHaG9zdCxcbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfRFJBR19BTkRfRFJPUF9ESVJFQ1RJVkVTXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyRHJhZ2dhYmxlR2hvc3RdLFxuICBleHBvcnRzOiBbQ0xSX0RSQUdfQU5EX0RST1BfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyYWdBbmREcm9wTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFJvb3REcm9wZG93blNlcnZpY2Uge1xuICBwcml2YXRlIF9jaGFuZ2VzOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBnZXQgY2hhbmdlcygpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGNsb3NlTWVudXMoKTogdm9pZCB7XG4gICAgdGhpcy5fY2hhbmdlcy5uZXh0KGZhbHNlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xyUm9vdERyb3Bkb3duRmFjdG9yeShleGlzdGluZzogUm9vdERyb3Bkb3duU2VydmljZSkge1xuICByZXR1cm4gZXhpc3RpbmcgfHwgbmV3IFJvb3REcm9wZG93blNlcnZpY2UoKTtcbn1cblxuZXhwb3J0IGNvbnN0IFJPT1RfRFJPUERPV05fUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IFJvb3REcm9wZG93blNlcnZpY2UsXG4gIHVzZUZhY3Rvcnk6IGNsclJvb3REcm9wZG93bkZhY3RvcnksXG4gIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBSb290RHJvcGRvd25TZXJ2aWNlXV0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT3B0aW9uYWwsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5pbXBvcnQgeyBQT1BPVkVSX0hPU1RfQU5DSE9SIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4nO1xuXG5pbXBvcnQgeyBST09UX0RST1BET1dOX1BST1ZJREVSLCBSb290RHJvcGRvd25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJvcGRvd24uc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kcm9wZG93bicsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRyb3Bkb3duXSc6ICd0cnVlJyxcbiAgICAvLyBGSVhNRTogcmVtb3ZlIHRoaXMgYXMgc29vbiBhcyB3ZSBzdG9wIHN1cHBvcnRpbmcgdGhpcyBvbGQgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj4gc3ludGF4XG4gICAgJ1tjbGFzcy5vcGVuXSc6ICdpZk9wZW5TZXJ2aWNlLm9wZW4nLFxuICB9LFxuICBwcm92aWRlcnM6IFtJZk9wZW5TZXJ2aWNlLCBST09UX0RST1BET1dOX1BST1ZJREVSLCB7IHByb3ZpZGU6IFBPUE9WRVJfSE9TVF9BTkNIT1IsIHVzZUV4aXN0aW5nOiBFbGVtZW50UmVmIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93biBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBAU2tpcFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgcHVibGljIHBhcmVudDogQ2xyRHJvcGRvd24sXG4gICAgcHVibGljIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIGRyb3Bkb3duU2VydmljZTogUm9vdERyb3Bkb3duU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChkcm9wZG93blNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUodmFsdWUgPT4gKHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gdmFsdWUpKSk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goaWZPcGVuU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKSkpO1xuICB9XG5cbiAgQElucHV0KCdjbHJDbG9zZU1lbnVPbkl0ZW1DbGljaycpIGlzTWVudUNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEcm9wZG93biB9IGZyb20gJy4vZHJvcGRvd24nO1xuaW1wb3J0IHsgUm9vdERyb3Bkb3duU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2Ryb3Bkb3duLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyRHJvcGRvd25JdGVtXScsIGhvc3Q6IHsgJ1tjbGFzcy5kcm9wZG93bi1pdGVtXSc6ICd0cnVlJyB9IH0pXG5leHBvcnQgY2xhc3MgQ2xyRHJvcGRvd25JdGVtIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZHJvcGRvd246IENsckRyb3Bkb3duLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBfZHJvcGRvd25TZXJ2aWNlOiBSb290RHJvcGRvd25TZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2NsaWNrJywgKCkgPT4gdGhpcy5vbkRyb3Bkb3duSXRlbUNsaWNrKCkpO1xuICB9XG5cbiAgb25Ecm9wZG93bkl0ZW1DbGljaygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kcm9wZG93bi5pc01lbnVDbG9zYWJsZSAmJiAhdGhpcy5lbC5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgdGhpcy5fZHJvcGRvd25TZXJ2aWNlLmNsb3NlTWVudXMoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RvciwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vY29tbW9uL2Fic3RyYWN0LXBvcG92ZXInO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlcic7XG5pbXBvcnQgeyBQT1BPVkVSX0hPU1RfQU5DSE9SIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZHJvcGRvd24tbWVudScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kcm9wZG93bi1tZW51XSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJvcGRvd25NZW51IGV4dGVuZHMgQWJzdHJhY3RQb3BvdmVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChQT1BPVkVSX0hPU1RfQU5DSE9SKVxuICAgIHBhcmVudEhvc3Q6IEVsZW1lbnRSZWYsXG4gICAgQE9wdGlvbmFsKClcbiAgICBAU2tpcFNlbGYoKVxuICAgIG5lc3RlZDogQ2xyRHJvcGRvd25NZW51XG4gICkge1xuICAgIGlmICghcGFyZW50SG9zdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItZHJvcGRvd24tbWVudSBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsci1kcm9wZG93bicpO1xuICAgIH1cbiAgICBzdXBlcihpbmplY3RvciwgcGFyZW50SG9zdCk7XG4gICAgaWYgKCFuZXN0ZWQpIHtcbiAgICAgIC8vIERlZmF1bHQgcG9zaXRpb25pbmcgZm9yIG5vcm1hbCBkcm9wZG93biBpcyBib3R0b20tbGVmdFxuICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmYXVsdCBwb3NpdGlvbmluZyBmb3IgbmVzdGVkIGRyb3Bkb3duIGlzIHJpZ2h0LXRvcFxuICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgfVxuICAgIHRoaXMucG9wb3Zlck9wdGlvbnMuYWxsb3dNdWx0aXBsZU9wZW4gPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VPbk91dHNpZGVDbGljayA9IHRydWU7XG4gIH1cblxuICBASW5wdXQoJ2NsclBvc2l0aW9uJylcbiAgc2V0IHBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpIHtcbiAgICAvLyBzZXQgdGhlIHBvcG92ZXIgdmFsdWVzIGJhc2VkIG9uIG1lbnUgcG9zaXRpb25cbiAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuVE9QX1JJR0hUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfTEVGVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tcmlnaHQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX1JJR0hUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodC10b3AnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0LWJvdHRvbSc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdC10b3AnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQtYm90dG9tJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5cbmltcG9ydCB7IENsckRyb3Bkb3duIH0gZnJvbSAnLi9kcm9wZG93bic7XG5cbkBEaXJlY3RpdmUoe1xuICAvLyBXZSBzdXBwb3J0IGJvdGggc2VsZWN0b3JzIGZvciBsZWdhY3kgcmVhc29uc1xuICBzZWxlY3RvcjogJ1tjbHJEcm9wZG93blRyaWdnZXJdLFtjbHJEcm9wZG93blRvZ2dsZV0nLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kcm9wZG93bi10b2dnbGVdJzogJ2lzUm9vdExldmVsVG9nZ2xlJyxcbiAgICAnW2NsYXNzLmRyb3Bkb3duLWl0ZW1dJzogJyFpc1Jvb3RMZXZlbFRvZ2dsZScsXG4gICAgJ1tjbGFzcy5leHBhbmRhYmxlXSc6ICchaXNSb290TGV2ZWxUb2dnbGUnLFxuICAgICdbY2xhc3MuYWN0aXZlXSc6ICdhY3RpdmUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93blRyaWdnZXIge1xuICBwdWJsaWMgaXNSb290TGV2ZWxUb2dnbGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKGRyb3Bkb3duOiBDbHJEcm9wZG93biwgcHJpdmF0ZSBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlKSB7XG4gICAgLy8gaWYgdGhlIGNvbnRhaW5pbmcgZHJvcGRvd24gaGFzIGEgcGFyZW50LCB0aGVuIHRoaXMgaXMgbm90IHRoZSByb290IGxldmVsIG9uZVxuICAgIGlmIChkcm9wZG93bi5wYXJlbnQpIHtcbiAgICAgIHRoaXMuaXNSb290TGV2ZWxUb2dnbGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBnZXQgYWN0aXZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbjtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSlcbiAgb25Ecm9wZG93blRyaWdnZXJDbGljayhldmVudDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLnRvZ2dsZVdpdGhFdmVudChldmVudCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vblBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJEcm9wZG93biB9IGZyb20gJy4vZHJvcGRvd24nO1xuaW1wb3J0IHsgQ2xyRHJvcGRvd25JdGVtIH0gZnJvbSAnLi9kcm9wZG93bi1pdGVtJztcbmltcG9ydCB7IENsckRyb3Bkb3duTWVudSB9IGZyb20gJy4vZHJvcGRvd24tbWVudSc7XG5pbXBvcnQgeyBDbHJEcm9wZG93blRyaWdnZXIgfSBmcm9tICcuL2Ryb3Bkb3duLXRyaWdnZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX0RST1BET1dOX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsckRyb3Bkb3duLCBDbHJEcm9wZG93bk1lbnUsIENsckRyb3Bkb3duVHJpZ2dlciwgQ2xyRHJvcGRvd25JdGVtXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9EUk9QRE9XTl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9EUk9QRE9XTl9ESVJFQ1RJVkVTLCBDbHJDb25kaXRpb25hbE1vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyb3Bkb3duTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8vIEBUT0RPIE1ha2UgdGhpcyBhbiBlbnVtXG5leHBvcnQgY29uc3QgQUxFUlRfVFlQRVM6IHN0cmluZ1tdID0gWydpbmZvJywgJ3dhcm5pbmcnLCAnZGFuZ2VyJywgJ3N1Y2Nlc3MnXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBbGVydEluZm9PYmplY3QgfSBmcm9tICcuLi91dGlscy9hbGVydC1pbmZvLW9iamVjdCc7XG5pbXBvcnQgeyBBTEVSVF9UWVBFUyB9IGZyb20gJy4uL3V0aWxzL2FsZXJ0LXR5cGVzJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbGVydEljb25BbmRUeXBlc1NlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MpIHt9XG5cbiAgcHJpdmF0ZSBkZWZhdWx0SWNvblNoYXBlID0gJ2luZm8tY2lyY2xlJztcbiAgcHJpdmF0ZSBfYWxlcnRJY29uU2hhcGUgPSAnJztcbiAgcHJpdmF0ZSBfYWxlcnRUeXBlID0gJ2luZm8nO1xuXG4gIGdldCBhbGVydFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fYWxlcnRUeXBlO1xuICB9XG4gIHNldCBhbGVydFR5cGUodmFsOiBzdHJpbmcpIHtcbiAgICBpZiAoQUxFUlRfVFlQRVMuaW5kZXhPZih2YWwpID4gLTEpIHtcbiAgICAgIHRoaXMuX2FsZXJ0VHlwZSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBnZXQgYWxlcnRJY29uU2hhcGUoKTogc3RyaW5nIHtcbiAgICBpZiAoJycgPT09IHRoaXMuX2FsZXJ0SWNvblNoYXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pY29uSW5mb0Zyb21UeXBlKHRoaXMuX2FsZXJ0VHlwZSkuc2hhcGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hbGVydEljb25TaGFwZTtcbiAgfVxuICBzZXQgYWxlcnRJY29uU2hhcGUodmFsOiBzdHJpbmcpIHtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgdGhpcy5fYWxlcnRJY29uU2hhcGUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHZhbCAhPT0gdGhpcy5fYWxlcnRJY29uU2hhcGUpIHtcbiAgICAgIHRoaXMuX2FsZXJ0SWNvblNoYXBlID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhbGVydEljb25UaXRsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmljb25JbmZvRnJvbVR5cGUodGhpcy5fYWxlcnRUeXBlKS50aXRsZTtcbiAgfVxuXG4gIHB1YmxpYyBpY29uSW5mb0Zyb21UeXBlKHR5cGU6IHN0cmluZyk6IEFsZXJ0SW5mb09iamVjdCB7XG4gICAgY29uc3QgcmV0dXJuT2JqID0geyBzaGFwZTogJycsIGNzc0NsYXNzOiAnJywgdGl0bGU6ICcnIH07XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgICByZXR1cm5PYmouc2hhcGUgPSAnZXhjbGFtYXRpb24tdHJpYW5nbGUnO1xuICAgICAgICByZXR1cm5PYmouY3NzQ2xhc3MgPSAnYWxlcnQtd2FybmluZyc7XG4gICAgICAgIHJldHVybk9iai50aXRsZSA9IHRoaXMuY29tbW9uU3RyaW5ncy53YXJuaW5nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Rhbmdlcic6XG4gICAgICAgIHJldHVybk9iai5zaGFwZSA9ICdleGNsYW1hdGlvbi1jaXJjbGUnO1xuICAgICAgICByZXR1cm5PYmouY3NzQ2xhc3MgPSAnYWxlcnQtZGFuZ2VyJztcbiAgICAgICAgcmV0dXJuT2JqLnRpdGxlID0gdGhpcy5jb21tb25TdHJpbmdzLmRhbmdlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgcmV0dXJuT2JqLnNoYXBlID0gJ2NoZWNrLWNpcmNsZSc7XG4gICAgICAgIHJldHVybk9iai5jc3NDbGFzcyA9ICdhbGVydC1zdWNjZXNzJztcbiAgICAgICAgcmV0dXJuT2JqLnRpdGxlID0gdGhpcy5jb21tb25TdHJpbmdzLnN1Y2Nlc3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuT2JqLnNoYXBlID0gdGhpcy5kZWZhdWx0SWNvblNoYXBlO1xuICAgICAgICByZXR1cm5PYmouY3NzQ2xhc3MgPSAnYWxlcnQtaW5mbyc7XG4gICAgICAgIHJldHVybk9iai50aXRsZSA9IHRoaXMuY29tbW9uU3RyaW5ncy5pbmZvO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuT2JqO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyQWxlcnQgfSBmcm9tICcuLi9hbGVydCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNdWx0aUFsZXJ0U2VydmljZSB7XG4gIHByaXZhdGUgYWxsQWxlcnRzOiBRdWVyeUxpc3Q8Q2xyQWxlcnQ+ID0gbmV3IFF1ZXJ5TGlzdDxDbHJBbGVydD4oKTtcbiAgcHJpdmF0ZSBfY3VycmVudCA9IDA7XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2UgPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gIHB1YmxpYyBnZXQgY2hhbmdlcygpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuICBzZXQgY3VycmVudChpbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKGluZGV4ICE9PSB0aGlzLl9jdXJyZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gaW5kZXg7XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dChpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFjdGl2ZUFsZXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxBbGVydHMuZmlsdGVyKGFsZXJ0ID0+ICFhbGVydC5fY2xvc2VkKTtcbiAgfVxuXG4gIGdldCBjdXJyZW50QWxlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlQWxlcnRzW3RoaXMuY3VycmVudF07XG4gIH1cblxuICBzZXQgY3VycmVudEFsZXJ0KGFsZXJ0OiBDbHJBbGVydCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuYWN0aXZlQWxlcnRzLmluZGV4T2YoYWxlcnQpO1xuICB9XG5cbiAgZ2V0IGNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUFsZXJ0cy5sZW5ndGg7XG4gIH1cblxuICBtYW5hZ2UoYWxlcnRzOiBRdWVyeUxpc3Q8Q2xyQWxlcnQ+KSB7XG4gICAgdGhpcy5hbGxBbGVydHMgPSBhbGVydHM7XG4gIH1cblxuICBuZXh0KCkge1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudCA9PT0gdGhpcy5hY3RpdmVBbGVydHMubGVuZ3RoIC0gMSA/IDAgOiB0aGlzLmN1cnJlbnQgKyAxO1xuICB9XG5cbiAgcHJldmlvdXMoKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlQWxlcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmN1cnJlbnQgPT09IDAgPyB0aGlzLmFjdGl2ZUFsZXJ0cy5sZW5ndGggLSAxIDogdGhpcy5jdXJyZW50IC0gMTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMucHJldmlvdXMoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3B0aW9uYWwsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vLyBwcm92aWRlcnNcbmltcG9ydCB7IEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2ljb24tYW5kLXR5cGVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTXVsdGlBbGVydFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9tdWx0aS1hbGVydC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1hbGVydCcsXG4gIHByb3ZpZGVyczogW0FsZXJ0SWNvbkFuZFR5cGVzU2VydmljZV0sXG4gIHRlbXBsYXRlVXJsOiAnLi9hbGVydC5odG1sJyxcbiAgc3R5bGVzOiBbJzpob3N0IHsgZGlzcGxheTogYmxvY2s7IH0nXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQWxlcnQge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWNvblNlcnZpY2U6IEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSxcbiAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSBwdWJsaWMgbXVsdGlBbGVydFNlcnZpY2U6IE11bHRpQWxlcnRTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge31cblxuICBASW5wdXQoJ2NsckFsZXJ0U2l6ZVNtYWxsJykgaXNTbWFsbDogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoJ2NsckFsZXJ0Q2xvc2FibGUnKSBjbG9zYWJsZTogYm9vbGVhbiA9IHRydWU7XG4gIEBJbnB1dCgnY2xyQWxlcnRBcHBMZXZlbCcpIGlzQXBwTGV2ZWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASW5wdXQoJ2NsckFsZXJ0Q2xvc2VkJykgX2Nsb3NlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBAT3V0cHV0KCdjbHJBbGVydENsb3NlZENoYW5nZScpIF9jbG9zZWRDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBASW5wdXQoJ2NsckFsZXJ0VHlwZScpXG4gIHNldCBhbGVydFR5cGUodmFsOiBzdHJpbmcpIHtcbiAgICB0aGlzLmljb25TZXJ2aWNlLmFsZXJ0VHlwZSA9IHZhbDtcbiAgfVxuICBnZXQgYWxlcnRUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaWNvblNlcnZpY2UuYWxlcnRUeXBlO1xuICB9XG5cbiAgQElucHV0KCdjbHJBbGVydEljb24nKVxuICBzZXQgYWxlcnRJY29uU2hhcGUodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuaWNvblNlcnZpY2UuYWxlcnRJY29uU2hhcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBhbGVydENsYXNzKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaWNvblNlcnZpY2UuaWNvbkluZm9Gcm9tVHlwZSh0aGlzLmljb25TZXJ2aWNlLmFsZXJ0VHlwZSkuY3NzQ2xhc3M7XG4gIH1cblxuICBwcml2YXRlIHByZXZpb3VzbHlIaWRkZW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBoaWRkZW4gPSBmYWxzZTtcblxuICBwcml2YXRlIGRldGVjdENoYW5nZXNJZk5lZWRlZCgpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c2x5SGlkZGVuICE9PSB0aGlzLmhpZGRlbikge1xuICAgICAgdGhpcy5wcmV2aW91c2x5SGlkZGVuID0gdGhpcy5oaWRkZW47XG4gICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlzSGlkZGVuKCkge1xuICAgIGlmICh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQgPT09IHRoaXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5wcmV2aW91c2x5SGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzbHlIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzSWZOZWVkZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5oaWRkZW47XG4gIH1cblxuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuY2xvc2FibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5tdWx0aUFsZXJ0U2VydmljZSkge1xuICAgICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jbG9zZSgpO1xuICAgIH1cbiAgICB0aGlzLl9jbG9zZWRDaGFuZ2VkLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBvcGVuKCk6IHZvaWQge1xuICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlZENoYW5nZWQuZW1pdChmYWxzZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbGVydEljb25BbmRUeXBlc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9pY29uLWFuZC10eXBlcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWFsZXJ0LWl0ZW0nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtaWNvbi13cmFwcGVyXCI+XG4gICAgICAgICAgICA8Y2xyLWljb24gY2xhc3M9XCJhbGVydC1pY29uXCIgXG4gICAgICAgICAgICAgIFthdHRyLnNoYXBlXT1cImljb25TZXJ2aWNlLmFsZXJ0SWNvblNoYXBlXCIgXG4gICAgICAgICAgICAgIFthdHRyLnRpdGxlXT1cImljb25TZXJ2aWNlLmFsZXJ0SWNvblRpdGxlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7IGNsYXNzOiAnYWxlcnQtaXRlbScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQWxlcnRJdGVtIHtcbiAgY29uc3RydWN0b3IocHVibGljIGljb25TZXJ2aWNlOiBBbGVydEljb25BbmRUeXBlc1NlcnZpY2UpIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckFsZXJ0IH0gZnJvbSAnLi9hbGVydCc7XG5pbXBvcnQgeyBNdWx0aUFsZXJ0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL211bHRpLWFsZXJ0LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYWxlcnRzJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2FsZXJ0cy5odG1sJyxcbiAgcHJvdmlkZXJzOiBbTXVsdGlBbGVydFNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5hbGVydHNdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuYWxlcnQtZGFuZ2VyXSc6IFwidGhpcy5jdXJyZW50QWxlcnRUeXBlID09ICdkYW5nZXInXCIsXG4gICAgJ1tjbGFzcy5hbGVydC1pbmZvXSc6IFwidGhpcy5jdXJyZW50QWxlcnRUeXBlID09ICdpbmZvJ1wiLFxuICAgICdbY2xhc3MuYWxlcnQtc3VjY2Vzc10nOiBcInRoaXMuY3VycmVudEFsZXJ0VHlwZSA9PSAnc3VjY2VzcydcIixcbiAgICAnW2NsYXNzLmFsZXJ0LXdhcm5pbmddJzogXCJ0aGlzLmN1cnJlbnRBbGVydFR5cGUgPT0gJ3dhcm5pbmcnXCIsXG4gIH0sXG4gIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrIH0nXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQWxlcnRzIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyQWxlcnQpIGFsbEFsZXJ0czogUXVlcnlMaXN0PENsckFsZXJ0PjtcblxuICAvKipcbiAgICogSW5wdXQvT3V0cHV0IHRvIHN1cHBvcnQgdHdvIHdheSBiaW5kaW5nIG9uIGN1cnJlbnQgYWxlcnQgaW5kZXhcbiAgICovXG4gIEBJbnB1dCgnY2xyQ3VycmVudEFsZXJ0SW5kZXgnKVxuICBwdWJsaWMgc2V0IF9pbnB1dEN1cnJlbnRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5kZXgpICYmIGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudCA9IGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckN1cnJlbnRBbGVydEluZGV4Q2hhbmdlJykgcHVibGljIGN1cnJlbnRBbGVydEluZGV4Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KGZhbHNlKTtcblxuICBzZXQgY3VycmVudEFsZXJ0SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudCA9IGluZGV4O1xuICB9XG4gIGdldCBjdXJyZW50QWxlcnRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIElucHV0L091dHB1dCB0byBzdXBwb3J0IHR3byB3YXkgYmluZGluZyBvbiBjdXJyZW50IGFsZXJ0IGluc3RhbmNlXG4gICAqL1xuICBASW5wdXQoJ2NsckN1cnJlbnRBbGVydCcpXG4gIHNldCBjdXJyZW50QWxlcnQoYWxlcnQ6IENsckFsZXJ0KSB7XG4gICAgaWYgKGFsZXJ0KSB7XG4gICAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydCA9IGFsZXJ0O1xuICAgIH1cbiAgfVxuICBnZXQgY3VycmVudEFsZXJ0KCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydDtcbiAgfVxuICBAT3V0cHV0KCdjbHJDdXJyZW50QWxlcnRDaGFuZ2UnKSBwdWJsaWMgY3VycmVudEFsZXJ0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJBbGVydD4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbnN1cmUgd2UgYXJlIG9ubHkgZGVhbGluZyB3aXRoIGFsZXJ0cyB0aGF0IGhhdmUgbm90IGJlZW4gY2xvc2VkIHlldFxuICAgKi9cbiAgZ2V0IGFsZXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxBbGVydHMuZmlsdGVyKGFsZXJ0ID0+IHtcbiAgICAgIHJldHVybiBhbGVydC5pc0hpZGRlbiA9PT0gZmFsc2U7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgY3VycmVudEFsZXJ0VHlwZSgpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydCkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0LmFsZXJ0VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHVibGljIG11bHRpQWxlcnRTZXJ2aWNlOiBNdWx0aUFsZXJ0U2VydmljZSkge31cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5tYW5hZ2UodGhpcy5hbGxBbGVydHMpO1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY2hhbmdlcy5zdWJzY3JpYmUoaW5kZXggPT4ge1xuICAgICAgdGhpcy5jdXJyZW50QWxlcnRJbmRleENoYW5nZS5uZXh0KGluZGV4KTtcbiAgICAgIHRoaXMuY3VycmVudEFsZXJ0Q2hhbmdlLm5leHQodGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJBbGVydCB9IGZyb20gJy4vYWxlcnQnO1xuaW1wb3J0IHsgTXVsdGlBbGVydFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9tdWx0aS1hbGVydC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1hbGVydHMtcGFnZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vYWxlcnRzLXBhZ2VyLmh0bWwnLFxuICBob3N0OiB7ICdbY2xhc3MuYWxlcnRzLXBhZ2VyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydHNQYWdlciBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBtdWx0aUFsZXJ0U2VydmljZUNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSW5wdXQvT3V0cHV0IHRvIHN1cHBvcnQgdHdvIHdheSBiaW5kaW5nIG9uIGN1cnJlbnQgYWxlcnQgaW5zdGFuY2VcbiAgICovXG4gIEBJbnB1dCgnY2xyQ3VycmVudEFsZXJ0JylcbiAgc2V0IGN1cnJlbnRBbGVydChhbGVydDogQ2xyQWxlcnQpIHtcbiAgICBpZiAoYWxlcnQpIHtcbiAgICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0ID0gYWxlcnQ7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50QWxlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0O1xuICB9XG5cbiAgQE91dHB1dCgnY2xyQ3VycmVudEFsZXJ0Q2hhbmdlJykgY3VycmVudEFsZXJ0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJBbGVydD4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBJbnB1dC9PdXRwdXQgdG8gc3VwcG9ydCB0d28gd2F5IGJpbmRpbmcgb24gY3VycmVudCBhbGVydCBpbmRleFxuICAgKi9cbiAgQElucHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleCcpXG4gIHNldCBjdXJyZW50QWxlcnRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50ID0gaW5kZXg7XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbGVydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQ7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleENoYW5nZScpIGN1cnJlbnRBbGVydEluZGV4Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG11bHRpQWxlcnRTZXJ2aWNlOiBNdWx0aUFsZXJ0U2VydmljZSwgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZUNoYW5nZXMgPSB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKGluZGV4ID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UuZW1pdChpbmRleCk7XG4gICAgICB0aGlzLmN1cnJlbnRBbGVydENoYW5nZS5lbWl0KHRoaXMubXVsdGlBbGVydFNlcnZpY2UuYWN0aXZlQWxlcnRzW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICBwYWdlVXAoKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5uZXh0KCk7XG4gIH1cblxuICBwYWdlRG93bigpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLnByZXZpb3VzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJEcm9wZG93bk1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyQWxlcnQgfSBmcm9tICcuL2FsZXJ0JztcbmltcG9ydCB7IENsckFsZXJ0SXRlbSB9IGZyb20gJy4vYWxlcnQtaXRlbSc7XG5pbXBvcnQgeyBDbHJBbGVydHMgfSBmcm9tICcuL2FsZXJ0cyc7XG5pbXBvcnQgeyBDbHJBbGVydHNQYWdlciB9IGZyb20gJy4vYWxlcnRzLXBhZ2VyJztcblxuZXhwb3J0IGNvbnN0IENMUl9BTEVSVF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJBbGVydCwgQ2xyQWxlcnRJdGVtLCBDbHJBbGVydHMsIENsckFsZXJ0c1BhZ2VyXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyRHJvcGRvd25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfQUxFUlRfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfQUxFUlRfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsckFsZXJ0TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQWxlcnRNb2R1bGUgfSBmcm9tICcuL2FsZXJ0L2FsZXJ0Lm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7IGV4cG9ydHM6IFtDbHJBbGVydE1vZHVsZV0gfSlcbmV4cG9ydCBjbGFzcyBDbHJFbXBoYXNpc01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgY2xhc3MgUmVzcG9uc2l2ZU5hdkNvZGVzIHtcbiAgcHVibGljIHN0YXRpYyBOQVZfTEVWRUxfMTogbnVtYmVyID0gMTtcbiAgcHVibGljIHN0YXRpYyBOQVZfTEVWRUxfMjogbnVtYmVyID0gMjtcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xPU0VfQUxMOiBzdHJpbmcgPSAnTkFWX0NMT1NFX0FMTCc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX09QRU46IHN0cmluZyA9ICdOQVZfT1BFTic7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMT1NFOiBzdHJpbmcgPSAnTkFWX0NMT1NFJztcbiAgcHVibGljIHN0YXRpYyBOQVZfVE9HR0xFOiBzdHJpbmcgPSAnTkFWX1RPR0dMRSc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX0hBTUJVUkdFUl9NRU5VOiBzdHJpbmcgPSAnb3Blbi1oYW1idXJnZXItbWVudSc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX09WRVJGTE9XX01FTlU6IHN0cmluZyA9ICdvcGVuLW92ZXJmbG93LW1lbnUnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19UUklHR0VSXzE6IHN0cmluZyA9ICdoZWFkZXItaGFtYnVyZ2VyLXRyaWdnZXInO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19UUklHR0VSXzI6IHN0cmluZyA9ICdoZWFkZXItb3ZlcmZsb3ctdHJpZ2dlcic7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX0xFVkVMXzE6IHN0cmluZyA9ICdjbHItbmF2LWxldmVsLTEnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19MRVZFTF8yOiBzdHJpbmcgPSAnY2xyLW5hdi1sZXZlbC0yJztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbnRyb2xDb2RlOiBzdHJpbmcsIHByaXZhdGUgX25hdkxldmVsOiBudW1iZXIpIHt9XG5cbiAgZ2V0IGNvbnRyb2xDb2RlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xDb2RlO1xuICB9XG5cbiAgZ2V0IG5hdkxldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX25hdkxldmVsO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb2RlcyB9IGZyb20gJy4uL3Jlc3BvbnNpdmUtbmF2LWNvZGVzJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSB9IGZyb20gJy4uL3Jlc3BvbnNpdmUtbmF2LWNvbnRyb2wtbWVzc2FnZSc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgcHVibGljIHJlc3BvbnNpdmVOYXZMaXN0OiBudW1iZXJbXSA9IFtdO1xuICBwcml2YXRlIHJlZ2lzdGVyTmF2U3ViamVjdDogU3ViamVjdDxudW1iZXJbXT4gPSBuZXcgU3ViamVjdDxudW1iZXJbXT4oKTtcbiAgcHJpdmF0ZSBjb250cm9sTmF2U3ViamVjdDogU3ViamVjdDxSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2U+ID0gbmV3IFN1YmplY3Q8UmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlPigpO1xuXG4gIGdldCByZWdpc3RlcmVkTmF2cygpOiBPYnNlcnZhYmxlPG51bWJlcltdPiB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJOYXZTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgZ2V0IG5hdkNvbnRyb2woKTogT2JzZXJ2YWJsZTxSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2U+IHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sTmF2U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xvc2VBbGxOYXZzKCk7IC8vIFdlIHN0YXJ0IHdpdGggYWxsIG5hdnMgY2xvc2VkXG4gIH1cblxuICByZWdpc3Rlck5hdihuYXZMZXZlbDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCFuYXZMZXZlbCB8fCB0aGlzLmlzTmF2UmVnaXN0ZXJlZChuYXZMZXZlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2TGlzdC5wdXNoKG5hdkxldmVsKTtcbiAgICB0aGlzLnJlZ2lzdGVyTmF2U3ViamVjdC5uZXh0KHRoaXMucmVzcG9uc2l2ZU5hdkxpc3QpO1xuICB9XG5cbiAgaXNOYXZSZWdpc3RlcmVkKG5hdkxldmVsOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5yZXNwb25zaXZlTmF2TGlzdC5pbmRleE9mKG5hdkxldmVsKSA+IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNdWx0aXBsZSBjbHItbmF2LWxldmVsICcgKyBuYXZMZXZlbCArICcgYXR0cmlidXRlcyBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IG9ubHkgb25lIGV4aXN0cycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHVucmVnaXN0ZXJOYXYobmF2TGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZXNwb25zaXZlTmF2TGlzdC5pbmRleE9mKG5hdkxldmVsKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5yZXNwb25zaXZlTmF2TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5yZWdpc3Rlck5hdlN1YmplY3QubmV4dCh0aGlzLnJlc3BvbnNpdmVOYXZMaXN0KTtcbiAgICB9XG4gIH1cblxuICBzZW5kQ29udHJvbE1lc3NhZ2UoY29udHJvbENvZGU6IHN0cmluZywgbmF2TGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IG1lc3NhZ2U6IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSA9IG5ldyBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UoY29udHJvbENvZGUsIG5hdkxldmVsKTtcbiAgICB0aGlzLmNvbnRyb2xOYXZTdWJqZWN0Lm5leHQobWVzc2FnZSk7XG4gIH1cblxuICBjbG9zZUFsbE5hdnMoKSB7XG4gICAgY29uc3QgbWVzc2FnZTogUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlID0gbmV3IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZShcbiAgICAgIFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0VfQUxMLFxuICAgICAgLTk5OVxuICAgICk7XG4gICAgdGhpcy5jb250cm9sTmF2U3ViamVjdC5uZXh0KG1lc3NhZ2UpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vbmF2L3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29kZXMgfSBmcm9tICcuLi9uYXYvcmVzcG9uc2l2ZS1uYXYtY29kZXMnO1xuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlIH0gZnJvbSAnLi4vbmF2L3Jlc3BvbnNpdmUtbmF2LWNvbnRyb2wtbWVzc2FnZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1tYWluLWNvbnRhaW5lcicsIGhvc3Q6IHsgJ1tjbGFzcy5tYWluLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsck1haW5Db250YWluZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIF9jbGFzc0xpc3Q6IERPTVRva2VuTGlzdDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsUmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlc3BvbnNpdmVOYXZTZXJ2aWNlOiBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5fY2xhc3NMaXN0ID0gdGhpcy5lbFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLm5hdkNvbnRyb2wuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChtZXNzYWdlOiBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UpID0+IHtcbiAgICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcm9jZXNzTWVzc2FnZShtZXNzYWdlOiBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UpOiB2b2lkIHtcbiAgICBsZXQgbmF2Q2xhc3M6IHN0cmluZyA9IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfSEFNQlVSR0VSX01FTlU7XG4gICAgaWYgKG1lc3NhZ2UuY29udHJvbENvZGUgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0VfQUxMKSB7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QucmVtb3ZlKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfSEFNQlVSR0VSX01FTlUpO1xuICAgICAgdGhpcy5fY2xhc3NMaXN0LnJlbW92ZShSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX09WRVJGTE9XX01FTlUpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5uYXZMZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8xKSB7XG4gICAgICB0aGlzLmNvbnRyb2xOYXYobWVzc2FnZS5jb250cm9sQ29kZSwgbmF2Q2xhc3MpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5uYXZMZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8yKSB7XG4gICAgICBuYXZDbGFzcyA9IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfT1ZFUkZMT1dfTUVOVTtcbiAgICAgIHRoaXMuY29udHJvbE5hdihtZXNzYWdlLmNvbnRyb2xDb2RlLCBuYXZDbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgY29udHJvbE5hdihjb250cm9sQ29kZTogc3RyaW5nLCBuYXZDbGFzczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKGNvbnRyb2xDb2RlID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX09QRU4pIHtcbiAgICAgIHRoaXMuX2NsYXNzTGlzdC5hZGQobmF2Q2xhc3MpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbENvZGUgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0UpIHtcbiAgICAgIHRoaXMuX2NsYXNzTGlzdC5yZW1vdmUobmF2Q2xhc3MpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbENvZGUgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfVE9HR0xFKSB7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QudG9nZ2xlKG5hdkNsYXNzKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTWFpbkNvbnRhaW5lciB9IGZyb20gJy4vbWFpbi1jb250YWluZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX0xBWU9VVF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJNYWluQ29udGFpbmVyXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9MQVlPVVRfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfTEFZT1VUX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJNYWluQ29udGFpbmVyTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFdpbGx5V29ua2EgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItbWFpbi1jb250YWluZXInIH0pXG5leHBvcnQgY2xhc3MgTWFpbkNvbnRhaW5lcldpbGx5V29ua2EgZXh0ZW5kcyBXaWxseVdvbmthIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT29tcGFMb29tcGEgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBNYWluQ29udGFpbmVyV2lsbHlXb25rYSB9IGZyb20gJy4vbWFpbi1jb250YWluZXItd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItaGVhZGVyJyB9KVxuZXhwb3J0IGNsYXNzIE5hdkRldGVjdGlvbk9vbXBhTG9vbXBhIGV4dGVuZHMgT29tcGFMb29tcGEge1xuICBwcml2YXRlIHJlc3BvbnNpdmVOYXZTZXJ2aWNlOiBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSB3aWxseVdvbmthOiBNYWluQ29udGFpbmVyV2lsbHlXb25rYSxcbiAgICByZXNwb25zaXZlTmF2U2VydmljZTogUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlXG4gICkge1xuICAgIGlmICghd2lsbHlXb25rYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItaGVhZGVyIHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLW1haW4tY29udGFpbmVyJyk7XG4gICAgfVxuICAgIHN1cGVyKGNkciwgd2lsbHlXb25rYSk7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZSA9IHJlc3BvbnNpdmVOYXZTZXJ2aWNlO1xuICB9XG5cbiAgLy8gTmF2RGV0ZWN0aW9uT29tcGFMb29tcGEgaXMgdGhlIGFkZGl0aW9uIG9mIHRoZSBuYXYgbGV2ZWxzXG4gIC8vIFNpbmNlIHdlIHN1cHBvcnQgMiBsZXZlbHMsIHRoZSBwb3NzaWJpbGl0aWVzIGFyZSAwLCAxIG9yIDMgKDEgKyAyKVxuICBnZXQgZmxhdm9yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnJlc3BvbnNpdmVOYXZMaXN0LnJlZHVjZSgoc3VtLCBuYXZMZXZlbCkgPT4gc3VtICsgbmF2TGV2ZWwsIDApO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jlc3BvbnNpdmUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb2RlcyB9IGZyb20gJy4vcmVzcG9uc2l2ZS1uYXYtY29kZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItaGVhZGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAqbmdJZj1cImlzTmF2TGV2ZWwxT25QYWdlXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaGVhZGVyLWhhbWJ1cmdlci10cmlnZ2VyXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVOYXYocmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8xKVwiPlxuICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICpuZ0lmPVwiaXNOYXZMZXZlbDJPblBhZ2VcIlxuICAgICAgICAgICAgY2xhc3M9XCJoZWFkZXItb3ZlcmZsb3ctdHJpZ2dlclwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlTmF2KHJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMilcIj5cbiAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXItYmFja2Ryb3BcIiAoY2xpY2spPVwiY2xvc2VPcGVuTmF2KClcIj48L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuaGVhZGVyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJIZWFkZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHVibGljIGlzTmF2TGV2ZWwxT25QYWdlOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpc05hdkxldmVsMk9uUGFnZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgcmVzcG9uc2l2ZU5hdkNvZGVzID0gUmVzcG9uc2l2ZU5hdkNvZGVzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVzcG9uc2l2ZU5hdlNlcnZpY2U6IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UucmVnaXN0ZXJlZE5hdnMuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChuYXZMZXZlbExpc3Q6IG51bWJlcltdKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU5hdlRyaWdnZXJzKG5hdkxldmVsTGlzdCk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLy8gcmVzZXQgdHJpZ2dlcnMuIGhhbmRsZXMgY2FzZXMgd2hlbiBhbiBhcHBsaWNhdGlvbiBoYXMgZGlmZmVyZW50IG5hdiBsZXZlbHMgb24gZGlmZmVyZW50IHBhZ2VzLlxuICByZXNldE5hdlRyaWdnZXJzKCkge1xuICAgIHRoaXMuaXNOYXZMZXZlbDFPblBhZ2UgPSBmYWxzZTtcbiAgICB0aGlzLmlzTmF2TGV2ZWwyT25QYWdlID0gZmFsc2U7XG4gIH1cblxuICAvLyBkZWNpZGVzIHdoaWNoIHRyaWdnZXJzIHRvIHNob3cgb24gdGhlIGhlYWRlclxuICBpbml0aWFsaXplTmF2VHJpZ2dlcnMobmF2TGlzdDogbnVtYmVyW10pOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0TmF2VHJpZ2dlcnMoKTtcbiAgICBpZiAobmF2TGlzdC5sZW5ndGggPiAyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNb3JlIHRoYW4gMiBOYXYgTGV2ZWxzIGRldGVjdGVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuYXZMaXN0LmZvckVhY2gobmF2TGV2ZWwgPT4ge1xuICAgICAgaWYgKG5hdkxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzEpIHtcbiAgICAgICAgdGhpcy5pc05hdkxldmVsMU9uUGFnZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5hdkxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzIpIHtcbiAgICAgICAgdGhpcy5pc05hdkxldmVsMk9uUGFnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBjbG9zZXMgdGhlIG5hdiB0aGF0IGlzIG9wZW5cbiAgY2xvc2VPcGVuTmF2KCkge1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UuY2xvc2VBbGxOYXZzKCk7XG4gIH1cblxuICAvLyB0b2dnbGVzIHRoZSBuYXYgdGhhdCBpcyBvcGVuXG4gIHRvZ2dsZU5hdihuYXZMZXZlbDogbnVtYmVyKSB7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5zZW5kQ29udHJvbE1lc3NhZ2UoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9UT0dHTEUsIG5hdkxldmVsKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29kZXMgfSBmcm9tICcuL3Jlc3BvbnNpdmUtbmF2LWNvZGVzJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2Nsci1uYXYtbGV2ZWxdJyB9KVxuZXhwb3J0IGNsYXNzIENsck5hdkxldmVsIGltcGxlbWVudHMgT25Jbml0IHtcbiAgQElucHV0KCdjbHItbmF2LWxldmVsJykgX2xldmVsOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZXNwb25zaXZlTmF2U2VydmljZTogUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlLCBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMubGV2ZWwgIT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMSAmJiB0aGlzLmxldmVsICE9PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05hdiBMZXZlbCBjYW4gb25seSBiZSAxIG9yIDInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5yZWdpc3Rlck5hdih0aGlzLmxldmVsKTtcbiAgICB0aGlzLmFkZE5hdkNsYXNzKHRoaXMubGV2ZWwpO1xuICB9XG5cbiAgYWRkTmF2Q2xhc3MobGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IG5hdkhvc3RDbGFzc0xpc3QgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3Q7XG4gICAgaWYgKGxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzEpIHtcbiAgICAgIG5hdkhvc3RDbGFzc0xpc3QuYWRkKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfTEVWRUxfMSk7XG4gICAgfSBlbHNlIGlmIChsZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8yKSB7XG4gICAgICBuYXZIb3N0Q2xhc3NMaXN0LmFkZChSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX0xFVkVMXzIpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgfVxuXG4gIC8vIGdldHRlciB0byBhY2Nlc3MgdGhlIHJlc3BvbnNpdmUgbmF2aWdhdGlvbiBjb2RlcyBmcm9tIHRoZSB0ZW1wbGF0ZVxuICBnZXQgcmVzcG9uc2l2ZU5hdkNvZGVzKCk6IFJlc3BvbnNpdmVOYXZDb2RlcyB7XG4gICAgcmV0dXJuIFJlc3BvbnNpdmVOYXZDb2RlcztcbiAgfVxuXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5zZW5kQ29udHJvbE1lc3NhZ2UoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9PUEVOLCB0aGlzLmxldmVsKTtcbiAgfVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2Uuc2VuZENvbnRyb2xNZXNzYWdlKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0UsIHRoaXMubGV2ZWwpO1xuICB9XG5cbiAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0cyB0aGUgYmVzdCB3YXkgdG8gZG8gdGhpcy4gUG9zc2libGUgbWV0aG9kc1xuICAvLyAxLiBIb3N0TGlzdGVuZXIgKGN1cnJlbnQgc29sdXRpb24pXG4gIC8vIDIuIERpcmVjdGl2ZXMgb24gdGhlIC5uYXYtbGluayBjbGFzcy4gV2UgZGlzY3Vzc2VkIG9uIG1vdmluZyBhd2F5IGZyb20gY2xhc3Mgc2VsZWN0b3JzIGJ1dCBJIGZvcmdldCB0aGUgcmVhc29uXG4gIC8vIHdoeVxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LnRhcmdldCddKVxuICBvbk1vdXNlQ2xpY2sodGFyZ2V0OiBhbnkpIHtcbiAgICBsZXQgY3VycmVudDogYW55ID0gdGFyZ2V0OyAvLyBHZXQgdGhlIGVsZW1lbnQgaW4gdGhlIERPTSBvbiB3aGljaCB0aGUgbW91c2Ugd2FzIGNsaWNrZWRcbiAgICBjb25zdCBuYXZIb3N0OiBhbnkgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDsgLy8gR2V0IHRoZSBjdXJyZW50IG5hdiBuYXRpdmUgSFRNTCBlbGVtZW50XG5cbiAgICAvLyBTdGFydCBjaGVja2luZyBpZiBjdXJyZW50IGFuZCBuYXZIb3N0IGFyZSBlcXVhbC5cbiAgICAvLyBJZiBub3QgdHJhdmVyc2UgdG8gdGhlIHBhcmVudE5vZGUgYW5kIGNoZWNrIGFnYWluLlxuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gbmF2SG9zdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCduYXYtbGluaycpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnVucmVnaXN0ZXJOYXYodGhpcy5sZXZlbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckRyb3Bkb3duTW9kdWxlIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBNYWluQ29udGFpbmVyV2lsbHlXb25rYSB9IGZyb20gJy4vY2hvY29sYXRlL21haW4tY29udGFpbmVyLXdpbGx5LXdvbmthJztcbmltcG9ydCB7IE5hdkRldGVjdGlvbk9vbXBhTG9vbXBhIH0gZnJvbSAnLi9jaG9jb2xhdGUvbmF2LWRldGVjdGlvbi1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgQ2xySGVhZGVyIH0gZnJvbSAnLi9oZWFkZXInO1xuaW1wb3J0IHsgQ2xyTmF2TGV2ZWwgfSBmcm9tICcuL25hdi1sZXZlbCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfTkFWSUdBVElPTl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xySGVhZGVyLFxuICBDbHJOYXZMZXZlbCxcbiAgTmF2RGV0ZWN0aW9uT29tcGFMb29tcGEsXG4gIE1haW5Db250YWluZXJXaWxseVdvbmthLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyRHJvcGRvd25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfTkFWSUdBVElPTl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9OQVZJR0FUSU9OX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJOYXZpZ2F0aW9uTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgICA8bmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVSZWZDb250YWluZXIge1xuICBAVmlld0NoaWxkKFRlbXBsYXRlUmVmKSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRlbXBsYXRlUmVmQ29udGFpbmVyIH0gZnJvbSAnLi90ZW1wbGF0ZS1yZWYtY29udGFpbmVyJztcblxuZXhwb3J0ICogZnJvbSAnLi90ZW1wbGF0ZS1yZWYtY29udGFpbmVyJztcblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1JFRl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtUZW1wbGF0ZVJlZkNvbnRhaW5lcl07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgVEVNUExBVEVfUkVGX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW1RFTVBMQVRFX1JFRl9ESVJFQ1RJVkVTXSxcbiAgZW50cnlDb21wb25lbnRzOiBbVEVNUExBVEVfUkVGX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbVEVNUExBVEVfUkVGX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUZW1wbGF0ZVJlZk1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaWxseVdvbmthIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL3dpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLXRhYnMnIH0pXG5leHBvcnQgY2xhc3MgVGFic1dpbGx5V29ua2EgZXh0ZW5kcyBXaWxseVdvbmthIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBJbmplY3QsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE9vbXBhTG9vbXBhIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL29vbXBhLWxvb21wYSc7XG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcblxuaW1wb3J0IHsgVGFic1dpbGx5V29ua2EgfSBmcm9tICcuL3RhYnMtd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyVGFiTGlua10sIGNsci10YWItY29udGVudCcgfSlcbmV4cG9ydCBjbGFzcyBBY3RpdmVPb21wYUxvb21wYSBleHRlbmRzIE9vbXBhTG9vbXBhIHtcbiAgcHJpdmF0ZSBpZkFjdGl2ZTogSWZBY3RpdmVTZXJ2aWNlO1xuICBwcml2YXRlIGlkOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSB3aWxseVdvbmthOiBUYWJzV2lsbHlXb25rYSxcbiAgICBASW5qZWN0KElGX0FDVElWRV9JRCkgaWQ6IG51bWJlcixcbiAgICBpZkFjdGl2ZTogSWZBY3RpdmVTZXJ2aWNlXG4gICkge1xuICAgIGlmICghd2lsbHlXb25rYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHJUYWJMaW5rIGFuZCBjbHItdGFiLWNvbnRlbnQgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItdGFicycpO1xuICAgIH1cbiAgICBzdXBlcihjZHIsIHdpbGx5V29ua2EpO1xuICAgIHRoaXMuaWZBY3RpdmUgPSBpZkFjdGl2ZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cblxuICBnZXQgZmxhdm9yKCkge1xuICAgIHJldHVybiB0aGlzLmlmQWN0aXZlLmN1cnJlbnQgPT09IHRoaXMuaWQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gVE9ETzogaWYgd2UgZmluZCBtb3JlIGNvbXBvbmVudHMgdGhhdCBjb3VsZCB1c2UgdGhpcywgY29uc2lkZXIgbW92aW5nIHRoaXMgdG8gdXRpbHNcbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBcmlhU2VydmljZSB7XG4gIHB1YmxpYyBhcmlhTGFiZWxsZWRCeTogc3RyaW5nO1xuICBwdWJsaWMgYXJpYUNvbnRyb2xzOiBzdHJpbmc7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJUYWIgfSBmcm9tICcuLi90YWInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGFic1NlcnZpY2Uge1xuICBwcml2YXRlIF9jaGlsZHJlbjogQ2xyVGFiW10gPSBbXTtcblxuICByZWdpc3Rlcih0YWI6IENsclRhYikge1xuICAgIHRoaXMuX2NoaWxkcmVuLnB1c2godGFiKTtcbiAgfVxuXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XG4gIH1cblxuICBnZXQgYWN0aXZlVGFiKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmZpbmQoKHRhYjogQ2xyVGFiKSA9PiB7XG4gICAgICByZXR1cm4gdGFiLmFjdGl2ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBvdmVyZmxvd1RhYnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZmlsdGVyKCh0YWI6IENsclRhYikgPT4ge1xuICAgICAgcmV0dXJuIHRhYi50YWJMaW5rLmluT3ZlcmZsb3cgPT09IHRydWU7XG4gICAgfSk7XG4gIH1cblxuICB1bnJlZ2lzdGVyKHRhYjogQ2xyVGFiKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YodGFiKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbmplY3QsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IEFyaWFTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYXJpYS5zZXJ2aWNlJztcblxubGV0IG5iVGFiQ29udGVudENvbXBvbmVudHM6IG51bWJlciA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10YWItY29udGVudCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAndGFiQ29udGVudElkJyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdhcmlhTGFiZWxsZWRCeScsXG4gICAgJ1thdHRyLmFyaWEtaGlkZGVuXSc6ICchYWN0aXZlJyxcbiAgICAnW2F0dHIuYXJpYS1leHBhbmRlZF0nOiAnYWN0aXZlJyxcbiAgICAnW2F0dHIuZGF0YS1oaWRkZW5dJzogJyFhY3RpdmUnLFxuICAgIHJvbGU6ICd0YWJwYW5lbCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYkNvbnRlbnQge1xuICBAVmlld0NoaWxkKCd0YWJDb250ZW50UHJvamVjdGVkUmVmJykgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPENsclRhYkNvbnRlbnQ+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBpZkFjdGl2ZVNlcnZpY2U6IElmQWN0aXZlU2VydmljZSxcbiAgICBASW5qZWN0KElGX0FDVElWRV9JRCkgcHVibGljIGlkOiBudW1iZXIsXG4gICAgcHJpdmF0ZSBhcmlhU2VydmljZTogQXJpYVNlcnZpY2VcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnRhYkNvbnRlbnRJZCkge1xuICAgICAgdGhpcy50YWJDb250ZW50SWQgPSAnY2xyLXRhYi1jb250ZW50LScgKyBuYlRhYkNvbnRlbnRDb21wb25lbnRzKys7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFyaWFMYWJlbGxlZEJ5KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUxhYmVsbGVkQnk7XG4gIH1cblxuICBnZXQgdGFiQ29udGVudElkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUNvbnRyb2xzO1xuICB9XG5cbiAgQElucHV0KCdpZCcpXG4gIHNldCB0YWJDb250ZW50SWQoaWQ6IHN0cmluZykge1xuICAgIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUNvbnRyb2xzID0gaWQ7XG4gIH1cblxuICBnZXQgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50ID09PSB0aGlzLmlkO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5sZXQgbmJUYWJzQ29tcG9uZW50ID0gMDtcblxuZXhwb3J0IGNvbnN0IFRBQlNfSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW48bnVtYmVyPignVEFCU19JRCcpO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5GYWN0b3J5KCkge1xuICByZXR1cm4gJ2Nsci10YWJzLScgKyBuYlRhYnNDb21wb25lbnQrKztcbn1cblxuZXhwb3J0IGNvbnN0IFRBQlNfSURfUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IFRBQlNfSUQsXG4gIHVzZUZhY3Rvcnk6IHRva2VuRmFjdG9yeSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSG9zdExpc3RlbmVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSUZfQUNUSVZFX0lELCBJZkFjdGl2ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuc2VydmljZSc7XG5pbXBvcnQgeyBUZW1wbGF0ZVJlZkNvbnRhaW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL3RlbXBsYXRlLXJlZi90ZW1wbGF0ZS1yZWYtY29udGFpbmVyJztcblxuaW1wb3J0IHsgQXJpYVNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9hcmlhLnNlcnZpY2UnO1xuaW1wb3J0IHsgVEFCU19JRCB9IGZyb20gJy4vdGFicy1pZC5wcm92aWRlcic7XG5cbmxldCBuYlRhYkxpbmtDb21wb25lbnRzOiBudW1iZXIgPSAwO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyVGFiTGlua10nLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAndGFiTGlua0lkJyxcbiAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnYWN0aXZlJyxcbiAgICAnW2F0dHIuYXJpYS1oaWRkZW5dJzogJ2ZhbHNlJyxcbiAgICAnW2F0dHIuYXJpYS1jb250cm9sc10nOiAnYXJpYUNvbnRyb2xzJyxcbiAgICAnW2NsYXNzLmJ0bl0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5idG4tbGlua10nOiAnIWluT3ZlcmZsb3cnLFxuICAgICdbY2xhc3MubmF2LWxpbmtdJzogJyFpbk92ZXJmbG93JyxcbiAgICAnW2NsYXNzLm5hdi1pdGVtXSc6ICchaW5PdmVyZmxvdycsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgcm9sZTogJ3RhYicsXG4gICAgdHlwZTogJ2J1dHRvbicsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYkxpbmsge1xuICBASW5wdXQoJ2NsclRhYkxpbmtJbk92ZXJmbG93JykgaW5PdmVyZmxvdzogYm9vbGVhbjtcbiAgdGVtcGxhdGVSZWZDb250YWluZXI6IFRlbXBsYXRlUmVmQ29udGFpbmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBpZkFjdGl2ZVNlcnZpY2U6IElmQWN0aXZlU2VydmljZSxcbiAgICBASW5qZWN0KElGX0FDVElWRV9JRCkgcHJpdmF0ZSBpZDogbnVtYmVyLFxuICAgIHByaXZhdGUgYXJpYVNlcnZpY2U6IEFyaWFTZXJ2aWNlLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgQEluamVjdChUQUJTX0lEKSBwdWJsaWMgdGFic0lkOiBudW1iZXJcbiAgKSB7XG4gICAgaWYgKCF0aGlzLnRhYkxpbmtJZCkge1xuICAgICAgdGhpcy50YWJMaW5rSWQgPSAnY2xyLXRhYi1saW5rLScgKyBuYlRhYkxpbmtDb21wb25lbnRzKys7XG4gICAgfVxuXG4gICAgLy8gVGFiIGxpbmtzIGNhbiBiZSByZW5kZXJlZCBpbiBvbmUgb2YgdHdvIHBsYWNlczogaW4gdGhlIG1haW4gYXJlYSBvciBpbnNpZGUgdGhlIG92ZXJmbG93IGRyb3Bkb3duIG1lbnUuXG4gICAgLy8gSGVyZSwgd2UgY3JlYXRlIGEgY29udGFpbmVyIHNvIHRoYXQgaXRzIHRlbXBsYXRlIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBlbWJlZGRlZFZpZXcgb24gdGhlIGZseS5cbiAgICAvLyBTZWUgVGFic1NlcnZpY2UncyByZW5kZXJWaWV3KCkgbWV0aG9kIGFuZCBob3cgaXQncyB1c2VkIGluIFRhYnMgY2xhc3MgZm9yIGFuIGV4YW1wbGUuXG4gICAgY29uc3QgZmFjdG9yeSA9IHRoaXMuY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFRlbXBsYXRlUmVmQ29udGFpbmVyKTtcbiAgICB0aGlzLnRlbXBsYXRlUmVmQ29udGFpbmVyID0gdGhpcy52aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5LCAxLCB1bmRlZmluZWQsIFtcbiAgICAgIFt0aGlzLmVsLm5hdGl2ZUVsZW1lbnRdLFxuICAgIF0pLmluc3RhbmNlO1xuICB9XG5cbiAgZ2V0IGFyaWFDb250cm9scygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFDb250cm9scztcbiAgfVxuXG4gIGdldCB0YWJMaW5rSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmlhU2VydmljZS5hcmlhTGFiZWxsZWRCeTtcbiAgfVxuXG4gIEBJbnB1dCgnaWQnKVxuICBzZXQgdGFiTGlua0lkKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFMYWJlbGxlZEJ5ID0gaWQ7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuaWZBY3RpdmVTZXJ2aWNlLmN1cnJlbnQgPSB0aGlzLmlkO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElGX0FDVElWRV9JRF9QUk9WSURFUiwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBBcmlhU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2FyaWEuc2VydmljZSc7XG5pbXBvcnQgeyBUYWJzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RhYnMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUYWJDb250ZW50IH0gZnJvbSAnLi90YWItY29udGVudCc7XG5pbXBvcnQgeyBDbHJUYWJMaW5rIH0gZnJvbSAnLi90YWItbGluay5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGFiJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIHByb3ZpZGVyczogW0lGX0FDVElWRV9JRF9QUk9WSURFUiwgQXJpYVNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUYWIge1xuICBAQ29udGVudENoaWxkKENsclRhYkxpbmspIHRhYkxpbms6IENsclRhYkxpbms7XG4gIEBDb250ZW50Q2hpbGQoQ2xyVGFiQ29udGVudCkgdGFiQ29udGVudDogQ2xyVGFiQ29udGVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgQEluamVjdChJRl9BQ1RJVkVfSUQpIHB1YmxpYyBpZDogbnVtYmVyLFxuICAgIHByaXZhdGUgdGFic1NlcnZpY2U6IFRhYnNTZXJ2aWNlXG4gICkge1xuICAgIHRhYnNTZXJ2aWNlLnJlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy50YWJzU2VydmljZS51bnJlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3RvciwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGFiLW92ZXJmbG93LWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZHJvcGRvd24tbWVudV0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYk92ZXJmbG93Q29udGVudCBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKGluamVjdG9yOiBJbmplY3RvciwgQFNraXBTZWxmKCkgcGFyZW50SG9zdDogRWxlbWVudFJlZikge1xuICAgIHN1cGVyKGluamVjdG9yLCBwYXJlbnRIb3N0KTtcbiAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX1JJR0hUO1xuICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgIHRoaXMuY2xvc2VPbk91dHNpZGVDbGljayA9IHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBJbmplY3QsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJZkFjdGl2ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuc2VydmljZSc7XG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuaW1wb3J0IHsgVGFic1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyVGFiTGluayB9IGZyb20gJy4vdGFiLWxpbmsuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRBQlNfSUQsIFRBQlNfSURfUFJPVklERVIgfSBmcm9tICcuL3RhYnMtaWQucHJvdmlkZXInO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRhYnMnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8dWwgY2xhc3M9XCJuYXZcIiByb2xlPVwidGFibGlzdFwiIFthdHRyLmFyaWEtb3duc109XCJ0YWJJZHNcIj5cbiAgICAgICAgICAgIDwhLS10YWIgbGlua3MtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGxpbmsgb2YgdGFiTGlua0RpcmVjdGl2ZXNcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibGluay50YWJzSWQgPT09IHRhYnNJZCAmJiAhbGluay5pbk92ZXJmbG93XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxpbmsudGVtcGxhdGVSZWZDb250YWluZXIudGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInRhYnNTZXJ2aWNlLm92ZXJmbG93VGFicy5sZW5ndGggPiAwXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYnMtb3ZlcmZsb3cgYm90dG9tLXJpZ2h0XCIgW2NsYXNzLm9wZW5dPVwiaWZPcGVuU2VydmljZS5vcGVuXCJcbiAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVPdmVyZmxvdygkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tbGluayBuYXYtbGluayBkcm9wZG93bi10b2dnbGVcIiB0eXBlPVwiYnV0dG9uXCIgW2NsYXNzLmFjdGl2ZV09XCJhY3RpdmVUYWJJbk92ZXJmbG93XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZWxsaXBzaXMtaG9yaXpvbnRhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MuaXMtaW5mb109XCJpZk9wZW5TZXJ2aWNlLm9wZW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5tb3JlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICA8IS0tdGFiIGxpbmtzIGluIG92ZXJmbG93IG1lbnUtLT5cbiAgICAgICAgICAgICAgICAgICAgPGNsci10YWItb3ZlcmZsb3ctY29udGVudD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGxpbmsgb2YgdGFiTGlua0RpcmVjdGl2ZXNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibGluay50YWJzSWQgPT09IHRhYnNJZCAmJiBsaW5rLmluT3ZlcmZsb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibGluay50ZW1wbGF0ZVJlZkNvbnRhaW5lci50ZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvY2xyLXRhYi1vdmVyZmxvdy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvdWw+XG4gICAgICAgIDwhLS10YWIgY29udGVudC0tPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgcHJvdmlkZXJzOiBbSWZBY3RpdmVTZXJ2aWNlLCBJZk9wZW5TZXJ2aWNlLCBUYWJzU2VydmljZSwgVEFCU19JRF9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYnMgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcbiAgQENvbnRlbnRDaGlsZHJlbihDbHJUYWJMaW5rLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pXG4gIHRhYkxpbmtEaXJlY3RpdmVzOiBRdWVyeUxpc3Q8Q2xyVGFiTGluaz47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIHB1YmxpYyBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHB1YmxpYyB0YWJzU2VydmljZTogVGFic1NlcnZpY2UsXG4gICAgQEluamVjdChUQUJTX0lEKSBwdWJsaWMgdGFic0lkOiBudW1iZXIsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7fVxuXG4gIGdldCBhY3RpdmVUYWJJbk92ZXJmbG93KCkge1xuICAgIHJldHVybiB0aGlzLnRhYnNTZXJ2aWNlLm92ZXJmbG93VGFicy5pbmRleE9mKHRoaXMudGFic1NlcnZpY2UuYWN0aXZlVGFiKSA+IC0xO1xuICB9XG5cbiAgZ2V0IHRhYklkcygpIHtcbiAgICByZXR1cm4gdGhpcy50YWJzU2VydmljZS5jaGlsZHJlbi5tYXAodGFiID0+IHRhYi50YWJMaW5rLnRhYkxpbmtJZCkuam9pbignICcpO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudGFiTGlua0RpcmVjdGl2ZXMuZmlyc3QuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVPdmVyZmxvdyhldmVudDogYW55KSB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLnRvZ2dsZVdpdGhFdmVudChldmVudCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vblBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJUZW1wbGF0ZVJlZk1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL3RlbXBsYXRlLXJlZi90ZW1wbGF0ZS1yZWYubW9kdWxlJztcblxuaW1wb3J0IHsgQWN0aXZlT29tcGFMb29tcGEgfSBmcm9tICcuL2Nob2NvbGF0ZS9hY3RpdmUtb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IFRhYnNXaWxseVdvbmthIH0gZnJvbSAnLi9jaG9jb2xhdGUvdGFicy13aWxseS13b25rYSc7XG5pbXBvcnQgeyBDbHJUYWIgfSBmcm9tICcuL3RhYic7XG5pbXBvcnQgeyBDbHJUYWJDb250ZW50IH0gZnJvbSAnLi90YWItY29udGVudCc7XG5pbXBvcnQgeyBDbHJUYWJMaW5rIH0gZnJvbSAnLi90YWItbGluay5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2xyVGFiT3ZlcmZsb3dDb250ZW50IH0gZnJvbSAnLi90YWItb3ZlcmZsb3ctY29udGVudCc7XG5pbXBvcnQgeyBDbHJUYWJzIH0gZnJvbSAnLi90YWJzJztcblxuZXhwb3J0IGNvbnN0IENMUl9UQUJTX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICBDbHJUYWJDb250ZW50LFxuICBDbHJUYWIsXG4gIENsclRhYnMsXG4gIENsclRhYk92ZXJmbG93Q29udGVudCxcbiAgQ2xyVGFiTGluayxcbiAgVGFic1dpbGx5V29ua2EsXG4gIEFjdGl2ZU9vbXBhTG9vbXBhLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSwgQ2xyQ29uZGl0aW9uYWxNb2R1bGUsIENsckljb25Nb2R1bGUsIENsclRlbXBsYXRlUmVmTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX1RBQlNfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfVEFCU19ESVJFQ1RJVkVTLCBDbHJDb25kaXRpb25hbE1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYnNNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmVydGljYWxOYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2Uge1xuICBwdWJsaWMgbmF2R3JvdXBDb3VudDogbnVtYmVyID0gMDtcblxuICByZWdpc3Rlck5hdkdyb3VwKCkge1xuICAgIHRoaXMubmF2R3JvdXBDb3VudCsrO1xuICB9XG5cbiAgdW5yZWdpc3Rlck5hdkdyb3VwKCk6IHZvaWQge1xuICAgIHRoaXMubmF2R3JvdXBDb3VudC0tO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTmF2SWNvblNlcnZpY2Uge1xuICBwcml2YXRlIF9pY29uczogbnVtYmVyID0gMDtcblxuICBnZXQgaGFzSWNvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ljb25zID4gMDtcbiAgfVxuXG4gIHJlZ2lzdGVySWNvbigpOiB2b2lkIHtcbiAgICB0aGlzLl9pY29ucysrO1xuICB9XG5cbiAgdW5yZWdpc3Rlckljb24oKTogdm9pZCB7XG4gICAgdGhpcy5faWNvbnMtLTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWZXJ0aWNhbE5hdlNlcnZpY2Uge1xuICBwcml2YXRlIF9hbmltYXRlT25Db2xsYXBzZWQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGdldCBhbmltYXRlT25Db2xsYXBzZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdGVPbkNvbGxhcHNlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NvbGxhcHNlZENoYW5nZWQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGdldCBjb2xsYXBzZWRDaGFuZ2VkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWRDaGFuZ2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29sbGFwc2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZ2V0IGNvbGxhcHNlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VkO1xuICB9XG5cbiAgc2V0IGNvbGxhcHNlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5jb2xsYXBzaWJsZSAmJiB0aGlzLl9jb2xsYXBzZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbGxhcHNlQmVoYXZpb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NvbGxhcHNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZ2V0IGNvbGxhcHNpYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzaWJsZTtcbiAgfVxuXG4gIHNldCBjb2xsYXBzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5fY29sbGFwc2libGUgIT09IHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlICYmIHRoaXMuY29sbGFwc2VkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ29sbGFwc2VCZWhhdmlvcihmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb2xsYXBzaWJsZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ29sbGFwc2VCZWhhdmlvcih2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuX2FuaW1hdGVPbkNvbGxhcHNlZC5uZXh0KHZhbHVlKTtcbiAgICB0aGlzLl9jb2xsYXBzZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl9jb2xsYXBzZWRDaGFuZ2VkLm5leHQodmFsdWUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1ncm91cC1yZWdpc3RyYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWljb24uc2VydmljZSc7XG5pbXBvcnQgeyBWZXJ0aWNhbE5hdlNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdmVydGljYWwtbmF2JyxcbiAgdGVtcGxhdGVVcmw6ICcuL3ZlcnRpY2FsLW5hdi5odG1sJyxcbiAgcHJvdmlkZXJzOiBbVmVydGljYWxOYXZTZXJ2aWNlLCBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlLCBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZV0sXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ2Nsci12ZXJ0aWNhbC1uYXYnLFxuICAgICdbY2xhc3MuaXMtY29sbGFwc2VkXSc6ICdjb2xsYXBzZWQnLFxuICAgICdbY2xhc3MuaGFzLW5hdi1ncm91cHNdJzogJ2hhc05hdkdyb3VwcycsXG4gICAgJ1tjbGFzcy5oYXMtaWNvbnNdJzogJ2hhc0ljb25zJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXYgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBnZXQgY29sbGFwc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2libGU7XG4gIH1cblxuICBASW5wdXQoJ2NsclZlcnRpY2FsTmF2Q29sbGFwc2libGUnKVxuICBzZXQgY29sbGFwc2libGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNpYmxlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyVmVydGljYWxOYXZDb2xsYXBzZWQnKVxuICBzZXQgY29sbGFwc2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsclZlcnRpY2FsTmF2Q29sbGFwc2VkQ2hhbmdlJylcbiAgcHJpdmF0ZSBfY29sbGFwc2VkQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBnZXQgaGFzTmF2R3JvdXBzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UubmF2R3JvdXBDb3VudCA+IDA7XG4gIH1cblxuICBnZXQgaGFzSWNvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdkljb25TZXJ2aWNlLmhhc0ljb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBfc3ViOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfbmF2U2VydmljZTogVmVydGljYWxOYXZTZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdkljb25TZXJ2aWNlOiBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZTogVmVydGljYWxOYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7XG4gICAgdGhpcy5fc3ViID0gdGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWRDaGFuZ2VkLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICB0aGlzLl9jb2xsYXBzZWRDaGFuZ2VkLmVtaXQodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgdG9nZ2xlQnlCdXR0b24oKSB7XG4gICAgdGhpcy5jb2xsYXBzZWQgPSAhdGhpcy5jb2xsYXBzZWQ7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdWIudW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWZXJ0aWNhbE5hdkdyb3VwU2VydmljZSB7XG4gIHByaXZhdGUgX2V4cGFuZENoYW5nZTogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgZ2V0IGV4cGFuZENoYW5nZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fZXhwYW5kQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgZXhwYW5kKCk6IHZvaWQge1xuICAgIHRoaXMuX2V4cGFuZENoYW5nZS5uZXh0KHRydWUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbkV2ZW50LCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuXG5pbXBvcnQgeyBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1ncm91cC1yZWdpc3RyYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBWZXJ0aWNhbE5hdkdyb3VwU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbmNvbnN0IEVYUEFOREVEX1NUQVRFOiBzdHJpbmcgPSAnZXhwYW5kZWQnO1xuY29uc3QgQ09MTEFQU0VEX1NUQVRFOiBzdHJpbmcgPSAnY29sbGFwc2VkJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXZlcnRpY2FsLW5hdi1ncm91cCcsXG4gIHRlbXBsYXRlVXJsOiAnLi92ZXJ0aWNhbC1uYXYtZ3JvdXAuaHRtbCcsXG4gIHByb3ZpZGVyczogW0V4cGFuZCwgVmVydGljYWxOYXZHcm91cFNlcnZpY2VdLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignY2xyRXhwYW5kJywgW1xuICAgICAgc3RhdGUoRVhQQU5ERURfU1RBVEUsIHN0eWxlKHsgaGVpZ2h0OiAnKicgfSkpLFxuICAgICAgc3RhdGUoQ09MTEFQU0VEX1NUQVRFLCBzdHlsZSh7IGhlaWdodDogMCwgJ292ZXJmbG93LXknOiAnaGlkZGVuJywgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSkpLFxuICAgICAgdHJhbnNpdGlvbihgJHtFWFBBTkRFRF9TVEFURX0gPD0+ICR7Q09MTEFQU0VEX1NUQVRFfWAsIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKSksXG4gICAgXSksXG4gIF0sXG4gIGhvc3Q6IHsgY2xhc3M6ICduYXYtZ3JvdXAnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclZlcnRpY2FsTmF2R3JvdXAgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9pdGVtRXhwYW5kOiBFeHBhbmQsXG4gICAgcHJpdmF0ZSBfbmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlOiBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9uYXZHcm91cFNlcnZpY2U6IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdlNlcnZpY2U6IFZlcnRpY2FsTmF2U2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICB0aGlzLl9uYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UucmVnaXN0ZXJOYXZHcm91cCgpO1xuXG4gICAgLy8gRklYTUU6IFRoaXMgc3Vic2NyaXB0aW9uIGhhbmRsZXMgYSBjb3JuZXIgY2FzZVxuICAgIC8vIFZlcnRpY2FsIE5hdiBjb2xsYXBzZSByZXF1aXJlcyB0aGUgYW5pbWF0aW9uIHRvIHJ1biBmaXJzdCBhbmQgdGhlblxuICAgIC8vIHJlbW92ZSB0aGUgbm9kZXMgZnJvbSB0aGUgRE9NLiBJZiB0aGUgdXNlciBkaXJlY3RseSBzZXRzIHRoZSBpbnB1dFxuICAgIC8vIG9uIHRoZSBjbHJJZkV4cGFuZGVkIGRpcmVjdGl2ZSwgd2UgaGF2ZSBubyBjaGFuY2UgdG8gcnVuIHRoZSBhbmltYXRpb25cbiAgICAvLyBhbmQgd2FpdCBmb3IgaXQgdG8gY29tcGxldGUuIFRoaXMgc3Vic2NyaXB0aW9uIG1ha2VzIHN1cmUgdGhhdCB0aGVcbiAgICAvLyBhbmltYXRpb24gc3RhdGVzIGFyZSBjb3JyZWN0IGZvciB0aGF0IGVkZ2UgY2FzZS5cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9pdGVtRXhwYW5kLmV4cGFuZENoYW5nZS5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9PT0gQ09MTEFQU0VEX1NUQVRFKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gRVhQQU5ERURfU1RBVEU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPT09IEVYUEFOREVEX1NUQVRFKSB7XG4gICAgICAgICAgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9IENPTExBUFNFRF9TVEFURTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gMS4gSWYgdGhlIG5hdiBpcyBjb2xsYXBzaW5nLCBjbG9zZSB0aGUgb3BlbiBuYXYgZ3JvdXAgKyBzYXZlIGl0cyBzdGF0ZVxuICAgIC8vIDIuIElmIHRoZSBuYXYgaXMgZXhwYW5kaW5nLCBleHBhbmQgdGhlIG5hdiBncm91cCBpZiB0aGUgcHJldmlvdXMgc3RhdGUgd2FzIGV4cGFuZGVkXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5fbmF2U2VydmljZS5hbmltYXRlT25Db2xsYXBzZWQuc3Vic2NyaWJlKChnb2luZ1RvQ29sbGFwc2U6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGdvaW5nVG9Db2xsYXBzZSAmJiB0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgdGhpcy53YXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9IENPTExBUFNFRF9TVEFURTtcbiAgICAgICAgfSBlbHNlIGlmICghZ29pbmdUb0NvbGxhcHNlICYmIHRoaXMud2FzRXhwYW5kZWQpIHtcbiAgICAgICAgICB0aGlzLmV4cGFuZEdyb3VwKCk7XG4gICAgICAgICAgdGhpcy53YXNFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBJZiBhIGxpbmsgaXMgY2xpY2tlZCwgZXhwYW5kIHRoZSBuYXYgZ3JvdXBcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9uYXZHcm91cFNlcnZpY2UuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSgoZXhwYW5kOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChleHBhbmQgJiYgIXRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICB0aGlzLmV4cGFuZEdyb3VwKCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgd2FzRXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlzLWV4cGFuZGVkJylcbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pdGVtRXhwYW5kLmV4cGFuZGVkO1xuICB9XG5cbiAgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1FeHBhbmQuZXhwYW5kZWQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9pdGVtRXhwYW5kLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIEBJbnB1dCgnY2xyVmVydGljYWxOYXZHcm91cEV4cGFuZGVkJylcbiAgc2V0IHVzZXJFeHBhbmRlZElucHV0KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh0aGlzLmV4cGFuZGVkICE9PSB2YWx1ZSkge1xuICAgICAgLy8gV2UgaGF2ZSB0byBjYWxsIHRvZ2dsZUV4cGFuZCBiZWNhdXNlIHNvbWUgY2FzZXMgcmVxdWlyZSBhbmltYXRpb25zIHRvIG9jY3VyIGZpcnN0XG4gICAgICAvLyBEaXJlY3RseSBzZXR0aW5nIHRoZSBFeHBhbmQgc2VydmljZSB2YWx1ZSBza2lwcyB0aGUgYW5pbWF0aW9uIGFuZCBjYW4gcmVzdWx0IGluXG4gICAgICAvLyBub2RlcyBpbiB0aGUgRE9NIGJ1dCB0aGUgbmF2IGdyb3VwIHN0aWxsIGJlaW5nIGNvbGxhcHNlZFxuICAgICAgdGhpcy50b2dnbGVFeHBhbmQoKTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJWZXJ0aWNhbE5hdkdyb3VwRXhwYW5kZWRDaGFuZ2UnKSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIHByaXZhdGUgX2V4cGFuZEFuaW1hdGlvblN0YXRlOiBzdHJpbmcgPSBDT0xMQVBTRURfU1RBVEU7XG5cbiAgZXhwYW5kR3JvdXAoKTogdm9pZCB7XG4gICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgLy8gRXhwYW5kZWQgYW5pbWF0aW9uIG9jY3VycyBhZnRlciBFeHBhbmQuZXhwYW5kIGlzIHNldCB0byB0cnVlXG4gICAgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9IEVYUEFOREVEX1NUQVRFO1xuICB9XG5cbiAgY29sbGFwc2VHcm91cCgpOiB2b2lkIHtcbiAgICAvLyBJZiBhIFZlcnRpY2FsIE5hdiBHcm91cCB0b2dnbGUgYnV0dG9uIGlzIGNsaWNrZWQgd2hpbGUgdGhlIFZlcnRpY2FsIE5hdiBpcyBpbiBDb2xsYXBzZWQgc3RhdGUsXG4gICAgLy8gdGhlIFZlcnRpY2FsIE5hdiBzaG91bGQgYmUgZXhwYW5kZWQgZmlyc3QuXG4gICAgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9IENPTExBUFNFRF9TVEFURTtcbiAgfVxuXG4gIC8vIGNsb3NlcyBhIGdyb3VwIGFmdGVyIHRoZSBjb2xsYXBzZSBhbmltYXRpb25cbiAgZXhwYW5kQW5pbWF0aW9uRG9uZSgkZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgaWYgKCRldmVudC50b1N0YXRlID09PSBDT0xMQVBTRURfU1RBVEUpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBnZXQgZXhwYW5kQW5pbWF0aW9uU3RhdGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwYW5kQW5pbWF0aW9uU3RhdGU7XG4gIH1cblxuICBzZXQgZXhwYW5kQW5pbWF0aW9uU3RhdGUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fZXhwYW5kQW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgIHRoaXMuX2V4cGFuZEFuaW1hdGlvblN0YXRlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlRXhwYW5kKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICB0aGlzLmNvbGxhcHNlR3JvdXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbmF2IGlzIGNvbGxhc3BlZCwgZmlyc3Qgb3BlbiB0aGUgbmF2XG4gICAgICBpZiAodGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgdGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHRoZW4gZXhwYW5kIHRoZSBuYXYgZ3JvdXBcbiAgICAgIHRoaXMuZXhwYW5kR3JvdXAoKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgaWYgc29tZW9uZSBtYXJrcyBhIG5hdiBncm91cCBleHBhbmRlZCBpbiBhIGNvbGxhcHNlZCBuYXZcbiAgICAvLyB0aGUgZXhwYW5kZWQgcHJvcGVydHkgaXMgc3dpdGNoZWQgYmFjayB0byBjb2xsYXBzZWQgc3RhdGUuXG4gICAgaWYgKHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkICYmIHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgIHRoaXMud2FzRXhwYW5kZWQgPSB0cnVlO1xuICAgICAgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9IENPTExBUFNFRF9TVEFURTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5fbmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlLnVucmVnaXN0ZXJOYXZHcm91cCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdmVydGljYWwtbmF2LWdyb3VwLWNoaWxkcmVuJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsclZlcnRpY2FsTmF2R3JvdXBDaGlsZHJlbiB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2SWNvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtaWNvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclZlcnRpY2FsTmF2SWNvbl0nLCBob3N0OiB7IGNsYXNzOiAnbmF2LWljb24nIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJWZXJ0aWNhbE5hdkljb24gaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF92ZXJ0aWNhbE5hdkljb25TZXJ2aWNlOiBWZXJ0aWNhbE5hdkljb25TZXJ2aWNlKSB7XG4gICAgdGhpcy5fdmVydGljYWxOYXZJY29uU2VydmljZS5yZWdpc3Rlckljb24oKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3ZlcnRpY2FsTmF2SWNvblNlcnZpY2UudW5yZWdpc3Rlckljb24oKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0TGlzdGVuZXIsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBWZXJ0aWNhbE5hdkdyb3VwU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1ncm91cC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW2NsclZlcnRpY2FsTmF2TGlua10nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyVmVydGljYWxOYXZJY29uXVwiPjwvbmctY29udGVudD5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJuYXYtdGV4dFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiAgICBcbiAgICAgICAgPC9zcGFuPlxuICAgIGAsXG4gIGhvc3Q6IHsgY2xhc3M6ICduYXYtbGluaycgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZMaW5rIHtcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSBfbmF2R3JvdXBTZXJ2aWNlOiBWZXJ0aWNhbE5hdkdyb3VwU2VydmljZSkge31cblxuICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gIHB1YmxpYyBleHBhbmRQYXJlbnROYXZHcm91cCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fbmF2R3JvdXBTZXJ2aWNlKSB7XG4gICAgICB0aGlzLl9uYXZHcm91cFNlcnZpY2UuZXhwYW5kKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJZkV4cGFuZE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2V4cGFuZC9pZi1leHBhbmQubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyVmVydGljYWxOYXYgfSBmcm9tICcuL3ZlcnRpY2FsLW5hdic7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdkdyb3VwIH0gZnJvbSAnLi92ZXJ0aWNhbC1uYXYtZ3JvdXAnO1xuaW1wb3J0IHsgQ2xyVmVydGljYWxOYXZHcm91cENoaWxkcmVuIH0gZnJvbSAnLi92ZXJ0aWNhbC1uYXYtZ3JvdXAtY2hpbGRyZW4nO1xuaW1wb3J0IHsgQ2xyVmVydGljYWxOYXZJY29uIH0gZnJvbSAnLi92ZXJ0aWNhbC1uYXYtaWNvbic7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdkxpbmsgfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi1saW5rJztcblxuZXhwb3J0IGNvbnN0IENMUl9WRVJUSUNBTF9OQVZfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbXG4gIENsclZlcnRpY2FsTmF2LFxuICBDbHJWZXJ0aWNhbE5hdkxpbmssXG4gIENsclZlcnRpY2FsTmF2R3JvdXAsXG4gIENsclZlcnRpY2FsTmF2R3JvdXBDaGlsZHJlbixcbiAgQ2xyVmVydGljYWxOYXZJY29uLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xySWZFeHBhbmRNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfVkVSVElDQUxfTkFWX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1ZFUlRJQ0FMX05BVl9ESVJFQ1RJVkVTLCBDbHJJZkV4cGFuZE1vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclZlcnRpY2FsTmF2TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJNYWluQ29udGFpbmVyTW9kdWxlIH0gZnJvbSAnLi9tYWluLWNvbnRhaW5lci9tYWluLWNvbnRhaW5lci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTmF2aWdhdGlvbk1vZHVsZSB9IGZyb20gJy4vbmF2L25hdmlnYXRpb24ubW9kdWxlJztcbmltcG9ydCB7IENsclRhYnNNb2R1bGUgfSBmcm9tICcuL3RhYnMvdGFicy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVmVydGljYWxOYXZNb2R1bGUgfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYubW9kdWxlJztcblxuQE5nTW9kdWxlKHsgZXhwb3J0czogW0Nsck1haW5Db250YWluZXJNb2R1bGUsIENsck5hdmlnYXRpb25Nb2R1bGUsIENsclRhYnNNb2R1bGUsIENsclZlcnRpY2FsTmF2TW9kdWxlXSB9KVxuZXhwb3J0IGNsYXNzIENsckxheW91dE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTY3JvbGxpbmdTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSkge31cblxuICBzdG9wU2Nyb2xsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuX2RvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnbm8tc2Nyb2xsaW5nJyk7XG4gIH1cblxuICByZXN1bWVTY3JvbGxpbmcoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2RvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmNvbnRhaW5zKCduby1zY3JvbGxpbmcnKSkge1xuICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCduby1zY3JvbGxpbmcnKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbkV2ZW50LCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RCaW5kaW5nLFxuICBIb3N0TGlzdGVuZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2UsXG4gIFZpZXdDaGlsZCxcbiAgSW5qZWN0LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRm9jdXNUcmFwRGlyZWN0aXZlIH0gZnJvbSAnLi4vdXRpbHMvZm9jdXMtdHJhcC9mb2N1cy10cmFwLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTY3JvbGxpbmdTZXJ2aWNlIH0gZnJvbSAnLi4vdXRpbHMvc2Nyb2xsaW5nL3Njcm9sbGluZy1zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBVTklRVUVfSUQsIFVOSVFVRV9JRF9QUk9WSURFUiB9IGZyb20gJy4uL3V0aWxzL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1tb2RhbCcsXG4gIHZpZXdQcm92aWRlcnM6IFtTY3JvbGxpbmdTZXJ2aWNlXSxcbiAgdGVtcGxhdGVVcmw6ICcuL21vZGFsLmh0bWwnLFxuICBzdHlsZXM6IFtcbiAgICBgXG4gICAgICAgIDpob3N0IHsgZGlzcGxheTogbm9uZTsgfVxuICAgICAgICA6aG9zdC5vcGVuIHsgZGlzcGxheTogaW5saW5lOyB9XG4gICAgYCxcbiAgXSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ2ZhZGVEb3duJywgW1xuICAgICAgdHJhbnNpdGlvbignKiA9PiBmYWxzZScsIFtzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAtMjUlKScgfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKV0pLFxuICAgICAgdHJhbnNpdGlvbignZmFsc2UgPT4gKicsIFthbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoMCwgLTI1JSknIH0pKV0pLFxuICAgIF0pLFxuICAgIHRyaWdnZXIoJ2ZhZGUnLCBbXG4gICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbc3R5bGUoeyBvcGFjaXR5OiAwIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwLjg1IH0pKV0pLFxuICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXSksXG4gICAgXSksXG4gIF0sXG4gIHByb3ZpZGVyczogW1VOSVFVRV9JRF9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIENsck1vZGFsIGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICBAVmlld0NoaWxkKEZvY3VzVHJhcERpcmVjdGl2ZSkgZm9jdXNUcmFwOiBGb2N1c1RyYXBEaXJlY3RpdmU7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5vcGVuJylcbiAgQElucHV0KCdjbHJNb2RhbE9wZW4nKVxuICBfb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICBAT3V0cHV0KCdjbHJNb2RhbE9wZW5DaGFuZ2UnKSBfb3BlbkNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIEBJbnB1dCgnY2xyTW9kYWxDbG9zYWJsZScpIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCdjbHJNb2RhbFNpemUnKSBzaXplOiBzdHJpbmc7XG4gIEBJbnB1dCgnY2xyTW9kYWxTdGF0aWNCYWNrZHJvcCcpIHN0YXRpY0JhY2tkcm9wOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgnY2xyTW9kYWxTa2lwQW5pbWF0aW9uJykgc2tpcEFuaW1hdGlvbjogc3RyaW5nID0gJ2ZhbHNlJztcblxuICAvLyBwcmVzZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgYnkgd2l6YXJkc1xuICBASW5wdXQoJ2Nsck1vZGFsT3ZlcnJpZGVTY3JvbGxTZXJ2aWNlJykgYnlwYXNzU2Nyb2xsU2VydmljZTogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoJ2Nsck1vZGFsUHJldmVudENsb3NlJykgc3RvcENsb3NlOiBib29sZWFuID0gZmFsc2U7XG4gIEBPdXRwdXQoJ2Nsck1vZGFsQWx0ZXJuYXRlQ2xvc2UnKSBhbHRDbG9zZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc2Nyb2xsaW5nU2VydmljZTogU2Nyb2xsaW5nU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncyxcbiAgICBASW5qZWN0KFVOSVFVRV9JRCkgcHVibGljIG1vZGFsSWQ6IHN0cmluZ1xuICApIHt9XG5cbiAgZ2V0IHNpemVDbGFzcygpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIHJldHVybiAnbW9kYWwtJyArIHRoaXMuc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIERldGVjdCB3aGVuIF9vcGVuIGlzIHNldCB0byB0cnVlIGFuZCBzZXQgbm8tc2Nyb2xsaW5nIHRvIHRydWVcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmJ5cGFzc1Njcm9sbFNlcnZpY2UgJiYgY2hhbmdlcyAmJiBjaGFuZ2VzLmhhc093blByb3BlcnR5KCdfb3BlbicpKSB7XG4gICAgICBpZiAoY2hhbmdlcy5fb3Blbi5jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsaW5nU2VydmljZS5zdG9wU2Nyb2xsaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zY3JvbGxpbmdTZXJ2aWNlLnJlc3VtZVNjcm9sbGluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3Njcm9sbGluZ1NlcnZpY2UucmVzdW1lU2Nyb2xsaW5nKCk7XG4gIH1cblxuICBvcGVuKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9vcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgIHRoaXMuX29wZW5DaGFuZ2VkLmVtaXQodHJ1ZSk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdib2R5OmtleXVwLmVzY2FwZScpXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN0b3BDbG9zZSkge1xuICAgICAgdGhpcy5hbHRDbG9zZS5lbWl0KGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNsb3NhYmxlIHx8ICF0aGlzLl9vcGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICAvLyB0b2RvOiByZW1vdmUgdGhpcyBhZnRlciBhbmltYXRpb24gYnVnIGlzIGZpeGVkIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE1Nzk4XG4gICAgLy8gdGhpcyB3YXMgaGFuZGxlZCBieSB0aGUgZmFkZURvbmUgZXZlbnQgYmVsb3csIGJ1dCB0aGF0IEFuaW1hdGlvbkV2ZW50IGlzIG5vdCBmaXJpbmcgaW4gQW5ndWxhciA0LjAuXG4gICAgdGhpcy5fb3BlbkNoYW5nZWQuZW1pdChmYWxzZSk7XG4gICAgLy8gU1BFQ01FXG4gICAgdGhpcy5mb2N1c1RyYXAuc2V0UHJldmlvdXNGb2N1cygpOyAvLyBIYW5kbGVzIG1vdmluZyBmb2N1cyBiYWNrIHRvIHRoZSBlbGVtZW50IHRoYXQgaGFkIGl0IGJlZm9yZS5cbiAgfVxuXG4gIGZhZGVEb25lKGU6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgaWYgKGUudG9TdGF0ZSA9PT0gJ3ZvaWQnKSB7XG4gICAgICB0aGlzLl9vcGVuQ2hhbmdlZC5lbWl0KGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckZvY3VzVHJhcE1vZHVsZSB9IGZyb20gJy4uL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTW9kYWwgfSBmcm9tICcuL21vZGFsJztcblxuZXhwb3J0IGNvbnN0IENMUl9NT0RBTF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJNb2RhbF07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGUsIENsckZvY3VzVHJhcE1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9NT0RBTF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9NT0RBTF9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTW9kYWxNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFBvc2l0aW9uIHtcbiAgYW5jaG9yUG9pbnQ6IFBvaW50O1xuICBwb3BvdmVyUG9pbnQ6IFBvaW50O1xuICBvZmZzZXRZOiBudW1iZXI7XG4gIG9mZnNldFg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNvbnN0IFNJR05QT1NUX1BPU0lUSU9OUzogeyBbaW5wdXQ6IHN0cmluZ106IFBvc2l0aW9uIH0gPSB7XG4gICd0b3AtbGVmdCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlRPUF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuQk9UVE9NX1JJR0hULCBvZmZzZXRZOiAtMTAsIG9mZnNldFg6IDAgfSxcbiAgJ3RvcC1taWRkbGUnOiB7IGFuY2hvclBvaW50OiBQb2ludC5UT1BfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkJPVFRPTV9DRU5URVIsIG9mZnNldFk6IC0xMCwgb2Zmc2V0WDogMCB9LFxuICAndG9wLXJpZ2h0JzogeyBhbmNob3JQb2ludDogUG9pbnQuVE9QX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5CT1RUT01fTEVGVCwgb2Zmc2V0WTogLTEwLCBvZmZzZXRYOiAwIH0sXG4gICdyaWdodC10b3AnOiB7IGFuY2hvclBvaW50OiBQb2ludC5SSUdIVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuTEVGVF9CT1RUT00sIG9mZnNldFk6IDIsIG9mZnNldFg6IDE0IH0sXG4gICdyaWdodC1taWRkbGUnOiB7IGFuY2hvclBvaW50OiBQb2ludC5SSUdIVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuTEVGVF9DRU5URVIsIG9mZnNldFk6IDYsIG9mZnNldFg6IDE0IH0sXG4gICdyaWdodC1ib3R0b20nOiB7IGFuY2hvclBvaW50OiBQb2ludC5SSUdIVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuTEVGVF9UT1AsIG9mZnNldFk6IC0xLCBvZmZzZXRYOiAxNCB9LFxuICAnYm90dG9tLXJpZ2h0JzogeyBhbmNob3JQb2ludDogUG9pbnQuQk9UVE9NX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5UT1BfTEVGVCwgb2Zmc2V0WTogOSwgb2Zmc2V0WDogLTEgfSxcbiAgJ2JvdHRvbS1taWRkbGUnOiB7IGFuY2hvclBvaW50OiBQb2ludC5CT1RUT01fQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LlRPUF9DRU5URVIsIG9mZnNldFk6IDksIG9mZnNldFg6IDEyIH0sXG4gICdib3R0b20tbGVmdCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LkJPVFRPTV9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuVE9QX1JJR0hULCBvZmZzZXRZOiA5LCBvZmZzZXRYOiAwIH0sXG4gICdsZWZ0LWJvdHRvbSc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LkxFRlRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LlJJR0hUX1RPUCwgb2Zmc2V0WTogMCwgb2Zmc2V0WDogLTE0IH0sXG4gICdsZWZ0LW1pZGRsZSc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LkxFRlRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LlJJR0hUX0NFTlRFUiwgb2Zmc2V0WTogNCwgb2Zmc2V0WDogLTE0IH0sXG4gICdsZWZ0LXRvcCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LkxFRlRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LlJJR0hUX0JPVFRPTSwgb2Zmc2V0WTogMCwgb2Zmc2V0WDogLTE0IH0sXG4gIGRlZmF1bHQ6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlJJR0hUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgb2Zmc2V0WTogNiwgb2Zmc2V0WDogMTQgfSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0b3IsIElucHV0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBBYnN0cmFjdFBvcG92ZXIgfSBmcm9tICcuLi9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQT1BPVkVSX0hPU1RfQU5DSE9SIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4nO1xuXG5pbXBvcnQgeyBTSUdOUE9TVF9QT1NJVElPTlMgfSBmcm9tICcuL3NpZ25wb3N0LXBvc2l0aW9ucyc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG4vLyBha2Egd2hlcmUgdGhlIGFycm93IC8gcG9pbnRlciBpcyBhdCBpbiByZWxhdGlvbiB0byB0aGUgYW5jaG9yXG5jb25zdCBQT1NJVElPTlM6IHN0cmluZ1tdID0gW1xuICAndG9wLWxlZnQnLFxuICAndG9wLW1pZGRsZScsXG4gICd0b3AtcmlnaHQnLFxuICAncmlnaHQtdG9wJyxcbiAgJ3JpZ2h0LW1pZGRsZScsIC8vIGRlZmF1bHRcbiAgJ3JpZ2h0LWJvdHRvbScsXG4gICdib3R0b20tcmlnaHQnLFxuICAnYm90dG9tLW1pZGRsZScsXG4gICdib3R0b20tbGVmdCcsXG4gICdsZWZ0LWJvdHRvbScsXG4gICdsZWZ0LW1pZGRsZScsXG4gICdsZWZ0LXRvcCcsXG5dO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc2lnbnBvc3QtY29udGVudCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzaWducG9zdC1mbGV4LXdyYXBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyLXBvaW50ZXJcIj48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzaWducG9zdC1jb250ZW50LWhlYWRlclwiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwic2lnbnBvc3QtYWN0aW9uIGNsb3NlXCIgKGNsaWNrKT1cImNsb3NlKClcIj5cbiAgICAgICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2xvc2VcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmNsb3NlXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNpZ25wb3N0LWNvbnRlbnQtYm9keVwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3Muc2lnbnBvc3QtY29udGVudF0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU2lnbnBvc3RDb250ZW50IGV4dGVuZHMgQWJzdHJhY3RQb3BvdmVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChQT1BPVkVSX0hPU1RfQU5DSE9SKVxuICAgIHBhcmVudEhvc3Q6IEVsZW1lbnRSZWYsXG4gICAgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICBpZiAoIXBhcmVudEhvc3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyLXNpZ25wb3N0LWNvbnRlbnQgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItc2lnbnBvc3QnKTtcbiAgICB9XG4gICAgc3VwZXIoaW5qZWN0b3IsIHBhcmVudEhvc3QpO1xuICAgIHRoaXMuY29tbW9uU3RyaW5ncyA9IGNvbW1vblN0cmluZ3M7XG4gICAgLy8gRGVmYXVsdHNcbiAgICB0aGlzLnBvc2l0aW9uID0gJ3JpZ2h0LW1pZGRsZSc7XG4gICAgdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3M7XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENsb3NlIGZ1bmN0aW9uIHRoYXQgdXNlcyB0aGUgc2lnbnBvc3QgaW5zdGFuY2UgdG8gdG9nZ2xlIHRoZSBzdGF0ZSBvZiB0aGUgY29udGVudCBwb3BvdmVyLlxuICAgKlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgfVxuXG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBzdHJpbmc7XG5cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgc2V0dGVyIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIENsclNpZ25wb3N0Q29udGVudCBwb3BvdmVyLiBUaGlzIGlzIGEgY29tYmluYXRpb24gb2YgdGhlIGZvbGxvd2luZzpcbiAgICogLSBhbmNob3JQb2ludCAtIHdoZXJlIG9uIHRoZSB0cmlnZ2VyIHRvIGFuY2hvciB0aGUgQ2xyU2lnbnBvc3RDb250ZW50XG4gICAqIC0gcG9wb3ZlclBvaW50IC0gd2hlcmUgb24gdGhlIENsclNpZ25wb3N0Q29udGVudCBjb250YWluZXIgdG8gYWxpZ24gd2l0aCB0aGUgYW5jaG9yUG9pbnRcbiAgICogLSBvZmZzZXRZIC0gd2hlcmUgb24gdGhlIFkgYXhpcyB0byBhbGlnbiB0aGUgQ2xyU2lnbnBvc3RDb250ZW50IHNvIGl0IG1lZXRzIHNwZWNzXG4gICAqIC0gb2Zmc2V0WCAtIHdoZXJlIG9uIHRoZSBYIGF4aXMgdG8gYWxpZ24gdGhlIENsclNpZ25wb3N0Q29udGVudCBzbyBpdCBtZWV0cyBzcGVjc1xuICAgKiBUaGVyZSBhcmUgMTIgcG9zc2libGUgcG9zaXRpb25zIHRvIHBsYWNlIGEgQ2xyU2lnbnBvc3RDb250ZW50IGNvbnRhaW5lcjpcbiAgICogLSB0b3AtbGVmdFxuICAgKiAtIHRvcC1taWRkbGVcbiAgICogLSB0b3AtcmlnaHRcbiAgICogLSByaWdodC10b3BcbiAgICogLSByaWdodC1taWRkbGVcbiAgICogLSByaWdodC1ib3R0b21cbiAgICogLSBib3R0b20tcmlnaHRcbiAgICogLSBib3R0b20tbWlkZGxlXG4gICAqIC0gYm90dG9tLWxlZnRcbiAgICogLSBsZWZ0LWJvdHRvbVxuICAgKiAtIGxlZnQtbWlkZGxlXG4gICAqIC0gbGVmdC10b3BcbiAgICpcbiAgICogSSB0aGluayBvZiBpdCBhcyBmb2xsb3dzIGZvciAndG9wLWxlZnQnIC0+IENPTlRBSU5FUl9TSURFLVNJREVfUE9TSVRJT04uIEluIHRoaXMgY2FzZSBDT05UQUlORVJfU0lERSBpcyAndG9wJ1xuICAgKiBtZWFuaW5nIHRoZSB0b3Agb2YgdGhlIHRyaWdnZXIgaWNvbiAoYWJvdmUgdGhlIGljb24gdGhhdCBoaWRlcy9zaG93cykgdGhlIENsclNpZ25wb3N0Q29udGVudC4gQW5kLCBTSURFX1BPU0lUSU9OXG4gICAqIGlzICdsZWZ0JyBtZWFuaW5nIHR3byB0aGluZ3M6IDEpIHRoZSBDbHJTaWducG9zdENvbnRlbnQgY29udGFpbmVyIGV4dGVuZHMgdG8gdGhlIGxlZnQgYW5kIDIpIHRoZSAnYXJyb3cvcG9pbnRlcidcbiAgICogbGlua2luZyB0aGUgU2luZ3Bvc3RDb250ZW50IHRvIHRoZSB0cmlnZ2VyIHBvaW50cyBkb3duIGF0IHRoZSBob3Jpem9udGFsIGNlbnRlciBvZiB0aGUgdHJpZ2dlciBpY29uLlxuICAgKlxuICAgKiBAcGFyYW0gbmV3UG9zaXRpb25cbiAgICovXG4gIEBJbnB1dCgnY2xyUG9zaXRpb24nKVxuICBzZXQgcG9zaXRpb24ocG9zaXRpb246IHN0cmluZykge1xuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCB0aGlzLnBvc2l0aW9uKTtcbiAgICBpZiAocG9zaXRpb24gJiYgUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID4gLTEpIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ3JpZ2h0LW1pZGRsZSc7XG4gICAgfVxuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCB0aGlzLnBvc2l0aW9uKTtcblxuICAgIGNvbnN0IHNldFBvc2l0aW9uID0gU0lHTlBPU1RfUE9TSVRJT05TW3RoaXMucG9zaXRpb25dO1xuICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBzZXRQb3NpdGlvbi5hbmNob3JQb2ludDtcbiAgICB0aGlzLnBvcG92ZXJQb2ludCA9IHNldFBvc2l0aW9uLnBvcG92ZXJQb2ludDtcbiAgICB0aGlzLnBvcG92ZXJPcHRpb25zLm9mZnNldFkgPSBzZXRQb3NpdGlvbi5vZmZzZXRZO1xuICAgIHRoaXMucG9wb3Zlck9wdGlvbnMub2Zmc2V0WCA9IHNldFBvc2l0aW9uLm9mZnNldFg7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vblBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJTaWducG9zdCB9IGZyb20gJy4vc2lnbnBvc3QnO1xuaW1wb3J0IHsgQ2xyU2lnbnBvc3RDb250ZW50IH0gZnJvbSAnLi9zaWducG9zdC1jb250ZW50JztcbmltcG9ydCB7IENsclNpZ25wb3N0VHJpZ2dlciB9IGZyb20gJy4vc2lnbnBvc3QtdHJpZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfU0lHTlBPU1RfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyU2lnbnBvc3QsIENsclNpZ25wb3N0Q29udGVudCwgQ2xyU2lnbnBvc3RUcmlnZ2VyXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9TSUdOUE9TVF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9TSUdOUE9TVF9ESVJFQ1RJVkVTLCBDbHJDb25kaXRpb25hbE1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclNpZ25wb3N0TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuaW1wb3J0IHsgUE9QT1ZFUl9IT1NUX0FOQ0hPUiB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRvb2x0aXAnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MudG9vbHRpcF0nOiAndHJ1ZScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0lmT3BlblNlcnZpY2UsIHsgcHJvdmlkZTogUE9QT1ZFUl9IT1NUX0FOQ0hPUiwgdXNlRXhpc3Rpbmc6IEVsZW1lbnRSZWYgfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRvb2x0aXAge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RvciwgSW5wdXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFBvcG92ZXIgfSBmcm9tICcuLi9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbmNvbnN0IFBPU0lUSU9OUzogc3RyaW5nW10gPSBbJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAncmlnaHQnLCAnbGVmdCddO1xuXG5jb25zdCBTSVpFUzogc3RyaW5nW10gPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJ107XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10b29sdGlwLWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MudG9vbHRpcC1jb250ZW50XSc6ICd0cnVlJyxcbiAgICAvLyBJJ20gZ2l2aW5nIHVwIG9uIGFuaW1hdGlvbiwgdGhleSBkaWQgbm90IHdvcmsgYmVmb3JlIGFuZCB3aWxsIG5vdCB3b3JrIG5vdy5cbiAgICAvLyBUb28gbWFueSBjb25mbGljdHMgd2l0aCBDbGFyaXR5IFVJLlxuICAgICdbc3R5bGUub3BhY2l0eV0nOiAnMScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRvb2x0aXBDb250ZW50IGV4dGVuZHMgQWJzdHJhY3RQb3BvdmVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChQT1BPVkVSX0hPU1RfQU5DSE9SKVxuICAgIHBhcmVudEhvc3Q6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgaWYgKCFwYXJlbnRIb3N0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci10b29sdGlwLWNvbnRlbnQgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItdG9vbHRpcCcpO1xuICAgIH1cbiAgICBzdXBlcihpbmplY3RvciwgcGFyZW50SG9zdCk7XG4gICAgLy8gRGVmYXVsdHNcbiAgICB0aGlzLnBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICB0aGlzLnNpemUgPSAnc20nO1xuICB9XG5cbiAgcHJpdmF0ZSBfcG9zaXRpb246IHN0cmluZztcblxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICB9XG5cbiAgQElucHV0KCdjbHJQb3NpdGlvbicpXG4gIHNldCBwb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKSB7XG4gICAgLy8gVWdoXG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0b29sdGlwLScgKyB0aGlzLnBvc2l0aW9uKTtcbiAgICBpZiAocG9zaXRpb24gJiYgUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID4gLTEpIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgLy8gVWdoXG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0b29sdGlwLScgKyB0aGlzLnBvc2l0aW9uKTtcblxuICAgIC8vIHNldCB0aGUgcG9wb3ZlciB2YWx1ZXMgYmFzZWQgb24gZGlyZWN0aW9uXG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuVE9QX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9CT1RUT007XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLWxlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuTEVGVF9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3NpemU6IHN0cmluZztcblxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyU2l6ZScpXG4gIHNldCBzaXplKHNpemU6IHN0cmluZykge1xuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndG9vbHRpcC0nICsgdGhpcy5zaXplKTtcbiAgICBpZiAoc2l6ZSAmJiBTSVpFUy5pbmRleE9mKHNpemUpID4gLTEpIHtcbiAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zaXplID0gJ3NtJztcbiAgICB9XG4gICAgLy8gVWdoXG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0b29sdGlwLScgKyB0aGlzLnNpemUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJUb29sdGlwVHJpZ2dlcl0nLCBob3N0OiB7ICdbYXR0ci50YWJpbmRleF0nOiAnMCcsICdbY2xhc3MudG9vbHRpcC10cmlnZ2VyXSc6ICd0cnVlJyB9IH0pXG5leHBvcnQgY2xhc3MgQ2xyVG9vbHRpcFRyaWdnZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UpIHt9XG5cbiAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgc2hvd1Rvb2x0aXAoKTogdm9pZCB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSB0cnVlO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICBoaWRlVG9vbHRpcCgpOiB2b2lkIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXIubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyVG9vbHRpcCB9IGZyb20gJy4vdG9vbHRpcCc7XG5pbXBvcnQgeyBDbHJUb29sdGlwQ29udGVudCB9IGZyb20gJy4vdG9vbHRpcC1jb250ZW50JztcbmltcG9ydCB7IENsclRvb2x0aXBUcmlnZ2VyIH0gZnJvbSAnLi90b29sdGlwLXRyaWdnZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX1RPT0xUSVBfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyVG9vbHRpcCwgQ2xyVG9vbHRpcFRyaWdnZXIsIENsclRvb2x0aXBDb250ZW50XTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9UT09MVElQX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1RPT0xUSVBfRElSRUNUSVZFUywgQ2xyQ29uZGl0aW9uYWxNb2R1bGUsIENsckljb25Nb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUb29sdGlwTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEcm9wZG93bk1vZHVsZSB9IGZyb20gJy4vZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcbmltcG9ydCB7IENsclNpZ25wb3N0TW9kdWxlIH0gZnJvbSAnLi9zaWducG9zdC9zaWducG9zdC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4vdG9vbHRpcC90b29sdGlwLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7IGV4cG9ydHM6IFtDbHJEcm9wZG93bk1vZHVsZSwgQ2xyU2lnbnBvc3RNb2R1bGUsIENsclRvb2x0aXBNb2R1bGVdIH0pXG5leHBvcnQgY2xhc3MgQ2xyUG9wb3Zlck1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCdXR0b25IdWJTZXJ2aWNlIHtcbiAgcHVibGljIGJ1dHRvbnNSZWFkeTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3ByZXZpb3VzQnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBwcmV2aW91c0J0bkNsaWNrZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNCdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfbmV4dEJ0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgbmV4dEJ0bkNsaWNrZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dEJ0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9kYW5nZXJCdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IGRhbmdlckJ0bkNsaWNrZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fZGFuZ2VyQnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2NhbmNlbEJ0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgY2FuY2VsQnRuQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxCdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZmluaXNoQnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBmaW5pc2hCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaEJ0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9jdXN0b21CdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IGN1c3RvbUJ0bkNsaWNrZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fY3VzdG9tQnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBidXR0b25DbGlja2VkKGJ1dHRvblR5cGU6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICgncHJldmlvdXMnID09PSBidXR0b25UeXBlKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c0J0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJ25leHQnID09PSBidXR0b25UeXBlKSB7XG4gICAgICB0aGlzLl9uZXh0QnRuQ2xpY2tlZC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmICgnZmluaXNoJyA9PT0gYnV0dG9uVHlwZSkge1xuICAgICAgdGhpcy5fZmluaXNoQnRuQ2xpY2tlZC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmICgnZGFuZ2VyJyA9PT0gYnV0dG9uVHlwZSkge1xuICAgICAgdGhpcy5fZGFuZ2VyQnRuQ2xpY2tlZC5uZXh0KCk7XG4gICAgfSBlbHNlIGlmICgnY2FuY2VsJyA9PT0gYnV0dG9uVHlwZSkge1xuICAgICAgdGhpcy5fY2FuY2VsQnRuQ2xpY2tlZC5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2N1c3RvbUJ0bkNsaWNrZWQubmV4dChidXR0b25UeXBlKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENscldpemFyZFBhZ2UgfSBmcm9tICcuLi93aXphcmQtcGFnZSc7XG5cbi8qKlxuICogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIG1hbmFnZXMgdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMgYXNzaWduZWQgdG8gdGhlIHdpemFyZCBhbmQgb2ZmZXJzXG4gKiBhIG51bWJlciBvZiBmdW5jdGlvbnMgdXNlZnVsIGFjcm9zcyB0aGUgd2l6YXJkcyBwcm92aWRlcnMgYW5kIHN1YmNvbXBvbmVudHMgLS0gYWxsIHJlbGF0ZWRcbiAqIHRvIGVzc2VudGlhbGx5IGxvb2t1cHMgb24gdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMuXG4gKlxuICogVGhlIGVhc2llc3Qgd2F5IHRvIGFjY2VzcyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgaXMgdmlhIHRoZSB3aXphcmQuIFRoZVxuICogZm9sbG93aW5nIGV4YW1wbGUgd291bGQgYWxsb3cgeW91IHRvIGFjY2VzcyB5b3VyIGluc3RhbmNlIG9mIHRoZSB3aXphcmQgZnJvbSB5b3VyIGhvc3RcbiAqIGNvbXBvbmVudCBhbmQgdGhlcmVieSBhY2Nlc3MgdGhlIHBhZ2UgY29sbGVjdGlvbiB2aWEgWW91ckhvc3RDb21wb25lbnQud2l6YXJkLnBhZ2VDb2xsZWN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiA8Y2xyLXdpemFyZCAjd2l6YXJkIC4uLj5cbiAqXG4gKiBAZXhhbXBsZVxuICogZXhwb3J0IGNsYXNzIFlvdXJIb3N0Q29tcG9uZW50IHtcbiAqICAgQFZpZXdDaGlsZChcIndpemFyZFwiKSB3aXphcmQ6IFdpemFyZDtcbiAqICAgLi4uXG4gKiB9XG4gKlxuICogVGhlIGhlYXJ0IG9mIHRoZSBwYWdlIGNvbGxlY3Rpb24gaXMgdGhlIHF1ZXJ5IGxpc3Qgb2YgcGFnZXMsIHdoaWNoIGl0IGlzIGFzc2lnbmVkIGFzIGFcbiAqIHJlZmVyZW5jZSB0byB0aGUgV2l6YXJkLnBhZ2VzIFF1ZXJ5TGlzdCB3aGVuIHRoZSB3aXphcmQgaXMgY3JlYXRlZC5cbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQYWdlQ29sbGVjdGlvblNlcnZpY2Uge1xuICAvKipcbiAgICogQSByZWZlcmVuY2UgdG8gdGhlIFdpemFyZC5wYWdlcyBRdWVyeUxpc3QuXG4gICAqXG4gICAqIFBvcHVsYXRlZCB3aGVuIHRoZSB3aXphcmQgaXMgY3JlYXRlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHBhZ2VzOiBRdWVyeUxpc3Q8Q2xyV2l6YXJkUGFnZT47XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBQYWdlQ29sbGVjdGlvblNlcnZpY2UucGFnZXMgUXVlcnlMaXN0IHRvIGFuIGFycmF5IGFuZCByZXR1cm5zIGl0LlxuICAgKlxuICAgKiBVc2VmdWwgZm9yIG1hbnkgaW5zdGFuY2VzIHdoZW4geW91IHdvdWxkIHByZWZlciBhIFF1ZXJ5TGlzdCB0byBhY3QgbGlrZSBhbiBhcnJheS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBwYWdlc0FzQXJyYXkoKTogQ2xyV2l6YXJkUGFnZVtdIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlcyA/IHRoaXMucGFnZXMudG9BcnJheSgpIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwYWdlcyBxdWVyeSBsaXN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhZ2VzQ291bnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlcyA/IHRoaXMucGFnZXMubGVuZ3RoIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0LXRvLWxhc3QgcGFnZSBpbiB0aGUgcXVlcnkgbGlzdCBvZiBwYWdlcy4gT3BlcmF0ZXMgYXMgYSBnZXR0ZXJcbiAgICogc28gdGhhdCBpdCBpc24ndCB3b3JraW5nIHdpdGggc3RhbGUgZGF0YS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBwZW51bHRpbWF0ZVBhZ2UoKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgcGFnZUNvdW50ID0gdGhpcy5wYWdlc0NvdW50O1xuXG4gICAgaWYgKHBhZ2VDb3VudCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbcGFnZUNvdW50IC0gMl07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGFzdCBwYWdlIGluIHRoZSBxdWVyeSBsaXN0IG9mIHBhZ2VzLiBPcGVyYXRlcyBhcyBhIGdldHRlclxuICAgKiBzbyB0aGF0IGl0IGlzbid0IHdvcmtpbmcgd2l0aCBzdGFsZSBkYXRhLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxhc3RQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRoaXMucGFnZXNDb3VudDtcblxuICAgIGlmIChwYWdlQ291bnQgPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFnZXNBc0FycmF5W3BhZ2VDb3VudCAtIDFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIHF1ZXJ5IGxpc3Qgb2YgcGFnZXMuIE9wZXJhdGVzIGFzIGEgZ2V0dGVyXG4gICAqIHNvIHRoYXQgaXQgaXNuJ3Qgd29ya2luZyB3aXRoIHN0YWxlIGRhdGEuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgZmlyc3RQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGlmICghdGhpcy5wYWdlc0NvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFnZXNBc0FycmF5WzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgbW9zdGx5IGludGVybmFsbHksIGJ1dCBhY2NlcHRzIGEgc3RyaW5nIElEIGFuZCByZXR1cm5zIGEgQ2xyV2l6YXJkUGFnZVxuICAgKiBvYmplY3QgdGhhdCBtYXRjaGVzIHRoZSBJRCBwYXNzZWQuIE5vdGUgdGhhdCBJRHMgaGVyZSBzaG91bGQgaW5jbHVkZSB0aGUgcHJlZml4XG4gICAqIFwiY2xyLXdpemFyZC1wYWdlLVwiLlxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0LXRvLWxhc3QgcGFnZSBpbiB0aGUgcXVlcnkgbGlzdCBvZiBwYWdlcy4gT3BlcmF0ZXMgYXMgYSBnZXR0ZXJcbiAgICogc28gdGhhdCBpdCBpc24ndCB3b3JraW5nIHdpdGggc3RhbGUgZGF0YS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFBhZ2VCeUlkKGlkOiBzdHJpbmcpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBjb25zdCBmb3VuZFBhZ2VzOiBDbHJXaXphcmRQYWdlW10gPSB0aGlzLnBhZ2VzLmZpbHRlcigocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4gaWQgPT09IHBhZ2UuaWQpO1xuICAgIHJldHVybiB0aGlzLmNoZWNrUmVzdWx0cyhmb3VuZFBhZ2VzLCBpZCk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBzIG51bWJlciBhcyBhIHBhcmFtZXRlciBhbmQgdHJlYXRzIHRoYXQgbnVtYmVyIGFzIHRoZSBpbmRleCBvZiB0aGUgcGFnZVxuICAgKiB5b3UncmUgbG9va2luZyBmb3IgaW4gdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMuIFJldHVybnMgYSAgd2l6YXJkIHBhZ2Ugb2JqZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFnZUJ5SW5kZXgoaW5kZXg6IG51bWJlcik6IENscldpemFyZFBhZ2Uge1xuICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRoaXMucGFnZXNDb3VudDtcbiAgICBjb25zdCBwYWdlc0xhc3RJbmRleDogbnVtYmVyID0gcGFnZUNvdW50ID4gMSA/IHBhZ2VDb3VudCAtIDEgOiAwO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmV0cmlldmUgcGFnZSB3aXRoIGluZGV4IG9mICcgKyBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID4gcGFnZXNMYXN0SW5kZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFnZSBpbmRleCBpcyBncmVhdGVyIHRoYW4gbGVuZ3RoIG9mIHBhZ2VzIGFycmF5LicpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhZ2VzQXNBcnJheVtpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgaXRzIGluZGV4IGluIHRoZVxuICAgKiBjb2xsZWN0aW9uIG9mIHBhZ2VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFnZUluZGV4KHBhZ2U6IENscldpemFyZFBhZ2UpOiBudW1iZXIge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlc0FzQXJyYXkuaW5kZXhPZihwYWdlKTtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWVzdGVkIHBhZ2UgY2Fubm90IGJlIGZvdW5kIGluIGNvbGxlY3Rpb24gb2YgcGFnZXMuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnNvbGlkYXRlcyBndWFyZCBsb2dpYyB0aGF0IHByZXZlbnRzIGEgY291cGxlIG9mIHVuZm9ydHVuYXRlIGVkZ2UgY2FzZXMgd2l0aFxuICAgKiBsb29rIHVwcyBvbiB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja1Jlc3VsdHMocmVzdWx0czogQ2xyV2l6YXJkUGFnZVtdLCByZXF1ZXN0ZWRQYWdlSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGZvdW5kUGFnZXNDb3VudDogbnVtYmVyID0gcmVzdWx0cy5sZW5ndGggfHwgMDtcblxuICAgIGlmIChmb3VuZFBhZ2VzQ291bnQgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vcmUgdGhhbiBvbmUgcGFnZSBoYXMgdGhlIHJlcXVlc3RlZCBpZCAnICsgcmVxdWVzdGVkUGFnZUlkICsgJy4nKTtcbiAgICB9IGVsc2UgaWYgKGZvdW5kUGFnZXNDb3VudCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGFnZSBjYW4gYmUgZm91bmQgd2l0aCB0aGUgaWQgJyArIHJlcXVlc3RlZFBhZ2VJZCArICcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIHR3byBudW1lcmljIGluZGV4ZXMgYW5kIHJldHVybnMgYW4gYXJyYXkgb2Ygd2l6YXJkIHBhZ2Ugb2JqZWN0cyB0aGF0IGluY2x1ZGVcbiAgICogYWxsIHdpemFyZCBwYWdlcyBpbiB0aGUgcGFnZSBjb2xsZWN0aW9uIGZyb20gdGhlIGZpcnN0IGluZGV4IHRvIHRoZSBzZWNvbmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwYWdlUmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBDbHJXaXphcmRQYWdlW10ge1xuICAgIGxldCBwYWdlczogQ2xyV2l6YXJkUGFnZVtdID0gW107XG5cbiAgICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgdHlwZW9mIHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgaXNOYU4oc3RhcnQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gbnVsbCB8fCB0eXBlb2YgZW5kID09PSB1bmRlZmluZWQgfHwgaXNOYU4oZW5kKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChlbmQgPiB0aGlzLnBhZ2VzQ291bnQpIHtcbiAgICAgIGVuZCA9IHRoaXMucGFnZXNDb3VudDtcbiAgICB9XG5cbiAgICBwYWdlcyA9IHRoaXMucGFnZXNBc0FycmF5O1xuXG4gICAgaWYgKGVuZCAtIHN0YXJ0ID09PSAwKSB7XG4gICAgICAvLyBqdXN0IHJldHVybiB0aGUgb25lIHBhZ2UgdGhleSB3YW50XG4gICAgICByZXR1cm4gW3RoaXMuZ2V0UGFnZUJ5SW5kZXgoc3RhcnQpXTtcbiAgICB9XG5cbiAgICAvLyBzbGljZSBlbmQgZG9lcyBub3QgaW5jbHVkZSBpdGVtIHJlZmVyZW5jZWQgYnkgZW5kIGluZGV4LCB3aGljaCBpcyB3ZWlyZCBmb3IgdXNlcnNcbiAgICAvLyBpbmNyZW1lbnRpbmcgZW5kIGluZGV4IGhlcmUgdG8gY29ycmVjdCB0aGF0IHNvIHVzZXJzIGFuZCBvdGhlciBtZXRob2RzXG4gICAgLy8gZG9uJ3QgaGF2ZSB0byB0aGluayBhYm91dCBpdFxuICAgIGVuZCA9IGVuZCArIDE7XG5cbiAgICAvLyBzbGljZSBkb2VzIG5vdCByZXR1cm4gdGhlIGxhc3Qgb25lIGluIHRoZSByYW5nZSBidXQgaXQgZG9lcyBpbmNsdWRlIHRoZSBmaXJzdCBvbmVcbiAgICAvLyBkb2VzIG5vdCBtb2RpZnkgb3JpZ2luYWwgYXJyYXlcbiAgICByZXR1cm4gcGFnZXMuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyB0d28gd2l6YXJkIHBhZ2Ugb2JqZWN0cyBhbmQgcmV0dXJucyB0aG9zZSBwYWdlIG9iamVjdHMgd2l0aCBhbGwgb3RoZXIgcGFnZVxuICAgKiBvYmplY3RzIGJldHdlZW4gdGhlbSBpbiB0aGUgcGFnZSBjb2xsZWN0aW9uLiBJdCBkb2Vzbid0IGNhcmUgd2hpY2ggcGFnZSBpcyBhaGVhZCBvZiB0aGVcbiAgICogb3RoZXIgaW4gdGhlIHBhcmFtZXRlcnMuIEl0IHdpbGwgYmUgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSB0aGF0IG91dCAgb24gaXRzIG93bi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFBhZ2VSYW5nZUZyb21QYWdlcyhwYWdlOiBDbHJXaXphcmRQYWdlLCBvdGhlclBhZ2U6IENscldpemFyZFBhZ2UpOiBDbHJXaXphcmRQYWdlW10ge1xuICAgIGNvbnN0IHBhZ2VJbmRleCA9IHRoaXMuZ2V0UGFnZUluZGV4KHBhZ2UpO1xuICAgIGNvbnN0IG90aGVyUGFnZUluZGV4ID0gdGhpcy5nZXRQYWdlSW5kZXgob3RoZXJQYWdlKTtcbiAgICBsZXQgc3RhcnRJbmRleDogbnVtYmVyO1xuICAgIGxldCBlbmRJbmRleDogbnVtYmVyO1xuXG4gICAgaWYgKHBhZ2VJbmRleCA8PSBvdGhlclBhZ2VJbmRleCkge1xuICAgICAgc3RhcnRJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgIGVuZEluZGV4ID0gb3RoZXJQYWdlSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5kZXggPSBvdGhlclBhZ2VJbmRleDtcbiAgICAgIGVuZEluZGV4ID0gcGFnZUluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYWdlUmFuZ2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgd2l6YXJkIHBhZ2Ugb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIHRoZSB3aXphcmQgcGFnZSBvYmplY3Qgb2ZcbiAgICogdGhlIHBhZ2UgaW1tZWRpYXRlbHkgYmVmb3JlIGl0IGluIHRoZSBwYWdlIGNvbGxlY3Rpb24uIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpc1xuICAgKiBubyBwYWdlIGJlZm9yZSB0aGUgcGFnZSBpdCBpcyBwYXNzZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRQcmV2aW91c1BhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIGNvbnN0IG15UGFnZUluZGV4ID0gdGhpcy5nZXRQYWdlSW5kZXgocGFnZSk7XG4gICAgY29uc3QgcHJldmlvdXNQYWdlSW5kZXggPSBteVBhZ2VJbmRleCAtIDE7XG4gICAgaWYgKHByZXZpb3VzUGFnZUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBhZ2VCeUluZGV4KHByZXZpb3VzUGFnZUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGEgd2l6YXJkIHBhZ2Ugb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGEgQm9vbGVhbiB0aGF0IHNheXMgaWZcbiAgICogdGhlIHBhZ2UgeW91IHNlbnQgaXQgaXMgY29tcGxldGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwcmV2aW91c1BhZ2VJc0NvbXBsZXRlZChwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgbGV0IHByZXZpb3VzUGFnZTogQ2xyV2l6YXJkUGFnZTtcblxuICAgIGlmICghcGFnZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByZXZpb3VzUGFnZSA9IHRoaXMuZ2V0UHJldmlvdXNQYWdlKHBhZ2UpO1xuXG4gICAgaWYgKG51bGwgPT09IHByZXZpb3VzUGFnZSkge1xuICAgICAgLy8gcGFnZSBpcyB0aGUgZmlyc3QgcGFnZS4gbm8gcHJldmlvdXMgcGFnZS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c1BhZ2UuY29tcGxldGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgd2l6YXJkIHBhZ2Ugb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIHRoZSB3aXphcmQgcGFnZSBvYmplY3Qgb2ZcbiAgICogdGhlIHBhZ2UgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbi4gUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzXG4gICAqIG5vIHBhZ2UgYWZ0ZXIgdGhlIHBhZ2UgaXQgaXMgcGFzc2VkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0TmV4dFBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIGNvbnN0IG15UGFnZUluZGV4ID0gdGhpcy5nZXRQYWdlSW5kZXgocGFnZSk7XG4gICAgY29uc3QgbmV4dFBhZ2VJbmRleCA9IG15UGFnZUluZGV4ICsgMTtcblxuICAgIGlmIChuZXh0UGFnZUluZGV4ID49IHRoaXMucGFnZXNBc0FycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBhZ2VCeUluZGV4KG5leHRQYWdlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgd2l6YXJkIHBhZ2Ugb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGFuZCBnZW5lcmF0ZXMgYSBzdGVwIGl0ZW0gaWQgZnJvbSB0aGVcbiAgICogcGFnZSBJRC4gUmV0dXJucyB0aGUgZ2VuZXJhdGVkIHN0ZXAgaXRlbSBJRCBhcyBhIHN0cmluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFN0ZXBJdGVtSWRGb3JQYWdlKHBhZ2U6IENscldpemFyZFBhZ2UpIHtcbiAgICBjb25zdCBwYWdlSWQgPSBwYWdlLmlkO1xuICAgIGNvbnN0IHBhZ2VJZFBhcnRzID0gcGFnZUlkLnNwbGl0KCctJykucmV2ZXJzZSgpO1xuXG4gICAgcGFnZUlkUGFydHNbMV0gPSAnc3RlcCc7XG4gICAgcmV0dXJuIHBhZ2VJZFBhcnRzLnJldmVyc2UoKS5qb2luKCctJyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhbGx5IG9ubHkgdXNlZCBpbnRlcm5hbGx5IHRvIG1hcmsgdGhhdCBhIHNwZWNpZmljIHBhZ2UgaGFzIGJlZW4gXCJjb21taXR0ZWRcIi5cbiAgICogVGhpcyBpbnZvbHZlcyBtYXJraW5nIHRoZSBwYWdlIGNvbXBsZXRlIGFuZCBmaXJpbmcgdGhlIENscldpemFyZFBhZ2Uub25Db21taXRcbiAgICogKGNscldpemFyZFBhZ2VPbkNvbW1pdCkgb3V0cHV0LiBUYWtlcyB0aGUgd2l6YXJkIHBhZ2Ugb2JqZWN0IHRoYXQgeW91IGludGVuZCB0b1xuICAgKiBtYXJrIGNvbXBsZXRlZCBhcyBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNvbW1pdFBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIGNvbnN0IHBhZ2VIYXNPdmVycmlkZXMgPSBwYWdlLnN0b3BOZXh0IHx8IHBhZ2UucHJldmVudERlZmF1bHQ7XG4gICAgcGFnZS5jb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgaWYgKCFwYWdlSGFzT3ZlcnJpZGVzKSB7XG4gICAgICAvLyBwcmV2ZW50IGxvb3Agb2YgZXZlbnQgZW1pc3Npb247IGFsdGVybmF0ZSBmbG93cyB3b3JrIG9mZlxuICAgICAgLy8gb2YgZXZlbnQgZW1pdHRlcnMgdGhpcyBpcyBob3cgdGhleSBicmVhayB0aGF0IGN5Y2xlLlxuICAgICAgcGFnZS5vbkNvbW1pdC5lbWl0KHBhZ2UuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHVzZWQgYnkgdGhlIG5hdlNlcnZpY2UgdG8gbmF2aWdhdGUgYmFjayB0byBmaXJzdCBwb3NzaWJsZSBzdGVwIGFmdGVyXG4gIC8vIHBhZ2VzIGFyZSByZXNldFxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9wYWdlc1Jlc2V0ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICogQW4gb2JzZXJ2YWJsZSB0aGF0IHRoZSBuYXZpZ2F0aW9uIHNlcnZpY2UgbGlzdGVucyB0byBpbiBvcmRlciB0byBrbm93IHdoZW5cbiAgICogdGhlIHBhZ2UgY29sbGVjdGlvbiBjb21wbGV0ZWQgc3RhdGVzIGhhdmUgYmVlbiByZXNldCB0byBmYWxzZSBzbyB0aGF0IHdheSBpdFxuICAgKiBjYW4gYWxzbyByZXNldCB0aGUgbmF2aWdhdGlvbiB0byBtYWtlIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBwYWdlIGNvbGxlY3Rpb25cbiAgICogY3VycmVudC9hY3RpdmUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFnZXNSZXNldCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZXNSZXNldC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFsbCBjb21wbGV0ZWQgc3RhdGVzIG9mIHRoZSBwYWdlcyBpbiB0aGUgcGFnZSBjb2xsZWN0aW9uIHRvIGZhbHNlIGFuZFxuICAgKiBub3RpZmllcyB0aGUgbmF2aWdhdGlvbiBzZXJ2aWNlIHRvIGxpa2V3aXNlIHJlc2V0IHRoZSBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcmVzZXQoKSB7XG4gICAgdGhpcy5wYWdlc0FzQXJyYXkuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4ge1xuICAgICAgcGFnZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICB0aGlzLl9wYWdlc1Jlc2V0Lm5leHQodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUm9sbHMgdGhyb3VnaCBhbGwgdGhlIHBhZ2VzIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24gdG8gbWFrZSBzdXJlIHRoZXJlIGFyZSBub1xuICAgKiBpbmNvbXBsZXRlIHBhZ2VzIHNhbmR3aWNoZWQgYmV0d2VlbiBjb21wbGV0ZWQgcGFnZXMgaW4gdGhlIHdvcmtmbG93LiBJZGVudGlmaWVzXG4gICAqIHRoZSBmaXJzdCBpbmNvbXBsZXRlIHBhZ2UgaW5kZXggYW5kIHNldHMgYWxsIHBhZ2VzIGJlaGluZCBpdCB0byBhIGNvbXBsZXRlZFxuICAgKiBzdGF0ZSBvZiBmYWxzZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUNvbXBsZXRlZFN0YXRlcygpOiB2b2lkIHtcbiAgICBjb25zdCBmaXJzdEluY29tcGxldGVJbmRleCA9IHRoaXMuZmluZEZpcnN0SW5jb21wbGV0ZVBhZ2VJbmRleCgpO1xuXG4gICAgaWYgKGZpcnN0SW5jb21wbGV0ZUluZGV4ID09PSB0aGlzLnBhZ2VzQXNBcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAvLyBhbGwgY29tcGxldGUgbm8gbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGFnZXNBc0FycmF5LmZvckVhY2goKHBhZ2U6IENscldpemFyZFBhZ2UsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChpbmRleCA+IGZpcnN0SW5jb21wbGV0ZUluZGV4KSB7XG4gICAgICAgIHBhZ2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaW5jb21wbGV0ZSBwYWdlIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBmaW5kRmlyc3RJbmNvbXBsZXRlUGFnZUluZGV4KCk6IG51bWJlciB7XG4gICAgbGV0IHJldHVybkluZGV4OiBudW1iZXIgPSBudWxsO1xuICAgIHRoaXMucGFnZXNBc0FycmF5LmZvckVhY2goKHBhZ2U6IENscldpemFyZFBhZ2UsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChudWxsID09PSByZXR1cm5JbmRleCAmJiBmYWxzZSA9PT0gcGFnZS5jb21wbGV0ZWQpIHtcbiAgICAgICAgcmV0dXJuSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZhbGx0aHJvdWdoLCBhbGwgY29tcGxldGVkLCByZXR1cm4gbGFzdCBwYWdlXG4gICAgaWYgKG51bGwgPT09IHJldHVybkluZGV4KSB7XG4gICAgICByZXR1cm5JbmRleCA9IHRoaXMucGFnZXNDb3VudCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVybkluZGV4O1xuICB9XG5cbiAgcHVibGljIGZpbmRGaXJzdEluY29tcGxldGVQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGNvbnN0IG15SW5jb21wbGV0ZUluZGV4ID0gdGhpcy5maW5kRmlyc3RJbmNvbXBsZXRlUGFnZUluZGV4KCk7XG4gICAgcmV0dXJuIHRoaXMucGFnZXNBc0FycmF5W215SW5jb21wbGV0ZUluZGV4XTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3ksIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZSB9IGZyb20gJy4uL3dpemFyZC1wYWdlJztcblxuaW1wb3J0IHsgQnV0dG9uSHViU2VydmljZSB9IGZyb20gJy4vYnV0dG9uLWh1Yi5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VDb2xsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UnO1xuXG4vKipcbiAqIFBlcmZvcm1zIG5hdmlnYXRpb24gZnVuY3Rpb25zIGZvciBhIHdpemFyZCBhbmQgbWFuYWdlcyB0aGUgY3VycmVudCBwYWdlLiBQcmVzZW50ZWQgYXMgYVxuICogc2VwYXJhdGUgc2VydmljZSB0byBlbmNhcHN1bGF0ZSB0aGUgYmVoYXZpb3Igb2YgbmF2aWdhdGluZyBhbmQgY29tcGxldGluZyB0aGUgd2l6YXJkIHNvXG4gKiB0aGF0IGl0IGNhbiBiZSBzaGFyZWQgYWNyb3NzIHRoZSB3aXphcmQgYW5kIGl0cyBzdWItY29tcG9uZW50cy5cbiAqXG4gKiBUaGUgZWFzaWVzdCB3YXkgdG8gYWNjZXNzIHRoZSBuYXZpZ2F0aW9uIHNlcnZpY2UgaXMgdGhlcmUgYSByZWZlcmVuY2Ugb24geW91ciB3aXphcmQuIFRoZVxuICogRm9sbG93aW5nIGV4YW1wbGUgd291bGQgYWxsb3cgeW91IHRvIGFjY2VzcyB5b3VyIGluc3RhbmNlIG9mIHRoZSB3aXphcmQgZnJvbSB5b3VyIGhvc3RcbiAqIGNvbXBvbmVudCBhbmQgdGhlcmVieSBhY2Nlc3MgdGhlIG5hdmlnYXRpb24gc2VydmljZSB2aWEgWW91ckhvc3RDb21wb25lbnQud2l6YXJkLm5hdlNlcnZpY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxjbHItd2l6YXJkICN3aXphcmQgLi4uPlxuICpcbiAqIEBleGFtcGxlXG4gKiBleHBvcnQgY2xhc3MgWW91ckhvc3RDb21wb25lbnQge1xuICogICBAVmlld0NoaWxkKFwid2l6YXJkXCIpIHdpemFyZDogV2l6YXJkO1xuICogICAuLi5cbiAqIH1cbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIC8qKlxuICAgKiBJcyBub3RpZmllZCB3aGVuIGEgcHJldmlvdXMgYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC4gUGVyZm9ybXMgY2hlY2tzXG4gICAqIGJlZm9yZSBhbGVydGluZyB0aGUgY3VycmVudCBwYWdlIG9mIHRoZSBidXR0b24gY2xpY2suIEVuYWN0cyBuYXZpZ2F0aW9uIHRvXG4gICAqIHRoZSBwcmV2aW91cyBwYWdlIGlmIG5vdCBvdmVycmlkZGVuIGF0IHRoZSBwYWdlIGxldmVsLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwcmV2aW91c0J1dHRvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBJcyBub3RpZmllZCB3aGVuIGEgTmV4dCBidXR0b24gaXMgY2xpY2tlZCBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBuZXh0QnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBkYW5nZXIgYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZGFuZ2VyQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSAgZmluaXNoIGJ1dHRvbiBpcyBjbGlja2VkIGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZpbmlzaEJ1dHRvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBJcyBub3RpZmllZCB3aGVuIGEgQ3VzdG9tIGJ1dHRvbiBpcyBjbGlja2VkIGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGN1c3RvbUJ1dHRvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBJcyBub3RpZmllZCB3aGVuIGEgQ2FuY2VsIGJ1dHRvbiBpcyBjbGlja2VkIGluIHRoZSB3aXphcmQuIE5vdGlmaWVzIHRoZSB3aXphcmQsXG4gICAqIHdoaWNoIGhhbmRsZXMgYWxsIGNhbmNlbCBmdW5jdGlvbmFsaXR5LCBpZiBjYW5jZWwgaXMgbm90IG92ZXJyaWRkZW4gYXQgdGhlIHBhZ2VcbiAgICogbGV2ZWwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNhbmNlbEJ1dHRvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBSZXNldHMgbmF2aWdhdGlvbiB0byBtYWtlIHRoZSBmaXJzdCBwYWdlIGN1cnJlbnQgd2hlbiB0aGUgcGFnZSBjb2xsZWN0aW9uIHNlcnZpY2VcbiAgICogZW1pdHMgYW4gZXZlbnQgbm90aWZ5aW5nIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIHRoYXQgaXQgaGFzIHJlc2V0IGFsbCBwYWdlc1xuICAgKiB0byB0aGVpciBwcmlzdGluZSwgaW5jb21wbGV0ZSBzdGF0ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcGFnZXNSZXNldFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLiBBbHNvIHNldHMgdXAgc3Vic2NyaXB0aW9uc1xuICAgKiB0aGF0IGxpc3RlbiB0byB0aGUgYnV0dG9uIHNlcnZpY2UgdG8gZGV0ZXJtaW5lIHdoZW4gYSBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgKiBpbiB0aGUgd2l6YXJkLiBJcyBhbHNvIHJlc3BvbnNpYmxlIGZvciB0YWtpbmcgYWN0aW9uIHdoZW4gdGhlIHBhZ2UgY29sbGVjdGlvblxuICAgKiByZXF1ZXN0cyB0aGF0IG5hdmlnYXRpb24gYmUgcmVzZXQgdG8gaXRzIHByaXN0aW5lIHN0YXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlQ29sbGVjdGlvbjogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLCBwdWJsaWMgYnV0dG9uU2VydmljZTogQnV0dG9uSHViU2VydmljZSkge1xuICAgIHRoaXMucHJldmlvdXNCdXR0b25TdWJzY3JpcHRpb24gPSB0aGlzLmJ1dHRvblNlcnZpY2UucHJldmlvdXNCdG5DbGlja2VkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG4gICAgICBpZiAodGhpcy5jdXJyZW50UGFnZUlzRmlyc3QgfHwgY3VycmVudFBhZ2UucHJldmlvdXNTdGVwRGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudFBhZ2UucHJldmlvdXNCdXR0b25DbGlja2VkLmVtaXQoY3VycmVudFBhZ2UpO1xuICAgICAgaWYgKCFjdXJyZW50UGFnZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLm5leHRCdXR0b25TdWJzY3JpcHRpb24gPSB0aGlzLmJ1dHRvblNlcnZpY2UubmV4dEJ0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnbmV4dCcpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5kYW5nZXJCdXR0b25TdWJzY3JpcHRpb24gPSB0aGlzLmJ1dHRvblNlcnZpY2UuZGFuZ2VyQnRuQ2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCdkYW5nZXInKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZmluaXNoQnV0dG9uU3Vic2NyaXB0aW9uID0gdGhpcy5idXR0b25TZXJ2aWNlLmZpbmlzaEJ0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnZmluaXNoJyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmN1c3RvbUJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5jdXN0b21CdG5DbGlja2VkLnN1YnNjcmliZSgodHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoIXRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZS5jdXN0b21CdXR0b25DbGlja2VkLmVtaXQodHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhbmNlbEJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5jYW5jZWxCdG5DbGlja2VkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBhZ2UucGFnZU9uQ2FuY2VsLmVtaXQodGhpcy5jdXJyZW50UGFnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wYWdlc1Jlc2V0U3Vic2NyaXB0aW9uID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5wYWdlc1Jlc2V0LnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLnNldEZpcnN0UGFnZUN1cnJlbnQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMucHJldmlvdXNCdXR0b25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLm5leHRCdXR0b25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLmRhbmdlckJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuZmluaXNoQnV0dG9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5jdXN0b21CdXR0b25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLmNhbmNlbEJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMucGFnZXNSZXNldFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudENoYW5nZWQgPSBuZXcgU3ViamVjdDxDbHJXaXphcmRQYWdlPigpO1xuXG4gIC8qKlxuICAgKiBBbiBPYnNlcnZhYmxlIHRoYXQgaXMgcHJlZG9taW5hbnRseSB1c2VkIGFtb25nc3QgdGhlIHN1YmNvbXBvbmVudHMgYW5kIHNlcnZpY2VzXG4gICAqIG9mIHRoZSB3aXphcmQuIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgdXNlcnMgbGlzdGVuIHRvIHRoZSBDbHJXaXphcmRQYWdlLm9uTG9hZFxuICAgKiAoY2xyV2l6YXJkUGFnZU9uTG9hZCkgb3V0cHV0IGluc3RlYWQgb2YgdGhpcyBPYnNlcnZhYmxlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudFBhZ2VDaGFuZ2VkKCk6IE9ic2VydmFibGU8Q2xyV2l6YXJkUGFnZT4ge1xuICAgIC8vIFRPRE86IE1BS0UgU1VSRSBFWFRFUk5BTCBPVVRQVVRTIFNBWSAnQ0hBTkdFJyBOT1QgJ0NIQU5HRUQnXG4gICAgLy8gQSBCUkVBS0lORyBDSEFOR0UgU08gQVdBSVRJTkcgTUlOT1IgUkVMRUFTRVxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q2hhbmdlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIEJvb2xlYW4gZmxhZyB1c2VkIGJ5IHRoZSBDbHJXaXphcmRQYWdlIHRvIGF2b2lkIGEgcmFjZSBjb25kaXRpb24gd2hlbiBwYWdlcyBhcmVcbiAgICogbG9hZGluZyBhbmQgdGhlcmUgaXMgbm8gY3VycmVudCBwYWdlIGRlZmluZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIG5hdlNlcnZpY2VMb2FkZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBib29sZWFuIGZsYWcgc2hhcmVkIGFjcm9zcyB0aGUgV2l6YXJkIHN1YmNvbXBvbmVudHMgdGhhdCBmb2xsb3dzIHRoZSB2YWx1ZVxuICAgKiBvZiB0aGUgV2l6YXJkLmZvcmNlRm9yd2FyZCAoY2xyV2l6YXJkRm9yY2VGb3J3YXJkTmF2aWdhdGlvbikgaW5wdXQuIFdoZW4gdHJ1ZSxcbiAgICogbmF2aWdhdGluZyBiYWNrd2FyZHMgaW4gdGhlIHN0ZXBuYXYgbWVudSB3aWxsIHJlc2V0IGFueSBza2lwcGVkIHBhZ2VzJyBjb21wbGV0ZWRcbiAgICogc3RhdGUgdG8gZmFsc2UuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSB3aXphcmQgZXhlY3V0ZXMgdmFsaWRhdGlvbiBvbiBhIHBhZ2UtYnktcGFnZSBiYXNpcyB3aGVuXG4gICAqIHRoZSBuZXh0IGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBmb3JjZUZvcndhcmROYXZpZ2F0aW9uID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZVRpdGxlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIC8vIHdoZW4gdGhlIHF1ZXJ5bGlzdCBvZiBwYWdlcyBpcyBlbXB0eS4gdGhpcyBpcyB0aGUgZmlyc3QgcGxhY2UgaXQgZmFpbHMuLi5cbiAgICBpZiAoIXRoaXMuY3VycmVudFBhZ2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFnZS50aXRsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQm9vbGVhbiB0aGF0IHRlbGxzIHlvdSB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBwYWdlIGlzIHRoZSBmaXJzdFxuICAgKiBwYWdlIGluIHRoZSBXaXphcmQuXG4gICAqXG4gICAqIFRoaXMgaXMgaGVscGZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciBhIHBhZ2UgaXMgbmF2aWdhYmxlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudFBhZ2VJc0ZpcnN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnBhZ2VDb2xsZWN0aW9uLmZpcnN0UGFnZSA9PT0gdGhpcy5jdXJyZW50UGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgQm9vbGVhbiB0aGF0IHRlbGxzIHlvdSB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBwYWdlIGlzIHRoZVxuICAgKiBsYXN0IHBhZ2UgaW4gdGhlIFdpemFyZC5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBidXR0b25zIHNob3VsZCBkaXNwbGF5IGluIHRoZSB3aXphcmQgZm9vdGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudFBhZ2VJc0xhc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGFnZUNvbGxlY3Rpb24ubGFzdFBhZ2UgPT09IHRoaXMuY3VycmVudFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9jdXJyZW50UGFnZTogQ2xyV2l6YXJkUGFnZTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ2xyV2l6YXJkUGFnZSBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgcGFnZSBvciBudWxsLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIGdldCBjdXJyZW50UGFnZSgpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRQYWdlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBDbHJXaXphcmRQYWdlIG9iamVjdCwgc2luY2UgdGhhdCBvYmplY3QgdG8gYmUgdGhlIGN1cnJlbnQvYWN0aXZlXG4gICAqIHBhZ2UgaW4gdGhlIHdpemFyZCwgYW5kIGVtaXRzIHRoZSBDbHJXaXphcmRQYWdlLm9uTG9hZCAoY2xyV2l6YXJkUGFnZU9uTG9hZClcbiAgICogZXZlbnQgZm9yIHRoYXQgcGFnZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IGFsbCBvZiB0aGlzIHdvcmsgaXMgYnlwYXNzZWQgaWYgdGhlIENscldpemFyZFBhZ2Ugb2JqZWN0IGlzIGFscmVhZHlcbiAgICogdGhlIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBzZXQgY3VycmVudFBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50UGFnZSAhPT0gcGFnZSAmJiAhdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgdGhpcy5fY3VycmVudFBhZ2UgPSBwYWdlO1xuICAgICAgcGFnZS5vbkxvYWQuZW1pdChwYWdlLmlkKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLm5leHQocGFnZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBfbW92ZWRUb05leHRQYWdlID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICogQW4gb2JzZXJ2YWJsZSB1c2VkIGludGVybmFsbHkgdG8gYWxlcnQgdGhlIHdpemFyZCB0aGF0IGZvcndhcmQgbmF2aWdhdGlvblxuICAgKiBoYXMgb2NjdXJyZWQuIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSB0aGUgV2l6YXJkLm9uTW92ZU5leHRcbiAgICogKGNscldpemFyZE9uTmV4dCkgb3V0cHV0IGluc3RlYWQgb2YgdGhpcyBvbmUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBtb3ZlZFRvTmV4dFBhZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmVkVG9OZXh0UGFnZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX3dpemFyZEZpbmlzaGVkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICogQW4gb2JzZXJ2YWJsZSB1c2VkIGludGVybmFsbHkgdG8gYWxlcnQgdGhlIHdpemFyZCB0aGF0IHRoZSBuYXYgc2VydmljZVxuICAgKiBoYXMgYXBwcm92ZWQgY29tcGxldGlvbiBvZiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHlvdSB1c2UgdGhlIFdpemFyZC53aXphcmRGaW5pc2hlZCAoY2xyV2l6YXJkT25GaW5pc2gpXG4gICAqIG91dHB1dCBpbnN0ZWFkIG9mIHRoaXMgb25lLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgd2l6YXJkRmluaXNoZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX3dpemFyZEZpbmlzaGVkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBwdWJsaWMgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IGFkdmFuY2VcbiAgICogdGhlIHVzZXIgdG8gdGhlIG5leHQgcGFnZS5cbiAgICpcbiAgICogV2hlbiBpbnZva2VkLCB0aGlzIG1ldGhvZCB3aWxsIG1vdmUgdGhlIHdpemFyZCB0byB0aGUgbmV4dCBwYWdlIGFmdGVyXG4gICAqIHN1Y2Nlc3NmdWwgdmFsaWRhdGlvbi4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGdvZXMgdGhyb3VnaCBhbGwgY2hlY2tzXG4gICAqIGFuZCBldmVudCBlbWlzc2lvbnMgYXMgaWYgV2l6YXJkLm5leHQoZmFsc2UpIGhhZCBiZWVuIGNhbGxlZC5cbiAgICpcbiAgICogSW4gbW9zdCBjYXNlcywgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byB1c2UgV2l6YXJkLm5leHQoZmFsc2UpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBuZXh0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlSXNMYXN0KSB7XG4gICAgICB0aGlzLmNoZWNrQW5kQ29tbWl0Q3VycmVudFBhZ2UoJ2ZpbmlzaCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnbmV4dCcpO1xuXG4gICAgaWYgKCF0aGlzLndpemFyZEhhc0FsdE5leHQgJiYgIXRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHRoaXMuX21vdmVkVG9OZXh0UGFnZS5uZXh0KHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCeXBhc3NlcyBjaGVja3MgYW5kIG1vc3QgZXZlbnQgZW1pc3Npb25zIHRvIGZvcmNlIGEgcGFnZSB0byBuYXZpZ2F0ZSBmb3J3YXJkLlxuICAgKlxuICAgKiBDb21wYXJhYmxlIHRvIGNhbGxpbmcgV2l6YXJkLm5leHQoKSBvciBXaXphcmQuZm9yY2VOZXh0KCkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZvcmNlTmV4dCgpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50UGFnZTogQ2xyV2l6YXJkUGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG4gICAgY29uc3QgbmV4dFBhZ2U6IENscldpemFyZFBhZ2UgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLmdldE5leHRQYWdlKGN1cnJlbnRQYWdlKTtcblxuICAgIC8vIGNhdGNoIGVycmFudCBudWxsIG9yIHVuZGVmaW5lZHMgdGhhdCBjcmVlcCBpblxuICAgIGlmICghbmV4dFBhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHdpemFyZCBoYXMgbm8gbmV4dCBwYWdlIHRvIGdvIHRvLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjdXJyZW50UGFnZS5jb21wbGV0ZWQpIHtcbiAgICAgIC8vIHRoaXMgaXMgYSBzdGF0ZSB0aGF0IGFsdCBuZXh0IGZsb3dzIGNhbiBnZXQgdGhlbXNlbHZlcyBpbi4uLlxuICAgICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5jb21taXRQYWdlKGN1cnJlbnRQYWdlKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IG5leHRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBidXR0b24vYWN0aW9uIHR5cGUgYXMgYSBwYXJhbWV0ZXIuIEVuY2Fwc3VsYXRlcyBhbGwgbG9naWMgZm9yXG4gICAqIGV2ZW50IGVtaXNzaW9ucywgc3RhdGUgb2YgdGhlIGN1cnJlbnQgcGFnZSwgYW5kIHdpemFyZCBhbmQgcGFnZSBsZXZlbCBvdmVycmlkZXMuXG4gICAqXG4gICAqIEF2b2lkIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSB1bmxlc3MgeW91IHJlYWxseSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKGJ1dHRvblR5cGU6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICBsZXQgaUFtVGhlTGFzdFBhZ2U6IGJvb2xlYW47XG5cbiAgICBsZXQgaXNOZXh0OiBib29sZWFuO1xuICAgIGxldCBpc0RhbmdlcjogYm9vbGVhbjtcbiAgICBsZXQgaXNEYW5nZXJOZXh0OiBib29sZWFuO1xuICAgIGxldCBpc0RhbmdlckZpbmlzaDogYm9vbGVhbjtcbiAgICBsZXQgaXNGaW5pc2g6IGJvb2xlYW47XG5cbiAgICBpZiAoIWN1cnJlbnRQYWdlLnJlYWR5VG9Db21wbGV0ZSB8fCB0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaUFtVGhlTGFzdFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlSXNMYXN0O1xuXG4gICAgaXNOZXh0ID0gYnV0dG9uVHlwZSA9PT0gJ25leHQnO1xuICAgIGlzRGFuZ2VyID0gYnV0dG9uVHlwZSA9PT0gJ2Rhbmdlcic7XG4gICAgaXNEYW5nZXJOZXh0ID0gaXNEYW5nZXIgJiYgIWlBbVRoZUxhc3RQYWdlO1xuICAgIGlzRGFuZ2VyRmluaXNoID0gaXNEYW5nZXIgJiYgaUFtVGhlTGFzdFBhZ2U7XG4gICAgaXNGaW5pc2ggPSBidXR0b25UeXBlID09PSAnZmluaXNoJyB8fCBpc0RhbmdlckZpbmlzaDtcblxuICAgIGlmIChpc0ZpbmlzaCAmJiAhaUFtVGhlTGFzdFBhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50UGFnZS5wcmltYXJ5QnV0dG9uQ2xpY2tlZC5lbWl0KGJ1dHRvblR5cGUpO1xuXG4gICAgaWYgKGlzRmluaXNoKSB7XG4gICAgICBjdXJyZW50UGFnZS5maW5pc2hCdXR0b25DbGlja2VkLmVtaXQoY3VycmVudFBhZ2UpO1xuICAgIH0gZWxzZSBpZiAoaXNEYW5nZXIpIHtcbiAgICAgIGN1cnJlbnRQYWdlLmRhbmdlckJ1dHRvbkNsaWNrZWQuZW1pdCgpO1xuICAgIH0gZWxzZSBpZiAoaXNOZXh0KSB7XG4gICAgICBjdXJyZW50UGFnZS5uZXh0QnV0dG9uQ2xpY2tlZC5lbWl0KCk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQYWdlLnN0b3BOZXh0IHx8IGN1cnJlbnRQYWdlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBjdXJyZW50UGFnZS5vbkNvbW1pdC5lbWl0KGN1cnJlbnRQYWdlLmlkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBvcmRlciBpcyB2ZXJ5IGltcG9ydGFudCB3aXRoIHRoZXNlIGVtaXR0ZXJzIVxuICAgIGlmIChpc0ZpbmlzaCkge1xuICAgICAgLy8gbWFyayBwYWdlIGFzIGNvbXBsZXRlXG4gICAgICBpZiAoIXRoaXMud2l6YXJkSGFzQWx0TmV4dCkge1xuICAgICAgICB0aGlzLnBhZ2VDb2xsZWN0aW9uLmNvbW1pdFBhZ2UoY3VycmVudFBhZ2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5fd2l6YXJkRmluaXNoZWQubmV4dCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpemFyZEhhc0FsdE5leHQpIHtcbiAgICAgIHRoaXMucGFnZUNvbGxlY3Rpb24uY29tbWl0UGFnZShjdXJyZW50UGFnZSk7XG5cbiAgICAgIGlmIChpc05leHQgfHwgaXNEYW5nZXJOZXh0KSB7XG4gICAgICAgIHRoaXMuX21vdmVkVG9OZXh0UGFnZS5uZXh0KHRydWUpO1xuICAgICAgfVxuICAgICAgLy8ganVtcCBvdXQgaGVyZSwgbm8gbWF0dGVyIHdoYXQgdHlwZSB3ZSdyZSBsb29raW5nIGF0XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTmV4dCB8fCBpc0Rhbmdlck5leHQpIHtcbiAgICAgIHRoaXMuZm9yY2VOZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBwdWJsaWMgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IGNvbmNsdWRlXG4gICAqIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIFdoZW4gaW52b2tlZCwgdGhpcyBtZXRob2Qgd2lsbCAgaW5pdGlhdGUgdGhlIHdvcmsgaW52b2x2ZWQgd2l0aCBmaW5hbGl6aW5nXG4gICAqIGFuZCBmaW5pc2hpbmcgdGhlIHdpemFyZCB3b3JrZmxvdy4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGdvZXMgdGhyb3VnaCBhbGxcbiAgICogY2hlY2tzIGFuZCBldmVudCBlbWlzc2lvbnMgYXMgaWYgV2l6YXJkLmZpbmlzaChmYWxzZSkgaGFkIGJlZW4gY2FsbGVkLlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHVzZSBXaXphcmQuZmluaXNoKGZhbHNlKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZmluaXNoKCk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnZmluaXNoJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9tb3ZlZFRvUHJldmlvdXNQYWdlID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIHdpemFyZCB3aGVuIGJhY2t3YXJkcyBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZCB2aWEgdGhlXG4gICAqIHByZXZpb3VzIGJ1dHRvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1vdmVkVG9QcmV2aW91c1BhZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX21vdmVkVG9QcmV2aW91c1BhZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvZ3JhbW1hdGljYWxseSBtb3ZlcyB0aGUgd2l6YXJkIHRvIHRoZSBwYWdlIGJlZm9yZSB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBJbiBtb3N0IGluc3RhbmNlcywgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byBjYWxsIFdpemFyZC5wcmV2aW91cygpXG4gICAqIHdoaWNoIGRvZXMgdGhlIHNhbWUgdGhpbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzKCk6IHZvaWQge1xuICAgIGxldCBwcmV2aW91c1BhZ2U6IENscldpemFyZFBhZ2U7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50UGFnZUlzRmlyc3QgfHwgdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHByZXZpb3VzUGFnZSA9IHRoaXMucGFnZUNvbGxlY3Rpb24uZ2V0UHJldmlvdXNQYWdlKHRoaXMuY3VycmVudFBhZ2UpO1xuXG4gICAgaWYgKCFwcmV2aW91c1BhZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tb3ZlZFRvUHJldmlvdXNQYWdlLm5leHQodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5mb3JjZUZvcndhcmROYXZpZ2F0aW9uKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFBhZ2UgPSBwcmV2aW91c1BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9jYW5jZWxXaXphcmQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSB3aXphcmQgdGhhdCBhIHVzZXIgaXMgdHJ5aW5nIHRvIGNhbmNlbCBpdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5vdGlmeVdpemFyZENhbmNlbCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxXaXphcmQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dzIGEgaG9vayBpbnRvIHRoZSBjYW5jZWwgd29ya2Zsb3cgb2YgdGhlIHdpemFyZCBmcm9tIHRoZSBuYXYgc2VydmljZS4gTm90ZSB0aGF0XG4gICAqIHRoaXMgcm91dGUgZ29lcyB0aHJvdWdoIGFsbCBjaGVja3MgYW5kIGV2ZW50IGVtaXNzaW9ucyBhcyBpZiBhIGNhbmNlbCBidXR0b24gaGFkXG4gICAqIGJlZW4gY2xpY2tlZC5cbiAgICpcbiAgICogSW4gbW9zdCBjYXNlcywgdXNlcnMgbG9va2luZyBmb3IgYSBob29rIGludG8gdGhlIGNhbmNlbCByb3V0aW5lIGFyZSBhY3R1YWxseSBsb29raW5nXG4gICAqIGZvciBhIHdheSB0byBjbG9zZSB0aGUgd2l6YXJkIGZyb20gdGhlaXIgaG9zdCBjb21wb25lbnQgYmVjYXVzZSB0aGV5IGhhdmUgcHJldmVudGVkXG4gICAqIHRoZSBkZWZhdWx0IGNhbmNlbCBhY3Rpb24uXG4gICAqXG4gICAqIEluIHRoaXMgaW5zdGFuY2UsIGl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSBXaXphcmQuY2xvc2UoKSB0byBhdm9pZCBhbnkgZXZlbnRcbiAgICogZW1pc3Npb24gbG9vcCByZXN1bHRpbmcgZnJvbSBhbiBldmVudCBoYW5kbGVyIGNhbGxpbmcgYmFjayBpbnRvIHJvdXRpbmUgdGhhdCB3aWxsXG4gICAqIGFnYWluIGV2b2tlIHRoZSBldmVudHMgaXQgaGFuZGxlcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMuX2NhbmNlbFdpemFyZC5uZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogQSBib29sZWFuIGZsYWcgc2hhcmVkIGFjcm9zcyB0aGUgV2l6YXJkIHN1YmNvbXBvbmVudHMgdGhhdCBmb2xsb3dzIHRoZSB2YWx1ZVxuICAgKiBvZiB0aGUgV2l6YXJkLnN0b3BDYW5jZWwgKGNscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsKSBpbnB1dC4gV2hlbiB0cnVlLCB0aGUgY2FuY2VsXG4gICAqIHJvdXRpbmUgaXMgc3VidmVydGVkIGFuZCBtdXN0IGJlIHJlaW5zdGF0ZWQgaW4gdGhlIGhvc3QgY29tcG9uZW50IGNhbGxpbmcgV2l6YXJkLmNsb3NlKClcbiAgICogYXQgc29tZSBwb2ludC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgd2l6YXJkSGFzQWx0Q2FuY2VsOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBmbGFnIHNoYXJlZCBhY3Jvc3MgdGhlIFdpemFyZCBzdWJjb21wb25lbnRzIHRoYXQgZm9sbG93cyB0aGUgdmFsdWVcbiAgICogb2YgdGhlIFdpemFyZC5zdG9wTmV4dCAoY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0KSBpbnB1dC4gV2hlbiB0cnVlLCB0aGUgbmV4dCBhbmQgZmluaXNoXG4gICAqIHJvdXRpbmVzIGFyZSBzdWJ2ZXJ0ZWQgYW5kIG11c3QgYmUgcmVpbnN0YXRlZCBpbiB0aGUgaG9zdCBjb21wb25lbnQgY2FsbGluZyBXaXphcmQubmV4dCgpLFxuICAgKiBXaXphcmQuZm9yY2VOZXh0KCksIFdpemFyZC5maW5pc2goKSwgb3IgV2l6YXJkLmZvcmNlRmluaXNoKCkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHdpemFyZEhhc0FsdE5leHQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBib29sZWFuIGZsYWcgc2hhcmVkIGFjcm9zcyB0aGUgV2l6YXJkIHN1YmNvbXBvbmVudHMgdGhhdCBmb2xsb3dzIHRoZSB2YWx1ZVxuICAgKiBvZiB0aGUgV2l6YXJkLnN0b3BOYXZpZ2F0aW9uIChjbHJXaXphcmRQcmV2ZW50TmF2aWdhdGlvbikgaW5wdXQuIFdoZW4gdHJ1ZSwgYWxsXG4gICAqIG5hdmlnYXRpb25hbCBlbGVtZW50cyBpbiB0aGUgd2l6YXJkIGFyZSBkaXNhYmxlZC5cbiAgICpcbiAgICogVGhpcyBpcyBpbnRlbmRlZCB0byBmcmVlemUgdGhlIHdpemFyZCBpbiBwbGFjZS4gRXZlbnRzIGFyZSBub3QgZmlyZWQgc28gdGhpcyBpc1xuICAgKiBub3QgYSB3YXkgdG8gaW1wbGVtZW50IGFsdGVybmF0ZSBmdW5jdGlvbmFsaXR5IGZvciBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB3aXphcmRTdG9wTmF2aWdhdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgd2l0aCB0aGUgc3RlcG5hdiBpdGVtcyB0aGF0IHByZXZlbnRzIHVzZXIgY2xpY2tzIG9uXG4gICAqIHN0ZXBuYXYgaXRlbXMgZnJvbSBuYXZpZ2F0aW5nIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHdpemFyZERpc2FibGVTdGVwbmF2OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGFsbCByZXF1aXJlZCBjaGVja3MgdG8gZGV0ZXJtaW5lIGlmIGEgdXNlciBjYW4gbmF2aWdhdGUgdG8gYSBwYWdlLiBDaGVja2luZyBhdCBlYWNoXG4gICAqIHBvaW50IGlmIGEgcGFnZSBpcyBuYXZpZ2FibGUgLS0gY29tcGxldGVkIHdoZXJlIHRoZSBwYWdlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBsYXN0IGNvbXBsZXRlZFxuICAgKiBwYWdlLlxuICAgKlxuICAgKiBUYWtlcyB0d28gcGFyYW1ldGVycy4gVGhlIGZpcnN0IG9uZSBtdXN0IGJlIGVpdGhlciB0aGUgQ2xyV2l6YXJkUGFnZSBvYmplY3Qgb3IgdGhlIElEIG9mIHRoZVxuICAgKiBDbHJXaXphcmRQYWdlIG9iamVjdCB0aGF0IHlvdSB3YW50IHRvIG1ha2UgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogVGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwgYW5kIGlzIGEgQm9vbGVhbiBmbGFnIGZvciBcImxhenkgY29tcGxldGlvblwiLiBXaGF0IHRoaXMgbWVhbnNcbiAgICogaXMgdGhlIFdpemFyZCB3aWxsIG1hcmsgYWxsIHBhZ2VzIGJldHdlZW4gdGhlIGN1cnJlbnQgcGFnZSBhbmQgdGhlIHBhZ2UgeW91IHdhbnQgdG8gbmF2aWdhdGVcbiAgICogdG8gYXMgY29tcGxldGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgaW5mb3JtYXRpb25hbCB3aXphcmRzIHRoYXQgZG8gbm90IHJlcXVpcmUgdXNlciBhY3Rpb24sXG4gICAqIGFsbG93aW5nIGFuIGVhc3kgbWVhbnMgZm9yIHVzZXJzIHRvIGp1bXAgYWhlYWQuXG4gICAqXG4gICAqIFRvIGF2b2lkIGNoZWNrcyBvbiBuYXZpZ2F0aW9uLCB1c2UgQ2xyV2l6YXJkUGFnZS5tYWtlQ3VycmVudCgpIGluc3RlYWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdvVG8ocGFnZVRvR29Ub09ySWQ6IGFueSwgbGF6eUNvbXBsZXRlOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBsZXQgcGFnZVRvR29UbzogQ2xyV2l6YXJkUGFnZTtcbiAgICBsZXQgY3VycmVudFBhZ2U6IENscldpemFyZFBhZ2U7XG4gICAgbGV0IG15UGFnZXM6IFBhZ2VDb2xsZWN0aW9uU2VydmljZTtcbiAgICBsZXQgcGFnZXNUb0NoZWNrOiBDbHJXaXphcmRQYWdlW107XG4gICAgbGV0IG9rYXlUb01vdmU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGxldCBnb2luZ0ZvcndhcmQ6IGJvb2xlYW47XG4gICAgbGV0IGN1cnJlbnRQYWdlSW5kZXg6IG51bWJlcjtcbiAgICBsZXQgZ29Ub1BhZ2VJbmRleDogbnVtYmVyO1xuXG4gICAgbXlQYWdlcyA9IHRoaXMucGFnZUNvbGxlY3Rpb247XG4gICAgcGFnZVRvR29UbyA9IHR5cGVvZiBwYWdlVG9Hb1RvT3JJZCA9PT0gJ3N0cmluZycgPyBteVBhZ2VzLmdldFBhZ2VCeUlkKHBhZ2VUb0dvVG9PcklkKSA6IHBhZ2VUb0dvVG9PcklkO1xuICAgIGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcblxuICAgIC8vIG5vIHBvaW50IGluIGdvaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UuIHlvdSdyZSB0aGVyZSBhbHJlYWR5IVxuICAgIC8vIGFsc28gaGFyZCBibG9jayBvbiBhbnkgbmF2aWdhdGlvbiB3aGVuIHN0b3BOYXZpZ2F0aW9uIGlzIHRydWVcbiAgICBpZiAocGFnZVRvR29UbyA9PT0gY3VycmVudFBhZ2UgfHwgdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRQYWdlSW5kZXggPSBteVBhZ2VzLmdldFBhZ2VJbmRleChjdXJyZW50UGFnZSk7XG4gICAgZ29Ub1BhZ2VJbmRleCA9IG15UGFnZXMuZ2V0UGFnZUluZGV4KHBhZ2VUb0dvVG8pO1xuICAgIGdvaW5nRm9yd2FyZCA9IGdvVG9QYWdlSW5kZXggPiBjdXJyZW50UGFnZUluZGV4O1xuICAgIHBhZ2VzVG9DaGVjayA9IG15UGFnZXMuZ2V0UGFnZVJhbmdlRnJvbVBhZ2VzKHRoaXMuY3VycmVudFBhZ2UsIHBhZ2VUb0dvVG8pO1xuXG4gICAgb2theVRvTW92ZSA9IGxhenlDb21wbGV0ZSB8fCB0aGlzLmNhbkdvVG8ocGFnZXNUb0NoZWNrKTtcblxuICAgIGlmICghb2theVRvTW92ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChnb2luZ0ZvcndhcmQgJiYgbGF6eUNvbXBsZXRlKSB7XG4gICAgICBwYWdlc1RvQ2hlY2suZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4ge1xuICAgICAgICBpZiAocGFnZSAhPT0gcGFnZVRvR29Ubykge1xuICAgICAgICAgIHBhZ2UuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghZ29pbmdGb3J3YXJkICYmIHRoaXMuZm9yY2VGb3J3YXJkTmF2aWdhdGlvbikge1xuICAgICAgcGFnZXNUb0NoZWNrLmZvckVhY2goKHBhZ2U6IENscldpemFyZFBhZ2UpID0+IHtcbiAgICAgICAgcGFnZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFBhZ2UgPSBwYWdlVG9Hb1RvO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSByYW5nZSBvZiBDbHJXaXphcmRQYWdlIG9iamVjdHMgYXMgYSBwYXJhbWV0ZXIuIFBlcmZvcm1zIHRoZSB3b3JrIG9mIGNoZWNraW5nXG4gICAqIHRob3NlIG9iamVjdHMgdG8gZGV0ZXJtaW5lIGlmIG5hdmlnYXRpb24gY2FuIGJlIGFjY29tcGxpc2hlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2FuR29UbyhwYWdlc1RvQ2hlY2s6IENscldpemFyZFBhZ2VbXSk6IGJvb2xlYW4ge1xuICAgIGxldCBva2F5VG9Nb3ZlID0gdHJ1ZTtcbiAgICBjb25zdCBteVBhZ2VzID0gdGhpcy5wYWdlQ29sbGVjdGlvbjtcblxuICAgIC8vIHByZXZpb3VzIHBhZ2UgY2FuIGJlIGltcG9ydGFudCB3aGVuIG1vdmluZyBiZWNhdXNlIGlmIGl0J3MgY29tcGxldGVkIGl0XG4gICAgLy8gYWxsb3dzIHVzIHRvIG1vdmUgdG8gdGhlIHBhZ2UgZXZlbiBpZiBpdCdzIGluY29tcGxldGUuLi5cbiAgICBsZXQgcHJldmlvdXNQYWdlUGFzc2VzOiBib29sZWFuO1xuXG4gICAgaWYgKCFwYWdlc1RvQ2hlY2sgfHwgcGFnZXNUb0NoZWNrLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwYWdlc1RvQ2hlY2suZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4ge1xuICAgICAgbGV0IHByZXZpb3VzUGFnZTogQ2xyV2l6YXJkUGFnZTtcblxuICAgICAgaWYgKCFva2F5VG9Nb3ZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2UuY29tcGxldGVkKSB7XG4gICAgICAgIC8vIGRlZmF1bHQgaXMgdHJ1ZS4ganVzdCBqdW1wIG91dCBpbnN0ZWFkIG9mIGNvbXBsaWNhdGluZyBpdC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzbyB3ZSBrbm93IG91ciBwYWdlIGlzIG5vdCBjb21wbGV0ZWQuLi5cbiAgICAgIHByZXZpb3VzUGFnZSA9IG15UGFnZXMuZ2V0UGFnZUluZGV4KHBhZ2UpID4gMCA/IG15UGFnZXMuZ2V0UHJldmlvdXNQYWdlKHBhZ2UpIDogbnVsbDtcbiAgICAgIHByZXZpb3VzUGFnZVBhc3NlcyA9IHByZXZpb3VzUGFnZSA9PT0gbnVsbCB8fCBwcmV2aW91c1BhZ2UuY29tcGxldGVkID09PSB0cnVlO1xuXG4gICAgICAvLyB3ZSBhcmUgZmFsc2UgaWYgbm90IHRoZSBjdXJyZW50IHBhZ2UgQU5EIHByZXZpb3VzIHBhZ2UgaXMgbm90IGNvbXBsZXRlZFxuICAgICAgLy8gKGJ1dCBtdXN0IGhhdmUgYSBwcmV2aW91cyBwYWdlKVxuICAgICAgaWYgKCFwYWdlLmN1cnJlbnQgJiYgIXByZXZpb3VzUGFnZVBhc3Nlcykge1xuICAgICAgICBva2F5VG9Nb3ZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoIHRvIHRydWUgYXMgZGVmYXVsdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9rYXlUb01vdmU7XG4gIH1cblxuICAvKipcbiAgICogTG9va3MgdGhyb3VnaCB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcyB0byBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpcyBpbmNvbXBsZXRlXG4gICAqIGFuZCBtYWtlcyB0aGF0IHBhZ2UgdGhlIGN1cnJlbnQvYWN0aXZlIHBhZ2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNldExhc3RFbmFibGVkUGFnZUN1cnJlbnQoKTogdm9pZCB7XG4gICAgY29uc3QgYWxsUGFnZXM6IENscldpemFyZFBhZ2VbXSA9IHRoaXMucGFnZUNvbGxlY3Rpb24ucGFnZXNBc0FycmF5O1xuICAgIGxldCBsYXN0Q29tcGxldGVkUGFnZUluZGV4OiBudW1iZXIgPSBudWxsO1xuXG4gICAgYWxsUGFnZXMuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKHBhZ2UuY29tcGxldGVkKSB7XG4gICAgICAgIGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChsYXN0Q29tcGxldGVkUGFnZUluZGV4ID09PSBudWxsKSB7XG4gICAgICAvLyBhbHdheXMgaXMgYXQgbGVhc3QgdGhlIGZpcnN0IGl0ZW0uLi5cbiAgICAgIGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAobGFzdENvbXBsZXRlZFBhZ2VJbmRleCArIDEgPCBhbGxQYWdlcy5sZW5ndGgpIHtcbiAgICAgIGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggPSBsYXN0Q29tcGxldGVkUGFnZUluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gYWxsUGFnZXNbbGFzdENvbXBsZXRlZFBhZ2VJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMgYW5kIG1ha2VzIHRoYXQgcGFnZSB0aGVcbiAgICogY3VycmVudC9hY3RpdmUgcGFnZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgc2V0Rmlyc3RQYWdlQ3VycmVudCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5wYWdlc0FzQXJyYXlbMF07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RlcG5hdiBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB3aXphcmQgd2hlbiBwYWdlcyBhcmUgZHluYW1pY2FsbHlcbiAgICogYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVOYXZpZ2F0aW9uKCk6IHZvaWQge1xuICAgIGxldCB0b1NldEN1cnJlbnQ6IENscldpemFyZFBhZ2U7XG4gICAgbGV0IGN1cnJlbnRQYWdlUmVtb3ZlZDogYm9vbGVhbjtcblxuICAgIHRoaXMucGFnZUNvbGxlY3Rpb24udXBkYXRlQ29tcGxldGVkU3RhdGVzKCk7XG5cbiAgICBjdXJyZW50UGFnZVJlbW92ZWQgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzQXNBcnJheS5pbmRleE9mKHRoaXMuY3VycmVudFBhZ2UpIDwgMDtcbiAgICBpZiAoY3VycmVudFBhZ2VSZW1vdmVkKSB7XG4gICAgICB0b1NldEN1cnJlbnQgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLmZpbmRGaXJzdEluY29tcGxldGVQYWdlKCk7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlID0gdG9TZXRDdXJyZW50O1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENscldpemFyZEhlYWRlckFjdGlvbiB9IGZyb20gJy4uL3dpemFyZC1oZWFkZXItYWN0aW9uJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhlYWRlckFjdGlvblNlcnZpY2Uge1xuICAvLyB0aGlzIHNlcnZpY2UgY29tbXVuaWNhdGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcmVzZW5jZS9kaXNwbGF5IG9mIGhlYWRlciBhY3Rpb25zXG4gIC8vIGFjcm9zcyB0aGUgd2l6YXJkXG5cbiAgY29uc3RydWN0b3IocHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlKSB7fVxuXG4gIHB1YmxpYyB3aXphcmRIZWFkZXJBY3Rpb25zOiBRdWVyeUxpc3Q8Q2xyV2l6YXJkSGVhZGVyQWN0aW9uPjtcblxuICBwdWJsaWMgZ2V0IHdpemFyZEhhc0hlYWRlckFjdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgd2l6YXJkSGRyQWN0aW9ucyA9IHRoaXMud2l6YXJkSGVhZGVyQWN0aW9ucztcbiAgICBpZiAoIXdpemFyZEhkckFjdGlvbnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHdpemFyZEhkckFjdGlvbnMudG9BcnJheSgpLmxlbmd0aCA+IDA7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlSGFzSGVhZGVyQWN0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlID8gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlLmhhc0hlYWRlckFjdGlvbnMgOiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2hvd1dpemFyZEhlYWRlckFjdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLmN1cnJlbnRQYWdlSGFzSGVhZGVyQWN0aW9ucyAmJiB0aGlzLndpemFyZEhhc0hlYWRlckFjdGlvbnM7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGRpc3BsYXlIZWFkZXJBY3Rpb25zV3JhcHBlcigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50UGFnZUhhc0hlYWRlckFjdGlvbnMgfHwgdGhpcy53aXphcmRIYXNIZWFkZXJBY3Rpb25zO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmxldCB3aXphcmRIZWFkZXJBY3Rpb25JbmRleCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQtaGVhZGVyLWFjdGlvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGNsYXNzPVwiYnRuIGNsci13aXphcmQtaGVhZGVyLWFjdGlvbiBidG4tbGlua1wiXG4gICAgICAgICAgICBbaWRdPVwiaWRcIlxuICAgICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjbGljaygpXCJcbiAgICAgICAgICAgIFt0aXRsZV09XCJ0aXRsZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgLFxuICBob3N0OiB7IGNsYXNzOiAnY2xyLXdpemFyZC1oZWFkZXItYWN0aW9uLXdyYXBwZXInIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZEhlYWRlckFjdGlvbiB7XG4gIC8vIHRpdGxlIGlzIGV4cGxhbmF0b3J5IHRleHQgYWRkZWQgdG8gdGhlIGhlYWRlciBhY3Rpb25cbiAgQElucHV0KCd0aXRsZScpIHRpdGxlOiBzdHJpbmcgPSAnJztcblxuICAvLyBJZiBvdXIgaG9zdCBoYXMgYW4gSUQgYXR0cmlidXRlLCB3ZSB1c2UgdGhpcyBpbnN0ZWFkIG9mIG91ciBpbmRleC5cbiAgQElucHV0KCdpZCcpIF9pZDogc3RyaW5nID0gKHdpemFyZEhlYWRlckFjdGlvbkluZGV4KyspLnRvU3RyaW5nKCk7XG5cbiAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2xyLXdpemFyZC1oZWFkZXItYWN0aW9uLSR7dGhpcy5faWR9YDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyV2l6YXJkSGVhZGVyQWN0aW9uRGlzYWJsZWQnKSBwdWJsaWMgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBAT3V0cHV0KCdhY3Rpb25DbGlja2VkJykgaGVhZGVyQWN0aW9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKGZhbHNlKTtcblxuICBjbGljaygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHBhc3NpbmcgdGhlIGhlYWRlciBhY3Rpb24gaWQgYWxsb3dzIHVzZXJzIHRvIGhhdmUgb25lIG1ldGhvZCB0aGF0XG4gICAgLy8gcm91dGVzIHRvIG1hbnkgZGlmZmVyZW50IGFjdGlvbnMgYmFzZWQgb24gdGhlIHR5cGUgb2YgaGVhZGVyIGFjdGlvblxuICAgIC8vIGNsaWNrZWQuIHRoaXMgaXMgZnVydGhlciBhaWRlZCBieSB1c2VycyBiZWluZyBhYmxlIHRvIHNwZWNpZnkgaWRzXG4gICAgLy8gZm9yIHRoZWlyIGhlYWRlciBhY3Rpb25zLlxuICAgIHRoaXMuaGVhZGVyQWN0aW9uQ2xpY2tlZC5lbWl0KHRoaXMuX2lkKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQYWdlQnV0dG9uc10nIH0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZUJ1dHRvbnMge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZUJ1dHRvbnNUZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUGFnZUhlYWRlckFjdGlvbnNdJyB9KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFBhZ2VIZWFkZXJBY3Rpb25zIHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VIZWFkZXJBY3Rpb25zVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhZ2VOYXZUaXRsZV0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZU5hdlRpdGxlIHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VOYXZUaXRsZVRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQYWdlVGl0bGVdJyB9KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFBhZ2VUaXRsZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlVGl0bGVUZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYnV0dG9uLWh1Yi5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VDb2xsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UtY29sbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlQnV0dG9ucyB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtYnV0dG9ucyc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucyB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtaGVhZGVyLWFjdGlvbnMnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZU5hdlRpdGxlIH0gZnJvbSAnLi93aXphcmQtcGFnZS1uYXZ0aXRsZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlVGl0bGUgfSBmcm9tICcuL3dpemFyZC1wYWdlLXRpdGxlJztcblxubGV0IHdpemFyZFBhZ2VJbmRleCA9IDA7XG5cbi8qKlxuICogVGhlIENscldpemFyZFBhZ2UgY29tcG9uZW50IGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwbGF5aW5nIHRoZSBjb250ZW50IG9mIGVhY2ggc3RlcFxuICogaW4gdGhlIHdpemFyZCB3b3JrZmxvdy5cbiAqXG4gKiBDbHJXaXphcmRQYWdlIGNvbXBvbmVudCBoYXMgaG9va3MgaW50byB0aGUgbmF2aWdhdGlvbiBzZXJ2aWNlIChDbHJXaXphcmRQYWdlLm5hdlNlcnZpY2UpLFxuICogcGFnZSBjb2xsZWN0aW9uIChDbHJXaXphcmRQYWdlLnBhZ2VDb2xsZWN0aW9uKSwgYW5kIGJ1dHRvbiBzZXJ2aWNlXG4gKiAoQ2xyV2l6YXJkUGFnZS5idXR0b25TZXJ2aWNlKS4gVGhlc2UgdGhyZWUgcHJvdmlkZXJzIGFyZSBzaGFyZWQgYWNyb3NzIHRoZSBjb21wb25lbnRzXG4gKiB3aXRoaW4gZWFjaCBpbnN0YW5jZSBvZiBhIFdpemFyZC5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQtcGFnZScsXG4gIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICdpZCcsXG4gICAgcm9sZTogJ3RhYnBhbmVsJyxcbiAgICAnW2F0dHIuYXJpYS1oaWRkZW5dJzogJyFjdXJyZW50JyxcbiAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICdzdGVwSXRlbUlkJyxcbiAgICAnW2NsYXNzLmFjdGl2ZV0nOiAnY3VycmVudCcsXG4gICAgJ1tjbGFzcy5jbHItd2l6YXJkLXBhZ2VdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRQYWdlIGltcGxlbWVudHMgT25Jbml0IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ2xyV2l6YXJkUGFnZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbmF2U2VydmljZTogV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgcHVibGljIHBhZ2VDb2xsZWN0aW9uOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UsXG4gICAgcHVibGljIGJ1dHRvblNlcnZpY2U6IEJ1dHRvbkh1YlNlcnZpY2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgcGFnZSB0aXRsZSB3aGljaCBpcyB1c2VkIGZvciBhIG51bWJlclxuICAgKiBvZiBkaWZmZXJlbnQgdGFza3MgZm9yIGRpc3BsYXkgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyV2l6YXJkUGFnZVRpdGxlKSBwdWJsaWMgcGFnZVRpdGxlOiBDbHJXaXphcmRQYWdlVGl0bGU7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBkZXNpcmVkIHRpdGxlIGZvciB0aGUgcGFnZSdzIHN0ZXAgaW4gdGhlXG4gICAqIG5hdmlnYXRpb24gb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgd2l6YXJkLiBDYW4gYmUgcHJvamVjdGVkIHRvIGNoYW5nZSB0aGVcbiAgICogbmF2aWdhdGlvbiBsaW5rJ3MgdGV4dC5cbiAgICpcbiAgICogSWYgbm90IGRlZmluZWQsIHRoZW4gQ2xyV2l6YXJkUGFnZS5wYWdlVGl0bGUgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIHN0ZXBuYXYuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkKENscldpemFyZFBhZ2VOYXZUaXRsZSkgcHVibGljIHBhZ2VOYXZUaXRsZTogQ2xyV2l6YXJkUGFnZU5hdlRpdGxlO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgYnV0dG9ucyBkZWZpbmVkIHdpdGhpbiB0aGUgcGFnZS4gSWYgbm90IGRlZmluZWQsXG4gICAqIHRoZSB3aXphcmQgZGVmYXVsdHMgdG8gdGhlIHNldCBvZiBidXR0b25zIGRlZmluZWQgYXMgYSBkaXJlY3QgY2hpbGQgb2YgdGhlXG4gICAqIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyV2l6YXJkUGFnZUJ1dHRvbnMpIHB1YmxpYyBfYnV0dG9uczogQ2xyV2l6YXJkUGFnZUJ1dHRvbnM7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBoZWFkZXIgYWN0aW9ucyBkZWZpbmVkIHdpdGhpbiB0aGUgcGFnZS4gSWYgbm90IGRlZmluZWQsXG4gICAqIHRoZSB3aXphcmQgZGVmYXVsdHMgdG8gdGhlIHNldCBvZiBoZWFkZXIgYWN0aW9ucyBkZWZpbmVkIGFzIGEgZGlyZWN0IGNoaWxkIG9mIHRoZVxuICAgKiB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkKENscldpemFyZFBhZ2VIZWFkZXJBY3Rpb25zKSBwdWJsaWMgX2hlYWRlckFjdGlvbnM6IENscldpemFyZFBhZ2VIZWFkZXJBY3Rpb25zO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfbmV4dFN0ZXBEaXNhYmxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGdldHRlciB0aGF0IHRlbGxzIHdoZXRoZXIgb3Igbm90IHRoZSB3aXphcmQgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICogdG8gbW92ZSB0byB0aGUgbmV4dCBwYWdlLlxuICAgKlxuICAgKiBVc2VmdWwgZm9yIGluLXBhZ2UgdmFsaWRhdGlvbiBiZWNhdXNlIGl0IHByZXZlbnRzIGZvcndhcmQgbmF2aWdhdGlvblxuICAgKiBhbmQgdmlzaWJseSBkaXNhYmxlcyB0aGUgbmV4dCBidXR0b24uXG4gICAqXG4gICAqIERvZXMgbm90IHJlcXVpcmUgdGhhdCB5b3UgcmUtaW1wbGVtZW50IG5hdmlnYXRpb24gcm91dGluZXMgbGlrZSB5b3VcbiAgICogd291bGQgaWYgeW91IHdlcmUgdXNpbmcgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdCBvclxuICAgKiBXaXphcmQucHJldmVudERlZmF1bHQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IG5leHRTdGVwRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRTdGVwRGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSBwYWdlIHNob3VsZCBhbGxvdyBmb3J3YXJkIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VOZXh0RGlzYWJsZWQnKVxuICBwdWJsaWMgc2V0IG5leHRTdGVwRGlzYWJsZWQodmFsOiBib29sZWFuKSB7XG4gICAgY29uc3QgdmFsQm9vbCA9ICEhdmFsO1xuICAgIGlmICh2YWxCb29sICE9PSB0aGlzLl9uZXh0U3RlcERpc2FibGVkKSB7XG4gICAgICB0aGlzLl9uZXh0U3RlcERpc2FibGVkID0gdmFsQm9vbDtcbiAgICAgIHRoaXMubmV4dFN0ZXBEaXNhYmxlZENoYW5nZS5lbWl0KHZhbEJvb2wpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB2YWx1ZSBvZiBDbHJXaXphcmRQYWdlLm5leHRTdGVwRGlzYWJsZWQgY2hhbmdlcy5cbiAgICogU2hvdWxkIGVtaXQgdGhlIG5ldyB2YWx1ZSBvZiBuZXh0U3RlcERpc2FibGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZU5leHREaXNhYmxlZENoYW5nZScpIG5leHRTdGVwRGlzYWJsZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHByaXZhdGUgX3ByZXZpb3VzU3RlcERpc2FibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIHRoYXQgdGVsbHMgd2hldGhlciBvciBub3QgdGhlIHdpemFyZCBzaG91bGQgYmUgYWxsb3dlZFxuICAgKiB0byBtb3ZlIHRvIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgKlxuICAgKiBVc2VmdWwgZm9yIGluLXBhZ2UgdmFsaWRhdGlvbiBiZWNhdXNlIGl0IHByZXZlbnRzIGJhY2t3YXJkIG5hdmlnYXRpb25cbiAgICogYW5kIHZpc2libHkgZGlzYWJsZXMgdGhlIHByZXZpb3VzIGJ1dHRvbi5cbiAgICpcbiAgICogRG9lcyBub3QgcmVxdWlyZSB0aGF0IHlvdSByZS1pbXBsZW1lbnQgbmF2aWdhdGlvbiByb3V0aW5lcyBsaWtlIHlvdVxuICAgKiB3b3VsZCBpZiB5b3Ugd2VyZSB1c2luZyBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0IG9yXG4gICAqIFdpemFyZC5wcmV2ZW50RGVmYXVsdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgcHJldmlvdXNTdGVwRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzU3RlcERpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgcGFnZSBzaG91bGQgYWxsb3cgYmFja3dhcmQgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUGFnZVByZXZpb3VzRGlzYWJsZWQnKVxuICBwdWJsaWMgc2V0IHByZXZpb3VzU3RlcERpc2FibGVkKHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhbEJvb2wgPSAhIXZhbDtcbiAgICBpZiAodmFsQm9vbCAhPT0gdGhpcy5fcHJldmlvdXNTdGVwRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuX3ByZXZpb3VzU3RlcERpc2FibGVkID0gdmFsQm9vbDtcbiAgICAgIHRoaXMucHJldmlvdXNTdGVwRGlzYWJsZWRDaGFuZ2UuZW1pdCh2YWxCb29sKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgdmFsdWUgb2YgQ2xyV2l6YXJkUGFnZS5wcmV2aW91c1N0ZXBEaXNhYmxlZCBjaGFuZ2VzLlxuICAgKiBTaG91bGQgZW1pdCB0aGUgbmV3IHZhbHVlIG9mIHByZXZpb3VzU3RlcERpc2FibGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZVByZXZpb3VzRGlzYWJsZWRDaGFuZ2UnKVxuICBwdWJsaWMgcHJldmlvdXNTdGVwRGlzYWJsZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGFsbCBhY3Rpb25zIGZyb20gdGhlIHBhZ2UgbGV2ZWwsIHNvIHlvdSBjYW4gdXNlIGFuIGFsdGVybmF0ZSBmdW5jdGlvbiBmb3JcbiAgICogdmFsaWRhdGlvbiBvciBkYXRhLW11bmdpbmcgd2l0aCBhIENscldpemFyZFBhZ2Uub25Db21taXQgKGNscldpemFyZFBhZ2VPbkNvbW1pdCBvdXRwdXQpLFxuICAgKiBDbHJXaXphcmRQYWdlLm9uQ2FuY2VsIChjbHJXaXphcmRQYWdlT25DYW5jZWwgb3V0cHV0KSwgb3Igb25lXG4gICAqIG9mIHRoZSBncmFudWxhciBwYWdlLWxldmVsIGJ1dHRvbiBjbGljayBldmVudCBlbWl0dGVycy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0JykgcHVibGljIHByZXZlbnREZWZhdWx0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9zdG9wQ2FuY2VsID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0cmlldmVzIHdoZXRoZXIgdGhlIHBhZ2UgaXMgcHJldmVudGluZyB0aGUgY2FuY2VsIGFjdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgc3RvcENhbmNlbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcENhbmNlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIGNhbmNlbCBhY3Rpb24gZnJvbSB0aGUgcGFnZSBsZXZlbC4gQWxsb3dzIHlvdSB0byB1c2UgYW5cbiAgICogYWx0ZXJuYXRlIGZ1bmN0aW9uIGZvciB2YWxpZGF0aW9uIG9yIGRhdGEtbXVuZ2luZyBiZWZvcmUgY2FuY2VsbGluZyB0aGVcbiAgICogd2l6YXJkIHdoZW4gY29tYmluZWQgd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5vbkNhbmNlbFxuICAgKiAodGhlIGNscldpemFyZFBhZ2VPbkNhbmNlbCBvdXRwdXQpLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGF0IHlvdSBtYW51YWxseSBjbG9zZSB0aGUgd2l6YXJkIGZyb20geW91ciBob3N0IGNvbXBvbmVudCxcbiAgICogdXN1YWxseSB3aXRoIGEgY2FsbCB0byBXaXphcmQuZm9yY2VOZXh0KCkgb3Igd2l6YXJkLm5leHQoKTtcbiAgICpcbiAgICogQG1lbWJlcm9mIENscldpemFyZFBhZ2VcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0Q2FuY2VsJylcbiAgcHVibGljIHNldCBzdG9wQ2FuY2VsKHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhbEJvb2wgPSAhIXZhbDtcbiAgICBpZiAodmFsQm9vbCAhPT0gdGhpcy5fc3RvcENhbmNlbCkge1xuICAgICAgdGhpcy5fc3RvcENhbmNlbCA9IHZhbEJvb2w7XG4gICAgICB0aGlzLnN0b3BDYW5jZWxDaGFuZ2UuZW1pdCh2YWxCb29sKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdENhbmNlbENoYW5nZScpIHN0b3BDYW5jZWxDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHByaXZhdGUgX3N0b3BOZXh0ID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgZ2V0dGVyIHRoYXQgdGVsbHMgeW91IHdoZXRoZXIgdGhlIHBhZ2UgaXMgcHJldmVudGluZyB0aGUgbmV4dCBhY3Rpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0b3BOZXh0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdG9wTmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZm9yd2FyZCBuYXZpZ2F0aW9uIGZyb20gdGhlIHBhZ2UgbGV2ZWwuIEFsbG93cyB5b3UgdG8gdXNlIGFuXG4gICAqIGFsdGVybmF0ZSBmdW5jdGlvbiBmb3IgdmFsaWRhdGlvbiBvciBkYXRhLW11bmdpbmcgYmVmb3JlIG1vdmluZyB0aGVcbiAgICogd2l6YXJkIHRvIHRoZSBuZXh0IHBhZ2V3aGVuIGNvbWJpbmVkIHdpdGggdGhlIENscldpemFyZFBhZ2Uub25Db21taXRcbiAgICogKGNscldpemFyZFBhZ2VPbkNvbW1pdCkgb3IgQ2xyV2l6YXJkUGFnZS5uZXh0QnV0dG9uQ2xpY2tlZFxuICAgKiAoY2xyV2l6YXJkUGFnZU5leHQpIG91dHB1dHMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoYXQgeW91IG1hbnVhbGx5IHRlbGwgdGhlIHdpemFyZCB0byBuYXZpZ2F0ZSBmb3J3YXJkIGZyb21cbiAgICogdGhlIGhvc3RDb21wb25lbnQsIHVzdWFsbHkgd2l0aCBhIGNhbGwgdG8gV2l6YXJkLmZvcmNlTmV4dCgpIG9yXG4gICAqIHdpemFyZC5uZXh0KCk7XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRQYWdlXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdE5leHQnKVxuICBwdWJsaWMgc2V0IHN0b3BOZXh0KHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhbEJvb2wgPSAhIXZhbDtcbiAgICBpZiAodmFsQm9vbCAhPT0gdGhpcy5fc3RvcE5leHQpIHtcbiAgICAgIHRoaXMuX3N0b3BOZXh0ID0gdmFsQm9vbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQW4gZXZlbnQgZW1pdHRlciBjYXJyaWVkIG92ZXIgZnJvbSBhIGxlZ2FjeSB2ZXJzaW9uIG9mIENscldpemFyZFBhZ2UuXG4gICAqIEZpcmVzIGFuIGV2ZW50IG9uIENscldpemFyZFBhZ2Ugd2hlbmV2ZXIgdGhlIG5leHQgb3IgZmluaXNoIGJ1dHRvbnNcbiAgICogYXJlIGNsaWNrZWQgYW5kIHRoZSBwYWdlIGlzIHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhlIFdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYXV0b21hdGljYWxseSBlbWl0IGFuIGV2ZW50IHdoZW4gYSBjdXN0b21cbiAgICogYnV0dG9uIGlzIHVzZWQgaW4gcGxhY2Ugb2YgYSBuZXh0IG9yIGZpbmlzaCBidXR0b24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlT25Db21taXQnKSBvbkNvbW1pdDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIENscldpemFyZFBhZ2UgYmVjb21lcyB0aGUgY3VycmVudCBwYWdlIG9mIHRoZVxuICAgKiBXaXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlT25Mb2FkJykgb25Mb2FkOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgQ2xyV2l6YXJkUGFnZSBpbnZva2VzIHRoZSBjYW5jZWwgcm91dGluZSBmb3IgdGhlIHdpemFyZC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5zdG9wQ2FuY2VsXG4gICAqIChjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHRDYW5jZWwpIG9yIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0cyB0byBpbXBsZW1lbnQgY3VzdG9tIGNhbmNlbFxuICAgKiBmdW5jdGlvbmFsaXR5IGF0IHRoZSBwYWdlIGxldmVsLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkb1xuICAgKiB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm4gdXNlcnMgYmVmb3JlIGNhbmNlbGxpbmcgdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLmNsb3NlKCkgZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuXG4gICAqIFRoaXMgY29uc3RpdHVlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2YgdGhlIGNhbmNlbCBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZU9uQ2FuY2VsJykgcGFnZU9uQ2FuY2VsOiBFdmVudEVtaXR0ZXI8Q2xyV2l6YXJkUGFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIENscldpemFyZFBhZ2UgaXNcbiAgICogdGhlIHdpemFyZCdzIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXQgdG8gaW1wbGVtZW50IGN1c3RvbSBmaW5pc2hcbiAgICogZnVuY3Rpb25hbGl0eSBhdCB0aGUgcGFnZSBsZXZlbC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG9cbiAgICogdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuIHVzZXJzIGJlZm9yZSBhbGxvd2luZyB0aGVtIHRvIGNvbXBsZXRlXG4gICAqIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHlvdSB0byBjYWxsIFdpemFyZC5maW5pc2goKSBvciBXaXphcmQuZm9yY2VGaW5pc2goKVxuICAgKiBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC4gVGhpcyBjb21iaW5hdGlvbiBjcmVhdGVzIGEgZnVsbCByZXBsYWNlbWVudCBvZlxuICAgKiB0aGUgZmluaXNoIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlRmluaXNoJykgZmluaXNoQnV0dG9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPENscldpemFyZFBhZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBwcmV2aW91cyBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIENscldpemFyZFBhZ2UgaXNcbiAgICogdGhlIHdpemFyZCdzIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXQgdG8gaW1wbGVtZW50IGN1c3RvbSBiYWNrd2FyZHNcbiAgICogbmF2aWdhdGlvbiBhdCB0aGUgcGFnZSBsZXZlbC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG9cbiAgICogdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuIHVzZXJzIGJlZm9yZSBhbGxvd2luZyB0aGVtIHRvIGdvXG4gICAqIGJhY2t3YXJkcyBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQucHJldmlvdXMoKVxuICAgKiBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC4gVGhpcyBjb21iaW5hdGlvbiBjcmVhdGVzIGEgZnVsbCByZXBsYWNlbWVudCBvZlxuICAgKiB0aGUgYmFja3dhcmRzIG5hdmlnYXRpb24gZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VQcmV2aW91cycpIHByZXZpb3VzQnV0dG9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPENscldpemFyZFBhZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBuZXh0IGJ1dHRvbiBpcyBjbGlja2VkIGFuZCB0aGUgQ2xyV2l6YXJkUGFnZSBpc1xuICAgKiB0aGUgd2l6YXJkJ3MgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0XG4gICAqIChjbHJXaXphcmRQYWdlUGFnZVByZXZlbnREZWZhdWx0KSBpbnB1dCB0byBpbXBsZW1lbnQgY3VzdG9tIGZvcndhcmRzXG4gICAqIG5hdmlnYXRpb24gYXQgdGhlIHBhZ2UgbGV2ZWwuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvXG4gICAqIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FybiB1c2VycyBiZWZvcmUgYWxsb3dpbmcgdGhlbSB0byBnb1xuICAgKiB0byB0aGUgbmV4dCBwYWdlIGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHlvdSB0byBjYWxsIFdpemFyZC5mb3JjZU5leHQoKSBvciBXaXphcmQubmV4dCgpXG4gICAqIGZyb20gdGhlIGhvc3QgY29tcG9uZW50LiBUaGlzIGNvbWJpbmF0aW9uIGNyZWF0ZXMgYSBmdWxsIHJlcGxhY2VtZW50IG9mXG4gICAqIHRoZSBmb3J3YXJkIG5hdmlnYXRpb24gZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VOZXh0JykgbmV4dEJ1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxDbHJXaXphcmRQYWdlPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiBhIGRhbmdlciBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIENscldpemFyZFBhZ2UgaXNcbiAgICogdGhlIHdpemFyZCdzIGN1cnJlbnQgcGFnZS4gQnkgZGVmYXVsdCwgYSBkYW5nZXIgYnV0dG9uIHdpbGwgYWN0IGFzXG4gICAqIGVpdGhlciBhIFwibmV4dFwiIG9yIFwiZmluaXNoXCIgYnV0dG9uIGRlcGVuZGluZyBvbiBpZiB0aGUgQ2xyV2l6YXJkUGFnZSBpcyB0aGVcbiAgICogbGFzdCBwYWdlIG9yIG5vdC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXQgdG8gaW1wbGVtZW50IGN1c3RvbSBmb3J3YXJkc1xuICAgKiBvciBmaW5pc2ggbmF2aWdhdGlvbiBhdCB0aGUgcGFnZSBsZXZlbCB3aGVuIHRoZSBkYW5nZXIgYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FyblxuICAgKiB1c2VycyBiZWZvcmUgYWxsb3dpbmcgdGhlbSB0byBnbyB0byB0aGUgbmV4dCBwYWdlIGluIHRoZSB3aXphcmQgb3JcbiAgICogZmluaXNoIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHlvdSB0byBjYWxsIFdpemFyZC5maW5pc2goKSwgV2l6YXJkLmZvcmNlRmluaXNoKCksXG4gICAqIFdpemFyZC5mb3JjZU5leHQoKSBvciBXaXphcmQubmV4dCgpIGZyb20gdGhlIGhvc3QgY29tcG9uZW50LiBUaGlzXG4gICAqIGNvbWJpbmF0aW9uIGNyZWF0ZXMgYSBmdWxsIHJlcGxhY2VtZW50IG9mIHRoZSBmb3J3YXJkIG5hdmlnYXRpb24gYW5kXG4gICAqIGZpbmlzaCBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZURhbmdlcicpIGRhbmdlckJ1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxDbHJXaXphcmRQYWdlPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiBhIG5leHQsIGZpbmlzaCwgb3IgZGFuZ2VyIGJ1dHRvbiBpcyBjbGlja2VkIGFuZCB0aGVcbiAgICogQ2xyV2l6YXJkUGFnZSBpcyB0aGUgd2l6YXJkJ3MgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0XG4gICAqIChjbHJXaXphcmRQYWdlUGFnZVByZXZlbnREZWZhdWx0KSBpbnB1dCB0byBpbXBsZW1lbnQgY3VzdG9tIGZvcndhcmRzXG4gICAqIG9yIGZpbmlzaCBuYXZpZ2F0aW9uIGF0IHRoZSBwYWdlIGxldmVsLCByZWdhcmRsZXNzIG9mIHRoZSB0eXBlIG9mXG4gICAqIHByaW1hcnkgYnV0dG9uLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkbyB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm5cbiAgICogdXNlcnMgYmVmb3JlIGFsbG93aW5nIHRoZW0gdG8gZ28gdG8gdGhlIG5leHQgcGFnZSBpbiB0aGUgd2l6YXJkIG9yXG4gICAqIGZpbmlzaCB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuZmluaXNoKCksIFdpemFyZC5mb3JjZUZpbmlzaCgpLFxuICAgKiBXaXphcmQuZm9yY2VOZXh0KCkgb3IgV2l6YXJkLm5leHQoKSBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC4gVGhpc1xuICAgKiBjb21iaW5hdGlvbiBjcmVhdGVzIGEgZnVsbCByZXBsYWNlbWVudCBvZiB0aGUgZm9yd2FyZCBuYXZpZ2F0aW9uIGFuZFxuICAgKiBmaW5pc2ggZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VQcmltYXJ5JykgcHJpbWFyeUJ1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VDdXN0b21CdXR0b24nKSBjdXN0b21CdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogQW4gaW5wdXQgdmFsdWUgdGhhdCBpcyB1c2VkIGludGVybmFsbHkgdG8gZ2VuZXJhdGUgdGhlIENscldpemFyZFBhZ2UgSUQgYXNcbiAgICogd2VsbCBhcyB0aGUgc3RlcCBuYXYgaXRlbSBJRC5cbiAgICpcbiAgICogVHlwZWQgYXMgYW55IGJlY2F1c2UgaXQgc2hvdWxkIGJlIGFibGUgdG8gYWNjZXB0IG51bWJlcnMgYXMgd2VsbCBhc1xuICAgKiBzdHJpbmdzLiBQYXNzaW5nIGFuIGluZGV4IGZvciB3aXphcmQgd2hvc2UgcGFnZXMgYXJlIGNyZWF0ZWQgd2l0aCBhblxuICAgKiBuZ0ZvciBsb29wIGlzIGEgY29tbW9uIHVzZSBjYXNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQElucHV0KCdpZCcpIF9pZDogYW55ID0gKHdpemFyZFBhZ2VJbmRleCsrKS50b1N0cmluZygpO1xuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCBnZW5lcmF0ZXMgYW4gSUQgc3RyaW5nIGZvciB0aGUgd2l6YXJkIHBhZ2UgZnJvbVxuICAgKiBlaXRoZXIgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGUgQ2xyV2l6YXJkUGFnZSBcImlkXCIgaW5wdXQgb3IgYSB3aXphcmQgcGFnZVxuICAgKiBjb3VudGVyIHNoYXJlZCBhY3Jvc3MgYWxsIHdpemFyZCBwYWdlcyBpbiB0aGUgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgdmFsdWUgcGFzc2VkIGludG8gdGhlIElEIGlucHV0IFdpbGwgYmUgcHJlZml4ZWQgd2l0aFxuICAgKiBcImNsci13aXphcmQtcGFnZS1cIi5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRQYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlkKCkge1xuICAgIC8vIGNvdmVycyB0aGluZ3MgbGlrZSBudWxsLCB1bmRlZmluZWQsIGZhbHNlLCBhbmQgZW1wdHkgc3RyaW5nXG4gICAgLy8gd2hpbGUgYWxsb3dpbmcgemVybyB0byBwYXNzXG4gICAgY29uc3QgaWRJc05vblplcm9GYWxzeSA9ICF0aGlzLl9pZCAmJiB0aGlzLl9pZCAhPT0gMDtcblxuICAgIC8vIGluIGFkZGl0aW9uIHRvIG5vbi16ZXJvIGZhbHN5IHdlIGFsc28gd2FudCB0byBtYWtlIHN1cmUgX2lkIGlzIG5vdCBhIG5lZ2F0aXZlXG4gICAgLy8gbnVtYmVyLlxuICAgIGlmIChpZElzTm9uWmVyb0ZhbHN5IHx8IHRoaXMuX2lkIDwgMCkge1xuICAgICAgLy8gZ3VhcmQgaGVyZSBpbiB0aGUgZXZlbnQgdGhhdCBpbnB1dCBiZWNvbWVzIHVuZGVmaW5lZCBvciBudWxsIGJ5IGFjY2lkZW50XG4gICAgICB0aGlzLl9pZCA9ICh3aXphcmRQYWdlSW5kZXgrKykudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGBjbHItd2l6YXJkLXBhZ2UtJHt0aGlzLl9pZH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IHNlcnZlcyBhcyBhIGNvbnZlbmllbmNlIGZvciB0aG9zZSB3aG8gd291bGQgcmF0aGVyXG4gICAqIG5vdCB0aGluayBpbiB0aGUgdGVybXMgb2YgIUNscldpemFyZFBhZ2UubmV4dFN0ZXBEaXNhYmxlZC4gRm9yIHNvbWUgdXNlIGNhc2VzLFxuICAgKiBDbHJXaXphcmRQYWdlLnJlYWR5VG9Db21wbGV0ZSBpcyBtb3JlIGxvZ2ljYWwgYW5kIGRlY2xhcmF0aXZlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCByZWFkeVRvQ29tcGxldGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICF0aGlzLm5leHRTdGVwRGlzYWJsZWQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2NvbXBsZXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgcGFnZSBpcyBtYXJrZWQgYXMgY29tcGxldGVkIGlmIGl0IGlzIGJvdGggcmVhZHlUb0NvbXBsZXRlIGFuZCBjb21wbGV0ZWQsXG4gICAqIGFzIGluIHRoZSBuZXh0IG9yIGZpbmlzaCBhY3Rpb24gaGFzIGJlZW4gZXhlY3V0ZWQgd2hpbGUgdGhpcyBwYWdlIHdhcyBjdXJyZW50LlxuICAgKlxuICAgKiBOb3RlIHRoZXJlIGlzIGFuZCBvcGVuIHF1ZXN0aW9uIGFib3V0IGhvdyB0byBoYW5kbGUgcGFnZXMgdGhhdCBhcmUgbWFya2VkXG4gICAqIGNvbXBsZXRlIGJ1dCB3aG8gYXJlIG5vIGxvbmdlciByZWFkeVRvQ29tcGxldGUuIFRoaXMgbWlnaHQgaW5kaWNhdGUgYW4gZXJyb3JcbiAgICogc3RhdGUgZm9yIHRoZSBDbHJXaXphcmRQYWdlLiBDdXJyZW50bHksIHRoZSB3aXphcmQgZG9lcyBub3QgYWNrbm93bGVkZ2UgdGhpcyBzdGF0ZVxuICAgKiBhbmQgb25seSByZXR1cm5zIHRoYXQgdGhlIHBhZ2UgaXMgaW5jb21wbGV0ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jb21wbGV0ZSAmJiB0aGlzLnJlYWR5VG9Db21wbGV0ZTtcblxuICAgIC8vIEZPUiBWMjogVU5XSU5EIENPTVBMRVRFRCwgUkVBRFlUT0NPTVBMRVRFLCBBTkQgRVJST1JTXG4gICAgLy8gU1VDSCBUSEFUIEVSUk9SUyBJUyBJVFMgT1dOIElOUFVULiBJRiBBIFNURVAgSVNcbiAgICAvLyBJTkNPTVBMRVRFIEFORCBFUlJPUkVELCBFUlJPUkVEIFdJTEwgTk9UIFNIT1cuXG4gICAgLy8gRklSU1QgUVVFU1RJT046IEFNIEkgR1JFWSBPUiBDT0xPUkVEP1xuICAgIC8vIFNFQ09ORCBRVUVTVElPTjogQU0gSSBHUkVFTiBPUiBSRUQ/XG4gIH1cblxuICAvKipcbiAgICogQSBDbHJXaXphcmRQYWdlIGNhbiBiZSBtYW51YWxseSBzZXQgdG8gY29tcGxldGVkIHVzaW5nIHRoaXMgYm9vbGVhbiBzZXR0ZXIuXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgdXNlcnMgcmVseSBvbiB0aGUgY29udmVuaWVuY2UgZnVuY3Rpb25zIGluIHRoZSB3aXphcmRcbiAgICogYW5kIG5hdmlnYXRpb24gc2VydmljZSBpbnN0ZWFkIG9mIG1hbnVhbGx5IHNldHRpbmcgcGFnZXPDosKAwpkgY29tcGxldGlvbiBzdGF0ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENscldpemFyZFBhZ2VcbiAgICovXG4gIHB1YmxpYyBzZXQgY29tcGxldGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fY29tcGxldGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2l0aCB0aGUgbmF2aWdhdGlvbiBzZXJ2aWNlIHRvIHNlZSBpZiBpdCBpcyB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2UgPT09IHRoaXM7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5lbmFibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBhZ2UgaXMgbmF2aWdhYmxlXG4gICAqIGluIHRoZSB3aXphcmQuIEEgd2l6YXJkIHBhZ2UgY2FuIGJlIG5hdmlnYXRlZCB0byBpZiBpdCBpcyBjb21wbGV0ZWRcbiAgICogb3IgdGhlIHBhZ2UgYmVmb3JlIGl0IGlzIGNvbXBsZXRlZC5cbiAgICpcbiAgICogVGhpcyBnZXR0ZXIgaGFuZGxlcyB0aGUgbG9naWMgZm9yIGVuYWJsaW5nIG9yIGRpc2FibGluZyB0aGUgbGlua3MgaW5cbiAgICogdGhlIHN0ZXAgbmF2IG9uIHRoZSBsZWZ0IFNpZGUgb2YgdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgZW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50IHx8IHRoaXMuY29tcGxldGVkIHx8IHRoaXMucHJldmlvdXNDb21wbGV0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgcGFnZSBiZWZvcmUgdGhpc1xuICAgKiBDbHJXaXphcmRQYWdlIGlzIGNvbXBsZXRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgb3Igbm90XG4gICAqIGEgcGFnZSBpcyBuYXZpZ2FibGUgaWYgaXQgaXMgbm90IGN1cnJlbnQgb3IgYWxyZWFkeSBjb21wbGV0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHByZXZpb3VzQ29tcGxldGVkKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHByZXZpb3VzUGFnZSA9IHRoaXMucGFnZUNvbGxlY3Rpb24uZ2V0UHJldmlvdXNQYWdlKHRoaXMpO1xuXG4gICAgaWYgKCFwcmV2aW91c1BhZ2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c1BhZ2UuY29tcGxldGVkO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRpdGxlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnBhZ2VUaXRsZS5wYWdlVGl0bGVUZW1wbGF0ZVJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBuYXZUaXRsZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICBpZiAodGhpcy5wYWdlTmF2VGl0bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhZ2VOYXZUaXRsZS5wYWdlTmF2VGl0bGVUZW1wbGF0ZVJlZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFnZVRpdGxlLnBhZ2VUaXRsZVRlbXBsYXRlUmVmO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhlYWRlckFjdGlvbnMoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9oZWFkZXJBY3Rpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9oZWFkZXJBY3Rpb25zLnBhZ2VIZWFkZXJBY3Rpb25zVGVtcGxhdGVSZWY7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzSGVhZGVyQWN0aW9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9oZWFkZXJBY3Rpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGJ1dHRvbnMoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9idXR0b25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9idXR0b25zLnBhZ2VCdXR0b25zVGVtcGxhdGVSZWY7XG4gIH1cblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBzYXlzIHdoZXRoZXIgb3JcbiAgICogbm90IHRoZSBDbHJXaXphcmRQYWdlIGluY2x1ZGVzIGJ1dHRvbnMuIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZVxuICAgKiBXaXphcmQgc2hvdWxkIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJ1dHRvbiBzZXQgZGVmaW5lZCBhc1xuICAgKiBpdHMgZGlyZWN0IGNoaWxkcmVuLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBoYXNCdXR0b25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuX2J1dHRvbnM7XG4gIH1cblxuICAvKipcbiAgICogVXNlcyB0aGUgbmF2IHNlcnZpY2UgdG8gbWFrZSB0aGUgQ2xyV2l6YXJkUGFnZSB0aGUgY3VycmVudCBwYWdlIGluIHRoZVxuICAgKiB3aXphcmQuIEJ5cGFzc2VzIGFsbCBjaGVja3MgYnV0IHN0aWxsIGVtaXRzIHRoZSBDbHJXaXphcmRQYWdlLm9uTG9hZFxuICAgKiAoY2xyV2l6YXJkUGFnZU9uTG9hZCkgb3V0cHV0LlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHRoZSBkZWZhdWx0IG5hdmlnYXRpb24gZnVuY3Rpb25zXG4gICAqIGluIFdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBtYWtlQ3VycmVudCgpOiB2b2lkIHtcbiAgICB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2UgPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIExpbmtzIHRoZSBuYXYgc2VydmljZSBhbmQgZXN0YWJsaXNoZXMgdGhlIGN1cnJlbnQgcGFnZSBpZiBvbmUgaXMgbm90IGRlZmluZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgY29uc3QgbmF2U2VydmljZSA9IHRoaXMubmF2U2VydmljZTtcbiAgICBpZiAoIW5hdlNlcnZpY2UuY3VycmVudFBhZ2UgJiYgIW5hdlNlcnZpY2UubmF2U2VydmljZUxvYWRlZCkge1xuICAgICAgdGhpcy5tYWtlQ3VycmVudCgpO1xuICAgICAgdGhpcy5uYXZTZXJ2aWNlLm5hdlNlcnZpY2VMb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBpZCB1c2VkIGJ5IHRoZSBzdGVwIG5hdiBpdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFnZS5cbiAgICpcbiAgICogQ2xyV2l6YXJkUGFnZSBuZWVkcyB0aGlzIElEIHN0cmluZyBmb3IgYXJpYSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgc3RlcEl0ZW1JZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhZ2VDb2xsZWN0aW9uLmdldFN0ZXBJdGVtSWRGb3JQYWdlKHRoaXMpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBEb0NoZWNrLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBJdGVyYWJsZURpZmZlcnMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQnV0dG9uSHViU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2J1dHRvbi1odWIuc2VydmljZSc7XG5pbXBvcnQgeyBIZWFkZXJBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGVhZGVyLWFjdGlvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG4vLyBwcm92aWRlcnNcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRIZWFkZXJBY3Rpb24gfSBmcm9tICcuL3dpemFyZC1oZWFkZXItYWN0aW9uJztcbmltcG9ydCB7IENscldpemFyZFBhZ2UgfSBmcm9tICcuL3dpemFyZC1wYWdlJztcblxuLyoqXG4gKlxuICogVGhlIFdpemFyZCBjb21wb25lbnRcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQnLFxuICBwcm92aWRlcnM6IFtXaXphcmROYXZpZ2F0aW9uU2VydmljZSwgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLCBCdXR0b25IdWJTZXJ2aWNlLCBIZWFkZXJBY3Rpb25TZXJ2aWNlXSxcbiAgdGVtcGxhdGVVcmw6ICcuL3dpemFyZC5odG1sJyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLXdpemFyZF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy53aXphcmQtbWRdJzogXCJzaXplID09ICdtZCdcIixcbiAgICAnW2NsYXNzLndpemFyZC1sZ10nOiBcInNpemUgPT0gJ2xnJ1wiLFxuICAgICdbY2xhc3Mud2l6YXJkLXhsXSc6IFwic2l6ZSA9PSAneGwnXCIsXG4gICAgJ1tjbGFzcy5sYXN0UGFnZV0nOiAnbmF2U2VydmljZS5jdXJyZW50UGFnZUlzTGFzdCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0LCBEb0NoZWNrIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgV2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbmF2U2VydmljZTogV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgcHVibGljIHBhZ2VDb2xsZWN0aW9uOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UsXG4gICAgcHVibGljIGJ1dHRvblNlcnZpY2U6IEJ1dHRvbkh1YlNlcnZpY2UsXG4gICAgcHVibGljIGhlYWRlckFjdGlvblNlcnZpY2U6IEhlYWRlckFjdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVyc1xuICApIHtcbiAgICB0aGlzLmdvTmV4dFN1YnNjcmlwdGlvbiA9IHRoaXMubmF2U2VydmljZS5tb3ZlZFRvTmV4dFBhZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMub25Nb3ZlTmV4dC5lbWl0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmdvUHJldmlvdXNTdWJzY3JpcHRpb24gPSB0aGlzLm5hdlNlcnZpY2UubW92ZWRUb1ByZXZpb3VzUGFnZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5vbk1vdmVQcmV2aW91cy5lbWl0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhbmNlbFN1YnNjcmlwdGlvbiA9IHRoaXMubmF2U2VydmljZS5ub3RpZnlXaXphcmRDYW5jZWwuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2tBbmRDYW5jZWwoKTtcbiAgICB9KTtcblxuICAgIHRoaXMud2l6YXJkRmluaXNoZWRTdWJzY3JpcHRpb24gPSB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkRmluaXNoZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICghdGhpcy5zdG9wTmV4dCkge1xuICAgICAgICB0aGlzLmZvcmNlRmluaXNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLndpemFyZEZpbmlzaGVkLmVtaXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuZGlmZmVyID0gZGlmZmVycy5maW5kKFtdKS5jcmVhdGUobnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBmb3IgbWFya2luZyB3aGVuIHRoZSBjb2xsZWN0aW9uIG9mIHdpemFyZCBwYWdlcyBoYXMgYmVlbiBhZGRlZCB0byBvciBkZWxldGVkIGZyb21cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgZGlmZmVyOiBhbnk7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIHRoZSBzaXplIGRlZmluZWQgYnkgdGhlIGNscldpemFyZFNpemUgaW5wdXRcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRTaXplJykgc2l6ZTogc3RyaW5nID0gJ3hsJztcblxuICAvKipcbiAgICogUmVzZXRzIHBhZ2UgY29tcGxldGVkIHN0YXRlcyB3aGVuIG5hdmlnYXRpbmcgYmFja3dhcmRzLiBDYW4gYmUgc2V0IHVzaW5nXG4gICAqIHRoZSBjbHJXaXphcmRGb3JjZUZvcndhcmROYXZpZ2F0aW9uIGlucHV0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZEZvcmNlRm9yd2FyZE5hdmlnYXRpb24nKVxuICBzZXQgZm9yY2VGb3J3YXJkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fZm9yY2VGb3J3YXJkID0gISF2YWx1ZTtcbiAgICB0aGlzLm5hdlNlcnZpY2UuZm9yY2VGb3J3YXJkTmF2aWdhdGlvbiA9IHZhbHVlO1xuICB9XG4gIHByaXZhdGUgX2ZvcmNlRm9yd2FyZDogYm9vbGVhbiA9IGZhbHNlO1xuICBnZXQgZm9yY2VGb3J3YXJkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9mb3JjZUZvcndhcmQ7XG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgdGhlIG1vZGFsIHBhcnQgb2YgdGhlIHdpemFyZCB3aGV0aGVyIGl0IHNob3VsZCBoYXZlIGEgY2xvc2UgXCJYXCJcbiAgICogaW4gdGhlIHRvcCByaWdodCBjb3JuZXIuIFNldCB3aXRoIHRoZSBjbHJXaXphcmRDbG9zYWJsZSBpbnB1dC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRDbG9zYWJsZScpIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAvKipcbiAgICogVG9nZ2xlcyBvcGVuL2Nsb3NlIG9mIHRoZSB3aXphcmQgY29tcG9uZW50LiBTZXQgdXNpbmcgdGhlIGNscldpemFyZE9wZW5cbiAgICogaW5wdXQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIHB1YmxpYyBfb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICBASW5wdXQoJ2NscldpemFyZE9wZW4nKVxuICBzZXQgY2xyV2l6YXJkT3BlbihvcGVuOiBib29sZWFuKSB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHRoaXMuYnV0dG9uU2VydmljZS5idXR0b25zUmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9vcGVuID0gb3BlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgaXMgb3BlbmVkIG9yIGNsb3NlZC4gRW1pdHMgdGhyb3VnaCB0aGVcbiAgICogY2xyV2l6YXJkT3BlbkNoYW5nZSBvdXRwdXQuIFdvcmtzIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlXG4gICAqIGNscldpemFyZE9wZW4gYmluZGluZyBzbyB5b3UgY2FuIHVzZS4uLlxuICAgKlxuICAgKiA8Y2xyLXdpemFyZCBbKGNscldpemFyZE9wZW4pXT1cImJsYWhcIlxuICAgKiAuLi5vci4uLlxuICAgKiA8Y2xyLXdpemFyZCBbY2xyV2l6YXJkT3Blbl09XCJzb21ldGhpbmdcIiAoY2xyV2l6YXJkT3BlbkNoYW5nZSk9XCJkb1NvbWV0aGlnbigkZXZlbnQpXCI+XG4gICAqXG4gICAqIC4uLmZvciB0d28td2F5IGJpbmRpbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZE9wZW5DaGFuZ2UnKSBfb3BlbkNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgaXMgY2FuY2VsZWQuIENhbiBiZSBvYnNlcnZlZCB0aHJvdWdoIHRoZSBjbHJXaXphcmRPbkNhbmNlbFxuICAgKiBvdXRwdXQuXG4gICAqXG4gICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbCBpbnB1dCB0byBjcmVhdGVcbiAgICogd2l6YXJkLWxldmVsIGN1c3RvbSBjYW5jZWwgcm91dGluZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZE9uQ2FuY2VsJykgb25DYW5jZWw6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIGNvbXBsZXRlZC4gQ2FuIGJlIG9ic2VydmVkIHRocm91Z2ggdGhlIGNscldpemFyZE9uRmluaXNoXG4gICAqIG91dHB1dC5cbiAgICpcbiAgICogQ2FuIGJlIGNvbWJpbmVkIHdpdGggdGhlIGNscldpemFyZFByZXZlbnREZWZhdWx0TmV4dCBpbnB1dCB0byBjcmVhdGVcbiAgICogd2l6YXJkLWxldmVsIGN1c3RvbSBjb21wbGV0aW9uIHJvdXRpbmVzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRPbkZpbmlzaCcpIHdpemFyZEZpbmlzaGVkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyByZXNldC4gU2VlIC5yZXNldCgpLiBDYW4gYmUgb2JzZXJ2ZWQgdGhyb3VnaFxuICAgKiB0aGUgY2xyV2l6YXJkT25SZXNldCBvdXRwdXQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZE9uUmVzZXQnKSBvblJlc2V0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEEgUXVlcnlMaXN0IG9mIHRoZSBwYWdlcyBpbiB0aGUgd2l6YXJkLiBOb3RlIHRoYXQgYSBRdWVyeUxpc3QgaXMgc29ydCBvZlxuICAgKiBsaWtlIGFuIEFycmF5IGJ1dCBub3QgcmVhbGx5LiBOb3RlIGFsc28gdGhhdCBwYWdlcyBkb2VzIG5vdCBjb250YWluXG4gICAqIFdpemFyZFBhZ2VzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgd2l0aCBhbiBuZ0lmLlxuICAgKlxuICAgKiBNb3N0IGludGVyYWN0aW9ucyB3aXRoIGEgQ2xyV2l6YXJkJ3MgcGFnZXMgYXJlIG1vcmUgZWFzaWx5IGRvbmUgdXNpbmcgdGhlXG4gICAqIGhlbHBlciBmdW5jdGlvbiBpbiB0aGUgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLCBhY2Nlc3NpYmxlIGZyb20gdGhlXG4gICAqIENscldpemFyZCB0aHJvdWdoIENscldpemFyZC5wYWdlQ29sbGVjdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJXaXphcmRQYWdlKSBwdWJsaWMgcGFnZXM6IFF1ZXJ5TGlzdDxDbHJXaXphcmRQYWdlPjtcblxuICAvKipcbiAgICogQSBRdWVyeUxpc3Qgb2YgdGhlIGhlYWRlciBhY3Rpb25zIGRlZmluZWQgYXQgdGhlIENscldpemFyZCBsZXZlbC4gRG9lcyBub3RcbiAgICogY29udGFpbiBoZWFkZXIgYWN0aW9ucyBkZWZpbmVkIGF0IHRoZSBwYWdlIGxldmVsLiBNb3N0bHkgdXNlZCBieSBvdGhlciBmdW5jdGlvbmFsaXR5XG4gICAqIHRoYXQgbmVlZHMgdG8gZWl0aGVyIGtub3cgaWYgdGhlIENscldpemFyZCBoYXMgaGVhZGVyIGFjdGlvbnMgb3IgbmVlZHMgdG8gc3RhbXAgdGhlbVxuICAgKiBzb21ld2hlcmUuXG4gICAqXG4gICAqIENvdWxkIGJlIHVzZWZ1bCBpZiB5b3UgbmVlZGVkIHRvIGxvY2F0ZSBhbmQgcHJvZ3JhbW1hdGljYWxseSBhY3RpdmF0ZSBhIHNwZWNpZmljXG4gICAqIGhlYWRlciBhY3Rpb24uIEJ1dCB0aGlzIGlzIHByb2JhYmx5IGVhc2llciB0byBkbyBieSBpbnZva2luZyB0aGUgaGVhZGVyIGFjdGlvbidzXG4gICAqIGV2ZW50IGhhbmRsZXIgaW4geW91ciBob3N0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJXaXphcmRIZWFkZXJBY3Rpb24pIHB1YmxpYyBoZWFkZXJBY3Rpb25zOiBRdWVyeUxpc3Q8Q2xyV2l6YXJkSGVhZGVyQWN0aW9uPjtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgY3VycmVudCBwYWdlIGhhcyBjaGFuZ2VkLiBDYW4gYmUgb2JzZXJ2ZWQgdGhyb3VnaCB0aGUgY2xyV2l6YXJkQ3VycmVudFBhZ2VDaGFuZ2VkXG4gICAqIG91dHB1dC4gVGhpcyBjYW4gaGFwcGVuIG9uIC5uZXh0KCkgb3IgLnByZXZpb3VzKCkuXG4gICAqIFVzZWZ1bCBmb3Igbm9uLWJsb2NraW5nIHZhbGlkYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZEN1cnJlbnRQYWdlQ2hhbmdlZCcpIGN1cnJlbnRQYWdlQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgbW92ZXMgdG8gdGhlIG5leHQgcGFnZS4gQ2FuIGJlIG9ic2VydmVkIHRocm91Z2ggdGhlIGNscldpemFyZE9uTmV4dFxuICAgKiBvdXRwdXQuXG4gICAqXG4gICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQgaW5wdXQgdG8gY3JlYXRlXG4gICAqIHdpemFyZC1sZXZlbCBjdXN0b20gbmF2aWdhdGlvbiByb3V0aW5lcywgd2hpY2ggYXJlIHVzZWZ1bCBmb3IgdmFsaWRhdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25OZXh0Jykgb25Nb3ZlTmV4dDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgbW92ZXMgdG8gdGhlIHByZXZpb3VzIHBhZ2UuIENhbiBiZSBvYnNlcnZlZCB0aHJvdWdoIHRoZVxuICAgKiBjbHJXaXphcmRPblByZXZpb3VzIG91dHB1dC5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWZ1bCBmb3IgdmFsaWRhdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25QcmV2aW91cycpIG9uTW92ZVByZXZpb3VzOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIENscldpemFyZCBmcm9tIG1vdmluZyB0byB0aGUgbmV4dCBwYWdlIG9yIGNsb3NpbmcgaXRzZWxmIG9uIGZpbmlzaGluZy5cbiAgICogU2V0IHVzaW5nIHRoZSBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQgaW5wdXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB1c2luZyBzdG9wTmV4dCB3aWxsIHJlcXVpcmUgeW91IHRvIGNyZWF0ZSB5b3VyIG93biBjYWxscyB0b1xuICAgKiAubmV4dCgpIGFuZCAuZmluaXNoKCkgaW4geW91ciBob3N0IGNvbXBvbmVudCB0byBtYWtlIHRoZSBDbHJXaXphcmQgd29yayBhc1xuICAgKiBleHBlY3RlZC5cbiAgICpcbiAgICogUHJpbWFyaWx5IHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0JylcbiAgc2V0IHN0b3BOZXh0KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc3RvcE5leHQgPSAhIXZhbHVlO1xuICAgIHRoaXMubmF2U2VydmljZS53aXphcmRIYXNBbHROZXh0ID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfc3RvcE5leHQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IHN0b3BOZXh0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdG9wTmV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBDbHJXaXphcmQgZnJvbSBjbG9zaW5nIHdoZW4gdGhlIGNhbmNlbCBidXR0b24gb3IgY2xvc2UgXCJYXCIgaXMgY2xpY2tlZC5cbiAgICogU2V0IHVzaW5nIHRoZSBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbCBpbnB1dC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHVzaW5nIHN0b3BDYW5jZWwgd2lsbCByZXF1aXJlIHlvdSB0byBjcmVhdGUgeW91ciBvd24gY2FsbHMgdG9cbiAgICogLmNsb3NlKCkgaW4geW91ciBob3N0IGNvbXBvbmVudCB0byBtYWtlIHRoZSBDbHJXaXphcmQgd29yayBhcyBleHBlY3RlZC5cbiAgICpcbiAgICogVXNlZnVsIGZvciBkb2luZyBjaGVja3Mgb3IgcHJvbXB0cyBiZWZvcmUgY2xvc2luZyBhIENscldpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQcmV2ZW50RGVmYXVsdENhbmNlbCcpXG4gIHNldCBzdG9wQ2FuY2VsKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc3RvcENhbmNlbCA9ICEhdmFsdWU7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLndpemFyZEhhc0FsdENhbmNlbCA9IHZhbHVlO1xuICB9XG4gIHByaXZhdGUgX3N0b3BDYW5jZWw6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IHN0b3BDYW5jZWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BDYW5jZWw7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgQ2xyV2l6YXJkIGZyb20gcGVyZm9ybWluZyBhbnkgZm9ybSBvZiBuYXZpZ2F0aW9uIGF3YXkgZnJvbSB0aGUgY3VycmVudFxuICAgKiBwYWdlLiBTZXQgdXNpbmcgdGhlIGNscldpemFyZFByZXZlbnROYXZpZ2F0aW9uIGlucHV0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgc3RvcE5hdmlnYXRpb24gaXMgbWVhbnQgdG8gZnJlZXplIHRoZSB3aXphcmQgaW4gcGxhY2UsIHR5cGljYWxseVxuICAgKiBkdXJpbmcgYSBsb25nIHZhbGlkYXRpb24gb3IgYmFja2dyb3VuZCBhY3Rpb24gd2hlcmUgeW91IHdhbnQgdGhlIHdpemFyZCB0b1xuICAgKiBkaXNwbGF5IGxvYWRpbmcgY29udGVudCBidXQgbm90IGFsbG93IHRoZSB1c2VyIHRvIGV4ZWN1dGUgbmF2aWdhdGlvbiBpblxuICAgKiB0aGUgc3RlcG5hdiwgY2xvc2UgWCwgb3IgdGhlICBiYWNrLCBmaW5pc2gsIG9yIG5leHQgYnV0dG9ucy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQcmV2ZW50TmF2aWdhdGlvbicpXG4gIHNldCBzdG9wTmF2aWdhdGlvbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3N0b3BOYXZpZ2F0aW9uID0gISF2YWx1ZTtcbiAgICB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkU3RvcE5hdmlnYXRpb24gPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9zdG9wTmF2aWdhdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuICBnZXQgc3RvcE5hdmlnYXRpb24oKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BOYXZpZ2F0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIGNsaWNrcyBvbiB0aGUgbGlua3MgaW4gdGhlIHN0ZXBuYXYgZnJvbSB3b3JraW5nLlxuICAgKlxuICAgKiBBIG1vcmUgZ3JhbnVsYXIgYnlwYXNzaW5nIG9mIG5hdmlnYXRpb24gd2hpY2ggY2FuIGJlIHVzZWZ1bCB3aGVuIHlvdXJcbiAgICogQ2xyV2l6YXJkIGlzIGluIGEgc3RhdGUgb2YgY29tcGxldGlvbiBhbmQgeW91IGRvbid0IHdhbnQgdXNlcnMgdG8gYmVcbiAgICogYWJsZSB0byBqdW1wIGJhY2t3YXJkcyBhbmQgY2hhbmdlIHRoaW5ncy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmREaXNhYmxlU3RlcG5hdicpXG4gIHNldCBkaXNhYmxlU3RlcG5hdih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2Rpc2FibGVTdGVwbmF2ID0gISF2YWx1ZTtcbiAgICB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkRGlzYWJsZVN0ZXBuYXYgPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9kaXNhYmxlU3RlcG5hdjogYm9vbGVhbiA9IGZhbHNlO1xuICBnZXQgZGlzYWJsZVN0ZXBuYXYoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVTdGVwbmF2O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgb25seSB0byBjb21tdW5pY2F0ZSB0byB0aGUgdW5kZXJseWluZyBtb2RhbCB0aGF0IGFuaW1hdGlvbnMgYXJlIG5vdFxuICAgKiB3YW50ZWQuIFByaW1hcnkgdXNlIGlzIGZvciB0aGUgZGlzcGxheSBvZiBzdGF0aWMvaW5saW5lIHdpemFyZHMuXG4gICAqXG4gICAqIFNldCB1c2luZyBjbHJXaXphcmRQcmV2ZW50TW9kYWxBbmltYXRpb24gaW5wdXQuIEJ1dCB5b3Ugc2hvdWxkIG5ldmVyIHNldCBpdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQcmV2ZW50TW9kYWxBbmltYXRpb24nKSBfc3RvcE1vZGFsQW5pbWF0aW9uczogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgZ2V0IHN0b3BNb2RhbEFuaW1hdGlvbnMoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5fc3RvcE1vZGFsQW5pbWF0aW9ucykge1xuICAgICAgcmV0dXJuICd0cnVlJztcbiAgICB9XG4gICAgcmV0dXJuICdmYWxzZSc7XG4gIH1cblxuICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50UGFnZVN1YnNjcmlwdGlvbiA9IHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZUNoYW5nZWQuc3Vic2NyaWJlKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlQ2hhbmdlZC5lbWl0KCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGdvTmV4dFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGdvUHJldmlvdXNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBjYW5jZWxTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBjdXJyZW50UGFnZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIHdpemFyZEZpbmlzaGVkU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZ29OZXh0U3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmdvTmV4dFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nb1ByZXZpb3VzU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmdvUHJldmlvdXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2FuY2VsU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmNhbmNlbFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jdXJyZW50UGFnZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy53aXphcmRGaW5pc2hlZFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy53aXphcmRGaW5pc2hlZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHJlZmVyZW5jZXMgdGhhdCBhcmUgbmVlZGVkIGJ5IHRoZSBwcm92aWRlcnMuXG4gICAqXG4gICAqIEBuYW1lIG5nQWZ0ZXJDb250ZW50SW5pdFxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMucGFnZUNvbGxlY3Rpb24ucGFnZXMgPSB0aGlzLnBhZ2VzO1xuICAgIHRoaXMuaGVhZGVyQWN0aW9uU2VydmljZS53aXphcmRIZWFkZXJBY3Rpb25zID0gdGhpcy5oZWFkZXJBY3Rpb25zO1xuXG4gICAgLy8gT25seSB0cmlnZ2VyIGJ1dHRvbnMgcmVhZHkgaWYgZGVmYXVsdCBpcyBvcGVuIChpbmxpbmVkKVxuICAgIGlmICh0aGlzLl9vcGVuKSB7XG4gICAgICB0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aGVuIHBhZ2VzIGFyZSBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhpcy5wYWdlc1xuICAgKlxuICAgKiBAbmFtZSBuZ0RvQ2hlY2tcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgcHVibGljIG5nRG9DaGVjaygpIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5kaWZmZXIuZGlmZih0aGlzLnBhZ2VzKTtcbiAgICBpZiAoY2hhbmdlcykge1xuICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKChyOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZU5hdmlnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKHI6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLm5hdlNlcnZpY2UudXBkYXRlTmF2aWdhdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbnQgcHJvcGVydHkgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgYSB3aXphcmQgaXMgc3RhdGljL2luLWxpbmUgb3Igbm90LlxuICAgKlxuICAgKiBAbmFtZSBpc1N0YXRpY1xuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzU3RhdGljKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2Nsci13aXphcmQtLWlubGluZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzIGEgZ2V0dGVyLCBjdXJyZW50IHBhZ2UgaXMgYSBjb252ZW5pZW50IHdheSB0byByZXRyaWV2ZSB0aGUgY3VycmVudCBwYWdlIGZyb21cbiAgICogdGhlIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLlxuICAgKlxuICAgKiBBcyBhIHNldHRlciwgY3VycmVudCBwYWdlIGFjY2VwdHMgYSBDbHJXaXphcmRQYWdlIGFuZCBwYXNzZXMgaXQgdG8gV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICogdG8gYmUgbWFkZSB0aGUgY3VycmVudCBwYWdlLiBjdXJyZW50UGFnZSBwZXJmb3JtcyBjaGVja3MgdG8gbWFrZSBzdXJlIGl0IGNhbiBuYXZpZ2F0ZVxuICAgKiB0byB0aGUgZGVzaWduYXRlZCBwYWdlLlxuICAgKlxuICAgKiBAbmFtZSBjdXJyZW50UGFnZVxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2U7XG4gIH1cbiAgcHVibGljIHNldCBjdXJyZW50UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLmdvVG8ocGFnZSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVudCBwcm9wZXJ0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgdGhlIGN1cnJlbnQgcGFnZSBpcyB0aGUgbGFzdCBwYWdlIG9mXG4gICAqIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBuYW1lIGlzTGFzdFxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzTGFzdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlSXNMYXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbnQgcHJvcGVydHkgZm9yIGRldGVybWluaW5nIGlmIHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlIGZpcnN0IHBhZ2Ugb2ZcbiAgICogdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG5hbWUgaXNGaXJzdFxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGlzRmlyc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZUlzRmlyc3Q7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIGFjdGlvbnMgbmVlZGVkIHRvIG9wZW4gdGhlIHdpemFyZC4gSWYgdGhlcmUgaXMgbm8gY3VycmVudFxuICAgKiBwYWdlIGRlZmluZWQsIHNldHMgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIHdpemFyZCB0byBiZSBjdXJyZW50LlxuICAgKlxuICAgKiBAbmFtZSBvcGVuXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBvcGVuKCk6IHZvaWQge1xuICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLmN1cnJlbnRQYWdlKSB7XG4gICAgICB0aGlzLm5hdlNlcnZpY2Uuc2V0Rmlyc3RQYWdlQ3VycmVudCgpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgcmVuZGVyIGJ1dHRvbnMgd2hlbiB3aXphcmQgaXMgb3BlbmVkLCB0byBhdm9pZCBjaG9jb2xhdGUgZXJyb3JzXG4gICAgdGhpcy5idXR0b25TZXJ2aWNlLmJ1dHRvbnNSZWFkeSA9IHRydWU7XG5cbiAgICB0aGlzLl9vcGVuQ2hhbmdlZC5lbWl0KHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgdGhlIHdvcmsgaW52b2x2ZWQgd2l0aCBjbG9zaW5nIHRoZSB3aXphcmQuIENhbGwgdGhpcyBkaXJlY3RseSBpbnN0ZWFkXG4gICAqIG9mIGNhbmNlbCgpIHRvIGltcGxlbWVudCBhbHRlcm5hdGl2ZSBjYW5jZWwgZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG5hbWUgY2xvc2VcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wZW5DaGFuZ2VkLmVtaXQoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbnQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBvcGVuIGFuZCBjbG9zZSB0aGUgd2l6YXJkLiBJdCBvcGVyYXRlc1xuICAgKiBieSBjaGVja2luZyBhIEJvb2xlYW4gcGFyYW1ldGVyLiBJZiB0cnVlLCB0aGUgd2l6YXJkIGlzIG9wZW5lZC4gSWYgZmFsc2UsXG4gICAqIGl0IGlzIGNsb3NlZC5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBwYXJhbWV0ZXIsIHNvIGJ5IGRlZmF1bHQgdGhlIHdpemFyZCB3aWxsXG4gICAqIGNsb3NlIGlmIGludm9rZWQgd2l0aCBubyBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBuYW1lIHRvZ2dsZVxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgd2l6YXJkIHRvIHRoZSBwcmV2aW91cyBwYWdlLlxuICAgKlxuICAgKiBAbmFtZSBwcmV2aW91c1xuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLnByZXZpb3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5jbHVkZXMgYSBCb29sZWFuIHBhcmFtZXRlciB0aGF0IHdpbGwgc2tpcCBjaGVja3MgYW5kIGV2ZW50IGVtaXNzaW9ucy5cbiAgICogSWYgdHJ1ZSwgdGhlIHdpemFyZCB3aWxsIG1vdmUgdG8gdGhlIG5leHQgcGFnZSByZWdhcmRsZXNzIG9mIHRoZSBzdGF0ZSBvZlxuICAgKiBpdHMgY3VycmVudCBwYWdlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYWx0ZXJuYXRpdmUgbmF2aWdhdGlvbiB3aGVyZSBldmVudFxuICAgKiBlbWlzc2lvbnMgaGF2ZSBhbHJlYWR5IGJlZW4gZG9uZSBhbmQgZmlyaW5nIHRoZW0gYWdhaW4gbWF5IGNhdXNlIGFuIGV2ZW50IGxvb3AuXG4gICAqXG4gICAqIEdlbmVyYWxseSwgd2l0aCBhbHRlcm5hdGl2ZSBuYXZpZ2F0aW9uLCB1c2VycyBhcmUgc3VwcGx5aW5nIHRoZWlyIG93biBjaGVja3NcbiAgICogYW5kIHZhbGlkYXRpb24uIFNvIHRoZXJlIGlzIG5vIHBvaW50IGluIHN1cGVyc2VkaW5nIHRoZWlyIGJ1c2luZXNzIGxvZ2ljXG4gICAqIHdpdGggb3VyIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAqXG4gICAqIElmIGZhbHNlLCB0aGUgd2l6YXJkIHdpbGwgZXhlY3V0ZSBkZWZhdWx0IGNoZWNrcyBhbmQgZW1pdCBldmVudHMgYXMgbm9ybWFsLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY3VzdG9tIGJ1dHRvbnMgb3IgcHJvZ3JhbW1hdGljIHdvcmtmbG93cyB0aGF0IGFyZSBub3RcbiAgICogZXhlY3V0aW5nIHRoZSB3aXphcmRzIGRlZmF1bHQgY2hlY2tzIGFuZCBlbWlzc2lvbnMuIEl0IGlzIGFub3RoZXIgd2F5IHRvXG4gICAqIG5hdmlnYXRlIHdpdGhvdXQgaGF2aW5nIHRvIHJld3JpdGUgdGhlIHdpemFyZMOiwoDCmXMgZGVmYXVsdCBmdW5jdGlvbmFsaXR5XG4gICAqIGZyb20gc2NyYXRjaC5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgbmV4dCgpIGRvZXMgbm90IGV4ZWN1dGUgZXZlbnQgZW1pc3Npb25zIG9yIGNoZWNrcyBiZWNhdXNlIHRoZVxuICAgKiA4MCUgY2FzZSBpcyB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFzIHBhcnQgb2YgYW4gYWx0ZXJuYXRpdmVcbiAgICogbmF2aWdhdGlvbiB3aXRoIGNscldpemFyZFByZXZlbnREZWZhdWx0TmV4dC5cbiAgICpcbiAgICogQG5hbWUgbmV4dFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgbmV4dChza2lwQ2hlY2tzQW5kRW1pdHM6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKHNraXBDaGVja3NBbmRFbWl0cykge1xuICAgICAgdGhpcy5mb3JjZU5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYXZTZXJ2aWNlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5jbHVkZXMgYSBCb29sZWFuIHBhcmFtZXRlciB0aGF0IHdpbGwgc2tpcCBjaGVja3MgYW5kIGV2ZW50IGVtaXNzaW9ucy5cbiAgICogSWYgdHJ1ZSwgdGhlIHdpemFyZCB3aWxsICBjb21wbGV0ZSBhbmQgY2xvc2UgcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2ZcbiAgICogaXRzIGN1cnJlbnQgcGFnZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsdGVybmF0aXZlIG5hdmlnYXRpb24gd2hlcmUgZXZlbnRcbiAgICogZW1pc3Npb25zIGhhdmUgYWxyZWFkeSBiZWVuIGRvbmUgYW5kIGZpcmluZyB0aGVtIGFnYWluIG1heSBjYXVzZSBhbiBldmVudCBsb29wLlxuICAgKlxuICAgKiBJZiBmYWxzZSwgdGhlIHdpemFyZCB3aWxsIGV4ZWN1dGUgZGVmYXVsdCBjaGVja3MgYW5kIGVtaXQgZXZlbnRzIGJlZm9yZVxuICAgKiBjb21wbGV0aW5nIGFuZCBjbG9zaW5nLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBmaW5pc2goKSBkb2VzIG5vdCBleGVjdXRlIGV2ZW50IGVtaXNzaW9ucyBvciBjaGVja3MgYmVjYXVzZSB0aGVcbiAgICogODAlIGNhc2UgaXMgdGhhdCB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhcyBwYXJ0IG9mIGFuIGFsdGVybmF0aXZlXG4gICAqIG5hdmlnYXRpb24gd2l0aCBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQuXG4gICAqXG4gICAqIEBuYW1lIGZpbmlzaFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgZmluaXNoKHNraXBDaGVja3NBbmRFbWl0czogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICBpZiAoc2tpcENoZWNrc0FuZEVtaXRzKSB7XG4gICAgICB0aGlzLmZvcmNlRmluaXNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmF2U2VydmljZS5maW5pc2goKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRG9lcyB0aGUgd29yayBvZiBmaW5pc2hpbmcgdXAgdGhlIHdpemFyZCBhbmQgY2xvc2luZyBpdCBidXQgZG9lc24ndCBkbyB0aGVcbiAgICogY2hlY2tzIGFuZCBlbWlzc2lvbnMgdGhhdCBvdGhlciBwYXRocyBkby4gR29vZCBmb3IgYSBsYXN0IHN0ZXAgaW4gYW5cbiAgICogYWx0ZXJuYXRlIHdvcmtmbG93LlxuICAgKlxuICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIGNhbGxpbmcgQ2xyV2l6YXJkLmZpbmlzaCh0cnVlKSBvciBDbHJXaXphcmQuZmluaXNoKClcbiAgICogd2l0aG91dCBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogQG5hbWUgZm9yY2VGaW5pc2hcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIGZvcmNlRmluaXNoKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgdGhlIHdvcmsgb2YgbW92aW5nIHRoZSB3aXphcmQgdG8gdGhlIG5leHQgcGFnZSB3aXRob3V0IHRoZVxuICAgKiBjaGVja3MgYW5kIGVtaXNzaW9ucyB0aGF0IG90aGVyIHBhdGhzIGRvLiBHb29kIGZvciBhIGxhc3Qgc3RlcCBpbiBhblxuICAgKiBhbHRlcm5hdGUgd29ya2Zsb3cuXG4gICAqXG4gICAqIERvZXMgdGhlIHNhbWUgdGhpbmcgYXMgY2FsbGluZyBDbHJXaXphcmQubmV4dCh0cnVlKSBvciBDbHJXaXphcmQubmV4dCgpXG4gICAqIHdpdGhvdXQgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBuYW1lIGZvcmNlTmV4dFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgZm9yY2VOZXh0KCk6IHZvaWQge1xuICAgIHRoaXMubmF2U2VydmljZS5mb3JjZU5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgdGhlIGZ1bmN0aW9uYWxpdHkgdGhhdCBjYW5jZWxzIGFuZCBjbG9zZXMgdGhlIHdpemFyZC5cbiAgICpcbiAgICogRG8gbm90IHVzZSB0aGlzIGZvciBhbiBvdmVycmlkZSBvZiB0aGUgY2FuY2VsIHRoZSBmdW5jdGlvbmFsaXR5XG4gICAqIHdpdGggY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWwsIGNscldpemFyZFByZXZlbnRQYWdlRGVmYXVsdENhbmNlbCxcbiAgICogb3IgY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0IGJlY2F1c2UgaXQgd2lsbCBpbml0aWF0ZSB0aGUgc2FtZSBjaGVja3NcbiAgICogYW5kIGV2ZW50IGVtaXNzaW9ucyB0aGF0IGludm9rZWQgeW91ciBldmVudCBoYW5kbGVyLlxuICAgKlxuICAgKiBVc2UgQ2xyV2l6YXJkLmNsb3NlKCkgaW5zdGVhZC5cbiAgICpcbiAgICogQG5hbWUgY2FuY2VsXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBjYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLmNhbmNlbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBiZWhhdmlvciBvZiB0aGUgdW5kZXJseWluZyBtb2RhbCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGhcbiAgICogYWx0ZXJuYXRpdmUgY2FuY2VsIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEluIG1vc3QgY2FzZXMsIHVzZSBDbHJXaXphcmQuY2FuY2VsKCkgaW5zdGVhZC5cbiAgICpcbiAgICogQG5hbWUgbW9kYWxDYW5jZWxcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIG1vZGFsQ2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tBbmRDYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgZm9yIGFsdGVybmF0aXZlIGNhbmNlbCBmbG93cyBkZWZpbmVkIGF0IHRoZSBjdXJyZW50IHBhZ2Ugb3JcbiAgICogd2l6YXJkIGxldmVsLiBQZXJmb3JtcyBhIGNhbmNlbGVkIGlmIG5vdC4gRW1pdHMgZXZlbnRzIHRoYXQgaW5pdGlhdGVcbiAgICogdGhlIGFsdGVybmF0aXZlIGNhbmNlbCBvdXRwdXRzIChjbHJXaXphcmRQYWdlT25DYW5jZWwgYW5kXG4gICAqIGNscldpemFyZE9uQ2FuY2VsKSBpZiBzby5cbiAgICpcbiAgICogQG5hbWUgY2hlY2tBbmRDYW5jZWxcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIGNoZWNrQW5kQ2FuY2VsKCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICBjb25zdCBjdXJyZW50UGFnZUhhc092ZXJyaWRlcyA9IGN1cnJlbnRQYWdlLnN0b3BDYW5jZWwgfHwgY3VycmVudFBhZ2UucHJldmVudERlZmF1bHQ7XG5cbiAgICBpZiAodGhpcy5zdG9wTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRQYWdlLnBhZ2VPbkNhbmNlbC5lbWl0KCk7XG4gICAgaWYgKCFjdXJyZW50UGFnZUhhc092ZXJyaWRlcykge1xuICAgICAgdGhpcy5vbkNhbmNlbC5lbWl0KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnN0b3BDYW5jZWwgJiYgIWN1cnJlbnRQYWdlSGFzT3ZlcnJpZGVzKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgdGhlIHdpemFyZCBJRCBhcyBhIHN0cmluZyBwYXJhbWV0ZXIgYW5kIGNhbGxzIHRvIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqIHRvIG5hdmlnYXRlIHRvIHRoZSBwYWdlIHdpdGggdGhhdCBJRC4gTmF2aWdhdGlvbiB3aWxsIGludm9rZSB0aGUgd2l6YXJkw6LCgMKZcyBkZWZhdWx0XG4gICAqIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zLlxuICAgKlxuICAgKiBQcm9iYWJseSBsZXNzIHVzZWZ1bCB0aGFuIGNhbGxpbmcgZGlyZWN0bHkgdG8gQ2xyV2l6YXJkLm5hdlNlcnZpY2UuZ29UbygpIGJlY2F1c2UgdGhlXG4gICAqIG5hdiBzZXJ2aWNlIG1ldGhvZCBjYW4gYWNjZXB0IGVpdGhlciBhIHN0cmluZyBJRCBvciBhIHBhZ2Ugb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSBleHBlY3RlZCBJRCBwYXJhbWV0ZXIgY2FuIGJlIGZvdW5kIGluIHRoZSByZXR1cm4gb2YgdGhlXG4gICAqIENscldpemFyZFBhZ2UuaWQgZ2V0dGVyLCB1c3VhbGx5IHByZWZpeGVkIHdpdGggw6LCgMKcY2xyLXdpemFyZC1wYWdlLcOiwoDCnCBhbmQgdGhlbiBlaXRoZXIgYVxuICAgKiBudW1lcmljIElEIG9yIHRoZSBJRCBzcGVjaWZpZWQgZm9yIHRoZSBDbHJXaXphcmRQYWdlIGNvbXBvbmVudMOiwoDCmXMgw6LCgMKcaWTDosKAwp0gaW5wdXQuXG4gICAqXG4gICAqIEBuYW1lIGdvVG9cbiAgICpcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIGdvVG8ocGFnZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoIXBhZ2VJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubmF2U2VydmljZS5nb1RvKHBhZ2VJZCk7XG4gIH1cblxuICAvKipcbiAgICogQSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0aGF0IGNhbGxzIHRvIFBhZ2VDb2xsZWN0aW9uU2VydmljZS5yZXNldCgpIGFuZCBlbWl0cyB0aGVcbiAgICogQ2xyV2l6YXJkLm9uUmVzZXQgZXZlbnQuXG4gICAqXG4gICAqIFJlc2V0IHNldHMgYWxsIFdpemFyZFBhZ2VzIHRvIGluY29tcGxldGUgYW5kIHNldHMgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIENscldpemFyZCB0b1xuICAgKiBiZSB0aGUgY3VycmVudCBwYWdlLCBlc3NlbnRpYWxseSByZXNldHRpbmcgdGhlIHdpemFyZCBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBVc2VycyB3b3VsZCB0aGVuIHVzZSB0aGUgb25SZXNldCBldmVudCB0byByZXNldCB0aGUgZGF0YSBvciBtb2RlbCBpbiB0aGVpclxuICAgKiBob3N0IGNvbXBvbmVudC5cbiAgICpcbiAgICogSXQgY291bGQgYmUgdXNlZnVsIHRvIGNhbGwgYSByZXNldCB3aXRob3V0IGZpcmluZyB0aGUgb25SZXNldCBldmVudC4gVG8gZG8gdGhpcyxcbiAgICoganVzdCBjYWxsIENscldpemFyZC5wYWdlQ29sbGVjdGlvbi5yZXNldCgpIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAbmFtZSByZXNldFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgcmVzZXQoKSB7XG4gICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5yZXNldCgpO1xuICAgIHRoaXMub25SZXNldC5uZXh0KCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQnV0dG9uSHViU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2J1dHRvbi1odWIuc2VydmljZSc7XG5pbXBvcnQgeyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9CVVRUT05fVFlQRVM6IGFueSA9IHtcbiAgY2FuY2VsOiAnY2FuY2VsJyxcbiAgcHJldmlvdXM6ICdwcmV2aW91cycsXG4gIG5leHQ6ICduZXh0JyxcbiAgZmluaXNoOiAnZmluaXNoJyxcbiAgZGFuZ2VyOiAnZGFuZ2VyJyxcbn07XG5cbmV4cG9ydCBjb25zdCBDVVNUT01fQlVUVE9OX1RZUEVTOiBhbnkgPSB7XG4gIGNhbmNlbDogJ2N1c3RvbS1jYW5jZWwnLFxuICBwcmV2aW91czogJ2N1c3RvbS1wcmV2aW91cycsXG4gIG5leHQ6ICdjdXN0b20tbmV4dCcsXG4gIGZpbmlzaDogJ2N1c3RvbS1maW5pc2gnLFxuICBkYW5nZXI6ICdjdXN0b20tZGFuZ2VyJyxcbn07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci13aXphcmQtYnV0dG9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImJ0biBjbHItd2l6YXJkLWJ0blwiXG4gICAgICAgICAgICBbY2xhc3MuYnRuLWxpbmtdPVwiaXNDYW5jZWxcIlxuICAgICAgICAgICAgW2NsYXNzLmNsci13aXphcmQtYnRuLS10ZXJ0aWFyeV09XCJpc0NhbmNlbFwiXG4gICAgICAgICAgICBbY2xhc3MuYnRuLW91dGxpbmVdPVwiaXNQcmV2aW91c1wiXG4gICAgICAgICAgICBbY2xhc3MuY2xyLXdpemFyZC1idG4tLXNlY29uZGFyeV09XCJpc1ByZXZpb3VzXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tcHJpbWFyeV09XCJpc1ByaW1hcnlBY3Rpb25cIlxuICAgICAgICAgICAgW2NsYXNzLmNsci13aXphcmQtYnRuLS1wcmltYXJ5XT1cImlzUHJpbWFyeUFjdGlvblwiXG4gICAgICAgICAgICBbY2xhc3MuYnRuLXN1Y2Nlc3NdPVwiaXNGaW5pc2hcIlxuICAgICAgICAgICAgW2NsYXNzLmJ0bi1kYW5nZXJdPVwiaXNEYW5nZXJcIlxuICAgICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImlzRGlzYWJsZWRcIlxuICAgICAgICAgICAgW2F0dHIuZGlzYWJsZWRdPVwiX2Rpc2FibGVkQXR0cmlidXRlXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjbGljaygpXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG4gIGhvc3Q6IHsgY2xhc3M6ICdjbHItd2l6YXJkLWJ0bi13cmFwcGVyJywgJ1thdHRyLmFyaWEtaGlkZGVuXSc6ICdpc0hpZGRlbicgfSxcbiAgc3R5bGVzOiBbJ1thcmlhLWhpZGRlbj1cInRydWVcIl0geyBkaXNwbGF5OiBub25lOyB9J10sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZEJ1dHRvbiB7XG4gIEBJbnB1dCgndHlwZScpIHB1YmxpYyB0eXBlOiBzdHJpbmcgPSAnJztcblxuICBASW5wdXQoJ2NscldpemFyZEJ1dHRvbkRpc2FibGVkJykgcHVibGljIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQElucHV0KCdjbHJXaXphcmRCdXR0b25IaWRkZW4nKSBwdWJsaWMgaGlkZGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gRXZlbnRFbWl0dGVyIHdoaWNoIGlzIGVtaXR0ZWQgd2hlbiBhIGJ1dHRvbiBpcyBjbGlja2VkLlxuICBAT3V0cHV0KCdjbHJXaXphcmRCdXR0b25DbGlja2VkJykgd2FzQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oZmFsc2UpO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYXZTZXJ2aWNlOiBXaXphcmROYXZpZ2F0aW9uU2VydmljZSwgcHVibGljIGJ1dHRvblNlcnZpY2U6IEJ1dHRvbkh1YlNlcnZpY2UpIHt9XG5cbiAgcHJpdmF0ZSBjaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHZhbHVlVG9DaGVjazogc3RyaW5nID0gJycsIHR5cGVUb0xvb2tVcDogc3RyaW5nKSB7XG4gICAgaWYgKERFRkFVTFRfQlVUVE9OX1RZUEVTW3R5cGVUb0xvb2tVcF0gPT09IHZhbHVlVG9DaGVjaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChDVVNUT01fQlVUVE9OX1RZUEVTW3R5cGVUb0xvb2tVcF0gPT09IHZhbHVlVG9DaGVjaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNDYW5jZWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh0aGlzLnR5cGUsICdjYW5jZWwnKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNOZXh0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNoZWNrRGVmYXVsdEFuZEN1c3RvbVR5cGUodGhpcy50eXBlLCAnbmV4dCcpO1xuICB9XG5cbiAgcHVibGljIGdldCBpc1ByZXZpb3VzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNoZWNrRGVmYXVsdEFuZEN1c3RvbVR5cGUodGhpcy50eXBlLCAncHJldmlvdXMnKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNGaW5pc2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh0aGlzLnR5cGUsICdmaW5pc2gnKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNEYW5nZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh0aGlzLnR5cGUsICdkYW5nZXInKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNQcmltYXJ5QWN0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzTmV4dCB8fCB0aGlzLmlzRGFuZ2VyIHx8IHRoaXMuaXNGaW5pc2g7XG4gIH1cblxuICBwdWJsaWMgZ2V0IF9kaXNhYmxlZEF0dHJpYnV0ZSgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAodGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0Rpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIC8vIGRlYWxpbmcgd2l0aCBuZWdhdGl2ZXMgaGVyZS4gY29nbml0aXZlbHkgZWFzaWVyIHRvIHRoaW5rIG9mIGl0IGxpa2UgdGhpcy4uLlxuICAgIGNvbnN0IGRpc2FibGVkID0gdHJ1ZTtcbiAgICBjb25zdCBuYXYgPSB0aGlzLm5hdlNlcnZpY2U7XG4gICAgY29uc3QgcGFnZSA9IHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZTtcblxuICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBjaGFuZ2UgdGhlIHJlc3BvbnNlIHVudGlsIGJ1dHRvbnMgYXJlIHJlYWR5IHRvIGF2b2lkIGNob2NvbGF0ZVxuICAgIGlmICghdGhpcy5idXR0b25TZXJ2aWNlLmJ1dHRvbnNSZWFkeSkge1xuICAgICAgcmV0dXJuICFkaXNhYmxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBuYXYud2l6YXJkU3RvcE5hdmlnYXRpb24gfHwgIXBhZ2UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FuY2VsKSB7XG4gICAgICByZXR1cm4gIWRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUHJldmlvdXMgJiYgKG5hdi5jdXJyZW50UGFnZUlzRmlyc3QgfHwgcGFnZS5wcmV2aW91c1N0ZXBEaXNhYmxlZCkpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0RhbmdlciAmJiAhcGFnZS5yZWFkeVRvQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc05leHQgJiYgKG5hdi5jdXJyZW50UGFnZUlzTGFzdCB8fCAhcGFnZS5yZWFkeVRvQ29tcGxldGUpKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNGaW5pc2ggJiYgKCFuYXYuY3VycmVudFBhZ2VJc0xhc3QgfHwgIXBhZ2UucmVhZHlUb0NvbXBsZXRlKSkge1xuICAgICAgcmV0dXJuIGRpc2FibGVkO1xuICAgIH1cblxuICAgIHJldHVybiAhZGlzYWJsZWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzSGlkZGVuKCk6IGJvb2xlYW4ge1xuICAgIC8vIGRlYWxpbmcgd2l0aCBuZWdhdGl2ZXMgaGVyZS4gY29nbml0aXZlbHkgZWFzaWVyIHRvIHRoaW5rIG9mIGl0IGxpa2UgdGhpcy4uLlxuICAgIGNvbnN0IGhpZGRlbiA9IHRydWU7XG4gICAgY29uc3QgbmF2ID0gdGhpcy5uYXZTZXJ2aWNlO1xuXG4gICAgLy8gRW5zdXJlIHdlIGRvbid0IGNoYW5nZSB0aGUgcmVzcG9uc2UgdW50aWwgYnV0dG9ucyBhcmUgcmVhZHkgdG8gYXZvaWQgY2hvY29sYXRlXG4gICAgaWYgKCF0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5KSB7XG4gICAgICByZXR1cm4gIWhpZGRlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oaWRkZW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzQ2FuY2VsKSB7XG4gICAgICByZXR1cm4gIWhpZGRlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1ByZXZpb3VzICYmIG5hdi5jdXJyZW50UGFnZUlzRmlyc3QpIHtcbiAgICAgIHJldHVybiBoaWRkZW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOZXh0ICYmIG5hdi5jdXJyZW50UGFnZUlzTGFzdCkge1xuICAgICAgcmV0dXJuIGhpZGRlbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0ZpbmlzaCAmJiAhbmF2LmN1cnJlbnRQYWdlSXNMYXN0KSB7XG4gICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH1cblxuICAgIHJldHVybiAhaGlkZGVuO1xuICB9XG5cbiAgY2xpY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2FzQ2xpY2tlZC5lbWl0KHRoaXMudHlwZSk7XG4gICAgdGhpcy5idXR0b25TZXJ2aWNlLmJ1dHRvbkNsaWNrZWQodGhpcy50eXBlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLXdpemFyZC10aXRsZSwgY2xyLXdpemFyZC1wYWdldGl0bGUnIH0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkQ3VzdG9tVGFncyB7XG4gIC8vIE5vIGJlaGF2aW9yXG4gIC8vIFRoZSBvbmx5IHB1cnBvc2UgaXMgdG8gXCJkZWNsYXJlXCIgdGhlIHRhZyBpbiBBbmd1bGFyXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItd2l6YXJkLXN0ZXBuYXYnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8b2wgY2xhc3M9XCJjbHItd2l6YXJkLXN0ZXBuYXYtbGlzdFwiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgICAgICAgICA8bGkgKm5nRm9yPVwibGV0IHBhZ2Ugb2YgcGFnZVNlcnZpY2UucGFnZXNcIiBjbHItd2l6YXJkLXN0ZXBuYXYtaXRlbSBcbiAgICAgICAgICAgIFtwYWdlXT1cInBhZ2VcIiBjbGFzcz1cImNsci13aXphcmQtc3RlcG5hdi1pdGVtXCI+PC9saT5cbiAgICAgICAgPC9vbD5cbiAgICBgLFxuICBob3N0OiB7IGNsYXNzOiAnY2xyLXdpemFyZC1zdGVwbmF2JyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRTdGVwbmF2IHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VTZXJ2aWNlOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UpIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENscldpemFyZFBhZ2UgfSBmcm9tICcuL3dpemFyZC1wYWdlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW2Nsci13aXphcmQtc3RlcG5hdi1pdGVtXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1saW5rIGNsci13aXphcmQtc3RlcG5hdi1saW5rXCIgKGNsaWNrKT1cImNsaWNrKClcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJwYWdlLm5hdlRpdGxlXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbaWRdJzogJ2lkJyxcbiAgICAnW2F0dHIuYXJpYS1zZWxlY3RlZF0nOiAnaXNDdXJyZW50JyxcbiAgICAnW2F0dHIuYXJpYS1jb250cm9sc10nOiAnaWQnLFxuICAgIHJvbGU6ICd0YWInLFxuICAgICdbY2xhc3MuY2xyLW5hdi1saW5rXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLm5hdi1pdGVtXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmFjdGl2ZV0nOiAnaXNDdXJyZW50JyxcbiAgICAnW2NsYXNzLmRpc2FibGVkXSc6ICdpc0Rpc2FibGVkJyxcbiAgICAnW2NsYXNzLm5vLWNsaWNrXSc6ICchY2FuTmF2aWdhdGUnLFxuICAgICdbY2xhc3MuY29tcGxldGVdJzogJ2lzQ29tcGxldGUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRTdGVwbmF2SXRlbSB7XG4gIEBJbnB1dCgncGFnZScpIHB1YmxpYyBwYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYXZTZXJ2aWNlOiBXaXphcmROYXZpZ2F0aW9uU2VydmljZSwgcHVibGljIHBhZ2VDb2xsZWN0aW9uOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UpIHt9XG5cbiAgcHJpdmF0ZSBwYWdlR3VhcmQoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnBhZ2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2l6YXJkIHN0ZXBuYXYgaXRlbSBpcyBub3QgYXNzb2NpYXRlZCB3aXRoIGEgd2l6YXJkIHBhZ2UuJyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgIHRoaXMucGFnZUd1YXJkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFnZUNvbGxlY3Rpb24uZ2V0U3RlcEl0ZW1JZEZvclBhZ2UodGhpcy5wYWdlKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNEaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICB0aGlzLnBhZ2VHdWFyZCgpO1xuICAgIHJldHVybiB0aGlzLnBhZ2UuZGlzYWJsZWQgfHwgdGhpcy5uYXZTZXJ2aWNlLndpemFyZFN0b3BOYXZpZ2F0aW9uIHx8IHRoaXMubmF2U2VydmljZS53aXphcmREaXNhYmxlU3RlcG5hdjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNDdXJyZW50KCk6IGJvb2xlYW4ge1xuICAgIHRoaXMucGFnZUd1YXJkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5jdXJyZW50O1xuICB9XG5cbiAgcHVibGljIGdldCBpc0NvbXBsZXRlKCk6IGJvb2xlYW4ge1xuICAgIHRoaXMucGFnZUd1YXJkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5jb21wbGV0ZWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGNhbk5hdmlnYXRlKCk6IGJvb2xlYW4ge1xuICAgIHRoaXMucGFnZUd1YXJkKCk7XG4gICAgcmV0dXJuIHRoaXMucGFnZUNvbGxlY3Rpb24ucHJldmlvdXNQYWdlSXNDb21wbGV0ZWQodGhpcy5wYWdlKTtcbiAgfVxuXG4gIGNsaWNrKCk6IHZvaWQge1xuICAgIHRoaXMucGFnZUd1YXJkKCk7XG5cbiAgICAvLyBpZiB3ZSBjbGljayBvbiBvdXIgb3duIHN0ZXBuYXYgb3IgYSBkaXNhYmxlZCBzdGVwbmF2LCB3ZSBkb24ndCB3YW50IHRvIGRvIGFueXRoaW5nXG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCB8fCB0aGlzLmlzQ3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubmF2U2VydmljZS5nb1RvKHRoaXMucGFnZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckFsZXJ0TW9kdWxlIH0gZnJvbSAnLi4vZW1waGFzaXMvYWxlcnQvYWxlcnQubW9kdWxlJztcbmltcG9ydCB7IENsck1vZGFsTW9kdWxlIH0gZnJvbSAnLi4vbW9kYWwvbW9kYWwubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyV2l6YXJkIH0gZnJvbSAnLi93aXphcmQnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkQnV0dG9uIH0gZnJvbSAnLi93aXphcmQtYnV0dG9uJztcbmltcG9ydCB7IENscldpemFyZEN1c3RvbVRhZ3MgfSBmcm9tICcuL3dpemFyZC1jdXN0b20tdGFncyc7XG5pbXBvcnQgeyBDbHJXaXphcmRIZWFkZXJBY3Rpb24gfSBmcm9tICcuL3dpemFyZC1oZWFkZXItYWN0aW9uJztcbmltcG9ydCB7IENscldpemFyZFBhZ2UgfSBmcm9tICcuL3dpemFyZC1wYWdlJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VCdXR0b25zIH0gZnJvbSAnLi93aXphcmQtcGFnZS1idXR0b25zJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VIZWFkZXJBY3Rpb25zIH0gZnJvbSAnLi93aXphcmQtcGFnZS1oZWFkZXItYWN0aW9ucyc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlTmF2VGl0bGUgfSBmcm9tICcuL3dpemFyZC1wYWdlLW5hdnRpdGxlJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VUaXRsZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtdGl0bGUnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkU3RlcG5hdiB9IGZyb20gJy4vd2l6YXJkLXN0ZXBuYXYnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkU3RlcG5hdkl0ZW0gfSBmcm9tICcuL3dpemFyZC1zdGVwbmF2LWl0ZW0nO1xuXG5leHBvcnQgY29uc3QgQ0xSX1dJWkFSRF9ESVJFQ1RJVkVTOiBhbnlbXSA9IFtcbiAgQ2xyV2l6YXJkLFxuICBDbHJXaXphcmRQYWdlLFxuICBDbHJXaXphcmRTdGVwbmF2LFxuICBDbHJXaXphcmRTdGVwbmF2SXRlbSxcbiAgQ2xyV2l6YXJkQnV0dG9uLFxuICBDbHJXaXphcmRIZWFkZXJBY3Rpb24sXG4gIENscldpemFyZEN1c3RvbVRhZ3MsXG4gIENscldpemFyZFBhZ2VUaXRsZSxcbiAgQ2xyV2l6YXJkUGFnZU5hdlRpdGxlLFxuICBDbHJXaXphcmRQYWdlQnV0dG9ucyxcbiAgQ2xyV2l6YXJkUGFnZUhlYWRlckFjdGlvbnMsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJNb2RhbE1vZHVsZSwgQ2xyQWxlcnRNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfV0laQVJEX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1dJWkFSRF9ESVJFQ1RJVkVTXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJCdXR0b25Nb2R1bGUgfSBmcm9tICcuL2J1dHRvbi9idXR0b24ubW9kdWxlJztcbmltcG9ydCB7IENsckRhdGFNb2R1bGUgfSBmcm9tICcuL2RhdGEvZGF0YS5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRHJhZ0FuZERyb3BNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1hbmQtZHJvcC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRW1waGFzaXNNb2R1bGUgfSBmcm9tICcuL2VtcGhhc2lzL2VtcGhhc2lzLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJGb3Jtc01vZHVsZSB9IGZyb20gJy4vZm9ybXMvZm9ybXMubW9kdWxlJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTGF5b3V0TW9kdWxlIH0gZnJvbSAnLi9sYXlvdXQvbGF5b3V0Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJNb2RhbE1vZHVsZSB9IGZyb20gJy4vbW9kYWwvbW9kYWwubW9kdWxlJztcbmltcG9ydCB7IENsclBvcG92ZXJNb2R1bGUgfSBmcm9tICcuL3BvcG92ZXIvcG9wb3Zlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJZkV4cGFuZE1vZHVsZSB9IGZyb20gJy4vdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRm9jdXNUcmFwTW9kdWxlIH0gZnJvbSAnLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAubW9kdWxlJztcbmltcG9ydCB7IENsckxvYWRpbmdNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkTW9kdWxlIH0gZnJvbSAnLi93aXphcmQvd2l6YXJkLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGV4cG9ydHM6IFtcbiAgICBDbHJFbXBoYXNpc01vZHVsZSxcbiAgICBDbHJEYXRhTW9kdWxlLFxuICAgIENsckljb25Nb2R1bGUsXG4gICAgQ2xyTW9kYWxNb2R1bGUsXG4gICAgQ2xyTG9hZGluZ01vZHVsZSxcbiAgICBDbHJJZkV4cGFuZE1vZHVsZSxcbiAgICBDbHJDb25kaXRpb25hbE1vZHVsZSxcbiAgICBDbHJGb2N1c1RyYXBNb2R1bGUsXG4gICAgQ2xyQnV0dG9uTW9kdWxlLFxuICAgIENsckZvcm1zTW9kdWxlLFxuICAgIENsckxheW91dE1vZHVsZSxcbiAgICBDbHJQb3BvdmVyTW9kdWxlLFxuICAgIENscldpemFyZE1vZHVsZSxcbiAgICBDbHJEcmFnQW5kRHJvcE1vZHVsZSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xhcml0eU1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuLyoqXG4gKiBQcml2YXRlIGNvdW50ZXIgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyBmb3IgdGhlIGNoZWNrYm94ZXMsIHRvIGJpbmQgdGhlIGxhYmVscyB0byB0aGVtLlxuICovXG5sZXQgbGF0ZXN0SWQgPSAwO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIENsckNoZWNrYm94IHdpbGwgYmUgcmVuYW1lZCB0byBDbHJDaGVja2JveERlcHJlY2F0ZWQgaW4gMC4xMiwgYW5kIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIG5ld1xuICogaW1wbGVtZW50YXRpb24gaW4gMC4xMywgc28gaWYgeW91IGltcG9ydCBpdCB5b3Ugd2lsbCBuZWVkIHRvIHVwZGF0ZSB5b3VyIHJlZmVyZW5jZXMuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jaGVja2JveCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDwhLS1cbiAgICAgICAgICAgIEZJWE1FOiBXZSBhcmUgbm90IHN1YnNjcmliZWQgdG8gdGhlIGNoYW5nZSBldmVudCBidXQgdGhlIGNsaWNrIGV2ZW50IGhlcmUuXG4gICAgICAgICAgICBUaGUgcmVhc29uIGZvciB0aGF0IGlzIGJlY2F1c2UgY2hlY2tib3hlcyBiZWhhdmUgZGlmZmVyZW50bHkgb24gSUUgJiBFZGdlLlxuICAgICAgICAgICAgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NDQ3OTM5XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFRvIGZpeCB0aGF0LCB3ZSBsaXN0ZW4gdG8gZXZlcnkgY2xpY2sgZXZlbnQgYW5kIHRoZW4gdG9nZ2xlIHRoZSBjaGVja2JveCBtYW51YWxseVxuICAgICAgICAgICAgdG8gbWFrZSBpdCBiZWhhdmUgdGhlIHNhbWUgd2F5IGFjcm9zcyB0aGUgYnJvd3NlcnMgd2Ugc3VwcG9ydC5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgVGhpcyB3b3JrcyBmb3IgY2FzZXMgd2hlbiB1c2VycyB0b2dnbGUgdGhlIGNoZWNrYm94IHVzaW5nIHRoZSBrZXlib2FyZCB0b286XG4gICAgICAgICAgICBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzg3ODk0MC9zcGFjZWJhci10cmlnZ2VyaW5nLWNsaWNrLWV2ZW50LW9uLWNoZWNrYm94XG4gICAgICAgIC0tPlxuICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImNsckFyaWFMYWJlbGVkQnlcIlxuICAgICAgICAgICAgICAgW2lkXT1cImlkXCIgW25hbWVdPVwibmFtZVwiIFtjaGVja2VkXT1cImNoZWNrZWRcIlxuICAgICAgICAgICAgICAgW2luZGV0ZXJtaW5hdGVdPVwiaW5kZXRlcm1pbmF0ZVwiIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAoYmx1cik9XCJ0b3VjaCgpXCIgKGNsaWNrKT1cImNoZWNrSW5kZXRlcm1pbmF0ZVN0YXRlKClcIj5cbiAgICAgICAgPGxhYmVsIFthdHRyLmZvcl09XCJpZFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2xhYmVsPlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5jaGVja2JveF0nOiAnIWlubGluZScsICdbY2xhc3MuY2hlY2tib3gtaW5saW5lXSc6ICdpbmxpbmUnLCAnW2NsYXNzLmRpc2FibGVkXSc6ICdkaXNhYmxlZCcgfSxcbiAgLypcbiAgICAgKiBUaGlzIHByb3ZpZGVyIGxldHMgdXMgZGVjbGFyZSBvdXIgY2hlY2tib3ggYXMgYSBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgKiB3aGljaCBhbGxvd3MgdXMgdG8gdXNlIFsobmdNb2RlbCldIGRpcmVjdGx5IG9uIG91ciBjb21wb25lbnQsXG4gICAgICogd2l0aCBhbGwgdGhlIGF1dG9tYXRpYyBmZWF0dXJlcyB3aXJpbmcgdGhhdCBjb21lIHdpdGggaXQuXG4gICAgICovXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENsckNoZWNrYm94RGVwcmVjYXRlZCksIG11bHRpOiB0cnVlIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDaGVja2JveERlcHJlY2F0ZWQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gIC8vIElmIG91ciBob3N0IGhhcyBhbiBJRCBhdHRyaWJ1dGUsIHdlIHVzZSB0aGlzIGluc3RlYWQgb2Ygb3VyIGluZGV4LlxuICBASW5wdXQoJ2lkJykgX2lkOiBzdHJpbmcgPSAobGF0ZXN0SWQrKykudG9TdHJpbmcoKTtcblxuICBwdWJsaWMgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgY2xyLWNoZWNrYm94LSR7dGhpcy5faWR9YDtcbiAgfVxuXG4gIC8vIElmIGhvc3QgcHJvdmlkZXMgYW4gY2xyQXJpYUxhYmVsZWRCeSBpbnB1dCwgd2UgYXBwbHkgaXQgdG8gdGhlIGNoZWNrYm94XG4gIEBJbnB1dCgnY2xyQXJpYUxhYmVsZWRCeScpIHB1YmxpYyBjbHJBcmlhTGFiZWxlZEJ5OiBzdHJpbmcgPSBudWxsO1xuXG4gIC8vIElmIG91ciBob3N0IGhhcyBhIG5hbWUgYXR0cmlidXRlLCB3ZSBhcHBseSBpdCB0byB0aGUgY2hlY2tib3guXG4gIEBJbnB1dCgnbmFtZScpIHB1YmxpYyBuYW1lOiBzdHJpbmcgPSBudWxsO1xuXG4gIC8vIElmIHRoZSBob3N0IGlzIGRpc2FibGVkIHdlIGFwcGx5IGl0IHRvIHRoZSBjaGVja2JveFxuICBASW5wdXQoJ2NsckRpc2FibGVkJykgcHVibGljIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLy8gU3VwcG9ydCBmb3IgaW5saW5lIGNoZWNrYm94ZXMsIGFkZHMgdGhlIG5lY2Vzc2FyeSBjbGFzcyB0byB0aGUgaG9zdFxuICBASW5wdXQoJ2NscklubGluZScpIHB1YmxpYyBpbmxpbmUgPSBmYWxzZTtcblxuICBwcml2YXRlIF9jaGVja2VkID0gZmFsc2U7XG5cbiAgcHVibGljIGdldCBjaGVja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICB9XG5cbiAgQElucHV0KCdjbHJDaGVja2VkJylcbiAgcHVibGljIHNldCBjaGVja2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9jaGVja2VkKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRDaGVja2VkKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pbmRldGVybWluYXRlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHVibGljIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuICB9XG5cbiAgQElucHV0KCdjbHJJbmRldGVybWluYXRlJylcbiAgcHVibGljIHNldCBpbmRldGVybWluYXRlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUgIT09IHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fY2hlY2tlZCkge1xuICAgICAgICB0aGlzLnNldENoZWNrZWQoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRJbmRldGVybWluYXRlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJJbmRldGVybWluYXRlQ2hhbmdlJylcbiAgcHVibGljIGluZGV0ZXJtaW5hdGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHByaXZhdGUgc2V0SW5kZXRlcm1pbmF0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSB2YWx1ZTtcbiAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UuZW1pdCh0aGlzLl9pbmRldGVybWluYXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0Q2hlY2tlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2NoZWNrZWQgPSB2YWx1ZTtcbiAgICB0aGlzLmNoYW5nZS5lbWl0KHRoaXMuX2NoZWNrZWQpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyQ2hlY2tlZENoYW5nZScpIHB1YmxpYyBjaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMuY2hlY2tlZCk7XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5jaGVja2VkKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgICAqIFRoZXNlIGNhbGxiYWNrcyB3aWxsIGJlIGdpdmVuIHRvIHVzIHRocm91Z2ggdGhlIENvbnRyb2xWYWx1ZUFjY2Vzc29yIGludGVyZmFjZSxcbiAgICAgKiBhbmQgd2UgbmVlZCB0byBjYWxsIHRoZW0gd2hlbiB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgY2hlY2tib3guXG4gICAgICovXG4gIHByaXZhdGUgb25DaGFuZ2VDYWxsYmFjayA9IChfOiBhbnkpID0+IHt9O1xuXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IG9uQ2hhbmdlO1xuICB9XG5cbiAgcHJpdmF0ZSBvblRvdWNoZWRDYWxsYmFjayA9ICgpID0+IHt9O1xuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IG9uVG91Y2hlZDtcbiAgfVxuXG4gIHB1YmxpYyB0b3VjaCgpIHtcbiAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gIH1cblxuICBjaGVja0luZGV0ZXJtaW5hdGVTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQ2hlY2tib3hEZXByZWNhdGVkIH0gZnJvbSAnLi9jaGVja2JveCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfQ0hFQ0tCT1hfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyQ2hlY2tib3hEZXByZWNhdGVkXTtcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0NMUl9DSEVDS0JPWF9ESVJFQ1RJVkVTXSwgZXhwb3J0czogW0NMUl9DSEVDS0JPWF9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94RGVwcmVjYXRlZE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRGF0ZXBpY2tlck1vZHVsZSB9IGZyb20gJy4uL2Zvcm1zL2RhdGVwaWNrZXIvZGF0ZXBpY2tlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ2hlY2tib3hEZXByZWNhdGVkTW9kdWxlIH0gZnJvbSAnLi9jaGVja2JveC9jaGVja2JveC5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW0NsckNoZWNrYm94RGVwcmVjYXRlZE1vZHVsZSwgQ2xyRGF0ZXBpY2tlck1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckZvcm1zRGVwcmVjYXRlZE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uTWV0YWRhdGEsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29sbGFwc2UoKTogQW5pbWF0aW9uTWV0YWRhdGFbXSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgcmV0dXJuIFtcbiAgICBzdGF0ZSgndHJ1ZScsIHN0eWxlKHsgaGVpZ2h0OiAwLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nIH0pKSxcbiAgICB0cmFuc2l0aW9uKCd0cnVlID0+IGZhbHNlJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IGhlaWdodDogJyonLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nIH0pKV0pLFxuICAgIHRyYW5zaXRpb24oJ2ZhbHNlID0+IHRydWUnLCBbc3R5bGUoeyBoZWlnaHQ6ICcqJywgJ292ZXJmbG93LXknOiAnaGlkZGVuJyB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gIF07XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25NZXRhZGF0YSwgc3R5bGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZhZGUob3BhY2l0eTogbnVtYmVyID0gMSk6IEFuaW1hdGlvbk1ldGFkYXRhW10ge1xuICByZXR1cm4gW1xuICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IG9wYWNpdHkgfSkpXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAgfSkpXSksXG4gIF07XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBBbmltYXRpb25NZXRhZGF0YSwgc3R5bGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZhZGVTbGlkZShkaXJlY3Rpb246IHN0cmluZyk6IEFuaW1hdGlvbk1ldGFkYXRhW10ge1xuICBsZXQgdHJhbnNmb3JtOiBzdHJpbmcgPSBudWxsO1xuICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCAyNSUpJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgLTI1JSknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgyNSUsIDApJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yNSUsIDApJztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGlyZWN0aW9uICcgKyBkaXJlY3Rpb24gKyAnIGZvciBzbGlkZSBhbmltYXRpb24uJyk7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogdHJhbnNmb3JtIH0pKV0pLFxuICBdO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uTWV0YWRhdGEsIHN0eWxlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzbGlkZShkaXJlY3Rpb246IHN0cmluZyk6IEFuaW1hdGlvbk1ldGFkYXRhW10ge1xuICBsZXQgdHJhbnNmb3JtOiBzdHJpbmcgPSBudWxsO1xuICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCAyNSUpJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgLTI1JSknO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgyNSUsIDApJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yNSUsIDApJztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZGlyZWN0aW9uICcgKyBkaXJlY3Rpb24gKyAnIGZvciBzbGlkZSBhbmltYXRpb24uJyk7XG4gIH1cbiAgcmV0dXJuIFtcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbc3R5bGUoeyB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IHRyYW5zZm9ybTogdHJhbnNmb3JtIH0pKV0pLFxuICBdO1xufVxuIl0sIm5hbWVzIjpbInN0YXRlIiwiZmlsdGVyIiwidHJpZ2dlciIsInRva2VuRmFjdG9yeSIsIlBPU0lUSU9OUyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7TUFRYSxnQkFBZ0I7OztZQUQ1QixTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFOzs7Ozs7OztBQ0duQyxNQUFhLG1CQUFtQixHQUFnQixDQUFDLGdCQUFnQixDQUFDO0FBR2xFLE1BQWEsYUFBYTs7O1lBRHpCLFFBQVEsU0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxFQUFFLFlBQVksRUFBRSxDQUFDLG1CQUFtQixDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsbUJBQW1CLENBQUMsRUFBRTs7Ozs7Ozs7O0lDR3hHLGVBQVk7SUFDWixZQUFTO0lBQ1QsZUFBWTtJQUNaLGFBQVU7SUFDVixZQUFTO0lBQ1QsV0FBUTtJQUNS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LEVBQUUsRUFBRSxFQUFFO0lBQzdHLGNBQWMsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsWUFBWSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFO0lBQzNHLGNBQWMsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFO0lBQzNHLGVBQWUsRUFBRSxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsYUFBYSxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsVUFBVSxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRTtJQUM5RyxhQUFhLEVBQUUsRUFBRSxXQUFXLEVBQUUsS0FBSyxDQUFDLGFBQWEsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLEVBQUU7SUFDMUcsYUFBYSxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDMUcsYUFBYSxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDN0csVUFBVSxFQUFFLEVBQUUsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXLEVBQUUsWUFBWSxFQUFFLEtBQUssQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEVBQUU7SUFDMUcsT0FBTyxF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