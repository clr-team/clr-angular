import { Directive, NgModule, EventEmitter, Input, Output, TemplateRef, ViewContainerRef, Optional, Injectable, Component, SkipSelf, ViewChild, forwardRef, ContentChildren, QueryList, InjectionToken, ElementRef, HostListener, Renderer2, HostBinding, Injector, NgZone, ComponentFactoryResolver, Inject, ContentChild, ChangeDetectorRef, IterableDiffers, PLATFORM_ID, defineInjectable, LOCALE_ID, Self, Attribute } from '@angular/core';
import { CommonModule, DOCUMENT, isPlatformBrowser, FormatWidth, FormStyle, getLocaleDateFormat, getLocaleDayNames, getLocaleFirstDayOfWeek, getLocaleMonthNames, TranslationWidth, NgForOf } from '@angular/common';
import { __extends, __assign, __values, __spread, __read } from 'tslib';
import { Subject, BehaviorSubject, of, combineLatest, isObservable } from 'rxjs';
import { animate, keyframes, style, transition, trigger, state } from '@angular/animations';
import { NgControl, FormsModule, SelectMultipleControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { first, filter, switchMap, map } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrIconCustomTag = /** @class */ (function () {
    function ClrIconCustomTag() {
    }
    ClrIconCustomTag.decorators = [
        { type: Directive, args: [{ selector: 'clr-icon' },] }
    ];
    return ClrIconCustomTag;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_ICON_DIRECTIVES = [ClrIconCustomTag];
var ClrIconModule = /** @class */ (function () {
    function ClrIconModule() {
    }
    ClrIconModule.decorators = [
        { type: NgModule, args: [{ imports: [CommonModule], declarations: [CLR_ICON_DIRECTIVES], exports: [CLR_ICON_DIRECTIVES] },] }
    ];
    return ClrIconModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
var Point = {
    RIGHT_CENTER: 0,
    RIGHT_TOP: 1,
    RIGHT_BOTTOM: 2,
    TOP_CENTER: 3,
    TOP_RIGHT: 4,
    TOP_LEFT: 5,
    BOTTOM_CENTER: 6,
    BOTTOM_RIGHT: 7,
    BOTTOM_LEFT: 8,
    LEFT_CENTER: 9,
    LEFT_TOP: 10,
    LEFT_BOTTOM: 11,
};
Point[Point.RIGHT_CENTER] = 'RIGHT_CENTER';
Point[Point.RIGHT_TOP] = 'RIGHT_TOP';
Point[Point.RIGHT_BOTTOM] = 'RIGHT_BOTTOM';
Point[Point.TOP_CENTER] = 'TOP_CENTER';
Point[Point.TOP_RIGHT] = 'TOP_RIGHT';
Point[Point.TOP_LEFT] = 'TOP_LEFT';
Point[Point.BOTTOM_CENTER] = 'BOTTOM_CENTER';
Point[Point.BOTTOM_RIGHT] = 'BOTTOM_RIGHT';
Point[Point.BOTTOM_LEFT] = 'BOTTOM_LEFT';
Point[Point.LEFT_CENTER] = 'LEFT_CENTER';
Point[Point.LEFT_TOP] = 'LEFT_TOP';
Point[Point.LEFT_BOTTOM] = 'LEFT_BOTTOM';
/** @type {?} */
var POSITION_RELATIVE = 'relative';
/** @type {?} */
var POSITION_ABSOLUTE = 'absolute';
/** @type {?} */
var POSITION_FIXED = 'fixed';
/** @type {?} */
var OVERFLOW_SCROLL = 'scroll';
/** @type {?} */
var OVERFLOW_AUTO = 'auto';
var Popover = /** @class */ (function () {
    function Popover(element) {
        this.element = element;
        /*
             * Containers up to the first positioned one will have an event on scroll
             */
        this.scrollableElements = [];
        this.boundOnScrollListener = this.emitScrollEvent.bind(this);
        // Browsers don't agree with what to do if some of these are not specified, so we set them all to be safe.
        element.style.position = POSITION_ABSOLUTE;
        element.style.top = 0;
        element.style.bottom = 'auto';
        element.style.left = 0;
        element.style.right = 'auto';
    }
    // TODO: need a way to account for parameters that change dynamically (positioning).
    // TODO: need a way to account for parameters that change dynamically (positioning).
    /**
     * @param {?} anchor
     * @param {?} anchorAlign
     * @param {?} popoverAlign
     * @param {?=} __3
     * @return {?}
     */
    Popover.prototype.anchor = 
    // TODO: need a way to account for parameters that change dynamically (positioning).
    /**
     * @param {?} anchor
     * @param {?} anchorAlign
     * @param {?} popoverAlign
     * @param {?=} __3
     * @return {?}
     */
    function (anchor, anchorAlign, popoverAlign, _a) {
        // TODO: we are assuming here that the popover is inside or next to the anchor.
        // We'd need to go up the popover tree too otherwise
        var _b = _a === void 0 ? {} : _a, _c = _b.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _b.offsetY, offsetY = _d === void 0 ? 0 : _d, _e = _b.useAnchorParent, useAnchorParent = _e === void 0 ? false : _e;
        this.addScrollEventListeners(anchor);
        if (useAnchorParent) {
            anchor = anchor.parentNode;
        }
        // explicitly override anchor's style to static
        anchor.style.position = 'static';
        /** @type {?} */
        var anchorRect = anchor.getBoundingClientRect();
        /** @type {?} */
        var popoverRect = this.element.getBoundingClientRect();
        // position of left top corner of anchor + the offset
        /** @type {?} */
        var leftDiff = anchorRect.left - popoverRect.left + offsetX;
        /** @type {?} */
        var topDiff = anchorRect.top - popoverRect.top + offsetY;
        // first, adjust positioning based on anchor's align point
        switch (anchorAlign) {
            case Point.LEFT_TOP:
            case Point.TOP_LEFT:
                break;
            case Point.TOP_CENTER:
                leftDiff += anchorRect.width / 2;
                break;
            case Point.TOP_RIGHT:
                leftDiff += anchorRect.width;
                break;
            case Point.RIGHT_TOP:
                leftDiff += anchorRect.width;
                break;
            case Point.LEFT_BOTTOM:
                topDiff += anchorRect.height;
                break;
            case Point.BOTTOM_LEFT:
                topDiff += anchorRect.height;
                break;
            case Point.BOTTOM_CENTER:
                topDiff += anchorRect.height;
                leftDiff += anchorRect.width / 2;
                break;
            case Point.BOTTOM_RIGHT:
                topDiff += anchorRect.height;
                leftDiff += anchorRect.width;
                break;
            case Point.RIGHT_BOTTOM:
                topDiff += anchorRect.height;
                leftDiff += anchorRect.width;
                break;
            case Point.LEFT_CENTER:
                topDiff += anchorRect.height / 2;
                break;
            case Point.RIGHT_CENTER:
                topDiff += anchorRect.height / 2;
                leftDiff += anchorRect.width;
                break;
            default:
        }
        // second, adjust positioning based on popover's align point
        switch (popoverAlign) {
            case Point.LEFT_TOP:
            case Point.TOP_LEFT:
                break;
            case Point.TOP_CENTER:
                leftDiff -= popoverRect.width / 2;
                break;
            case Point.TOP_RIGHT:
                leftDiff -= popoverRect.width;
                break;
            case Point.RIGHT_TOP:
                leftDiff -= popoverRect.width;
                break;
            case Point.LEFT_BOTTOM:
                topDiff -= popoverRect.height;
                break;
            case Point.BOTTOM_LEFT:
                topDiff -= popoverRect.height;
                break;
            case Point.BOTTOM_CENTER:
                topDiff -= popoverRect.height;
                leftDiff -= popoverRect.width / 2;
                break;
            case Point.BOTTOM_RIGHT:
                topDiff -= popoverRect.height;
                leftDiff -= popoverRect.width;
                break;
            case Point.RIGHT_BOTTOM:
                topDiff -= popoverRect.height;
                leftDiff -= popoverRect.width;
                break;
            case Point.LEFT_CENTER:
                topDiff -= popoverRect.height / 2;
                break;
            case Point.RIGHT_CENTER:
                topDiff -= popoverRect.height / 2;
                leftDiff -= popoverRect.width;
                break;
            default:
        }
        // Third, adjust with popover's margins based on the two align points.
        // Here, we make an assumption that popover is primarily positioned outside the
        // anchor with minor offset. Without this assumption, it's impossible to apply
        // the popover's margins in a predictable way. For example, assume that a popover
        // and its anchor are exactly the same size. if a popover is positioned inside the
        // anchor (which is technically possible), then it becomes impossible to know what to do
        // if the popover has a non-zero margin value all around (because applying the margin in
        // all four directions will result in no margin visually, which isn't what we want).
        // Therefore, our logic makes assumptions about margins of interest given the points,
        // and only covers the cases where popover is outside the anchor.
        /** @type {?} */
        var popoverComputedStyle = getComputedStyle(this.element);
        /** @type {?} */
        var marginLeft = parseInt(popoverComputedStyle.marginLeft, 10);
        /** @type {?} */
        var marginRight = parseInt(popoverComputedStyle.marginRight, 10);
        /** @type {?} */
        var marginTop = parseInt(popoverComputedStyle.marginTop, 10);
        /** @type {?} */
        var marginBottom = parseInt(popoverComputedStyle.marginBottom, 10);
        switch (anchorAlign) {
            case Point.LEFT_TOP:
            case Point.TOP_LEFT:
            case Point.TOP_RIGHT:
            case Point.RIGHT_TOP:
                if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                    topDiff -= marginBottom;
                    leftDiff -= marginRight;
                }
                if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                    topDiff -= marginTop;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                    topDiff += marginTop;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                    topDiff += marginTop;
                    leftDiff -= marginRight;
                }
                break;
            case Point.LEFT_BOTTOM:
            case Point.BOTTOM_LEFT:
            case Point.BOTTOM_RIGHT:
            case Point.RIGHT_BOTTOM:
                if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
                    topDiff -= marginBottom;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
                    topDiff -= marginBottom;
                    leftDiff -= marginRight;
                }
                if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
                    topDiff += marginTop;
                    leftDiff += marginLeft;
                }
                if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
                    topDiff += marginTop;
                    leftDiff -= marginRight;
                }
                break;
            case Point.TOP_CENTER:
                topDiff -= marginBottom;
                leftDiff += marginLeft;
                leftDiff -= marginRight;
                break;
            case Point.BOTTOM_CENTER:
                topDiff += marginTop;
                leftDiff += marginLeft;
                leftDiff -= marginRight;
                break;
            case Point.LEFT_CENTER:
                topDiff += marginTop;
                topDiff -= marginBottom;
                leftDiff -= marginRight;
                break;
            case Point.RIGHT_CENTER:
                topDiff += marginTop;
                topDiff -= marginBottom;
                leftDiff += marginLeft;
                break;
            default:
        }
        this.element.style.transform = "translateX(" + Math.round(leftDiff) + "px) translateY(" + Math.round(topDiff) + "px)";
        return this._scroll.asObservable();
    };
    /**
     * @return {?}
     */
    Popover.prototype.release = /**
     * @return {?}
     */
    function () {
        this.element.style.transform = '';
        this.removeScrollEventListeners();
    };
    /**
     * @param {?} container
     * @return {?}
     */
    Popover.prototype.isPositioned = /**
     * @param {?} container
     * @return {?}
     */
    function (container) {
        /** @type {?} */
        var position = getComputedStyle(container).position;
        return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
    };
    /**
     * @return {?}
     */
    Popover.prototype.emitScrollEvent = /**
     * @return {?}
     */
    function () {
        this._scroll.next();
    };
    /**
     * @param {?} e
     * @return {?}
     */
    Popover.prototype.addScrollEventListeners = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this._scroll = new Subject();
        /** @type {?} */
        var anchor = e;
        /** @type {?} */
        var current = e;
        while (current && current !== document) {
            if (this.scrolls(current)) {
                current.addEventListener('scroll', this.boundOnScrollListener);
                this.scrollableElements.push(current);
            }
            if (current !== anchor && this.isPositioned(current)) {
                break;
            }
            current = current.parentNode;
        }
    };
    /**
     * @return {?}
     */
    Popover.prototype.removeScrollEventListeners = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.scrollableElements), _c = _b.next(); !_c.done; _c = _b.next()) {
                var elem = _c.value;
                elem.removeEventListener('scroll', this.boundOnScrollListener);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.scrollableElements.length = 0;
        if (this._scroll) {
            this._scroll.complete();
            delete this._scroll;
        }
    };
    /**
     * @param {?} container
     * @return {?}
     */
    Popover.prototype.scrolls = /**
     * @param {?} container
     * @return {?}
     */
    function (container) {
        /** @type {?} */
        var computedStyles = getComputedStyle(container);
        return (computedStyles.overflowX === OVERFLOW_SCROLL ||
            computedStyles.overflowX === OVERFLOW_AUTO ||
            computedStyles.overflowY === OVERFLOW_SCROLL ||
            computedStyles.overflowY === OVERFLOW_AUTO);
    };
    return Popover;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var openCount = 0;
/** @type {?} */
var waiting = [];
// pending create functions
var PopoverDirectiveOld = /** @class */ (function () {
    function PopoverDirectiveOld(templateRef, viewContainer) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.popoverOptions = {};
        this.clrPopoverOldChange = new EventEmitter(false);
    }
    Object.defineProperty(PopoverDirectiveOld.prototype, "clrPopoverOld", {
        set: /**
         * @param {?} open
         * @return {?}
         */
        function (open) {
            var _this = this;
            if (open) {
                if (this.popoverOptions.allowMultipleOpen) {
                    this.createPopover();
                }
                else {
                    if (openCount === 0) {
                        this.createPopover();
                    }
                    else {
                        waiting.push(function () {
                            _this.createPopover();
                        });
                    }
                }
            }
            else {
                this.viewContainer.clear();
                this.destroyPopover();
                if (!this.popoverOptions.allowMultipleOpen) {
                    if (waiting.length > 0) {
                        /** @type {?} */
                        var createPopoverFn = waiting.shift();
                        createPopoverFn();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PopoverDirectiveOld.prototype.createPopover = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var embeddedViewRef = (/** @type {?} */ (this.viewContainer.createEmbeddedView(this.templateRef)));
        // TODO: Not sure of the risks associated with using this. Find an alternative.
        // Needed for find the correct height and width of dynamically created views
        // inside of the popover. For Eg: Button Groups
        embeddedViewRef.detectChanges();
        // filter out other nodes in the view ref so we are only left with element nodes
        /** @type {?} */
        var elementNodes = embeddedViewRef.rootNodes.filter(function (node) {
            return node.nodeType === 1;
        });
        // we take the first element node in the embedded view; usually there should only be one anyways
        this._popoverInstance = new Popover(elementNodes[0]);
        this._subscription = this._popoverInstance
            .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
            .subscribe(function () {
            _this.clrPopoverOldChange.emit(false);
        });
        openCount++;
    };
    /**
     * @return {?}
     */
    PopoverDirectiveOld.prototype.destroyPopover = /**
     * @return {?}
     */
    function () {
        if (this._popoverInstance) {
            this._subscription.unsubscribe();
            this._popoverInstance.release();
            delete this._popoverInstance;
            openCount--;
        }
    };
    /**
     * @return {?}
     */
    PopoverDirectiveOld.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyPopover();
    };
    PopoverDirectiveOld.decorators = [
        { type: Directive, args: [{ selector: '[clrPopoverOld]' },] }
    ];
    /** @nocollapse */
    PopoverDirectiveOld.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    PopoverDirectiveOld.propDecorators = {
        anchorElem: [{ type: Input, args: ['clrPopoverOldAnchor',] }],
        anchorPoint: [{ type: Input, args: ['clrPopoverOldAnchorPoint',] }],
        popoverPoint: [{ type: Input, args: ['clrPopoverOldPopoverPoint',] }],
        popoverOptions: [{ type: Input, args: ['clrPopoverOldOptions',] }],
        clrPopoverOldChange: [{ type: Output, args: ['clrPopoverOldChange',] }],
        clrPopoverOld: [{ type: Input }]
    };
    return PopoverDirectiveOld;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var POPOVER_DIRECTIVES = [PopoverDirectiveOld];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrCommonPopoverModule = /** @class */ (function () {
    function ClrCommonPopoverModule() {
    }
    ClrCommonPopoverModule.decorators = [
        { type: NgModule, args: [{ imports: [CommonModule], declarations: [POPOVER_DIRECTIVES], exports: [POPOVER_DIRECTIVES] },] }
    ];
    return ClrCommonPopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
 * This does not mean you should extend it, simply implementing it is fine.
 * @abstract
 */
var  /**
 * This is an abstract class because we need it to still be a valid token for dependency injection after transpiling.
 * This does not mean you should extend it, simply implementing it is fine.
 * @abstract
 */
LoadingListener = /** @class */ (function () {
    function LoadingListener() {
    }
    return LoadingListener;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
var ClrLoadingState = {
    DEFAULT: 0,
    LOADING: 1,
    SUCCESS: 2,
    ERROR: 3,
};
ClrLoadingState[ClrLoadingState.DEFAULT] = 'DEFAULT';
ClrLoadingState[ClrLoadingState.LOADING] = 'LOADING';
ClrLoadingState[ClrLoadingState.SUCCESS] = 'SUCCESS';
ClrLoadingState[ClrLoadingState.ERROR] = 'ERROR';
var ClrLoading = /** @class */ (function () {
    // We find the first parent that handles something loading
    function ClrLoading(listener) {
        this.listener = listener;
        this._loadingState = ClrLoadingState.DEFAULT;
    }
    Object.defineProperty(ClrLoading.prototype, "loadingState", {
        get: /**
         * @return {?}
         */
        function () {
            return this._loadingState;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === true) {
                value = ClrLoadingState.LOADING;
            }
            else if (!value) {
                value = ClrLoadingState.DEFAULT;
            }
            if (value === this._loadingState) {
                return;
            }
            this._loadingState = value;
            if (this.listener) {
                this.listener.loadingStateChange(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrLoading.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.loadingState = ClrLoadingState.DEFAULT;
    };
    ClrLoading.decorators = [
        { type: Directive, args: [{ selector: '[clrLoading]' },] }
    ];
    /** @nocollapse */
    ClrLoading.ctorParameters = function () { return [
        { type: LoadingListener, decorators: [{ type: Optional }] }
    ]; };
    ClrLoading.propDecorators = {
        loadingState: [{ type: Input, args: ['clrLoading',] }]
    };
    return ClrLoading;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ButtonInGroupService = /** @class */ (function () {
    function ButtonInGroupService() {
        this._changes = new Subject();
    }
    Object.defineProperty(ButtonInGroupService.prototype, "changes", {
        get: /**
         * @return {?}
         */
        function () {
            return this._changes.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} button
     * @return {?}
     */
    ButtonInGroupService.prototype.updateButtonGroup = /**
     * @param {?} button
     * @return {?}
     */
    function (button) {
        this._changes.next(button);
    };
    ButtonInGroupService.decorators = [
        { type: Injectable }
    ];
    return ButtonInGroupService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrButton = /** @class */ (function () {
    function ClrButton(buttonInGroupService) {
        this.buttonInGroupService = buttonInGroupService;
        this._enableService = false;
        this._inMenu = false;
        this._classNames = 'btn';
        this._name = null;
        this._type = null;
        this._id = null;
        this._disabled = null;
        this._click = new EventEmitter(false);
    }
    Object.defineProperty(ClrButton.prototype, "inMenu", {
        get: /**
         * @return {?}
         */
        function () {
            return this._inMenu;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = !!value;
            if (this._inMenu !== value) {
                this._inMenu = value;
                // We check if the service flag is enabled
                // and if the service exists because the service is optional
                if (this._enableService && this.buttonInGroupService) {
                    this.buttonInGroupService.updateButtonGroup(this);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrButton.prototype, "classNames", {
        get: /**
         * @return {?}
         */
        function () {
            return this._classNames;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                /** @type {?} */
                var classNames = value.split(' ');
                if (classNames.indexOf('btn') === -1) {
                    classNames.push('btn');
                }
                this._classNames = classNames.join(' ');
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrButton.prototype, "name", {
        get: /**
         * @return {?}
         */
        function () {
            return this._name;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                this._name = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrButton.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this._type;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                this._type = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrButton.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                this._id = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrButton.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== null && value !== false) {
                this._disabled = '';
            }
            else {
                this._disabled = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} state
     * @return {?}
     */
    ClrButton.prototype.loadingStateChange = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        this.loading = state$$1 === ClrLoadingState.LOADING;
    };
    /**
     * @return {?}
     */
    ClrButton.prototype.emitClick = /**
     * @return {?}
     */
    function () {
        this._click.emit(true);
    };
    /**
     * @return {?}
     */
    ClrButton.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._enableService = true;
    };
    ClrButton.decorators = [
        { type: Component, args: [{
                    selector: 'clr-button',
                    template: "\n        <ng-template #buttonProjectedRef>\n            <button \n                [class]=\"classNames\" \n                (click)=\"emitClick()\"\n                [attr.type]=\"type\"\n                [attr.name]=\"name\"\n                [attr.disabled]=\"disabled\"\n                [id]=\"id\">\n                <span class=\"spinner spinner-inline\" *ngIf=\"loading\"></span>\n                <ng-content></ng-content>\n            </button>\n        </ng-template>\n    ",
                    providers: [{ provide: LoadingListener, useExisting: ClrButton }]
                }] }
    ];
    /** @nocollapse */
    ClrButton.ctorParameters = function () { return [
        { type: ButtonInGroupService, decorators: [{ type: SkipSelf }, { type: Optional }] }
    ]; };
    ClrButton.propDecorators = {
        templateRef: [{ type: ViewChild, args: ['buttonProjectedRef',] }],
        inMenu: [{ type: Input, args: ['clrInMenu',] }],
        classNames: [{ type: Input, args: ['class',] }],
        name: [{ type: Input, args: ['name',] }],
        type: [{ type: Input, args: ['type',] }],
        id: [{ type: Input, args: ['id',] }],
        disabled: [{ type: Input, args: ['disabled',] }],
        _click: [{ type: Output, args: ['click',] }]
    };
    return ClrButton;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @type {?} */
var CLR_MENU_POSITIONS = [
    'bottom-left',
    'bottom-right',
    'top-left',
    'top-right',
    'left-bottom',
    'left-top',
    'right-bottom',
    'right-top',
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// @TODO Put the Required type back in when our minimumly supported version of Angular uses
// TS 2.8 or greater (should be Angular 7)
// export class ClrCommonStringsService implements Required<ClrCommonStrings> {
var 
// @TODO Put the Required type back in when our minimumly supported version of Angular uses
// TS 2.8 or greater (should be Angular 7)
// export class ClrCommonStringsService implements Required<ClrCommonStrings> {
ClrCommonStringsService = /** @class */ (function () {
    function ClrCommonStringsService() {
        this.open = 'Open';
        this.close = 'Close';
        this.show = 'Show';
        this.hide = 'Hide';
        this.expand = 'Expand';
        this.collapse = 'Collapse';
        this.more = 'More';
        this.select = 'Select';
        this.selectAll = 'Select All';
        this.previous = 'Previous';
        this.next = 'Next';
        this.current = 'Jump to current';
        this.info = 'Info';
        this.success = 'Success';
        this.warning = 'Warning';
        this.danger = 'Error';
        this.rowActions = 'Available actions';
        this.pickColumns = 'Show or hide columns';
    }
    return ClrCommonStringsService;
}());
/**
 * @param {?=} existing
 * @return {?}
 */
function commonStringsFactory(existing) {
    /** @type {?} */
    var defaults = new ClrCommonStringsService();
    if (existing) {
        return __assign({}, defaults, existing);
    }
    return defaults;
}
/** @type {?} */
var COMMON_STRINGS_PROVIDER = {
    useFactory: commonStringsFactory,
    // We have a circular dependency for now, we can address it later once these
    // tree-shakeable providers have proper documentation.
    deps: [[new Optional(), new SkipSelf(), forwardRef(function () { return ClrCommonStrings; })]],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var ClrCommonStrings = /** @class */ (function () {
    function ClrCommonStrings() {
    }
    ClrCommonStrings.decorators = [
        { type: Injectable, args: [__assign({ providedIn: 'root' }, COMMON_STRINGS_PROVIDER),] }
    ];
    /** @nocollapse */ ClrCommonStrings.ngInjectableDef = defineInjectable({ factory: function ClrCommonStrings_Factory() { return new ClrCommonStrings(); }, token: ClrCommonStrings, providedIn: "root" });
    return ClrCommonStrings;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrButtonGroup = /** @class */ (function () {
    function ClrButtonGroup(buttonGroupNewService, elementRef, commonStrings) {
        this.buttonGroupNewService = buttonGroupNewService;
        this.elementRef = elementRef;
        this.commonStrings = commonStrings;
        this.inlineButtons = [];
        this.menuButtons = [];
        this._openMenu = false;
        this.anchorPoint = Point.BOTTOM_LEFT; // default if menuPosition isn't set
        // default if menuPosition isn't set
        this.popoverPoint = Point.LEFT_TOP; // default if menuPosition isn't set
        /**
         * Flag with indicates if the overflow menu toggle was clicked.
         * If true, this can save us traversing the DOM to find
         * whether the click was withing the button group toggle
         * or menu in the onMouseClick method
         */
        this._overflowMenuToggleClicked = false;
    }
    /**
     * 1. Initializes the initial Button Group View
     * 2. Subscribes to changes on the ContentChildren
     *    in case the user content projection changes
     */
    /**
     * 1. Initializes the initial Button Group View
     * 2. Subscribes to changes on the ContentChildren
     *    in case the user content projection changes
     * @return {?}
     */
    ClrButtonGroup.prototype.ngAfterContentInit = /**
     * 1. Initializes the initial Button Group View
     * 2. Subscribes to changes on the ContentChildren
     *    in case the user content projection changes
     * @return {?}
     */
    function () {
        var _this = this;
        this.initializeButtons();
        this.buttonGroupNewService.changes.subscribe(function (button) { return _this.rearrangeButton(button); });
        this.buttons.changes.subscribe(function () {
            _this.initializeButtons();
        });
    };
    /**
     * Moves the button into the other ViewContainer
     * when an update is received.
     *
     * @param button
     */
    /**
     * Moves the button into the other ViewContainer
     * when an update is received.
     *
     * @param {?} button
     * @return {?}
     */
    ClrButtonGroup.prototype.rearrangeButton = /**
     * Moves the button into the other ViewContainer
     * when an update is received.
     *
     * @param {?} button
     * @return {?}
     */
    function (button) {
        /** @type {?} */
        var fromView;
        /** @type {?} */
        var toView;
        if (button.inMenu) {
            fromView = this.inlineButtons;
            toView = this.menuButtons;
        }
        else {
            fromView = this.menuButtons;
            toView = this.inlineButtons;
        }
        /** @type {?} */
        var index = fromView.indexOf(button);
        if (index > -1) {
            fromView.splice(index, 1);
            /** @type {?} */
            var moveIndex = this.getMoveIndex(button);
            if (moveIndex <= toView.length) {
                toView.splice(moveIndex, 0, button);
            }
        }
    };
    /**
     * Author: Eudes
     *
     * Finds the order of a button w.r.t other buttons
     *
     * @param buttonToMove
     * @returns
     */
    /**
     * Author: Eudes
     *
     * Finds the order of a button w.r.t other buttons
     *
     * @param {?} buttonToMove
     * @return {?}
     */
    ClrButtonGroup.prototype.getMoveIndex = /**
     * Author: Eudes
     *
     * Finds the order of a button w.r.t other buttons
     *
     * @param {?} buttonToMove
     * @return {?}
     */
    function (buttonToMove) {
        /** @type {?} */
        var tempArr = this.buttons.filter(function (button) { return button.inMenu === buttonToMove.inMenu; });
        return tempArr.indexOf(buttonToMove);
    };
    /**
     * @return {?}
     */
    ClrButtonGroup.prototype.initializeButtons = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var tempInlineButtons = [];
        /** @type {?} */
        var tempInMenuButtons = [];
        this.buttons.forEach(function (button) {
            if (button.inMenu) {
                tempInMenuButtons.push(button);
            }
            else {
                tempInlineButtons.push(button);
            }
        });
        this.inlineButtons = tempInlineButtons;
        this.menuButtons = tempInMenuButtons;
    };
    Object.defineProperty(ClrButtonGroup.prototype, "menuPosition", {
        get: /**
         * @return {?}
         */
        function () {
            return this._menuPosition;
        },
        set: /**
         * @param {?} pos
         * @return {?}
         */
        function (pos) {
            if (pos && CLR_MENU_POSITIONS.indexOf(pos) > -1) {
                this._menuPosition = pos;
            }
            else {
                this._menuPosition = 'bottom-left';
            }
            // set the popover values based on menu position
            switch (this._menuPosition) {
                case 'top-right':
                    this.anchorPoint = Point.TOP_RIGHT;
                    this.popoverPoint = Point.RIGHT_BOTTOM;
                    break;
                case 'top-left':
                    this.anchorPoint = Point.TOP_LEFT;
                    this.popoverPoint = Point.LEFT_BOTTOM;
                    break;
                case 'bottom-right':
                    this.anchorPoint = Point.BOTTOM_RIGHT;
                    this.popoverPoint = Point.RIGHT_TOP;
                    break;
                case 'bottom-left':
                    this.anchorPoint = Point.BOTTOM_LEFT;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
                case 'right-top':
                    this.anchorPoint = Point.RIGHT_TOP;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
                case 'right-bottom':
                    this.anchorPoint = Point.RIGHT_BOTTOM;
                    this.popoverPoint = Point.LEFT_BOTTOM;
                    break;
                case 'left-top':
                    this.anchorPoint = Point.LEFT_TOP;
                    this.popoverPoint = Point.RIGHT_TOP;
                    break;
                case 'left-bottom':
                    this.anchorPoint = Point.LEFT_BOTTOM;
                    this.popoverPoint = Point.RIGHT_BOTTOM;
                    break;
                default:
                    this.anchorPoint = Point.BOTTOM_LEFT;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrButtonGroup.prototype, "openMenu", {
        get: /**
         * @return {?}
         */
        function () {
            return this._openMenu;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._openMenu = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
     * clicked. Also set a flag that indicates that the toggle
     * was clicked so that we don't traverse the DOM to find the
     * location of the click.
     */
    // default if menuPosition isn't set
    /**
     * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
     * clicked. Also set a flag that indicates that the toggle
     * was clicked so that we don't traverse the DOM to find the
     * location of the click.
     * @return {?}
     */
    ClrButtonGroup.prototype.toggleMenu = 
    // default if menuPosition isn't set
    /**
     * Toggle the ClrDropdown Menu when the ClrDropdown Toggle is
     * clicked. Also set a flag that indicates that the toggle
     * was clicked so that we don't traverse the DOM to find the
     * location of the click.
     * @return {?}
     */
    function () {
        this.openMenu = !this.openMenu;
        this._overflowMenuToggleClicked = true;
    };
    // TODO: Generic Directive to handle this
    /**
     * Called on mouse clicks anywhere in the DOM.
     * Checks to see if the mouseclick happened on the host or outside
     */
    // TODO: Generic Directive to handle this
    /**
     * Called on mouse clicks anywhere in the DOM.
     * Checks to see if the mouseclick happened on the host or outside
     * @param {?} target
     * @return {?}
     */
    ClrButtonGroup.prototype.onMouseClick = 
    // TODO: Generic Directive to handle this
    /**
     * Called on mouse clicks anywhere in the DOM.
     * Checks to see if the mouseclick happened on the host or outside
     * @param {?} target
     * @return {?}
     */
    function (target) {
        if (this.openMenu && !this._overflowMenuToggleClicked) {
            // Reset the overflow menu toggle clicked flag
            this._overflowMenuToggleClicked = false;
            /** @type {?} */
            var current = target;
            // Get the element in the DOM on which the mouse was clicked
            /** @type {?} */
            var host = this.elementRef.nativeElement;
            if (current.classList.contains('dropdown-menu')) {
                current = current.parentNode;
                while (current) {
                    if (current === document) {
                        this.openMenu = false;
                        return;
                    }
                    // If clicked on dropdown menu and menu is in host
                    // do nothing
                    if (current === host) {
                        return;
                    }
                    current = current.parentNode;
                }
            }
            this.openMenu = false;
        }
        this._overflowMenuToggleClicked = false; // Reset the overflow menu toggle clicked flag
    };
    ClrButtonGroup.decorators = [
        { type: Component, args: [{
                    selector: 'clr-button-group',
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-container *ngFor=\"let inlineButton of inlineButtons\">\n    <ng-template [ngTemplateOutlet]=\"inlineButton.templateRef\"></ng-template>\n</ng-container>\n<ng-container *ngIf=\"menuButtons.length > 0\">\n    <div\n        class=\"btn-group-overflow open\"\n        [ngClass]=\"menuPosition\"\n        #anchor>\n        <button\n            class=\"btn dropdown-toggle\"\n            (click)=\"toggleMenu()\">\n            <clr-icon shape=\"ellipsis-horizontal\" [attr.title]=\"commonStrings.more\"></clr-icon>\n        </button>\n        <div\n            class=\"dropdown-menu\"\n            *clrPopoverOld=\"openMenu; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint;\">\n            <ng-template [ngTemplateOutlet]=\"ref\"></ng-template>\n        </div>\n    </div>\n</ng-container>\n<ng-template #ref>\n    <ng-container *ngFor=\"let menuButton of menuButtons\">\n        <ng-template [ngTemplateOutlet]=\"menuButton.templateRef\"></ng-template>\n    </ng-container>\n</ng-template>\n",
                    providers: [ButtonInGroupService],
                    host: { '[class.btn-group]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrButtonGroup.ctorParameters = function () { return [
        { type: ButtonInGroupService },
        { type: ElementRef },
        { type: ClrCommonStrings }
    ]; };
    ClrButtonGroup.propDecorators = {
        buttons: [{ type: ContentChildren, args: [ClrButton,] }],
        menuPosition: [{ type: Input, args: ['clrMenuPosition',] }],
        onMouseClick: [{ type: HostListener, args: ['document:click', ['$event.target'],] }]
    };
    return ClrButtonGroup;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_BUTTON_GROUP_DIRECTIVES = [ClrButton, ClrButtonGroup];
var ClrButtonGroupModule = /** @class */ (function () {
    function ClrButtonGroupModule() {
    }
    ClrButtonGroupModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule, ClrCommonPopoverModule],
                    declarations: [CLR_BUTTON_GROUP_DIRECTIVES],
                    exports: [CLR_BUTTON_GROUP_DIRECTIVES],
                },] }
    ];
    return ClrButtonGroupModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrLoadingButton = /** @class */ (function () {
    function ClrLoadingButton(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.buttonState = ClrLoadingState;
        this.state = ClrLoadingState.DEFAULT;
        this.clrLoadingChange = new EventEmitter(false);
    }
    /**
     * @param {?} state
     * @return {?}
     */
    ClrLoadingButton.prototype.loadingStateChange = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        if (state$$1 === this.state) {
            return;
        }
        this.state = state$$1;
        switch (state$$1) {
            case ClrLoadingState.DEFAULT:
                this.renderer.removeStyle(this.el.nativeElement, 'width');
                this.renderer.removeStyle(this.el.nativeElement, 'transform'); // for chromium render bug see issue https://github.com/vmware/clarity/issues/2700
                if (!this.disabled) {
                    this.renderer.removeAttribute(this.el.nativeElement, 'disabled');
                }
                break;
            case ClrLoadingState.LOADING:
                this.setExplicitButtonWidth();
                this.renderer.setStyle(this.el.nativeElement, 'transform', 'translatez(0)'); // for chromium render bug see issue https://github.com/vmware/clarity/issues/2700
                this.renderer.setAttribute(this.el.nativeElement, 'disabled', '');
                break;
            case ClrLoadingState.SUCCESS:
                this.setExplicitButtonWidth();
                break;
            case ClrLoadingState.ERROR:
                this.loadingStateChange(ClrLoadingState.DEFAULT);
                break;
            default:
                break;
        }
        this.clrLoadingChange.emit(state$$1);
    };
    /**
     * @return {?}
     */
    ClrLoadingButton.prototype.setExplicitButtonWidth = /**
     * @return {?}
     */
    function () {
        if (this.el.nativeElement && this.el.nativeElement.getBoundingClientRect) {
            /** @type {?} */
            var boundingClientRect = this.el.nativeElement.getBoundingClientRect();
            this.renderer.setStyle(this.el.nativeElement, 'width', boundingClientRect.width + "px");
        }
    };
    ClrLoadingButton.decorators = [
        { type: Component, args: [{
                    selector: 'button[clrLoading]',
                    template: "\n        <ng-container [ngSwitch]=\"state\">\n            <span *ngSwitchCase=\"buttonState.LOADING\">\n                <span @spinner class=\"spinner spinner-inline\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.SUCCESS\">\n                <span @validated (@validated.done)=\"this.loadingStateChange(this.buttonState.DEFAULT)\" class=\"spinner spinner-inline spinner-check\"></span>\n            </span>\n            <span *ngSwitchCase=\"buttonState.DEFAULT\" @defaultButton>\n                <ng-content></ng-content>\n            </span>\n        </ng-container>\n    ",
                    providers: [{ provide: LoadingListener, useExisting: ClrLoadingButton }],
                    animations: [
                        trigger('defaultButton', [
                            transition(':enter', [style({ opacity: 0 }), animate('200ms 100ms ease-in', style({ opacity: 1 }))]),
                            // TODO: see if we can get leave animation to work before spinner's enter animation
                            transition(':leave', [style({ opacity: 0 })]),
                        ]),
                        trigger('spinner', [
                            transition(':enter', [style({ opacity: 0 }), animate('200ms 100ms ease-in', style({ opacity: 1 }))]),
                            transition(':leave', [style({ opacity: 1 }), animate('100ms ease-out', style({ opacity: 0 }))]),
                        ]),
                        trigger('validated', [
                            transition(':enter', [
                                animate('600ms', keyframes([
                                    style({ transform: 'scale(0,0)', offset: 0 }),
                                    style({ opacity: 1, offset: 0.2 }),
                                    style({ transform: 'scale(1.2,1.2)', offset: 0.4 }),
                                    style({ transform: 'scale(.9,.9)', offset: 0.6 }),
                                    style({ transform: 'scale(1,1)', offset: 1 }),
                                ])),
                            ]),
                            transition(':leave', [style({ opacity: 1 }), animate('100ms ease-out', style({ opacity: 0 }))]),
                        ]),
                    ],
                    host: { '[attr.disabled]': "disabled? '' : null" }
                }] }
    ];
    /** @nocollapse */
    ClrLoadingButton.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    ClrLoadingButton.propDecorators = {
        disabled: [{ type: Input, args: ['disabled',] }],
        clrLoadingChange: [{ type: Output, args: ['clrLoadingChange',] }]
    };
    return ClrLoadingButton;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_LOADING_BUTTON_DIRECTIVES = [ClrLoadingButton];
var ClrLoadingButtonModule = /** @class */ (function () {
    function ClrLoadingButtonModule() {
    }
    ClrLoadingButtonModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [CLR_LOADING_BUTTON_DIRECTIVES],
                    exports: [CLR_LOADING_BUTTON_DIRECTIVES],
                },] }
    ];
    return ClrLoadingButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrButtonModule = /** @class */ (function () {
    function ClrButtonModule() {
    }
    ClrButtonModule.decorators = [
        { type: NgModule, args: [{
                    exports: [ClrLoadingButtonModule, ClrButtonGroupModule],
                },] }
    ];
    return ClrButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var EmptyAnchor = /** @class */ (function () {
    function EmptyAnchor() {
    }
    EmptyAnchor.decorators = [
        { type: Component, args: [{
                    template: ''
                }] }
    ];
    return EmptyAnchor;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Internal module, please do not export!
 */
var ClrHostWrappingModule = /** @class */ (function () {
    function ClrHostWrappingModule() {
    }
    ClrHostWrappingModule.decorators = [
        { type: NgModule, args: [{ declarations: [EmptyAnchor], exports: [EmptyAnchor], entryComponents: [EmptyAnchor] },] }
    ];
    return ClrHostWrappingModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrControlError = /** @class */ (function () {
    function ClrControlError() {
    }
    ClrControlError.decorators = [
        { type: Component, args: [{
                    selector: 'clr-control-error',
                    template: "\n    <ng-content></ng-content>\n    ",
                    host: { '[class.clr-subtext]': 'true' }
                }] }
    ];
    return ClrControlError;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrControlHelper = /** @class */ (function () {
    function ClrControlHelper() {
    }
    ClrControlHelper.decorators = [
        { type: Component, args: [{
                    selector: 'clr-control-helper',
                    template: "\n    <ng-content></ng-content>\n    ",
                    host: { '[class.clr-subtext]': 'true' }
                }] }
    ];
    return ClrControlHelper;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NgControlService = /** @class */ (function () {
    function NgControlService() {
        // Observable to subscribe to the control, since its not available immediately for projected content
        this._controlChanges = new Subject();
    }
    Object.defineProperty(NgControlService.prototype, "controlChanges", {
        get: /**
         * @return {?}
         */
        function () {
            return this._controlChanges.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} control
     * @return {?}
     */
    NgControlService.prototype.setControl = /**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        this._controlChanges.next(control);
    };
    NgControlService.decorators = [
        { type: Injectable }
    ];
    return NgControlService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var IfErrorService = /** @class */ (function () {
    function IfErrorService(ngControlService) {
        var _this = this;
        this.ngControlService = ngControlService;
        // Implement our own status changes observable, since Angular controls don't
        // fire on events like blur, and we want to return the boolean state instead of a string
        this._statusChanges = new Subject();
        this.subscriptions = [];
        // Wait for the control to be available
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            if (control) {
                _this.control = control;
                _this.listenForChanges();
            }
        }));
    }
    Object.defineProperty(IfErrorService.prototype, "statusChanges", {
        get: /**
         * @return {?}
         */
        function () {
            return this._statusChanges.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    // Subscribe to the status change events, only after touched and emit the control
    // Subscribe to the status change events, only after touched and emit the control
    /**
     * @return {?}
     */
    IfErrorService.prototype.listenForChanges = 
    // Subscribe to the status change events, only after touched and emit the control
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.control.statusChanges.subscribe(function () {
            _this.sendValidity();
        }));
    };
    /**
     * @return {?}
     */
    IfErrorService.prototype.sendValidity = /**
     * @return {?}
     */
    function () {
        if ((this.control.touched || this.control.dirty) && this.control.invalid) {
            this._statusChanges.next(true);
        }
        else {
            this._statusChanges.next(false);
        }
    };
    // Allows a control to push a status check upstream, such as on blur
    // Allows a control to push a status check upstream, such as on blur
    /**
     * @return {?}
     */
    IfErrorService.prototype.triggerStatusChange = 
    // Allows a control to push a status check upstream, such as on blur
    /**
     * @return {?}
     */
    function () {
        if (this.control) {
            this.sendValidity();
        }
    };
    // Clean up subscriptions
    // Clean up subscriptions
    /**
     * @return {?}
     */
    IfErrorService.prototype.ngOnDestroy = 
    // Clean up subscriptions
    /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    IfErrorService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IfErrorService.ctorParameters = function () { return [
        { type: NgControlService }
    ]; };
    return IfErrorService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrIfError = /** @class */ (function () {
    function ClrIfError(ifErrorService, ngControlService, template, container) {
        var _this = this;
        this.ifErrorService = ifErrorService;
        this.ngControlService = ngControlService;
        this.template = template;
        this.container = container;
        this.subscriptions = [];
        this.displayed = false;
        if (!this.ifErrorService) {
            throw new Error('clrIfError can only be used within a form control container element like clr-input-container');
        }
        else {
            this.displayError(false);
        }
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            _this.control = control;
        }));
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            // If there is a specific error to track, check it, otherwise check overall validity
            if (_this.error && _this.control) {
                _this.displayError(_this.control.hasError(_this.error));
            }
            else {
                _this.displayError(invalid);
            }
        }));
    }
    /**
     * @return {?}
     */
    ClrIfError.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * @param {?} invalid
     * @return {?}
     */
    ClrIfError.prototype.displayError = /**
     * @param {?} invalid
     * @return {?}
     */
    function (invalid) {
        if (invalid && !this.displayed) {
            this.container.createEmbeddedView(this.template);
            this.displayed = true;
        }
        else if (!invalid) {
            this.container.clear();
            this.displayed = false;
        }
    };
    ClrIfError.decorators = [
        { type: Directive, args: [{ selector: '[clrIfError]' },] }
    ];
    /** @nocollapse */
    ClrIfError.ctorParameters = function () { return [
        { type: IfErrorService, decorators: [{ type: Optional }] },
        { type: NgControlService, decorators: [{ type: Optional }] },
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    ClrIfError.propDecorators = {
        error: [{ type: Input, args: ['clrIfError',] }]
    };
    return ClrIfError;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var counter = 0;
var ControlIdService = /** @class */ (function () {
    function ControlIdService() {
        this._id = 'clr-form-control-' + ++counter;
        this._idChange = new BehaviorSubject(this._id);
    }
    Object.defineProperty(ControlIdService.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value;
            this._idChange.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControlIdService.prototype, "idChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._idChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    ControlIdService.decorators = [
        { type: Injectable }
    ];
    return ControlIdService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {string} */
var Layouts = {
    VERTICAL: 'vertical',
    HORIZONTAL: 'horizontal',
    COMPACT: 'compact',
};
var LayoutService = /** @class */ (function () {
    function LayoutService() {
        this.layout = Layouts.HORIZONTAL;
        // This is basically a replacement for Object.values(), which IE11 and Node <9 don't support :(
        // String enums cannot be reverse-mapped, meaning Layouts['COMPACT'] does not return 'compact' so
        // this exists to deal with this little caveat to get the list of the values as an array.
        this.layoutValues = Object.keys(Layouts).map(function (key) { return Layouts[key]; });
    }
    /**
     * @return {?}
     */
    LayoutService.prototype.isVertical = /**
     * @return {?}
     */
    function () {
        return this.layout === Layouts.VERTICAL;
    };
    /**
     * @return {?}
     */
    LayoutService.prototype.isHorizontal = /**
     * @return {?}
     */
    function () {
        return this.layout === Layouts.HORIZONTAL;
    };
    /**
     * @return {?}
     */
    LayoutService.prototype.isCompact = /**
     * @return {?}
     */
    function () {
        return this.layout === Layouts.COMPACT;
    };
    Object.defineProperty(LayoutService.prototype, "layoutClass", {
        get: /**
         * @return {?}
         */
        function () {
            return "clr-form-" + this.layout;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} layout
     * @return {?}
     */
    LayoutService.prototype.isValid = /**
     * @param {?} layout
     * @return {?}
     */
    function (layout) {
        return this.layoutValues.indexOf(layout) > -1;
    };
    LayoutService.decorators = [
        { type: Injectable }
    ];
    return LayoutService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrLabel = /** @class */ (function () {
    function ClrLabel(controlIdService, layoutService, ngControlService, renderer, el) {
        this.controlIdService = controlIdService;
        this.layoutService = layoutService;
        this.ngControlService = ngControlService;
        this.renderer = renderer;
        this.el = el;
        this.subscriptions = [];
        this.enableGrid = true;
    }
    /**
     * @return {?}
     */
    ClrLabel.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Only add the clr-control-label if it is inside a control container
        if (this.controlIdService || this.ngControlService) {
            this.renderer.addClass(this.el.nativeElement, 'clr-control-label');
        }
        // Only set the grid column classes if we are in the right context and if they aren't already set
        if (this.enableGrid &&
            this.layoutService &&
            !this.layoutService.isVertical() &&
            this.el.nativeElement &&
            this.el.nativeElement.className.indexOf('clr-col') < 0) {
            this.renderer.addClass(this.el.nativeElement, 'clr-col-12');
            this.renderer.addClass(this.el.nativeElement, 'clr-col-md-2');
        }
        if (this.controlIdService && !this.forAttr) {
            this.subscriptions.push(this.controlIdService.idChange.subscribe(function (id) { return (_this.forAttr = id); }));
        }
    };
    /**
     * @return {?}
     */
    ClrLabel.prototype.disableGrid = /**
     * @return {?}
     */
    function () {
        this.enableGrid = false;
    };
    /**
     * @return {?}
     */
    ClrLabel.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrLabel.decorators = [
        { type: Directive, args: [{ selector: 'label' },] }
    ];
    /** @nocollapse */
    ClrLabel.ctorParameters = function () { return [
        { type: ControlIdService, decorators: [{ type: Optional }] },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: NgControlService, decorators: [{ type: Optional }] },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    ClrLabel.propDecorators = {
        forAttr: [{ type: HostBinding, args: ['attr.for',] }, { type: Input, args: ['for',] }]
    };
    return ClrLabel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var IS_NEW_FORMS_LAYOUT = new InjectionToken('IS_NEW_FORMS_LAYOUT');
/** @type {?} */
var IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER = {
    provide: IS_NEW_FORMS_LAYOUT,
    useValue: true,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var MarkControlService = /** @class */ (function () {
    function MarkControlService() {
        this._dirty = new Subject();
    }
    Object.defineProperty(MarkControlService.prototype, "dirtyChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dirty.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MarkControlService.prototype.markAsDirty = /**
     * @return {?}
     */
    function () {
        this._dirty.next();
    };
    MarkControlService.decorators = [
        { type: Injectable }
    ];
    return MarkControlService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrForm = /** @class */ (function () {
    function ClrForm(layoutService, markControlService) {
        this.layoutService = layoutService;
        this.markControlService = markControlService;
    }
    /**
     * @return {?}
     */
    ClrForm.prototype.markAsDirty = /**
     * @return {?}
     */
    function () {
        this.markControlService.markAsDirty();
    };
    ClrForm.decorators = [
        { type: Directive, args: [{
                    selector: '[clrForm]',
                    providers: [LayoutService, MarkControlService, IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER],
                    host: {
                        '[class.clr-form]': 'true',
                        '[class.clr-form-horizontal]': 'layoutService.isHorizontal()',
                        '[class.clr-form-compact]': 'layoutService.isCompact()',
                    },
                },] }
    ];
    /** @nocollapse */
    ClrForm.ctorParameters = function () { return [
        { type: LayoutService },
        { type: MarkControlService }
    ]; };
    return ClrForm;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrLayout = /** @class */ (function () {
    function ClrLayout(layoutService) {
        this.layoutService = layoutService;
    }
    /**
     * @return {?}
     */
    ClrLayout.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // Only set the layout if it is a valid option
        if (this.layout && this.layoutService.isValid(this.layout)) {
            this.layoutService.layout = this.layout;
        }
    };
    ClrLayout.decorators = [
        { type: Directive, args: [{
                    selector: '[clrForm][clrLayout]',
                },] }
    ];
    /** @nocollapse */
    ClrLayout.ctorParameters = function () { return [
        { type: LayoutService }
    ]; };
    ClrLayout.propDecorators = {
        layout: [{ type: Input, args: ['clrLayout',] }]
    };
    return ClrLayout;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrCommonFormsModule = /** @class */ (function () {
    function ClrCommonFormsModule() {
    }
    ClrCommonFormsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
                    exports: [ClrLabel, ClrControlError, ClrControlHelper, ClrIfError, ClrForm, ClrLayout],
                },] }
    ];
    return ClrCommonFormsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var IS_TOGGLE = new InjectionToken('IS_TOGGLE');
/**
 * @return {?}
 */
function isToggleFactory() {
    return new BehaviorSubject(false);
}
/** @type {?} */
var IS_TOGGLE_PROVIDER = { provide: IS_TOGGLE, useFactory: isToggleFactory };
var ClrCheckboxWrapper = /** @class */ (function () {
    function ClrCheckboxWrapper(toggleService) {
        var _this = this;
        // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
        // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
        // but we'd still need to insert a label
        this._dynamic = false;
        this.toggle = false;
        this.subscriptions = [];
        this.subscriptions.push(toggleService.subscribe(function (state$$1) {
            _this.toggle = state$$1;
        }));
    }
    /**
     * @return {?}
     */
    ClrCheckboxWrapper.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.label) {
            this.label.disableGrid();
        }
    };
    /**
     * @return {?}
     */
    ClrCheckboxWrapper.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrCheckboxWrapper.decorators = [
        { type: Component, args: [{
                    selector: 'clr-checkbox-wrapper,clr-toggle-wrapper',
                    template: "\n    <ng-content select=\"[clrCheckbox],[clrToggle]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                    host: {
                        '[class.clr-checkbox-wrapper]': '!toggle',
                        '[class.clr-toggle-wrapper]': 'toggle',
                    },
                    providers: [ControlIdService, IS_TOGGLE_PROVIDER]
                }] }
    ];
    /** @nocollapse */
    ClrCheckboxWrapper.ctorParameters = function () { return [
        { type: BehaviorSubject, decorators: [{ type: Inject, args: [IS_TOGGLE,] }] }
    ]; };
    ClrCheckboxWrapper.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }]
    };
    return ClrCheckboxWrapper;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
 * still undefined.
 * TODO - make sure these comment annotations do not break ng-packgr.
 * @template W
 */
var /**
 * HostWrapper must be called in OnInit to ensure that the Views are ready. If its called in a constructor the view is
 * still undefined.
 * TODO - make sure these comment annotations do not break ng-packgr.
 * @template W
 */
HostWrapper = /** @class */ (function () {
    function HostWrapper(containerType, vcr, index) {
        if (index === void 0) { index = 0; }
        this.injector = vcr.injector;
        // If the host is already wrapped, we don't do anything
        if (!this.injector.get(containerType, null)) {
            /** @type {?} */
            var cfr = this.injector.get(ComponentFactoryResolver);
            /** @type {?} */
            var el = this.injector.get(ElementRef);
            // We need a new anchor, since we're projecting the current one.
            vcr.createComponent(cfr.resolveComponentFactory(EmptyAnchor));
            /** @type {?} */
            var factory = cfr.resolveComponentFactory(containerType);
            // Craft the element array based on what slot to use. Angular only uses the index to determine
            // which ng-content to project into, so if you have more than one ng-content you'll need to set
            // the index in the constructor appropriately
            /** @type {?} */
            var element = [];
            element[index] = [el.nativeElement];
            // We're assuming only one projection slot, but in more complex cases we might want to provide
            // a different array of projected elements.
            /** @type {?} */
            var containerRef = vcr.createComponent(factory, undefined, undefined, element);
            // We can now remove the useless anchor
            vcr.remove(0);
            // We note that the container was dynamically created
            containerRef.instance._dynamic = true;
            // We keep the wrapper's injector to access the dependencies that weren't available before.
            this.injector = containerRef.injector;
        }
    }
    /**
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    HostWrapper.prototype.get = /**
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    function (token, notFoundValue) {
        return this.injector.get(token, notFoundValue);
    };
    return HostWrapper;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ControlClassService = /** @class */ (function () {
    function ControlClassService() {
        this.className = '';
    }
    /**
     * @param {?=} invalid
     * @param {?=} grid
     * @param {?=} additional
     * @return {?}
     */
    ControlClassService.prototype.controlClass = /**
     * @param {?=} invalid
     * @param {?=} grid
     * @param {?=} additional
     * @return {?}
     */
    function (invalid, grid, additional) {
        if (invalid === void 0) { invalid = false; }
        if (grid === void 0) { grid = false; }
        if (additional === void 0) { additional = ''; }
        /** @type {?} */
        var controlClasses = [this.className, additional];
        if (invalid) {
            controlClasses.push('clr-error');
        }
        if (grid && this.className.indexOf('clr-col') === -1) {
            controlClasses.push('clr-col-md-10 clr-col-12');
        }
        return controlClasses.join(' ').trim();
    };
    // We want to remove the column classes from the input up to the container
    // We want to remove the column classes from the input up to the container
    /**
     * @param {?} renderer
     * @param {?} element
     * @return {?}
     */
    ControlClassService.prototype.initControlClass = 
    // We want to remove the column classes from the input up to the container
    /**
     * @param {?} renderer
     * @param {?} element
     * @return {?}
     */
    function (renderer, element) {
        if (element && element.className) {
            this.className = element.className;
            /** @type {?} */
            var klasses = element.className.split(' ');
            klasses.forEach(function (klass) {
                if (klass.startsWith('clr-col')) {
                    renderer.removeClass(element, klass);
                }
            });
        }
    };
    ControlClassService.decorators = [
        { type: Injectable }
    ];
    return ControlClassService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template W
 */
var WrappedFormControl = /** @class */ (function () {
    // I lost way too much time trying to make this work without injecting the ViewContainerRef and the Injector,
    // I'm giving up. So we have to inject these two manually for now.
    function WrappedFormControl(vcr, wrapperType, injector, ngControl, renderer, el) {
        var _this = this;
        this.vcr = vcr;
        this.wrapperType = wrapperType;
        this.ngControl = ngControl;
        this.subscriptions = [];
        this.index = 0;
        try {
            this.ngControlService = injector.get(NgControlService);
            this.ifErrorService = injector.get(IfErrorService);
            this.controlClassService = injector.get(ControlClassService);
            this.markControlService = injector.get(MarkControlService);
        }
        catch (e) { }
        if (this.controlClassService) {
            this.controlClassService.initControlClass(renderer, el.nativeElement);
        }
        if (this.markControlService) {
            this.subscriptions.push(this.markControlService.dirtyChange.subscribe(function () {
                _this.ngControl.control.markAsDirty();
                _this.ngControl.control.updateValueAndValidity();
            }));
        }
    }
    Object.defineProperty(WrappedFormControl.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value;
            if (this.controlIdService) {
                this.controlIdService.id = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WrappedFormControl.prototype.triggerValidation = /**
     * @return {?}
     */
    function () {
        if (this.ifErrorService) {
            this.ifErrorService.triggerStatusChange();
        }
    };
    // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
    // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
    // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
    // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
    // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
    // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
    // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
    // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
    /**
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    WrappedFormControl.prototype.getProviderFromContainer = 
    // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
    // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
    // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
    // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
    /**
     * @template T
     * @param {?} token
     * @param {?=} notFoundValue
     * @return {?}
     */
    function (token, notFoundValue) {
        try {
            return this._containerInjector.get(token, notFoundValue);
        }
        catch (e) {
            return notFoundValue;
        }
    };
    /**
     * @return {?}
     */
    WrappedFormControl.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._containerInjector = new HostWrapper(this.wrapperType, this.vcr, this.index);
        this.controlIdService = this._containerInjector.get(ControlIdService);
        if (this._id) {
            this.controlIdService.id = this._id;
        }
        else {
            this._id = this.controlIdService.id;
        }
        if (this.ngControlService) {
            this.ngControlService.setControl(this.ngControl);
        }
    };
    /**
     * @return {?}
     */
    WrappedFormControl.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    WrappedFormControl.propDecorators = {
        id: [{ type: HostBinding }, { type: Input }],
        triggerValidation: [{ type: HostListener, args: ['blur',] }]
    };
    return WrappedFormControl;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This implements both the clrCheckbox and clrToggle functionality, since they are both just checkboxes with different
 * visual styling. The challenge is that the container needs to know which selector was used, which the \@Attribute
 * decorator gets for us to determine if the toggle is used, and emits a value to the wrapper container to tell it
 * there is a toggle switch instead.
 */
var ClrCheckbox = /** @class */ (function (_super) {
    __extends(ClrCheckbox, _super);
    function ClrCheckbox(vcr, injector, control, renderer, el, toggle) {
        var _this = _super.call(this, vcr, ClrCheckboxWrapper, injector, control, renderer, el) || this;
        _this.toggle = toggle;
        return _this;
    }
    /**
     * @return {?}
     */
    ClrCheckbox.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        /** @type {?} */
        var toggleService = this.getProviderFromContainer(IS_TOGGLE, null);
        if (toggleService && this.toggle !== null) {
            toggleService.next(true);
        }
    };
    ClrCheckbox.decorators = [
        { type: Directive, args: [{ selector: '[clrCheckbox],[clrToggle]' },] }
    ];
    /** @nocollapse */
    ClrCheckbox.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Injector },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: Renderer2 },
        { type: ElementRef },
        { type: String, decorators: [{ type: Attribute, args: ['clrToggle',] }] }
    ]; };
    return ClrCheckbox;
}(WrappedFormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrCheckboxContainer = /** @class */ (function () {
    // @TODO Solve for group validation, which doesn't work now with ngModelGroup
    // Blocked by https://github.com/angular/angular/issues/20268
    // @Input()
    // set clrFormGroup(value: FormGroup) {
    //   this.formGroup = value;
    // }
    // @Input()
    // set clrFormArray(value: FormArray) {
    //   this.formGroup = value;
    // }
    function ClrCheckboxContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
        var _this = this;
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this.inline = false;
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            _this.control = control;
        }));
    }
    Object.defineProperty(ClrCheckboxContainer.prototype, "clrInline", {
        get: /**
         * @return {?}
         */
        function () {
            return this.inline;
        },
        // private formGroup: AbstractControl;
        /*
         * Here we want to support the following cases
         * clrInline - true by presence
         * clrInline="true|false" - unless it is explicitly false, strings are considered true
         * [clrInline]="true|false" - expect a boolean
         */
        set: 
        // private formGroup: AbstractControl;
        /*
           * Here we want to support the following cases
           * clrInline - true by presence
           * clrInline="true|false" - unless it is explicitly false, strings are considered true
           * [clrInline]="true|false" - expect a boolean
           */
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                this.inline = value === 'false' ? false : true;
            }
            else {
                this.inline = !!value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrCheckboxContainer.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // @TODO put a solution in for form group validation
        // if (!this.formGroup) {
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            _this.invalid = invalid;
        }));
        // } else {
        //   // Because ngModel does this, we have to delay a tick to get the result
        //   Promise.resolve().then(() => {
        //     this.subscriptions.push(
        //       this.formGroup.statusChanges.subscribe(() => {
        //         this.invalid = this.formGroup.invalid;
        //       })
        //     );
        //   });
        // }
    };
    /**
     * @return {?}
     */
    ClrCheckboxContainer.prototype.controlClass = /**
     * @return {?}
     */
    function () {
        return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
    };
    /**
     * @return {?}
     */
    ClrCheckboxContainer.prototype.addGrid = /**
     * @return {?}
     */
    function () {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    ClrCheckboxContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
    };
    ClrCheckboxContainer.decorators = [
        { type: Component, args: [{
                    selector: 'clr-checkbox-container,clr-toggle-container',
                    template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-checkbox-wrapper,clr-toggle-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n  ",
                    host: {
                        '[class.clr-form-control]': 'true',
                        '[class.clr-form-control-disabled]': 'control?.disabled',
                        '[class.clr-row]': 'addGrid()',
                    },
                    providers: [NgControlService, ControlClassService, IfErrorService]
                }] }
    ];
    /** @nocollapse */
    ClrCheckboxContainer.ctorParameters = function () { return [
        { type: IfErrorService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: ControlClassService },
        { type: NgControlService }
    ]; };
    ClrCheckboxContainer.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }],
        clrInline: [{ type: Input }]
    };
    return ClrCheckboxContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrCheckboxModule = /** @class */ (function () {
    function ClrCheckboxModule() {
    }
    ClrCheckboxModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
                    declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                    exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
                    entryComponents: [ClrCheckboxWrapper],
                },] }
    ];
    return ClrCheckboxModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var activeCounter = 0;
/** @type {?} */
var IF_ACTIVE_ID = new InjectionToken('IF_ACTIVE_ID');
/**
 * @return {?}
 */
function tokenFactory() {
    return ++activeCounter;
}
/** @type {?} */
var IF_ACTIVE_ID_PROVIDER = {
    provide: IF_ACTIVE_ID,
    useFactory: tokenFactory,
};
var IfActiveService = /** @class */ (function () {
    function IfActiveService() {
        /**
         * *****
         * \@property _currentChange
         *
         * \@description
         * A RXJS Subject that updates and provides subscriptions to for the current current state of a component template
         * implemting the IfActive structural directive.
         *
         */
        this._currentChange = new Subject();
    }
    Object.defineProperty(IfActiveService.prototype, "currentChange", {
        /*********
         *
         * @description
         * A getter function that provides an observable for the _current Subject.
         *
         */
        get: /**
         * ******
         *
         * \@description
         * A getter function that provides an observable for the _current Subject.
         *
         * @return {?}
         */
        function () {
            return this._currentChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IfActiveService.prototype, "current", {
        /*********
         *
         * @description
         * A getter that returns the current value of this IfActive instance.
         * @returns
         */
        get: /**
         * ******
         *
         * \@description
         * A getter that returns the current value of this IfActive instance.
         * @return {?}
         */
        function () {
            return this._current;
        },
        /*********
         *
         * @description
         * A setter function that updates the current state of _current for this instance of IfActive structural directive.
         * And, broadcasts the new value to all subscribers.
         *
         * @param value
         */
        set: /**
         * ******
         *
         * \@description
         * A setter function that updates the current state of _current for this instance of IfActive structural directive.
         * And, broadcasts the new value to all subscribers.
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._current !== value) {
                this._current = value;
                this._currentChange.next(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    IfActiveService.decorators = [
        { type: Injectable }
    ];
    return IfActiveService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrIfActive = /** @class */ (function () {
    function ClrIfActive(ifActiveService, id, template, container) {
        var _this = this;
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.template = template;
        this.container = container;
        this.wasActive = false;
        /**
         * *******
         * \@property activeChange
         *
         * \@description
         * An event emitter that emits when the active property is set to allow for 2way binding when the directive is
         * used with de-structured / de-sugared syntax.
         *
         */
        this.activeChange = new EventEmitter(false);
        this.checkAndUpdateView(ifActiveService.current);
        this.subscription = this.ifActiveService.currentChange.subscribe(function (newCurrentId) {
            _this.checkAndUpdateView(newCurrentId);
        });
    }
    /**
     * @param {?} currentId
     * @return {?}
     */
    ClrIfActive.prototype.checkAndUpdateView = /**
     * @param {?} currentId
     * @return {?}
     */
    function (currentId) {
        /** @type {?} */
        var isNowActive = currentId === this.id;
        // only emit if the new active state is changed since last time.
        if (isNowActive !== this.wasActive) {
            this.updateView(isNowActive);
            this.activeChange.emit(isNowActive);
            this.wasActive = isNowActive;
        }
    };
    Object.defineProperty(ClrIfActive.prototype, "active", {
        /********
         *
         * @description
         * A getter that returns the current IfActiveService.active value.
         */
        get: /**
         * *****
         *
         * \@description
         * A getter that returns the current IfActiveService.active value.
         * @return {?}
         */
        function () {
            return this.ifActiveService.current === this.id;
        },
        /*********
         *
         * @description
         * A setter that updates IfActiveService.active with value.
         *
         * @param value
         */
        set: /**
         * ******
         *
         * \@description
         * A setter that updates IfActiveService.active with value.
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.ifActiveService.current = this.id;
            }
        },
        enumerable: true,
        configurable: true
    });
    /*********
     *
     * @description
     * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param value
     */
    /**
     * ******
     *
     * \@description
     * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param {?} value
     * @return {?}
     */
    ClrIfActive.prototype.updateView = /**
     * ******
     *
     * \@description
     * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.container.createEmbeddedView(this.template);
        }
        else {
            this.container.clear();
        }
    };
    /**
     * @return {?}
     */
    ClrIfActive.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    ClrIfActive.decorators = [
        { type: Directive, args: [{ selector: '[clrIfActive]' },] }
    ];
    /** @nocollapse */
    ClrIfActive.ctorParameters = function () { return [
        { type: IfActiveService },
        { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    ClrIfActive.propDecorators = {
        active: [{ type: Input, args: ['clrIfActive',] }],
        activeChange: [{ type: Output, args: ['clrIfActiveChange',] }]
    };
    return ClrIfActive;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var IfOpenService = /** @class */ (function () {
    function IfOpenService() {
        /**
         * *****
         * \@property _openChange
         *
         * \@description
         * A RXJS Subject that updates and provides subscriptions to for the current open state of a component template
         * implemting the IfOpen structural directive.
         */
        this._openChange = new Subject();
        /**
         *  Popovers might need to ignore click events on an element
         *  (eg: popover opens on focus on an input field. Clicks should be ignored in this case)
         */
        this._ignoredElementChange = new Subject();
    }
    Object.defineProperty(IfOpenService.prototype, "openChange", {
        /*********
         *
         * @description
         * A getter function that provides an observable for the _opened Subject.
         *
         */
        get: /**
         * ******
         *
         * \@description
         * A getter function that provides an observable for the _opened Subject.
         *
         * @return {?}
         */
        function () {
            return this._openChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IfOpenService.prototype, "open", {
        /*********
         *
         * @description
         * A getter that returns the current value of this IfOpen instance.
         *
         */
        get: /**
         * ******
         *
         * \@description
         * A getter that returns the current value of this IfOpen instance.
         *
         * @return {?}
         */
        function () {
            return this._open;
        },
        /*********
         *
         * @description
         * A setter function that updates the current state of _open for this instance of IfOpen structural directive. And,
         * broadcasts the new value to all subscribers.
         *
         * @param value
         */
        set: /**
         * ******
         *
         * \@description
         * A setter function that updates the current state of _open for this instance of IfOpen structural directive. And,
         * broadcasts the new value to all subscribers.
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = !!value;
            if (this._open !== value) {
                this._open = value;
                this._openChange.next(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    IfOpenService.prototype.toggleWithEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.originalEvent = event;
        this.open = !this.open;
        delete this.originalEvent;
    };
    Object.defineProperty(IfOpenService.prototype, "ignoredElementChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._ignoredElementChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} element
     * @return {?}
     */
    IfOpenService.prototype.registerIgnoredElement = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this._ignoredElementChange.next(element);
    };
    IfOpenService.decorators = [
        { type: Injectable }
    ];
    return IfOpenService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrIfOpen = /** @class */ (function () {
    function ClrIfOpen(ifOpenService, template, container) {
        var _this = this;
        this.ifOpenService = ifOpenService;
        this.template = template;
        this.container = container;
        /**
         * *******
         * \@property openChange
         *
         * \@description
         * An event emitter that emits when the open property is set to allow for 2way binding when the directive is
         * used with de-structured / de-sugared syntax.
         */
        this.openChange = new EventEmitter(false);
        this.subscription = this.ifOpenService.openChange.subscribe(function (change) {
            _this.updateView(change);
            _this.openChange.emit(change);
        });
    }
    Object.defineProperty(ClrIfOpen.prototype, "open", {
        /********
         *
         * @description
         * A getter that returns the current IfOpenService.open value.
         *
         */
        get: /**
         * *****
         *
         * \@description
         * A getter that returns the current IfOpenService.open value.
         *
         * @return {?}
         */
        function () {
            return this.ifOpenService.open;
        },
        /*********
         *
         * @description
         * A setter that updates IfOpenService.open with value.
         *
         * @param value
         */
        set: /**
         * ******
         *
         * \@description
         * A setter that updates IfOpenService.open with value.
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.ifOpenService.open = value;
        },
        enumerable: true,
        configurable: true
    });
    /*********
     *
     * @description
     * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param value
     */
    /**
     * ******
     *
     * \@description
     * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param {?} value
     * @return {?}
     */
    ClrIfOpen.prototype.updateView = /**
     * ******
     *
     * \@description
     * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
     * Clears all views from the ViewContainerRef
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.container.createEmbeddedView(this.template);
        }
        else {
            this.container.clear();
        }
    };
    /**
     * @return {?}
     */
    ClrIfOpen.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    ClrIfOpen.decorators = [
        { type: Directive, args: [{ selector: '[clrIfOpen]' },] }
    ];
    /** @nocollapse */
    ClrIfOpen.ctorParameters = function () { return [
        { type: IfOpenService },
        { type: TemplateRef },
        { type: ViewContainerRef }
    ]; };
    ClrIfOpen.propDecorators = {
        open: [{ type: Input, args: ['clrIfOpen',] }],
        openChange: [{ type: Output, args: ['clrIfOpenChange',] }]
    };
    return ClrIfOpen;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CONDITIONAL_DIRECTIVES = [ClrIfActive, ClrIfOpen];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrConditionalModule = /** @class */ (function () {
    function ClrConditionalModule() {
    }
    ClrConditionalModule.decorators = [
        { type: NgModule, args: [{ imports: [CommonModule], declarations: [CONDITIONAL_DIRECTIVES], exports: [CONDITIONAL_DIRECTIVES] },] }
    ];
    return ClrConditionalModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var FocusTrapTracker = /** @class */ (function () {
    function FocusTrapTracker() {
        this._previousFocusTraps = [];
    }
    Object.defineProperty(FocusTrapTracker.prototype, "current", {
        get: /**
         * @return {?}
         */
        function () {
            return this._current;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._previousFocusTraps.push(this._current);
            this._current = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusTrapTracker.prototype, "nbFocusTrappers", {
        get: /**
         * @return {?}
         */
        function () {
            return this._previousFocusTraps.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FocusTrapTracker.prototype.activatePreviousTrapper = /**
     * @return {?}
     */
    function () {
        this._current = this._previousFocusTraps.pop();
    };
    FocusTrapTracker.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ FocusTrapTracker.ngInjectableDef = defineInjectable({ factory: function FocusTrapTracker_Factory() { return new FocusTrapTracker(); }, token: FocusTrapTracker, providedIn: "root" });
    return FocusTrapTracker;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var FocusTrapDirective = /** @class */ (function () {
    function FocusTrapDirective(el, injector, focusTrapsTracker, renderer, platformId) {
        this.el = el;
        this.injector = injector;
        this.focusTrapsTracker = focusTrapsTracker;
        this.renderer = renderer;
        this.platformId = platformId;
        this.document = this.injector.get(DOCUMENT);
        this.focusTrapsTracker.current = this;
        this.renderer.setAttribute(this.el.nativeElement, 'tabindex', '0');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    FocusTrapDirective.prototype.onFocusIn = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var nativeElement = this.el.nativeElement;
        if (this.focusTrapsTracker.current === this && event.target && !nativeElement.contains(event.target)) {
            nativeElement.focus();
        }
    };
    /**
     * @return {?}
     */
    FocusTrapDirective.prototype.createFocusableOffScreenEl = /**
     * @return {?}
     */
    function () {
        // Not using Renderer2's createElement method because that leads to DOM leakage.
        // https://github.com/angular/angular/issues/26954
        /** @type {?} */
        var offScreenSpan = this.document.createElement('span');
        this.renderer.setAttribute(offScreenSpan, 'tabindex', '0');
        this.renderer.addClass(offScreenSpan, 'offscreen-focus-rebounder');
        return offScreenSpan;
    };
    /**
     * @return {?}
     */
    FocusTrapDirective.prototype.addReboundEls = /**
     * @return {?}
     */
    function () {
        // We will add these focus rebounding elements only in the following conditions:
        // 1. It should be running inside browser platform as it accesses document.body element
        // 2. We should NOT add them more than once. Hence, we are counting a number of focus trappers
        //    and only add on the first focus trapper.
        if (isPlatformBrowser(this.platformId) && this.focusTrapsTracker.nbFocusTrappers === 1) {
            this.topReboundEl = this.createFocusableOffScreenEl();
            this.bottomReboundEl = this.createFocusableOffScreenEl();
            // Add reboundBeforeTrapEl to the document body as the first child
            this.renderer.insertBefore(this.document.body, this.topReboundEl, this.document.body.firstChild);
            // Add reboundAfterTrapEl to the document body as the last child
            this.renderer.appendChild(this.document.body, this.bottomReboundEl);
        }
    };
    /**
     * @return {?}
     */
    FocusTrapDirective.prototype.removeReboundEls = /**
     * @return {?}
     */
    function () {
        if (isPlatformBrowser(this.platformId) &&
            this.focusTrapsTracker.nbFocusTrappers === 1 &&
            this.topReboundEl &&
            this.bottomReboundEl) {
            this.renderer.removeChild(this.document.body, this.topReboundEl);
            this.renderer.removeChild(this.document.body, this.bottomReboundEl);
            // These are here to to make sure that
            // we completely delete all traces of the removed DOM objects.
            delete this.topReboundEl;
            delete this.bottomReboundEl;
        }
    };
    /**
     * @return {?}
     */
    FocusTrapDirective.prototype.setPreviousFocus = /**
     * @return {?}
     */
    function () {
        if (this.previousActiveElement && this.previousActiveElement.focus) {
            this.previousActiveElement.focus();
        }
    };
    /**
     * @return {?}
     */
    FocusTrapDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (isPlatformBrowser(this.platformId)) {
            this.previousActiveElement = (/** @type {?} */ (this.document.activeElement));
        }
        this.addReboundEls();
    };
    /**
     * @return {?}
     */
    FocusTrapDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeReboundEls();
        this.setPreviousFocus();
        this.focusTrapsTracker.activatePreviousTrapper();
    };
    FocusTrapDirective.decorators = [
        { type: Directive, args: [{ selector: '[clrFocusTrap]' },] }
    ];
    /** @nocollapse */
    FocusTrapDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Injector },
        { type: FocusTrapTracker },
        { type: Renderer2 },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    FocusTrapDirective.propDecorators = {
        onFocusIn: [{ type: HostListener, args: ['document:focusin', ['$event'],] }]
    };
    return FocusTrapDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var FOCUS_TRAP_DIRECTIVES = [FocusTrapDirective];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrFocusTrapModule = /** @class */ (function () {
    function ClrFocusTrapModule() {
    }
    ClrFocusTrapModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [FOCUS_TRAP_DIRECTIVES],
                    exports: [FOCUS_TRAP_DIRECTIVES],
                },] }
    ];
    return ClrFocusTrapModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @type {?} */
var UP_ARROW = 38;
/** @type {?} */
var DOWN_ARROW = 40;
/** @type {?} */
var RIGHT_ARROW = 39;
/** @type {?} */
var LEFT_ARROW = 37;
/** @type {?} */
var ESC = 27;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * This is the en-001 short locale date format. Setting as default.
 * @type {?}
 */
var DEFAULT_LOCALE_FORMAT = 'dd/MM/y';
// https://en.wikipedia.org/wiki/Date_format_by_country
/** @type {?} */
var LITTLE_ENDIAN_REGEX = /d+.+m+.+y+/i;
/** @type {?} */
var MIDDLE_ENDIAN_REGEX = /m+.+d+.+y+/i;
// No need for BIG_ENDIAN_REGEX because anything that doesn't satisfy the above 2
// is automatically BIG_ENDIAN
/** @type {?} */
var DELIMITER_REGEX = /d+|m+|y+/i;
/** @type {?} */
var USER_INPUT_REGEX = /\d+/g;
/** @type {?} */
var MOBILE_USERAGENT_REGEX = /Mobi/i;
/** @type {?} */
var RTL_REGEX = /\u200f/g;
/** @type {?} */
var YEAR = 'YYYY';
/** @type {?} */
var MONTH = 'MM';
/** @type {?} */
var DATE = 'DD';
/** @type {?} */
var LITTLE_ENDIAN = {
    name: 'LITTLE_ENDIAN',
    format: [DATE, MONTH, YEAR],
};
/** @type {?} */
var MIDDLE_ENDIAN = {
    name: 'MIDDLE_ENDIAN',
    format: [MONTH, DATE, YEAR],
};
/** @type {?} */
var BIG_ENDIAN = {
    name: 'BIG_ENDIAN',
    format: [YEAR, MONTH, DATE],
};
/** @type {?} */
var NO_OF_DAYS_IN_A_WEEK = 7;
/** @type {?} */
var NO_OF_ROWS_IN_CALENDAR_VIEW = 6;
/** @type {?} */
var TOTAL_DAYS_IN_DAYS_VIEW = NO_OF_DAYS_IN_A_WEEK * NO_OF_ROWS_IN_CALENDAR_VIEW;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Returns the number of days in a month.
 * @param {?} year
 * @param {?} month
 * @return {?}
 */
function getNumberOfDaysInTheMonth(year, month) {
    // If we go to the next month, but use a day of 0, it returns the last day from the previous month
    return new Date(year, month + 1, 0).getDate();
}
/**
 * Returns the day for the corresponding date where 0 represents Sunday.
 * @param {?} year
 * @param {?} month
 * @param {?} date
 * @return {?}
 */
function getDay(year, month, date) {
    return new Date(year, month, date).getDay();
}
/**
 * Takes in a year and if it is a 2 digit year, returns the corresponding 4 digit year.
 * Window of 80 years before and 20 years after the present year.
 * Credit: https://github.com/globalizejs/globalize/blob/e1b31cd6a4f1cff75b185b68b7a32220aac5196f/src/date/parse.js
 * @param {?} year
 * @return {?}
 */
function parseToFourDigitYear(year) {
    if (year > 9999 || (year > 100 && year < 999) || year < 10) {
        return -1;
    }
    if (year > 999) {
        return year;
    }
    /** @type {?} */
    var currYear = new Date().getFullYear();
    /** @type {?} */
    var century = Math.floor(currYear / 100) * 100;
    /** @type {?} */
    var result = year + century;
    if (result > currYear + 20) {
        result = result - 100;
    }
    return result;
}
/**
 * @param {?} date1
 * @param {?} date2
 * @return {?}
 */
function datesAreEqual(date1, date2) {
    if (date1 instanceof Date && date2 instanceof Date) {
        return (date1.getFullYear() === date2.getFullYear() &&
            date1.getMonth() === date2.getMonth() &&
            date1.getDate() === date2.getDate());
    }
    else {
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var DayViewModel = /** @class */ (function () {
    function DayViewModel(dayModel, isTodaysDate, isDisabled, isSelected, isFocusable) {
        if (isTodaysDate === void 0) { isTodaysDate = false; }
        if (isDisabled === void 0) { isDisabled = false; }
        if (isSelected === void 0) { isSelected = false; }
        if (isFocusable === void 0) { isFocusable = false; }
        this.dayModel = dayModel;
        this.isTodaysDate = isTodaysDate;
        this.isDisabled = isDisabled;
        this.isSelected = isSelected;
        this.isFocusable = isFocusable;
    }
    Object.defineProperty(DayViewModel.prototype, "tabIndex", {
        /**
         * Gets the tab index based on the isFocusable flag.
         */
        get: /**
         * Gets the tab index based on the isFocusable flag.
         * @return {?}
         */
        function () {
            return this.isFocusable ? 0 : -1;
        },
        enumerable: true,
        configurable: true
    });
    return DayViewModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CalendarModel = /** @class */ (function () {
    function CalendarModel(year, month) {
        this.year = year;
        this.month = month;
        this.initializeDaysInCalendar();
    }
    /**
     * Populates the days array with the DayModels in the current Calendar.
     */
    /**
     * Populates the days array with the DayModels in the current Calendar.
     * @return {?}
     */
    CalendarModel.prototype.initializeDaysInCalendar = /**
     * Populates the days array with the DayModels in the current Calendar.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var noOfDaysInCalendar = getNumberOfDaysInTheMonth(this.year, this.month);
        this.days = Array(noOfDaysInCalendar)
            .fill(null)
            .map(function (date, index) {
            return new DayModel(_this.year, _this.month, index + 1);
        });
    };
    /**
     * Checks if the calendar passed is equal to the current calendar.
     */
    /**
     * Checks if the calendar passed is equal to the current calendar.
     * @param {?} calendar
     * @return {?}
     */
    CalendarModel.prototype.isEqual = /**
     * Checks if the calendar passed is equal to the current calendar.
     * @param {?} calendar
     * @return {?}
     */
    function (calendar) {
        if (calendar) {
            return this.year === calendar.year && this.month === calendar.month;
        }
        return false;
    };
    /**
     * Checks if a DayModel is in the Calendar
     */
    /**
     * Checks if a DayModel is in the Calendar
     * @param {?} day
     * @return {?}
     */
    CalendarModel.prototype.isDayInCalendar = /**
     * Checks if a DayModel is in the Calendar
     * @param {?} day
     * @return {?}
     */
    function (day) {
        if (day) {
            return this.year === day.year && this.month === day.month;
        }
        return false;
    };
    /**
     * Returns CalendarModel of the previous month.
     */
    /**
     * Returns CalendarModel of the previous month.
     * @return {?}
     */
    CalendarModel.prototype.previousMonth = /**
     * Returns CalendarModel of the previous month.
     * @return {?}
     */
    function () {
        if (this.month === 0) {
            return new CalendarModel(this.year - 1, 11);
        }
        else {
            return new CalendarModel(this.year, this.month - 1);
        }
    };
    /**
     * Returns CalendarModel of the next month.
     */
    /**
     * Returns CalendarModel of the next month.
     * @return {?}
     */
    CalendarModel.prototype.nextMonth = /**
     * Returns CalendarModel of the next month.
     * @return {?}
     */
    function () {
        if (this.month === 11) {
            return new CalendarModel(this.year + 1, 0);
        }
        else {
            return new CalendarModel(this.year, this.month + 1);
        }
    };
    return CalendarModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DayModel = /** @class */ (function () {
    function DayModel(year, month, date) {
        this.year = year;
        this.month = month;
        this.date = date;
    }
    Object.defineProperty(DayModel.prototype, "calendar", {
        /**
         * Returns the Calendar for the current DayModel.
         */
        get: /**
         * Returns the Calendar for the current DayModel.
         * @return {?}
         */
        function () {
            return new CalendarModel(this.year, this.month);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if the passed CalendarDate is equal to itself.
     */
    /**
     * Checks if the passed CalendarDate is equal to itself.
     * @param {?} day
     * @return {?}
     */
    DayModel.prototype.isEqual = /**
     * Checks if the passed CalendarDate is equal to itself.
     * @param {?} day
     * @return {?}
     */
    function (day) {
        if (day) {
            return this.year === day.year && this.month === day.month && this.date === day.date;
        }
        return false;
    };
    /**
     * Converts the CalendarDate into the Javascript Date object.
     */
    /**
     * Converts the CalendarDate into the Javascript Date object.
     * @return {?}
     */
    DayModel.prototype.toDate = /**
     * Converts the CalendarDate into the Javascript Date object.
     * @return {?}
     */
    function () {
        return new Date(this.year, this.month, this.date);
    };
    /**
     * Returns a new DayModel which is incremented based on the value passed.
     */
    /**
     * Returns a new DayModel which is incremented based on the value passed.
     * @param {?} value
     * @return {?}
     */
    DayModel.prototype.incrementBy = /**
     * Returns a new DayModel which is incremented based on the value passed.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // Creating new Javascript Date object to increment because
        // it will automatically take care of switching to next or previous
        // months & years without we having to worry about it.
        /** @type {?} */
        var date = new Date(this.year, this.month, this.date + value);
        return new DayModel(date.getFullYear(), date.getMonth(), date.getDate());
    };
    /**
     * Clones the current day model.
     */
    /**
     * Clones the current day model.
     * @return {?}
     */
    DayModel.prototype.clone = /**
     * Clones the current day model.
     * @return {?}
     */
    function () {
        return new DayModel(this.year, this.month, this.date);
    };
    return DayModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var CalendarViewModel = /** @class */ (function () {
    function CalendarViewModel(calendar, selectedDay, focusableDay, today, firstDayOfWeek) {
        this.calendar = calendar;
        this.selectedDay = selectedDay;
        this.focusableDay = focusableDay;
        this.today = today;
        this.firstDayOfWeek = firstDayOfWeek;
        this.currMonthDayViews = [];
        this.initializeCalendarView();
    }
    Object.defineProperty(CalendarViewModel.prototype, "calendarView", {
        /**
         * DayViewModel matrix. Size 6x7
         */
        get: /**
         * DayViewModel matrix. Size 6x7
         * @return {?}
         */
        function () {
            return this._calendarView;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generates a 6x7 matrix of DayViewModel based on the Calendar.
     * The 6x7 matrix is structured according to the first day of the week.
     * 6 rows to accommodate months which might have dates spanning over 6 weeks.
     * 7 columns because there are 7 days in a week :P :D
     */
    /**
     * Generates a 6x7 matrix of DayViewModel based on the Calendar.
     * The 6x7 matrix is structured according to the first day of the week.
     * 6 rows to accommodate months which might have dates spanning over 6 weeks.
     * 7 columns because there are 7 days in a week :P :D
     * @return {?}
     */
    CalendarViewModel.prototype.initializeCalendarView = /**
     * Generates a 6x7 matrix of DayViewModel based on the Calendar.
     * The 6x7 matrix is structured according to the first day of the week.
     * 6 rows to accommodate months which might have dates spanning over 6 weeks.
     * 7 columns because there are 7 days in a week :P :D
     * @return {?}
     */
    function () {
        // Generate prev and next month calendar models.
        /** @type {?} */
        var prevMonthCalendar = this.calendar.previousMonth();
        /** @type {?} */
        var nextMonthCalendar = this.calendar.nextMonth();
        // Get no of days from prev and next months.
        /** @type {?} */
        var daysFromPrevMonthInCalView = this.numDaysFromPrevMonthInCalView(this.calendar.year, this.calendar.month);
        /** @type {?} */
        var daysFromNextMonthInCalView = TOTAL_DAYS_IN_DAYS_VIEW - (this.calendar.days.length + daysFromPrevMonthInCalView);
        // Generate prev, curr and next day view models
        /** @type {?} */
        var prevMonthDayViews = [];
        /** @type {?} */
        var nextMonthDayViews = [];
        if (daysFromPrevMonthInCalView > 0) {
            prevMonthDayViews = this.generateDayViewModels(prevMonthCalendar.days.slice(-1 * daysFromPrevMonthInCalView), true, false);
        }
        this.currMonthDayViews = this.generateDayViewModels(this.calendar.days, false, true);
        if (daysFromNextMonthInCalView > 0) {
            nextMonthDayViews = this.generateDayViewModels(nextMonthCalendar.days.slice(0, daysFromNextMonthInCalView), true, false);
        }
        // Generate calendar view and initialize flags
        this._calendarView = this.generateCalendarView(prevMonthDayViews, this.currMonthDayViews, nextMonthDayViews);
        this.initializeSelectedDay();
        this.initializeFocusableDay();
    };
    /**
     * Generates a DayViewModel array based on the DayModel passed
     */
    /**
     * Generates a DayViewModel array based on the DayModel passed
     * @param {?} days
     * @param {?} isDisabled
     * @param {?} isCurrentCalendar
     * @return {?}
     */
    CalendarViewModel.prototype.generateDayViewModels = /**
     * Generates a DayViewModel array based on the DayModel passed
     * @param {?} days
     * @param {?} isDisabled
     * @param {?} isCurrentCalendar
     * @return {?}
     */
    function (days, isDisabled, isCurrentCalendar) {
        /** @type {?} */
        var dayViews = days.map(function (day) {
            return new DayViewModel(day, false, isDisabled, false, false);
        });
        if (isCurrentCalendar && this.calendar.isDayInCalendar(this.today)) {
            dayViews[this.today.date - 1].isTodaysDate = true;
        }
        return dayViews;
    };
    /**
     * Gets the first day of the current month to figure out how many dates of previous month
     * are needed to complete the Calendar View based on the first day of the week.
     * eg: Assuming locale en-US, the first day of the week is Sunday,
     * if first day of the current month lands on Wednesday, then
     * (this.getDay function would return 3 since
     * first day of the week is 0), we need the 3 days from the previous month.
     */
    /**
     * Gets the first day of the current month to figure out how many dates of previous month
     * are needed to complete the Calendar View based on the first day of the week.
     * eg: Assuming locale en-US, the first day of the week is Sunday,
     * if first day of the current month lands on Wednesday, then
     * (this.getDay function would return 3 since
     * first day of the week is 0), we need the 3 days from the previous month.
     * @param {?} currentYear
     * @param {?} currentMonth
     * @return {?}
     */
    CalendarViewModel.prototype.numDaysFromPrevMonthInCalView = /**
     * Gets the first day of the current month to figure out how many dates of previous month
     * are needed to complete the Calendar View based on the first day of the week.
     * eg: Assuming locale en-US, the first day of the week is Sunday,
     * if first day of the current month lands on Wednesday, then
     * (this.getDay function would return 3 since
     * first day of the week is 0), we need the 3 days from the previous month.
     * @param {?} currentYear
     * @param {?} currentMonth
     * @return {?}
     */
    function (currentYear, currentMonth) {
        /** @type {?} */
        var firstDayOfCurrMonth = getDay(currentYear, currentMonth, 1);
        if (firstDayOfCurrMonth >= this.firstDayOfWeek) {
            return firstDayOfCurrMonth - this.firstDayOfWeek;
        }
        else {
            return NO_OF_DAYS_IN_A_WEEK + firstDayOfCurrMonth - this.firstDayOfWeek;
        }
    };
    /**
     * Checks if the Day passed is in the CalendarView.
     */
    /**
     * Checks if the Day passed is in the CalendarView.
     * @param {?} day
     * @return {?}
     */
    CalendarViewModel.prototype.isDayInCalendarView = /**
     * Checks if the Day passed is in the CalendarView.
     * @param {?} day
     * @return {?}
     */
    function (day) {
        if (!this.calendar.isDayInCalendar(day)) {
            return false;
        }
        return true;
    };
    /**
     * Using the DayViewModels from the previous, current and next month, this function
     * generates the CalendarView.
     */
    /**
     * Using the DayViewModels from the previous, current and next month, this function
     * generates the CalendarView.
     * @param {?} prev
     * @param {?} curr
     * @param {?} next
     * @return {?}
     */
    CalendarViewModel.prototype.generateCalendarView = /**
     * Using the DayViewModels from the previous, current and next month, this function
     * generates the CalendarView.
     * @param {?} prev
     * @param {?} curr
     * @param {?} next
     * @return {?}
     */
    function (prev, curr, next) {
        /** @type {?} */
        var combinationArr = __spread(prev, curr, next);
        /** @type {?} */
        var calendarView = [];
        for (var i = 0; i < NO_OF_ROWS_IN_CALENDAR_VIEW; i++) {
            calendarView[i] = combinationArr.slice(i * NO_OF_DAYS_IN_A_WEEK, (i + 1) * NO_OF_DAYS_IN_A_WEEK);
        }
        return calendarView;
    };
    /**
     * Initialize the selected day if the day is in the calendar.
     */
    /**
     * Initialize the selected day if the day is in the calendar.
     * @return {?}
     */
    CalendarViewModel.prototype.initializeSelectedDay = /**
     * Initialize the selected day if the day is in the calendar.
     * @return {?}
     */
    function () {
        if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
            this.currMonthDayViews[this.selectedDay.date - 1].isSelected = true;
        }
    };
    /**
     * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
     * we check for the selected day. If selected day is not set then check if today is in the current
     * calendar. If not then just set the 15th of the current calendar month.
     */
    /**
     * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
     * we check for the selected day. If selected day is not set then check if today is in the current
     * calendar. If not then just set the 15th of the current calendar month.
     * @return {?}
     */
    CalendarViewModel.prototype.initializeFocusableDay = /**
     * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
     * we check for the selected day. If selected day is not set then check if today is in the current
     * calendar. If not then just set the 15th of the current calendar month.
     * @return {?}
     */
    function () {
        if (this.focusableDay && this.isDayInCalendarView(this.focusableDay)) {
            this.setFocusableFlag(this.focusableDay, true);
        }
        else if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
            this.setFocusableFlag(this.selectedDay, true);
            this.focusableDay = this.selectedDay.clone();
        }
        else if (this.isDayInCalendarView(this.today)) {
            this.setFocusableFlag(this.today, true);
            this.focusableDay = this.today.clone();
        }
        else {
            this.focusableDay = new DayModel(this.calendar.year, this.calendar.month, 15);
            this.setFocusableFlag(this.focusableDay, true);
        }
    };
    /**
     * @param {?} day
     * @param {?} flag
     * @return {?}
     */
    CalendarViewModel.prototype.setFocusableFlag = /**
     * @param {?} day
     * @param {?} flag
     * @return {?}
     */
    function (day, flag) {
        if (day) {
            this.currMonthDayViews[day.date - 1].isFocusable = flag;
        }
    };
    /**
     * Updates the focusable day in the calendar.
     */
    /**
     * Updates the focusable day in the calendar.
     * @param {?} day
     * @return {?}
     */
    CalendarViewModel.prototype.updateFocusableDay = /**
     * Updates the focusable day in the calendar.
     * @param {?} day
     * @return {?}
     */
    function (day) {
        this.setFocusableFlag(this.focusableDay, false);
        this.setFocusableFlag(day, true);
        this.focusableDay = day;
    };
    return CalendarViewModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service is responsible for:
 * 1. Initializing the displayed calendar.
 * 2. Moving the calendar to the next, previous or current months
 * 3. Managing the focused and selected day models.
 */
var DateNavigationService = /** @class */ (function () {
    function DateNavigationService() {
        /**
         * Variable to store today's date.
         */
        this._todaysFullDate = new Date();
        this._selectedDayChange = new Subject();
        this._displayedCalendarChange = new Subject();
        this._focusOnCalendarChange = new Subject();
        this._focusedDayChange = new Subject();
    }
    Object.defineProperty(DateNavigationService.prototype, "displayedCalendar", {
        get: /**
         * @return {?}
         */
        function () {
            return this._displayedCalendar;
        },
        enumerable: true,
        configurable: true
    });
    // not a setter because i want this to remain private
    // not a setter because i want this to remain private
    /**
     * @param {?} value
     * @return {?}
     */
    DateNavigationService.prototype.setDisplayedCalendar = 
    // not a setter because i want this to remain private
    /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!this._displayedCalendar.isEqual(value)) {
            this._displayedCalendar = value;
            this._displayedCalendarChange.next();
        }
    };
    /**
     * @return {?}
     */
    DateNavigationService.prototype.initializeTodaysDate = /**
     * @return {?}
     */
    function () {
        this._todaysFullDate = new Date();
        this._today = new DayModel(this._todaysFullDate.getFullYear(), this._todaysFullDate.getMonth(), this._todaysFullDate.getDate());
    };
    Object.defineProperty(DateNavigationService.prototype, "today", {
        get: /**
         * @return {?}
         */
        function () {
            return this._today;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateNavigationService.prototype, "selectedDayChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectedDayChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Notifies that the selected day has changed so that the date can be emitted to the user.
     * Note: Only to be called from day.ts
     */
    /**
     * Notifies that the selected day has changed so that the date can be emitted to the user.
     * Note: Only to be called from day.ts
     * @param {?} dayModel
     * @return {?}
     */
    DateNavigationService.prototype.notifySelectedDayChanged = /**
     * Notifies that the selected day has changed so that the date can be emitted to the user.
     * Note: Only to be called from day.ts
     * @param {?} dayModel
     * @return {?}
     */
    function (dayModel) {
        if (dayModel.isEqual(this.selectedDay)) {
            return;
        }
        this.selectedDay = dayModel;
        this._selectedDayChange.next(dayModel);
    };
    /**
     * Initializes the calendar based on the selected day.
     */
    /**
     * Initializes the calendar based on the selected day.
     * @return {?}
     */
    DateNavigationService.prototype.initializeCalendar = /**
     * Initializes the calendar based on the selected day.
     * @return {?}
     */
    function () {
        this.focusedDay = null; // Can be removed later on the store focus
        this.initializeTodaysDate();
        if (this.selectedDay) {
            this._displayedCalendar = new CalendarModel(this.selectedDay.year, this.selectedDay.month);
        }
        else {
            this._displayedCalendar = new CalendarModel(this.today.year, this.today.month);
        }
    };
    /**
     * @param {?} month
     * @return {?}
     */
    DateNavigationService.prototype.changeMonth = /**
     * @param {?} month
     * @return {?}
     */
    function (month) {
        this.setDisplayedCalendar(new CalendarModel(this._displayedCalendar.year, month));
    };
    /**
     * @param {?} year
     * @return {?}
     */
    DateNavigationService.prototype.changeYear = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this.setDisplayedCalendar(new CalendarModel(year, this._displayedCalendar.month));
    };
    /**
     * Moves the displayed calendar to the next month.
     */
    /**
     * Moves the displayed calendar to the next month.
     * @return {?}
     */
    DateNavigationService.prototype.moveToNextMonth = /**
     * Moves the displayed calendar to the next month.
     * @return {?}
     */
    function () {
        this.setDisplayedCalendar(this._displayedCalendar.nextMonth());
    };
    /**
     * Moves the displayed calendar to the previous month.
     */
    /**
     * Moves the displayed calendar to the previous month.
     * @return {?}
     */
    DateNavigationService.prototype.moveToPreviousMonth = /**
     * Moves the displayed calendar to the previous month.
     * @return {?}
     */
    function () {
        this.setDisplayedCalendar(this._displayedCalendar.previousMonth());
    };
    /**
     * Moves the displayed calendar to the current month and year.
     */
    /**
     * Moves the displayed calendar to the current month and year.
     * @return {?}
     */
    DateNavigationService.prototype.moveToCurrentMonth = /**
     * Moves the displayed calendar to the current month and year.
     * @return {?}
     */
    function () {
        if (!this.displayedCalendar.isDayInCalendar(this.today)) {
            this.setDisplayedCalendar(new CalendarModel(this.today.year, this.today.month));
        }
        this._focusOnCalendarChange.next();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    DateNavigationService.prototype.incrementFocusDay = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.focusedDay = this.focusedDay.incrementBy(value);
        if (this._displayedCalendar.isDayInCalendar(this.focusedDay)) {
            this._focusedDayChange.next(this.focusedDay);
        }
        else {
            this.setDisplayedCalendar(this.focusedDay.calendar);
        }
        this._focusOnCalendarChange.next();
    };
    Object.defineProperty(DateNavigationService.prototype, "displayedCalendarChange", {
        /**
         * This observable lets the subscriber know that the displayed calendar has changed.
         */
        get: /**
         * This observable lets the subscriber know that the displayed calendar has changed.
         * @return {?}
         */
        function () {
            return this._displayedCalendarChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateNavigationService.prototype, "focusOnCalendarChange", {
        /**
         * This observable lets the subscriber know that the focus should be applied on the calendar.
         */
        get: /**
         * This observable lets the subscriber know that the focus should be applied on the calendar.
         * @return {?}
         */
        function () {
            return this._focusOnCalendarChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateNavigationService.prototype, "focusedDayChange", {
        /**
         * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
         */
        get: /**
         * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
         * @return {?}
         */
        function () {
            return this._focusedDayChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    DateNavigationService.decorators = [
        { type: Injectable }
    ];
    return DateNavigationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service focuses the day that is focusable in the calendar.
 */
var DatepickerFocusService = /** @class */ (function () {
    function DatepickerFocusService(_ngZone, platformId) {
        this._ngZone = _ngZone;
        this.platformId = platformId;
    }
    /**
     * @param {?} elRef
     * @return {?}
     */
    DatepickerFocusService.prototype.focusCell = /**
     * @param {?} elRef
     * @return {?}
     */
    function (elRef) {
        var _this = this;
        this._ngZone.runOutsideAngular(function () {
            _this.ngZoneIsStableInBrowser().subscribe(function () {
                /** @type {?} */
                var focusEl = elRef.nativeElement.querySelector('[tabindex="0"]');
                if (focusEl) {
                    focusEl.focus();
                }
            });
        });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DatepickerFocusService.prototype.focusInput = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var _this = this;
        this._ngZone.runOutsideAngular(function () { return _this.ngZoneIsStableInBrowser().subscribe(function () { return element.focus(); }); });
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DatepickerFocusService.prototype.elementIsFocused = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return isPlatformBrowser(this.platformId) && document.activeElement === element;
    };
    /**
     * @return {?}
     */
    DatepickerFocusService.prototype.ngZoneIsStableInBrowser = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Credit: Material: https://github.com/angular/material2/blob/master/src/lib/datepicker/calendar.ts
        return this._ngZone.onStable.asObservable().pipe(first(), filter(function () { return isPlatformBrowser(_this.platformId); }));
    };
    DatepickerFocusService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DatepickerFocusService.ctorParameters = function () { return [
        { type: NgZone },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    return DatepickerFocusService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service extracts the Angular CLDR data needed by the datepicker.
 */
var LocaleHelperService = /** @class */ (function () {
    function LocaleHelperService(locale) {
        this.locale = locale;
        this._firstDayOfWeek = 0;
        this.initializeLocaleData();
    }
    Object.defineProperty(LocaleHelperService.prototype, "firstDayOfWeek", {
        get: /**
         * @return {?}
         */
        function () {
            return this._firstDayOfWeek;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LocaleHelperService.prototype, "localeDaysNarrow", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localeDaysNarrow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LocaleHelperService.prototype, "localeMonthsAbbreviated", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localeMonthsAbbreviated;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LocaleHelperService.prototype, "localeMonthsWide", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localeMonthsWide;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LocaleHelperService.prototype, "localeDateFormat", {
        get: /**
         * @return {?}
         */
        function () {
            return this._localeDateFormat;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initializes the locale data.
     */
    /**
     * Initializes the locale data.
     * @return {?}
     */
    LocaleHelperService.prototype.initializeLocaleData = /**
     * Initializes the locale data.
     * @return {?}
     */
    function () {
        // Order in which these functions is called is very important.
        this.initializeFirstDayOfWeek();
        this.initializeLocaleDateFormat();
        this.initializeLocaleMonthsAbbreviated();
        this.initializeLocaleMonthsWide();
        this.initializeLocaleDaysNarrow();
    };
    /**
     * Initialize day names in the TranslationWidth.Narrow format based on the locale.
     * eg: [S, M, T...] for en-US.
     */
    /**
     * Initialize day names in the TranslationWidth.Narrow format based on the locale.
     * eg: [S, M, T...] for en-US.
     * @return {?}
     */
    LocaleHelperService.prototype.initializeLocaleDaysNarrow = /**
     * Initialize day names in the TranslationWidth.Narrow format based on the locale.
     * eg: [S, M, T...] for en-US.
     * @return {?}
     */
    function () {
        // Get locale day names starting with Sunday
        /** @type {?} */
        var tempArr = getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Narrow).slice();
        // Get first day of the week based on the locale
        /** @type {?} */
        var firstDayOfWeek = this.firstDayOfWeek;
        // Rearrange the tempArr to start with the first day of the week based on the locale.
        if (firstDayOfWeek > 0) {
            /** @type {?} */
            var prevDays = tempArr.splice(0, firstDayOfWeek);
            tempArr.push.apply(tempArr, __spread(prevDays));
        }
        this._localeDaysNarrow = tempArr;
    };
    /**
     * Initializes the array of month names in the TranslationWidth.Abbreviated format.
     * e.g. `[Jan, Feb, ...]` for en-US
     */
    /**
     * Initializes the array of month names in the TranslationWidth.Abbreviated format.
     * e.g. `[Jan, Feb, ...]` for en-US
     * @return {?}
     */
    LocaleHelperService.prototype.initializeLocaleMonthsAbbreviated = /**
     * Initializes the array of month names in the TranslationWidth.Abbreviated format.
     * e.g. `[Jan, Feb, ...]` for en-US
     * @return {?}
     */
    function () {
        this._localeMonthsAbbreviated = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated).slice();
    };
    /**
     * Initializes the array of month names in the TranslationWidth.Wide format.
     * e.g. `[January, February, ...]` for en-US
     */
    /**
     * Initializes the array of month names in the TranslationWidth.Wide format.
     * e.g. `[January, February, ...]` for en-US
     * @return {?}
     */
    LocaleHelperService.prototype.initializeLocaleMonthsWide = /**
     * Initializes the array of month names in the TranslationWidth.Wide format.
     * e.g. `[January, February, ...]` for en-US
     * @return {?}
     */
    function () {
        this._localeMonthsWide = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Wide).slice();
    };
    /**
     * Initializes the first day of the week based on the locale.
     */
    /**
     * Initializes the first day of the week based on the locale.
     * @return {?}
     */
    LocaleHelperService.prototype.initializeFirstDayOfWeek = /**
     * Initializes the first day of the week based on the locale.
     * @return {?}
     */
    function () {
        this._firstDayOfWeek = getLocaleFirstDayOfWeek(this.locale);
    };
    /**
     * @return {?}
     */
    LocaleHelperService.prototype.initializeLocaleDateFormat = /**
     * @return {?}
     */
    function () {
        this._localeDateFormat = getLocaleDateFormat(this.locale, FormatWidth.Short);
    };
    LocaleHelperService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    LocaleHelperService.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
    ]; };
    return LocaleHelperService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrCalendar = /** @class */ (function () {
    function ClrCalendar(_localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
        this._localeHelperService = _localeHelperService;
        this._dateNavigationService = _dateNavigationService;
        this._datepickerFocusService = _datepickerFocusService;
        this._elRef = _elRef;
        this._subs = [];
        this.generateCalendarView();
        this.initializeSubscriptions();
    }
    Object.defineProperty(ClrCalendar.prototype, "localeDaysNarrow", {
        /**
         * Gets the locale days according to the TranslationWidth.Narrow format.
         */
        get: /**
         * Gets the locale days according to the TranslationWidth.Narrow format.
         * @return {?}
         */
        function () {
            return this._localeHelperService.localeDaysNarrow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrCalendar.prototype, "calendar", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dateNavigationService.displayedCalendar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrCalendar.prototype, "selectedDay", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dateNavigationService.selectedDay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrCalendar.prototype, "focusedDay", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dateNavigationService.focusedDay;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrCalendar.prototype, "today", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dateNavigationService.today;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize subscriptions to:
     * 1. update the calendar view model.
     * 2. update the focusable day in the calendar view model.
     * 3. focus on the focusable day in the calendar.
     */
    /**
     * Initialize subscriptions to:
     * 1. update the calendar view model.
     * 2. update the focusable day in the calendar view model.
     * 3. focus on the focusable day in the calendar.
     * @return {?}
     */
    ClrCalendar.prototype.initializeSubscriptions = /**
     * Initialize subscriptions to:
     * 1. update the calendar view model.
     * 2. update the focusable day in the calendar view model.
     * 3. focus on the focusable day in the calendar.
     * @return {?}
     */
    function () {
        var _this = this;
        this._subs.push(this._dateNavigationService.displayedCalendarChange.subscribe(function () {
            _this.generateCalendarView();
        }));
        this._subs.push(this._dateNavigationService.focusedDayChange.subscribe(function (focusedDay) {
            _this.calendarViewModel.updateFocusableDay(focusedDay);
        }));
        this._subs.push(this._dateNavigationService.focusOnCalendarChange.subscribe(function () {
            _this._datepickerFocusService.focusCell(_this._elRef);
        }));
    };
    /**
     * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
     */
    /**
     * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
     * @return {?}
     */
    ClrCalendar.prototype.generateCalendarView = /**
     * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
     * @return {?}
     */
    function () {
        this.calendarViewModel = new CalendarViewModel(this.calendar, this.selectedDay, this.focusedDay, this.today, this._localeHelperService.firstDayOfWeek);
    };
    /**
     * Delegates Keyboard arrow navigation to the DateNavigationService.
     */
    /**
     * Delegates Keyboard arrow navigation to the DateNavigationService.
     * @param {?} event
     * @return {?}
     */
    ClrCalendar.prototype.onKeyDown = /**
     * Delegates Keyboard arrow navigation to the DateNavigationService.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event && this.focusedDay) {
            switch (event.keyCode) {
                case UP_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(-1 * NO_OF_DAYS_IN_A_WEEK);
                    break;
                case DOWN_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(NO_OF_DAYS_IN_A_WEEK);
                    break;
                case LEFT_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(-1);
                    break;
                case RIGHT_ARROW:
                    event.preventDefault();
                    this._dateNavigationService.incrementFocusDay(1);
                    break;
                default:
                    break; // No default case. TSLint x-(
            }
        }
    };
    /**
     * Focuses on the focusable day when the Calendar View is initialized.
     */
    /**
     * Focuses on the focusable day when the Calendar View is initialized.
     * @return {?}
     */
    ClrCalendar.prototype.ngAfterViewInit = /**
     * Focuses on the focusable day when the Calendar View is initialized.
     * @return {?}
     */
    function () {
        this._datepickerFocusService.focusCell(this._elRef);
    };
    /**
     * Unsubscribe from subscriptions.
     */
    /**
     * Unsubscribe from subscriptions.
     * @return {?}
     */
    ClrCalendar.prototype.ngOnDestroy = /**
     * Unsubscribe from subscriptions.
     * @return {?}
     */
    function () {
        this._subs.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrCalendar.decorators = [
        { type: Component, args: [{ selector: 'clr-calendar', template: "<table class=\"calendar-table weekdays\">\n    <tr class=\"calendar-row\">\n        <td *ngFor=\"let day of localeDaysNarrow\" class=\"calendar-cell weekday\">\n            {{day}}\n        </td>\n    </tr>\n</table>\n<table\n    class=\"calendar-table calendar-dates\">\n    <tr class=\"calendar-row\" *ngFor=\"let row of calendarViewModel.calendarView\">\n        <td *ngFor=\"let dayView of row\" class=\"calendar-cell\">\n            <clr-day [clrDayView]=\"dayView\"></clr-day>\n        </td>\n    </tr>\n</table>\n" }] }
    ];
    /** @nocollapse */
    ClrCalendar.ctorParameters = function () { return [
        { type: LocaleHelperService },
        { type: DateNavigationService },
        { type: DatepickerFocusService },
        { type: ElementRef }
    ]; };
    ClrCalendar.propDecorators = {
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return ClrCalendar;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var FocusService = /** @class */ (function () {
    function FocusService() {
        this._focused = new BehaviorSubject(false);
    }
    Object.defineProperty(FocusService.prototype, "focusChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._focused.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FocusService.prototype, "focused", {
        set: /**
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            this._focused.next(state$$1);
        },
        enumerable: true,
        configurable: true
    });
    FocusService.decorators = [
        { type: Injectable }
    ];
    return FocusService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DateFormControlService = /** @class */ (function () {
    function DateFormControlService() {
        this._touchedChange = new Subject();
        this._dirtyChange = new Subject();
    }
    Object.defineProperty(DateFormControlService.prototype, "touchedChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._touchedChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateFormControlService.prototype, "dirtyChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dirtyChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DateFormControlService.prototype.markAsTouched = /**
     * @return {?}
     */
    function () {
        this._touchedChange.next();
    };
    /**
     * @return {?}
     */
    DateFormControlService.prototype.markAsDirty = /**
     * @return {?}
     */
    function () {
        this._dirtyChange.next();
    };
    DateFormControlService.decorators = [
        { type: Injectable }
    ];
    return DateFormControlService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DateIOService = /** @class */ (function () {
    function DateIOService(_localeHelperService) {
        this._localeHelperService = _localeHelperService;
        this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
        this.localeDisplayFormat = LITTLE_ENDIAN;
        this.delimiters = ['/', '/'];
        this.cldrLocaleDateFormat = this._localeHelperService.localeDateFormat;
        this.initializeLocaleDisplayFormat();
    }
    /**
     * @return {?}
     */
    DateIOService.prototype.initializeLocaleDisplayFormat = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var format = this.cldrLocaleDateFormat.toLocaleLowerCase();
        if (LITTLE_ENDIAN_REGEX.test(format)) {
            this.localeDisplayFormat = LITTLE_ENDIAN;
        }
        else if (MIDDLE_ENDIAN_REGEX.test(format)) {
            this.localeDisplayFormat = MIDDLE_ENDIAN;
        }
        else {
            // everything else is set to BIG-ENDIAN FORMAT
            this.localeDisplayFormat = BIG_ENDIAN;
        }
        this.extractDelimiters();
    };
    /**
     * @return {?}
     */
    DateIOService.prototype.extractDelimiters = /**
     * @return {?}
     */
    function () {
        if (this.cldrLocaleDateFormat) {
            // Sanitize Date Format. Remove RTL characters.
            // FIXME: When we support RTL, remove this and handle it correctly.
            /** @type {?} */
            var localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, '');
            /** @type {?} */
            var delimiters = localeFormat.split(DELIMITER_REGEX);
            // NOTE: The split from the CLDR date format should always result
            // in an arary with 4 elements. The 1st and the 2nd values are the delimiters
            // we will use in order.
            // Eg: "dd/MM/y".split(/d+|m+|y+/i) results in ["", "/", "/", ""]
            if (delimiters && delimiters.length === 4) {
                this.delimiters = [delimiters[1], delimiters[2]];
            }
            else {
                console.error('Unexpected date format received. Delimiters extracted: ', delimiters);
            }
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    DateIOService.prototype.toLocaleDisplayFormatString = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (date) {
            if (isNaN(date.getTime())) {
                return '';
            }
            /** @type {?} */
            var dateNo = date.getDate();
            /** @type {?} */
            var monthNo = date.getMonth() + 1;
            /** @type {?} */
            var dateStr = dateNo > 9 ? dateNo.toString() : '0' + dateNo;
            /** @type {?} */
            var monthStr = monthNo > 9 ? monthNo.toString() : '0' + monthNo;
            if (this.localeDisplayFormat === LITTLE_ENDIAN) {
                return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
            }
            else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
                return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
            }
            else {
                return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
            }
        }
        return '';
    };
    Object.defineProperty(DateIOService.prototype, "placeholderText", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var format = this.localeDisplayFormat.format;
            return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if the month entered by the user is valid or not.
     * Note: Month is 0 based.
     */
    /**
     * Checks if the month entered by the user is valid or not.
     * Note: Month is 0 based.
     * @param {?} month
     * @return {?}
     */
    DateIOService.prototype.isValidMonth = /**
     * Checks if the month entered by the user is valid or not.
     * Note: Month is 0 based.
     * @param {?} month
     * @return {?}
     */
    function (month) {
        return month > -1 && month < 12;
    };
    /**
     * Checks if the date is valid depending on the year and month provided.
     */
    /**
     * Checks if the date is valid depending on the year and month provided.
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    DateIOService.prototype.isValidDate = /**
     * Checks if the date is valid depending on the year and month provided.
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    function (year, month, date) {
        return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
    };
    /**
     * Validates the parameters provided and returns the date.
     * If the parameters are not
     * valid then return null.
     * NOTE: (Month here is 1 based since the user has provided that as an input)
     */
    /**
     * Validates the parameters provided and returns the date.
     * If the parameters are not
     * valid then return null.
     * NOTE: (Month here is 1 based since the user has provided that as an input)
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    DateIOService.prototype.validateAndGetDate = /**
     * Validates the parameters provided and returns the date.
     * If the parameters are not
     * valid then return null.
     * NOTE: (Month here is 1 based since the user has provided that as an input)
     * @param {?} year
     * @param {?} month
     * @param {?} date
     * @return {?}
     */
    function (year, month, date) {
        // I don't know whats wrong with the TS compiler. It throws an error if I write
        // the below if statement. The error is:
        // Operator '!==' cannot be applied to types '2' and '4'
        // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
        /*
            if (year.length !== 2 || year.length !== 4) {
                return null;
            }
            */
        // I don't know whats wrong with the TS compiler. It throws an error if I write
        // the below if statement. The error is:
        // Operator '!==' cannot be applied to types '2' and '4'
        // More info here: https://github.com/Microsoft/TypeScript/issues/12794#issuecomment-270342936
        /*
                if (year.length !== 2 || year.length !== 4) {
                    return null;
                }
                */
        // Instead I have to write the logic like this x-(
        /** @type {?} */
        var y = +year;
        /** @type {?} */
        var m = +month - 1;
        // month is 0 based
        /** @type {?} */
        var d = +date;
        if (!this.isValidMonth(m) || !this.isValidDate(y, m, d)) {
            return null;
        }
        /** @type {?} */
        var result = parseToFourDigitYear(y);
        return result !== -1 ? new Date(result, m, d) : null;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    DateIOService.prototype.getDateValueFromDateString = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (!date) {
            return null;
        }
        /** @type {?} */
        var dateParts = date.match(USER_INPUT_REGEX);
        if (!dateParts || dateParts.length !== 3) {
            return null;
        }
        var _a = __read(dateParts, 3), firstPart = _a[0], secondPart = _a[1], thirdPart = _a[2];
        if (this.localeDisplayFormat === LITTLE_ENDIAN) {
            // secondPart is month && firstPart is date
            return this.validateAndGetDate(thirdPart, secondPart, firstPart);
        }
        else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
            // firstPart is month && secondPart is date
            return this.validateAndGetDate(thirdPart, firstPart, secondPart);
        }
        else {
            // secondPart is month && thirdPart is date
            return this.validateAndGetDate(firstPart, secondPart, thirdPart);
        }
    };
    DateIOService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DateIOService.ctorParameters = function () { return [
        { type: LocaleHelperService }
    ]; };
    return DateIOService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
// iPad mini screen width
// http://stephen.io/mediaqueries/#iPadMini
/** @type {?} */
var DATEPICKER_ENABLE_BREAKPOINT = 768;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DatepickerEnabledService = /** @class */ (function () {
    function DatepickerEnabledService(_document) {
        this._document = _document;
        this._isUserAgentMobile = false;
        if (this._document) {
            this._isUserAgentMobile = MOBILE_USERAGENT_REGEX.test(_document.defaultView.navigator.userAgent);
            this._innerWidth = _document.defaultView.innerWidth;
        }
    }
    Object.defineProperty(DatepickerEnabledService.prototype, "isEnabled", {
        /**
         * Returns if the calendar should be active or not.
         * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
         * then the calendar is inactive.
         */
        get: /**
         * Returns if the calendar should be active or not.
         * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
         * then the calendar is inactive.
         * @return {?}
         */
        function () {
            // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent
            // What they recommend is:
            //"In summary, we recommend looking for the string 'Mobi'
            // anywhere in the User Agent to detect a mobile device."
            if (this._document) {
                if (this._innerWidth < DATEPICKER_ENABLE_BREAKPOINT && this._isUserAgentMobile) {
                    return false;
                }
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    DatepickerEnabledService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DatepickerEnabledService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    return DatepickerEnabledService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This component contains two template for the old and new forms layouts.
 * When it is time to remove the old forms layouts support, remove the ng-templates
 * and ng-container, and just keep the inner content of the #newLayout as the template
 * and move the ng-content for clrDate.
 */
var ClrDateContainer = /** @class */ (function () {
    function ClrDateContainer(_ifOpenService, _dateNavigationService, _datepickerEnabledService, dateFormControlService, commonStrings, ifErrorService, focusService, controlClassService, layoutService, newFormsLayout, ngControlService) {
        var _this = this;
        this._ifOpenService = _ifOpenService;
        this._dateNavigationService = _dateNavigationService;
        this._datepickerEnabledService = _datepickerEnabledService;
        this.dateFormControlService = dateFormControlService;
        this.commonStrings = commonStrings;
        this.ifErrorService = ifErrorService;
        this.focusService = focusService;
        this.controlClassService = controlClassService;
        this.layoutService = layoutService;
        this.newFormsLayout = newFormsLayout;
        this.ngControlService = ngControlService;
        this._dynamic = false;
        this.invalid = false;
        this.focus = false;
        this.subscriptions = [];
        this.subscriptions.push(this._ifOpenService.openChange.subscribe(function (open) {
            if (open) {
                _this.initializeCalendar();
            }
        }));
        this.subscriptions.push(this.focusService.focusChange.subscribe(function (state$$1) {
            _this.focus = state$$1;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            _this.control = control;
        }));
    }
    /**
     * @return {?}
     */
    ClrDateContainer.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            _this.invalid = invalid;
        }));
    };
    /**
     * Returns the classes to apply to the control
     */
    /**
     * Returns the classes to apply to the control
     * @return {?}
     */
    ClrDateContainer.prototype.controlClass = /**
     * Returns the classes to apply to the control
     * @return {?}
     */
    function () {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    };
    /**
     * Determines if the control needs to add grid classes
     */
    /**
     * Determines if the control needs to add grid classes
     * @return {?}
     */
    ClrDateContainer.prototype.addGrid = /**
     * Determines if the control needs to add grid classes
     * @return {?}
     */
    function () {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    };
    Object.defineProperty(ClrDateContainer.prototype, "isEnabled", {
        /**
         * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
         */
        get: /**
         * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
         * @return {?}
         */
        function () {
            return this._datepickerEnabledService.isEnabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
     */
    /**
     * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
     * @return {?}
     */
    ClrDateContainer.prototype.initializeCalendar = /**
     * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
     * @return {?}
     */
    function () {
        this._dateNavigationService.initializeCalendar();
    };
    /**
     * Toggles the Datepicker Popover.
     */
    /**
     * Toggles the Datepicker Popover.
     * @param {?} event
     * @return {?}
     */
    ClrDateContainer.prototype.toggleDatepicker = /**
     * Toggles the Datepicker Popover.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._ifOpenService.toggleWithEvent(event);
        this.dateFormControlService.markAsTouched();
    };
    /**
     * Unsubscribe from subscriptions.
     */
    /**
     * Unsubscribe from subscriptions.
     * @return {?}
     */
    ClrDateContainer.prototype.ngOnDestroy = /**
     * Unsubscribe from subscriptions.
     * @return {?}
     */
    function () {
        this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
    };
    ClrDateContainer.decorators = [
        { type: Component, args: [{
                    selector: 'clr-date-container',
                    template: "\n    <ng-template #oldLayout>\n        <ng-content></ng-content>\n        <ng-container *ngTemplateOutlet=\"clrDate\"></ng-container>\n        <button\n            type=\"button\"\n            class=\"datepicker-trigger\"\n            (click)=\"toggleDatepicker($event)\"\n            *ngIf=\"isEnabled\">\n            <clr-icon shape=\"calendar\" class=\"datepicker-trigger-icon\" [attr.title]=\"commonStrings.open\"></clr-icon>\n        </button>\n        <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>\n    </ng-template>\n    \n    <ng-template #newLayout>\n      <ng-content select=\"label\"></ng-content>\n      <label *ngIf=\"!label && addGrid()\"></label>\n      <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n        <div class=\"clr-input-wrapper\">\n          <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n            <ng-container *ngTemplateOutlet=\"clrDate\"></ng-container>\n            <button type=\"button\" class=\"clr-input-group-icon-action\" (click)=\"toggleDatepicker($event)\" *ngIf=\"isEnabled\" [attr.title]=\"commonStrings.open\" [disabled]=\"control?.disabled\">\n              <clr-icon shape=\"calendar\"></clr-icon>\n            </button>\n            <clr-datepicker-view-manager *clrIfOpen clrFocusTrap></clr-datepicker-view-manager>\n          </div>\n          <clr-icon class=\"clr-validate-icon\" shape=\"exclamation-circle\"></clr-icon>\n        </div>\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </ng-template>\n    \n    <ng-template #clrDate>\n      <ng-content select=\"[clrDate]\"></ng-content>\n    </ng-template>\n    \n    <ng-container *ngIf=\"newFormsLayout; then newLayout else oldLayout\"></ng-container>\n    ",
                    providers: [
                        ControlIdService,
                        IfOpenService,
                        LocaleHelperService,
                        IfErrorService,
                        ControlClassService,
                        FocusService,
                        NgControlService,
                        DateIOService,
                        DateNavigationService,
                        DatepickerEnabledService,
                        DateFormControlService,
                    ],
                    host: {
                        '[class.date-container]': '!newFormsLayout',
                        '[class.clr-form-control-disabled]': 'control?.disabled',
                        '[class.clr-form-control]': 'newFormsLayout',
                        '[class.clr-row]': 'addGrid()',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrDateContainer.ctorParameters = function () { return [
        { type: IfOpenService },
        { type: DateNavigationService },
        { type: DatepickerEnabledService },
        { type: DateFormControlService },
        { type: ClrCommonStrings },
        { type: IfErrorService },
        { type: FocusService },
        { type: ControlClassService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [IS_NEW_FORMS_LAYOUT,] }] },
        { type: NgControlService }
    ]; };
    ClrDateContainer.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }]
    };
    return ClrDateContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// There are four ways the datepicker value is set
// 1. Value set by user typing into text input as a string ex: '01/28/2015'
// 2. Value set explicitly by Angular Forms APIs as a string ex: '01/28/2015'
// 3. Value set by user via datepicker UI as a Date Object
// 4. Value set via `clrDate` input as a Date Object
var ClrDateInput = /** @class */ (function (_super) {
    __extends(ClrDateInput, _super);
    function ClrDateInput(viewContainerRef, injector, el, renderer, control, container, dateIOService, dateNavigationService, datepickerEnabledService, dateFormControlService, platformId, focusService, newFormsLayout, datepickerFocusService) {
        var _this = _super.call(this, viewContainerRef, ClrDateContainer, injector, control, renderer, el) || this;
        _this.el = el;
        _this.renderer = renderer;
        _this.control = control;
        _this.container = container;
        _this.dateIOService = dateIOService;
        _this.dateNavigationService = dateNavigationService;
        _this.datepickerEnabledService = datepickerEnabledService;
        _this.dateFormControlService = dateFormControlService;
        _this.platformId = platformId;
        _this.focusService = focusService;
        _this.newFormsLayout = newFormsLayout;
        _this.datepickerFocusService = datepickerFocusService;
        _this.dateChange = new EventEmitter(false);
        _this.index = 4;
        return _this;
    }
    Object.defineProperty(ClrDateInput.prototype, "date", {
        set: /**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            if (this.previousDateChange !== date) {
                this.updateDate(this.getValidDateValueFromDate(date));
            }
            if (!this.initialClrDateInputValue) {
                this.initialClrDateInputValue = date;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDateInput.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.setFormLayout();
        this.populateServicesFromContainerComponent();
        this.subscriptions.push(this.listenForUserSelectedDayChanges(), this.listenForControlValueChanges(), this.listenForTouchChanges(), this.listenForDirtyChanges(), this.listenForInputRefocus());
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // I don't know why I have to do this but after using the new HostWrapping Module I have to delay the processing
        // of the initial Input set by the user to here. If I do not 2 issues occur:
        // 1. The Input setter is called before ngOnInit. ngOnInit initializes the services without which the setter fails.
        // 2. The Renderer doesn't work before ngAfterViewInit (It used to before the new HostWrapping Module for some reason).
        // I need the renderer to set the value property on the input to make sure that if the user has supplied a Date
        // input object, we reflect it with the right date on the input field using the IO service. I am not sure if
        // these are major issues or not but just noting them down here.
        this.processInitialInputs();
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.setFocusStates = /**
     * @return {?}
     */
    function () {
        this.setFocus(true);
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.triggerValidation = /**
     * @return {?}
     */
    function () {
        _super.prototype.triggerValidation.call(this);
        this.setFocus(false);
    };
    Object.defineProperty(ClrDateInput.prototype, "placeholderText", {
        get: /**
         * @return {?}
         */
        function () {
            return this.placeholder ? this.placeholder : this.dateIOService.placeholderText;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDateInput.prototype, "inputType", {
        get: /**
         * @return {?}
         */
        function () {
            return isPlatformBrowser(this.platformId) && this.usingNativeDatepicker() ? 'date' : 'text';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} target
     * @return {?}
     */
    ClrDateInput.prototype.onValueChange = /**
     * @param {?} target
     * @return {?}
     */
    function (target) {
        /** @type {?} */
        var validDateValue = this.dateIOService.getDateValueFromDateString(target.value);
        if (this.usingClarityDatepicker() && validDateValue) {
            this.updateDate(validDateValue, true);
        }
        else if (this.usingNativeDatepicker()) {
            var _a = __read(target.value.split('-'), 3), year = _a[0], month = _a[1], day = _a[2];
            this.updateDate(new Date(+year, +month - 1, +day), true);
        }
        else {
            this.emitDateOutput(null);
        }
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.usingClarityDatepicker = /**
     * @return {?}
     */
    function () {
        return this.datepickerEnabledService.isEnabled;
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.usingNativeDatepicker = /**
     * @return {?}
     */
    function () {
        return !this.datepickerEnabledService.isEnabled;
    };
    /**
     * @param {?} focus
     * @return {?}
     */
    ClrDateInput.prototype.setFocus = /**
     * @param {?} focus
     * @return {?}
     */
    function (focus) {
        if (this.focusService) {
            this.focusService.focused = focus;
        }
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.populateServicesFromContainerComponent = /**
     * @return {?}
     */
    function () {
        if (!this.container) {
            this.dateIOService = this.getProviderFromContainer(DateIOService);
            this.dateNavigationService = this.getProviderFromContainer(DateNavigationService);
            this.datepickerEnabledService = this.getProviderFromContainer(DatepickerEnabledService);
            this.dateFormControlService = this.getProviderFromContainer(DateFormControlService);
        }
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.processInitialInputs = /**
     * @return {?}
     */
    function () {
        if (this.datepickerHasFormControl()) {
            this.updateDate(this.dateIOService.getDateValueFromDateString(this.control.value));
        }
        else {
            this.updateDate(this.initialClrDateInputValue);
        }
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.setFormLayout = /**
     * @return {?}
     */
    function () {
        if (this.clrNewLayout !== undefined) {
            this.newFormsLayout = !!this.clrNewLayout;
        }
    };
    /**
     * @param {?} value
     * @param {?=} setByUserInteraction
     * @return {?}
     */
    ClrDateInput.prototype.updateDate = /**
     * @param {?} value
     * @param {?=} setByUserInteraction
     * @return {?}
     */
    function (value, setByUserInteraction) {
        if (setByUserInteraction === void 0) { setByUserInteraction = false; }
        /** @type {?} */
        var date = this.getValidDateValueFromDate(value);
        if (setByUserInteraction) {
            this.emitDateOutput(date);
        }
        else {
            this.previousDateChange = date;
        }
        if (this.dateNavigationService) {
            this.dateNavigationService.selectedDay = date
                ? new DayModel(date.getFullYear(), date.getMonth(), date.getDate())
                : null;
        }
        this.updateInput(date);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    ClrDateInput.prototype.updateInput = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (date) {
            /** @type {?} */
            var dateString = this.dateIOService.toLocaleDisplayFormatString(date);
            if (this.datepickerHasFormControl() && dateString !== this.control.value) {
                this.control.control.setValue(dateString);
            }
            else if (this.usingNativeDatepicker()) {
                this.renderer.setProperty(this.el.nativeElement, 'valueAsDate', date);
            }
            else {
                this.renderer.setProperty(this.el.nativeElement, 'value', dateString);
            }
        }
        else {
            this.renderer.setProperty(this.el.nativeElement, 'value', '');
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    ClrDateInput.prototype.getValidDateValueFromDate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (this.dateIOService) {
            /** @type {?} */
            var dateString = this.dateIOService.toLocaleDisplayFormatString(date);
            return this.dateIOService.getDateValueFromDateString(dateString);
        }
        else {
            return null;
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    ClrDateInput.prototype.emitDateOutput = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (!datesAreEqual(date, this.previousDateChange)) {
            this.dateChange.emit(date);
            this.previousDateChange = date;
        }
        else if (!date && this.previousDateChange) {
            this.dateChange.emit(null);
            this.previousDateChange = null;
        }
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.datepickerHasFormControl = /**
     * @return {?}
     */
    function () {
        return !!this.control;
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.listenForControlValueChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return of(this.datepickerHasFormControl())
            .pipe(filter(function (hasControl) { return hasControl; }), switchMap(function () { return _this.control.valueChanges; }), 
        // only update date value if not being set by user
        filter(function () { return !_this.datepickerFocusService.elementIsFocused(_this.el.nativeElement); }))
            .subscribe(function (value) { return _this.updateDate(_this.dateIOService.getDateValueFromDateString(value)); });
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.listenForUserSelectedDayChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this.dateNavigationService.selectedDayChange.subscribe(function (dayModel) { return _this.updateDate(dayModel.toDate(), true); });
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.listenForTouchChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this.dateFormControlService.touchedChange
            .pipe(filter(function () { return _this.datepickerHasFormControl(); }))
            .subscribe(function () { return _this.control.control.markAsTouched(); });
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.listenForDirtyChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this.dateFormControlService.dirtyChange
            .pipe(filter(function () { return _this.datepickerHasFormControl(); }))
            .subscribe(function () { return _this.control.control.markAsDirty(); });
    };
    /**
     * @return {?}
     */
    ClrDateInput.prototype.listenForInputRefocus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this.dateNavigationService.selectedDayChange
            .pipe(filter(function (date) { return !!date; }))
            .subscribe(function (v) { return _this.datepickerFocusService.focusInput(_this.el.nativeElement); });
    };
    ClrDateInput.decorators = [
        { type: Directive, args: [{
                    selector: '[clrDate]',
                    host: {
                        '[class.date-input]': '!newFormsLayout',
                        '[class.clr-input]': 'newFormsLayout',
                    },
                    providers: [DatepickerFocusService],
                },] }
    ];
    /** @nocollapse */
    ClrDateInput.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Injector },
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: ClrDateContainer, decorators: [{ type: Optional }] },
        { type: DateIOService, decorators: [{ type: Optional }] },
        { type: DateNavigationService, decorators: [{ type: Optional }] },
        { type: DatepickerEnabledService, decorators: [{ type: Optional }] },
        { type: DateFormControlService, decorators: [{ type: Optional }] },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: FocusService, decorators: [{ type: Optional }] },
        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [IS_NEW_FORMS_LAYOUT,] }] },
        { type: DatepickerFocusService }
    ]; };
    ClrDateInput.propDecorators = {
        placeholder: [{ type: Input }],
        clrNewLayout: [{ type: Input }],
        dateChange: [{ type: Output, args: ['clrDateChange',] }],
        date: [{ type: Input, args: ['clrDate',] }],
        setFocusStates: [{ type: HostListener, args: ['focus',] }],
        triggerValidation: [{ type: HostListener, args: ['blur',] }],
        placeholderText: [{ type: HostBinding, args: ['attr.placeholder',] }],
        inputType: [{ type: HostBinding, args: ['attr.type',] }],
        onValueChange: [{ type: HostListener, args: ['change', ['$event.target'],] }]
    };
    return ClrDateInput;
}(WrappedFormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// Literally any annotation would work here, but writing our own @HoneyBadger annotation feels overkill.
/**
 * @abstract
 */
var AbstractPopover = /** @class */ (function () {
    function AbstractPopover(injector, parentHost) {
        var _this = this;
        this.parentHost = parentHost;
        this.updateAnchor = false;
        this.popoverOptions = {};
        /*
             * Until https://github.com/angular/angular/issues/8785 is supported, we don't have any way to instantiate
             * a separate directive on the host. So let's do dirty but performant for now.
             */
        this.closeOnOutsideClick = false;
        this.el = injector.get(ElementRef);
        this.ifOpenService = injector.get(IfOpenService);
        this.renderer = injector.get(Renderer2);
        // Default anchor is the parent host
        this.anchorElem = parentHost.nativeElement;
        this.popoverInstance = new Popover(this.el.nativeElement);
        this.subscription = this.ifOpenService.openChange.subscribe(function (change) {
            if (change) {
                _this.anchor();
                _this.attachESCListener();
            }
            else {
                _this.release();
                _this.detachESCListener();
            }
        });
        if (this.ifOpenService.open) {
            this.anchor();
            this.attachESCListener();
        }
    }
    /**
     * @return {?}
     */
    AbstractPopover.prototype.anchor = /**
     * @return {?}
     */
    function () {
        this.updateAnchor = true;
        // Ugh
        this.ignore = this.ifOpenService.originalEvent;
    };
    /**
     * @return {?}
     */
    AbstractPopover.prototype.release = /**
     * @return {?}
     */
    function () {
        this.detachOutsideClickListener();
        this.popoverInstance.release();
    };
    /**
     * @return {?}
     */
    AbstractPopover.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.updateAnchor) {
            this.updateAnchor = false;
            this.popoverInstance
                .anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions)
                .subscribe(function () {
                // if a scroll event is detected, close the popover
                _this.ifOpenService.open = false;
            });
            this.attachOutsideClickListener();
        }
    };
    /**
     * @return {?}
     */
    AbstractPopover.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.release();
        this.detachESCListener();
        this.subscription.unsubscribe();
    };
    Object.defineProperty(AbstractPopover.prototype, "isOffScreen", {
        /*
           * Fallback to hide when *clrIfOpen is not being used
           */
        get: /*
             * Fallback to hide when *clrIfOpen is not being used
             */
        /**
         * @return {?}
         */
        function () {
            return this.ifOpenService.open ? false : true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AbstractPopover.prototype.attachESCListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.documentESCListener = this.renderer.listen('document', 'keydown', function (event) {
            if (event && event.keyCode === ESC) {
                _this.ifOpenService.open = false;
            }
        });
    };
    /**
     * @return {?}
     */
    AbstractPopover.prototype.detachESCListener = /**
     * @return {?}
     */
    function () {
        if (this.documentESCListener) {
            this.documentESCListener();
            delete this.documentESCListener;
        }
    };
    /**
     * @return {?}
     */
    AbstractPopover.prototype.attachOutsideClickListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.closeOnOutsideClick) {
            this.hostClickListener = this.renderer.listen(this.el.nativeElement, 'click', function (event) { return (_this.ignore = event); });
            if (this.ignoredElement) {
                this.ignoredElementClickListener = this.renderer.listen(this.ignoredElement, 'click', function (event) { return (_this.ignore = event); });
            }
            this.documentClickListener = this.renderer.listen('document', 'click', function (event) {
                if (event === _this.ignore) {
                    delete _this.ignore;
                }
                else {
                    _this.ifOpenService.open = false;
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AbstractPopover.prototype.detachOutsideClickListener = /**
     * @return {?}
     */
    function () {
        if (this.closeOnOutsideClick) {
            if (this.hostClickListener) {
                this.hostClickListener();
                delete this.hostClickListener;
            }
            if (this.ignoredElementClickListener) {
                this.ignoredElementClickListener();
                delete this.ignoredElementClickListener;
            }
            if (this.documentClickListener) {
                this.documentClickListener();
                delete this.documentClickListener;
            }
        }
    };
    AbstractPopover.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AbstractPopover.ctorParameters = function () { return [
        { type: Injector },
        { type: ElementRef, decorators: [{ type: SkipSelf }] }
    ]; };
    AbstractPopover.propDecorators = {
        isOffScreen: [{ type: HostBinding, args: ['class.is-off-screen',] }]
    };
    return AbstractPopover;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This service manages which view is visible in the datepicker popover.
 */
var ViewManagerService = /** @class */ (function () {
    function ViewManagerService() {
        this._currentView = "DAYVIEW" /* DAYVIEW */;
    }
    Object.defineProperty(ViewManagerService.prototype, "isDayView", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentView === "DAYVIEW" /* DAYVIEW */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewManagerService.prototype, "isYearView", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentView === "YEARVIEW" /* YEARVIEW */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ViewManagerService.prototype, "isMonthView", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentView === "MONTHVIEW" /* MONTHVIEW */;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ViewManagerService.prototype.changeToMonthView = /**
     * @return {?}
     */
    function () {
        this._currentView = "MONTHVIEW" /* MONTHVIEW */;
    };
    /**
     * @return {?}
     */
    ViewManagerService.prototype.changeToYearView = /**
     * @return {?}
     */
    function () {
        this._currentView = "YEARVIEW" /* YEARVIEW */;
    };
    /**
     * @return {?}
     */
    ViewManagerService.prototype.changeToDayView = /**
     * @return {?}
     */
    function () {
        this._currentView = "DAYVIEW" /* DAYVIEW */;
    };
    ViewManagerService.decorators = [
        { type: Injectable }
    ];
    return ViewManagerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatepickerViewManager = /** @class */ (function (_super) {
    __extends(ClrDatepickerViewManager, _super);
    function ClrDatepickerViewManager(parent, _injector, _viewManagerService) {
        var _this = _super.call(this, _injector, parent) || this;
        _this._viewManagerService = _viewManagerService;
        _this.configurePopover();
        return _this;
    }
    /**
     * Configure Popover Direction and Close indicators
     */
    /**
     * Configure Popover Direction and Close indicators
     * @return {?}
     */
    ClrDatepickerViewManager.prototype.configurePopover = /**
     * Configure Popover Direction and Close indicators
     * @return {?}
     */
    function () {
        this.anchorPoint = Point.BOTTOM_LEFT;
        this.popoverPoint = Point.LEFT_TOP;
        this.closeOnOutsideClick = true;
    };
    Object.defineProperty(ClrDatepickerViewManager.prototype, "isMonthView", {
        /**
         * Returns if the current view is the monthpicker.
         */
        get: /**
         * Returns if the current view is the monthpicker.
         * @return {?}
         */
        function () {
            return this._viewManagerService.isMonthView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatepickerViewManager.prototype, "isYearView", {
        /**
         * Returns if the current view is the yearpicker.
         */
        get: /**
         * Returns if the current view is the yearpicker.
         * @return {?}
         */
        function () {
            return this._viewManagerService.isYearView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatepickerViewManager.prototype, "isDayView", {
        /**
         * Returns if the current view is the daypicker.
         */
        get: /**
         * Returns if the current view is the daypicker.
         * @return {?}
         */
        function () {
            return this._viewManagerService.isDayView;
        },
        enumerable: true,
        configurable: true
    });
    ClrDatepickerViewManager.decorators = [
        { type: Component, args: [{
                    selector: 'clr-datepicker-view-manager',
                    template: "<!--\n* Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n* This software is released under MIT license.\n* The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<clr-monthpicker *ngIf=\"isMonthView\"></clr-monthpicker>\n<clr-yearpicker *ngIf=\"isYearView\"></clr-yearpicker>\n<clr-daypicker *ngIf=\"isDayView\"></clr-daypicker>\n",
                    providers: [ViewManagerService, DatepickerFocusService],
                    host: { '[class.datepicker]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrDatepickerViewManager.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: SkipSelf }] },
        { type: Injector },
        { type: ViewManagerService }
    ]; };
    return ClrDatepickerViewManager;
}(AbstractPopover));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDay = /** @class */ (function () {
    function ClrDay(_dateNavigationService, _ifOpenService, dateFormControlService) {
        this._dateNavigationService = _dateNavigationService;
        this._ifOpenService = _ifOpenService;
        this.dateFormControlService = dateFormControlService;
    }
    /**
     * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
     */
    /**
     * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
     * @return {?}
     */
    ClrDay.prototype.onDayViewFocus = /**
     * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
     * @return {?}
     */
    function () {
        this._dateNavigationService.focusedDay = this.dayView.dayModel;
    };
    /**
     * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
     */
    /**
     * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
     * @return {?}
     */
    ClrDay.prototype.selectDay = /**
     * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var day = this.dayView.dayModel;
        this._dateNavigationService.notifySelectedDayChanged(day);
        this.dateFormControlService.markAsDirty();
        this._ifOpenService.open = false;
    };
    ClrDay.decorators = [
        { type: Component, args: [{
                    selector: 'clr-day',
                    template: "\n        <button\n            class=\"day-btn\"\n            type=\"button\"\n            [class.is-today]=\"dayView.isTodaysDate\"\n            [class.is-disabled]=\"dayView.isDisabled\"\n            [class.is-selected]=\"dayView.isSelected\"\n            [attr.tabindex]=\"dayView.tabIndex\"\n            (click)=\"selectDay()\"\n            (focus)=\"onDayViewFocus()\">\n            {{dayView.dayModel.date}}\n        </button>\n    ",
                    host: { '[class.day]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrDay.ctorParameters = function () { return [
        { type: DateNavigationService },
        { type: IfOpenService },
        { type: DateFormControlService }
    ]; };
    ClrDay.propDecorators = {
        dayView: [{ type: Input, args: ['clrDayView',] }]
    };
    return ClrDay;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDaypicker = /** @class */ (function () {
    function ClrDaypicker(_viewManagerService, _dateNavigationService, _localeHelperService, commonStrings) {
        this._viewManagerService = _viewManagerService;
        this._dateNavigationService = _dateNavigationService;
        this._localeHelperService = _localeHelperService;
        this.commonStrings = commonStrings;
    }
    /**
     * Calls the ViewManagerService to change to the monthpicker view.
     */
    /**
     * Calls the ViewManagerService to change to the monthpicker view.
     * @return {?}
     */
    ClrDaypicker.prototype.changeToMonthView = /**
     * Calls the ViewManagerService to change to the monthpicker view.
     * @return {?}
     */
    function () {
        this._viewManagerService.changeToMonthView();
    };
    /**
     * Calls the ViewManagerService to change to the yearpicker view.
     */
    /**
     * Calls the ViewManagerService to change to the yearpicker view.
     * @return {?}
     */
    ClrDaypicker.prototype.changeToYearView = /**
     * Calls the ViewManagerService to change to the yearpicker view.
     * @return {?}
     */
    function () {
        this._viewManagerService.changeToYearView();
    };
    Object.defineProperty(ClrDaypicker.prototype, "calendarMonth", {
        /**
         * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
         */
        get: /**
         * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
         * @return {?}
         */
        function () {
            return this._localeHelperService.localeMonthsAbbreviated[this._dateNavigationService.displayedCalendar.month];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDaypicker.prototype, "calendarYear", {
        /**
         * Returns the year value of the calendar.
         */
        get: /**
         * Returns the year value of the calendar.
         * @return {?}
         */
        function () {
            return this._dateNavigationService.displayedCalendar.year;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calls the DateNavigationService to move to the next month.
     */
    /**
     * Calls the DateNavigationService to move to the next month.
     * @return {?}
     */
    ClrDaypicker.prototype.nextMonth = /**
     * Calls the DateNavigationService to move to the next month.
     * @return {?}
     */
    function () {
        this._dateNavigationService.moveToNextMonth();
    };
    /**
     * Calls the DateNavigationService to move to the previous month.
     */
    /**
     * Calls the DateNavigationService to move to the previous month.
     * @return {?}
     */
    ClrDaypicker.prototype.previousMonth = /**
     * Calls the DateNavigationService to move to the previous month.
     * @return {?}
     */
    function () {
        this._dateNavigationService.moveToPreviousMonth();
    };
    /**
     * Calls the DateNavigationService to move to the current month.
     */
    /**
     * Calls the DateNavigationService to move to the current month.
     * @return {?}
     */
    ClrDaypicker.prototype.currentMonth = /**
     * Calls the DateNavigationService to move to the current month.
     * @return {?}
     */
    function () {
        this._dateNavigationService.moveToCurrentMonth();
    };
    ClrDaypicker.decorators = [
        { type: Component, args: [{ selector: 'clr-daypicker', template: "<div class=\"calendar-header\">\n    <div class=\"calendar-pickers\">\n        <button class=\"calendar-btn monthpicker-trigger\" type=\"button\" (click)=\"changeToMonthView()\">\n            {{calendarMonth}}\n        </button>\n        <button class=\"calendar-btn yearpicker-trigger\" type=\"button\" (click)=\"changeToYearView()\">\n            {{calendarYear}}\n        </button>\n    </div>\n    <div class=\"calendar-switchers\">\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"previousMonth()\">\n            <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n        </button>\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"currentMonth()\">\n            <clr-icon shape=\"event\" [attr.title]=\"commonStrings.current\"></clr-icon>\n        </button>\n        <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"nextMonth()\">\n            <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n<clr-calendar></clr-calendar>\n", host: { '[class.daypicker]': 'true' } }] }
    ];
    /** @nocollapse */
    ClrDaypicker.ctorParameters = function () { return [
        { type: ViewManagerService },
        { type: DateNavigationService },
        { type: LocaleHelperService },
        { type: ClrCommonStrings }
    ]; };
    return ClrDaypicker;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrMonthpicker = /** @class */ (function () {
    function ClrMonthpicker(_viewManagerService, _localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
        this._viewManagerService = _viewManagerService;
        this._localeHelperService = _localeHelperService;
        this._dateNavigationService = _dateNavigationService;
        this._datepickerFocusService = _datepickerFocusService;
        this._elRef = _elRef;
        this._focusedMonthIndex = this.calendarMonthIndex;
    }
    Object.defineProperty(ClrMonthpicker.prototype, "monthNames", {
        /**
         * Gets the months array which is used to rendered the monthpicker view.
         * Months are in the TranslationWidth.Wide format.
         */
        get: /**
         * Gets the months array which is used to rendered the monthpicker view.
         * Months are in the TranslationWidth.Wide format.
         * @return {?}
         */
        function () {
            return this._localeHelperService.localeMonthsWide;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrMonthpicker.prototype, "calendarMonthIndex", {
        /**
         * Gets the month value of the Calendar.
         */
        get: /**
         * Gets the month value of the Calendar.
         * @return {?}
         */
        function () {
            return this._dateNavigationService.displayedCalendar.month;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calls the DateNavigationService to update the month value of the calendar.
     * Also changes the view to the daypicker.
     */
    /**
     * Calls the DateNavigationService to update the month value of the calendar.
     * Also changes the view to the daypicker.
     * @param {?} monthIndex
     * @return {?}
     */
    ClrMonthpicker.prototype.changeMonth = /**
     * Calls the DateNavigationService to update the month value of the calendar.
     * Also changes the view to the daypicker.
     * @param {?} monthIndex
     * @return {?}
     */
    function (monthIndex) {
        this._dateNavigationService.changeMonth(monthIndex);
        this._viewManagerService.changeToDayView();
    };
    /**
     * Compares the month passed to the focused month and returns the tab index.
     */
    /**
     * Compares the month passed to the focused month and returns the tab index.
     * @param {?} monthIndex
     * @return {?}
     */
    ClrMonthpicker.prototype.getTabIndex = /**
     * Compares the month passed to the focused month and returns the tab index.
     * @param {?} monthIndex
     * @return {?}
     */
    function (monthIndex) {
        return monthIndex === this._focusedMonthIndex ? 0 : -1;
    };
    /**
     * Handles the Keyboard arrow navigation for the monthpicker.
     */
    /**
     * Handles the Keyboard arrow navigation for the monthpicker.
     * @param {?} event
     * @return {?}
     */
    ClrMonthpicker.prototype.onKeyDown = /**
     * Handles the Keyboard arrow navigation for the monthpicker.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // NOTE: Didn't move this to the date navigation service because
        // the logic is fairly simple and it didn't make sense for me
        // to create extra observables just to move this logic to the service.
        if (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            if (keyCode === UP_ARROW && this._focusedMonthIndex > 0) {
                event.preventDefault();
                this._focusedMonthIndex--;
                this._datepickerFocusService.focusCell(this._elRef);
            }
            else if (keyCode === DOWN_ARROW && this._focusedMonthIndex < 11) {
                event.preventDefault();
                this._focusedMonthIndex++;
                this._datepickerFocusService.focusCell(this._elRef);
            }
            else if (keyCode === RIGHT_ARROW && this._focusedMonthIndex < 6) {
                event.preventDefault();
                this._focusedMonthIndex = this._focusedMonthIndex + 6;
                this._datepickerFocusService.focusCell(this._elRef);
            }
            else if (keyCode === LEFT_ARROW && this._focusedMonthIndex > 5) {
                event.preventDefault();
                this._focusedMonthIndex = this._focusedMonthIndex - 6;
                this._datepickerFocusService.focusCell(this._elRef);
            }
        }
    };
    /**
     * Focuses on the current calendar month when the View is initialized.
     */
    /**
     * Focuses on the current calendar month when the View is initialized.
     * @return {?}
     */
    ClrMonthpicker.prototype.ngAfterViewInit = /**
     * Focuses on the current calendar month when the View is initialized.
     * @return {?}
     */
    function () {
        this._datepickerFocusService.focusCell(this._elRef);
    };
    ClrMonthpicker.decorators = [
        { type: Component, args: [{
                    selector: 'clr-monthpicker',
                    template: "\n        <button\n            type=\"button\"\n            class=\"calendar-btn month\"\n            *ngFor=\"let month of monthNames; let monthIndex = index\"\n            (click)=\"changeMonth(monthIndex)\"\n            [class.is-selected]=\"monthIndex === calendarMonthIndex\"\n            [attr.tabindex]=\"getTabIndex(monthIndex)\">\n            {{month}}\n        </button>\n    ",
                    host: {
                        '[class.monthpicker]': 'true',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrMonthpicker.ctorParameters = function () { return [
        { type: ViewManagerService },
        { type: LocaleHelperService },
        { type: DateNavigationService },
        { type: DatepickerFocusService },
        { type: ElementRef }
    ]; };
    ClrMonthpicker.propDecorators = {
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return ClrMonthpicker;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @type {?} */
var YEARS_TO_DISPLAY = 10;
var YearRangeModel = /** @class */ (function () {
    function YearRangeModel(year) {
        this.year = year;
        this.yearRange = [];
        this.generateYearRange();
    }
    Object.defineProperty(YearRangeModel.prototype, "middleYear", {
        /**
         * Gets the number in the middle of the range.
         */
        get: /**
         * Gets the number in the middle of the range.
         * @return {?}
         */
        function () {
            return this.yearRange[Math.floor(this.yearRange.length / 2)];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Generates the year range based on the year parameter.
     * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
     */
    /**
     * Generates the year range based on the year parameter.
     * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
     * @return {?}
     */
    YearRangeModel.prototype.generateYearRange = /**
     * Generates the year range based on the year parameter.
     * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
     * @return {?}
     */
    function () {
        /** @type {?} */
        var remainder = this.year % YEARS_TO_DISPLAY;
        /** @type {?} */
        var floor = this.year - remainder;
        /** @type {?} */
        var ceil = floor + YEARS_TO_DISPLAY;
        this.yearRange = this.generateRange(floor, ceil);
    };
    /**
     * Function which generate a range of numbers from floor to ceil.
     */
    /**
     * Function which generate a range of numbers from floor to ceil.
     * @param {?} floor
     * @param {?} ceil
     * @return {?}
     */
    YearRangeModel.prototype.generateRange = /**
     * Function which generate a range of numbers from floor to ceil.
     * @param {?} floor
     * @param {?} ceil
     * @return {?}
     */
    function (floor, ceil) {
        return Array.from({ length: ceil - floor }, function (v, k) { return k + floor; });
    };
    /**
     * Generates the YearRangeModel for the next decade.
     */
    /**
     * Generates the YearRangeModel for the next decade.
     * @return {?}
     */
    YearRangeModel.prototype.nextDecade = /**
     * Generates the YearRangeModel for the next decade.
     * @return {?}
     */
    function () {
        return new YearRangeModel(this.year + 10);
    };
    /**
     * Generates the YearRangeModel for the previous decade.
     */
    /**
     * Generates the YearRangeModel for the previous decade.
     * @return {?}
     */
    YearRangeModel.prototype.previousDecade = /**
     * Generates the YearRangeModel for the previous decade.
     * @return {?}
     */
    function () {
        return new YearRangeModel(this.year - 10);
    };
    /**
     * Generates the YearRangeModel for the current decade.
     */
    /**
     * Generates the YearRangeModel for the current decade.
     * @return {?}
     */
    YearRangeModel.prototype.currentDecade = /**
     * Generates the YearRangeModel for the current decade.
     * @return {?}
     */
    function () {
        return new YearRangeModel(new Date().getFullYear());
    };
    /**
     * Checks if the value is in the YearRangeModel.
     */
    /**
     * Checks if the value is in the YearRangeModel.
     * @param {?} value
     * @return {?}
     */
    YearRangeModel.prototype.inRange = /**
     * Checks if the value is in the YearRangeModel.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.yearRange.indexOf(value) > -1;
    };
    return YearRangeModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrYearpicker = /** @class */ (function () {
    function ClrYearpicker(_dateNavigationService, _viewManagerService, _datepickerFocusService, _elRef, commonStrings) {
        this._dateNavigationService = _dateNavigationService;
        this._viewManagerService = _viewManagerService;
        this._datepickerFocusService = _datepickerFocusService;
        this._elRef = _elRef;
        this.commonStrings = commonStrings;
        this.yearRangeModel = new YearRangeModel(this.calendarYear);
        this._focusedYear = this.calendarYear;
    }
    Object.defineProperty(ClrYearpicker.prototype, "calendarYear", {
        /**
         * Gets the year which the user is currently on.
         */
        get: /**
         * Gets the year which the user is currently on.
         * @return {?}
         */
        function () {
            return this._dateNavigationService.displayedCalendar.year;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Increments the focus year by the value passed. Updates the YearRangeModel if the
     * new value is not in the current decade.
     */
    /**
     * Increments the focus year by the value passed. Updates the YearRangeModel if the
     * new value is not in the current decade.
     * @param {?} value
     * @return {?}
     */
    ClrYearpicker.prototype.incrementFocusYearBy = /**
     * Increments the focus year by the value passed. Updates the YearRangeModel if the
     * new value is not in the current decade.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._focusedYear = this._focusedYear + value;
        if (!this.yearRangeModel.inRange(this._focusedYear)) {
            if (value > 0) {
                this.yearRangeModel = this.yearRangeModel.nextDecade();
            }
            else {
                this.yearRangeModel = this.yearRangeModel.previousDecade();
            }
        }
        this._datepickerFocusService.focusCell(this._elRef);
    };
    /**
     * Calls the DateNavigationService to update the year value of the calendar.
     * Also changes the view to the daypicker.
     */
    /**
     * Calls the DateNavigationService to update the year value of the calendar.
     * Also changes the view to the daypicker.
     * @param {?} year
     * @return {?}
     */
    ClrYearpicker.prototype.changeYear = /**
     * Calls the DateNavigationService to update the year value of the calendar.
     * Also changes the view to the daypicker.
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this._dateNavigationService.changeYear(year);
        this._viewManagerService.changeToDayView();
    };
    /**
     * Updates the YearRangeModel to the previous decade.
     */
    /**
     * Updates the YearRangeModel to the previous decade.
     * @return {?}
     */
    ClrYearpicker.prototype.previousDecade = /**
     * Updates the YearRangeModel to the previous decade.
     * @return {?}
     */
    function () {
        this.yearRangeModel = this.yearRangeModel.previousDecade();
        // Year in the yearpicker is not focused because while navigating to a different decade,
        // you want the focus to remain on the decade switcher arrows.
    };
    /**
     * Updates the YearRangeModel to the current decade.
     */
    /**
     * Updates the YearRangeModel to the current decade.
     * @return {?}
     */
    ClrYearpicker.prototype.currentDecade = /**
     * Updates the YearRangeModel to the current decade.
     * @return {?}
     */
    function () {
        if (!this.yearRangeModel.inRange(this._dateNavigationService.today.year)) {
            this.yearRangeModel = this.yearRangeModel.currentDecade();
        }
        this._datepickerFocusService.focusCell(this._elRef);
    };
    /**
     * Updates the YearRangeModel to the next decade.
     */
    /**
     * Updates the YearRangeModel to the next decade.
     * @return {?}
     */
    ClrYearpicker.prototype.nextDecade = /**
     * Updates the YearRangeModel to the next decade.
     * @return {?}
     */
    function () {
        this.yearRangeModel = this.yearRangeModel.nextDecade();
        // Year in the yearpicker is not focused because while navigating to a different decade,
        // you want the focus to remain on the decade switcher arrows.
    };
    /**
     * Compares the year passed to the focused year and returns the tab index.
     */
    /**
     * Compares the year passed to the focused year and returns the tab index.
     * @param {?} year
     * @return {?}
     */
    ClrYearpicker.prototype.getTabIndex = /**
     * Compares the year passed to the focused year and returns the tab index.
     * @param {?} year
     * @return {?}
     */
    function (year) {
        if (!this.yearRangeModel.inRange(this._focusedYear)) {
            if (this.yearRangeModel.inRange(this.calendarYear)) {
                this._focusedYear = this.calendarYear;
            }
            else {
                this._focusedYear = this.yearRangeModel.middleYear;
            }
        }
        return this._focusedYear === year ? 0 : -1;
    };
    /**
     * Handles the Keyboard arrow navigation for the yearpicker.
     */
    /**
     * Handles the Keyboard arrow navigation for the yearpicker.
     * @param {?} event
     * @return {?}
     */
    ClrYearpicker.prototype.onKeyDown = /**
     * Handles the Keyboard arrow navigation for the yearpicker.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // NOTE: Didn't move this to the date navigation service because
        // the logic is fairly simple and it didn't make sense for me
        // to create extra observables just to move this logic to the service.
        if (event) {
            /** @type {?} */
            var keyCode = event.keyCode;
            if (keyCode === UP_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(-1);
            }
            else if (keyCode === DOWN_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(1);
            }
            else if (keyCode === RIGHT_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(5);
            }
            else if (keyCode === LEFT_ARROW) {
                event.preventDefault();
                this.incrementFocusYearBy(-5);
            }
        }
    };
    /**
     * Focuses on the current calendar year when the View is initialized.
     */
    /**
     * Focuses on the current calendar year when the View is initialized.
     * @return {?}
     */
    ClrYearpicker.prototype.ngAfterViewInit = /**
     * Focuses on the current calendar year when the View is initialized.
     * @return {?}
     */
    function () {
        this._datepickerFocusService.focusCell(this._elRef);
    };
    ClrYearpicker.decorators = [
        { type: Component, args: [{
                    selector: 'clr-yearpicker',
                    template: "\n        <div class=\"year-switchers\">\n            <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"previousDecade()\">\n                <clr-icon shape=\"angle\" dir=\"left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n            </button>\n            <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"currentDecade()\">\n                <clr-icon shape=\"event\" [attr.title]=\"commonStrings.current\"></clr-icon>\n            </button>\n            <button class=\"calendar-btn switcher\" type=\"button\" (click)=\"nextDecade()\">\n                <clr-icon shape=\"angle\" dir=\"right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n            </button>\n        </div>\n        <div class=\"years\">\n            <button\n                *ngFor=\"let year of yearRangeModel.yearRange\"\n                type=\"button\"\n                class=\"calendar-btn year\"\n                [attr.tabindex]=\"getTabIndex(year)\"\n                [class.is-selected]=\"year === calendarYear\"\n                (click)=\"changeYear(year)\">\n                {{year}}\n            </button>\n        </div>\n    ",
                    host: {
                        '[class.yearpicker]': 'true',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrYearpicker.ctorParameters = function () { return [
        { type: DateNavigationService },
        { type: ViewManagerService },
        { type: DatepickerFocusService },
        { type: ElementRef },
        { type: ClrCommonStrings }
    ]; };
    ClrYearpicker.propDecorators = {
        onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return ClrYearpicker;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_DATEPICKER_DIRECTIVES = [
    ClrDay,
    ClrDateContainer,
    ClrDateInput,
    ClrDatepickerViewManager,
    ClrMonthpicker,
    ClrYearpicker,
    ClrDaypicker,
    ClrCalendar,
];
var ClrDatepickerModule = /** @class */ (function () {
    function ClrDatepickerModule() {
    }
    ClrDatepickerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ClrHostWrappingModule,
                        ClrConditionalModule,
                        ClrIconModule,
                        ClrFocusTrapModule,
                        ClrCommonFormsModule,
                    ],
                    declarations: [CLR_DATEPICKER_DIRECTIVES],
                    exports: [CLR_DATEPICKER_DIRECTIVES],
                    entryComponents: [ClrDateContainer],
                },] }
    ];
    return ClrDatepickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrInputContainer = /** @class */ (function () {
    function ClrInputContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
        var _this = this;
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            _this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            _this.control = control;
        }));
    }
    /**
     * @return {?}
     */
    ClrInputContainer.prototype.controlClass = /**
     * @return {?}
     */
    function () {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    };
    /**
     * @return {?}
     */
    ClrInputContainer.prototype.addGrid = /**
     * @return {?}
     */
    function () {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    ClrInputContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscriptions) {
            this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
        }
    };
    ClrInputContainer.decorators = [
        { type: Component, args: [{
                    selector: 'clr-input-container',
                    template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-input-wrapper\">\n                <ng-content select=\"[clrInput]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                    host: {
                        '[class.clr-form-control]': 'true',
                        '[class.clr-form-control-disabled]': 'control?.disabled',
                        '[class.clr-row]': 'addGrid()',
                    },
                    providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                }] }
    ];
    /** @nocollapse */
    ClrInputContainer.ctorParameters = function () { return [
        { type: IfErrorService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: ControlClassService },
        { type: NgControlService }
    ]; };
    ClrInputContainer.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }]
    };
    return ClrInputContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrInput = /** @class */ (function (_super) {
    __extends(ClrInput, _super);
    function ClrInput(vcr, injector, control, renderer, el) {
        var _this = _super.call(this, vcr, ClrInputContainer, injector, control, renderer, el) || this;
        _this.index = 1;
        return _this;
    }
    ClrInput.decorators = [
        { type: Directive, args: [{ selector: '[clrInput]', host: { '[class.clr-input]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrInput.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Injector },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    return ClrInput;
}(WrappedFormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrInputModule = /** @class */ (function () {
    function ClrInputModule() {
    }
    ClrInputModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                    declarations: [ClrInput, ClrInputContainer],
                    exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer],
                    entryComponents: [ClrInputContainer],
                },] }
    ];
    return ClrInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var TOGGLE_SERVICE = new InjectionToken(undefined);
/**
 * @return {?}
 */
function ToggleServiceFactory() {
    return new BehaviorSubject(false);
}
/** @type {?} */
var TOGGLE_SERVICE_PROVIDER = { provide: TOGGLE_SERVICE, useFactory: ToggleServiceFactory };
var ClrPasswordContainer = /** @class */ (function () {
    function ClrPasswordContainer(ifErrorService, layoutService, controlClassService, focusService, ngControlService, toggleService, commonStrings) {
        var _this = this;
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.focusService = focusService;
        this.ngControlService = ngControlService;
        this.toggleService = toggleService;
        this.commonStrings = commonStrings;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.show = false;
        this.focus = false;
        this._toggle = true;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            _this.invalid = invalid;
        }));
        this.subscriptions.push(this.focusService.focusChange.subscribe(function (state$$1) {
            _this.focus = state$$1;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            _this.control = control;
        }));
    }
    Object.defineProperty(ClrPasswordContainer.prototype, "clrToggle", {
        get: /**
         * @return {?}
         */
        function () {
            return this._toggle;
        },
        set: /**
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            this._toggle = state$$1;
            if (!state$$1) {
                this.show = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrPasswordContainer.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.show = !this.show;
        this.toggleService.next(this.show);
    };
    /**
     * @return {?}
     */
    ClrPasswordContainer.prototype.controlClass = /**
     * @return {?}
     */
    function () {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    };
    /**
     * @return {?}
     */
    ClrPasswordContainer.prototype.addGrid = /**
     * @return {?}
     */
    function () {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    ClrPasswordContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscriptions) {
            this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
        }
    };
    ClrPasswordContainer.decorators = [
        { type: Component, args: [{
                    selector: 'clr-password-container',
                    template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n      <div class=\"clr-input-wrapper\">\n        <div class=\"clr-input-group\" [class.clr-focus]=\"focus\">\n          <ng-content select=\"[clrPassword]\"></ng-content>\n          <button\n            *ngIf=\"clrToggle\"\n            (click)=\"toggle()\"\n            [disabled]=\"control?.disabled\"\n            class=\"clr-input-group-icon-action\"\n            type=\"button\">\n            <clr-icon\n            [attr.shape]=\"show ? 'eye-hide' : 'eye'\"\n            [attr.title]=\"show ? commonStrings.hide : commonStrings.show\"></clr-icon>\n          </button>\n        </div>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n      </div>\n      <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n      <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n    </div>\n    ",
                    host: {
                        '[class.clr-form-control]': 'true',
                        '[class.clr-form-control-disabled]': 'control?.disabled',
                        '[class.clr-row]': 'addGrid()',
                    },
                    providers: [
                        IfErrorService,
                        NgControlService,
                        ControlIdService,
                        ControlClassService,
                        FocusService,
                        TOGGLE_SERVICE_PROVIDER,
                    ]
                }] }
    ];
    /** @nocollapse */
    ClrPasswordContainer.ctorParameters = function () { return [
        { type: IfErrorService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: ControlClassService },
        { type: FocusService },
        { type: NgControlService },
        { type: BehaviorSubject, decorators: [{ type: Inject, args: [TOGGLE_SERVICE,] }] },
        { type: ClrCommonStrings }
    ]; };
    ClrPasswordContainer.propDecorators = {
        clrToggle: [{ type: Input, args: ['clrToggle',] }],
        label: [{ type: ContentChild, args: [ClrLabel,] }]
    };
    return ClrPasswordContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrPassword = /** @class */ (function (_super) {
    __extends(ClrPassword, _super);
    function ClrPassword(vcr, injector, control, renderer, el, focusService, toggleService) {
        var _this = _super.call(this, vcr, ClrPasswordContainer, injector, control, renderer, el) || this;
        _this.focusService = focusService;
        _this.toggleService = toggleService;
        _this.index = 1;
        if (!_this.focusService) {
            throw new Error('clrPassword requires being wrapped in <clr-password-container>');
        }
        _this.subscriptions.push(_this.toggleService.subscribe(function (toggle) {
            renderer.setProperty(el.nativeElement, 'type', toggle ? 'text' : 'password');
        }));
        return _this;
    }
    /**
     * @return {?}
     */
    ClrPassword.prototype.triggerFocus = /**
     * @return {?}
     */
    function () {
        if (this.focusService) {
            this.focusService.focused = true;
        }
    };
    /**
     * @return {?}
     */
    ClrPassword.prototype.triggerValidation = /**
     * @return {?}
     */
    function () {
        _super.prototype.triggerValidation.call(this);
        if (this.focusService) {
            this.focusService.focused = false;
        }
    };
    ClrPassword.decorators = [
        { type: Directive, args: [{ selector: '[clrPassword]', host: { '[class.clr-input]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrPassword.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Injector },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: Renderer2 },
        { type: ElementRef },
        { type: FocusService, decorators: [{ type: Optional }] },
        { type: BehaviorSubject, decorators: [{ type: Optional }, { type: Inject, args: [TOGGLE_SERVICE,] }] }
    ]; };
    ClrPassword.propDecorators = {
        triggerFocus: [{ type: HostListener, args: ['focus',] }],
        triggerValidation: [{ type: HostListener, args: ['blur',] }]
    };
    return ClrPassword;
}(WrappedFormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrPasswordModule = /** @class */ (function () {
    function ClrPasswordModule() {
    }
    ClrPasswordModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                    declarations: [ClrPassword, ClrPasswordContainer],
                    exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer],
                    entryComponents: [ClrPasswordContainer],
                },] }
    ];
    return ClrPasswordModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrRadioWrapper = /** @class */ (function () {
    function ClrRadioWrapper() {
        // We need both _dynamic for HostWrapper and ContentChild(ClrLabel) in cases where
        // the user puts a radio inside a wrapper without a label, host wrapping doesn't apply
        // but we'd still need to insert a label
        this._dynamic = false;
    }
    /**
     * @return {?}
     */
    ClrRadioWrapper.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.label) {
            this.label.disableGrid();
        }
    };
    ClrRadioWrapper.decorators = [
        { type: Component, args: [{
                    selector: 'clr-radio-wrapper',
                    template: "\n    <ng-content select=\"[clrRadio]\"></ng-content>\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label\"></label>\n  ",
                    host: {
                        '[class.clr-radio-wrapper]': 'true',
                    },
                    providers: [ControlIdService]
                }] }
    ];
    ClrRadioWrapper.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }]
    };
    return ClrRadioWrapper;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrRadio = /** @class */ (function (_super) {
    __extends(ClrRadio, _super);
    function ClrRadio(vcr, injector, control, renderer, el) {
        return _super.call(this, vcr, ClrRadioWrapper, injector, control, renderer, el) || this;
    }
    ClrRadio.decorators = [
        { type: Directive, args: [{ selector: '[clrRadio]' },] }
    ];
    /** @nocollapse */
    ClrRadio.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Injector },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    return ClrRadio;
}(WrappedFormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrRadioContainer = /** @class */ (function () {
    function ClrRadioContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
        var _this = this;
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this.inline = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            _this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            _this.control = control;
        }));
    }
    Object.defineProperty(ClrRadioContainer.prototype, "clrInline", {
        get: /**
         * @return {?}
         */
        function () {
            return this.inline;
        },
        /*
         * Here we want to support the following cases
         * clrInline - true by presence
         * clrInline="true|false" - unless it is explicitly false, strings are considered true
         * [clrInline]="true|false" - expect a boolean
         */
        set: /*
           * Here we want to support the following cases
           * clrInline - true by presence
           * clrInline="true|false" - unless it is explicitly false, strings are considered true
           * [clrInline]="true|false" - expect a boolean
           */
        /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string') {
                this.inline = value === 'false' ? false : true;
            }
            else {
                this.inline = !!value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrRadioContainer.prototype.controlClass = /**
     * @return {?}
     */
    function () {
        return this.controlClassService.controlClass(this.invalid, this.addGrid(), this.inline ? 'clr-control-inline' : '');
    };
    /**
     * @return {?}
     */
    ClrRadioContainer.prototype.addGrid = /**
     * @return {?}
     */
    function () {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    ClrRadioContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
    };
    ClrRadioContainer.decorators = [
        { type: Component, args: [{
                    selector: 'clr-radio-container',
                    template: "\n    <ng-content select=\"label\"></ng-content>\n    <label *ngIf=\"!label && addGrid()\"></label>\n    <div class=\"clr-control-container\" [class.clr-control-inline]=\"clrInline\" [ngClass]=\"controlClass()\">\n      <ng-content select=\"clr-radio-wrapper\"></ng-content>\n      <div class=\"clr-subtext-wrapper\">\n        <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n        <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n        <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n      </div>\n    </div>\n    ",
                    host: {
                        '[class.clr-form-control]': 'true',
                        '[class.clr-form-control-disabled]': 'control?.disabled',
                        '[class.clr-row]': 'addGrid()',
                    },
                    providers: [NgControlService, ControlClassService, IfErrorService]
                }] }
    ];
    /** @nocollapse */
    ClrRadioContainer.ctorParameters = function () { return [
        { type: IfErrorService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: ControlClassService },
        { type: NgControlService }
    ]; };
    ClrRadioContainer.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }],
        clrInline: [{ type: Input }]
    };
    return ClrRadioContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrRadioModule = /** @class */ (function () {
    function ClrRadioModule() {
    }
    ClrRadioModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
                    declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                    exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper],
                    entryComponents: [ClrRadioWrapper],
                },] }
    ];
    return ClrRadioModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrSelectContainer = /** @class */ (function () {
    function ClrSelectContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
        var _this = this;
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.multi = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            _this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            if (control) {
                _this.multi = control.valueAccessor instanceof SelectMultipleControlValueAccessor;
                _this.control = control;
            }
        }));
    }
    /**
     * @return {?}
     */
    ClrSelectContainer.prototype.wrapperClass = /**
     * @return {?}
     */
    function () {
        return this.multi ? 'clr-multiselect-wrapper' : 'clr-select-wrapper';
    };
    /**
     * @return {?}
     */
    ClrSelectContainer.prototype.controlClass = /**
     * @return {?}
     */
    function () {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    };
    /**
     * @return {?}
     */
    ClrSelectContainer.prototype.addGrid = /**
     * @return {?}
     */
    function () {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    ClrSelectContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscriptions) {
            this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
        }
    };
    ClrSelectContainer.decorators = [
        { type: Component, args: [{
                    selector: 'clr-select-container',
                    template: "    \n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div [ngClass]=\"wrapperClass()\">\n                <ng-content select=\"[clrSelect]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                    host: {
                        '[class.clr-form-control]': 'true',
                        '[class.clr-form-control-disabled]': 'control?.disabled',
                        '[class.clr-row]': 'addGrid()',
                    },
                    providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                }] }
    ];
    /** @nocollapse */
    ClrSelectContainer.ctorParameters = function () { return [
        { type: IfErrorService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: ControlClassService },
        { type: NgControlService }
    ]; };
    ClrSelectContainer.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }],
        multiple: [{ type: ContentChild, args: [SelectMultipleControlValueAccessor,] }]
    };
    return ClrSelectContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrSelect = /** @class */ (function (_super) {
    __extends(ClrSelect, _super);
    function ClrSelect(vcr, injector, control, renderer, el) {
        var _this = _super.call(this, vcr, ClrSelectContainer, injector, control, renderer, el) || this;
        _this.index = 1;
        return _this;
    }
    ClrSelect.decorators = [
        { type: Directive, args: [{ selector: '[clrSelect]', host: { '[class.clr-select]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrSelect.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Injector },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    return ClrSelect;
}(WrappedFormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrSelectModule = /** @class */ (function () {
    function ClrSelectModule() {
    }
    ClrSelectModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                    declarations: [ClrSelect, ClrSelectContainer],
                    exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer],
                    entryComponents: [ClrSelectContainer],
                },] }
    ];
    return ClrSelectModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTextareaContainer = /** @class */ (function () {
    function ClrTextareaContainer(ifErrorService, layoutService, controlClassService, ngControlService) {
        var _this = this;
        this.ifErrorService = ifErrorService;
        this.layoutService = layoutService;
        this.controlClassService = controlClassService;
        this.ngControlService = ngControlService;
        this.subscriptions = [];
        this.invalid = false;
        this._dynamic = false;
        this.subscriptions.push(this.ifErrorService.statusChanges.subscribe(function (invalid) {
            _this.invalid = invalid;
        }));
        this.subscriptions.push(this.ngControlService.controlChanges.subscribe(function (control) {
            _this.control = control;
        }));
    }
    /**
     * @return {?}
     */
    ClrTextareaContainer.prototype.controlClass = /**
     * @return {?}
     */
    function () {
        return this.controlClassService.controlClass(this.invalid, this.addGrid());
    };
    /**
     * @return {?}
     */
    ClrTextareaContainer.prototype.addGrid = /**
     * @return {?}
     */
    function () {
        if (this.layoutService && !this.layoutService.isVertical()) {
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    ClrTextareaContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscriptions) {
            this.subscriptions.map(function (sub) { return sub.unsubscribe(); });
        }
    };
    ClrTextareaContainer.decorators = [
        { type: Component, args: [{
                    selector: 'clr-textarea-container',
                    template: "\n        <ng-content select=\"label\"></ng-content>\n        <label *ngIf=\"!label && addGrid()\"></label>\n        <div class=\"clr-control-container\" [ngClass]=\"controlClass()\">\n            <div class=\"clr-textarea-wrapper\">\n                <ng-content select=\"[clrTextarea]\"></ng-content>\n                <clr-icon *ngIf=\"invalid\" class=\"clr-validate-icon\" shape=\"exclamation-circle\" aria-hidden=\"true\"></clr-icon>\n            </div>\n            <ng-content select=\"clr-control-helper\" *ngIf=\"!invalid\"></ng-content>\n            <ng-content select=\"clr-control-error\" *ngIf=\"invalid\"></ng-content>\n        </div>\n    ",
                    host: {
                        '[class.clr-form-control]': 'true',
                        '[class.clr-form-control-disabled]': 'control?.disabled',
                        '[class.clr-row]': 'addGrid()',
                    },
                    providers: [IfErrorService, NgControlService, ControlIdService, ControlClassService]
                }] }
    ];
    /** @nocollapse */
    ClrTextareaContainer.ctorParameters = function () { return [
        { type: IfErrorService },
        { type: LayoutService, decorators: [{ type: Optional }] },
        { type: ControlClassService },
        { type: NgControlService }
    ]; };
    ClrTextareaContainer.propDecorators = {
        label: [{ type: ContentChild, args: [ClrLabel,] }]
    };
    return ClrTextareaContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTextarea = /** @class */ (function (_super) {
    __extends(ClrTextarea, _super);
    function ClrTextarea(vcr, injector, control, renderer, el) {
        var _this = _super.call(this, vcr, ClrTextareaContainer, injector, control, renderer, el) || this;
        _this.index = 1;
        return _this;
    }
    ClrTextarea.decorators = [
        { type: Directive, args: [{ selector: '[clrTextarea]', host: { '[class.clr-textarea]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrTextarea.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: Injector },
        { type: NgControl, decorators: [{ type: Self }, { type: Optional }] },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    return ClrTextarea;
}(WrappedFormControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTextareaModule = /** @class */ (function () {
    function ClrTextareaModule() {
    }
    ClrTextareaModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
                    declarations: [ClrTextarea, ClrTextareaContainer],
                    exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer],
                    entryComponents: [ClrTextareaContainer],
                },] }
    ];
    return ClrTextareaModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrFormsModule = /** @class */ (function () {
    function ClrFormsModule() {
    }
    ClrFormsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    exports: [
                        ClrCommonFormsModule,
                        ClrCheckboxModule,
                        ClrDatepickerModule,
                        ClrInputModule,
                        ClrPasswordModule,
                        ClrRadioModule,
                        ClrSelectModule,
                        ClrTextareaModule,
                    ],
                },] }
    ];
    return ClrFormsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var Expand = /** @class */ (function () {
    function Expand() {
        this.expandable = 0;
        // private _replace: boolean = false;
        this._replace = new BehaviorSubject(false);
        this._loading = false;
        this._expanded = false;
        // TODO: Move this to the datagrid RowExpand.
        // I spent some time doing this but ran into a couple of issues
        // Will take care of this later.
        this._animate = new Subject();
        this._expandChange = new Subject();
    }
    Object.defineProperty(Expand.prototype, "replace", {
        get: /**
         * @return {?}
         */
        function () {
            return this._replace.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} replaceValue
     * @return {?}
     */
    Expand.prototype.setReplace = /**
     * @param {?} replaceValue
     * @return {?}
     */
    function (replaceValue) {
        this._replace.next(replaceValue);
    };
    Object.defineProperty(Expand.prototype, "loading", {
        get: /**
         * @return {?}
         */
        function () {
            return this._loading;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = !!value;
            if (value !== this._loading) {
                this._loading = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Expand.prototype, "expanded", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expanded;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = !!value;
            if (value !== this._expanded) {
                this._expanded = value;
                this._animate.next();
                this._expandChange.next(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    Expand.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.expanded = !this._expanded;
    };
    Object.defineProperty(Expand.prototype, "animate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._animate.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Expand.prototype, "expandChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expandChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} state
     * @return {?}
     */
    Expand.prototype.loadingStateChange = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        switch (state$$1) {
            case ClrLoadingState.LOADING:
                this.loading = true;
                break;
            default:
                this.loading = false;
                this._animate.next();
                break;
        }
    };
    Expand.decorators = [
        { type: Injectable }
    ];
    return Expand;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * TODO: make this a reusable directive outside of Datagrid, like [clrLoading].
 */
var ClrIfExpanded = /** @class */ (function () {
    function ClrIfExpanded(template, container, el, renderer, expand) {
        var _this = this;
        this.template = template;
        this.container = container;
        this.el = el;
        this.renderer = renderer;
        this.expand = expand;
        this._expanded = false;
        this.expandedChange = new EventEmitter(true);
        /**
         * Subscriptions to all the services and queries changes
         */
        this._subscriptions = [];
        expand.expandable++;
        this._subscriptions.push(expand.expandChange.subscribe(function () {
            _this.updateView();
            _this.expandedChange.emit(_this.expand.expanded);
        }));
    }
    Object.defineProperty(ClrIfExpanded.prototype, "expanded", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expanded;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'boolean') {
                this.expand.expanded = value;
                this._expanded = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrIfExpanded.prototype.updateView = /**
     * @return {?}
     */
    function () {
        if (this.expand.expanded && this.container.length !== 0) {
            return;
        }
        if (this.template) {
            if (this.expand.expanded) {
                // Should we pass a context? I don't see anything useful to pass right now,
                // but we can come back to it in the future as a solution for additional features.
                this.container.createEmbeddedView(this.template);
            }
            else {
                // TODO: Move when we move the animation logic to Datagrid Row Expand
                // We clear before the animation is over. Not ideal, but doing better would involve a much heavier
                // process for very little gain. Once Angular animations are dynamic enough, we should be able to
                // get the optimal behavior.
                this.container.clear();
            }
        }
        else {
            try {
                // If we don't have a template ref, we fallback to a crude display: none for now.
                if (this.expand.expanded) {
                    this.renderer.setStyle(this.el.nativeElement, 'display', null);
                }
                else {
                    this.renderer.setStyle(this.el.nativeElement, 'display', 'none');
                }
            }
            catch (e) {
                // We catch the case where clrIfExpanded was put on a non-DOM element, and we just do nothing
            }
        }
    };
    /**
     * @return {?}
     */
    ClrIfExpanded.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.updateView();
    };
    /**
     * @return {?}
     */
    ClrIfExpanded.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.expand.expandable--;
        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrIfExpanded.decorators = [
        { type: Directive, args: [{ selector: '[clrIfExpanded]' },] }
    ];
    /** @nocollapse */
    ClrIfExpanded.ctorParameters = function () { return [
        { type: TemplateRef, decorators: [{ type: Optional }] },
        { type: ViewContainerRef },
        { type: ElementRef },
        { type: Renderer2 },
        { type: Expand }
    ]; };
    ClrIfExpanded.propDecorators = {
        expanded: [{ type: Input, args: ['clrIfExpanded',] }],
        expandedChange: [{ type: Output, args: ['clrIfExpandedChange',] }]
    };
    return ClrIfExpanded;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var EXPAND_DIRECTIVES = [ClrIfExpanded];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrIfExpandModule = /** @class */ (function () {
    function ClrIfExpandModule() {
    }
    ClrIfExpandModule.decorators = [
        { type: NgModule, args: [{ imports: [CommonModule], declarations: [EXPAND_DIRECTIVES], exports: [EXPAND_DIRECTIVES] },] }
    ];
    return ClrIfExpandModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_LOADING_DIRECTIVES = [ClrLoading];
var ClrLoadingModule = /** @class */ (function () {
    function ClrLoadingModule() {
    }
    ClrLoadingModule.decorators = [
        { type: NgModule, args: [{ imports: [CommonModule], declarations: [CLR_LOADING_DIRECTIVES], exports: [CLR_LOADING_DIRECTIVES] },] }
    ];
    return ClrLoadingModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var OutsideClick = /** @class */ (function () {
    function OutsideClick(el) {
        this.el = el;
        this.strict = false;
        this.outsideClick = new EventEmitter(false);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    OutsideClick.prototype.documentClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var target = event.target;
        // Get the element in the DOM on which the mouse was clicked
        /** @type {?} */
        var host = this.el.nativeElement;
        if (target === host) {
            return;
        }
        if (!this.strict && host.contains(target)) {
            return;
        }
        this.outsideClick.emit(event);
    };
    OutsideClick.decorators = [
        { type: Directive, args: [{ selector: '[clrOutsideClick]' },] }
    ];
    /** @nocollapse */
    OutsideClick.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    OutsideClick.propDecorators = {
        strict: [{ type: Input, args: ['clrStrict',] }],
        outsideClick: [{ type: Output, args: ['clrOutsideClick',] }],
        documentClick: [{ type: HostListener, args: ['document:click', ['$event'],] }]
    };
    return OutsideClick;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var OUSTIDE_CLICK_DIRECTIVES = [OutsideClick];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrOutsideClickModule = /** @class */ (function () {
    function ClrOutsideClickModule() {
    }
    ClrOutsideClickModule.decorators = [
        { type: NgModule, args: [{ imports: [CommonModule], declarations: [OUSTIDE_CLICK_DIRECTIVES], exports: [OUSTIDE_CLICK_DIRECTIVES] },] }
    ];
    return ClrOutsideClickModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DomAdapter = /** @class */ (function () {
    function DomAdapter() {
    }
    /**
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.userDefinedWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        element.classList.add('datagrid-cell-width-zero');
        /** @type {?} */
        var userDefinedWidth = this.clientRect(element).width;
        element.classList.remove('datagrid-cell-width-zero');
        return userDefinedWidth;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.scrollBarWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return element.offsetWidth - element.clientWidth;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.scrollWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return element.scrollWidth || 0;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.computedHeight = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return parseInt(getComputedStyle(element).getPropertyValue('height'), 10);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.clientRect = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        /** @type {?} */
        var elementClientRect = element.getBoundingClientRect();
        return {
            top: parseInt(elementClientRect.top, 10),
            bottom: parseInt(elementClientRect.bottom, 10),
            left: parseInt(elementClientRect.left, 10),
            right: parseInt(elementClientRect.right, 10),
            width: parseInt(elementClientRect.width, 10),
            height: parseInt(elementClientRect.height, 10),
        };
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.minWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return parseInt(getComputedStyle(element).getPropertyValue('min-width'), 10);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomAdapter.prototype.focus = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        element.focus();
    };
    DomAdapter.decorators = [
        { type: Injectable }
    ];
    return DomAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This class is used to convert an internal event
// to an external event to be emitted.
/**
 * @template T
 */
var  
// This class is used to convert an internal event
// to an external event to be emitted.
/**
 * @template T
 */
ClrDragEvent = /** @class */ (function () {
    function ClrDragEvent(dragEvent) {
        this.dragPosition = dragEvent.dragPosition;
        this.group = dragEvent.group;
        this.dragDataTransfer = dragEvent.dragDataTransfer;
        this.dropPointPosition = dragEvent.dropPointPosition;
    }
    return ClrDragEvent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
var DragEventType = {
    DRAG_START: 0,
    DRAG_MOVE: 1,
    DRAG_END: 2,
    DRAG_ENTER: 3,
    DRAG_LEAVE: 4,
    DROP: 5,
};
DragEventType[DragEventType.DRAG_START] = 'DRAG_START';
DragEventType[DragEventType.DRAG_MOVE] = 'DRAG_MOVE';
DragEventType[DragEventType.DRAG_END] = 'DRAG_END';
DragEventType[DragEventType.DRAG_ENTER] = 'DRAG_ENTER';
DragEventType[DragEventType.DRAG_LEAVE] = 'DRAG_LEAVE';
DragEventType[DragEventType.DROP] = 'DROP';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var DragAndDropEventBusService = /** @class */ (function () {
    function DragAndDropEventBusService() {
        this.dragStart = new Subject();
        this.dragMove = new Subject();
        this.dragEnd = new Subject();
        this.drop = new Subject();
    }
    Object.defineProperty(DragAndDropEventBusService.prototype, "dragStarted", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dragStart.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragAndDropEventBusService.prototype, "dragMoved", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dragMove.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragAndDropEventBusService.prototype, "dragEnded", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dragEnd.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragAndDropEventBusService.prototype, "dropped", {
        get: /**
         * @return {?}
         */
        function () {
            return this.drop.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    DragAndDropEventBusService.prototype.broadcast = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.type) {
            case DragEventType.DRAG_START:
                this.dragStart.next(event);
                break;
            case DragEventType.DRAG_MOVE:
                this.dragMove.next(event);
                break;
            case DragEventType.DRAG_END:
                this.dragEnd.next(event);
                break;
            case DragEventType.DROP:
                this.drop.next(event);
                break;
            default:
                break;
        }
    };
    DragAndDropEventBusService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */ DragAndDropEventBusService.ngInjectableDef = defineInjectable({ factory: function DragAndDropEventBusService_Factory() { return new DragAndDropEventBusService(); }, token: DragAndDropEventBusService, providedIn: "root" });
    return DragAndDropEventBusService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var DragEventListenerService = /** @class */ (function () {
    function DragEventListenerService(ngZone, renderer, eventBus) {
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.eventBus = eventBus;
        this.dragStart = new Subject();
        this.dragMove = new Subject();
        this.dragEnd = new Subject();
        this.hasDragStarted = false;
    }
    Object.defineProperty(DragEventListenerService.prototype, "dragStarted", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dragStart.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragEventListenerService.prototype, "dragMoved", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dragMove.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DragEventListenerService.prototype, "dragEnded", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dragEnd.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} draggableEl
     * @return {?}
     */
    DragEventListenerService.prototype.attachDragListeners = /**
     * @param {?} draggableEl
     * @return {?}
     */
    function (draggableEl) {
        this.draggableEl = draggableEl;
        this.listeners = [
            this.customDragEvent(this.draggableEl, 'mousedown', 'mousemove', 'mouseup'),
            this.customDragEvent(this.draggableEl, 'touchstart', 'touchmove', 'touchend'),
        ];
    };
    /**
     * @return {?}
     */
    DragEventListenerService.prototype.detachDragListeners = /**
     * @return {?}
     */
    function () {
        if (this.listeners) {
            this.listeners.map(function (event) { return event(); });
        }
        // In most cases, once users start dragging with mousedown/touchstart events,
        // they will end dragging at one point with mouseup/touchend.
        // However, there might be a few cases where mousedown/touchstart events get registered,
        // but the draggable element gets removed before user ends dragging.
        // In that case, we need to remove the attached listeners that happened during the mousedown/touchstart events.
        if (this.nestedListeners) {
            this.nestedListeners.map(function (event) { return event(); });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DragEventListenerService.prototype.getNativeEventObject = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (((/** @type {?} */ (event))).hasOwnProperty('changedTouches')) {
            return ((/** @type {?} */ (event))).changedTouches[0];
        }
        else {
            return event;
        }
    };
    /**
     * @param {?} element
     * @param {?} startOnEvent
     * @param {?} moveOnEvent
     * @param {?} endOnEvent
     * @return {?}
     */
    DragEventListenerService.prototype.customDragEvent = /**
     * @param {?} element
     * @param {?} startOnEvent
     * @param {?} moveOnEvent
     * @param {?} endOnEvent
     * @return {?}
     */
    function (element, startOnEvent, moveOnEvent, endOnEvent) {
        var _this = this;
        return this.renderer.listen(element, startOnEvent, function (startEvent) {
            // save the initial point to initialPosition
            // this will be used to calculate how far the draggable has been dragged from its initial position
            _this.initialPosition = {
                pageX: _this.getNativeEventObject(startEvent).pageX,
                pageY: _this.getNativeEventObject(startEvent).pageY,
            };
            // Initialize nested listeners' property with a new empty array;
            _this.nestedListeners = [];
            // This is needed to disable selection during dragging (especially in EDGE/IE11).
            _this.nestedListeners.push(_this.renderer.listen('document', 'selectstart', function (selectEvent) {
                selectEvent.preventDefault();
                selectEvent.stopImmediatePropagation();
            }));
            // Listen to mousemove/touchmove events outside of angular zone.
            _this.nestedListeners.push(_this.ngZone.runOutsideAngular(function () {
                return _this.renderer.listen('document', moveOnEvent, function (moveEvent) {
                    // Event.stopImmediatePropagation() is needed here to prevent nested draggables from getting dragged
                    // altogether. We shouldn't use Event.stopPropagation() here as we are listening to the events
                    // on the global element level.
                    // With Event.stopImmediatePropagation(), it registers the events sent from the inner most draggable
                    // first. Then immediately after that, it stops listening to the same type of events on the same
                    // element. So this will help us to not register the same events that would come from the parent
                    // level draggables eventually.
                    moveEvent.stopImmediatePropagation();
                    if (!_this.hasDragStarted) {
                        _this.hasDragStarted = true;
                        // Fire "dragstart"
                        _this.broadcast(moveEvent, DragEventType.DRAG_START);
                    }
                    else {
                        // Fire "dragmove"
                        _this.broadcast(moveEvent, DragEventType.DRAG_MOVE);
                    }
                });
            }));
            // Listen to mouseup/touchend events.
            _this.nestedListeners.push(_this.renderer.listen('document', endOnEvent, function (endEvent) {
                if (_this.hasDragStarted) {
                    // Fire "dragend" only if dragstart is registered
                    _this.hasDragStarted = false;
                    _this.broadcast(endEvent, DragEventType.DRAG_END);
                }
                // We must remove the the nested listeners every time drag completes.
                if (_this.nestedListeners) {
                    _this.nestedListeners.map(function (event) { return event(); });
                }
            }));
        });
    };
    /**
     * @param {?} event
     * @param {?} eventType
     * @return {?}
     */
    DragEventListenerService.prototype.broadcast = /**
     * @param {?} event
     * @param {?} eventType
     * @return {?}
     */
    function (event, eventType) {
        /** @type {?} */
        var dragEvent = this.generateDragEvent(event, eventType);
        switch (dragEvent.type) {
            case DragEventType.DRAG_START:
                this.dragStart.next(dragEvent);
                break;
            case DragEventType.DRAG_MOVE:
                this.dragMove.next(dragEvent);
                break;
            case DragEventType.DRAG_END:
                this.dragEnd.next(dragEvent);
                break;
            default:
                break;
        }
        // The following properties are set after they are broadcasted to the DraggableGhost component.
        dragEvent.ghostElement = this.ghostElement;
        dragEvent.dropPointPosition = this.dropPointPosition;
        this.eventBus.broadcast(dragEvent);
    };
    /**
     * @param {?} event
     * @param {?} eventType
     * @return {?}
     */
    DragEventListenerService.prototype.generateDragEvent = /**
     * @param {?} event
     * @param {?} eventType
     * @return {?}
     */
    function (event, eventType) {
        /** @type {?} */
        var nativeEvent = this.getNativeEventObject(event);
        return {
            type: eventType,
            dragPosition: {
                pageX: nativeEvent.pageX,
                pageY: nativeEvent.pageY,
                moveX: nativeEvent.pageX - this.initialPosition.pageX,
                moveY: nativeEvent.pageY - this.initialPosition.pageY,
            },
            group: this.group,
            dragDataTransfer: this.dragDataTransfer,
            ghostElement: this.ghostElement,
        };
    };
    DragEventListenerService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DragEventListenerService.ctorParameters = function () { return [
        { type: NgZone },
        { type: Renderer2 },
        { type: DragAndDropEventBusService }
    ]; };
    return DragEventListenerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This service is used to capture the state of clrDraggable element
// at a certain event and passes it to clrDraggableGhost component.
/**
 * @template T
 */
var DraggableSnapshotService = /** @class */ (function () {
    function DraggableSnapshotService(domAdapter) {
        this.domAdapter = domAdapter;
    }
    /**
     * @param {?} el
     * @param {?} event
     * @return {?}
     */
    DraggableSnapshotService.prototype.capture = /**
     * @param {?} el
     * @param {?} event
     * @return {?}
     */
    function (el, event) {
        this.draggableElClientRect = this.domAdapter.clientRect(el);
        this.snapshotDragEvent = event;
    };
    /**
     * @return {?}
     */
    DraggableSnapshotService.prototype.discard = /**
     * @return {?}
     */
    function () {
        delete this.draggableElClientRect;
        delete this.snapshotDragEvent;
    };
    Object.defineProperty(DraggableSnapshotService.prototype, "hasDraggableState", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.snapshotDragEvent && !!this.draggableElClientRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DraggableSnapshotService.prototype, "clientRect", {
        get: /**
         * @return {?}
         */
        function () {
            return this.draggableElClientRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DraggableSnapshotService.prototype, "dragEvent", {
        get: /**
         * @return {?}
         */
        function () {
            return this.snapshotDragEvent;
        },
        enumerable: true,
        configurable: true
    });
    DraggableSnapshotService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DraggableSnapshotService.ctorParameters = function () { return [
        { type: DomAdapter }
    ]; };
    return DraggableSnapshotService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDraggableGhost = /** @class */ (function () {
    function ClrDraggableGhost(el, dragEventListener, draggableSnapshot, renderer, ngZone) {
        var _this = this;
        this.el = el;
        this.dragEventListener = dragEventListener;
        this.draggableSnapshot = draggableSnapshot;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.subscriptions = [];
        this.leaveAnimConfig = { value: 0, params: { top: '0px', left: '0px' } };
        if (!this.dragEventListener || !this.draggableSnapshot) {
            throw new Error('The clr-draggable-ghost component can only be used inside of a clrDraggable directive.');
        }
        this.draggableGhostEl = this.el.nativeElement;
        // Need to use Renderer2 as it runs outside of NgZone
        this.renderer.addClass(this.draggableGhostEl, 'draggable-ghost');
        // Register the ghost element in DragEventListener to pass in a ClrDragEvent.
        this.dragEventListener.ghostElement = this.draggableGhostEl;
        // Default ghost size gets the size of ClrDraggable element.
        this.setDefaultGhostSize(this.draggableGhostEl);
        /** @type {?} */
        var offset = {
            top: this.draggableSnapshot.hasDraggableState
                ? this.draggableSnapshot.dragEvent.dragPosition.pageY - this.draggableSnapshot.clientRect.top
                : 0,
            left: this.draggableSnapshot.hasDraggableState
                ? this.draggableSnapshot.dragEvent.dragPosition.pageX - this.draggableSnapshot.clientRect.left
                : 0,
        };
        /** @type {?} */
        var isAnimationConfigured = false;
        this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
            // On the first drag move event, we configure the animation as it's dependent on the first drag event.
            if (!isAnimationConfigured) {
                if (_this.draggableSnapshot.hasDraggableState) {
                    _this.animateToOnLeave(_this.draggableSnapshot.clientRect.top + "px", _this.draggableSnapshot.clientRect.left + "px");
                }
                else {
                    _this.animateToOnLeave(event.dragPosition.pageY + "px", event.dragPosition.pageX + "px");
                }
                isAnimationConfigured = true;
            }
            // Position the draggable ghost.
            /** @type {?} */
            var topLeftPosition = _this.findTopLeftPosition(event.dragPosition, offset);
            _this.setPositionStyle(_this.draggableGhostEl, topLeftPosition.pageX, topLeftPosition.pageY);
            _this.dragEventListener.dropPointPosition = _this.findDropPointPosition(topLeftPosition);
        }));
    }
    /**
     * @param {?} el
     * @return {?}
     */
    ClrDraggableGhost.prototype.setDefaultGhostSize = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        if (this.draggableSnapshot.hasDraggableState) {
            this.setSizeStyle(el, this.draggableSnapshot.clientRect.width, this.draggableSnapshot.clientRect.height);
        }
    };
    /**
     * @param {?} top
     * @param {?} left
     * @return {?}
     */
    ClrDraggableGhost.prototype.animateToOnLeave = /**
     * @param {?} top
     * @param {?} left
     * @return {?}
     */
    function (top, left) {
        var _this = this;
        this.ngZone.run(function () {
            _this.leaveAnimConfig = { value: 0, params: { top: top, left: left } };
        });
    };
    /**
     * @param {?} dragPosition
     * @param {?} offset
     * @return {?}
     */
    ClrDraggableGhost.prototype.findTopLeftPosition = /**
     * @param {?} dragPosition
     * @param {?} offset
     * @return {?}
     */
    function (dragPosition, offset) {
        return { pageX: dragPosition.pageX - offset.left, pageY: dragPosition.pageY - offset.top };
    };
    /**
     * @param {?} topLeftPosition
     * @return {?}
     */
    ClrDraggableGhost.prototype.findDropPointPosition = /**
     * @param {?} topLeftPosition
     * @return {?}
     */
    function (topLeftPosition) {
        if (this.draggableSnapshot.hasDraggableState) {
            return {
                pageX: topLeftPosition.pageX + this.draggableSnapshot.clientRect.width / 2,
                pageY: topLeftPosition.pageY + this.draggableSnapshot.clientRect.height / 2,
            };
        }
        else {
            return topLeftPosition;
        }
    };
    /**
     * @param {?} el
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    ClrDraggableGhost.prototype.setSizeStyle = /**
     * @param {?} el
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    function (el, width, height) {
        this.renderer.setStyle(el, 'width', width + "px");
        this.renderer.setStyle(el, 'height', height + "px");
    };
    /**
     * @param {?} el
     * @param {?} left
     * @param {?} top
     * @return {?}
     */
    ClrDraggableGhost.prototype.setPositionStyle = /**
     * @param {?} el
     * @param {?} left
     * @param {?} top
     * @return {?}
     */
    function (el, left, top) {
        this.renderer.setStyle(el, 'left', left + "px");
        this.renderer.setStyle(el, 'top', top + "px");
        this.renderer.setStyle(el, 'visibility', 'visible');
    };
    /**
     * @return {?}
     */
    ClrDraggableGhost.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrDraggableGhost.decorators = [
        { type: Component, args: [{
                    selector: 'clr-draggable-ghost',
                    template: "<ng-content></ng-content>",
                    animations: [
                        trigger('leaveAnimation', [
                            transition(':leave', [
                                style({ left: '*', top: '*' }),
                                animate('0.2s ease-in-out', style({ top: '{{top}}', left: '{{left}}' })),
                            ]),
                        ]),
                    ]
                }] }
    ];
    /** @nocollapse */
    ClrDraggableGhost.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DragEventListenerService, decorators: [{ type: Optional }] },
        { type: DraggableSnapshotService, decorators: [{ type: Optional }] },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    ClrDraggableGhost.propDecorators = {
        leaveAnimConfig: [{ type: HostBinding, args: ['@leaveAnimation',] }]
    };
    return ClrDraggableGhost;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This structural directive will be used mainly together with `clr-draggable-ghost` directive inside of clrDraggable
// directive. The directive is responsible for instantiating `clr-draggable-ghost` directive only during dragging so
// that Angular Change Detection is prevented from running if a component or directive is placed inside of the
// `clr-draggable-ghost` directive.
/**
 * @template T
 */
var ClrIfDragged = /** @class */ (function () {
    function ClrIfDragged(template, container, dragEventListener) {
        var _this = this;
        this.template = template;
        this.container = container;
        this.dragEventListener = dragEventListener;
        this.subscriptions = [];
        if (!this.dragEventListener || !this.container) {
            throw new Error('The *clrIfDragged directive can only be used inside of a clrDraggable directive.');
        }
        this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
            _this.container.createEmbeddedView(_this.template);
        }));
        this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
            _this.container.clear();
        }));
    }
    /**
     * @return {?}
     */
    ClrIfDragged.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrIfDragged.decorators = [
        { type: Directive, args: [{ selector: '[clrIfDragged]' },] }
    ];
    /** @nocollapse */
    ClrIfDragged.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: DragEventListenerService, decorators: [{ type: Optional }] }
    ]; };
    return ClrIfDragged;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This provider registers the drag handle element.
// When it registers a element as a drag handle, it attaches that element to the listeners from ClrDragEventListener.
// Also, it adds the "drag-handle" css class to the registered element through Renderer.
/**
 * @template T
 */
var DragHandleRegistrarService = /** @class */ (function () {
    function DragHandleRegistrarService(dragEventListener, renderer) {
        this.dragEventListener = dragEventListener;
        this.renderer = renderer;
    }
    Object.defineProperty(DragHandleRegistrarService.prototype, "defaultHandleEl", {
        get: /**
         * @return {?}
         */
        function () {
            return this._defaultHandleEl;
        },
        set: /**
         * @param {?} el
         * @return {?}
         */
        function (el) {
            this._defaultHandleEl = el; // defaultHandleEl will be usually the clrDraggable element.
            // If the customHandleEl has been registered,
            // don't make the defaultHandleEl the drag handle yet until the customHandleEl is unregistered.
            if (!this._customHandleEl) {
                this.makeElementHandle(this._defaultHandleEl);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} el
     * @return {?}
     */
    DragHandleRegistrarService.prototype.makeElementHandle = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        if (this._defaultHandleEl && this._defaultHandleEl !== el) {
            // Before making an element the custom handle element,
            // we should remove the existing drag-handle class from the draggable element.
            this.renderer.removeClass(this._defaultHandleEl, 'drag-handle');
        }
        this.dragEventListener.attachDragListeners(el);
        this.renderer.addClass(el, 'drag-handle');
    };
    Object.defineProperty(DragHandleRegistrarService.prototype, "customHandleEl", {
        get: /**
         * @return {?}
         */
        function () {
            return this._customHandleEl;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} el
     * @return {?}
     */
    DragHandleRegistrarService.prototype.registerCustomHandle = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        this.dragEventListener.detachDragListeners(); // removes the existing listeners
        this._customHandleEl = el;
        this.makeElementHandle(this._customHandleEl);
    };
    /**
     * @return {?}
     */
    DragHandleRegistrarService.prototype.unregisterCustomHandle = /**
     * @return {?}
     */
    function () {
        this.dragEventListener.detachDragListeners(); // removes the existing listeners
        this.renderer.removeClass(this._customHandleEl, 'drag-handle');
        delete this._customHandleEl;
        // if default handle is set, make that handle
        if (this._defaultHandleEl) {
            this.makeElementHandle(this._defaultHandleEl);
        }
    };
    DragHandleRegistrarService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DragHandleRegistrarService.ctorParameters = function () { return [
        { type: DragEventListenerService },
        { type: Renderer2 }
    ]; };
    return DragHandleRegistrarService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// This service class adds and removes the "in-drag" class to the document body element
// through its public enter() and exit() methods.
var GlobalDragModeService = /** @class */ (function () {
    function GlobalDragModeService(renderer) {
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    GlobalDragModeService.prototype.enter = /**
     * @return {?}
     */
    function () {
        this.renderer.addClass(document.body, 'in-drag');
    };
    /**
     * @return {?}
     */
    GlobalDragModeService.prototype.exit = /**
     * @return {?}
     */
    function () {
        this.renderer.removeClass(document.body, 'in-drag');
    };
    GlobalDragModeService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    GlobalDragModeService.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    return GlobalDragModeService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDraggable = /** @class */ (function () {
    function ClrDraggable(el, dragEventListener, dragHandleRegistrar, viewContainerRef, cfr, injector, draggableSnapshot, globalDragMode) {
        this.el = el;
        this.dragEventListener = dragEventListener;
        this.dragHandleRegistrar = dragHandleRegistrar;
        this.viewContainerRef = viewContainerRef;
        this.cfr = cfr;
        this.injector = injector;
        this.draggableSnapshot = draggableSnapshot;
        this.globalDragMode = globalDragMode;
        this.subscriptions = [];
        this.dragOn = false;
        this.dragStartEmitter = new EventEmitter();
        this.dragMoveEmitter = new EventEmitter();
        this.dragEndEmitter = new EventEmitter();
        this.draggableEl = this.el.nativeElement;
        this.componentFactory = this.cfr.resolveComponentFactory(ClrDraggableGhost);
    }
    Object.defineProperty(ClrDraggable.prototype, "dataTransfer", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dragEventListener.dragDataTransfer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDraggable.prototype, "group", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.dragEventListener.group = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    ClrDraggable.prototype.createDefaultGhost = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.draggableSnapshot.capture(this.draggableEl, event);
        // NOTE: The default ghost element will appear
        // next to the clrDraggable in the DOM as a sibling element.
        this.viewContainerRef.createComponent(this.componentFactory, 0, this.injector, [
            [this.draggableEl.cloneNode(true)],
        ]);
    };
    /**
     * @return {?}
     */
    ClrDraggable.prototype.destroyDefaultGhost = /**
     * @return {?}
     */
    function () {
        this.viewContainerRef.clear();
        this.draggableSnapshot.discard();
    };
    /**
     * @return {?}
     */
    ClrDraggable.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dragHandleRegistrar.defaultHandleEl = this.draggableEl;
        this.subscriptions.push(this.dragEventListener.dragStarted.subscribe(function (event) {
            _this.globalDragMode.enter();
            _this.dragOn = true;
            if (!_this.customGhost) {
                _this.createDefaultGhost(event);
            }
            _this.dragStartEmitter.emit(new ClrDragEvent(event));
        }));
        this.subscriptions.push(this.dragEventListener.dragMoved.subscribe(function (event) {
            _this.dragMoveEmitter.emit(new ClrDragEvent(event));
        }));
        this.subscriptions.push(this.dragEventListener.dragEnded.subscribe(function (event) {
            _this.globalDragMode.exit();
            _this.dragOn = false;
            if (!_this.customGhost) {
                _this.destroyDefaultGhost();
            }
            _this.dragEndEmitter.emit(new ClrDragEvent(event));
        }));
    };
    /**
     * @return {?}
     */
    ClrDraggable.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        this.dragEventListener.detachDragListeners();
    };
    ClrDraggable.decorators = [
        { type: Directive, args: [{
                    selector: '[clrDraggable]',
                    providers: [
                        DragEventListenerService,
                        DragHandleRegistrarService,
                        DraggableSnapshotService,
                        GlobalDragModeService,
                        DomAdapter,
                    ],
                    host: { '[class.draggable]': 'true', '[class.being-dragged]': 'dragOn' },
                },] }
    ];
    /** @nocollapse */
    ClrDraggable.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DragEventListenerService },
        { type: DragHandleRegistrarService },
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver },
        { type: Injector },
        { type: DraggableSnapshotService },
        { type: GlobalDragModeService }
    ]; };
    ClrDraggable.propDecorators = {
        customGhost: [{ type: ContentChild, args: [ClrIfDragged,] }],
        dataTransfer: [{ type: Input, args: ['clrDraggable',] }],
        group: [{ type: Input, args: ['clrGroup',] }],
        dragStartEmitter: [{ type: Output, args: ['clrDragStart',] }],
        dragMoveEmitter: [{ type: Output, args: ['clrDragMove',] }],
        dragEndEmitter: [{ type: Output, args: ['clrDragEnd',] }]
    };
    return ClrDraggable;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDroppable = /** @class */ (function () {
    function ClrDroppable(el, eventBus, domAdapter, renderer) {
        this.el = el;
        this.eventBus = eventBus;
        this.domAdapter = domAdapter;
        this.renderer = renderer;
        this.isDraggableMatch = false;
        this._isDraggableOver = false;
        this._dropTolerance = { top: 0, right: 0, bottom: 0, left: 0 };
        this.dragStartEmitter = new EventEmitter();
        this.dragMoveEmitter = new EventEmitter();
        this.dragEndEmitter = new EventEmitter();
        this.dragLeaveEmitter = new EventEmitter();
        this.dragEnterEmitter = new EventEmitter();
        this.dropEmitter = new EventEmitter();
        this.droppableEl = this.el.nativeElement;
    }
    Object.defineProperty(ClrDroppable.prototype, "isDraggableOver", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // We need to add/remove this draggable-over class via Renderer2
            // because isDraggableOver is set outside of NgZone.
            if (value) {
                this.renderer.addClass(this.droppableEl, 'draggable-over');
            }
            else {
                this.renderer.removeClass(this.droppableEl, 'draggable-over');
            }
            this._isDraggableOver = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDroppable.prototype, "group", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._group = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} top
     * @param {?=} right
     * @param {?=} bottom
     * @param {?=} left
     * @return {?}
     */
    ClrDroppable.prototype.dropToleranceGenerator = /**
     * @param {?=} top
     * @param {?=} right
     * @param {?=} bottom
     * @param {?=} left
     * @return {?}
     */
    function (top, right, bottom, left) {
        if (top === void 0) { top = 0; }
        if (right === void 0) { right = top; }
        if (bottom === void 0) { bottom = top; }
        if (left === void 0) { left = right; }
        return { top: top, right: right, bottom: bottom, left: left };
    };
    Object.defineProperty(ClrDroppable.prototype, "dropTolerance", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // If user provides an object here and wants to manipulate/update properties individually,
            // the object must be immutable as we generate new object based user's given object.
            if (typeof value === 'number') {
                this._dropTolerance = this.dropToleranceGenerator(value);
            }
            else if (typeof value === 'string') {
                /** @type {?} */
                var toleranceValues = value
                    .trim()
                    .split(/\s+/)
                    .map(function (tolerance) { return parseInt(tolerance, 10); });
                this._dropTolerance = this.dropToleranceGenerator.apply(this, __spread(toleranceValues));
            }
            else if (value) {
                // The value could be passed in as {left: 20, top: 30 }
                // In this case, the rest of the direction properties should be 0.
                // That's why we initialize properties with 0 first, then override with user's given value.
                this._dropTolerance = __assign({}, this.dropToleranceGenerator(0), value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} subscription
     * @return {?}
     */
    ClrDroppable.prototype.unsubscribeFrom = /**
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) {
        if (subscription) {
            subscription.unsubscribe();
        }
    };
    /**
     * @param {?} draggableGroup
     * @return {?}
     */
    ClrDroppable.prototype.checkGroupMatch = /**
     * @param {?} draggableGroup
     * @return {?}
     */
    function (draggableGroup) {
        // Both Draggable and Droppable have clrGroup input.
        // The clrGroup input can be both a string key or array of string keys in Draggable and Droppable.
        // It's not match if Draggable has no defined value assigned to clrGroup, but Droppable has a defined clrGroup.
        if (!draggableGroup && this._group) {
            return false;
        }
        // The same is true the other way round.
        if (!this._group && draggableGroup) {
            return false;
        }
        // It's match if both Draggable and Droppable have no assigned value for clrGroup.
        if (!this._group && !draggableGroup) {
            return true;
        }
        // It's match if both Draggable and Droppable have simple string keys that are matching.
        // It's match if Draggable's simple clrGroup key is matching with one of the clrGroup keys of Droppable. The
        // same is true the other way round.
        // it's match if one of the clrGroup keys of Droppable is matching with one of the clrGroup keys of Draggable.
        if (typeof draggableGroup === 'string') {
            if (typeof this._group === 'string') {
                return this._group === draggableGroup;
            }
            else {
                return this._group.indexOf(draggableGroup) > -1;
            }
        }
        else {
            if (typeof this._group === 'string') {
                return draggableGroup.indexOf(this._group) > -1;
            }
            else {
                return ((/** @type {?} */ (this._group))).some(function (groupKey) { return draggableGroup.indexOf(groupKey) > -1; });
            }
        }
    };
    /**
     * @param {?} point
     * @return {?}
     */
    ClrDroppable.prototype.isInDropArea = /**
     * @param {?} point
     * @return {?}
     */
    function (point) {
        if (!point) {
            return false;
        }
        if (!this.clientRect) {
            this.clientRect = this.domAdapter.clientRect(this.droppableEl);
        }
        if (point.pageX >= this.clientRect.left - this._dropTolerance.left &&
            point.pageX <= this.clientRect.right + this._dropTolerance.right &&
            point.pageY >= this.clientRect.top - this._dropTolerance.top &&
            point.pageY <= this.clientRect.bottom + this._dropTolerance.bottom) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} dragStartEvent
     * @return {?}
     */
    ClrDroppable.prototype.onDragStart = /**
     * @param {?} dragStartEvent
     * @return {?}
     */
    function (dragStartEvent) {
        var _this = this;
        // Check draggable and droppable have a matching group key.
        this.isDraggableMatch = this.checkGroupMatch(dragStartEvent.group);
        // Subscribe to dragMoved and dragEnded only if draggable and droppable have a matching group key.
        if (this.isDraggableMatch) {
            this.dragStartEmitter.emit(new ClrDragEvent(dragStartEvent));
            this.dragMoveSubscription = this.eventBus.dragMoved.subscribe(function (dragMoveEvent) {
                _this.onDragMove(dragMoveEvent);
            });
            this.dragEndSubscription = this.eventBus.dragEnded.subscribe(function (dragEndEvent) {
                _this.onDragEnd(dragEndEvent);
            });
        }
    };
    /**
     * @param {?} dragMoveEvent
     * @return {?}
     */
    ClrDroppable.prototype.onDragMove = /**
     * @param {?} dragMoveEvent
     * @return {?}
     */
    function (dragMoveEvent) {
        /** @type {?} */
        var isInDropArea = this.isInDropArea(dragMoveEvent.dropPointPosition);
        if (!this._isDraggableOver && isInDropArea) {
            this.isDraggableOver = true;
            /** @type {?} */
            var dragEnterEvent = __assign({}, dragMoveEvent, { type: DragEventType.DRAG_ENTER });
            this.eventBus.broadcast(dragEnterEvent);
            this.dragEnterEmitter.emit(new ClrDragEvent(dragEnterEvent));
        }
        else if (this._isDraggableOver && !isInDropArea) {
            this.isDraggableOver = false;
            /** @type {?} */
            var dragLeaveEvent = __assign({}, dragMoveEvent, { type: DragEventType.DRAG_LEAVE });
            this.eventBus.broadcast(dragLeaveEvent);
            this.dragLeaveEmitter.emit(new ClrDragEvent(dragLeaveEvent));
        }
        this.dragMoveEmitter.emit(new ClrDragEvent(dragMoveEvent));
    };
    /**
     * @param {?} dragEndEvent
     * @return {?}
     */
    ClrDroppable.prototype.onDragEnd = /**
     * @param {?} dragEndEvent
     * @return {?}
     */
    function (dragEndEvent) {
        if (this._isDraggableOver) {
            if (dragEndEvent.ghostElement) {
                // By this point, the draggable ghost component is destroyed,
                // but the element would be active until its animation completes.
                // As such, once the ghost is dropped over, we will give it "dropped" class.
                // This process cannot be done in the ghost component
                // because any subscription to the drop event is ineffective or invalid
                // as the component had been already destroyed.
                this.renderer.addClass(dragEndEvent.ghostElement, 'dropped');
            }
            /** @type {?} */
            var dropEvent = __assign({}, dragEndEvent, { type: DragEventType.DROP });
            this.eventBus.broadcast(dropEvent);
            this.dropEmitter.emit(new ClrDragEvent(dropEvent));
            this.isDraggableOver = false;
        }
        this.dragEndEmitter.emit(new ClrDragEvent(dragEndEvent));
        this.unsubscribeFrom(this.dragMoveSubscription);
        this.unsubscribeFrom(this.dragEndSubscription);
        this.isDraggableMatch = false;
        delete this.clientRect;
    };
    /**
     * @return {?}
     */
    ClrDroppable.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dragStartSubscription = this.eventBus.dragStarted.subscribe(function (dragStartEvent) {
            _this.onDragStart(dragStartEvent);
        });
    };
    /**
     * @return {?}
     */
    ClrDroppable.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.unsubscribeFrom(this.dragStartSubscription);
        this.unsubscribeFrom(this.dragMoveSubscription);
        this.unsubscribeFrom(this.dragEndSubscription);
    };
    ClrDroppable.decorators = [
        { type: Directive, args: [{
                    selector: '[clrDroppable]',
                    providers: [DomAdapter],
                    host: { '[class.droppable]': 'true', '[class.draggable-match]': 'isDraggableMatch' },
                },] }
    ];
    /** @nocollapse */
    ClrDroppable.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DragAndDropEventBusService },
        { type: DomAdapter },
        { type: Renderer2 }
    ]; };
    ClrDroppable.propDecorators = {
        group: [{ type: Input, args: ['clrGroup',] }],
        dropTolerance: [{ type: Input, args: ['clrDropTolerance',] }],
        dragStartEmitter: [{ type: Output, args: ['clrDragStart',] }],
        dragMoveEmitter: [{ type: Output, args: ['clrDragMove',] }],
        dragEndEmitter: [{ type: Output, args: ['clrDragEnd',] }],
        dragLeaveEmitter: [{ type: Output, args: ['clrDragLeave',] }],
        dragEnterEmitter: [{ type: Output, args: ['clrDragEnter',] }],
        dropEmitter: [{ type: Output, args: ['clrDrop',] }]
    };
    return ClrDroppable;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDragHandle = /** @class */ (function () {
    function ClrDragHandle(el, dragHandleRegistrar) {
        this.el = el;
        this.dragHandleRegistrar = dragHandleRegistrar;
        if (!this.dragHandleRegistrar) {
            // ClrDragHandleRegistrar is provided in ClrDraggable so we expect it to be present here
            // as clrDragHandle is required to be used only inside of a clrDraggable directive.
            throw new Error('The clrDragHandle directive can only be used inside of a clrDraggable directive.');
        }
        this.dragHandleRegistrar.registerCustomHandle(this.el.nativeElement);
    }
    /**
     * @return {?}
     */
    ClrDragHandle.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.dragHandleRegistrar.unregisterCustomHandle();
    };
    ClrDragHandle.decorators = [
        { type: Directive, args: [{ selector: '[clrDragHandle]', host: { '[class.drag-handle]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrDragHandle.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DragHandleRegistrarService, decorators: [{ type: Optional }] }
    ]; };
    return ClrDragHandle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_DRAG_AND_DROP_DIRECTIVES = [
    ClrDraggable,
    ClrDroppable,
    ClrIfDragged,
    ClrDragHandle,
    ClrDraggableGhost,
];
var ClrDragAndDropModule = /** @class */ (function () {
    function ClrDragAndDropModule() {
    }
    ClrDragAndDropModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [CLR_DRAG_AND_DROP_DIRECTIVES],
                    entryComponents: [ClrDraggableGhost],
                    exports: [CLR_DRAG_AND_DROP_DIRECTIVES],
                },] }
    ];
    return ClrDragAndDropModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DatagridRowExpandAnimation = /** @class */ (function () {
    function DatagridRowExpandAnimation(el, domAdapter, renderer, expand) {
        var _this = this;
        this.el = el;
        this.domAdapter = domAdapter;
        this.renderer = renderer;
        this.expand = expand;
        if (expand && expand.animate) {
            expand.animate.subscribe(function () {
                // We already had an animation waiting, so we just have to run in, not prepare again
                if (_this.oldHeight) {
                    setTimeout(function () { return _this.run(); });
                }
                else {
                    _this.animate();
                }
            });
        }
    }
    /*
       * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
       * They're working on it, but have no ETA.
       */
    /*
         * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
         * They're working on it, but have no ETA.
         */
    /**
     * @return {?}
     */
    DatagridRowExpandAnimation.prototype.animate = /*
         * Dirty manual animation handling, but we have no way to use dynamic heights in Angular's current API.
         * They're working on it, but have no ETA.
         */
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Check if we do have web-animations available. If not, just skip the animation.
        if (!this.el.nativeElement.animate) {
            return;
        }
        // We had an animation running, we skip to the end
        if (this.running) {
            this.running.finish();
        }
        this.oldHeight = this.domAdapter.computedHeight(this.el.nativeElement);
        // In case height has not yet been set. When starting expanded, for example.
        // See https://github.com/vmware/clarity/issues/2904
        if (isNaN(this.oldHeight)) {
            this.oldHeight = 0;
        }
        // We set the height of the element immediately to avoid a flicker before the animation starts.
        this.renderer.setStyle(this.el.nativeElement, 'height', this.oldHeight + 'px');
        this.renderer.setStyle(this.el.nativeElement, 'overflow-y', 'hidden');
        setTimeout(function () {
            if (_this.expand.loading) {
                return;
            }
            _this.run();
        });
    };
    /**
     * @return {?}
     */
    DatagridRowExpandAnimation.prototype.run = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.renderer.setStyle(this.el.nativeElement, 'height', null);
        /** @type {?} */
        var newHeight = this.domAdapter.computedHeight(this.el.nativeElement);
        this.running = this.el.nativeElement.animate({ height: [this.oldHeight + 'px', newHeight + 'px'], easing: 'ease-in-out' }, { duration: 200 });
        this.running.onfinish = function () {
            _this.renderer.setStyle(_this.el.nativeElement, 'overflow-y', null);
            delete _this.running;
        };
        delete this.oldHeight;
    };
    DatagridRowExpandAnimation.decorators = [
        { type: Directive, args: [{ selector: 'clr-dg-row' },] }
    ];
    /** @nocollapse */
    DatagridRowExpandAnimation.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DomAdapter },
        { type: Renderer2 },
        { type: Expand }
    ]; };
    return DatagridRowExpandAnimation;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * @abstract
 */
var  /*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * @abstract
 */
CustomFilter = /** @class */ (function () {
    function CustomFilter() {
    }
    return CustomFilter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * This provider implements some form of synchronous debouncing through a lock pattern
 * to avoid emitting multiple state changes for a single user action.
 */
var StateDebouncer = /** @class */ (function () {
    function StateDebouncer() {
        /**
         * The Observable that lets other classes subscribe to global state changes
         */
        this._change = new Subject();
        /*
             * This is the lock, to only emit once all the changes have finished processing
             */
        this.nbChanges = 0;
    }
    Object.defineProperty(StateDebouncer.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: 
        // We do not want to expose the Subject itself, but the Observable which is read-only
        /**
         * @return {?}
         */
        function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    StateDebouncer.prototype.changeStart = /**
     * @return {?}
     */
    function () {
        this.nbChanges++;
    };
    /**
     * @return {?}
     */
    StateDebouncer.prototype.changeDone = /**
     * @return {?}
     */
    function () {
        if (--this.nbChanges === 0) {
            this._change.next();
        }
    };
    StateDebouncer.decorators = [
        { type: Injectable }
    ];
    return StateDebouncer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var Page = /** @class */ (function () {
    function Page(stateDebouncer) {
        this.stateDebouncer = stateDebouncer;
        this.activated = false;
        /**
         * Page size, a value of 0 means no pagination
         */
        this._size = 0;
        /**
         * Total items (needed to guess the last page)
         */
        this._totalItems = 0;
        /**
         * The Observable that lets other classes subscribe to page changes
         */
        this._change = new Subject();
        this._sizeChange = new Subject();
        /**
         * Current page
         */
        this._current = 1;
    }
    Object.defineProperty(Page.prototype, "size", {
        get: /**
         * @return {?}
         */
        function () {
            return this._size;
        },
        set: /**
         * @param {?} size
         * @return {?}
         */
        function (size) {
            /** @type {?} */
            var oldSize = this._size;
            if (size !== oldSize) {
                this.stateDebouncer.changeStart();
                this._size = size;
                if (size === 0) {
                    this._current = 1;
                }
                else {
                    // Yeap. That's the formula to keep the first item from the old page still
                    // displayed in the new one.
                    this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
                }
                // We always emit an event even if the current page index didn't change, because
                // the size changing means the items inside the page are different
                this._change.next(this._current);
                this._sizeChange.next(this._size);
                this.stateDebouncer.changeDone();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "totalItems", {
        get: /**
         * @return {?}
         */
        function () {
            return this._totalItems;
        },
        set: /**
         * @param {?} total
         * @return {?}
         */
        function (total) {
            this._totalItems = total;
            // If we have less items than before, we might need to change the current page
            if (this.current > this.last) {
                this.current = this.last;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "last", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._last) {
                return this._last;
            }
            // If the last page isn't known, we compute it from the last item's index
            if (this.size > 0 && this.totalItems) {
                return Math.ceil(this.totalItems / this.size);
            }
            return 1;
        },
        set: /**
         * @param {?} page
         * @return {?}
         */
        function (page) {
            this._last = page;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: 
        // We do not want to expose the Subject itself, but the Observable which is read-only
        /**
         * @return {?}
         */
        function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "sizeChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sizeChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "current", {
        get: /**
         * @return {?}
         */
        function () {
            return this._current;
        },
        set: /**
         * @param {?} page
         * @return {?}
         */
        function (page) {
            if (page !== this._current) {
                this.stateDebouncer.changeStart();
                this._current = page;
                this._change.next(page);
                this.stateDebouncer.changeDone();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Moves to the previous page if it exists
     */
    /**
     * Moves to the previous page if it exists
     * @return {?}
     */
    Page.prototype.previous = /**
     * Moves to the previous page if it exists
     * @return {?}
     */
    function () {
        if (this.current > 1) {
            this.current--;
        }
    };
    /**
     * Moves to the next page if it exists
     */
    /**
     * Moves to the next page if it exists
     * @return {?}
     */
    Page.prototype.next = /**
     * Moves to the next page if it exists
     * @return {?}
     */
    function () {
        if (this.current < this.last) {
            this.current++;
        }
    };
    Object.defineProperty(Page.prototype, "firstItem", {
        /**
         * Index of the first item displayed on the current page, starting at 0
         */
        get: /**
         * Index of the first item displayed on the current page, starting at 0
         * @return {?}
         */
        function () {
            if (this.size === 0) {
                return 0;
            }
            return (this.current - 1) * this.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Page.prototype, "lastItem", {
        /**
         * Index of the last item displayed on the current page, starting at 0
         */
        get: /**
         * Index of the last item displayed on the current page, starting at 0
         * @return {?}
         */
        function () {
            if (this.size === 0) {
                return this.totalItems - 1;
            }
            /** @type {?} */
            var lastInPage = this.current * this.size - 1;
            if (this.totalItems) {
                lastInPage = Math.min(lastInPage, this.totalItems - 1);
            }
            return lastInPage;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the page size to 0
     */
    /**
     * Resets the page size to 0
     * @return {?}
     */
    Page.prototype.resetPageSize = /**
     * Resets the page size to 0
     * @return {?}
     */
    function () {
        this.size = 0;
    };
    Page.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Page.ctorParameters = function () { return [
        { type: StateDebouncer }
    ]; };
    return Page;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var FiltersProvider = /** @class */ (function () {
    function FiltersProvider(_page, stateDebouncer) {
        this._page = _page;
        this.stateDebouncer = stateDebouncer;
        /**
         * This subject is the list of filters that changed last, not the whole list.
         * We emit a list rather than just one filter to allow batch changes to several at once.
         */
        this._change = new Subject();
        /**
         * List of all filters, whether they're active or not
         */
        this._all = [];
    }
    Object.defineProperty(FiltersProvider.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: 
        // We do not want to expose the Subject itself, but the Observable which is read-only
        /**
         * @return {?}
         */
        function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Tests if at least one filter is currently active
     */
    /**
     * Tests if at least one filter is currently active
     * @return {?}
     */
    FiltersProvider.prototype.hasActiveFilters = /**
     * Tests if at least one filter is currently active
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            // We do not use getActiveFilters() because this function will be called much more often
            // and stopping the loop early might be relevant.
            for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                var filter$$1 = _c.value.filter;
                if (filter$$1 && filter$$1.isActive()) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return false;
    };
    /**
     * Returns a list of all currently active filters
     */
    /**
     * Returns a list of all currently active filters
     * @return {?}
     */
    FiltersProvider.prototype.getActiveFilters = /**
     * Returns a list of all currently active filters
     * @return {?}
     */
    function () {
        var e_2, _a;
        /** @type {?} */
        var ret = [];
        try {
            for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                var filter$$1 = _c.value.filter;
                if (filter$$1 && filter$$1.isActive()) {
                    ret.push(filter$$1);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return ret;
    };
    /**
     * Registers a filter, and returns a deregistration function
     */
    /**
     * Registers a filter, and returns a deregistration function
     * @template F
     * @param {?} filter
     * @return {?}
     */
    FiltersProvider.prototype.add = /**
     * Registers a filter, and returns a deregistration function
     * @template F
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        var _this = this;
        /** @type {?} */
        var index = this._all.length;
        /** @type {?} */
        var subscription = filter$$1.changes.subscribe(function () { return _this.resetPageAndEmitFilterChange([filter$$1]); });
        /** @type {?} */
        var hasUnregistered = false;
        /** @type {?} */
        var registered = new RegisteredFilter(filter$$1, function () {
            if (hasUnregistered) {
                return;
            }
            subscription.unsubscribe();
            _this._all.splice(index, 1);
            if (filter$$1.isActive()) {
                _this.resetPageAndEmitFilterChange([]);
            }
            hasUnregistered = true;
        });
        this._all.push(registered);
        if (filter$$1.isActive()) {
            this.resetPageAndEmitFilterChange([filter$$1]);
        }
        return registered;
    };
    /**
     * Accepts an item if it is accepted by all currently active filters
     */
    /**
     * Accepts an item if it is accepted by all currently active filters
     * @param {?} item
     * @return {?}
     */
    FiltersProvider.prototype.accepts = /**
     * Accepts an item if it is accepted by all currently active filters
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var e_3, _a;
        try {
            for (var _b = __values(this._all), _c = _b.next(); !_c.done; _c = _b.next()) {
                var filter$$1 = _c.value.filter;
                if (filter$$1 && filter$$1.isActive() && !filter$$1.accepts(item)) {
                    return false;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return true;
    };
    /**
     * @param {?} filters
     * @return {?}
     */
    FiltersProvider.prototype.resetPageAndEmitFilterChange = /**
     * @param {?} filters
     * @return {?}
     */
    function (filters) {
        this.stateDebouncer.changeStart();
        // filtering may change the page number such that current page number doesn't exist in the filtered dataset.
        // So here we always set the current page to 1 so that it'll fetch first page's data with the given filter.
        this._page.current = 1;
        this._change.next(filters);
        this.stateDebouncer.changeDone();
    };
    FiltersProvider.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FiltersProvider.ctorParameters = function () { return [
        { type: Page },
        { type: StateDebouncer }
    ]; };
    return FiltersProvider;
}());
/**
 * @template T, F
 */
var /**
 * @template T, F
 */
RegisteredFilter = /** @class */ (function () {
    function RegisteredFilter(filter$$1, unregister) {
        this.filter = filter$$1;
        this.unregister = unregister;
    }
    return RegisteredFilter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T, F
 */
var  /**
 * @abstract
 * @template T, F
 */
DatagridFilterRegistrar = /** @class */ (function () {
    function DatagridFilterRegistrar(filters) {
        this.filters = filters;
    }
    Object.defineProperty(DatagridFilterRegistrar.prototype, "filter", {
        get: /**
         * @return {?}
         */
        function () {
            return this.registered && this.registered.filter;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} filter
     * @return {?}
     */
    DatagridFilterRegistrar.prototype.setFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        // If we previously had another filter, we unregister it
        this.deleteFilter();
        if (filter$$1 instanceof RegisteredFilter) {
            this.registered = filter$$1;
        }
        else if (filter$$1) {
            this.registered = this.filters.add(filter$$1);
        }
    };
    /**
     * @return {?}
     */
    DatagridFilterRegistrar.prototype.deleteFilter = /**
     * @return {?}
     */
    function () {
        if (this.registered) {
            this.registered.unregister();
            delete this.registered;
        }
    };
    /**
     * @return {?}
     */
    DatagridFilterRegistrar.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.deleteFilter();
    };
    return DatagridFilterRegistrar;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Custom filter that can be added in any column to override the default object property string filter.
 * The reason this is not just an input on DatagridColumn is because we need the filter's template to be projected,
 * since it can be anything (not just a text input).
 * @template T
 */
var ClrDatagridFilter = /** @class */ (function (_super) {
    __extends(ClrDatagridFilter, _super);
    function ClrDatagridFilter(_filters, commonStrings) {
        var _this = _super.call(this, _filters) || this;
        _this.commonStrings = commonStrings;
        _this.anchorPoint = Point.RIGHT_BOTTOM;
        _this.popoverPoint = Point.RIGHT_TOP;
        _this.popoverOptions = { allowMultipleOpen: true };
        /**
         * Tracks whether the filter dropdown is open or not
         */
        _this._open = false;
        _this.openChanged = new EventEmitter(false);
        return _this;
    }
    Object.defineProperty(ClrDatagridFilter.prototype, "open", {
        get: /**
         * @return {?}
         */
        function () {
            return this._open;
        },
        set: /**
         * @param {?} open
         * @return {?}
         */
        function (open) {
            /** @type {?} */
            var boolOpen = !!open;
            if (boolOpen !== this._open) {
                this._open = boolOpen;
                this.openChanged.emit(boolOpen);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridFilter.prototype, "customFilter", {
        set: /**
         * @param {?} filter
         * @return {?}
         */
        function (filter$$1) {
            this.setFilter(filter$$1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridFilter.prototype, "active", {
        /**
         * Indicates if the filter is currently active
         */
        get: /**
         * Indicates if the filter is currently active
         * @return {?}
         */
        function () {
            return !!this.filter && this.filter.isActive();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows/hides the filter dropdown
     */
    /**
     * Shows/hides the filter dropdown
     * @return {?}
     */
    ClrDatagridFilter.prototype.toggle = /**
     * Shows/hides the filter dropdown
     * @return {?}
     */
    function () {
        this.open = !this.open;
    };
    ClrDatagridFilter.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-filter',
                    // We register this component as a CustomFilter, for the parent column to detect it.
                    providers: [{ provide: CustomFilter, useExisting: ClrDatagridFilter }],
                    template: "\n        <button #anchor class=\"datagrid-filter-toggle\" (click)=\"toggle()\"\n            [class.datagrid-filter-open]=\"open\" [class.datagrid-filtered]=\"active\"\n            type=\"button\"></button>\n\n        <ng-template [(clrPopoverOld)]=\"open\" [clrPopoverOldAnchor]=\"anchor\" [clrPopoverOldAnchorPoint]=\"anchorPoint\"\n             [clrPopoverOldPopoverPoint]=\"popoverPoint\" [clrPopoverOldOptions]=\"popoverOptions\">\n            <div class=\"datagrid-filter\">\n                <!-- FIXME: this whole filter part needs a final design before we can try to have a cleaner DOM -->\n                <div class=\"datagrid-filter-close-wrapper\">\n                    <button type=\"button\" class=\"close\" (click)=\"open = false\">\n                        <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n                    </button>\n                </div>\n    \n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n    "
                }] }
    ];
    /** @nocollapse */
    ClrDatagridFilter.ctorParameters = function () { return [
        { type: FiltersProvider },
        { type: ClrCommonStrings }
    ]; };
    ClrDatagridFilter.propDecorators = {
        open: [{ type: Input, args: ['clrDgFilterOpen',] }],
        openChanged: [{ type: Output, args: ['clrDgFilterOpenChange',] }],
        customFilter: [{ type: Input, args: ['clrDgFilter',] }]
    };
    return ClrDatagridFilter;
}(DatagridFilterRegistrar));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Generic accessor for deep object properties
 * that can be specified as simple dot-separated strings.
 * @template T
 */
var /*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * Generic accessor for deep object properties
 * that can be specified as simple dot-separated strings.
 * @template T
 */
NestedProperty = /** @class */ (function () {
    function NestedProperty(prop) {
        this.prop = prop;
        if (prop.indexOf('.') >= 0) {
            this.splitProp = prop.split('.');
        }
    }
    // Safe getter for a deep object property, will not throw an error but return
    // undefined if one of the intermediate properties is null or undefined.
    // Safe getter for a deep object property, will not throw an error but return
    // undefined if one of the intermediate properties is null or undefined.
    /**
     * @param {?} item
     * @return {?}
     */
    NestedProperty.prototype.getPropValue = 
    // Safe getter for a deep object property, will not throw an error but return
    // undefined if one of the intermediate properties is null or undefined.
    /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var e_1, _a;
        if (this.splitProp) {
            /** @type {?} */
            var value = item;
            try {
                for (var _b = __values(this.splitProp), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var nestedProp = _c.value;
                    if (value == null || typeof value === 'undefined' || typeof value[nestedProp] === 'undefined') {
                        return undefined;
                    }
                    value = value[nestedProp];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return value;
        }
        else {
            return item[this.prop];
        }
    };
    return NestedProperty;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
DatagridPropertyStringFilter = /** @class */ (function () {
    function DatagridPropertyStringFilter(prop, exact) {
        if (exact === void 0) { exact = false; }
        this.prop = prop;
        this.exact = exact;
        this.nestedProp = new NestedProperty(prop);
    }
    /**
     * @param {?} item
     * @param {?} search
     * @return {?}
     */
    DatagridPropertyStringFilter.prototype.accepts = /**
     * @param {?} item
     * @param {?} search
     * @return {?}
     */
    function (item, search) {
        /** @type {?} */
        var propValue = this.nestedProp.getPropValue(item);
        if (typeof propValue === 'undefined') {
            return false;
        }
        else if (this.exact) {
            return ('' + propValue).toLowerCase() === search;
        }
        else {
            return ('' + propValue).toLowerCase().indexOf(search) >= 0;
        }
    };
    return DatagridPropertyStringFilter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var /**
 * @template T
 */
DatagridStringFilterImpl = /** @class */ (function () {
    function DatagridStringFilterImpl(filterFn) {
        this.filterFn = filterFn;
        /**
         * The Observable required as part of the Filter interface
         */
        this._changes = new Subject();
        /**
         * Raw input value
         */
        this._rawValue = '';
        /**
         * Input value converted to lowercase
         */
        this._lowerCaseValue = '';
    }
    Object.defineProperty(DatagridStringFilterImpl.prototype, "changes", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: 
        // We do not want to expose the Subject itself, but the Observable which is read-only
        /**
         * @return {?}
         */
        function () {
            return this._changes.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridStringFilterImpl.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rawValue;
        },
        /**
         * Common setter for the input value
         */
        set: /**
         * Common setter for the input value
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                value = '';
            }
            if (value !== this._rawValue) {
                this._rawValue = value;
                this._lowerCaseValue = value.toLowerCase().trim();
                this._changes.next(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridStringFilterImpl.prototype, "lowerCaseValue", {
        get: /**
         * @return {?}
         */
        function () {
            return this._lowerCaseValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates if the filter is currently active, meaning the input is not empty
     */
    /**
     * Indicates if the filter is currently active, meaning the input is not empty
     * @return {?}
     */
    DatagridStringFilterImpl.prototype.isActive = /**
     * Indicates if the filter is currently active, meaning the input is not empty
     * @return {?}
     */
    function () {
        return !!this.value;
    };
    /**
     * Tests if an item matches a search text
     */
    /**
     * Tests if an item matches a search text
     * @param {?} item
     * @return {?}
     */
    DatagridStringFilterImpl.prototype.accepts = /**
     * Tests if an item matches a search text
     * @param {?} item
     * @return {?}
     */
    function (item) {
        // We always test with the lowercase value of the input, to stay case insensitive
        return this.filterFn.accepts(item, this.lowerCaseValue);
    };
    Object.defineProperty(DatagridStringFilterImpl.prototype, "state", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.filterFn instanceof DatagridPropertyStringFilter) {
                return {
                    property: this.filterFn.prop,
                    value: this.value,
                };
            }
            return this;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} other
     * @return {?}
     */
    DatagridStringFilterImpl.prototype.equals = /**
     * @param {?} other
     * @return {?}
     */
    function (other) {
        if (other instanceof DatagridStringFilterImpl) {
            if (other.filterFn instanceof DatagridPropertyStringFilter) {
                return (this.filterFn instanceof DatagridPropertyStringFilter &&
                    other.filterFn.prop === this.filterFn.prop &&
                    other.value === this.value);
            }
            return other === this;
        }
        return false;
    };
    return DatagridStringFilterImpl;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var DatagridStringFilter = /** @class */ (function (_super) {
    __extends(DatagridStringFilter, _super);
    function DatagridStringFilter(filters, domAdapter) {
        var _this = _super.call(this, filters) || this;
        _this.domAdapter = domAdapter;
        /**
         * Indicates if the filter dropdown is open
         */
        _this.open = false;
        _this.filterValueChange = new EventEmitter();
        return _this;
    }
    Object.defineProperty(DatagridStringFilter.prototype, "customStringFilter", {
        /**
         * Customizable filter logic based on a search text
         */
        set: /**
         * Customizable filter logic based on a search text
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value instanceof RegisteredFilter) {
                this.setFilter(value);
            }
            else {
                this.setFilter(new DatagridStringFilterImpl(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DatagridStringFilter.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.filterContainer.openChanged.subscribe(function (open) {
            if (open) {
                // We need the timeout because at the time this executes, the input isn't
                // displayed yet.
                setTimeout(function () {
                    _this.domAdapter.focus(_this.input.nativeElement);
                });
            }
        });
    };
    Object.defineProperty(DatagridStringFilter.prototype, "value", {
        /**
         * Common setter for the input value
         */
        get: /**
         * Common setter for the input value
         * @return {?}
         */
        function () {
            return this.filter.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!this.filter) {
                return;
            }
            if (!value) {
                value = '';
            }
            if (value !== this.filter.value) {
                this.filter.value = value;
                this.filterValueChange.emit(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DatagridStringFilter.prototype.close = /**
     * @return {?}
     */
    function () {
        this.open = false;
    };
    DatagridStringFilter.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-string-filter',
                    providers: [{ provide: CustomFilter, useExisting: DatagridStringFilter }],
                    template: "\n        <clr-dg-filter [clrDgFilter]=\"registered\" [(clrDgFilterOpen)]=\"open\">\n            <!--\n                Even though this *ngIf looks useless because the filter container already has one,\n                it prevents NgControlStatus and other directives automatically added by Angular\n                on inputs with NgModel from freaking out because of their host binding changing\n                mid-change detection when the input is destroyed.\n            -->\n            <input #input type=\"text\" name=\"search\" [(ngModel)]=\"value\" *ngIf=\"open\"\n                (keyup.enter)=\"close()\" (keyup.escape)=\"close()\"/>\n        </clr-dg-filter>\n    "
                }] }
    ];
    /** @nocollapse */
    DatagridStringFilter.ctorParameters = function () { return [
        { type: FiltersProvider },
        { type: DomAdapter }
    ]; };
    DatagridStringFilter.propDecorators = {
        customStringFilter: [{ type: Input, args: ['clrDgStringFilter',] }],
        input: [{ type: ViewChild, args: ['input',] }],
        filterContainer: [{ type: ViewChild, args: [ClrDatagridFilter,] }],
        value: [{ type: Input, args: ['clrFilterValue',] }],
        filterValueChange: [{ type: Output, args: ['clrFilterValueChange',] }]
    };
    return DatagridStringFilter;
}(DatagridFilterRegistrar));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
OompaLoompa = /** @class */ (function () {
    // FIXME: Request Injector once we move to Angular 4.2+, it'll allow easier refactors
    function OompaLoompa(cdr, willyWonka) {
        var _this = this;
        this.subscription = willyWonka.chocolate.subscribe(function () {
            if (_this.latestFlavor !== _this.flavor) {
                cdr.detectChanges();
            }
        });
    }
    /**
     * @return {?}
     */
    OompaLoompa.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        this.latestFlavor = this.flavor;
    };
    /**
     * @return {?}
     */
    OompaLoompa.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    return OompaLoompa;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RowActionService = /** @class */ (function () {
    function RowActionService() {
        this.actionableCount = 0;
    }
    /**
     * @return {?}
     */
    RowActionService.prototype.register = /**
     * @return {?}
     */
    function () {
        this.actionableCount++;
    };
    /**
     * @return {?}
     */
    RowActionService.prototype.unregister = /**
     * @return {?}
     */
    function () {
        this.actionableCount--;
    };
    Object.defineProperty(RowActionService.prototype, "hasActionableRow", {
        /**
         * false means no rows with action
         */
        get: /**
         * false means no rows with action
         * @return {?}
         */
        function () {
            return this.actionableCount > 0;
        },
        enumerable: true,
        configurable: true
    });
    RowActionService.decorators = [
        { type: Injectable }
    ];
    return RowActionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
 * declarative API, we need to fight against change detection and its one-way flow. This is
 * currently the least dirty solution to do what we want.
 *
 * Do not modify or even use this class unless you know exactly what you're doing.
 * It has the potential to trigger change detection loops or kill app performances.
 */
var  /*
 * After a conversation with the Angular core team, it turns out we don't have much of a choice for our
 * declarative API, we need to fight against change detection and its one-way flow. This is
 * currently the least dirty solution to do what we want.
 *
 * Do not modify or even use this class unless you know exactly what you're doing.
 * It has the potential to trigger change detection loops or kill app performances.
 */
WillyWonka = /** @class */ (function () {
    function WillyWonka() {
        this._chocolate = new Subject();
    }
    Object.defineProperty(WillyWonka.prototype, "chocolate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._chocolate.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WillyWonka.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        this._chocolate.next();
    };
    return WillyWonka;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DatagridWillyWonka = /** @class */ (function (_super) {
    __extends(DatagridWillyWonka, _super);
    function DatagridWillyWonka() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DatagridWillyWonka.decorators = [
        { type: Directive, args: [{ selector: 'clr-datagrid' },] }
    ];
    return DatagridWillyWonka;
}(WillyWonka));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ActionableOompaLoompa = /** @class */ (function (_super) {
    __extends(ActionableOompaLoompa, _super);
    function ActionableOompaLoompa(cdr, willyWonka, rowActions) {
        var _this = this;
        if (!willyWonka) {
            throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
        }
        _this = _super.call(this, cdr, willyWonka) || this;
        _this.rowActions = rowActions;
        return _this;
    }
    Object.defineProperty(ActionableOompaLoompa.prototype, "flavor", {
        get: /**
         * @return {?}
         */
        function () {
            return this.rowActions.hasActionableRow;
        },
        enumerable: true,
        configurable: true
    });
    ActionableOompaLoompa.decorators = [
        { type: Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
    ];
    /** @nocollapse */
    ActionableOompaLoompa.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: DatagridWillyWonka, decorators: [{ type: Optional }] },
        { type: RowActionService }
    ]; };
    return ActionableOompaLoompa;
}(OompaLoompa));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ExpandableRowsCount = /** @class */ (function () {
    function ExpandableRowsCount() {
        this.expandableCount = 0;
    }
    /**
     * @return {?}
     */
    ExpandableRowsCount.prototype.register = /**
     * @return {?}
     */
    function () {
        this.expandableCount++;
    };
    /**
     * @return {?}
     */
    ExpandableRowsCount.prototype.unregister = /**
     * @return {?}
     */
    function () {
        this.expandableCount--;
    };
    Object.defineProperty(ExpandableRowsCount.prototype, "hasExpandableRow", {
        /**
         * false means no rows with action
         */
        get: /**
         * false means no rows with action
         * @return {?}
         */
        function () {
            return this.expandableCount > 0;
        },
        enumerable: true,
        configurable: true
    });
    ExpandableRowsCount.decorators = [
        { type: Injectable }
    ];
    return ExpandableRowsCount;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ExpandableOompaLoompa = /** @class */ (function (_super) {
    __extends(ExpandableOompaLoompa, _super);
    function ExpandableOompaLoompa(cdr, willyWonka, expandableCount) {
        var _this = this;
        if (!willyWonka) {
            throw new Error('clr-dg-row should only be used inside of a clr-datagrid');
        }
        _this = _super.call(this, cdr, willyWonka) || this;
        _this.expandableCount = expandableCount;
        return _this;
    }
    Object.defineProperty(ExpandableOompaLoompa.prototype, "flavor", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expandableCount.hasExpandableRow;
        },
        enumerable: true,
        configurable: true
    });
    ExpandableOompaLoompa.decorators = [
        { type: Directive, args: [{ selector: 'clr-datagrid, clr-dg-row' },] }
    ];
    /** @nocollapse */
    ExpandableOompaLoompa.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: DatagridWillyWonka, decorators: [{ type: Optional }] },
        { type: ExpandableRowsCount }
    ]; };
    return ExpandableOompaLoompa;
}(OompaLoompa));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var  /**
 * @template T
 */
DatagridPropertyComparator = /** @class */ (function () {
    function DatagridPropertyComparator(prop) {
        this.prop = prop;
        this.nestedProp = new NestedProperty(prop);
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    DatagridPropertyComparator.prototype.compare = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        /** @type {?} */
        var propA = this.nestedProp.getPropValue(a);
        /** @type {?} */
        var propB = this.nestedProp.getPropValue(b);
        if (typeof propA === 'string') {
            propA = propA.toLowerCase();
        }
        if (typeof propB === 'string') {
            propB = propB.toLowerCase();
        }
        if (typeof propA === 'undefined' || propA === null) {
            if (typeof propB === 'undefined' || propB === null) {
                return 0;
            }
            else {
                return 1;
            }
        }
        else {
            if (typeof propB === 'undefined' || propB === null) {
                return -1;
            }
            else if (propA < propB) {
                return -1;
            }
            else if (propA > propB) {
                return 1;
            }
            else {
                return 0;
            }
        }
    };
    return DatagridPropertyComparator;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
var ClrDatagridSortOrder = {
    UNSORTED: 0,
    ASC: 1,
    DESC: -1,
};
ClrDatagridSortOrder[ClrDatagridSortOrder.UNSORTED] = 'UNSORTED';
ClrDatagridSortOrder[ClrDatagridSortOrder.ASC] = 'ASC';
ClrDatagridSortOrder[ClrDatagridSortOrder.DESC] = 'DESC';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var Sort = /** @class */ (function () {
    function Sort(stateDebouncer) {
        this.stateDebouncer = stateDebouncer;
        /**
         * Ascending order if false, descending if true
         */
        this._reverse = false;
        /**
         * The Observable that lets other classes subscribe to sort changes
         */
        this._change = new Subject();
    }
    Object.defineProperty(Sort.prototype, "comparator", {
        get: /**
         * @return {?}
         */
        function () {
            return this._comparator;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.stateDebouncer.changeStart();
            this._comparator = value;
            this.emitChange();
            this.stateDebouncer.changeDone();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sort.prototype, "reverse", {
        get: /**
         * @return {?}
         */
        function () {
            return this._reverse;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.stateDebouncer.changeStart();
            this._reverse = value;
            this.emitChange();
            this.stateDebouncer.changeDone();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    Sort.prototype.emitChange = /**
     * @return {?}
     */
    function () {
        this._change.next(this);
    };
    Object.defineProperty(Sort.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: 
        // We do not want to expose the Subject itself, but the Observable which is read-only
        /**
         * @return {?}
         */
        function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
     * optional forceReverse input parameter allows to override that toggling behavior by sorting in
     * reverse order if `true`.
     *
     * @memberof Sort
     */
    /**
     * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
     * optional forceReverse input parameter allows to override that toggling behavior by sorting in
     * reverse order if `true`.
     *
     * \@memberof Sort
     * @param {?} sortBy
     * @param {?=} forceReverse
     * @return {?}
     */
    Sort.prototype.toggle = /**
     * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
     * optional forceReverse input parameter allows to override that toggling behavior by sorting in
     * reverse order if `true`.
     *
     * \@memberof Sort
     * @param {?} sortBy
     * @param {?=} forceReverse
     * @return {?}
     */
    function (sortBy, forceReverse) {
        this.stateDebouncer.changeStart();
        // We modify private properties directly, to batch the change event
        if (this.comparator === sortBy) {
            this._reverse = typeof forceReverse !== 'undefined' ? forceReverse || !this._reverse : !this._reverse;
        }
        else {
            this._comparator = sortBy;
            this._reverse = typeof forceReverse !== 'undefined' ? forceReverse : false;
        }
        this.emitChange();
        this.stateDebouncer.changeDone();
    };
    /**
     * Clears the current sorting order
     */
    /**
     * Clears the current sorting order
     * @return {?}
     */
    Sort.prototype.clear = /**
     * Clears the current sorting order
     * @return {?}
     */
    function () {
        this.comparator = null;
    };
    /**
     * Compares two objects according to the current comparator
     */
    /**
     * Compares two objects according to the current comparator
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    Sort.prototype.compare = /**
     * Compares two objects according to the current comparator
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        return (this.reverse ? -1 : 1) * this.comparator.compare(a, b);
    };
    Sort.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Sort.ctorParameters = function () { return [
        { type: StateDebouncer }
    ]; };
    return Sort;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var WrappedColumn = /** @class */ (function () {
    function WrappedColumn() {
        this._dynamic = false;
    }
    // the columns projected view (in memory)
    /**
     * @return {?}
     */
    WrappedColumn.prototype.ngAfterViewInit = 
    // the columns projected view (in memory)
    /**
     * @return {?}
     */
    function () {
        // Create the cells view in memory, not the DOM.
        this.columnView = this.templateRef.createEmbeddedView(null);
    };
    WrappedColumn.decorators = [
        { type: Component, args: [{
                    selector: 'dg-wrapped-column',
                    template: "        \n        <ng-template #columnPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                }] }
    ];
    WrappedColumn.propDecorators = {
        templateRef: [{ type: ViewChild, args: ['columnPortal',] }]
    };
    return WrappedColumn;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var nbCount = 0;
/**
 * @template T
 */
var ClrDatagridColumn = /** @class */ (function (_super) {
    __extends(ClrDatagridColumn, _super);
    function ClrDatagridColumn(_sort, filters, vcr) {
        var _this = _super.call(this, filters) || this;
        _this._sort = _sort;
        _this.vcr = vcr;
        // deprecated: to be removed - START
        /**
         * Indicates if the column is currently sorted
         *
         * @deprecated This will be removed soon, in favor of the sortOrder mechanism
         */
        _this._sorted = false;
        /**
         * @deprecated This will be removed soon, in favor of the sortOrder mechanism
         */
        _this.sortedChange = new EventEmitter();
        // deprecated: to be removed - END
        /**
         * Indicates how the column is currently sorted
         */
        _this._sortOrder = ClrDatagridSortOrder.UNSORTED;
        _this.sortOrderChange = new EventEmitter();
        /**
         * A custom filter for this column that can be provided in the projected content
         */
        _this.customFilter = false;
        _this.filterValueChange = new EventEmitter();
        _this._sortSubscription = _sort.change.subscribe(function (sort) {
            // We're only listening to make sure we emit an event when the column goes from sorted to unsorted
            if (_this.sortOrder !== ClrDatagridSortOrder.UNSORTED && sort.comparator !== _this._sortBy) {
                _this._sortOrder = ClrDatagridSortOrder.UNSORTED;
                _this.sortOrderChange.emit(_this._sortOrder);
                // removes the sortIcon when column becomes unsorted
                _this.sortIcon = null;
            }
            // deprecated: to be removed - START
            if (_this.sorted && sort.comparator !== _this._sortBy) {
                _this._sorted = false;
                _this.sortedChange.emit(false);
            }
            // deprecated: to be removed - END
        });
        _this.columnId = 'dg-col-' + nbCount.toString(); // Approximate a GUID
        nbCount++;
        return _this;
    }
    Object.defineProperty(ClrDatagridColumn.prototype, "hidden", {
        /**
         * @property hidden
         *
         * @description
         * A property that allows the column to be hidden / shown with css
         * Note the default allows the ClrDatagridColumn to have an *ngIf on it. (EHCAIWC - will occur if its not
         * initialized)
         *
         * @default false
         *
         */
        get: /**
         * \@property hidden
         *
         * \@description
         * A property that allows the column to be hidden / shown with css
         * Note the default allows the ClrDatagridColumn to have an *ngIf on it. (EHCAIWC - will occur if its not
         * initialized)
         *
         * \@default false
         *
         * @return {?}
         */
        function () {
            return !!this.hideable && this.hideable.hidden;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDatagridColumn.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._sortSubscription.unsubscribe();
    };
    Object.defineProperty(ClrDatagridColumn.prototype, "field", {
        get: /**
         * @return {?}
         */
        function () {
            return this._field;
        },
        set: /**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            if (typeof field === 'string') {
                this._field = field;
                if (!this.customFilter) {
                    this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
                }
                if (!this._sortBy) {
                    this._sortBy = new DatagridPropertyComparator(field);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridColumn.prototype, "sortBy", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sortBy;
        },
        set: /**
         * @param {?} comparator
         * @return {?}
         */
        function (comparator) {
            if (typeof comparator === 'string') {
                this._sortBy = new DatagridPropertyComparator(comparator);
            }
            else {
                if (comparator) {
                    this._sortBy = comparator;
                }
                else {
                    if (this._field) {
                        this._sortBy = new DatagridPropertyComparator(this._field);
                    }
                    else {
                        delete this._sortBy;
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridColumn.prototype, "sortable", {
        /**
         * Indicates if the column is sortable
         */
        get: /**
         * Indicates if the column is sortable
         * @return {?}
         */
        function () {
            return !!this._sortBy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridColumn.prototype, "sorted", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sorted;
        },
        /**
         * @deprecated This will be removed soon, in favor of the sortOrder mechanism
         */
        set: /**
         * @deprecated This will be removed soon, in favor of the sortOrder mechanism
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value && this.sorted) {
                this._sorted = false;
                this._sort.clear();
            }
            else if (value && !this.sorted) {
                this.sort();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridColumn.prototype, "sortOrder", {
        get: /**
         * @return {?}
         */
        function () {
            return this._sortOrder;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'undefined') {
                return;
            }
            // only if the incoming order is different from the current one
            if (this._sortOrder === value) {
                return;
            }
            switch (value) {
                // the Unsorted case happens when the current state is either Asc or Desc
                default:
                case ClrDatagridSortOrder.UNSORTED:
                    this._sort.clear();
                    break;
                case ClrDatagridSortOrder.ASC:
                    this.sort(false);
                    break;
                case ClrDatagridSortOrder.DESC:
                    this.sort(true);
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridColumn.prototype, "ariaSort", {
        get: /**
         * @return {?}
         */
        function () {
            switch (this._sortOrder) {
                default:
                case ClrDatagridSortOrder.UNSORTED:
                    return 'none';
                case ClrDatagridSortOrder.ASC:
                    return 'ascending';
                case ClrDatagridSortOrder.DESC:
                    return 'descending';
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sorts the datagrid based on this column
     */
    /**
     * Sorts the datagrid based on this column
     * @param {?=} reverse
     * @return {?}
     */
    ClrDatagridColumn.prototype.sort = /**
     * Sorts the datagrid based on this column
     * @param {?=} reverse
     * @return {?}
     */
    function (reverse) {
        if (!this.sortable) {
            return;
        }
        this._sort.toggle(this._sortBy, reverse);
        // setting the private variable to not retrigger the setter logic
        this._sortOrder = this._sort.reverse ? ClrDatagridSortOrder.DESC : ClrDatagridSortOrder.ASC;
        // Sets the correct icon for current sort order
        this.sortIcon = this._sortOrder === ClrDatagridSortOrder.DESC ? 'arrow down' : 'arrow';
        this.sortOrderChange.emit(this._sortOrder);
        // deprecated: to be removed - START
        this._sorted = true;
        this.sortedChange.emit(true);
        // deprecated: to be removed - END
    };
    Object.defineProperty(ClrDatagridColumn.prototype, "projectedFilter", {
        set: /**
         * @param {?} custom
         * @return {?}
         */
        function (custom) {
            if (custom) {
                this.deleteFilter();
                this.customFilter = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridColumn.prototype, "filterValue", {
        get: /**
         * @return {?}
         */
        function () {
            return this.filter.value;
        },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            this.updateFilterValue = newValue;
            this.filterValueChange.emit(this.filter.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridColumn.prototype, "updateFilterValue", {
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (!this.filter) {
                return;
            }
            if (!newValue) {
                newValue = '';
            }
            if (newValue !== this.filter.value) {
                this.filter.value = newValue;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDatagridColumn.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.wrappedInjector = new HostWrapper(WrappedColumn, this.vcr);
    };
    Object.defineProperty(ClrDatagridColumn.prototype, "_view", {
        get: /**
         * @return {?}
         */
        function () {
            return this.wrappedInjector.get(WrappedColumn, this.vcr).columnView;
        },
        enumerable: true,
        configurable: true
    });
    ClrDatagridColumn.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-column',
                    template: "\n      <div class=\"datagrid-column-flex\">\n          <!-- I'm really not happy with that select since it's not very scalable -->\n          <ng-content select=\"clr-dg-filter, clr-dg-string-filter\"></ng-content>\n\n          <clr-dg-string-filter\n                  *ngIf=\"field && !customFilter\"\n                  [clrDgStringFilter]=\"registered\"\n                  [(clrFilterValue)]=\"filterValue\"></clr-dg-string-filter>\n\n          <ng-template #columnTitle>\n              <ng-content></ng-content>\n          </ng-template>\n\n          <button class=\"datagrid-column-title\" *ngIf=\"sortable\" (click)=\"sort()\" type=\"button\">\n              <ng-container *ngTemplateOutlet=\"columnTitle\"></ng-container>\n              <clr-icon\n                      *ngIf=\"sortIcon\"\n                      [attr.shape]=\"sortIcon\"\n                      class=\"sort-icon\"></clr-icon>\n          </button>\n\n          <span class=\"datagrid-column-title\" *ngIf=\"!sortable\">\n               <ng-container *ngTemplateOutlet=\"columnTitle\"></ng-container>\n            </span>\n\n          <clr-dg-column-separator></clr-dg-column-separator>\n      </div>\n  ",
                    host: {
                        '[class.datagrid-column]': 'true',
                        '[class.datagrid-column--hidden]': 'hidden',
                        '[attr.aria-sort]': 'ariaSort',
                        role: 'columnheader',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrDatagridColumn.ctorParameters = function () { return [
        { type: Sort },
        { type: FiltersProvider },
        { type: ViewContainerRef }
    ]; };
    ClrDatagridColumn.propDecorators = {
        field: [{ type: Input, args: ['clrDgField',] }],
        sortBy: [{ type: Input, args: ['clrDgSortBy',] }],
        sorted: [{ type: Input, args: ['clrDgSorted',] }],
        sortedChange: [{ type: Output, args: ['clrDgSortedChange',] }],
        sortOrder: [{ type: Input, args: ['clrDgSortOrder',] }],
        sortOrderChange: [{ type: Output, args: ['clrDgSortOrderChange',] }],
        projectedFilter: [{ type: ContentChild, args: [CustomFilter,] }],
        updateFilterValue: [{ type: Input, args: ['clrFilterValue',] }],
        filterValueChange: [{ type: Output, args: ['clrFilterValueChange',] }]
    };
    return ClrDatagridColumn;
}(DatagridFilterRegistrar));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var Items = /** @class */ (function () {
    function Items(_filters, _sort, _page) {
        this._filters = _filters;
        this._sort = _sort;
        this._page = _page;
        /**
         * Indicates if the data is currently loading
         */
        this.loading = false;
        // TODO: Verify that trackBy is registered for the *ngFor case too
        /**
         * Tracking function to identify objects. Default is reference equality.
         */
        this.trackBy = function (index, item) { return item; };
        /**
         * Whether we should use smart items for this datagrid or let the user handle
         * everything.
         */
        this._smart = false;
        /**
         * List of items currently displayed
         */
        this._displayed = [];
        /**
         * The Observable that lets other classes subscribe to items changes
         */
        this._change = new Subject();
        this._allChanges = new Subject();
    }
    /**
     * Cleans up our subscriptions to other providers
     */
    /**
     * Cleans up our subscriptions to other providers
     * @return {?}
     */
    Items.prototype.destroy = /**
     * Cleans up our subscriptions to other providers
     * @return {?}
     */
    function () {
        if (this._filtersSub) {
            this._filtersSub.unsubscribe();
        }
        if (this._sortSub) {
            this._sortSub.unsubscribe();
        }
        if (this._pageSub) {
            this._pageSub.unsubscribe();
        }
    };
    Object.defineProperty(Items.prototype, "smart", {
        get: /**
         * @return {?}
         */
        function () {
            return this._smart;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    Items.prototype.smartenUp = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._smart = true;
        /*
             * These observers trigger a chain of function: filter -> sort -> paginate
             * An observer up the chain re-triggers all the operations that follow it.
             */
        this._filtersSub = this._filters.change.subscribe(function () { return _this._filterItems(); });
        this._sortSub = this._sort.change.subscribe(function () {
            // Special case, if the datagrid went from sorted to unsorted, we have to re-filter
            // to get the original order back
            if (!_this._sort.comparator) {
                _this._filterItems();
            }
            else {
                _this._sortItems();
            }
        });
        this._pageSub = this._page.change.subscribe(function () { return _this._changePage(); });
    };
    Object.defineProperty(Items.prototype, "all", {
        get: /**
         * @return {?}
         */
        function () {
            return this._all;
        },
        set: /**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            this._all = items;
            this.emitAllChanges(items);
            if (this.smart) {
                this._filterItems();
            }
            else {
                this._displayed = items;
                this.emitChange();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Manually recompute the list of displayed items
     */
    /**
     * Manually recompute the list of displayed items
     * @return {?}
     */
    Items.prototype.refresh = /**
     * Manually recompute the list of displayed items
     * @return {?}
     */
    function () {
        if (this.smart) {
            this._filterItems();
        }
    };
    Object.defineProperty(Items.prototype, "displayed", {
        get: /**
         * @return {?}
         */
        function () {
            // Ideally we could return an immutable array, but we don't have it in Clarity yet.
            return this._displayed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    Items.prototype.emitChange = /**
     * @return {?}
     */
    function () {
        this._change.next(this.displayed);
    };
    Object.defineProperty(Items.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: 
        // We do not want to expose the Subject itself, but the Observable which is read-only
        /**
         * @return {?}
         */
        function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} items
     * @return {?}
     */
    Items.prototype.emitAllChanges = /**
     * @param {?} items
     * @return {?}
     */
    function (items) {
        this._allChanges.next(items);
    };
    Object.defineProperty(Items.prototype, "allChanges", {
        get: /**
         * @return {?}
         */
        function () {
            return this._allChanges.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Items.prototype, "uninitialized", {
        /**
         * Checks if we don't have data to process yet, to abort early operations
         */
        get: /**
         * Checks if we don't have data to process yet, to abort early operations
         * @return {?}
         */
        function () {
            return !this._all;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * FiltersProvider items from the raw list
     */
    /**
     * FiltersProvider items from the raw list
     * @return {?}
     */
    Items.prototype._filterItems = /**
     * FiltersProvider items from the raw list
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.uninitialized) {
            return;
        }
        if (this._filters.hasActiveFilters()) {
            this._filtered = this._all.filter(function (item) { return _this._filters.accepts(item); });
        }
        else {
            // Work on a shallow copy of the array, to not modify the user's model
            this._filtered = this._all.slice();
        }
        this._page.totalItems = this._filtered.length;
        this._sortItems();
    };
    /**
     * Sorts items in the filtered list
     */
    /**
     * Sorts items in the filtered list
     * @return {?}
     */
    Items.prototype._sortItems = /**
     * Sorts items in the filtered list
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.uninitialized) {
            return;
        }
        if (this._sort.comparator) {
            this._filtered.sort(function (a, b) { return _this._sort.compare(a, b); });
        }
        this._changePage();
    };
    /**
     * Extracts the current page from the sorted list
     */
    /**
     * Extracts the current page from the sorted list
     * @return {?}
     */
    Items.prototype._changePage = /**
     * Extracts the current page from the sorted list
     * @return {?}
     */
    function () {
        // If we know we have pagination but the page size hasn't been set yet, we wait for it.
        if (this.uninitialized || (this._page.activated && this._page.size === 0)) {
            return;
        }
        if (this._page.size > 0) {
            this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
        }
        else {
            this._displayed = this._filtered;
        }
        this.emitChange();
    };
    Items.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Items.ctorParameters = function () { return [
        { type: FiltersProvider },
        { type: Sort },
        { type: Page }
    ]; };
    return Items;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDatagridItems = /** @class */ (function () {
    function ClrDatagridItems(template, differs, items, vcr) {
        var _this = this;
        this.template = template;
        this.differs = differs;
        this.items = items;
        this.vcr = vcr;
        this.differ = null;
        this.subscriptions = [];
        items.smartenUp();
        this.iterableProxy = new NgForOf(this.vcr, this.template, this.differs);
        this.subscriptions.push(items.change.subscribe(function (newItems) {
            _this.iterableProxy.ngForOf = newItems;
            _this.iterableProxy.ngDoCheck();
        }));
    }
    Object.defineProperty(ClrDatagridItems.prototype, "rawItems", {
        set: /**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            this._rawItems = items ? items : []; // local copy for ngOnChange diffing
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridItems.prototype, "trackBy", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.iterableProxy.ngForTrackBy = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDatagridItems.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (!this.differ) {
            this.differ = this.differs.find(this._rawItems).create(this.iterableProxy.ngForTrackBy);
        }
        if (this.differ) {
            /** @type {?} */
            var changes = this.differ.diff(this._rawItems);
            if (changes) {
                // TODO: not very efficient right now,
                // but premature optimization is the root of all evil.
                this.items.all = this._rawItems;
            }
        }
    };
    /**
     * @return {?}
     */
    ClrDatagridItems.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrDatagridItems.decorators = [
        { type: Directive, args: [{
                    selector: '[clrDgItems][clrDgItemsOf]',
                },] }
    ];
    /** @nocollapse */
    ClrDatagridItems.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: Items },
        { type: ViewContainerRef }
    ]; };
    ClrDatagridItems.propDecorators = {
        rawItems: [{ type: Input, args: ['clrDgItemsOf',] }],
        trackBy: [{ type: Input, args: ['clrDgItemsTrackBy',] }]
    };
    return ClrDatagridItems;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDatagridPlaceholder = /** @class */ (function () {
    function ClrDatagridPlaceholder(items) {
        this.items = items;
    }
    Object.defineProperty(ClrDatagridPlaceholder.prototype, "emptyDatagrid", {
        /**
         * Tests if the datagrid is empty, meaning it doesn't contain any items
         */
        get: /**
         * Tests if the datagrid is empty, meaning it doesn't contain any items
         * @return {?}
         */
        function () {
            return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
        },
        enumerable: true,
        configurable: true
    });
    ClrDatagridPlaceholder.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-placeholder',
                    template: "\n        <div\n            class=\"datagrid-placeholder\"\n            [class.datagrid-empty]=\"emptyDatagrid\">\n                <div class=\"datagrid-placeholder-image\" *ngIf=\"emptyDatagrid\"></div>\n                <ng-content *ngIf=\"emptyDatagrid\"></ng-content>\n        </div>\n    ",
                    host: { '[class.datagrid-placeholder-container]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrDatagridPlaceholder.ctorParameters = function () { return [
        { type: Items }
    ]; };
    return ClrDatagridPlaceholder;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var POPOVER_HOST_ANCHOR = new InjectionToken('POPOVER_HOST_ANCHOR');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrSignpostTrigger = /** @class */ (function () {
    function ClrSignpostTrigger(ifOpenService, renderer, el) {
        var _this = this;
        this.ifOpenService = ifOpenService;
        this.renderer = renderer;
        this.el = el;
        this.subscriptions = [];
        this.subscriptions.push(this.ifOpenService.openChange.subscribe(function (isOpen) {
            if (isOpen) {
                _this.renderer.addClass(_this.el.nativeElement, 'active');
            }
            else {
                _this.renderer.removeClass(_this.el.nativeElement, 'active');
            }
        }));
    }
    /**
     * @return {?}
     */
    ClrSignpostTrigger.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**********
     *
     * @description
     * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
     */
    /**
     * *******
     *
     * \@description
     * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
     * @param {?} event
     * @return {?}
     */
    ClrSignpostTrigger.prototype.onSignpostTriggerClick = /**
     * *******
     *
     * \@description
     * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.ifOpenService.toggleWithEvent(event);
    };
    ClrSignpostTrigger.decorators = [
        { type: Directive, args: [{ selector: '[clrSignpostTrigger]', host: { class: 'signpost-trigger' } },] }
    ];
    /** @nocollapse */
    ClrSignpostTrigger.ctorParameters = function () { return [
        { type: IfOpenService },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    ClrSignpostTrigger.propDecorators = {
        onSignpostTriggerClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return ClrSignpostTrigger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrSignpost = /** @class */ (function () {
    function ClrSignpost(commonStrings) {
        this.commonStrings = commonStrings;
        /**
         * *******
         * \@property useCustomTrigger
         *
         * \@description
         * Flag used to determine if we need to use the default trigger or a user supplied trigger element.
         *
         */
        this.useCustomTrigger = false;
    }
    Object.defineProperty(ClrSignpost.prototype, "customTrigger", {
        /**********
         * @property signPostTrigger
         *
         * @description
         * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
         *
         */
        set: /**
         * *******
         * \@property signPostTrigger
         *
         * \@description
         * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
         *
         * @param {?} trigger
         * @return {?}
         */
        function (trigger$$1) {
            this.useCustomTrigger = !!trigger$$1;
        },
        enumerable: true,
        configurable: true
    });
    ClrSignpost.decorators = [
        { type: Component, args: [{
                    selector: 'clr-signpost',
                    template: "\n        <ng-container *ngIf=\"!useCustomTrigger\">\n            <button\n                type=\"button\"\n                class=\"signpost-action btn btn-small btn-link\"\n                clrSignpostTrigger>\n                <clr-icon shape=\"info\" [attr.title]=\"commonStrings.info\"></clr-icon>\n            </button>\n        </ng-container>\n        \n        <ng-content></ng-content>\n    ",
                    host: { '[class.signpost]': 'true' },
                    providers: [IfOpenService, { provide: POPOVER_HOST_ANCHOR, useExisting: ElementRef }]
                }] }
    ];
    /** @nocollapse */
    ClrSignpost.ctorParameters = function () { return [
        { type: ClrCommonStrings }
    ]; };
    ClrSignpost.propDecorators = {
        customTrigger: [{ type: ContentChild, args: [ClrSignpostTrigger,] }]
    };
    return ClrSignpost;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 * An \@Injectable provider class that enables
 *
 * 1. Managing, track hideability of DatagridColumns
 *
 */
var HideableColumnService = /** @class */ (function () {
    function HideableColumnService() {
        /**
         * *******
         * \@property dgHiddenColumnMap
         *
         * \@description
         * An array of DatagridHideableColumn.
         * NOTE: because we can have columns w/o the *clrDgHideableColumn directive
         * this array will have empty spaces a.k.a nulls. This is needed to be able to map
         * DatagridCells to DatagridColumns in the RowRenderer.
         *
         */
        this._columnList = [];
        /**
         * *******
         *
         * \@property dgHiddenColumnMapChange
         *
         * \@description
         * A behavior subject that can broadcast updates to the column list.
         * NOTE: I am using BehaviorSubject because <clr-dg-column-toggle> is not getting the latest _columnListChange
         * on page load.
         *
         */
        this._columnListChange = new BehaviorSubject(this._columnList);
    }
    Object.defineProperty(HideableColumnService.prototype, "canHideNextColumn", {
        /**********
         *
         * @property canHideNextColumn
         *
         * @description
         * Service function that is called by clr-dg-column-toggle component. Use this if you need to ask if you can hide
         * a column. It acts as a guard against hiding all the columns making sure there is at least one column displayed.
         *
         */
        get: /**
         * *******
         *
         * \@property canHideNextColumn
         *
         * \@description
         * Service function that is called by clr-dg-column-toggle component. Use this if you need to ask if you can hide
         * a column. It acts as a guard against hiding all the columns making sure there is at least one column displayed.
         *
         * @return {?}
         */
        function () {
            /** @type {?} */
            var hiddenColumns = this._columnList.filter(function (column) { return column !== undefined; }).filter(function (column) { return column.hidden; });
            return this._columnList.length - hiddenColumns.length > 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HideableColumnService.prototype, "checkForAllColumnsVisible", {
        /**********
         *
         * @property checkForAllColumnsVisible
         *
         * @description
         * For when you need to know if the datagrid's columns are all showing.
         *
         */
        get: /**
         * *******
         *
         * \@property checkForAllColumnsVisible
         *
         * \@description
         * For when you need to know if the datagrid's columns are all showing.
         *
         * @return {?}
         */
        function () {
            return !this._columnList.some(function (column) { return column && column.hidden; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HideableColumnService.prototype, "columnListChange", {
        /***********
         * @property columnListChange
         *
         * @description
         * A public property that enables subscribers to hear updates to the column map.
         * Use this if you need to do something whenever the Datagrid's column list is changed (i.e *ngIf on a column).
         *
         */
        get: /**
         * ********
         * \@property columnListChange
         *
         * \@description
         * A public property that enables subscribers to hear updates to the column map.
         * Use this if you need to do something whenever the Datagrid's column list is changed (i.e *ngIf on a column).
         *
         * @return {?}
         */
        function () {
            return this._columnListChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**********
     *
     * @description
     * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
     * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
     *
     */
    /**
     * *******
     *
     * \@description
     * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
     * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
     *
     * @return {?}
     */
    HideableColumnService.prototype.getColumns = /**
     * *******
     *
     * \@description
     * Public function that returns the current list of columns. I needed an array of to iterate on in the RowRenderer
     * but subscribing to the _columnListChange changes did not seem like the correct way to get it.
     *
     * @return {?}
     */
    function () {
        return this._columnList;
    };
    /**********
     *
     * @description
     * Iterate through the current _columnList:
     * - if it has a DatagridHideableColumn and is hidden then show it.
     * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
     *
     */
    /**
     * *******
     *
     * \@description
     * Iterate through the current _columnList:
     * - if it has a DatagridHideableColumn and is hidden then show it.
     * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
     *
     * @return {?}
     */
    HideableColumnService.prototype.showHiddenColumns = /**
     * *******
     *
     * \@description
     * Iterate through the current _columnList:
     * - if it has a DatagridHideableColumn and is hidden then show it.
     * - if it's DatagridHideableColumn was previously the last column visible, turn that flag off.
     *
     * @return {?}
     */
    function () {
        this._columnList.forEach(function (column) {
            if (column && column.hidden === true) {
                column.hidden = false;
            }
            if (column && column.lastVisibleColumn) {
                column.lastVisibleColumn = false;
            }
        });
    };
    /**
     *
     * @param columns: DatagridColumn[]
     *
     * @description
     * Creates an array of DatagridHideableColumn's || null based column array passed as param.
     * Is dependent on the order in @ContentChildren in Datagrid.
     *
     */
    /**
     *
     * \@description
     * Creates an array of DatagridHideableColumn's || null based column array passed as param.
     * Is dependent on the order in \@ContentChildren in Datagrid.
     *
     * @param {?} columns
     * @return {?}
     */
    HideableColumnService.prototype.updateColumnList = /**
     *
     * \@description
     * Creates an array of DatagridHideableColumn's || null based column array passed as param.
     * Is dependent on the order in \@ContentChildren in Datagrid.
     *
     * @param {?} columns
     * @return {?}
     */
    function (columns) {
        this._columnList = columns; // clear the list
        this.updateForLastVisibleColumn(); // Update our visibility state for UI
        this._columnListChange.next(this._columnList); // Broadcast it
    };
    /**********
     *
     * @description
     * Gets the current visible count for all columns.
     * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
     * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
     * lastVisibleColumn.
     *
     */
    /**
     * *******
     *
     * \@description
     * Gets the current visible count for all columns.
     * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
     * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
     * lastVisibleColumn.
     *
     * @return {?}
     */
    HideableColumnService.prototype.updateForLastVisibleColumn = /**
     * *******
     *
     * \@description
     * Gets the current visible count for all columns.
     * When it is greater than 1 it marks everything as false for the lastVisibleColumn.
     * When visible count is not > 1 (i.e) 1. , it finds the only column that is not hidden and marks it as the
     * lastVisibleColumn.
     *
     * @return {?}
     */
    function () {
        // There is more than one column showing, make sure nothing is marked lastVisibleColumn
        if (this.canHideNextColumn) {
            this._columnList.map(function (column) {
                if (column && column.lastVisibleColumn) {
                    column.lastVisibleColumn = false;
                }
            });
        }
        else {
            // The visibleCount is down to only one column showing. Find it and flag it as the lastVisibleColumn
            this._columnList.map(function (column) {
                if (column && !column.hidden) {
                    column.lastVisibleColumn = true;
                }
            });
        }
    };
    /**********
     *
     * @description
     * Return a HideableColumn in this._columnList for the given id.
     *
     *
     */
    /**
     * *******
     *
     * \@description
     * Return a HideableColumn in this._columnList for the given id.
     *
     *
     * @param {?} id
     * @return {?}
     */
    HideableColumnService.prototype.getColumnById = /**
     * *******
     *
     * \@description
     * Return a HideableColumn in this._columnList for the given id.
     *
     *
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (id) {
            return this._columnList.find(function (column) { return column && column.id === id; });
        }
        return;
    };
    HideableColumnService.decorators = [
        { type: Injectable }
    ];
    return HideableColumnService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var WrappedCell = /** @class */ (function () {
    function WrappedCell() {
        this._dynamic = false;
    }
    // the cells projected view
    /**
     * @return {?}
     */
    WrappedCell.prototype.ngAfterViewInit = 
    // the cells projected view
    /**
     * @return {?}
     */
    function () {
        this.cellView = this.templateRef.createEmbeddedView(null);
    };
    WrappedCell.decorators = [
        { type: Component, args: [{
                    selector: 'dg-wrapped-cell',
                    template: "        \n        <ng-template #cellPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                }] }
    ];
    WrappedCell.propDecorators = {
        templateRef: [{ type: ViewChild, args: ['cellPortal',] }]
    };
    return WrappedCell;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridCell = /** @class */ (function () {
    function ClrDatagridCell(hideableColumnService, _el, _renderer, vcr) {
        this.hideableColumnService = hideableColumnService;
        this._el = _el;
        this._renderer = _renderer;
        this.vcr = vcr;
    }
    Object.defineProperty(ClrDatagridCell.prototype, "id", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value;
            this.mapHideableColumn(this._id);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} columnId
     * @return {?}
     */
    ClrDatagridCell.prototype.mapHideableColumn = /**
     * @param {?} columnId
     * @return {?}
     */
    function (columnId) {
        var _this = this;
        if (!columnId) {
            return;
        }
        /** @type {?} */
        var hideableColumn = this.hideableColumnService.getColumnById(this._id);
        this.setHiddenClass(hideableColumn.hidden);
        this.hiddenStateSubscription = hideableColumn.hiddenChangeState.subscribe(function () {
            _this.setHiddenClass(hideableColumn.hidden);
        });
    };
    /**
     * @param {?} hideableColumnValue
     * @return {?}
     */
    ClrDatagridCell.prototype.setHiddenClass = /**
     * @param {?} hideableColumnValue
     * @return {?}
     */
    function (hideableColumnValue) {
        if (hideableColumnValue) {
            this._renderer.addClass(this._el.nativeElement, 'datagrid-cell--hidden');
        }
        else {
            this._renderer.removeClass(this._el.nativeElement, 'datagrid-cell--hidden');
        }
    };
    /**
     * @return {?}
     */
    ClrDatagridCell.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.wrappedInjector = new HostWrapper(WrappedCell, this.vcr);
    };
    /**
     * @return {?}
     */
    ClrDatagridCell.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.hiddenStateSubscription) {
            this.hiddenStateSubscription.unsubscribe();
        }
    };
    Object.defineProperty(ClrDatagridCell.prototype, "_view", {
        get: /**
         * @return {?}
         */
        function () {
            return this.wrappedInjector.get(WrappedCell, this.vcr).cellView;
        },
        enumerable: true,
        configurable: true
    });
    ClrDatagridCell.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-cell',
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: {
                        '[class.datagrid-cell]': 'true',
                        '[class.datagrid-signpost-trigger]': 'signpost.length > 0',
                        role: 'cell',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrDatagridCell.ctorParameters = function () { return [
        { type: HideableColumnService },
        { type: ElementRef },
        { type: Renderer2 },
        { type: ViewContainerRef }
    ]; };
    ClrDatagridCell.propDecorators = {
        signpost: [{ type: ContentChildren, args: [ClrSignpost,] }]
    };
    return ClrDatagridCell;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
var DatagridDisplayMode = {
    DISPLAY: 0,
    CALCULATE: 1,
};
DatagridDisplayMode[DatagridDisplayMode.DISPLAY] = 'DISPLAY';
DatagridDisplayMode[DatagridDisplayMode.CALCULATE] = 'CALCULATE';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
var DatagridRenderStep = {
    ALIGN_COLUMNS: 0,
    CALCULATE_MODE_ON: 1,
    CALCULATE_MODE_OFF: 2,
    CLEAR_WIDTHS: 3,
    COMPUTE_COLUMN_WIDTHS: 4,
    DETECT_STRICT_WIDTHS: 5,
};
DatagridRenderStep[DatagridRenderStep.ALIGN_COLUMNS] = 'ALIGN_COLUMNS';
DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_ON] = 'CALCULATE_MODE_ON';
DatagridRenderStep[DatagridRenderStep.CALCULATE_MODE_OFF] = 'CALCULATE_MODE_OFF';
DatagridRenderStep[DatagridRenderStep.CLEAR_WIDTHS] = 'CLEAR_WIDTHS';
DatagridRenderStep[DatagridRenderStep.COMPUTE_COLUMN_WIDTHS] = 'COMPUTE_COLUMN_WIDTHS';
DatagridRenderStep[DatagridRenderStep.DETECT_STRICT_WIDTHS] = 'DETECT_STRICT_WIDTHS';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DatagridRenderOrganizer = /** @class */ (function () {
    function DatagridRenderOrganizer() {
        this._renderStep = new Subject();
        this.alreadySized = false;
    }
    Object.defineProperty(DatagridRenderOrganizer.prototype, "renderStep", {
        get: /**
         * @return {?}
         */
        function () {
            return this._renderStep.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} step
     * @return {?}
     */
    DatagridRenderOrganizer.prototype.filterRenderSteps = /**
     * @param {?} step
     * @return {?}
     */
    function (step) {
        return this.renderStep.pipe(filter(function (testStep) { return step === testStep; }));
    };
    /**
     * @return {?}
     */
    DatagridRenderOrganizer.prototype.resize = /**
     * @return {?}
     */
    function () {
        this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_ON);
        if (this.alreadySized) {
            this._renderStep.next(DatagridRenderStep.CLEAR_WIDTHS);
        }
        this._renderStep.next(DatagridRenderStep.DETECT_STRICT_WIDTHS);
        this._renderStep.next(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS);
        this._renderStep.next(DatagridRenderStep.ALIGN_COLUMNS);
        this.alreadySized = true;
        this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_OFF);
    };
    DatagridRenderOrganizer.decorators = [
        { type: Injectable }
    ];
    return DatagridRenderOrganizer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DisplayModeService = /** @class */ (function () {
    function DisplayModeService(renderOrganizer) {
        var _this = this;
        this.subscriptions = [];
        this._view = new BehaviorSubject(DatagridDisplayMode.DISPLAY);
        this.subscriptions.push(renderOrganizer
            .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_ON)
            .subscribe(function () { return _this._view.next(DatagridDisplayMode.CALCULATE); }));
        this.subscriptions.push(renderOrganizer
            .filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_OFF)
            .subscribe(function () { return _this._view.next(DatagridDisplayMode.DISPLAY); }));
    }
    Object.defineProperty(DisplayModeService.prototype, "view", {
        get: /**
         * @return {?}
         */
        function () {
            return this._view.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DisplayModeService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    DisplayModeService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    DisplayModeService.ctorParameters = function () { return [
        { type: DatagridRenderOrganizer }
    ]; };
    return DisplayModeService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
var SelectionType = {
    None: 0,
    Single: 1,
    Multi: 2,
};
SelectionType[SelectionType.None] = 'None';
SelectionType[SelectionType.Single] = 'Single';
SelectionType[SelectionType.Multi] = 'Multi';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var nbSelection = 0;
/**
 * @template T
 */
var Selection = /** @class */ (function () {
    function Selection(_items, _filters) {
        var _this = this;
        this._items = _items;
        this._filters = _filters;
        this.prevSelectionRefs = []; // Refs of selected items
        this._selectionType = SelectionType.None;
        this.rowSelectionMode = false;
        /**
         * Ignore items changes in the same change detection cycle.
         */
        // tslint:disable-next-line
        this.debounce = false;
        /**
         * Subscriptions to the other providers changes.
         */
        this.subscriptions = [];
        /**
         * The Observable that lets other classes subscribe to selection changes
         */
        this._change = new Subject();
        this.id = 'clr-dg-selection' + nbSelection++;
        this.subscriptions.push(this._filters.change.subscribe(function () {
            if (!_this._selectable) {
                return;
            }
            _this.clearSelection();
        }));
        this.subscriptions.push(this._items.allChanges.subscribe(function (updatedItems) {
            switch (_this.selectionType) {
                case SelectionType.None: {
                    break;
                }
                case SelectionType.Single: {
                    /** @type {?} */
                    var newSingle_1;
                    /** @type {?} */
                    var trackBy_1 = _this._items.trackBy;
                    /** @type {?} */
                    var selectionUpdated_1 = false;
                    // if the currentSingle has been set before data was loaded, we look up and save the ref from current data set
                    if (_this.currentSingle && !_this.prevSingleSelectionRef) {
                        if (_this._items.all && _this._items.trackBy) {
                            /** @type {?} */
                            var lookup = _this._items.all.findIndex(function (maybe) { return maybe === _this.currentSingle; });
                            _this.prevSingleSelectionRef = _this._items.trackBy(lookup, _this.currentSingle);
                        }
                    }
                    updatedItems.forEach(function (item, index) {
                        /** @type {?} */
                        var ref = trackBy_1(index, item);
                        // If one of the updated items is the previously selectedSingle, set it as the new one
                        if (_this.prevSingleSelectionRef === ref) {
                            newSingle_1 = item;
                            selectionUpdated_1 = true;
                        }
                    });
                    // If we're using smart datagrids, we expect all items to be present in the updatedItems array.
                    // Therefore, we should delete the currentSingle if it used to be defined but doesn't exist anymore.
                    // No explicit "delete" is required, since newSingle would be undefined at this point.
                    // Marking it as selectionUpdated here will set currentSingle to undefined below in the setTimeout.
                    if (_this._items.smart && !newSingle_1) {
                        selectionUpdated_1 = true;
                    }
                    // TODO: Discussed this with Eudes and this is fine for now.
                    // But we need to figure out a different pattern for the
                    // child triggering the parent change detection problem.
                    // Using setTimeout for now to fix this.
                    setTimeout(function () {
                        if (selectionUpdated_1) {
                            _this.currentSingle = newSingle_1;
                        }
                    }, 0);
                    break;
                }
                case SelectionType.Multi: {
                    /** @type {?} */
                    var leftOver_1 = _this.current.slice();
                    /** @type {?} */
                    var trackBy_2 = _this._items.trackBy;
                    /** @type {?} */
                    var selectionUpdated_2 = false;
                    // if the current has been set before data was loaded, we look up and save the ref from current data set
                    if (_this.current.length > 0 && _this.prevSelectionRefs.length !== _this.current.length) {
                        if (_this._items.all && _this._items.trackBy) {
                            _this.prevSelectionRefs = [];
                            _this.current.forEach(function (item) {
                                /** @type {?} */
                                var lookup = _this._items.all.findIndex(function (maybe) { return maybe === item; });
                                _this.prevSelectionRefs.push(_this._items.trackBy(lookup, item));
                            });
                        }
                    }
                    // TODO: revisit this when we work on https://github.com/vmware/clarity/issues/2342
                    // currently, the selection is cleared when filter is applied, so the logic inside
                    // the if statement below results in broken behavior.
                    if (leftOver_1.length > 0) {
                        updatedItems.forEach(function (item, index) {
                            /** @type {?} */
                            var ref = trackBy_2(index, item);
                            // Look in current selected refs array if item is selected, and update actual value
                            /** @type {?} */
                            var selectedIndex = _this.prevSelectionRefs.indexOf(ref);
                            if (selectedIndex > -1) {
                                leftOver_1[selectedIndex] = item;
                                selectionUpdated_2 = true;
                            }
                        });
                        // Filter out any unmatched items if we're using smart datagrids where we expect all items to be
                        // present
                        if (_this._items.smart) {
                            leftOver_1 = leftOver_1.filter(function (selected) { return updatedItems.indexOf(selected) > -1; });
                            if (_this.current.length !== leftOver_1.length) {
                                selectionUpdated_2 = true;
                            }
                        }
                        // TODO: Discussed this with Eudes and this is fine for now.
                        // But we need to figure out a different pattern for the
                        // child triggering the parent change detection problem.
                        // Using setTimeout for now to fix this.
                        setTimeout(function () {
                            if (selectionUpdated_2) {
                                _this.current = leftOver_1;
                            }
                        }, 0);
                    }
                    break;
                }
                default: {
                    break;
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    Selection.prototype.clearSelection = /**
     * @return {?}
     */
    function () {
        this.current.length = 0;
        this.prevSelectionRefs = [];
        this._currentSingle = null;
        this.prevSingleSelectionRef = null;
        this.emitChange();
    };
    Object.defineProperty(Selection.prototype, "selectionType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectionType;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === this.selectionType) {
                return;
            }
            this._selectionType = value;
            if (value === SelectionType.None) {
                delete this.current;
            }
            else {
                this.updateCurrent([], false);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "_selectable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectionType === SelectionType.Multi || this._selectionType === SelectionType.Single;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cleans up our subscriptions to other providers
     */
    /**
     * Cleans up our subscriptions to other providers
     * @return {?}
     */
    Selection.prototype.destroy = /**
     * Cleans up our subscriptions to other providers
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    Object.defineProperty(Selection.prototype, "currentSingle", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currentSingle;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (value === this._currentSingle) {
                return;
            }
            this._currentSingle = value;
            if (this._items.all && this._items.trackBy && value) {
                /** @type {?} */
                var lookup = this._items.all.findIndex(function (maybe) { return maybe === value; });
                this.prevSingleSelectionRef = this._items.trackBy(lookup, value);
            }
            this.emitChange();
            // Ignore items changes in the same change detection cycle.
            // @TODO This can likely be removed!
            this.debounce = true;
            setTimeout(function () { return (_this.debounce = false); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Selection.prototype, "current", {
        get: /**
         * @return {?}
         */
        function () {
            return this._current;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.updateCurrent(value, true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    Selection.prototype.updateCurrent = /**
     * @param {?} value
     * @param {?} emit
     * @return {?}
     */
    function (value, emit) {
        var _this = this;
        this._current = value;
        if (emit) {
            this.emitChange();
            // Ignore items changes in the same change detection cycle.
            // @TODO This can likely be removed!
            this.debounce = true;
            setTimeout(function () { return (_this.debounce = false); });
        }
    };
    /**
     * @return {?}
     */
    Selection.prototype.emitChange = /**
     * @return {?}
     */
    function () {
        if (this._selectionType === SelectionType.Single) {
            this._change.next(this.currentSingle);
        }
        else if (this._selectionType === SelectionType.Multi) {
            this._change.next(this.current);
        }
    };
    Object.defineProperty(Selection.prototype, "change", {
        // We do not want to expose the Subject itself, but the Observable which is read-only
        get: 
        // We do not want to expose the Subject itself, but the Observable which is read-only
        /**
         * @return {?}
         */
        function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Checks if an item is currently selected
     */
    /**
     * Checks if an item is currently selected
     * @param {?} item
     * @return {?}
     */
    Selection.prototype.isSelected = /**
     * Checks if an item is currently selected
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this._selectionType === SelectionType.Single) {
            return this.currentSingle === item;
        }
        else if (this._selectionType === SelectionType.Multi) {
            return this.current.indexOf(item) >= 0;
        }
        return false;
    };
    /**
     * Selects an item
     */
    /**
     * Selects an item
     * @param {?} item
     * @return {?}
     */
    Selection.prototype.selectItem = /**
     * Selects an item
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.current.push(item);
        if (this._items.trackBy) {
            // Push selected ref onto array
            /** @type {?} */
            var lookup = this._items.all.findIndex(function (maybe) { return maybe === item; });
            this.prevSelectionRefs.push(this._items.trackBy(lookup, item));
        }
    };
    /**
     * Deselects an item
     */
    /**
     * Deselects an item
     * @param {?} indexOfItem
     * @return {?}
     */
    Selection.prototype.deselectItem = /**
     * Deselects an item
     * @param {?} indexOfItem
     * @return {?}
     */
    function (indexOfItem) {
        this.current.splice(indexOfItem, 1);
        if (this._items.trackBy && indexOfItem < this.prevSelectionRefs.length) {
            // Keep selected refs array in sync
            this.prevSelectionRefs.splice(indexOfItem, 1);
        }
    };
    /**
     * Selects or deselects an item
     */
    /**
     * Selects or deselects an item
     * @param {?} item
     * @param {?} selected
     * @return {?}
     */
    Selection.prototype.setSelected = /**
     * Selects or deselects an item
     * @param {?} item
     * @param {?} selected
     * @return {?}
     */
    function (item, selected) {
        switch (this._selectionType) {
            case SelectionType.None:
                break;
            case SelectionType.Single:
                // in single selection, set currentSingle method should be used
                break;
            case SelectionType.Multi:
                /** @type {?} */
                var index = this.current.indexOf(item);
                if (index >= 0 && !selected) {
                    this.deselectItem(index);
                    this.emitChange();
                }
                else if (index < 0 && selected) {
                    this.selectItem(item);
                    this.emitChange();
                }
                break;
            default:
                break;
        }
    };
    /**
     * Checks if all currently displayed items are selected
     */
    /**
     * Checks if all currently displayed items are selected
     * @return {?}
     */
    Selection.prototype.isAllSelected = /**
     * Checks if all currently displayed items are selected
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._selectionType !== SelectionType.Multi || !this._items.displayed) {
            return false;
        }
        /** @type {?} */
        var displayedItems = this._items.displayed;
        /** @type {?} */
        var nbDisplayed = this._items.displayed.length;
        if (nbDisplayed < 1) {
            return false;
        }
        /** @type {?} */
        var temp = displayedItems.filter(function (item) { return _this.current.indexOf(item) > -1; });
        return temp.length === displayedItems.length;
    };
    /**
     * Selects or deselects all currently displayed items
     */
    /**
     * Selects or deselects all currently displayed items
     * @return {?}
     */
    Selection.prototype.toggleAll = /**
     * Selects or deselects all currently displayed items
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
            return;
        }
        /*
             * If every currently displayed item is already selected, we clear them.
             * If at least one item isn't selected, we select every currently displayed item.
             */
        if (this.isAllSelected()) {
            this._items.displayed.forEach(function (item) {
                /** @type {?} */
                var currentIndex = _this.current.indexOf(item);
                if (currentIndex > -1) {
                    _this.deselectItem(currentIndex);
                }
            });
        }
        else {
            this._items.displayed.forEach(function (item) {
                if (_this.current.indexOf(item) < 0) {
                    _this.selectItem(item);
                }
            });
        }
        this.emitChange();
    };
    Selection.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    Selection.ctorParameters = function () { return [
        { type: Items },
        { type: FiltersProvider }
    ]; };
    return Selection;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var WrappedRow = /** @class */ (function () {
    function WrappedRow() {
        this._dynamic = false;
    }
    // the rows projected view (in memory)
    /**
     * @return {?}
     */
    WrappedRow.prototype.ngAfterViewInit = 
    // the rows projected view (in memory)
    /**
     * @return {?}
     */
    function () {
        // Create the cells view in memory, not the DOM.
        this.rowView = this.templateRef.createEmbeddedView(null);
    };
    WrappedRow.decorators = [
        { type: Component, args: [{
                    selector: 'dg-wrapped-row',
                    template: "        \n        <ng-template #rowPortal>\n            <ng-content></ng-content>\n        </ng-template>\n    "
                }] }
    ];
    WrappedRow.propDecorators = {
        templateRef: [{ type: ViewChild, args: ['rowPortal',] }]
    };
    return WrappedRow;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var nbRow = 0;
/**
 * @template T
 */
var ClrDatagridRow = /** @class */ (function () {
    function ClrDatagridRow(selection, rowActionService, globalExpandable, expand, hideableColumnService, displayMode, vcr, renderer, el, commonStrings) {
        var _this = this;
        this.selection = selection;
        this.rowActionService = rowActionService;
        this.globalExpandable = globalExpandable;
        this.expand = expand;
        this.hideableColumnService = hideableColumnService;
        this.displayMode = displayMode;
        this.vcr = vcr;
        this.renderer = renderer;
        this.el = el;
        this.commonStrings = commonStrings;
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
        this._selected = false;
        this.selectedChanged = new EventEmitter(false);
        this.expandedChange = new EventEmitter(false);
        this.subscriptions = [];
        this.displayCells = false;
        nbRow++;
        this.id = 'clr-dg-row' + nbRow;
        this.radioId = 'clr-dg-row-rd' + nbRow;
        this.checkboxId = 'clr-dg-row-cb' + nbRow;
        this.subscriptions.push(combineLatest(this.expand.replace, this.expand.expandChange).subscribe(function (_a) {
            var _b = __read(_a, 2), expandReplaceValue = _b[0], expandChangeValue = _b[1];
            if (expandReplaceValue && expandChangeValue) {
                // replaced and expanding
                _this.replaced = true;
                _this.renderer.addClass(_this.el.nativeElement, 'datagrid-row-replaced');
            }
            else {
                _this.replaced = false;
                // Handles these cases: not replaced and collapsing & replaced and
                // collapsing and not replaced and expanding.
                _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-row-replaced');
            }
        }));
    }
    Object.defineProperty(ClrDatagridRow.prototype, "selected", {
        /**
         * Indicates if the row is selected
         */
        get: /**
         * Indicates if the row is selected
         * @return {?}
         */
        function () {
            if (this.selection.selectionType === SelectionType.None) {
                return this._selected;
            }
            else {
                return this.selection.isSelected(this.item);
            }
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.selection.selectionType === SelectionType.None) {
                this._selected = value;
            }
            else {
                this.selection.setSelected(this.item, value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} selected
     * @return {?}
     */
    ClrDatagridRow.prototype.toggle = /**
     * @param {?=} selected
     * @return {?}
     */
    function (selected) {
        if (selected === void 0) { selected = !this.selected; }
        if (selected !== this.selected) {
            this.selected = selected;
            this.selectedChanged.emit(selected);
        }
    };
    Object.defineProperty(ClrDatagridRow.prototype, "expanded", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expand.expanded;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.expand.expanded = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDatagridRow.prototype.toggleExpand = /**
     * @return {?}
     */
    function () {
        if (this.expand.expandable) {
            this.expanded = !this.expanded;
            this.expandedChange.emit(this.expanded);
        }
    };
    /**
     * @return {?}
     */
    ClrDatagridRow.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Make sure things get started
        /** @type {?} */
        var columnsList = this.hideableColumnService.getColumns();
        this.updateCellsForColumns(columnsList);
        // Triggered when the Cells list changes per row-renderer
        this.dgCells.changes.subscribe(function (cellList) {
            /** @type {?} */
            var columnList = _this.hideableColumnService.getColumns();
            if (cellList.length === columnList.length) {
                _this.updateCellsForColumns(columnList);
                _this.dgCells.forEach(function (cell) {
                    _this._scrollableCells.insert(cell._view);
                });
            }
        });
        // Used to set things up the first time but only after all the columns are ready.
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
            // Prevents cell updates when cols and cells array are not aligned - only seems to run on init / first time.
            if (columnList.length === _this.dgCells.length) {
                _this.updateCellsForColumns(columnList);
            }
        }));
    };
    /**
     * @return {?}
     */
    ClrDatagridRow.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.displayMode.view.subscribe(function (viewChange) {
            // Listen for view changes and move cells around depending on the current displayType
            // remove cell views from display view
            for (var i = _this._scrollableCells.length; i > 0; i--) {
                _this._scrollableCells.detach();
            }
            // remove cell views from calculated view
            for (var i = _this._calculatedCells.length; i > 0; i--) {
                _this._calculatedCells.detach();
            }
            if (viewChange === DatagridDisplayMode.CALCULATE) {
                _this.displayCells = false;
                _this.dgCells.forEach(function (cell) {
                    _this._calculatedCells.insert(cell._view);
                });
            }
            else {
                _this.displayCells = true;
                _this.dgCells.forEach(function (cell) {
                    _this._scrollableCells.insert(cell._view);
                });
            }
        }));
    };
    /**********
     *
     * @description
     * 1. Maps the new columnListChange to the dgCells list by index
     * 2. Sets the hidden state on the cell
     * Take a Column list and use index to access the columns for hideable properties.
     *
     */
    /**
     * *******
     *
     * \@description
     * 1. Maps the new columnListChange to the dgCells list by index
     * 2. Sets the hidden state on the cell
     * Take a Column list and use index to access the columns for hideable properties.
     *
     * @param {?} columnList
     * @return {?}
     */
    ClrDatagridRow.prototype.updateCellsForColumns = /**
     * *******
     *
     * \@description
     * 1. Maps the new columnListChange to the dgCells list by index
     * 2. Sets the hidden state on the cell
     * Take a Column list and use index to access the columns for hideable properties.
     *
     * @param {?} columnList
     * @return {?}
     */
    function (columnList) {
        // Map cells to columns with Array.index
        this.dgCells.forEach(function (cell, index) {
            /** @type {?} */
            var currentColumn = columnList[index];
            if (currentColumn) {
                cell.id = currentColumn.id;
            }
        });
    };
    /**
     * @return {?}
     */
    ClrDatagridRow.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * @return {?}
     */
    ClrDatagridRow.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.wrappedInjector = new HostWrapper(WrappedRow, this.vcr);
    };
    Object.defineProperty(ClrDatagridRow.prototype, "_view", {
        get: /**
         * @return {?}
         */
        function () {
            return this.wrappedInjector.get(WrappedRow, this.vcr).rowView;
        },
        enumerable: true,
        configurable: true
    });
    ClrDatagridRow.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-row',
                    template: "<!--\n  We need to wrap the #rowContent in label element if we are in rowSelectionMode.\n  Clicking of that wrapper label will equate to clicking on the whole row, which triggers the checkbox to toggle.\n-->\n<label class=\"datagrid-row-clickable\" *ngIf=\"selection.rowSelectionMode\">\n  <ng-template [ngTemplateOutlet]=\"rowContent\"></ng-template>\n</label>\n\n<ng-template *ngIf=\"!selection.rowSelectionMode\" [ngTemplateOutlet]=\"rowContent\"></ng-template>\n\n<!--\n    We need the \"project into template\" hacks because we need this in 2 different places\n    depending on whether the details replace the row or not.\n-->\n<ng-template #detail>\n  <ng-content select=\"clr-dg-row-detail\"></ng-content>\n</ng-template>\n\n<ng-template #rowContent>\n  <div role=\"row\" [id]=\"id\" class=\"datagrid-row-master datagrid-row-flex\">\n    <div class=\"datagrid-row-sticky\">\n      <!-- Sticky elements here -->\n      <ng-container #stickyCells></ng-container> <!-- placeholder for projecting other sticky cells as pinned-->\n    </div>\n    <div class=\"datagrid-row-scrollable\" [ngClass]=\"{'is-replaced': replaced && expanded}\">\n      <div class=\"datagrid-scrolling-cells\">\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\">\n          <input clrCheckbox type=\"checkbox\" [ngModel]=\"selected\" (ngModelChange)=\"toggle($event)\" [id]=\"checkboxId\"\n                 [attr.aria-label]=\"commonStrings.select\">\n        </div>\n        <div *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\"\n             class=\"datagrid-select datagrid-fixed-column datagrid-cell\">\n            <!-- TODO: it would be better if in addition to the generic \"Select\" label, we could add aria-labelledby\n            to label the radio by the first cell in the row (typically an id or name).\n            It's pretty easy to label it with the whole row since we already have an id for it, but in most\n            cases the row is far too long to serve as a label, the screenreader reads every single cell content. -->\n            <input type=\"radio\" clrRadio [id]=\"radioId\" [name]=\"selection.id + '-radio'\" [value]=\"item\"\n                   [(ngModel)]=\"selection.currentSingle\" [checked]=\"selection.currentSingle === item\"\n                   [attr.aria-label]=\"commonStrings.select\">\n        </div>\n        <div *ngIf=\"rowActionService.hasActionableRow\"\n             class=\"datagrid-row-actions datagrid-fixed-column datagrid-cell\">\n          <ng-content select=\"clr-dg-action-overflow\"></ng-content>\n        </div>\n        <div *ngIf=\"globalExpandable.hasExpandableRow\"\n             class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\">\n          <ng-container *ngIf=\"expand.expandable\">\n            <button (click)=\"toggleExpand()\" *ngIf=\"!expand.loading\" type=\"button\" class=\"datagrid-expandable-caret-button\">\n              <clr-icon shape=\"caret\"\n                        class=\"datagrid-expandable-caret-icon\"\n                        [attr.dir]=\"expand.expanded ? 'down' : 'right'\"\n                        [attr.title]=\"expand.expanded ? commonStrings.collapse : commonStrings.expand\"></clr-icon>\n            </button>\n            <div class=\"spinner spinner-sm\" *ngIf=\"expand.loading\"></div>\n          </ng-container>\n        </div>\n        <ng-container #scrollableCells></ng-container>\n      </div>\n      <!-- details here when replace, re-visit when sticky container is used for pinned cells -->\n      <ng-template *ngIf=\"replaced && !expand.loading\"\n                   [ngTemplateOutlet]=\"detail\"></ng-template>\n    </div>\n    <ng-template *ngIf=\"!replaced && !expand.loading\"\n                 [ngTemplateOutlet]=\"detail\"></ng-template>\n  </div>\n</ng-template>\n\n<ng-container #calculatedCells></ng-container>\n",
                    host: {
                        '[class.datagrid-row]': 'true',
                        '[class.datagrid-selected]': 'selected',
                        '[attr.aria-owns]': 'id',
                        role: 'rowgroup',
                    },
                    providers: [Expand, { provide: LoadingListener, useExisting: Expand }]
                }] }
    ];
    /** @nocollapse */
    ClrDatagridRow.ctorParameters = function () { return [
        { type: Selection },
        { type: RowActionService },
        { type: ExpandableRowsCount },
        { type: Expand },
        { type: HideableColumnService },
        { type: DisplayModeService },
        { type: ViewContainerRef },
        { type: Renderer2 },
        { type: ElementRef },
        { type: ClrCommonStrings }
    ]; };
    ClrDatagridRow.propDecorators = {
        item: [{ type: Input, args: ['clrDgItem',] }],
        selected: [{ type: Input, args: ['clrDgSelected',] }],
        selectedChanged: [{ type: Output, args: ['clrDgSelectedChange',] }],
        expanded: [{ type: Input, args: ['clrDgExpanded',] }],
        expandedChange: [{ type: Output, args: ['clrDgExpandedChange',] }],
        dgCells: [{ type: ContentChildren, args: [ClrDatagridCell,] }],
        _stickyCells: [{ type: ViewChild, args: ['stickyCells', { read: ViewContainerRef },] }],
        _scrollableCells: [{ type: ViewChild, args: ['scrollableCells', { read: ViewContainerRef },] }],
        _calculatedCells: [{ type: ViewChild, args: ['calculatedCells', { read: ViewContainerRef },] }]
    };
    return ClrDatagridRow;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ColumnToggleButtonsService = /** @class */ (function () {
    function ColumnToggleButtonsService() {
        this.buttons = null;
        this.selectAllDisabled = false;
        this._selectAllButtonClicked = new Subject();
    }
    Object.defineProperty(ColumnToggleButtonsService.prototype, "selectAllButtonClicked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selectAllButtonClicked.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ColumnToggleButtonsService.prototype.buttonClicked = /**
     * @return {?}
     */
    function () {
        this._selectAllButtonClicked.next();
    };
    ColumnToggleButtonsService.decorators = [
        { type: Injectable }
    ];
    return ColumnToggleButtonsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This provider aggregates state changes from the various providers of the Datagrid
 * @template T
 */
var StateProvider = /** @class */ (function () {
    function StateProvider(filters, sort, page, debouncer) {
        var _this = this;
        this.filters = filters;
        this.sort = sort;
        this.page = page;
        this.debouncer = debouncer;
        /**
         * The Observable that lets other classes subscribe to global state changes
         */
        this.change = this.debouncer.change.pipe(map(function () { return _this.state; }));
    }
    Object.defineProperty(StateProvider.prototype, "state", {
        /*
           * By making this a getter, we open the possibility for a setter in the future.
           * It's been requested a couple times.
           */
        get: /*
             * By making this a getter, we open the possibility for a setter in the future.
             * It's been requested a couple times.
             */
        /**
         * @return {?}
         */
        function () {
            var e_1, _a;
            /** @type {?} */
            var state$$1 = {};
            if (this.page.size > 0) {
                state$$1.page = { from: this.page.firstItem, to: this.page.lastItem, size: this.page.size };
            }
            if (this.sort.comparator) {
                if (this.sort.comparator instanceof DatagridPropertyComparator) {
                    /*
                             * Special case for the default object property comparator,
                             * we give the property name instead of the actual comparator.
                             */
                    state$$1.sort = { by: ((/** @type {?} */ (this.sort.comparator))).prop, reverse: this.sort.reverse };
                }
                else {
                    state$$1.sort = { by: this.sort.comparator, reverse: this.sort.reverse };
                }
            }
            /** @type {?} */
            var activeFilters = this.filters.getActiveFilters();
            if (activeFilters.length > 0) {
                state$$1.filters = [];
                try {
                    for (var activeFilters_1 = __values(activeFilters), activeFilters_1_1 = activeFilters_1.next(); !activeFilters_1_1.done; activeFilters_1_1 = activeFilters_1.next()) {
                        var filter$$1 = activeFilters_1_1.value;
                        if (filter$$1.state) {
                            state$$1.filters.push(filter$$1.state);
                        }
                        else {
                            state$$1.filters.push(filter$$1);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (activeFilters_1_1 && !activeFilters_1_1.done && (_a = activeFilters_1.return)) _a.call(activeFilters_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return state$$1;
        },
        enumerable: true,
        configurable: true
    });
    StateProvider.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateProvider.ctorParameters = function () { return [
        { type: FiltersProvider },
        { type: Sort },
        { type: Page },
        { type: StateDebouncer }
    ]; };
    return StateProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * \@description
 * Internal datagrid service that holds a reference to the clr-dg-table element and exposes a method to get height.
 */
var TableSizeService = /** @class */ (function () {
    function TableSizeService(platformId) {
        this.platformId = platformId;
    }
    Object.defineProperty(TableSizeService.prototype, "tableRef", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tableRef;
        },
        set: /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            this._tableRef = element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TableSizeService.prototype, "table", {
        set: /**
         * @param {?} table
         * @return {?}
         */
        function (table) {
            if (isPlatformBrowser(this.platformId) && table.nativeElement) {
                this.tableRef = table.nativeElement.querySelector('.datagrid-table');
            }
        },
        enumerable: true,
        configurable: true
    });
    // Used when resizing columns to show the column border being dragged.
    // Used when resizing columns to show the column border being dragged.
    /**
     * @return {?}
     */
    TableSizeService.prototype.getColumnDragHeight = 
    // Used when resizing columns to show the column border being dragged.
    /**
     * @return {?}
     */
    function () {
        if (!this.tableRef) {
            return;
        }
        return this.tableRef.clientHeight + "px";
    };
    TableSizeService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    TableSizeService.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    return TableSizeService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ColumnsService = /** @class */ (function () {
    function ColumnsService(organizer) {
        var _this = this;
        this.organizer = organizer;
        this.subscriptions = [];
        this.columns = [];
        this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.reset(); }));
    }
    /**
     * @return {?}
     */
    ColumnsService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * @return {?}
     */
    ColumnsService.prototype.reset = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.columns.forEach(function (column, index) {
            _this.emitStateChange(index, { width: 0 });
        });
    };
    // Helper method to emit a change to a column only when there is an actual diff to process for that column
    // Helper method to emit a change to a column only when there is an actual diff to process for that column
    /**
     * @param {?} columnIndex
     * @param {?} diff
     * @return {?}
     */
    ColumnsService.prototype.emitStateChange = 
    // Helper method to emit a change to a column only when there is an actual diff to process for that column
    /**
     * @param {?} columnIndex
     * @param {?} diff
     * @return {?}
     */
    function (columnIndex, diff) {
        if (!this.columns[columnIndex]) {
            return;
        }
        /** @type {?} */
        var current = this.columns[columnIndex].value;
        /** @type {?} */
        var hasChange = Object.keys(diff).filter(function (key) { return diff[key] !== current[key]; });
        if (hasChange) {
            this.columns[columnIndex].next(__assign({}, current, diff));
        }
    };
    ColumnsService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ColumnsService.ctorParameters = function () { return [
        { type: DatagridRenderOrganizer }
    ]; };
    return ColumnsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDatagrid = /** @class */ (function () {
    function ClrDatagrid(columnService, organizer, items, expandableRows, selection, rowActionService, stateProvider, displayMode, renderer, el, commonStrings) {
        this.columnService = columnService;
        this.organizer = organizer;
        this.items = items;
        this.expandableRows = expandableRows;
        this.selection = selection;
        this.rowActionService = rowActionService;
        this.stateProvider = stateProvider;
        this.displayMode = displayMode;
        this.renderer = renderer;
        this.el = el;
        this.commonStrings = commonStrings;
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
        /**
         * Output emitted whenever the data needs to be refreshed, based on user action or external ones
         */
        this.refresh = new EventEmitter(false);
        this.selectedChanged = new EventEmitter(false);
        this.singleSelectedChanged = new EventEmitter(false);
        /**
         * Subscriptions to all the services and queries changes
         */
        this._subscriptions = [];
    }
    Object.defineProperty(ClrDatagrid.prototype, "loading", {
        /**
         * Freezes the datagrid while data is loading
         */
        get: /**
         * Freezes the datagrid while data is loading
         * @return {?}
         */
        function () {
            return this.items.loading;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.items.loading = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Public method to re-trigger the computation of displayed items manually
     */
    /**
     * Public method to re-trigger the computation of displayed items manually
     * @return {?}
     */
    ClrDatagrid.prototype.dataChanged = /**
     * Public method to re-trigger the computation of displayed items manually
     * @return {?}
     */
    function () {
        this.items.refresh();
    };
    Object.defineProperty(ClrDatagrid.prototype, "selected", {
        /**
         * Array of all selected items
         */
        set: /**
         * Array of all selected items
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.selection.selectionType = SelectionType.Multi;
            }
            else {
                this.selection.selectionType = SelectionType.None;
            }
            this.selection.updateCurrent(value, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagrid.prototype, "singleSelected", {
        /**
         * Selected item in single-select mode
         */
        set: /**
         * Selected item in single-select mode
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selection.selectionType = SelectionType.Single;
            // the clrDgSingleSelected is updated in one of two cases:
            // 1. an explicit value is passed
            // 2. is being set to null or undefined, where previously it had a value
            if (value) {
                this.selection.currentSingle = value;
            }
            else if (this.selection.currentSingle) {
                this.selection.currentSingle = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagrid.prototype, "rowSelectionMode", {
        /**
         * Selection/Deselection on row click mode
         */
        set: /**
         * Selection/Deselection on row click mode
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selection.rowSelectionMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagrid.prototype, "allSelected", {
        /**
         * Indicates if all currently displayed items are selected
         */
        get: /**
         * Indicates if all currently displayed items are selected
         * @return {?}
         */
        function () {
            return this.selection.isAllSelected();
        },
        /**
         * Selects/deselects all currently displayed items
         * @param value
         */
        set: /**
         * Selects/deselects all currently displayed items
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /*
                 * This is a setter but we ignore the value.
                 * It's strange, but it lets us have an indeterminate state where only
                 * some of the items are selected.
                 */
            this.selection.toggleAll();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDatagrid.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.items.smart) {
            this.items.all = this.rows.map(function (row) { return row.item; });
        }
        this._subscriptions.push(this.rows.changes.subscribe(function () {
            if (!_this.items.smart) {
                _this.items.all = _this.rows.map(function (row) { return row.item; });
            }
            _this.rows.forEach(function (row) {
                _this._displayedRows.insert(row._view);
            });
        }));
        this._subscriptions.push(this.columns.changes.subscribe(function (columns) {
            _this.columnService.updateColumnList(_this.columns.map(function (col) { return col.hideable; }));
        }));
        // Get ColumnService ready for HideableColumns.
        this.columnService.updateColumnList(this.columns.map(function (col) { return col.hideable; }));
    };
    /**
     * Our setup happens in the view of some of our components, so we wait for it to be done before starting
     */
    /**
     * Our setup happens in the view of some of our components, so we wait for it to be done before starting
     * @return {?}
     */
    ClrDatagrid.prototype.ngAfterViewInit = /**
     * Our setup happens in the view of some of our components, so we wait for it to be done before starting
     * @return {?}
     */
    function () {
        var _this = this;
        // TODO: determine if we can get rid of provider wiring in view init so that subscriptions can be done earlier
        this.refresh.emit(this.stateProvider.state);
        this._subscriptions.push(this.stateProvider.change.subscribe(function (state$$1) { return _this.refresh.emit(state$$1); }));
        this._subscriptions.push(this.selection.change.subscribe(function (s) {
            if (_this.selection.selectionType === SelectionType.Single) {
                _this.singleSelectedChanged.emit((/** @type {?} */ (s)));
            }
            else if (_this.selection.selectionType === SelectionType.Multi) {
                _this.selectedChanged.emit((/** @type {?} */ (s)));
            }
        }));
        // A subscription that listens for displayMode changes on the datagrid
        this.displayMode.view.subscribe(function (viewChange) {
            // Remove any projected columns from the projectedDisplayColumns container
            for (var i = _this._projectedDisplayColumns.length; i > 0; i--) {
                _this._projectedDisplayColumns.detach();
            }
            // Remove any projected columns from the projectedCalculationColumns container
            for (var i = _this._projectedCalculationColumns.length; i > 0; i--) {
                _this._projectedCalculationColumns.detach();
            }
            // Remove any projected rows from the calculationRows container
            for (var i = _this._calculationRows.length; i > 0; i--) {
                _this._calculationRows.detach();
            }
            // Remove any projected rows from the displayedRows container
            for (var i = _this._displayedRows.length; i > 0; i--) {
                _this._displayedRows.detach();
            }
            if (viewChange === DatagridDisplayMode.DISPLAY) {
                // Set state, style for the datagrid to DISPLAY and insert row & columns into containers
                _this.renderer.removeClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                _this.columns.forEach(function (column) {
                    _this._projectedDisplayColumns.insert(column._view);
                });
                _this.rows.forEach(function (row) {
                    _this._displayedRows.insert(row._view);
                });
            }
            else {
                // Set state, style for the datagrid to CALCULATE and insert row & columns into containers
                _this.renderer.addClass(_this.el.nativeElement, 'datagrid-calculate-mode');
                _this.columns.forEach(function (column) {
                    _this._projectedCalculationColumns.insert(column._view);
                });
                _this.rows.forEach(function (row) {
                    _this._calculationRows.insert(row._view);
                });
            }
        });
    };
    /**
     * @return {?}
     */
    ClrDatagrid.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * @return {?}
     */
    ClrDatagrid.prototype.resize = /**
     * @return {?}
     */
    function () {
        this.organizer.resize();
    };
    ClrDatagrid.decorators = [
        { type: Component, args: [{
                    selector: 'clr-datagrid',
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-content select=\"clr-dg-action-bar\"></ng-content>\n<div class=\"datagrid\" #datagrid>\n    <div class=\"datagrid-table-wrapper\">\n      <div role=\"grid\" class=\"datagrid-table\">\n        <div role=\"rowgroup\" class=\"datagrid-header\">\n          <div role=\"row\" class=\"datagrid-row\">\n            <div class=\"datagrid-row-master datagrid-row-flex\">\n              <div class=\"datagrid-row-sticky\">\n                <!-- Sticky elements here -->\n              </div>\n              <div class=\"datagrid-row-scrollable\">\n                <!--header for datagrid where you can select multiple rows -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                     *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n                            <span class=\"datagrid-column-title\">\n                                <input clrCheckbox type=\"checkbox\" [(ngModel)]=\"allSelected\"\n                                       [attr.aria-label]=\"commonStrings.selectAll\">\n                            </span>\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <!-- header for datagrid where you can select one row only -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-select datagrid-fixed-column\"\n                     *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\">\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <!-- header for single row action; only displayType if we have at least one actionable row in datagrid -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-row-actions datagrid-fixed-column\"\n                     *ngIf=\"rowActionService.hasActionableRow\">\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <!-- header for carets; only displayType if we have at least one expandable row in datagrid -->\n                <div role=\"columnheader\" class=\"datagrid-column datagrid-expandable-caret datagrid-fixed-column\"\n                     *ngIf=\"expandableRows.hasExpandableRow\">\n                  <div class=\"datagrid-column-separator\"></div>\n                </div>\n                <ng-container #projectedDisplayColumns></ng-container>\n              </div>\n            </div>\n          </div>\n        </div>\n        <ng-container #displayedRows></ng-container>\n        <!-- Custom placeholder overrides the default empty one -->\n        <ng-content select=\"clr-dg-placeholder\"></ng-content>\n        <clr-dg-placeholder *ngIf=\"!placeholder\"></clr-dg-placeholder>\n      </div>\n    </div>\n</div>\n<ng-content select=\"clr-dg-footer\"></ng-content>\n<div class=\"datagrid-spinner\" *ngIf=\"loading\">\n    <div class=\"spinner spinner-md\">Loading...</div>\n</div>\n\n<div class=\"datagrid-calculation-table\">\n    <div class=\"datagrid-calculation-header\">\n        <ng-container #projectedCalculationColumns></ng-container>\n    </div>\n    <ng-container #calculationRows></ng-container>\n</div>\n",
                    providers: [
                        Selection,
                        Sort,
                        FiltersProvider,
                        Page,
                        Items,
                        DatagridRenderOrganizer,
                        RowActionService,
                        ExpandableRowsCount,
                        HideableColumnService,
                        StateDebouncer,
                        StateProvider,
                        ColumnToggleButtonsService,
                        TableSizeService,
                        ColumnsService,
                        DisplayModeService,
                    ],
                    host: { '[class.datagrid-host]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrDatagrid.ctorParameters = function () { return [
        { type: HideableColumnService },
        { type: DatagridRenderOrganizer },
        { type: Items },
        { type: ExpandableRowsCount },
        { type: Selection },
        { type: RowActionService },
        { type: StateProvider },
        { type: DisplayModeService },
        { type: Renderer2 },
        { type: ElementRef },
        { type: ClrCommonStrings }
    ]; };
    ClrDatagrid.propDecorators = {
        loading: [{ type: Input, args: ['clrDgLoading',] }],
        refresh: [{ type: Output, args: ['clrDgRefresh',] }],
        iterator: [{ type: ContentChild, args: [ClrDatagridItems,] }],
        selected: [{ type: Input, args: ['clrDgSelected',] }],
        selectedChanged: [{ type: Output, args: ['clrDgSelectedChange',] }],
        singleSelected: [{ type: Input, args: ['clrDgSingleSelected',] }],
        singleSelectedChanged: [{ type: Output, args: ['clrDgSingleSelectedChange',] }],
        rowSelectionMode: [{ type: Input, args: ['clrDgRowSelection',] }],
        placeholder: [{ type: ContentChild, args: [ClrDatagridPlaceholder,] }],
        columns: [{ type: ContentChildren, args: [ClrDatagridColumn,] }],
        rows: [{ type: ContentChildren, args: [ClrDatagridRow,] }],
        scrollableColumns: [{ type: ViewChild, args: ['scrollableColumns', { read: ViewContainerRef },] }],
        _projectedDisplayColumns: [{ type: ViewChild, args: ['projectedDisplayColumns', { read: ViewContainerRef },] }],
        _projectedCalculationColumns: [{ type: ViewChild, args: ['projectedCalculationColumns', { read: ViewContainerRef },] }],
        _displayedRows: [{ type: ViewChild, args: ['displayedRows', { read: ViewContainerRef },] }],
        _calculationRows: [{ type: ViewChild, args: ['calculationRows', { read: ViewContainerRef },] }]
    };
    return ClrDatagrid;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridActionBar = /** @class */ (function () {
    function ClrDatagridActionBar() {
    }
    ClrDatagridActionBar.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-action-bar',
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: { '[class.datagrid-action-bar]': 'true' }
                }] }
    ];
    return ClrDatagridActionBar;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridActionOverflow = /** @class */ (function () {
    function ClrDatagridActionOverflow(rowActionService, commonStrings) {
        this.rowActionService = rowActionService;
        this.commonStrings = commonStrings;
        this.anchorPoint = Point.RIGHT_CENTER;
        this.popoverPoint = Point.LEFT_CENTER;
        /**
         * Tracks whether the action overflow menu is open or not
         */
        this._open = false;
        this.openChanged = new EventEmitter(false);
        this.rowActionService.register();
    }
    /**
     * @return {?}
     */
    ClrDatagridActionOverflow.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.rowActionService.unregister();
    };
    Object.defineProperty(ClrDatagridActionOverflow.prototype, "open", {
        get: /**
         * @return {?}
         */
        function () {
            return this._open;
        },
        set: /**
         * @param {?} open
         * @return {?}
         */
        function (open) {
            /** @type {?} */
            var boolOpen = !!open;
            if (boolOpen !== this._open) {
                this._open = boolOpen;
                this.openChanged.emit(boolOpen);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows/hides the action overflow menu
     */
    /**
     * Shows/hides the action overflow menu
     * @param {?} event
     * @return {?}
     */
    ClrDatagridActionOverflow.prototype.toggle = /**
     * Shows/hides the action overflow menu
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.openingEvent = event;
        this.open = !this.open;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ClrDatagridActionOverflow.prototype.close = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /*
             * Because this listener is added synchonously, before the event finishes bubbling up the DOM,
             * we end up firing on the very click that just opened the menu, p
             * otentially closing it immediately every time. So we just ignore it.
             */
        if (event === this.openingEvent) {
            delete this.openingEvent;
            return;
        }
        this.open = false;
    };
    ClrDatagridActionOverflow.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-action-overflow',
                    template: "\n        <button (click)=\"toggle($event)\" type=\"button\" class=\"datagrid-action-toggle\" #anchor>\n            <clr-icon shape=\"ellipsis-vertical\" [attr.title]=\"commonStrings.rowActions\"></clr-icon>\n        </button>\n        <ng-template [(clrPopoverOld)]=\"open\" [clrPopoverOldAnchor]=\"anchor\" [clrPopoverOldAnchorPoint]=\"anchorPoint\"\n                     [clrPopoverOldPopoverPoint]=\"popoverPoint\">\n            <div #menu class=\"datagrid-action-overflow\" (clrOutsideClick)=\"close($event)\" [clrStrict]=\"true\">\n                <ng-content></ng-content>\n            </div>\n        </ng-template>\n    "
                }] }
    ];
    /** @nocollapse */
    ClrDatagridActionOverflow.ctorParameters = function () { return [
        { type: RowActionService },
        { type: ClrCommonStrings }
    ]; };
    ClrDatagridActionOverflow.propDecorators = {
        open: [{ type: Input, args: ['clrDgActionOverflowOpen',] }],
        openChanged: [{ type: Output, args: ['clrDgActionOverflowOpenChange',] }]
    };
    return ClrDatagridActionOverflow;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var MIN_COLUMN_WIDTH = 96;
// This service allows DatagridHeaderRenderer and ClrDatagridColumnSeparator
// to share column resize data with each other.
var ColumnResizerService = /** @class */ (function () {
    function ColumnResizerService(el, domAdapter, organizer) {
        this.el = el;
        this.domAdapter = domAdapter;
        this.organizer = organizer;
        this._resizedBy = 0;
    }
    Object.defineProperty(ColumnResizerService.prototype, "resizedBy", {
        get: /**
         * @return {?}
         */
        function () {
            return this._resizedBy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnResizerService.prototype, "minColumnWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.domAdapter.minWidth(this.el.nativeElement) || MIN_COLUMN_WIDTH;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnResizerService.prototype, "maxResizeRange", {
        get: /**
         * @return {?}
         */
        function () {
            return this.widthBeforeResize - this.minColumnWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ColumnResizerService.prototype.startResize = /**
     * @return {?}
     */
    function () {
        this._resizedBy = 0;
        this.isWithinMaxResizeRange = true;
        this.widthBeforeResize = this.domAdapter.clientRect(this.el.nativeElement).width;
    };
    /**
     * @return {?}
     */
    ColumnResizerService.prototype.endResize = /**
     * @return {?}
     */
    function () {
        this.organizer.resize();
    };
    Object.defineProperty(ColumnResizerService.prototype, "widthAfterResize", {
        get: /**
         * @return {?}
         */
        function () {
            return this.widthBeforeResize + this._resizedBy;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    ColumnResizerService.prototype.calculateResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var moveX = event.dragPosition.moveX;
        // returns the resize amount within the allowed range
        if (moveX < -this.maxResizeRange) {
            this._resizedBy = -this.maxResizeRange;
            this.isWithinMaxResizeRange = false;
        }
        else {
            this._resizedBy = moveX;
            this.isWithinMaxResizeRange = true;
        }
    };
    ColumnResizerService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ColumnResizerService.ctorParameters = function () { return [
        { type: ElementRef },
        { type: DomAdapter },
        { type: DatagridRenderOrganizer }
    ]; };
    return ColumnResizerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var NB_INSTANCES = 0;
/** @type {?} */
var UNIQUE_ID = new InjectionToken('UNIQUE_ID');
/**
 * @return {?}
 */
function uniqueIdFactory() {
    return 'clr-id-' + NB_INSTANCES++;
}
/** @type {?} */
var UNIQUE_ID_PROVIDER = {
    provide: UNIQUE_ID,
    useFactory: uniqueIdFactory,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridColumnSeparator = /** @class */ (function () {
    // Every column draggable separator should have its own unique ID
    // in order to not conflict with other draggables/droppables.
    function ClrDatagridColumnSeparator(columnResizerService, renderer, tableSizeService, document, columnSeparatorId) {
        this.columnResizerService = columnResizerService;
        this.renderer = renderer;
        this.tableSizeService = tableSizeService;
        this.document = document;
        this.columnSeparatorId = columnSeparatorId;
    }
    /**
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    ClrDatagridColumnSeparator.prototype.showTracker = /**
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    function (resizeTrackerEl) {
        this.columnResizerService.startResize();
        /** @type {?} */
        var tableHeight = this.tableSizeService.getColumnDragHeight();
        this.renderer.setStyle(resizeTrackerEl, 'height', tableHeight);
        this.renderer.setStyle(resizeTrackerEl, 'display', 'block');
    };
    /**
     * @param {?} event
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    ClrDatagridColumnSeparator.prototype.moveTracker = /**
     * @param {?} event
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    function (event, resizeTrackerEl) {
        this.columnResizerService.calculateResize(event);
        this.renderer.setStyle(resizeTrackerEl, 'transform', "translateX(" + this.columnResizerService.resizedBy + "px)");
        this.renderer.setStyle(this.document.body, 'cursor', 'col-resize');
        this.redFlagTracker(resizeTrackerEl);
    };
    /**
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    ClrDatagridColumnSeparator.prototype.hideTracker = /**
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    function (resizeTrackerEl) {
        this.columnResizerService.endResize();
        this.renderer.setStyle(resizeTrackerEl, 'display', 'none');
        this.renderer.setStyle(resizeTrackerEl, 'transform', "translateX(0px)");
        this.renderer.setStyle(this.document.body, 'cursor', 'auto');
    };
    /**
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    ClrDatagridColumnSeparator.prototype.redFlagTracker = /**
     * @param {?} resizeTrackerEl
     * @return {?}
     */
    function (resizeTrackerEl) {
        /** @type {?} */
        var isWithinMaxResizeRange;
        // @TODO(JEREMY) Review this, it will always be true because above is always null
        if (isWithinMaxResizeRange !== this.columnResizerService.isWithinMaxResizeRange) {
            isWithinMaxResizeRange = this.columnResizerService.isWithinMaxResizeRange;
            if (!isWithinMaxResizeRange) {
                this.renderer.addClass(resizeTrackerEl, 'exceeded-max');
            }
            else {
                this.renderer.removeClass(resizeTrackerEl, 'exceeded-max');
            }
        }
    };
    ClrDatagridColumnSeparator.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-column-separator',
                    template: "\n    <div class=\"datagrid-column-handle\" aria-hidden=\"true\"\n      clrDraggable \n      [clrGroup]=\"columnSeparatorId\" \n      (clrDragStart)=\"showTracker(resizeTrackerEl)\" \n      (clrDragMove)=\"moveTracker($event, resizeTrackerEl)\" \n      (clrDragEnd)=\"hideTracker(resizeTrackerEl)\"></div>\n    <div class=\"datagrid-column-resize-tracker\" #resizeTrackerEl></div>\n    ",
                    host: {
                        '[class.datagrid-column-separator]': 'true',
                    },
                    providers: [UNIQUE_ID_PROVIDER]
                }] }
    ];
    /** @nocollapse */
    ClrDatagridColumnSeparator.ctorParameters = function () { return [
        { type: ColumnResizerService },
        { type: Renderer2 },
        { type: TableSizeService },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] }
    ]; };
    return ClrDatagridColumnSeparator;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridColumnToggleButton = /** @class */ (function () {
    function ClrDatagridColumnToggleButton(toggleButtons) {
        this.toggleButtons = toggleButtons;
    }
    ClrDatagridColumnToggleButton.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-column-toggle-button',
                    template: "\n        <button class=\"btn btn-sm btn-link\"\n            (click)=\"toggleButtons.buttonClicked()\"\n            [disabled]=\"toggleButtons.selectAllDisabled\"\n            type=\"button\">\n            <ng-content></ng-content>\n        </button>\n    "
                }] }
    ];
    /** @nocollapse */
    ClrDatagridColumnToggleButton.ctorParameters = function () { return [
        { type: ColumnToggleButtonsService }
    ]; };
    return ClrDatagridColumnToggleButton;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridColumnToggleTitle = /** @class */ (function () {
    function ClrDatagridColumnToggleTitle() {
    }
    ClrDatagridColumnToggleTitle.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-column-toggle-title',
                    template: "<ng-content></ng-content>"
                }] }
    ];
    return ClrDatagridColumnToggleTitle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridColumnToggle = /** @class */ (function () {
    function ClrDatagridColumnToggle(hideableColumnService, columnToggleButtons, commonStrings) {
        this.hideableColumnService = hideableColumnService;
        this.columnToggleButtons = columnToggleButtons;
        this.commonStrings = commonStrings;
        this.subscriptions = [];
        /**
         *
         * Popover init
         */
        this.anchorPoint = Point.TOP_LEFT;
        this.popoverPoint = Point.LEFT_BOTTOM;
        this.open = false;
        /**
         * *
         * DatagridHideableColumnModel init
         */
        this.columns = [];
    }
    Object.defineProperty(ClrDatagridColumnToggle.prototype, "allColumnsVisible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._allColumnsVisible;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._allColumnsVisible = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDatagridColumnToggle.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
            // Reset the list of columns
            _this.columns.length = 0;
            _this.hideableColumnService.updateForLastVisibleColumn();
            _this.allColumnsVisible = _this.hideableColumnService.checkForAllColumnsVisible;
            _this.columnToggleButtons.selectAllDisabled = _this.allColumnsVisible;
            // Add only the hidden columns to the toggler.
            columnList.forEach(function (col) {
                if (col) {
                    _this.columns.push(col);
                }
            });
        }));
        this.subscriptions.push(this.columnToggleButtons.selectAllButtonClicked.subscribe(function () {
            _this.selectAll();
        }));
    };
    /**
     * @return {?}
     */
    ClrDatagridColumnToggle.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * @return {?}
     */
    ClrDatagridColumnToggle.prototype.selectAll = /**
     * @return {?}
     */
    function () {
        this.hideableColumnService.showHiddenColumns();
        this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
        this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
    };
    /**
     * @param {?} event
     * @param {?} column
     * @return {?}
     */
    ClrDatagridColumnToggle.prototype.toggleColumn = /**
     * @param {?} event
     * @param {?} column
     * @return {?}
     */
    function (event, column) {
        column.hidden = !event;
        this.allColumnsVisible = this.hideableColumnService.checkForAllColumnsVisible;
        this.columnToggleButtons.selectAllDisabled = this.allColumnsVisible;
        this.hideableColumnService.updateForLastVisibleColumn();
    };
    /**
     * @return {?}
     */
    ClrDatagridColumnToggle.prototype.toggleUI = /**
     * @return {?}
     */
    function () {
        this.open = !this.open;
    };
    ClrDatagridColumnToggle.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-column-toggle',
                    template: "\n        <button\n                #anchor\n                (click)=\"toggleUI()\"\n                class=\"btn btn-sm btn-link column-toggle--action\"\n                type=\"button\">\n            <clr-icon shape=\"view-columns\" [attr.title]=\"commonStrings.pickColumns\"></clr-icon>\n        </button>\n        <div class=\"column-switch\"\n             *clrPopoverOld=\"open; anchor: anchor; anchorPoint: anchorPoint; popoverPoint: popoverPoint\">\n            <div class=\"switch-header\">\n                <ng-container *ngIf=\"!title\">Show Columns</ng-container>\n                <ng-content select=\"clr-dg-column-toggle-title\"></ng-content>\n                <button\n                    class=\"btn btn-sm btn-link\"\n                    (click)=\"toggleUI()\"\n                    type=\"button\">\n                    <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n                </button>\n            </div>\n            <ul class=\"switch-content list-unstyled\">\n                <li *ngFor=\"let column of columns\">\n                    <clr-checkbox-wrapper>\n                        <input clrCheckbox type=\"checkbox\"\n                          [disabled]=\"column.lastVisibleColumn\"\n                          [ngModel]=\"!column.hidden\"\n                          (ngModelChange)=\"toggleColumn($event, column)\">\n                        <label><ng-template [ngTemplateOutlet]=\"column.template\"></ng-template></label>\n                    </clr-checkbox-wrapper>\n                </li>\n            </ul>\n            <div class=\"switch-footer\" *ngIf=\"buttons.length > 0\">\n                <ng-content select=\"clr-dg-column-toggle-button\"></ng-content>\n            </div>\n            <div class=\"switch-footer\" *ngIf=\"buttons.length === 0\">\n                <div>\n                    <button\n                            class=\"btn btn-sm btn-link p6 text-uppercase\"\n                            [disabled]=\"allColumnsVisible\"\n                            (click)=\"selectAll()\"\n                            type=\"button\">Select All\n                    </button>\n                </div>\n            </div>\n        </div>\n    ",
                    host: { '[class.column-switch-wrapper]': 'true', '[class.active]': 'open' }
                }] }
    ];
    /** @nocollapse */
    ClrDatagridColumnToggle.ctorParameters = function () { return [
        { type: HideableColumnService },
        { type: ColumnToggleButtonsService },
        { type: ClrCommonStrings }
    ]; };
    ClrDatagridColumnToggle.propDecorators = {
        title: [{ type: ContentChild, args: [ClrDatagridColumnToggleTitle,] }],
        buttons: [{ type: ContentChildren, args: [ClrDatagridColumnToggleButton,] }]
    };
    return ClrDatagridColumnToggle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * I don't think this deserves to be in IfExpanded itself,
 * so I'm adding a second directive on the same selector for now just for the datagrid
 */
var DatagridDetailRegisterer = /** @class */ (function () {
    function DatagridDetailRegisterer(expandableRowsCount) {
        this.expandableRowsCount = expandableRowsCount;
        if (this.expandableRowsCount) {
            this.expandableRowsCount.register();
        }
    }
    /**
     * @return {?}
     */
    DatagridDetailRegisterer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.expandableRowsCount) {
            this.expandableRowsCount.unregister();
        }
    };
    DatagridDetailRegisterer.decorators = [
        { type: Directive, args: [{ selector: '[clrIfExpanded]' },] }
    ];
    /** @nocollapse */
    DatagridDetailRegisterer.ctorParameters = function () { return [
        { type: ExpandableRowsCount, decorators: [{ type: Optional }] }
    ]; };
    return DatagridDetailRegisterer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDatagridFooter = /** @class */ (function () {
    function ClrDatagridFooter(selection, hideableColumnService, cdr) {
        this.selection = selection;
        this.hideableColumnService = hideableColumnService;
        this.cdr = cdr;
        this.subscriptions = [];
        /* reference to the enum so that template can access */
        this.SELECTION_TYPE = SelectionType;
    }
    /**
     * @return {?}
     */
    ClrDatagridFooter.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (change) {
            /** @type {?} */
            var hiddenColumnsInSub = change.filter(function (col) { return col; });
            if (hiddenColumnsInSub.length > 0) {
                _this.activeToggler = true;
            }
        }));
        /** @type {?} */
        var hiddenColumns = this.hideableColumnService.getColumns().filter(function (col) { return col; });
        if (hiddenColumns.length > 0) {
            this.activeToggler = true;
        }
    };
    /**
     * @return {?}
     */
    ClrDatagridFooter.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) {
            sub.unsubscribe();
        });
    };
    ClrDatagridFooter.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-footer',
                    template: "\n        <ng-container\n            *ngIf=\"(selection.selectionType === SELECTION_TYPE.Multi) && (selection.current.length > 0)\">\n          <div class=\"clr-form-control-disabled\">\n              <clr-checkbox-wrapper class=\"datagrid-footer-select\">\n                <input clrCheckbox type=\"checkbox\" checked=\"checked\" disabled>\n                <label>{{selection.current.length}}</label>\n            </clr-checkbox-wrapper>\n          </div>\n        </ng-container>\n        <ng-content select=\"clr-dg-column-toggle\"></ng-content>\n        <clr-dg-column-toggle *ngIf=\"!toggle && activeToggler\"></clr-dg-column-toggle>\n        <div class=\"datagrid-footer-description\">\n            <ng-content></ng-content>\n        </div>\n        <ng-content select=\"clr-dg-pagination\"></ng-content>\n    ",
                    host: {
                        '[class.datagrid-footer]': 'true',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrDatagridFooter.ctorParameters = function () { return [
        { type: Selection },
        { type: HideableColumnService },
        { type: ChangeDetectorRef }
    ]; };
    ClrDatagridFooter.propDecorators = {
        toggle: [{ type: ContentChild, args: [ClrDatagridColumnToggle,] }]
    };
    return ClrDatagridFooter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * \@description
 * A utility class for that adds hide/show functionality to a column, its cells and enables a toggler in the
 * DatagridColumnToggle Component.
 *
 */
var /**
 *
 * \@description
 * A utility class for that adds hide/show functionality to a column, its cells and enables a toggler in the
 * DatagridColumnToggle Component.
 *
 */
DatagridHideableColumnModel = /** @class */ (function () {
    /**
     *
     * @description
     * The init function for DatagridHideableColumnModel instances that does the following:
     *
     * 1. Set values for the private variables that enable a hideable column
     * 2. Broadcast the next hidden change for anyone (already) subscribed to this DatagridHideableColumnModel
     *
     */
    function DatagridHideableColumnModel(_template, _id, _hidden) {
        if (_hidden === void 0) { _hidden = false; }
        this._template = _template;
        this._id = _id;
        this._hidden = _hidden;
        /**
         * \@property hiddenChanges
         *
         * \@description
         * A stream of state changes an instance of DatagridHideableColumnModel will broadcast to subscribers.
         *
         */
        this.hiddenChangesState = new Subject();
        // Flag this true when the service only has one visible column open.
        this.lastVisibleColumn = false;
    }
    Object.defineProperty(DatagridHideableColumnModel.prototype, "template", {
        /**
         *
         * @description
         * A getter function that returns an TemplateRef of the DatagridColumn that is hideable. This is currently used to
         * populate the DatagridColumnToggle UI with the correct Column name.
         *
         */
        get: /**
         *
         * \@description
         * A getter function that returns an TemplateRef of the DatagridColumn that is hideable. This is currently used to
         * populate the DatagridColumnToggle UI with the correct Column name.
         *
         * @return {?}
         */
        function () {
            return this._template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridHideableColumnModel.prototype, "id", {
        /**
         *
         * @description
         * public function that returns the id of a HideableCOlumn instance. Used by the HideableCOlumnService for passing
         * state and actions between DateGridColumns, DataGridCells & the DatagridColumnToggle Components.
         *
         */
        get: /**
         *
         * \@description
         * public function that returns the id of a HideableCOlumn instance. Used by the HideableCOlumnService for passing
         * state and actions between DateGridColumns, DataGridCells & the DatagridColumnToggle Components.
         *
         * @return {?}
         */
        function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridHideableColumnModel.prototype, "hidden", {
        /**
         *
         * @description
         * A getter that returns the hidden value of a DatagridHideableColumnModel instance.
         *
         */
        get: /**
         *
         * \@description
         * A getter that returns the hidden value of a DatagridHideableColumnModel instance.
         *
         * @return {?}
         */
        function () {
            return this._hidden;
        },
        /**
         *
         * @description
         * The setter for setting the hidden state of a DatagridHideableColumnModel instance.
         * It also broadcasts the change after its set.
         *
         */
        set: /**
         *
         * \@description
         * The setter for setting the hidden state of a DatagridHideableColumnModel instance.
         * It also broadcasts the change after its set.
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._hidden === value) {
                return;
            }
            this._hidden = value;
            this.hiddenChangesState.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DatagridHideableColumnModel.prototype, "hiddenChangeState", {
        /**
         *
         * @description
         * An Observable for the HideableColumns hidden changes.
         *
         */
        get: /**
         *
         * \@description
         * An Observable for the HideableColumns hidden changes.
         *
         * @return {?}
         */
        function () {
            return this.hiddenChangesState.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    return DatagridHideableColumnModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridHideableColumn = /** @class */ (function () {
    /**
     * @description
     * Used the DatagridColumn to get and set an id for this HiddenColumn
     *
     */
    function ClrDatagridHideableColumn(templateRef, viewContainerRef, dgColumn) {
        var _this = this;
        this.templateRef = templateRef;
        this.viewContainerRef = viewContainerRef;
        this.dgColumn = dgColumn;
        this.hiddenChange = new EventEmitter();
        this.columnId = dgColumn.columnId;
        // Use the templateRef to create this view
        this.viewContainerRef.createEmbeddedView(this.templateRef);
        // Create instance of the utility class DatagridHideableColumn.
        // Note this is on the parent instance of DatagridColumn.
        this.dgColumn.hideable = new DatagridHideableColumnModel(this.templateRef, this.columnId, this._hidden);
        this.dgColumn.hideable.hiddenChangeState.subscribe(function (state$$1) { return _this.hiddenChange.emit(state$$1); });
    }
    Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHideableColumn", {
        /**
         *
         * @description
         * Setter fn for the @Input with the same name as this structural directive.
         * It allows the user to pre-configure the column's hide/show state. { hidden: true }
         * It's more verbose but has more Clarity.
         *
         *
         * @example
         * *clrDgHideableColumn
         * *clrDgHideableColumn={hidden: false}
         * *clrDgHideableColumn={hidden: true}
         *
         */
        set: /**
         *
         * \@description
         * Setter fn for the \@Input with the same name as this structural directive.
         * It allows the user to pre-configure the column's hide/show state. { hidden: true }
         * It's more verbose but has more Clarity.
         *
         *
         * \@example
         * *clrDgHideableColumn
         * *clrDgHideableColumn={hidden: false}
         * *clrDgHideableColumn={hidden: true}
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.clrDgHidden = value && value.hidden ? value.hidden : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridHideableColumn.prototype, "clrDgHidden", {
        set: /**
         * @param {?} hidden
         * @return {?}
         */
        function (hidden) {
            this._hidden = hidden ? hidden : false;
            if (this.dgColumn.hideable) {
                this.dgColumn.hideable.hidden = this._hidden;
            }
        },
        enumerable: true,
        configurable: true
    });
    ClrDatagridHideableColumn.decorators = [
        { type: Directive, args: [{ selector: '[clrDgHideableColumn]' },] }
    ];
    /** @nocollapse */
    ClrDatagridHideableColumn.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: ViewContainerRef },
        { type: ClrDatagridColumn }
    ]; };
    ClrDatagridHideableColumn.propDecorators = {
        clrDgHideableColumn: [{ type: Input, args: ['clrDgHideableColumn',] }],
        clrDgHidden: [{ type: Input, args: ['clrDgHidden',] }],
        hiddenChange: [{ type: Output, args: ['clrDgHiddenChange',] }]
    };
    return ClrDatagridHideableColumn;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrDatagridItemsTrackBy = /** @class */ (function () {
    function ClrDatagridItemsTrackBy(_items) {
        this._items = _items;
    }
    Object.defineProperty(ClrDatagridItemsTrackBy.prototype, "trackBy", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._items) {
                this._items.trackBy = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    ClrDatagridItemsTrackBy.decorators = [
        { type: Directive, args: [{
                    selector: '[ngForTrackBy]',
                },] }
    ];
    /** @nocollapse */
    ClrDatagridItemsTrackBy.ctorParameters = function () { return [
        { type: Items, decorators: [{ type: Optional }] }
    ]; };
    ClrDatagridItemsTrackBy.propDecorators = {
        trackBy: [{ type: Input, args: ['ngForTrackBy',] }]
    };
    return ClrDatagridItemsTrackBy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridPageSize = /** @class */ (function () {
    function ClrDatagridPageSize(page) {
        this.page = page;
    }
    /**
     * @return {?}
     */
    ClrDatagridPageSize.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.pageSizeOptions || this.pageSizeOptions.length === 0) {
            this.pageSizeOptions = [this.page.size];
        }
    };
    ClrDatagridPageSize.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-page-size',
                    template: "\n    <ng-content></ng-content>\n    <div class=\"clr-select-wrapper\">\n      <select [class.clr-page-size-select]=\"true\" [(ngModel)]=\"page.size\">\n        <option *ngFor=\"let option of pageSizeOptions\" [ngValue]=\"option\">{{option}}</option>\n      </select>\n    </div>\n  "
                }] }
    ];
    /** @nocollapse */
    ClrDatagridPageSize.ctorParameters = function () { return [
        { type: Page }
    ]; };
    ClrDatagridPageSize.propDecorators = {
        pageSizeOptions: [{ type: Input, args: ['clrPageSizeOptions',] }]
    };
    return ClrDatagridPageSize;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDatagridPagination = /** @class */ (function () {
    function ClrDatagridPagination(page) {
        this.page = page;
        this.currentChanged = new EventEmitter(false);
        this.page.activated = true;
    }
    /**********
     * Subscription to the Page service for page changes.
     * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
     */
    /**
     * *******
     * Subscription to the Page service for page changes.
     * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
     * @return {?}
     */
    ClrDatagridPagination.prototype.ngOnInit = /**
     * *******
     * Subscription to the Page service for page changes.
     * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
     * @return {?}
     */
    function () {
        var _this = this;
        /*
         * Default page size is 10.
         * The reason we set it here and not in the provider itself is because
         * we don't want pagination if this component isn't present in the datagrid.
         */
        if (!this.page.size) {
            this.page.size = 10;
        }
        this._pageSubscription = this.page.change.subscribe(function (current) { return _this.currentChanged.emit(current); });
    };
    /**
     * @return {?}
     */
    ClrDatagridPagination.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.page.resetPageSize();
        if (this._pageSubscription) {
            this._pageSubscription.unsubscribe();
        }
    };
    Object.defineProperty(ClrDatagridPagination.prototype, "pageSize", {
        /**
         * Page size
         */
        get: /**
         * Page size
         * @return {?}
         */
        function () {
            return this.page.size;
        },
        set: /**
         * @param {?} size
         * @return {?}
         */
        function (size) {
            if (typeof size === 'number') {
                this.page.size = size;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridPagination.prototype, "totalItems", {
        /**
         * Total items (needed to guess the last page)
         */
        get: /**
         * Total items (needed to guess the last page)
         * @return {?}
         */
        function () {
            return this.page.totalItems;
        },
        set: /**
         * @param {?} total
         * @return {?}
         */
        function (total) {
            if (typeof total === 'number') {
                this.page.totalItems = total;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridPagination.prototype, "lastPage", {
        /**
         * Last page
         */
        get: /**
         * Last page
         * @return {?}
         */
        function () {
            return this.page.last;
        },
        set: /**
         * @param {?} last
         * @return {?}
         */
        function (last) {
            if (typeof last === 'number') {
                this.page.last = last;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridPagination.prototype, "currentPage", {
        /**
         * Current page
         */
        get: /**
         * Current page
         * @return {?}
         */
        function () {
            return this.page.current;
        },
        set: /**
         * @param {?} page
         * @return {?}
         */
        function (page) {
            if (typeof page === 'number') {
                this.page.current = page;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Moves to the previous page if it exists
     */
    /**
     * Moves to the previous page if it exists
     * @return {?}
     */
    ClrDatagridPagination.prototype.previous = /**
     * Moves to the previous page if it exists
     * @return {?}
     */
    function () {
        this.page.previous();
    };
    /**
     * Moves to the next page if it exists
     */
    /**
     * Moves to the next page if it exists
     * @return {?}
     */
    ClrDatagridPagination.prototype.next = /**
     * Moves to the next page if it exists
     * @return {?}
     */
    function () {
        this.page.next();
    };
    Object.defineProperty(ClrDatagridPagination.prototype, "firstItem", {
        /**
         * Index of the first item displayed on the current page, starting at 0
         */
        get: /**
         * Index of the first item displayed on the current page, starting at 0
         * @return {?}
         */
        function () {
            return this.page.firstItem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridPagination.prototype, "lastItem", {
        /**
         * Index of the last item displayed on the current page, starting at 0
         */
        get: /**
         * Index of the last item displayed on the current page, starting at 0
         * @return {?}
         */
        function () {
            return this.page.lastItem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrDatagridPagination.prototype, "middlePages", {
        /**
         * Conditionally adds page numbers before and after the current page
         */
        get: /**
         * Conditionally adds page numbers before and after the current page
         * @return {?}
         */
        function () {
            /** @type {?} */
            var middlePages = [];
            if (this.page.current > 1) {
                middlePages.push(this.page.current - 1);
            }
            middlePages.push(this.page.current);
            if (this.page.current < this.page.last) {
                middlePages.push(this.page.current + 1);
            }
            return middlePages;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * We only update the pagination's current page on blur of the input field, or
     * when they press enter.
     */
    /**
     * We only update the pagination's current page on blur of the input field, or
     * when they press enter.
     * @param {?} event
     * @return {?}
     */
    ClrDatagridPagination.prototype.updateCurrentPage = /**
     * We only update the pagination's current page on blur of the input field, or
     * when they press enter.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var parsed = parseInt(event.target.value, 10);
        // if the input value, is not a number, we don't update the page
        if (!isNaN(parsed)) {
            if (parsed < 1) {
                this.page.current = 1;
            }
            else if (parsed > this.page.last) {
                this.page.current = this.page.last;
            }
            else {
                this.page.current = parsed;
            }
        }
        /**
         * Set the input's value to the new current page. This is needed because the code
         * above may have changed the value from what the user entered in.
         */
        this.currentPageInputRef.nativeElement.value = this.page.current;
    };
    ClrDatagridPagination.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-pagination',
                    template: "\n    <div class=\"pagination-size\" *ngIf=\"_pageSizeComponent\">\n      <ng-content select=\"clr-dg-page-size\"></ng-content>\n    </div>\n    <div class=\"pagination-description\">\n      <ng-content></ng-content>\n    </div>\n    <div class=\"pagination-list\" *ngIf=\"page.last > 1\">\n      <button type=\"button\" class=\"pagination-first\" [disabled]=\"page.current <= 1\" (click)=\"page.current = 1\">\n        <clr-icon shape=\"step-forward-2 down\"></clr-icon>\n      </button>\n      <button type=\"button\" class=\"pagination-previous\" [disabled]=\"page.current <= 1\" (click)=\"page.current = page.current - 1\">\n        <clr-icon shape=\"angle left\"></clr-icon>\n      </button>\n      <input #currentPageInput type=\"text\" class=\"pagination-current\" [size]=\"page.last.toString().length\" [value]=\"page.current\"\n             (keydown.enter)=\"updateCurrentPage($event)\" (blur)=\"updateCurrentPage($event)\"/>&nbsp;/&nbsp;<span>{{page.last}}</span>\n      <button type=\"button\" class=\"pagination-next\" [disabled]=\"page.current >= page.last\" (click)=\"page.current = page.current + 1\">\n        <clr-icon shape=\"angle right\"></clr-icon>\n      </button>\n      <button type=\"button\" class=\"pagination-last\" [disabled]=\"page.current >= page.last\" (click)=\"page.current = page.last\">\n        <clr-icon shape=\"step-forward-2 up\"></clr-icon>\n      </button>\n    </div>\n    ",
                    host: { '[class.pagination]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrDatagridPagination.ctorParameters = function () { return [
        { type: Page }
    ]; };
    ClrDatagridPagination.propDecorators = {
        _pageSizeComponent: [{ type: ContentChild, args: [ClrDatagridPageSize,] }],
        currentPageInputRef: [{ type: ViewChild, args: ['currentPageInput',] }],
        pageSize: [{ type: Input, args: ['clrDgPageSize',] }],
        totalItems: [{ type: Input, args: ['clrDgTotalItems',] }],
        lastPage: [{ type: Input, args: ['clrDgLastPage',] }],
        currentPage: [{ type: Input, args: ['clrDgPage',] }],
        currentChanged: [{ type: Output, args: ['clrDgPageChange',] }]
    };
    return ClrDatagridPagination;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Generic bland container serving various purposes for Datagrid.
 * For instance, it can help span a text over multiple rows in detail view.
 * @template T
 */
var ClrDatagridRowDetail = /** @class */ (function () {
    function ClrDatagridRowDetail(selection, rowActionService, expand, hideableColumnService, expandableRows) {
        this.selection = selection;
        this.rowActionService = rowActionService;
        this.expand = expand;
        this.hideableColumnService = hideableColumnService;
        this.expandableRows = expandableRows;
        /* reference to the enum so that template can access it */
        this.SELECTION_TYPE = SelectionType;
        this.subscriptions = [];
        this.replacedRow = false;
    }
    Object.defineProperty(ClrDatagridRowDetail.prototype, "replace", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.expand.setReplace(!!value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrDatagridRowDetail.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var columnsList = this.hideableColumnService.getColumns();
        this.updateCellsForColumns(columnsList);
        // Triggered when the Cells list changes per row-renderer
        this.subscriptions.push(this.cells.changes.subscribe(function (cellList) {
            /** @type {?} */
            var columnList = _this.hideableColumnService.getColumns();
            if (cellList.length === columnList.length) {
                _this.updateCellsForColumns(columnList);
            }
        }));
        // Used to set things up the first time but only after all the columns are ready.
        this.subscriptions.push(this.hideableColumnService.columnListChange.subscribe(function (columnList) {
            // Prevents cell updates when cols and cells array are not aligned
            if (columnList.length === _this.cells.length) {
                _this.updateCellsForColumns(columnList);
            }
        }));
        this.subscriptions.push(this.expand.replace.subscribe(function (replaceChange) {
            _this.replacedRow = replaceChange;
        }));
    };
    /**
     * @param {?} columnList
     * @return {?}
     */
    ClrDatagridRowDetail.prototype.updateCellsForColumns = /**
     * @param {?} columnList
     * @return {?}
     */
    function (columnList) {
        this.cells.forEach(function (cell, index) {
            /** @type {?} */
            var currentColumn = columnList[index];
            if (currentColumn) {
                cell.id = currentColumn.id;
            }
        });
    };
    /**
     * @return {?}
     */
    ClrDatagridRowDetail.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrDatagridRowDetail.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dg-row-detail',
                    template: "\n        <ng-container *ngIf=\"!replacedRow\">\n            <!-- space for multiselection state -->\n            <div class=\"datagrid-cell datagrid-select datagrid-fixed-column\"\n                *ngIf=\"selection.selectionType === SELECTION_TYPE.Multi\">\n            </div>\n            <!-- space for single selection state -->\n            <div class=\"datagrid-cell datagrid-select datagrid-fixed-column\"\n                *ngIf=\"selection.selectionType === SELECTION_TYPE.Single\">\n            </div>\n            <!-- space for single row action; only displayType if we have at least one actionable row in datagrid -->\n            <div class=\"datagrid-cell datagrid-row-actions datagrid-fixed-column\"\n                *ngIf=\"rowActionService.hasActionableRow\">\n            </div>\n            <!-- space for expandable caret action; only displayType if we have at least one expandable row in datagrid -->\n            <div *ngIf=\"expandableRows.hasExpandableRow\"\n                        class=\"datagrid-expandable-caret datagrid-fixed-column datagrid-cell\">\n            </div>\n        </ng-container>\n        <ng-content></ng-content>\n    ",
                    host: {
                        '[class.datagrid-row-flex]': 'true',
                        '[class.datagrid-row-detail]': 'true',
                        '[class.datagrid-container]': 'cells.length === 0',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrDatagridRowDetail.ctorParameters = function () { return [
        { type: Selection },
        { type: RowActionService },
        { type: Expand },
        { type: HideableColumnService },
        { type: ExpandableRowsCount }
    ]; };
    ClrDatagridRowDetail.propDecorators = {
        cells: [{ type: ContentChildren, args: [ClrDatagridCell,] }],
        replace: [{ type: Input, args: ['clrDgReplace',] }]
    };
    return ClrDatagridRowDetail;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var STRICT_WIDTH_CLASS = 'datagrid-fixed-width';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
var DatagridColumnChanges = {
    WIDTH: 0,
};
DatagridColumnChanges[DatagridColumnChanges.WIDTH] = 'WIDTH';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DatagridCellRenderer = /** @class */ (function () {
    function DatagridCellRenderer(el, renderer, organizer) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.subscriptions = [];
        this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
    }
    Object.defineProperty(DatagridCellRenderer.prototype, "columnState", {
        // @TODO(JEREMY) Work out how to dedupe some of this code between header and cell renderers
        set: 
        // @TODO(JEREMY) Work out how to dedupe some of this code between header and cell renderers
        /**
         * @param {?} columnState
         * @return {?}
         */
        function (columnState) {
            var _this = this;
            if (this.stateSubscription) {
                this.stateSubscription.unsubscribe();
            }
            this.stateSubscription = columnState.subscribe(function (state$$1) { return _this.stateChanges(state$$1); });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DatagridCellRenderer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        if (this.stateSubscription) {
            this.stateSubscription.unsubscribe();
        }
    };
    /**
     * @param {?} state
     * @return {?}
     */
    DatagridCellRenderer.prototype.stateChanges = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        var _this = this;
        if (state$$1.changes && state$$1.changes.length) {
            state$$1.changes.forEach(function (change) {
                switch (change) {
                    case DatagridColumnChanges.WIDTH:
                        _this.setWidth(state$$1);
                        break;
                    default:
                        break;
                }
            });
        }
    };
    /**
     * @return {?}
     */
    DatagridCellRenderer.prototype.clearWidth = /**
     * @return {?}
     */
    function () {
        this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        this.renderer.setStyle(this.el.nativeElement, 'width', null);
    };
    /**
     * @param {?} state
     * @return {?}
     */
    DatagridCellRenderer.prototype.setWidth = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        if (state$$1.strictWidth) {
            this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        }
        else {
            this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        }
        this.renderer.setStyle(this.el.nativeElement, 'width', state$$1.width + 'px');
    };
    DatagridCellRenderer.decorators = [
        { type: Directive, args: [{ selector: 'clr-dg-cell' },] }
    ];
    /** @nocollapse */
    DatagridCellRenderer.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: DatagridRenderOrganizer }
    ]; };
    return DatagridCellRenderer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DatagridHeaderRenderer = /** @class */ (function () {
    function DatagridHeaderRenderer(el, renderer, organizer, domAdapter, columnResizerService) {
        var _this = this;
        this.el = el;
        this.renderer = renderer;
        this.organizer = organizer;
        this.domAdapter = domAdapter;
        this.columnResizerService = columnResizerService;
        this.resizeEmitter = new EventEmitter();
        /**
         * Indicates if the column has a strict width, so it doesn't shrink or expand based on the content.
         */
        this.widthSet = false;
        this.autoSet = false;
        this.subscriptions = [];
        this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(function () { return _this.clearWidth(); }));
        this.subscriptions.push(this.organizer
            .filterRenderSteps(DatagridRenderStep.DETECT_STRICT_WIDTHS)
            .subscribe(function () { return _this.detectStrictWidth(); }));
    }
    Object.defineProperty(DatagridHeaderRenderer.prototype, "columnState", {
        set: /**
         * @param {?} columnState
         * @return {?}
         */
        function (columnState) {
            var _this = this;
            if (this.stateSubscription) {
                this.stateSubscription.unsubscribe();
            }
            this.stateSubscription = columnState.subscribe(function (state$$1) { return _this.stateChanges(state$$1); });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DatagridHeaderRenderer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        if (this.stateSubscription) {
            this.stateSubscription.unsubscribe();
        }
    };
    /**
     * @param {?} state
     * @return {?}
     */
    DatagridHeaderRenderer.prototype.stateChanges = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        var _this = this;
        if (state$$1.changes && state$$1.changes.length) {
            state$$1.changes.forEach(function (change) {
                switch (change) {
                    case DatagridColumnChanges.WIDTH:
                        _this.setWidth(state$$1);
                        break;
                    default:
                        break;
                }
            });
        }
    };
    /**
     * @return {?}
     */
    DatagridHeaderRenderer.prototype.clearWidth = /**
     * @return {?}
     */
    function () {
        // remove the width only if we set it, and it is not changed by dragging.
        if (this.widthSet && !this.columnResizerService.resizedBy) {
            this.renderer.setStyle(this.el.nativeElement, 'width', null);
        }
        if (this.autoSet) {
            this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
        }
    };
    /**
     * @return {?}
     */
    DatagridHeaderRenderer.prototype.detectStrictWidth = /**
     * @return {?}
     */
    function () {
        if (this.columnResizerService.resizedBy) {
            return this.columnResizerService.widthAfterResize;
        }
        else if (this.autoSet) {
            return 0;
        }
        else {
            return this.domAdapter.userDefinedWidth(this.el.nativeElement);
        }
    };
    /**
     * @param {?} strictWidth
     * @return {?}
     */
    DatagridHeaderRenderer.prototype.computeWidth = /**
     * @param {?} strictWidth
     * @return {?}
     */
    function (strictWidth) {
        /** @type {?} */
        var width = strictWidth;
        if (!width) {
            width = this.domAdapter.scrollWidth(this.el.nativeElement);
        }
        return width;
    };
    /**
     * @return {?}
     */
    DatagridHeaderRenderer.prototype.getColumnWidthState = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var strictWidth = this.detectStrictWidth();
        return {
            width: this.computeWidth(strictWidth),
            strictWidth: strictWidth,
        };
    };
    /**
     * @param {?} state
     * @return {?}
     */
    DatagridHeaderRenderer.prototype.setWidth = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        if (state$$1.strictWidth) {
            if (this.columnResizerService.resizedBy) {
                this.resizeEmitter.emit(state$$1.width);
                this.renderer.setStyle(this.el.nativeElement, 'width', state$$1.width + 'px');
                this.widthSet = false;
            }
            // Don't set width if there is a user-defined one. Just add the strict width class.
            this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
            this.autoSet = false;
        }
        else {
            this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
            this.renderer.setStyle(this.el.nativeElement, 'width', state$$1.width + 'px');
            this.widthSet = true;
            this.autoSet = true;
        }
    };
    DatagridHeaderRenderer.decorators = [
        { type: Directive, args: [{ selector: 'clr-dg-column', providers: [ColumnResizerService] },] }
    ];
    /** @nocollapse */
    DatagridHeaderRenderer.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: DatagridRenderOrganizer },
        { type: DomAdapter },
        { type: ColumnResizerService }
    ]; };
    DatagridHeaderRenderer.propDecorators = {
        resizeEmitter: [{ type: Output, args: ['clrDgColumnResize',] }]
    };
    return DatagridHeaderRenderer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NoopDomAdapter = /** @class */ (function () {
    function NoopDomAdapter() {
    }
    /**
     * @param {?} element
     * @return {?}
     */
    NoopDomAdapter.prototype.userDefinedWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return 0;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NoopDomAdapter.prototype.scrollBarWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return 0;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NoopDomAdapter.prototype.scrollWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return 0;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NoopDomAdapter.prototype.computedHeight = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return 0;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NoopDomAdapter.prototype.clientRect = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0,
            width: 0,
            height: 0,
        };
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NoopDomAdapter.prototype.minWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return 0;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    NoopDomAdapter.prototype.focus = /**
     * @param {?} element
     * @return {?}
     */
    function (element) { };
    NoopDomAdapter.decorators = [
        { type: Injectable }
    ];
    return NoopDomAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var DatagridRowRenderer = /** @class */ (function () {
    function DatagridRowRenderer(columnsService) {
        this.columnsService = columnsService;
    }
    /**
     * @return {?}
     */
    DatagridRowRenderer.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.cells.changes.subscribe(function () {
            _this.setColumnStates();
        });
    };
    /**
     * @return {?}
     */
    DatagridRowRenderer.prototype.setupColumns = /**
     * @return {?}
     */
    function () {
        this.setColumnStates();
    };
    /**
     * @return {?}
     */
    DatagridRowRenderer.prototype.setColumnStates = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.cells.forEach(function (cell, index) {
            if (_this.columnsService.columns[index]) {
                cell.columnState = _this.columnsService.columns[index];
            }
        });
    };
    DatagridRowRenderer.decorators = [
        { type: Directive, args: [{ selector: 'clr-dg-row, clr-dg-row-detail' },] }
    ];
    /** @nocollapse */
    DatagridRowRenderer.ctorParameters = function () { return [
        { type: ColumnsService }
    ]; };
    DatagridRowRenderer.propDecorators = {
        cells: [{ type: ContentChildren, args: [DatagridCellRenderer,] }]
    };
    return DatagridRowRenderer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// Fixes build error
// @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
/** @type {?} */
var domAdapterFactory = function (platformId) {
    if (isPlatformBrowser(platformId)) {
        return new DomAdapter();
    }
    else {
        return new NoopDomAdapter();
    }
};
// Fixes build error
// @dynamic (https://github.com/angular/angular/issues/19698#issuecomment-338340211)
/**
 * @template T
 */
var DatagridMainRenderer = /** @class */ (function () {
    function DatagridMainRenderer(organizer, items, page, domAdapter, el, renderer, tableSizeService, columnsService) {
        var _this = this;
        this.organizer = organizer;
        this.items = items;
        this.page = page;
        this.domAdapter = domAdapter;
        this.el = el;
        this.renderer = renderer;
        this.tableSizeService = tableSizeService;
        this.columnsService = columnsService;
        this._heightSet = false;
        this.subscriptions = [];
        /**
         * Indicates if we want to re-compute columns width. This should only happen:
         * 1) When headers change, with columns being added or removed
         * 2) When rows are lazily loaded for the first time
         */
        this.columnsSizesStable = false;
        this.shouldStabilizeColumns = true;
        this.subscriptions.push(this.organizer
            .filterRenderSteps(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS)
            .subscribe(function () { return _this.computeHeadersWidth(); }));
        this.subscriptions.push(this.page.sizeChange.subscribe(function () {
            if (_this._heightSet) {
                _this.resetDatagridHeight();
            }
        }));
        this.subscriptions.push(this.items.change.subscribe(function () { return (_this.shouldStabilizeColumns = true); }));
    }
    /**
     * @return {?}
     */
    DatagridMainRenderer.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.setupColumns();
        this.subscriptions.push(this.headers.changes.subscribe(function () {
            // TODO: only re-stabilize if a column was added or removed. Reordering is fine.
            // Need to setup columns before stabalizing them
            _this.setupColumns();
            _this.columnsSizesStable = false;
            _this.stabilizeColumns();
        }));
        this.subscriptions.push(this.rows.changes.subscribe(function () {
            _this.rows.forEach(function (row) { return row.setupColumns(); });
        }));
    };
    // Initialize and set Table width for horizontal scrolling here.
    // Initialize and set Table width for horizontal scrolling here.
    /**
     * @return {?}
     */
    DatagridMainRenderer.prototype.ngAfterViewInit = 
    // Initialize and set Table width for horizontal scrolling here.
    /**
     * @return {?}
     */
    function () {
        this.tableSizeService.table = this.el;
    };
    /**
     * @return {?}
     */
    DatagridMainRenderer.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.shouldStabilizeColumns) {
            this.stabilizeColumns();
        }
        if (this.shouldComputeHeight()) {
            setTimeout(function () {
                _this.computeDatagridHeight();
            });
        }
    };
    /**
     * @return {?}
     */
    DatagridMainRenderer.prototype.setupColumns = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.headers.forEach(function (header, index) {
            // We want to get the initial state
            _this.columnsService.columns[index] = new BehaviorSubject(header.getColumnWidthState());
            header.columnState = _this.columnsService.columns[index];
        });
        this.columnsService.columns.splice(this.headers.length); // Trim any old columns
        this.rows.forEach(function (row) { return row.setupColumns(); });
    };
    /**
     * @return {?}
     */
    DatagridMainRenderer.prototype.shouldComputeHeight = /**
     * @return {?}
     */
    function () {
        if (!this._heightSet && this.page.size > 0) {
            if (this.items.displayed.length === this.page.size) {
                return true;
            }
        }
        return false;
    };
    /**
     * Computes the height of the datagrid.
     *
     * NOTE: We had to choose to set the height instead of the min-height because
     * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
     * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
     * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
     *
     * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
     */
    /**
     * Computes the height of the datagrid.
     *
     * NOTE: We had to choose to set the height instead of the min-height because
     * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
     * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
     * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
     *
     * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
     * @return {?}
     */
    DatagridMainRenderer.prototype.computeDatagridHeight = /**
     * Computes the height of the datagrid.
     *
     * NOTE: We had to choose to set the height instead of the min-height because
     * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
     * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
     * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
     *
     * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
     * @return {?}
     */
    function () {
        // IE doesn't return correct value for getComputedStyle(element).getPropertyValue("height")
        /** @type {?} */
        var value = this.domAdapter.clientRect(this.el.nativeElement).height;
        this.renderer.setStyle(this.el.nativeElement, 'height', value + 'px');
        this._heightSet = true;
    };
    /**
     * @return {?}
     */
    DatagridMainRenderer.prototype.resetDatagridHeight = /**
     * @return {?}
     */
    function () {
        this.renderer.setStyle(this.el.nativeElement, 'height', '');
        this._heightSet = false;
    };
    /**
     * @return {?}
     */
    DatagridMainRenderer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    /**
     * Makes each header compute its width.
     */
    /**
     * Makes each header compute its width.
     * @return {?}
     */
    DatagridMainRenderer.prototype.computeHeadersWidth = /**
     * Makes each header compute its width.
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var nbColumns = this.headers.length;
        /** @type {?} */
        var allStrict = true;
        this.headers.forEach(function (header, index) {
            // On the last header column check whether all columns have strict widths.
            // If all columns have strict widths, remove the strict width from the last column and make it the column's
            // minimum width so that when all previous columns shrink, it will get a flexible width and cover the empty
            // gap in the Datagrid.
            /** @type {?} */
            var state$$1 = __assign({ changes: [DatagridColumnChanges.WIDTH] }, header.getColumnWidthState());
            if (!state$$1.strictWidth) {
                allStrict = false;
            }
            if (nbColumns === index + 1 && allStrict) {
                state$$1.strictWidth = 0;
            }
            _this.columnsService.emitStateChange(index, state$$1);
        });
    };
    /**
     * Triggers a whole re-rendring cycle to set column sizes, if needed.
     */
    /**
     * Triggers a whole re-rendring cycle to set column sizes, if needed.
     * @return {?}
     */
    DatagridMainRenderer.prototype.stabilizeColumns = /**
     * Triggers a whole re-rendring cycle to set column sizes, if needed.
     * @return {?}
     */
    function () {
        this.shouldStabilizeColumns = false;
        if (this.columnsSizesStable) {
            // Nothing to do.
            return;
        }
        // Resize when the rows are loaded.
        if (this.items.displayed.length > 0) {
            this.organizer.resize();
            this.columnsSizesStable = true;
        }
    };
    DatagridMainRenderer.decorators = [
        { type: Directive, args: [{
                    selector: 'clr-datagrid',
                    providers: [{ provide: DomAdapter, useFactory: domAdapterFactory, deps: [PLATFORM_ID] }],
                },] }
    ];
    /** @nocollapse */
    DatagridMainRenderer.ctorParameters = function () { return [
        { type: DatagridRenderOrganizer },
        { type: Items },
        { type: Page },
        { type: DomAdapter },
        { type: ElementRef },
        { type: Renderer2 },
        { type: TableSizeService },
        { type: ColumnsService }
    ]; };
    DatagridMainRenderer.propDecorators = {
        headers: [{ type: ContentChildren, args: [DatagridHeaderRenderer,] }],
        rows: [{ type: ContentChildren, args: [DatagridRowRenderer,] }]
    };
    return DatagridMainRenderer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_DATAGRID_DIRECTIVES = [
    // Core
    ClrDatagrid,
    ClrDatagridActionBar,
    ClrDatagridActionOverflow,
    ClrDatagridColumn,
    ClrDatagridColumnSeparator,
    ClrDatagridColumnToggle,
    ClrDatagridHideableColumn,
    ClrDatagridFilter,
    ClrDatagridItems,
    ClrDatagridItemsTrackBy,
    ClrDatagridRow,
    ClrDatagridRowDetail,
    DatagridDetailRegisterer,
    ClrDatagridCell,
    ClrDatagridFooter,
    ClrDatagridPagination,
    ClrDatagridPageSize,
    ClrDatagridPlaceholder,
    ClrDatagridColumnToggleButton,
    ClrDatagridColumnToggleTitle,
    WrappedCell,
    WrappedColumn,
    WrappedRow,
    // Renderers
    DatagridMainRenderer,
    DatagridHeaderRenderer,
    DatagridRowRenderer,
    DatagridCellRenderer,
    // Chocolate
    DatagridWillyWonka,
    ActionableOompaLoompa,
    ExpandableOompaLoompa,
    // Animation hack
    DatagridRowExpandAnimation,
    // Built-in shortcuts
    DatagridStringFilter,
];
var ClrDatagridModule = /** @class */ (function () {
    function ClrDatagridModule() {
    }
    ClrDatagridModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ClrIconModule,
                        ClrFormsModule,
                        FormsModule,
                        ClrCommonPopoverModule,
                        ClrLoadingModule,
                        ClrOutsideClickModule,
                        ClrDragAndDropModule,
                    ],
                    declarations: [CLR_DATAGRID_DIRECTIVES],
                    exports: [CLR_DATAGRID_DIRECTIVES, ClrIfExpandModule],
                    entryComponents: [WrappedCell, WrappedColumn, WrappedRow],
                },] }
    ];
    return ClrDatagridModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrStackBlock = /** @class */ (function () {
    /*
       * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
       * querying for children StackBlocks, but this feature is not available when downgrading
       * the component for Angular 1.
       */
    function ClrStackBlock(parent, commonStrings) {
        this.parent = parent;
        this.commonStrings = commonStrings;
        this.expanded = false;
        this.expandedChange = new EventEmitter(false);
        this.expandable = false;
        this.focused = false;
        this._changedChildren = 0;
        this._fullyInitialized = false;
        this._changed = false;
        if (parent) {
            parent.addChild();
        }
    }
    Object.defineProperty(ClrStackBlock.prototype, "getChangedValue", {
        get: /**
         * @return {?}
         */
        function () {
            return this._changed || (this._changedChildren > 0 && !this.expanded);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrStackBlock.prototype, "setChangedValue", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._changed = value;
            if (this.parent && this._fullyInitialized) {
                if (value) {
                    this.parent._changedChildren++;
                }
                else {
                    this.parent._changedChildren--;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrStackBlock.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // in order to access the parent ClrStackBlock's properties,
        // the child ClrStackBlock  has to be fully initialized at first.
        this._fullyInitialized = true;
    };
    /**
     * @return {?}
     */
    ClrStackBlock.prototype.addChild = /**
     * @return {?}
     */
    function () {
        this.expandable = true;
    };
    /**
     * @return {?}
     */
    ClrStackBlock.prototype.toggleExpand = /**
     * @return {?}
     */
    function () {
        if (this.expandable) {
            this.expanded = !this.expanded;
            this.expandedChange.emit(this.expanded);
        }
    };
    Object.defineProperty(ClrStackBlock.prototype, "caretDirection", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expanded ? 'down' : 'right';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrStackBlock.prototype, "caretTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expanded ? this.commonStrings.collapse : this.commonStrings.expand;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrStackBlock.prototype, "role", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expandable ? 'button' : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrStackBlock.prototype, "tabIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expandable ? '0' : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrStackBlock.prototype, "onStackLabelFocus", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expandable && !this.expanded && this.focused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrStackBlock.prototype, "ariaExpanded", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.expandable) {
                return null;
            }
            else {
                return this.expanded ? 'true' : 'false';
            }
        },
        enumerable: true,
        configurable: true
    });
    ClrStackBlock.decorators = [
        { type: Component, args: [{
                    selector: 'clr-stack-block',
                    template: "\n    <dt class=\"stack-block-label\"\n        (click)=\"toggleExpand()\"\n        (keyup.enter)=\"toggleExpand()\"\n        (keyup.space)=\"toggleExpand()\"\n        (focus)=\"focused = true\"\n        (blur)=\"focused = false\"\n        [attr.role]=\"role\"\n        [attr.tabindex]=\"tabIndex\"\n        [attr.aria-expanded]=\"ariaExpanded\">\n      <clr-icon shape=\"caret\"\n                class=\"stack-block-caret\"\n                *ngIf=\"expandable\"\n                [attr.dir]=\"caretDirection\"\n                [attr.title]=\"caretTitle\"></clr-icon>\n      <ng-content select=\"clr-stack-label\"></ng-content>\n    </dt>\n    <dd class=\"stack-block-content\">\n      <ng-content></ng-content>\n    </dd>\n    <!-- FIXME: remove this string concatenation when boolean states are supported -->\n    <div [@collapse]=\"''+!expanded\" class=\"stack-children\" >\n      <ng-content select=\"clr-stack-block\"></ng-content>\n    </div>\n  ",
                    // Make sure the host has the proper class for styling purposes
                    host: { '[class.stack-block]': 'true' },
                    animations: [
                        trigger('collapse', [
                            state('true', style({ height: 0, display: 'none' })),
                            transition('true => false', [animate('0.2s ease-in-out', style({ height: '*', display: '*' }))]),
                            transition('false => true', [style({ height: '*', display: '*' }), animate('0.2s ease-in-out')]),
                        ]),
                    ],
                    styles: ["\n        :host { display: block; }\n    "]
                }] }
    ];
    /** @nocollapse */
    ClrStackBlock.ctorParameters = function () { return [
        { type: ClrStackBlock, decorators: [{ type: SkipSelf }, { type: Optional }] },
        { type: ClrCommonStrings }
    ]; };
    ClrStackBlock.propDecorators = {
        expanded: [{ type: HostBinding, args: ['class.stack-block-expanded',] }, { type: Input, args: ['clrSbExpanded',] }],
        expandedChange: [{ type: Output, args: ['clrSbExpandedChange',] }],
        expandable: [{ type: HostBinding, args: ['class.stack-block-expandable',] }, { type: Input, args: ['clrSbExpandable',] }],
        getChangedValue: [{ type: HostBinding, args: ['class.stack-block-changed',] }],
        setChangedValue: [{ type: Input, args: ['clrSbNotifyChange',] }],
        onStackLabelFocus: [{ type: HostBinding, args: ['class.on-focus',] }]
    };
    return ClrStackBlock;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrStackView = /** @class */ (function () {
    function ClrStackView() {
        /**
         * Undocumented experimental feature: inline editing.
         */
        this.editable = false;
        this.save = new EventEmitter(false);
        this._editMode = false;
        this.editingChange = new EventEmitter(false);
        /**
         * End of undocumented experimental feature.
         */
    }
    Object.defineProperty(ClrStackView.prototype, "editing", {
        get: /**
         * @return {?}
         */
        function () {
            return this.editable && this._editMode;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.editable) {
                this._editMode = value;
                this.editingChange.emit(value);
                if (!value) {
                    this.save.emit(null);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    ClrStackView.decorators = [
        { type: Component, args: [{
                    selector: 'clr-stack-view',
                    template: "\n        <ng-content select=\"clr-stack-header\"></ng-content>\n        <dl class=\"stack-view\"><ng-content></ng-content></dl>\n    ",
                    styles: ["\n        :host { display: block; }\n    "]
                }] }
    ];
    ClrStackView.propDecorators = {
        save: [{ type: Output, args: ['clrStackSave',] }]
    };
    return ClrStackView;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrStackHeader = /** @class */ (function () {
    function ClrStackHeader(stackView) {
        this.stackView = stackView;
    }
    ClrStackHeader.decorators = [
        { type: Component, args: [{
                    selector: 'clr-stack-header',
                    template: "\n        <h4 class=\"stack-header\">\n            <span class=\"stack-title\"><ng-content></ng-content></span>\n            \n            <span class=\"stack-actions\">\n                <ng-content select=\".stack-action\"></ng-content>\n                <!-- Undocumented experimental feature: inline editing. -->\n                <button *ngIf=\"stackView.editable\" class=\"stack-action btn btn-sm btn-link\" \n                        (click)=\"stackView.editing = !stackView.editing\" type=\"button\">\n                        Edit\n                </button>\n                <!-- End of undocumented experimental feature. -->\n            </span>\n        </h4>\n    ",
                    styles: ["\n        :host { display: block; }\n    "]
                }] }
    ];
    /** @nocollapse */
    ClrStackHeader.ctorParameters = function () { return [
        { type: ClrStackView }
    ]; };
    return ClrStackHeader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var StackControl = /** @class */ (function () {
    function StackControl(stackView) {
        var _this = this;
        this.stackView = stackView;
        this.modelChange = new EventEmitter(false);
        // Make the ClrStackView editable, since it contains a StackControl
        this.stackView.editable = true;
        this.stackView.editingChange.subscribe(function (editing) {
            // Edit mode was closed
            if (!editing) {
                _this.modelChange.emit(_this.model);
            }
        });
    }
    return StackControl;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrStackInput = /** @class */ (function (_super) {
    __extends(ClrStackInput, _super);
    function ClrStackInput(stackView) {
        var _this = _super.call(this, stackView) || this;
        _this.stackView = stackView;
        _this.type = 'text';
        return _this;
    }
    ClrStackInput.decorators = [
        { type: Component, args: [{
                    selector: 'clr-stack-input',
                    inputs: ['model: clrModel', 'type'],
                    outputs: ['modelChange: clrModelChange'],
                    template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <input [type]=\"type\" *ngIf=\"stackView.editing\" [(ngModel)]=\"model\"/>\n    "
                }] }
    ];
    /** @nocollapse */
    ClrStackInput.ctorParameters = function () { return [
        { type: ClrStackView }
    ]; };
    return ClrStackInput;
}(StackControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrStackSelect = /** @class */ (function (_super) {
    __extends(ClrStackSelect, _super);
    function ClrStackSelect(stackView) {
        var _this = _super.call(this, stackView) || this;
        _this.stackView = stackView;
        return _this;
    }
    ClrStackSelect.decorators = [
        { type: Component, args: [{
                    selector: 'clr-stack-select',
                    inputs: ['model: clrModel'],
                    outputs: ['modelChange: clrModelChange'],
                    template: "\n        <span *ngIf=\"!stackView.editing\">{{model}}</span>\n        <div class=\"select\" *ngIf=\"stackView.editing\" >\n            <select [(ngModel)]=\"model\">\n                <ng-content></ng-content>\n            </select>\n        </div>\n    "
                }] }
    ];
    /** @nocollapse */
    ClrStackSelect.ctorParameters = function () { return [
        { type: ClrStackView }
    ]; };
    return ClrStackSelect;
}(StackControl));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrStackViewCustomTags = /** @class */ (function () {
    function ClrStackViewCustomTags() {
    }
    ClrStackViewCustomTags.decorators = [
        { type: Directive, args: [{ selector: 'clr-stack-label, clr-stack-content' },] }
    ];
    return ClrStackViewCustomTags;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_STACK_VIEW_DIRECTIVES = [
    ClrStackView,
    ClrStackHeader,
    ClrStackBlock,
    ClrStackViewCustomTags,
    /**
     * Undocumented experimental feature: inline editing.
     */
    ClrStackInput,
    ClrStackSelect,
];
var ClrStackViewModule = /** @class */ (function () {
    function ClrStackViewModule() {
    }
    ClrStackViewModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, FormsModule, ClrIconModule],
                    declarations: [CLR_STACK_VIEW_DIRECTIVES],
                    exports: [CLR_STACK_VIEW_DIRECTIVES],
                },] }
    ];
    return ClrStackViewModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {number} */
var ClrSelectedState = {
    // WARNING! Unselected has the value 0,
    // so it's actually the only one that will evaluate to false if cast to a boolean.
    // Don't mess with the order!
    UNSELECTED: 0,
    SELECTED: 1,
    INDETERMINATE: 2,
};
ClrSelectedState[ClrSelectedState.UNSELECTED] = 'UNSELECTED';
ClrSelectedState[ClrSelectedState.SELECTED] = 'SELECTED';
ClrSelectedState[ClrSelectedState.INDETERMINATE] = 'INDETERMINATE';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @abstract
 * @template T
 */
var /**
 * @abstract
 * @template T
 */
TreeNodeModel = /** @class */ (function () {
    function TreeNodeModel() {
        this.selected = new BehaviorSubject(ClrSelectedState.UNSELECTED);
        /*
           * Being able to push this down to the RecursiveTreeNodeModel would require too much work on the angular components
           * right now for them to know which kind of model they are using. So I'm lifting the public properties to this
           * abstract parent class for now and we can revisit it later, when we're not facing such a close deadline.
           */
        this.loading = false;
    }
    /**
     * @return {?}
     */
    TreeNodeModel.prototype.destroy = /**
     * @return {?}
     */
    function () {
        // Just to be safe
        this.selected.complete();
    };
    // Propagate by default when eager, don't propagate in the lazy-loaded tree.
    // Propagate by default when eager, don't propagate in the lazy-loaded tree.
    /**
     * @param {?} state
     * @param {?} propagateUp
     * @param {?} propagateDown
     * @return {?}
     */
    TreeNodeModel.prototype.setSelected = 
    // Propagate by default when eager, don't propagate in the lazy-loaded tree.
    /**
     * @param {?} state
     * @param {?} propagateUp
     * @param {?} propagateDown
     * @return {?}
     */
    function (state$$1, propagateUp, propagateDown) {
        if (state$$1 === this.selected.value) {
            return;
        }
        this.selected.next(state$$1);
        if (propagateDown && state$$1 !== ClrSelectedState.INDETERMINATE && this.children) {
            this.children.forEach(function (child) { return child.setSelected(state$$1, false, true); });
        }
        if (propagateUp && this.parent) {
            this.parent._updateSelectionFromChildren();
        }
    };
    /**
     * @param {?} propagate
     * @return {?}
     */
    TreeNodeModel.prototype.toggleSelection = /**
     * @param {?} propagate
     * @return {?}
     */
    function (propagate) {
        // Both unselected and indeterminate toggle to selected
        /** @type {?} */
        var newState = this.selected.value === ClrSelectedState.SELECTED ? ClrSelectedState.UNSELECTED : ClrSelectedState.SELECTED;
        // NOTE: we always propagate selection up in this method because it is only called when the user takes an action.
        // It should never be called from lifecycle hooks or app-provided inputs.
        this.setSelected(newState, true, propagate);
    };
    /**
     * @return {?}
     */
    TreeNodeModel.prototype.computeSelectionStateFromChildren = /**
     * @return {?}
     */
    function () {
        var e_1, _a;
        /** @type {?} */
        var oneSelected = false;
        /** @type {?} */
        var oneUnselected = false;
        try {
            // Using a good old for loop to exit as soon as we can tell, for better performance on large trees.
            for (var _b = __values(this.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                switch (child.selected.value) {
                    case ClrSelectedState.INDETERMINATE:
                        return ClrSelectedState.INDETERMINATE;
                    case ClrSelectedState.SELECTED:
                        oneSelected = true;
                        if (oneUnselected) {
                            return ClrSelectedState.INDETERMINATE;
                        }
                        break;
                    case ClrSelectedState.UNSELECTED:
                    default:
                        // Default is the same as unselected, in case an undefined somehow made it all the way here.
                        oneUnselected = true;
                        if (oneSelected) {
                            return ClrSelectedState.INDETERMINATE;
                        }
                        break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!oneSelected) {
            return ClrSelectedState.UNSELECTED;
        }
        else if (!oneUnselected) {
            return ClrSelectedState.SELECTED;
        }
    };
    /*
     * Internal, but needs to be called by other nodes
     */
    /*
       * Internal, but needs to be called by other nodes
       */
    /**
     * @return {?}
     */
    TreeNodeModel.prototype._updateSelectionFromChildren = /*
       * Internal, but needs to be called by other nodes
       */
    /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var newState = this.computeSelectionStateFromChildren();
        if (newState === this.selected.value) {
            return;
        }
        this.selected.next(newState);
        if (this.parent) {
            this.parent._updateSelectionFromChildren();
        }
    };
    return TreeNodeModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * A declarative model is built by traversing the Angular component tree.
 * Declarative = Tree node components dictate the model
 */
/**
 * @template T
 */
var /*
 * A declarative model is built by traversing the Angular component tree.
 * Declarative = Tree node components dictate the model
 */
/**
 * @template T
 */
DeclarativeTreeNodeModel = /** @class */ (function (_super) {
    __extends(DeclarativeTreeNodeModel, _super);
    function DeclarativeTreeNodeModel(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        if (parent) {
            parent._addChild(_this);
        }
        _this.children = [];
        return _this;
    }
    /**
     * @param {?} child
     * @return {?}
     */
    DeclarativeTreeNodeModel.prototype._addChild = /**
     * @param {?} child
     * @return {?}
     */
    function (child) {
        this.children.push(child);
    };
    /**
     * @param {?} child
     * @return {?}
     */
    DeclarativeTreeNodeModel.prototype._removeChild = /**
     * @param {?} child
     * @return {?}
     */
    function (child) {
        /** @type {?} */
        var index = this.children.indexOf(child);
        if (index > -1) {
            this.children.splice(index, 1);
        }
    };
    /**
     * @return {?}
     */
    DeclarativeTreeNodeModel.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.parent) {
            this.parent._removeChild(this);
        }
        _super.prototype.destroy.call(this);
    };
    return DeclarativeTreeNodeModel;
}(TreeNodeModel));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var TreeFeaturesService = /** @class */ (function () {
    function TreeFeaturesService() {
        this.selectable = false;
        this.eager = true;
    }
    TreeFeaturesService.decorators = [
        { type: Injectable }
    ];
    return TreeFeaturesService;
}());
/**
 * @template T
 * @param {?} existing
 * @return {?}
 */
function treeFeaturesFactory(existing) {
    return existing || new TreeFeaturesService();
}
/** @type {?} */
var TREE_FEATURES_PROVIDER = {
    provide: TreeFeaturesService,
    useFactory: treeFeaturesFactory,
    /*
       * The Optional + SkipSelf pattern ensures that in case of nested components, only the root one will
       * instantiate a new service and all its children will reuse the root's instance.
       * If there are several roots (in this case, several independent trees on a page), each root will instantiate
       * its own service so they won't interfere with one another.
       *
       * TL;DR - Optional + SkipSelf = 1 instance of TreeFeaturesService per tree.
       */
    deps: [[new Optional(), new SkipSelf(), TreeFeaturesService]],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrTreeNode = /** @class */ (function () {
    function ClrTreeNode(nodeId, parent, featuresService, expandService, commonStrings, injector) {
        this.nodeId = nodeId;
        this.featuresService = featuresService;
        this.expandService = expandService;
        this.commonStrings = commonStrings;
        this.STATES = ClrSelectedState;
        // We need an async EventEmitter or we will trigger chocolate errors like it's 2016.
        this.selectedChange = new EventEmitter(true);
        this.expandedChange = new EventEmitter();
        this.subscriptions = [];
        if (this.featuresService.recursion) {
            // I'm completely stuck, we have to hack into private properties until either
            // https://github.com/angular/angular/issues/14935 or https://github.com/angular/angular/issues/15998
            // are fixed
            this._model = ((/** @type {?} */ (injector))).view.context.clrModel;
        }
        else {
            // Force cast for now, not sure how to tie the correct type here to featuresService.recursion
            this._model = new DeclarativeTreeNodeModel(parent ? (/** @type {?} */ (parent._model)) : null);
        }
    }
    /**
     * @return {?}
     */
    ClrTreeNode.prototype.isExpandable = /**
     * @return {?}
     */
    function () {
        if (typeof this.expandable !== 'undefined') {
            return this.expandable;
        }
        return !!this.expandService.expandable || this._model.children.length > 0;
    };
    Object.defineProperty(ClrTreeNode.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () {
            return this._model.selected.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.featuresService.selectable = true;
            // Gracefully handle falsy states like null or undefined because it's just easier than answering questions.
            // This shouldn't happen with strict typing on the app's side, but it's not up to us.
            if (value === null || typeof value === 'undefined') {
                value = ClrSelectedState.UNSELECTED;
            }
            // We match booleans to the corresponding ClrSelectedState
            if (typeof value === 'boolean') {
                value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
            }
            // We propagate only if the tree is in smart mode
            this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTreeNode.prototype, "treeNodeRole", {
        get: /**
         * @return {?}
         */
        function () {
            return this._model.parent ? 'treeitem' : 'tree';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTreeNode.prototype, "rootAriaMultiSelectable", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._model.parent || !this.featuresService.selectable) {
                return null;
            }
            else {
                return true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTreeNode.prototype, "ariaSelected", {
        get: /**
         * @return {?}
         */
        function () {
            return this.featuresService.selectable ? this._model.selected.value === ClrSelectedState.SELECTED : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTreeNode.prototype, "expanded", {
        // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
        // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
        // case, you can't use a structural directive, it would need to go on an ng-container.
        get: 
        // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
        // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
        // case, you can't use a structural directive, it would need to go on an ng-container.
        /**
         * @return {?}
         */
        function () {
            return this.expandService.expanded;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.expandService.expanded = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrTreeNode.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.subscriptions.push(this._model.selected.subscribe(function (value) { return _this.selectedChange.emit(value); }));
        this.subscriptions.push(this.expandService.expandChange.subscribe(function (value) { return _this.expandedChange.emit(value); }));
    };
    /**
     * @return {?}
     */
    ClrTreeNode.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._model.destroy();
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrTreeNode.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tree-node',
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"clr-tree-node-content-container\">\n  <button\n    *ngIf=\"isExpandable() && !_model.loading && !expandService.loading\"\n    type=\"button\"\n    class=\"clr-treenode-caret\"\n    (click)=\"expandService.toggle()\"\n    [attr.aria-expanded]=\"expandService.expanded\">\n    <clr-icon\n      class=\"clr-treenode-caret-icon\"\n      shape=\"caret\"\n      [attr.dir]=\"expandService.expanded ? 'down' : 'right'\"\n      [attr.title]=\"expandService.expanded ? commonStrings.collapse : commonStrings.expand\"></clr-icon>\n  </button>\n  <div class=\"clr-treenode-spinner-container\" *ngIf=\"expandService.loading || _model.loading\">\n        <span class=\"clr-treenode-spinner spinner\"></span>\n  </div>\n  <div class=\"clr-checkbox-wrapper clr-treenode-checkbox\" *ngIf=\"featuresService.selectable\">\n    <input type=\"checkbox\" id=\"{{nodeId}}-check\" class=\"clr-checkbox\" [attr.aria-labelledby]=\"nodeId\"\n           [checked]=\"_model.selected.value === STATES.SELECTED\"\n           [indeterminate]=\"_model.selected.value === STATES.INDETERMINATE\"\n           (change)=\"_model.toggleSelection(featuresService.eager)\">\n    <label for=\"{{nodeId}}-check\" class=\"clr-control-label\"></label>\n  </div>\n  <div class=\"clr-treenode-content\" [id]=\"nodeId\">\n    <ng-content></ng-content>\n  </div>\n</div>\n<div class=\"clr-treenode-children\"\n     [@childNodesState]=\"expandService.expanded ? 'expanded' : 'collapsed'\"\n     [attr.role]=\"isExpandable() ? 'group' : null\">\n  <ng-content select=\"clr-tree-node\"></ng-content>\n  <ng-content select=\"[clrIfExpanded]\"></ng-content>\n  <clr-recursive-children [parent]=\"_model\"></clr-recursive-children>\n</div>\n",
                    providers: [UNIQUE_ID_PROVIDER, TREE_FEATURES_PROVIDER, Expand, { provide: LoadingListener, useExisting: Expand }],
                    animations: [
                        trigger('childNodesState', [
                            state('expanded', style({ height: '*', 'overflow-y': 'hidden' })),
                            state('collapsed', style({ height: 0, 'overflow-y': 'hidden' })),
                            transition('expanded <=> collapsed', animate('0.2s ease-in-out')),
                        ]),
                    ],
                    host: { '[class.clr-tree-node]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrTreeNode.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] },
        { type: ClrTreeNode, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: TreeFeaturesService },
        { type: Expand },
        { type: ClrCommonStrings },
        { type: Injector }
    ]; };
    ClrTreeNode.propDecorators = {
        selected: [{ type: Input, args: ['clrSelected',] }],
        selectedChange: [{ type: Output, args: ['clrSelectedChange',] }],
        treeNodeRole: [{ type: HostBinding, args: ['attr.role',] }],
        rootAriaMultiSelectable: [{ type: HostBinding, args: ['attr.aria-multiselectable',] }],
        ariaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
        expandable: [{ type: Input, args: ['clrExpandable',] }],
        expanded: [{ type: Input, args: ['clrExpanded',] }],
        expandedChange: [{ type: Output, args: ['clrExpandedChange',] }]
    };
    return ClrTreeNode;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrTree = /** @class */ (function () {
    // This component can also be used just to declare providers once for trees with multiple root nodes.
    function ClrTree(featuresService) {
        this.featuresService = featuresService;
    }
    Object.defineProperty(ClrTree.prototype, "lazy", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.featuresService.eager = !value;
        },
        enumerable: true,
        configurable: true
    });
    ClrTree.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tree',
                    template: "\n    <ng-content></ng-content>\n    <clr-recursive-children *ngIf=\"featuresService.recursion\"\n                            [children]=\"featuresService.recursion.root\"></clr-recursive-children>\n  ",
                    providers: [TREE_FEATURES_PROVIDER]
                }] }
    ];
    /** @nocollapse */
    ClrTree.ctorParameters = function () { return [
        { type: TreeFeaturesService }
    ]; };
    ClrTree.propDecorators = {
        lazy: [{ type: Input, args: ['clrLazy',] }]
    };
    return ClrTree;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/**
 * @template T
 * @param {?} o
 * @return {?}
 */
function isPromise(o) {
    // Shamelessly copied from every open-source project out there.
    return o && typeof ((/** @type {?} */ (o))).then === 'function';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * A recursive model is built received from the app and traversed to create the corresponding components.
 * Recursive = Model dictates the tree node components
 */
/**
 * @template T
 */
var /*
 * A recursive model is built received from the app and traversed to create the corresponding components.
 * Recursive = Model dictates the tree node components
 */
/**
 * @template T
 */
RecursiveTreeNodeModel = /** @class */ (function (_super) {
    __extends(RecursiveTreeNodeModel, _super);
    function RecursiveTreeNodeModel(model, parent, getChildren) {
        var _this = _super.call(this) || this;
        _this.getChildren = getChildren;
        _this.childrenFetched = false;
        _this._children = [];
        _this.model = model;
        _this.parent = parent;
        return _this;
    }
    /**
     * @return {?}
     */
    RecursiveTreeNodeModel.prototype.fetchChildren = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.childrenFetched) {
            return;
        }
        /** @type {?} */
        var asyncChildren = this.getChildren(this.model);
        if (isPromise(asyncChildren)) {
            this.loading = true;
            asyncChildren.then(function (raw) {
                _this._children = _this.wrapChildren(raw);
                _this.loading = false;
            });
        }
        else if (isObservable(asyncChildren)) {
            this.loading = true;
            this.subscription = asyncChildren.subscribe(function (raw) {
                _this._children = _this.wrapChildren(raw);
                _this.loading = false;
            });
        }
        else if (asyncChildren) {
            // Synchronous case
            this._children = this.wrapChildren(asyncChildren);
        }
        else {
            this._children = [];
        }
        this.childrenFetched = true;
    };
    /**
     * @param {?} rawModels
     * @return {?}
     */
    RecursiveTreeNodeModel.prototype.wrapChildren = /**
     * @param {?} rawModels
     * @return {?}
     */
    function (rawModels) {
        var _this = this;
        return rawModels.map(function (m) { return new RecursiveTreeNodeModel(m, _this, _this.getChildren); });
    };
    Object.defineProperty(RecursiveTreeNodeModel.prototype, "children", {
        get: /**
         * @return {?}
         */
        function () {
            this.fetchChildren();
            return this._children;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._children = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    RecursiveTreeNodeModel.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        _super.prototype.destroy.call(this);
    };
    return RecursiveTreeNodeModel;
}(TreeNodeModel));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var ClrRecursiveForOf = /** @class */ (function () {
    function ClrRecursiveForOf(template, featuresService) {
        this.template = template;
        this.featuresService = featuresService;
    }
    // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
    // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
    /**
     * @return {?}
     */
    ClrRecursiveForOf.prototype.ngOnChanges = 
    // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
    /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var wrapped;
        if (Array.isArray(this.nodes)) {
            wrapped = this.nodes.map(function (node) { return new RecursiveTreeNodeModel(node, null, _this.getChildren); });
        }
        else {
            wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren)];
        }
        this.featuresService.recursion = {
            template: this.template,
            root: wrapped,
        };
    };
    ClrRecursiveForOf.decorators = [
        { type: Directive, args: [{ selector: '[clrRecursiveFor][clrRecursiveForOf]' },] }
    ];
    /** @nocollapse */
    ClrRecursiveForOf.ctorParameters = function () { return [
        { type: TemplateRef },
        { type: TreeFeaturesService }
    ]; };
    ClrRecursiveForOf.propDecorators = {
        nodes: [{ type: Input, args: ['clrRecursiveForOf',] }],
        getChildren: [{ type: Input, args: ['clrRecursiveForGetChildren',] }]
    };
    return ClrRecursiveForOf;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var RecursiveChildren = /** @class */ (function () {
    function RecursiveChildren(featuresService, expandService) {
        var _this = this;
        this.featuresService = featuresService;
        this.expandService = expandService;
        if (expandService && featuresService.recursion) {
            this.subscription = this.expandService.expandChange.subscribe(function (value) {
                if (value && _this.parent) {
                    // Once again, I'm sure we can find a way to avoid this casting by typing every component in a way that
                    // lets us use the more specific model classes depending on the use of *clrRecursiveForOf or not.
                    // But it would take time, which we don't have right now.
                    ((/** @type {?} */ (_this.parent))).fetchChildren();
                }
            });
        }
    }
    /**
     * @return {?}
     */
    RecursiveChildren.prototype.shouldRender = /**
     * @return {?}
     */
    function () {
        return (this.featuresService.recursion &&
            // In the smart case, we eagerly render all the recursive children
            // to make sure two-way bindings for selection are available.
            // They will be hidden with CSS by the parent.
            (this.featuresService.eager || !this.expandService || this.expandService.expanded));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    RecursiveChildren.prototype.getContext = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return {
            $implicit: node.model,
            clrModel: node,
        };
    };
    /**
     * @return {?}
     */
    RecursiveChildren.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    RecursiveChildren.decorators = [
        { type: Component, args: [{
                    selector: 'clr-recursive-children',
                    template: "\n    <ng-container *ngIf=\"shouldRender()\">\n      <ng-container *ngFor=\"let child of parent?.children || children\">\n        <ng-container *ngTemplateOutlet=\"featuresService.recursion.template; context: getContext(child)\"></ng-container>\n      </ng-container>\n    </ng-container>\n  "
                }] }
    ];
    /** @nocollapse */
    RecursiveChildren.ctorParameters = function () { return [
        { type: TreeFeaturesService },
        { type: Expand, decorators: [{ type: Optional }] }
    ]; };
    RecursiveChildren.propDecorators = {
        parent: [{ type: Input, args: ['parent',] }],
        children: [{ type: Input, args: ['children',] }]
    };
    return RecursiveChildren;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_TREE_VIEW_DIRECTIVES = [ClrTree, ClrTreeNode, ClrRecursiveForOf];
var ClrTreeViewModule = /** @class */ (function () {
    function ClrTreeViewModule() {
    }
    ClrTreeViewModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule, ClrLoadingModule],
                    declarations: [CLR_TREE_VIEW_DIRECTIVES, RecursiveChildren],
                    exports: [CLR_TREE_VIEW_DIRECTIVES, ClrIfExpandModule],
                },] }
    ];
    return ClrTreeViewModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDataModule = /** @class */ (function () {
    function ClrDataModule() {
    }
    ClrDataModule.decorators = [
        { type: NgModule, args: [{ exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule] },] }
    ];
    return ClrDataModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var RootDropdownService = /** @class */ (function () {
    function RootDropdownService() {
        this._changes = new Subject();
    }
    Object.defineProperty(RootDropdownService.prototype, "changes", {
        get: /**
         * @return {?}
         */
        function () {
            return this._changes.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    RootDropdownService.prototype.closeMenus = /**
     * @return {?}
     */
    function () {
        this._changes.next(false);
    };
    RootDropdownService.decorators = [
        { type: Injectable }
    ];
    return RootDropdownService;
}());
/**
 * @param {?} existing
 * @return {?}
 */
function clrRootDropdownFactory(existing) {
    return existing || new RootDropdownService();
}
/** @type {?} */
var ROOT_DROPDOWN_PROVIDER = {
    provide: RootDropdownService,
    useFactory: clrRootDropdownFactory,
    deps: [[new Optional(), new SkipSelf(), RootDropdownService]],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDropdown = /** @class */ (function () {
    function ClrDropdown(parent, ifOpenService, cdr, dropdownService) {
        var _this = this;
        this.parent = parent;
        this.ifOpenService = ifOpenService;
        this.cdr = cdr;
        this.subscriptions = [];
        this.isMenuClosable = true;
        this.subscriptions.push(dropdownService.changes.subscribe(function (value) { return (_this.ifOpenService.open = value); }));
        this.subscriptions.push(ifOpenService.openChange.subscribe(function (value) { return _this.cdr.markForCheck(); }));
    }
    /**
     * @return {?}
     */
    ClrDropdown.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
    };
    ClrDropdown.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dropdown',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[class.dropdown]': 'true',
                        // FIXME: remove this as soon as we stop supporting this old <div class="dropdown-menu"> syntax
                        '[class.open]': 'ifOpenService.open',
                    },
                    providers: [IfOpenService, ROOT_DROPDOWN_PROVIDER, { provide: POPOVER_HOST_ANCHOR, useExisting: ElementRef }]
                }] }
    ];
    /** @nocollapse */
    ClrDropdown.ctorParameters = function () { return [
        { type: ClrDropdown, decorators: [{ type: SkipSelf }, { type: Optional }] },
        { type: IfOpenService },
        { type: ChangeDetectorRef },
        { type: RootDropdownService }
    ]; };
    ClrDropdown.propDecorators = {
        isMenuClosable: [{ type: Input, args: ['clrCloseMenuOnItemClick',] }]
    };
    return ClrDropdown;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDropdownItem = /** @class */ (function () {
    function ClrDropdownItem(dropdown, el, _dropdownService, renderer) {
        this.dropdown = dropdown;
        this.el = el;
        this._dropdownService = _dropdownService;
        this.renderer = renderer;
    }
    /**
     * @return {?}
     */
    ClrDropdownItem.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.renderer.listen(this.el.nativeElement, 'click', function () { return _this.onDropdownItemClick(); });
    };
    /**
     * @return {?}
     */
    ClrDropdownItem.prototype.onDropdownItemClick = /**
     * @return {?}
     */
    function () {
        if (this.dropdown.isMenuClosable && !this.el.nativeElement.classList.contains('disabled')) {
            this._dropdownService.closeMenus();
        }
    };
    ClrDropdownItem.decorators = [
        { type: Directive, args: [{ selector: '[clrDropdownItem]', host: { '[class.dropdown-item]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrDropdownItem.ctorParameters = function () { return [
        { type: ClrDropdown },
        { type: ElementRef },
        { type: RootDropdownService },
        { type: Renderer2 }
    ]; };
    return ClrDropdownItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDropdownMenu = /** @class */ (function (_super) {
    __extends(ClrDropdownMenu, _super);
    function ClrDropdownMenu(injector, parentHost, nested) {
        var _this = this;
        if (!parentHost) {
            throw new Error('clr-dropdown-menu should only be used inside of a clr-dropdown');
        }
        _this = _super.call(this, injector, parentHost) || this;
        if (!nested) {
            // Default positioning for normal dropdown is bottom-left
            _this.anchorPoint = Point.BOTTOM_LEFT;
            _this.popoverPoint = Point.LEFT_TOP;
        }
        else {
            // Default positioning for nested dropdown is right-top
            _this.anchorPoint = Point.RIGHT_TOP;
            _this.popoverPoint = Point.LEFT_TOP;
        }
        _this.popoverOptions.allowMultipleOpen = true;
        _this.closeOnOutsideClick = true;
        return _this;
    }
    Object.defineProperty(ClrDropdownMenu.prototype, "position", {
        set: /**
         * @param {?} position
         * @return {?}
         */
        function (position) {
            // set the popover values based on menu position
            switch (position) {
                case 'top-right':
                    this.anchorPoint = Point.TOP_RIGHT;
                    this.popoverPoint = Point.RIGHT_BOTTOM;
                    break;
                case 'top-left':
                    this.anchorPoint = Point.TOP_LEFT;
                    this.popoverPoint = Point.LEFT_BOTTOM;
                    break;
                case 'bottom-right':
                    this.anchorPoint = Point.BOTTOM_RIGHT;
                    this.popoverPoint = Point.RIGHT_TOP;
                    break;
                case 'bottom-left':
                    this.anchorPoint = Point.BOTTOM_LEFT;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
                case 'right-top':
                    this.anchorPoint = Point.RIGHT_TOP;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
                case 'right-bottom':
                    this.anchorPoint = Point.RIGHT_BOTTOM;
                    this.popoverPoint = Point.LEFT_BOTTOM;
                    break;
                case 'left-top':
                    this.anchorPoint = Point.LEFT_TOP;
                    this.popoverPoint = Point.RIGHT_TOP;
                    break;
                case 'left-bottom':
                    this.anchorPoint = Point.LEFT_BOTTOM;
                    this.popoverPoint = Point.RIGHT_BOTTOM;
                    break;
                default:
                    this.anchorPoint = Point.BOTTOM_LEFT;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    ClrDropdownMenu.decorators = [
        { type: Component, args: [{
                    selector: 'clr-dropdown-menu',
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: {
                        '[class.dropdown-menu]': 'true',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrDropdownMenu.ctorParameters = function () { return [
        { type: Injector },
        { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [POPOVER_HOST_ANCHOR,] }] },
        { type: ClrDropdownMenu, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    ClrDropdownMenu.propDecorators = {
        position: [{ type: Input, args: ['clrPosition',] }]
    };
    return ClrDropdownMenu;
}(AbstractPopover));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrDropdownTrigger = /** @class */ (function () {
    function ClrDropdownTrigger(dropdown, ifOpenService) {
        this.ifOpenService = ifOpenService;
        this.isRootLevelToggle = true;
        // if the containing dropdown has a parent, then this is not the root level one
        if (dropdown.parent) {
            this.isRootLevelToggle = false;
        }
    }
    Object.defineProperty(ClrDropdownTrigger.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ifOpenService.open;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    ClrDropdownTrigger.prototype.onDropdownTriggerClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.ifOpenService.toggleWithEvent(event);
    };
    ClrDropdownTrigger.decorators = [
        { type: Directive, args: [{
                    // We support both selectors for legacy reasons
                    selector: '[clrDropdownTrigger],[clrDropdownToggle]',
                    host: {
                        '[class.dropdown-toggle]': 'isRootLevelToggle',
                        '[class.dropdown-item]': '!isRootLevelToggle',
                        '[class.expandable]': '!isRootLevelToggle',
                        '[class.active]': 'active',
                    },
                },] }
    ];
    /** @nocollapse */
    ClrDropdownTrigger.ctorParameters = function () { return [
        { type: ClrDropdown },
        { type: IfOpenService }
    ]; };
    ClrDropdownTrigger.propDecorators = {
        onDropdownTriggerClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return ClrDropdownTrigger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_DROPDOWN_DIRECTIVES = [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem];
var ClrDropdownModule = /** @class */ (function () {
    function ClrDropdownModule() {
    }
    ClrDropdownModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrCommonPopoverModule],
                    declarations: [CLR_DROPDOWN_DIRECTIVES],
                    exports: [CLR_DROPDOWN_DIRECTIVES, ClrConditionalModule, ClrIconModule],
                },] }
    ];
    return ClrDropdownModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
// @TODO Make this an enum
/** @type {?} */
var ALERT_TYPES = ['info', 'warning', 'danger', 'success'];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var AlertIconAndTypesService = /** @class */ (function () {
    function AlertIconAndTypesService(commonStrings) {
        this.commonStrings = commonStrings;
        this.defaultIconShape = 'info-circle';
        this._alertIconShape = '';
        this._alertType = 'info';
    }
    Object.defineProperty(AlertIconAndTypesService.prototype, "alertType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._alertType;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (ALERT_TYPES.indexOf(val) > -1) {
                this._alertType = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconShape", {
        get: /**
         * @return {?}
         */
        function () {
            if ('' === this._alertIconShape) {
                return this.iconInfoFromType(this._alertType).shape;
            }
            return this._alertIconShape;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (!val) {
                this._alertIconShape = '';
            }
            else if (val !== this._alertIconShape) {
                this._alertIconShape = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AlertIconAndTypesService.prototype, "alertIconTitle", {
        get: /**
         * @return {?}
         */
        function () {
            return this.iconInfoFromType(this._alertType).title;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} type
     * @return {?}
     */
    AlertIconAndTypesService.prototype.iconInfoFromType = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        /** @type {?} */
        var returnObj = { shape: '', cssClass: '', title: '' };
        switch (type) {
            case 'warning':
                returnObj.shape = 'exclamation-triangle';
                returnObj.cssClass = 'alert-warning';
                returnObj.title = this.commonStrings.warning;
                break;
            case 'danger':
                returnObj.shape = 'exclamation-circle';
                returnObj.cssClass = 'alert-danger';
                returnObj.title = this.commonStrings.danger;
                break;
            case 'success':
                returnObj.shape = 'check-circle';
                returnObj.cssClass = 'alert-success';
                returnObj.title = this.commonStrings.success;
                break;
            default:
                returnObj.shape = this.defaultIconShape;
                returnObj.cssClass = 'alert-info';
                returnObj.title = this.commonStrings.info;
                break;
        }
        return returnObj;
    };
    AlertIconAndTypesService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    AlertIconAndTypesService.ctorParameters = function () { return [
        { type: ClrCommonStrings }
    ]; };
    return AlertIconAndTypesService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var MultiAlertService = /** @class */ (function () {
    function MultiAlertService() {
        this.allAlerts = new QueryList();
        this._current = 0;
        /**
         * The Observable that lets other classes subscribe to changes
         */
        this._change = new Subject();
    }
    Object.defineProperty(MultiAlertService.prototype, "changes", {
        get: /**
         * @return {?}
         */
        function () {
            return this._change.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiAlertService.prototype, "current", {
        get: /**
         * @return {?}
         */
        function () {
            return this._current;
        },
        set: /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            if (index !== this._current) {
                this._current = index;
                this._change.next(index);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiAlertService.prototype, "activeAlerts", {
        get: /**
         * @return {?}
         */
        function () {
            return this.allAlerts.filter(function (alert) { return !alert._closed; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiAlertService.prototype, "currentAlert", {
        get: /**
         * @return {?}
         */
        function () {
            return this.activeAlerts[this.current];
        },
        set: /**
         * @param {?} alert
         * @return {?}
         */
        function (alert) {
            this.current = this.activeAlerts.indexOf(alert);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MultiAlertService.prototype, "count", {
        get: /**
         * @return {?}
         */
        function () {
            return this.activeAlerts.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} alerts
     * @return {?}
     */
    MultiAlertService.prototype.manage = /**
     * @param {?} alerts
     * @return {?}
     */
    function (alerts) {
        var _this = this;
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.allAlerts = alerts;
        this.subscription = this.allAlerts.changes.subscribe(function () {
            if (_this.current >= _this.allAlerts.length) {
                _this.current = Math.max(0, _this.allAlerts.length - 1);
            }
        });
    };
    /**
     * @return {?}
     */
    MultiAlertService.prototype.next = /**
     * @return {?}
     */
    function () {
        this.current = this.current === this.activeAlerts.length - 1 ? 0 : this.current + 1;
    };
    /**
     * @return {?}
     */
    MultiAlertService.prototype.previous = /**
     * @return {?}
     */
    function () {
        if (this.activeAlerts.length === 0) {
            return;
        }
        this.current = this.current === 0 ? this.activeAlerts.length - 1 : this.current - 1;
    };
    /**
     * @return {?}
     */
    MultiAlertService.prototype.close = /**
     * @return {?}
     */
    function () {
        this.previous();
    };
    /**
     * @return {?}
     */
    MultiAlertService.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    };
    MultiAlertService.decorators = [
        { type: Injectable }
    ];
    return MultiAlertService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrAlert = /** @class */ (function () {
    function ClrAlert(iconService, cdr, multiAlertService, commonStrings) {
        this.iconService = iconService;
        this.cdr = cdr;
        this.multiAlertService = multiAlertService;
        this.commonStrings = commonStrings;
        this.isSmall = false;
        this.closable = true;
        this.isAppLevel = false;
        this._closed = false;
        this._closedChanged = new EventEmitter(false);
        this.previouslyHidden = false;
        this.hidden = false;
    }
    Object.defineProperty(ClrAlert.prototype, "alertType", {
        get: /**
         * @return {?}
         */
        function () {
            return this.iconService.alertType;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.iconService.alertType = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrAlert.prototype, "alertIconShape", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.iconService.alertIconShape = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrAlert.prototype, "alertClass", {
        get: /**
         * @return {?}
         */
        function () {
            return this.iconService.iconInfoFromType(this.iconService.alertType).cssClass;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrAlert.prototype.detectChangesIfNeeded = /**
     * @return {?}
     */
    function () {
        if (this.previouslyHidden !== this.hidden) {
            this.previouslyHidden = this.hidden;
            this.cdr.detectChanges();
        }
    };
    Object.defineProperty(ClrAlert.prototype, "isHidden", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.multiAlertService) {
                // change detection issue in production mode causes currentAlert to be undefined when only the first alert exists
                // https://github.com/vmware/clarity/issues/2430
                if (this.multiAlertService.currentAlert === this || this.multiAlertService.count === 0) {
                    if (this.hidden === true) {
                        this.previouslyHidden = true;
                        this.hidden = false;
                    }
                }
                else if (this.hidden === false) {
                    this.previouslyHidden = false;
                    this.hidden = true;
                }
                this.detectChangesIfNeeded();
            }
            return this.hidden;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrAlert.prototype.close = /**
     * @return {?}
     */
    function () {
        if (!this.closable) {
            return;
        }
        this._closed = true;
        if (this.multiAlertService) {
            this.multiAlertService.close();
        }
        this._closedChanged.emit(true);
    };
    /**
     * @return {?}
     */
    ClrAlert.prototype.open = /**
     * @return {?}
     */
    function () {
        this._closed = false;
        this._closedChanged.emit(false);
    };
    ClrAlert.decorators = [
        { type: Component, args: [{
                    selector: 'clr-alert',
                    providers: [AlertIconAndTypesService],
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n    *ngIf=\"!_closed\"\n    class=\"alert\"\n    [ngClass]=\"alertClass\"\n    [class.alert-hidden]=\"isHidden\"\n    [class.alert-sm]=\"isSmall\"\n    [class.alert-app-level]=\"isAppLevel\"\n    role=\"alert\">\n    <div class=\"alert-items\">\n        <ng-content></ng-content>\n    </div>\n    <button type=\"button\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n        <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n    </button>\n</div>\n",
                    styles: [':host { display: block; }']
                }] }
    ];
    /** @nocollapse */
    ClrAlert.ctorParameters = function () { return [
        { type: AlertIconAndTypesService },
        { type: ChangeDetectorRef },
        { type: MultiAlertService, decorators: [{ type: Optional }] },
        { type: ClrCommonStrings }
    ]; };
    ClrAlert.propDecorators = {
        isSmall: [{ type: Input, args: ['clrAlertSizeSmall',] }],
        closable: [{ type: Input, args: ['clrAlertClosable',] }],
        isAppLevel: [{ type: Input, args: ['clrAlertAppLevel',] }],
        _closed: [{ type: Input, args: ['clrAlertClosed',] }],
        _closedChanged: [{ type: Output, args: ['clrAlertClosedChange',] }],
        alertType: [{ type: Input, args: ['clrAlertType',] }],
        alertIconShape: [{ type: Input, args: ['clrAlertIcon',] }]
    };
    return ClrAlert;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrAlertItem = /** @class */ (function () {
    function ClrAlertItem(iconService) {
        this.iconService = iconService;
    }
    ClrAlertItem.decorators = [
        { type: Component, args: [{
                    selector: 'clr-alert-item',
                    template: "\n        <div class=\"alert-icon-wrapper\">\n            <clr-icon class=\"alert-icon\" \n              [attr.shape]=\"iconService.alertIconShape\" \n              [attr.title]=\"iconService.alertIconTitle\"></clr-icon>\n        </div>\n        <ng-content></ng-content>\n    ",
                    host: { class: 'alert-item' }
                }] }
    ];
    /** @nocollapse */
    ClrAlertItem.ctorParameters = function () { return [
        { type: AlertIconAndTypesService }
    ]; };
    return ClrAlertItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrAlerts = /** @class */ (function () {
    function ClrAlerts(multiAlertService) {
        this.multiAlertService = multiAlertService;
        this.currentAlertIndexChange = new EventEmitter(false);
        this.currentAlertChange = new EventEmitter(false);
    }
    Object.defineProperty(ClrAlerts.prototype, "_inputCurrentIndex", {
        /**
         * Input/Output to support two way binding on current alert index
         */
        set: /**
         * Input/Output to support two way binding on current alert index
         * @param {?} index
         * @return {?}
         */
        function (index) {
            if (Number.isInteger(index) && index >= 0) {
                this.multiAlertService.current = index;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrAlerts.prototype, "currentAlertIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.multiAlertService.current;
        },
        set: /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.multiAlertService.current = index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrAlerts.prototype, "currentAlert", {
        get: /**
         * @return {?}
         */
        function () {
            return this.multiAlertService.currentAlert;
        },
        /**
         * Input/Output to support two way binding on current alert instance
         */
        set: /**
         * Input/Output to support two way binding on current alert instance
         * @param {?} alert
         * @return {?}
         */
        function (alert) {
            if (alert) {
                this.multiAlertService.currentAlert = alert;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrAlerts.prototype, "alerts", {
        /**
         * Ensure we are only dealing with alerts that have not been closed yet
         */
        get: /**
         * Ensure we are only dealing with alerts that have not been closed yet
         * @return {?}
         */
        function () {
            return this.allAlerts.filter(function (alert) {
                return alert.isHidden === false;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrAlerts.prototype, "currentAlertType", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.multiAlertService.currentAlert) {
                return this.multiAlertService.currentAlert.alertType;
            }
            return '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrAlerts.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.multiAlertService.manage(this.allAlerts);
        this.multiAlertService.changes.subscribe(function (index) {
            _this.currentAlertIndexChange.next(index);
            _this.currentAlertChange.next(_this.multiAlertService.currentAlert);
        });
    };
    /**
     * @return {?}
     */
    ClrAlerts.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.multiAlertService.destroy();
    };
    ClrAlerts.decorators = [
        { type: Component, args: [{
                    selector: 'clr-alerts',
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-alerts-pager\n        *ngIf=\"multiAlertService.count > 1\"\n        [clrCurrentAlertIndex]=\"currentAlertIndex\">\n</clr-alerts-pager>\n<ng-content select=\"clr-alert\"></ng-content>\n",
                    providers: [MultiAlertService],
                    host: {
                        '[class.alerts]': 'true',
                        '[class.alert-danger]': "this.currentAlertType == 'danger'",
                        '[class.alert-info]': "this.currentAlertType == 'info'",
                        '[class.alert-success]': "this.currentAlertType == 'success'",
                        '[class.alert-warning]': "this.currentAlertType == 'warning'",
                    },
                    styles: [':host { display: block }']
                }] }
    ];
    /** @nocollapse */
    ClrAlerts.ctorParameters = function () { return [
        { type: MultiAlertService }
    ]; };
    ClrAlerts.propDecorators = {
        allAlerts: [{ type: ContentChildren, args: [ClrAlert,] }],
        _inputCurrentIndex: [{ type: Input, args: ['clrCurrentAlertIndex',] }],
        currentAlertIndexChange: [{ type: Output, args: ['clrCurrentAlertIndexChange',] }],
        currentAlert: [{ type: Input, args: ['clrCurrentAlert',] }],
        currentAlertChange: [{ type: Output, args: ['clrCurrentAlertChange',] }]
    };
    return ClrAlerts;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrAlertsPager = /** @class */ (function () {
    function ClrAlertsPager(multiAlertService, commonStrings) {
        this.multiAlertService = multiAlertService;
        this.commonStrings = commonStrings;
        this.currentAlertChange = new EventEmitter(false);
        this.currentAlertIndexChange = new EventEmitter();
    }
    Object.defineProperty(ClrAlertsPager.prototype, "currentAlert", {
        get: /**
         * @return {?}
         */
        function () {
            return this.multiAlertService.currentAlert;
        },
        /**
         * Input/Output to support two way binding on current alert instance
         */
        set: /**
         * Input/Output to support two way binding on current alert instance
         * @param {?} alert
         * @return {?}
         */
        function (alert) {
            if (alert) {
                this.multiAlertService.currentAlert = alert;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrAlertsPager.prototype, "currentAlertIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.multiAlertService.current;
        },
        /**
         * Input/Output to support two way binding on current alert index
         */
        set: /**
         * Input/Output to support two way binding on current alert index
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.multiAlertService.current = index;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrAlertsPager.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.multiAlertServiceChanges = this.multiAlertService.changes.subscribe(function (index) {
            _this.currentAlertIndexChange.emit(index);
            _this.currentAlertChange.emit(_this.multiAlertService.activeAlerts[index]);
        });
    };
    /**
     * @return {?}
     */
    ClrAlertsPager.prototype.pageUp = /**
     * @return {?}
     */
    function () {
        this.multiAlertService.next();
    };
    /**
     * @return {?}
     */
    ClrAlertsPager.prototype.pageDown = /**
     * @return {?}
     */
    function () {
        this.multiAlertService.previous();
    };
    /**
     * @return {?}
     */
    ClrAlertsPager.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.multiAlertServiceChanges.unsubscribe();
    };
    ClrAlertsPager.decorators = [
        { type: Component, args: [{
                    selector: 'clr-alerts-pager',
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"alerts-pager-control\">\n    <div class=\"alerts-page-down\">\n        <button class=\"alerts-pager-button\" (click)=\"pageDown()\">\n            <clr-icon shape=\"caret left\" [attr.title]=\"commonStrings.previous\"></clr-icon>\n        </button>\n    </div>\n    <div class=\"alerts-pager-text\">\n        {{this.multiAlertService.current+1}} / {{this.multiAlertService.count}}\n    </div>\n    <div class=\"alerts-page-up\">\n        <button class=\"alerts-pager-button\" (click)=\"pageUp()\">\n            <clr-icon shape=\"caret right\" [attr.title]=\"commonStrings.next\"></clr-icon>\n        </button>\n    </div>\n</div>\n",
                    host: { '[class.alerts-pager]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrAlertsPager.ctorParameters = function () { return [
        { type: MultiAlertService },
        { type: ClrCommonStrings }
    ]; };
    ClrAlertsPager.propDecorators = {
        currentAlert: [{ type: Input, args: ['clrCurrentAlert',] }],
        currentAlertChange: [{ type: Output, args: ['clrCurrentAlertChange',] }],
        currentAlertIndex: [{ type: Input, args: ['clrCurrentAlertIndex',] }],
        currentAlertIndexChange: [{ type: Output, args: ['clrCurrentAlertIndexChange',] }]
    };
    return ClrAlertsPager;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_ALERT_DIRECTIVES = [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager];
var ClrAlertModule = /** @class */ (function () {
    function ClrAlertModule() {
    }
    ClrAlertModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule, ClrDropdownModule],
                    declarations: [CLR_ALERT_DIRECTIVES],
                    exports: [CLR_ALERT_DIRECTIVES],
                },] }
    ];
    return ClrAlertModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrEmphasisModule = /** @class */ (function () {
    function ClrEmphasisModule() {
    }
    ClrEmphasisModule.decorators = [
        { type: NgModule, args: [{ exports: [ClrAlertModule] },] }
    ];
    return ClrEmphasisModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var ResponsiveNavCodes = /** @class */ (function () {
    function ResponsiveNavCodes() {
    }
    ResponsiveNavCodes.NAV_LEVEL_1 = 1;
    ResponsiveNavCodes.NAV_LEVEL_2 = 2;
    ResponsiveNavCodes.NAV_CLOSE_ALL = 'NAV_CLOSE_ALL';
    ResponsiveNavCodes.NAV_OPEN = 'NAV_OPEN';
    ResponsiveNavCodes.NAV_CLOSE = 'NAV_CLOSE';
    ResponsiveNavCodes.NAV_TOGGLE = 'NAV_TOGGLE';
    ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU = 'open-hamburger-menu';
    ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU = 'open-overflow-menu';
    ResponsiveNavCodes.NAV_CLASS_TRIGGER_1 = 'header-hamburger-trigger';
    ResponsiveNavCodes.NAV_CLASS_TRIGGER_2 = 'header-overflow-trigger';
    ResponsiveNavCodes.NAV_CLASS_LEVEL_1 = 'clr-nav-level-1';
    ResponsiveNavCodes.NAV_CLASS_LEVEL_2 = 'clr-nav-level-2';
    return ResponsiveNavCodes;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
var ResponsiveNavControlMessage = /** @class */ (function () {
    function ResponsiveNavControlMessage(_controlCode, _navLevel) {
        this._controlCode = _controlCode;
        this._navLevel = _navLevel;
    }
    Object.defineProperty(ResponsiveNavControlMessage.prototype, "controlCode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._controlCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponsiveNavControlMessage.prototype, "navLevel", {
        get: /**
         * @return {?}
         */
        function () {
            return this._navLevel;
        },
        enumerable: true,
        configurable: true
    });
    return ResponsiveNavControlMessage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ResponsiveNavigationService = /** @class */ (function () {
    function ResponsiveNavigationService() {
        this.responsiveNavList = [];
        this.registerNavSubject = new Subject();
        this.controlNavSubject = new Subject();
        this.closeAllNavs(); // We start with all navs closed
    }
    Object.defineProperty(ResponsiveNavigationService.prototype, "registeredNavs", {
        get: /**
         * @return {?}
         */
        function () {
            return this.registerNavSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResponsiveNavigationService.prototype, "navControl", {
        get: /**
         * @return {?}
         */
        function () {
            return this.controlNavSubject.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} navLevel
     * @return {?}
     */
    ResponsiveNavigationService.prototype.registerNav = /**
     * @param {?} navLevel
     * @return {?}
     */
    function (navLevel) {
        if (!navLevel || this.isNavRegistered(navLevel)) {
            return;
        }
        this.responsiveNavList.push(navLevel);
        this.registerNavSubject.next(this.responsiveNavList);
    };
    /**
     * @param {?} navLevel
     * @return {?}
     */
    ResponsiveNavigationService.prototype.isNavRegistered = /**
     * @param {?} navLevel
     * @return {?}
     */
    function (navLevel) {
        if (this.responsiveNavList.indexOf(navLevel) > -1) {
            console.error('Multiple clr-nav-level ' + navLevel + ' attributes found. Please make sure that only one exists');
            return true;
        }
        return false;
    };
    /**
     * @param {?} navLevel
     * @return {?}
     */
    ResponsiveNavigationService.prototype.unregisterNav = /**
     * @param {?} navLevel
     * @return {?}
     */
    function (navLevel) {
        /** @type {?} */
        var index = this.responsiveNavList.indexOf(navLevel);
        if (index > -1) {
            this.responsiveNavList.splice(index, 1);
            this.registerNavSubject.next(this.responsiveNavList);
        }
    };
    /**
     * @param {?} controlCode
     * @param {?} navLevel
     * @return {?}
     */
    ResponsiveNavigationService.prototype.sendControlMessage = /**
     * @param {?} controlCode
     * @param {?} navLevel
     * @return {?}
     */
    function (controlCode, navLevel) {
        /** @type {?} */
        var message = new ResponsiveNavControlMessage(controlCode, navLevel);
        this.controlNavSubject.next(message);
    };
    /**
     * @return {?}
     */
    ResponsiveNavigationService.prototype.closeAllNavs = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var message = new ResponsiveNavControlMessage(ResponsiveNavCodes.NAV_CLOSE_ALL, -999);
        this.controlNavSubject.next(message);
    };
    ResponsiveNavigationService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    ResponsiveNavigationService.ctorParameters = function () { return []; };
    /** @nocollapse */ ResponsiveNavigationService.ngInjectableDef = defineInjectable({ factory: function ResponsiveNavigationService_Factory() { return new ResponsiveNavigationService(); }, token: ResponsiveNavigationService, providedIn: "root" });
    return ResponsiveNavigationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrMainContainer = /** @class */ (function () {
    function ClrMainContainer(elRef, responsiveNavService) {
        this.elRef = elRef;
        this.responsiveNavService = responsiveNavService;
    }
    /**
     * @return {?}
     */
    ClrMainContainer.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._classList = this.elRef.nativeElement.classList;
        this._subscription = this.responsiveNavService.navControl.subscribe({
            next: function (message) {
                _this.processMessage(message);
            },
        });
    };
    /**
     * @param {?} message
     * @return {?}
     */
    ClrMainContainer.prototype.processMessage = /**
     * @param {?} message
     * @return {?}
     */
    function (message) {
        /** @type {?} */
        var navClass = ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
        if (message.controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL) {
            this._classList.remove(ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
            this._classList.remove(ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
        }
        else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
            this.controlNav(message.controlCode, navClass);
        }
        else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
            navClass = ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
            this.controlNav(message.controlCode, navClass);
        }
    };
    /**
     * @param {?} controlCode
     * @param {?} navClass
     * @return {?}
     */
    ClrMainContainer.prototype.controlNav = /**
     * @param {?} controlCode
     * @param {?} navClass
     * @return {?}
     */
    function (controlCode, navClass) {
        if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
            this._classList.add(navClass);
        }
        else if (controlCode === ResponsiveNavCodes.NAV_CLOSE) {
            this._classList.remove(navClass);
        }
        else if (controlCode === ResponsiveNavCodes.NAV_TOGGLE) {
            this._classList.toggle(navClass);
        }
    };
    /**
     * @return {?}
     */
    ClrMainContainer.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    ClrMainContainer.decorators = [
        { type: Directive, args: [{ selector: 'clr-main-container', host: { '[class.main-container]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrMainContainer.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ResponsiveNavigationService }
    ]; };
    return ClrMainContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_LAYOUT_DIRECTIVES = [ClrMainContainer];
var ClrMainContainerModule = /** @class */ (function () {
    function ClrMainContainerModule() {
    }
    ClrMainContainerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule],
                    declarations: [CLR_LAYOUT_DIRECTIVES],
                    exports: [CLR_LAYOUT_DIRECTIVES],
                },] }
    ];
    return ClrMainContainerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var MainContainerWillyWonka = /** @class */ (function (_super) {
    __extends(MainContainerWillyWonka, _super);
    function MainContainerWillyWonka() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MainContainerWillyWonka.decorators = [
        { type: Directive, args: [{ selector: 'clr-main-container' },] }
    ];
    return MainContainerWillyWonka;
}(WillyWonka));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var NavDetectionOompaLoompa = /** @class */ (function (_super) {
    __extends(NavDetectionOompaLoompa, _super);
    function NavDetectionOompaLoompa(cdr, willyWonka, responsiveNavService) {
        var _this = this;
        if (!willyWonka) {
            throw new Error('clr-header should only be used inside of a clr-main-container');
        }
        _this = _super.call(this, cdr, willyWonka) || this;
        _this.responsiveNavService = responsiveNavService;
        return _this;
    }
    Object.defineProperty(NavDetectionOompaLoompa.prototype, "flavor", {
        // NavDetectionOompaLoompa is the addition of the nav levels
        // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
        get: 
        // NavDetectionOompaLoompa is the addition of the nav levels
        // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
        /**
         * @return {?}
         */
        function () {
            return this.responsiveNavService.responsiveNavList.reduce(function (sum, navLevel) { return sum + navLevel; }, 0);
        },
        enumerable: true,
        configurable: true
    });
    NavDetectionOompaLoompa.decorators = [
        { type: Directive, args: [{ selector: 'clr-header' },] }
    ];
    /** @nocollapse */
    NavDetectionOompaLoompa.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: MainContainerWillyWonka, decorators: [{ type: Optional }] },
        { type: ResponsiveNavigationService }
    ]; };
    return NavDetectionOompaLoompa;
}(OompaLoompa));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrHeader = /** @class */ (function () {
    function ClrHeader(responsiveNavService) {
        var _this = this;
        this.responsiveNavService = responsiveNavService;
        this.isNavLevel1OnPage = false;
        this.isNavLevel2OnPage = false;
        this.responsiveNavCodes = ResponsiveNavCodes;
        this._subscription = this.responsiveNavService.registeredNavs.subscribe({
            next: function (navLevelList) {
                _this.initializeNavTriggers(navLevelList);
            },
        });
    }
    // reset triggers. handles cases when an application has different nav levels on different pages.
    // reset triggers. handles cases when an application has different nav levels on different pages.
    /**
     * @return {?}
     */
    ClrHeader.prototype.resetNavTriggers = 
    // reset triggers. handles cases when an application has different nav levels on different pages.
    /**
     * @return {?}
     */
    function () {
        this.isNavLevel1OnPage = false;
        this.isNavLevel2OnPage = false;
    };
    // decides which triggers to show on the header
    // decides which triggers to show on the header
    /**
     * @param {?} navList
     * @return {?}
     */
    ClrHeader.prototype.initializeNavTriggers = 
    // decides which triggers to show on the header
    /**
     * @param {?} navList
     * @return {?}
     */
    function (navList) {
        var _this = this;
        this.resetNavTriggers();
        if (navList.length > 2) {
            console.error('More than 2 Nav Levels detected.');
            return;
        }
        navList.forEach(function (navLevel) {
            if (navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
                _this.isNavLevel1OnPage = true;
            }
            else if (navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
                _this.isNavLevel2OnPage = true;
            }
        });
    };
    // closes the nav that is open
    // closes the nav that is open
    /**
     * @return {?}
     */
    ClrHeader.prototype.closeOpenNav = 
    // closes the nav that is open
    /**
     * @return {?}
     */
    function () {
        this.responsiveNavService.closeAllNavs();
    };
    // toggles the nav that is open
    // toggles the nav that is open
    /**
     * @param {?} navLevel
     * @return {?}
     */
    ClrHeader.prototype.toggleNav = 
    // toggles the nav that is open
    /**
     * @param {?} navLevel
     * @return {?}
     */
    function (navLevel) {
        this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_TOGGLE, navLevel);
    };
    /**
     * @return {?}
     */
    ClrHeader.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    ClrHeader.decorators = [
        { type: Component, args: [{
                    selector: 'clr-header',
                    template: "\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel1OnPage\"\n            class=\"header-hamburger-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_1)\">\n            <span></span>\n        </button>\n        <ng-content></ng-content>\n        <button\n            type=\"button\"\n            *ngIf=\"isNavLevel2OnPage\"\n            class=\"header-overflow-trigger\"\n            (click)=\"toggleNav(responsiveNavCodes.NAV_LEVEL_2)\">\n            <span></span>\n        </button>\n        <div class=\"header-backdrop\" (click)=\"closeOpenNav()\"></div>\n    ",
                    host: { '[class.header]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrHeader.ctorParameters = function () { return [
        { type: ResponsiveNavigationService }
    ]; };
    return ClrHeader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrNavLevel = /** @class */ (function () {
    function ClrNavLevel(responsiveNavService, elementRef) {
        this.responsiveNavService = responsiveNavService;
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ClrNavLevel.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.level !== ResponsiveNavCodes.NAV_LEVEL_1 && this.level !== ResponsiveNavCodes.NAV_LEVEL_2) {
            console.error('Nav Level can only be 1 or 2');
            return;
        }
        this.responsiveNavService.registerNav(this.level);
        this.addNavClass(this.level);
    };
    /**
     * @param {?} level
     * @return {?}
     */
    ClrNavLevel.prototype.addNavClass = /**
     * @param {?} level
     * @return {?}
     */
    function (level) {
        /** @type {?} */
        var navHostClassList = this.elementRef.nativeElement.classList;
        if (level === ResponsiveNavCodes.NAV_LEVEL_1) {
            navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_1);
        }
        else if (level === ResponsiveNavCodes.NAV_LEVEL_2) {
            navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_2);
        }
    };
    Object.defineProperty(ClrNavLevel.prototype, "level", {
        get: /**
         * @return {?}
         */
        function () {
            return this._level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrNavLevel.prototype, "responsiveNavCodes", {
        // getter to access the responsive navigation codes from the template
        get: 
        // getter to access the responsive navigation codes from the template
        /**
         * @return {?}
         */
        function () {
            return ResponsiveNavCodes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrNavLevel.prototype.open = /**
     * @return {?}
     */
    function () {
        this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, this.level);
    };
    /**
     * @return {?}
     */
    ClrNavLevel.prototype.close = /**
     * @return {?}
     */
    function () {
        this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, this.level);
    };
    // TODO: Figure out whats the best way to do this. Possible methods
    // 1. HostListener (current solution)
    // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
    // why
    // TODO: Figure out whats the best way to do this. Possible methods
    // 1. HostListener (current solution)
    // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
    // why
    /**
     * @param {?} target
     * @return {?}
     */
    ClrNavLevel.prototype.onMouseClick = 
    // TODO: Figure out whats the best way to do this. Possible methods
    // 1. HostListener (current solution)
    // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
    // why
    /**
     * @param {?} target
     * @return {?}
     */
    function (target) {
        /** @type {?} */
        var current = target;
        // Get the element in the DOM on which the mouse was clicked
        /** @type {?} */
        var navHost = this.elementRef.nativeElement;
        // Start checking if current and navHost are equal.
        // If not traverse to the parentNode and check again.
        while (current) {
            if (current === navHost) {
                return;
            }
            else if (current.classList.contains('nav-link')) {
                this.close();
                return;
            }
            current = current.parentNode;
        }
    };
    /**
     * @return {?}
     */
    ClrNavLevel.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.responsiveNavService.unregisterNav(this.level);
    };
    ClrNavLevel.decorators = [
        { type: Directive, args: [{ selector: '[clr-nav-level]' },] }
    ];
    /** @nocollapse */
    ClrNavLevel.ctorParameters = function () { return [
        { type: ResponsiveNavigationService },
        { type: ElementRef }
    ]; };
    ClrNavLevel.propDecorators = {
        _level: [{ type: Input, args: ['clr-nav-level',] }],
        onMouseClick: [{ type: HostListener, args: ['click', ['$event.target'],] }]
    };
    return ClrNavLevel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_NAVIGATION_DIRECTIVES = [
    ClrHeader,
    ClrNavLevel,
    NavDetectionOompaLoompa,
    MainContainerWillyWonka,
];
var ClrNavigationModule = /** @class */ (function () {
    function ClrNavigationModule() {
    }
    ClrNavigationModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule, ClrDropdownModule],
                    declarations: [CLR_NAVIGATION_DIRECTIVES],
                    exports: [CLR_NAVIGATION_DIRECTIVES],
                },] }
    ];
    return ClrNavigationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var TemplateRefContainer = /** @class */ (function () {
    function TemplateRefContainer() {
    }
    TemplateRefContainer.decorators = [
        { type: Component, args: [{
                    template: "\n      <ng-template>\n        <ng-content></ng-content>\n      </ng-template>\n    "
                }] }
    ];
    TemplateRefContainer.propDecorators = {
        template: [{ type: ViewChild, args: [TemplateRef,] }]
    };
    return TemplateRefContainer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var TEMPLATE_REF_DIRECTIVES = [TemplateRefContainer];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTemplateRefModule = /** @class */ (function () {
    function ClrTemplateRefModule() {
    }
    ClrTemplateRefModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    declarations: [TEMPLATE_REF_DIRECTIVES],
                    entryComponents: [TEMPLATE_REF_DIRECTIVES],
                    exports: [TEMPLATE_REF_DIRECTIVES],
                },] }
    ];
    return ClrTemplateRefModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var TabsWillyWonka = /** @class */ (function (_super) {
    __extends(TabsWillyWonka, _super);
    function TabsWillyWonka() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TabsWillyWonka.decorators = [
        { type: Directive, args: [{ selector: 'clr-tabs' },] }
    ];
    return TabsWillyWonka;
}(WillyWonka));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ActiveOompaLoompa = /** @class */ (function (_super) {
    __extends(ActiveOompaLoompa, _super);
    function ActiveOompaLoompa(cdr, willyWonka, id, ifActive) {
        var _this = this;
        if (!willyWonka) {
            throw new Error('clrTabLink and clr-tab-content should only be used inside of a clr-tabs');
        }
        _this = _super.call(this, cdr, willyWonka) || this;
        _this.ifActive = ifActive;
        _this.id = id;
        return _this;
    }
    Object.defineProperty(ActiveOompaLoompa.prototype, "flavor", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ifActive.current === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ActiveOompaLoompa.decorators = [
        { type: Directive, args: [{ selector: '[clrTabLink], clr-tab-content' },] }
    ];
    /** @nocollapse */
    ActiveOompaLoompa.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: TabsWillyWonka, decorators: [{ type: Optional }] },
        { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
        { type: IfActiveService }
    ]; };
    return ActiveOompaLoompa;
}(OompaLoompa));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// TODO: if we find more components that could use this, consider moving this to utils
var AriaService = /** @class */ (function () {
    function AriaService() {
    }
    AriaService.decorators = [
        { type: Injectable }
    ];
    return AriaService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/*
 * Copyright (c) 2016-2019 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
/** @enum {string} */
var TabsLayout = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var TabsService = /** @class */ (function () {
    function TabsService() {
        this._children = [];
        this.layout = TabsLayout.HORIZONTAL;
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    TabsService.prototype.register = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        this._children.push(tab);
    };
    Object.defineProperty(TabsService.prototype, "children", {
        get: /**
         * @return {?}
         */
        function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabsService.prototype, "activeTab", {
        get: /**
         * @return {?}
         */
        function () {
            return this.children.find(function (tab) {
                return tab.active;
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabsService.prototype, "overflowTabs", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.layout === TabsLayout.VERTICAL) {
                return [];
            }
            else {
                return this.children.filter(function (tab) { return tab.tabLink.inOverflow === true; });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} tab
     * @return {?}
     */
    TabsService.prototype.unregister = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        /** @type {?} */
        var index = this.children.indexOf(tab);
        if (index > -1) {
            this.children.splice(index, 1);
        }
    };
    TabsService.decorators = [
        { type: Injectable }
    ];
    return TabsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var nbTabContentComponents = 0;
var ClrTabContent = /** @class */ (function () {
    function ClrTabContent(ifActiveService, id, ariaService) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.ariaService = ariaService;
        if (!this.tabContentId) {
            this.tabContentId = 'clr-tab-content-' + nbTabContentComponents++;
        }
    }
    Object.defineProperty(ClrTabContent.prototype, "ariaLabelledBy", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ariaService.ariaLabelledBy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabContent.prototype, "tabContentId", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ariaService.ariaControls;
        },
        set: /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            this.ariaService.ariaControls = id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabContent.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ifActiveService.current === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ClrTabContent.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tab-content',
                    template: "\n    <ng-template #tabContentProjectedRef>\n      <section [id]=\"tabContentId\" role=\"tabpanel\" [class.active]=\"active\"\n               [hidden]=\"!active\"\n               [attr.aria-labelledby]=\"ariaLabelledBy\"\n               [attr.aria-expanded]=\"active\"\n               [attr.aria-hidden]=\"!active\">\n        <ng-content></ng-content>\n      </section>\n    </ng-template>\n    "
                }] }
    ];
    /** @nocollapse */
    ClrTabContent.ctorParameters = function () { return [
        { type: IfActiveService },
        { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
        { type: AriaService }
    ]; };
    ClrTabContent.propDecorators = {
        templateRef: [{ type: ViewChild, args: ['tabContentProjectedRef',] }],
        tabContentId: [{ type: Input, args: ['id',] }]
    };
    return ClrTabContent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var nbTabsComponent = 0;
/** @type {?} */
var TABS_ID = new InjectionToken('TABS_ID');
/**
 * @return {?}
 */
function tokenFactory$1() {
    return 'clr-tabs-' + nbTabsComponent++;
}
/** @type {?} */
var TABS_ID_PROVIDER = {
    provide: TABS_ID,
    useFactory: tokenFactory$1,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var nbTabLinkComponents = 0;
var ClrTabLink = /** @class */ (function () {
    function ClrTabLink(ifActiveService, id, ariaService, el, cfr, viewContainerRef, tabsService, tabsId) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.ariaService = ariaService;
        this.el = el;
        this.cfr = cfr;
        this.viewContainerRef = viewContainerRef;
        this.tabsService = tabsService;
        this.tabsId = tabsId;
        if (!this.tabLinkId) {
            this.tabLinkId = 'clr-tab-link-' + nbTabLinkComponents++;
        }
        // Tab links can be rendered in one of two places: in the main area or inside the overflow dropdown menu.
        // Here, we create a container so that its template can be used to create embeddedView on the fly.
        // See TabsService's renderView() method and how it's used in Tabs class for an example.
        /** @type {?} */
        var factory = this.cfr.resolveComponentFactory(TemplateRefContainer);
        this.templateRefContainer = this.viewContainerRef.createComponent(factory, 1, undefined, [
            [this.el.nativeElement],
        ]).instance;
    }
    Object.defineProperty(ClrTabLink.prototype, "inOverflow", {
        get: /**
         * @return {?}
         */
        function () {
            return this._inOverflow && this.tabsService.layout !== TabsLayout.VERTICAL;
        },
        set: /**
         * @param {?} inOverflow
         * @return {?}
         */
        function (inOverflow) {
            this._inOverflow = inOverflow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabLink.prototype, "addLinkClasses", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.inOverflow;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabLink.prototype, "ariaControls", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ariaService.ariaControls;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabLink.prototype, "tabLinkId", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ariaService.ariaLabelledBy;
        },
        set: /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            this.ariaService.ariaLabelledBy = id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrTabLink.prototype.activate = /**
     * @return {?}
     */
    function () {
        this.ifActiveService.current = this.id;
    };
    Object.defineProperty(ClrTabLink.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ifActiveService.current === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ClrTabLink.decorators = [
        { type: Directive, args: [{
                    selector: '[clrTabLink]',
                    host: {
                        '[attr.aria-hidden]': 'false',
                        '[class.btn]': 'true',
                        role: 'tab',
                        type: 'button',
                    },
                },] }
    ];
    /** @nocollapse */
    ClrTabLink.ctorParameters = function () { return [
        { type: IfActiveService },
        { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
        { type: AriaService },
        { type: ElementRef },
        { type: ComponentFactoryResolver },
        { type: ViewContainerRef },
        { type: TabsService },
        { type: Number, decorators: [{ type: Inject, args: [TABS_ID,] }] }
    ]; };
    ClrTabLink.propDecorators = {
        inOverflow: [{ type: Input, args: ['clrTabLinkInOverflow',] }],
        addLinkClasses: [{ type: HostBinding, args: ['class.btn-link',] }, { type: HostBinding, args: ['class.nav-link',] }],
        ariaControls: [{ type: HostBinding, args: ['attr.aria-controls',] }],
        tabLinkId: [{ type: HostBinding, args: ['id',] }, { type: Input, args: ['id',] }],
        activate: [{ type: HostListener, args: ['click',] }],
        active: [{ type: HostBinding, args: ['class.active',] }, { type: HostBinding, args: ['attr.aria-selected',] }]
    };
    return ClrTabLink;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTab = /** @class */ (function () {
    function ClrTab(ifActiveService, id, tabsService) {
        this.ifActiveService = ifActiveService;
        this.id = id;
        this.tabsService = tabsService;
        tabsService.register(this);
    }
    /**
     * @return {?}
     */
    ClrTab.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.tabsService.unregister(this);
    };
    Object.defineProperty(ClrTab.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ifActiveService.current === this.id;
        },
        enumerable: true,
        configurable: true
    });
    ClrTab.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tab',
                    template: "\n        <ng-content></ng-content>\n    ",
                    providers: [IF_ACTIVE_ID_PROVIDER, AriaService]
                }] }
    ];
    /** @nocollapse */
    ClrTab.ctorParameters = function () { return [
        { type: IfActiveService },
        { type: Number, decorators: [{ type: Inject, args: [IF_ACTIVE_ID,] }] },
        { type: TabsService }
    ]; };
    ClrTab.propDecorators = {
        tabLink: [{ type: ContentChild, args: [ClrTabLink,] }],
        tabContent: [{ type: ContentChild, args: [ClrTabContent,] }]
    };
    return ClrTab;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTabOverflowContent = /** @class */ (function (_super) {
    __extends(ClrTabOverflowContent, _super);
    function ClrTabOverflowContent(injector, parentHost) {
        var _this = _super.call(this, injector, parentHost) || this;
        _this.anchorPoint = Point.BOTTOM_RIGHT;
        _this.popoverPoint = Point.RIGHT_TOP;
        _this.closeOnOutsideClick = true;
        return _this;
    }
    ClrTabOverflowContent.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tab-overflow-content',
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: {
                        '[class.dropdown-menu]': 'true',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrTabOverflowContent.ctorParameters = function () { return [
        { type: Injector },
        { type: ElementRef, decorators: [{ type: SkipSelf }] }
    ]; };
    return ClrTabOverflowContent;
}(AbstractPopover));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTabs = /** @class */ (function () {
    function ClrTabs(ifActiveService, ifOpenService, tabsService, tabsId, commonStrings) {
        this.ifActiveService = ifActiveService;
        this.ifOpenService = ifOpenService;
        this.tabsService = tabsService;
        this.tabsId = tabsId;
        this.commonStrings = commonStrings;
        this.subscriptions = [];
        this._tabLinkDirectives = [];
    }
    Object.defineProperty(ClrTabs.prototype, "layout", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tabsService.layout;
        },
        set: /**
         * @param {?} layout
         * @return {?}
         */
        function (layout) {
            if (Object.values(TabsLayout).includes(layout)) {
                this.tabsService.layout = layout;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabs.prototype, "tabLinkDirectives", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tabLinkDirectives;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabs.prototype, "tabContents", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tabs.filter(function (tab) { return !!tab.tabContent; }).map(function (tab) { return tab.tabContent; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabs.prototype, "activeTabInOverflow", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTabs.prototype, "tabIds", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tabsService.children.map(function (tab) { return tab.tabLink.tabLinkId; }).join(' ');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrTabs.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._tabLinkDirectives = this.tabs.map(function (tab) { return tab.tabLink; });
        this.subscriptions.push(this.tabs.changes.subscribe(function () {
            _this._tabLinkDirectives = _this.tabs.map(function (tab) { return tab.tabLink; });
        }));
        if (typeof this.ifActiveService.current === 'undefined' && this.tabLinkDirectives[0]) {
            this.tabLinkDirectives[0].activate();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ClrTabs.prototype.toggleOverflow = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.ifOpenService.toggleWithEvent(event);
    };
    Object.defineProperty(ClrTabs.prototype, "isVertical", {
        get: /**
         * @return {?}
         */
        function () {
            return this.layout === TabsLayout.VERTICAL;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrTabs.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (sub) {
            sub.unsubscribe();
        });
    };
    ClrTabs.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tabs',
                    template: "\n        <ul class=\"nav\" role=\"tablist\" [attr.aria-owns]=\"tabIds\">\n            <!--tab links-->\n            <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                <ng-container *ngIf=\"link.tabsId === tabsId && !link.inOverflow\">\n                    <li role=\"presentation\" class=\"nav-item\">\n                        <ng-container [ngTemplateOutlet]=\"link.templateRefContainer.template\"></ng-container>\n                    </li>\n                </ng-container>\n            </ng-container>\n            <ng-container *ngIf=\"tabsService.overflowTabs.length > 0\">\n                <div class=\"tabs-overflow bottom-right\" [class.open]=\"ifOpenService.open\"\n                     (click)=\"toggleOverflow($event)\">\n                    <li role=\"presentation\" class=\"nav-item\">\n                        <button class=\"btn btn-link nav-link dropdown-toggle\" type=\"button\" [class.active]=\"activeTabInOverflow\">\n                            <clr-icon shape=\"ellipsis-horizontal\"\n                              [class.is-info]=\"ifOpenService.open\"\n                              [attr.title]=\"commonStrings.more\"></clr-icon>\n                        </button>\n                    </li>\n                    <!--tab links in overflow menu-->\n                    <clr-tab-overflow-content>\n                        <ng-container *ngFor=\"let link of tabLinkDirectives\">\n                            <ng-container *ngIf=\"link.tabsId === tabsId && link.inOverflow\"\n                                          [ngTemplateOutlet]=\"link.templateRefContainer.template\">\n                            </ng-container>\n                        </ng-container>\n                    </clr-tab-overflow-content>\n                </div>\n            </ng-container>\n        </ul>\n        <!--tab content-->\n        <ng-container *ngFor=\"let content of tabContents\">\n            <ng-container [ngTemplateOutlet]=\"content.templateRef\"></ng-container>\n        </ng-container>\n    ",
                    providers: [IfActiveService, IfOpenService, TabsService, TABS_ID_PROVIDER]
                }] }
    ];
    /** @nocollapse */
    ClrTabs.ctorParameters = function () { return [
        { type: IfActiveService },
        { type: IfOpenService },
        { type: TabsService },
        { type: Number, decorators: [{ type: Inject, args: [TABS_ID,] }] },
        { type: ClrCommonStrings }
    ]; };
    ClrTabs.propDecorators = {
        layout: [{ type: Input, args: ['clrLayout',] }],
        tabs: [{ type: ContentChildren, args: [ClrTab,] }],
        isVertical: [{ type: HostBinding, args: ['class.tabs-vertical',] }]
    };
    return ClrTabs;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_TABS_DIRECTIVES = [
    ClrTabContent,
    ClrTab,
    ClrTabs,
    ClrTabOverflowContent,
    ClrTabLink,
    TabsWillyWonka,
    ActiveOompaLoompa,
];
var ClrTabsModule = /** @class */ (function () {
    function ClrTabsModule() {
    }
    ClrTabsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrCommonPopoverModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule],
                    declarations: [CLR_TABS_DIRECTIVES],
                    exports: [CLR_TABS_DIRECTIVES, ClrConditionalModule],
                },] }
    ];
    return ClrTabsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var VerticalNavGroupRegistrationService = /** @class */ (function () {
    function VerticalNavGroupRegistrationService() {
        this.navGroupCount = 0;
    }
    /**
     * @return {?}
     */
    VerticalNavGroupRegistrationService.prototype.registerNavGroup = /**
     * @return {?}
     */
    function () {
        this.navGroupCount++;
    };
    /**
     * @return {?}
     */
    VerticalNavGroupRegistrationService.prototype.unregisterNavGroup = /**
     * @return {?}
     */
    function () {
        this.navGroupCount--;
    };
    VerticalNavGroupRegistrationService.decorators = [
        { type: Injectable }
    ];
    return VerticalNavGroupRegistrationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var VerticalNavIconService = /** @class */ (function () {
    function VerticalNavIconService() {
        this._icons = 0;
    }
    Object.defineProperty(VerticalNavIconService.prototype, "hasIcons", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icons > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    VerticalNavIconService.prototype.registerIcon = /**
     * @return {?}
     */
    function () {
        this._icons++;
    };
    /**
     * @return {?}
     */
    VerticalNavIconService.prototype.unregisterIcon = /**
     * @return {?}
     */
    function () {
        this._icons--;
    };
    VerticalNavIconService.decorators = [
        { type: Injectable }
    ];
    return VerticalNavIconService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var VerticalNavService = /** @class */ (function () {
    function VerticalNavService() {
        this._animateOnCollapsed = new Subject();
        this._collapsedChanged = new Subject();
        this._collapsed = false;
        this._collapsible = false;
    }
    Object.defineProperty(VerticalNavService.prototype, "animateOnCollapsed", {
        get: /**
         * @return {?}
         */
        function () {
            return this._animateOnCollapsed.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VerticalNavService.prototype, "collapsedChanged", {
        get: /**
         * @return {?}
         */
        function () {
            return this._collapsedChanged.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VerticalNavService.prototype, "collapsed", {
        get: /**
         * @return {?}
         */
        function () {
            return this._collapsed;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = !!value;
            if (this.collapsible && this._collapsed !== value) {
                this.updateCollapseBehavior(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VerticalNavService.prototype, "collapsible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._collapsible;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = !!value;
            if (this._collapsible !== value) {
                if (!value && this.collapsed) {
                    this.updateCollapseBehavior(false);
                }
                this._collapsible = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    VerticalNavService.prototype.updateCollapseBehavior = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._animateOnCollapsed.next(value);
        this._collapsed = value;
        this._collapsedChanged.next(value);
    };
    VerticalNavService.decorators = [
        { type: Injectable }
    ];
    return VerticalNavService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrVerticalNav = /** @class */ (function () {
    function ClrVerticalNav(_navService, _navIconService, _navGroupRegistrationService, commonStrings) {
        var _this = this;
        this._navService = _navService;
        this._navIconService = _navIconService;
        this._navGroupRegistrationService = _navGroupRegistrationService;
        this.commonStrings = commonStrings;
        this._collapsedChanged = new EventEmitter(true);
        this._sub = this._navService.collapsedChanged.subscribe(function (value) {
            _this._collapsedChanged.emit(value);
        });
    }
    Object.defineProperty(ClrVerticalNav.prototype, "collapsible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._navService.collapsible;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._navService.collapsible = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrVerticalNav.prototype, "collapsed", {
        get: /**
         * @return {?}
         */
        function () {
            return this._navService.collapsed;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._navService.collapsed = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrVerticalNav.prototype, "hasNavGroups", {
        get: /**
         * @return {?}
         */
        function () {
            return this._navGroupRegistrationService.navGroupCount > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrVerticalNav.prototype, "hasIcons", {
        get: /**
         * @return {?}
         */
        function () {
            return this._navIconService.hasIcons;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrVerticalNav.prototype.toggleByButton = /**
     * @return {?}
     */
    function () {
        this.collapsed = !this.collapsed;
    };
    /**
     * @return {?}
     */
    ClrVerticalNav.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._sub.unsubscribe();
    };
    ClrVerticalNav.decorators = [
        { type: Component, args: [{
                    selector: 'clr-vertical-nav',
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<button type=\"button\" class=\"nav-trigger\"\n        [class.on-collapse]=\"collapsed\"\n        (click)=\"toggleByButton()\"\n        *ngIf=\"collapsible\">\n    <clr-icon shape=\"angle-double\"\n              class=\"nav-trigger-icon\"\n              [attr.dir]=\"(this.collapsed) ? 'right' : 'left'\"\n              [attr.title]=\"(this.collapsed) ? commonStrings.expand : commonStrings.collapse\"></clr-icon>\n</button>\n<!-- Click handler on .nav-content is bad but required :-( -->\n<div class=\"nav-content\">\n    <ng-content></ng-content>\n    <button (click)=\"collapsed = false\" class=\"nav-btn\" *ngIf=\"collapsible && collapsed\"></button>\n</div>\n",
                    providers: [VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService],
                    host: {
                        class: 'clr-vertical-nav',
                        '[class.is-collapsed]': 'collapsed',
                        '[class.has-nav-groups]': 'hasNavGroups',
                        '[class.has-icons]': 'hasIcons',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrVerticalNav.ctorParameters = function () { return [
        { type: VerticalNavService },
        { type: VerticalNavIconService },
        { type: VerticalNavGroupRegistrationService },
        { type: ClrCommonStrings }
    ]; };
    ClrVerticalNav.propDecorators = {
        collapsible: [{ type: Input, args: ['clrVerticalNavCollapsible',] }],
        collapsed: [{ type: Input, args: ['clrVerticalNavCollapsed',] }],
        _collapsedChanged: [{ type: Output, args: ['clrVerticalNavCollapsedChange',] }]
    };
    return ClrVerticalNav;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var VerticalNavGroupService = /** @class */ (function () {
    function VerticalNavGroupService() {
        this._expandChange = new Subject();
    }
    Object.defineProperty(VerticalNavGroupService.prototype, "expandChange", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expandChange.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    VerticalNavGroupService.prototype.expand = /**
     * @return {?}
     */
    function () {
        this._expandChange.next(true);
    };
    VerticalNavGroupService.decorators = [
        { type: Injectable }
    ];
    return VerticalNavGroupService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var EXPANDED_STATE = 'expanded';
/** @type {?} */
var COLLAPSED_STATE = 'collapsed';
var ClrVerticalNavGroup = /** @class */ (function () {
    function ClrVerticalNavGroup(_itemExpand, _navGroupRegistrationService, _navGroupService, _navService, commonStrings) {
        var _this = this;
        this._itemExpand = _itemExpand;
        this._navGroupRegistrationService = _navGroupRegistrationService;
        this._navGroupService = _navGroupService;
        this._navService = _navService;
        this.commonStrings = commonStrings;
        this.wasExpanded = false;
        this.expandedChange = new EventEmitter(true);
        this._subscriptions = [];
        this._expandAnimationState = COLLAPSED_STATE;
        this._navGroupRegistrationService.registerNavGroup();
        // FIXME: This subscription handles a corner case
        // Vertical Nav collapse requires the animation to run first and then
        // remove the nodes from the DOM. If the user directly sets the input
        // on the clrIfExpanded directive, we have no chance to run the animation
        // and wait for it to complete. This subscription makes sure that the
        // animation states are correct for that edge case.
        this._subscriptions.push(this._itemExpand.expandChange.subscribe(function (value) {
            if (value && _this.expandAnimationState === COLLAPSED_STATE) {
                if (_this._navService.collapsed) {
                    _this._navService.collapsed = false;
                }
                _this.expandAnimationState = EXPANDED_STATE;
            }
            else if (!value && _this.expandAnimationState === EXPANDED_STATE) {
                _this.expandAnimationState = COLLAPSED_STATE;
            }
        }));
        // 1. If the nav is collapsing, close the open nav group + save its state
        // 2. If the nav is expanding, expand the nav group if the previous state was expanded
        this._subscriptions.push(this._navService.animateOnCollapsed.subscribe(function (goingToCollapse) {
            if (goingToCollapse && _this.expanded) {
                _this.wasExpanded = true;
                _this.expandAnimationState = COLLAPSED_STATE;
            }
            else if (!goingToCollapse && _this.wasExpanded) {
                _this.expandGroup();
                _this.wasExpanded = false;
            }
        }));
        // If a link is clicked, expand the nav group
        this._subscriptions.push(this._navGroupService.expandChange.subscribe(function (expand) {
            if (expand && !_this.expanded) {
                _this.expandGroup();
            }
        }));
    }
    Object.defineProperty(ClrVerticalNavGroup.prototype, "expanded", {
        get: /**
         * @return {?}
         */
        function () {
            return this._itemExpand.expanded;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._itemExpand.expanded !== value) {
                this._itemExpand.expanded = value;
                this.expandedChange.emit(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrVerticalNavGroup.prototype, "userExpandedInput", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = !!value;
            if (this.expanded !== value) {
                // We have to call toggleExpand because some cases require animations to occur first
                // Directly setting the Expand service value skips the animation and can result in
                // nodes in the DOM but the nav group still being collapsed
                this.toggleExpand();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrVerticalNavGroup.prototype.expandGroup = /**
     * @return {?}
     */
    function () {
        this.expanded = true;
        // Expanded animation occurs after Expand.expand is set to true
        this.expandAnimationState = EXPANDED_STATE;
    };
    /**
     * @return {?}
     */
    ClrVerticalNavGroup.prototype.collapseGroup = /**
     * @return {?}
     */
    function () {
        // If a Vertical Nav Group toggle button is clicked while the Vertical Nav is in Collapsed state,
        // the Vertical Nav should be expanded first.
        this.expandAnimationState = COLLAPSED_STATE;
    };
    // closes a group after the collapse animation
    // closes a group after the collapse animation
    /**
     * @param {?} $event
     * @return {?}
     */
    ClrVerticalNavGroup.prototype.expandAnimationDone = 
    // closes a group after the collapse animation
    /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if ($event.toState === COLLAPSED_STATE) {
            this.expanded = false;
        }
    };
    Object.defineProperty(ClrVerticalNavGroup.prototype, "expandAnimationState", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expandAnimationState;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._expandAnimationState) {
                this._expandAnimationState = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrVerticalNavGroup.prototype.toggleExpand = /**
     * @return {?}
     */
    function () {
        if (this.expanded) {
            this.collapseGroup();
        }
        else {
            // If nav is collasped, first open the nav
            if (this._navService.collapsed) {
                this._navService.collapsed = false;
            }
            // then expand the nav group
            this.expandGroup();
        }
    };
    /**
     * @return {?}
     */
    ClrVerticalNavGroup.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        // This makes sure that if someone marks a nav group expanded in a collapsed nav
        // the expanded property is switched back to collapsed state.
        if (this._navService.collapsed && this.expanded) {
            this.wasExpanded = true;
            this.expandAnimationState = COLLAPSED_STATE;
        }
    };
    /**
     * @return {?}
     */
    ClrVerticalNavGroup.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscriptions.forEach(function (sub) { return sub.unsubscribe(); });
        this._navGroupRegistrationService.unregisterNavGroup();
    };
    ClrVerticalNavGroup.decorators = [
        { type: Component, args: [{
                    selector: 'clr-vertical-nav-group',
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class=\"nav-group-content\">\n    <ng-content select=\"[clrVerticalNavLink]\"></ng-content>\n    <button\n        class=\"nav-group-trigger\"\n        type=\"button\"\n        (click)=\"toggleExpand()\">\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <div class=\"nav-group-text\">\n            <ng-content></ng-content>\n        </div>\n        <clr-icon shape=\"caret\"\n                  class=\"nav-group-trigger-icon\"\n                  [attr.dir]=\"(this.expanded) ? 'down' : 'right'\"\n                  [attr.title]=\"(this.expanded) ? commonStrings.collapse : commonStrings.expand\">\n        </clr-icon>\n    </button>\n</div>\n<!--TODO: This animation needs to be added to the clr-vertical-nav-group-children component-->\n<div class=\"nav-group-children\"\n     [@clrExpand]=\"expandAnimationState\"\n     (@clrExpand.done)=\"expandAnimationDone($event)\">\n    <ng-content select=\"[clrIfExpanded], clr-vertical-nav-group-children\"></ng-content>\n</div>\n",
                    providers: [Expand, VerticalNavGroupService],
                    animations: [
                        trigger('clrExpand', [
                            state(EXPANDED_STATE, style({ height: '*' })),
                            state(COLLAPSED_STATE, style({ height: 0, 'overflow-y': 'hidden', visibility: 'hidden' })),
                            transition(EXPANDED_STATE + " <=> " + COLLAPSED_STATE, animate('0.2s ease-in-out')),
                        ]),
                    ],
                    host: { class: 'nav-group' }
                }] }
    ];
    /** @nocollapse */
    ClrVerticalNavGroup.ctorParameters = function () { return [
        { type: Expand },
        { type: VerticalNavGroupRegistrationService },
        { type: VerticalNavGroupService },
        { type: VerticalNavService },
        { type: ClrCommonStrings }
    ]; };
    ClrVerticalNavGroup.propDecorators = {
        expanded: [{ type: HostBinding, args: ['class.is-expanded',] }],
        userExpandedInput: [{ type: Input, args: ['clrVerticalNavGroupExpanded',] }],
        expandedChange: [{ type: Output, args: ['clrVerticalNavGroupExpandedChange',] }]
    };
    return ClrVerticalNavGroup;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrVerticalNavGroupChildren = /** @class */ (function () {
    function ClrVerticalNavGroupChildren() {
    }
    ClrVerticalNavGroupChildren.decorators = [
        { type: Component, args: [{
                    selector: 'clr-vertical-nav-group-children',
                    template: "\n        <ng-content></ng-content>\n    "
                }] }
    ];
    return ClrVerticalNavGroupChildren;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrVerticalNavIcon = /** @class */ (function () {
    function ClrVerticalNavIcon(_verticalNavIconService) {
        this._verticalNavIconService = _verticalNavIconService;
        this._verticalNavIconService.registerIcon();
    }
    /**
     * @return {?}
     */
    ClrVerticalNavIcon.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._verticalNavIconService.unregisterIcon();
    };
    ClrVerticalNavIcon.decorators = [
        { type: Directive, args: [{ selector: '[clrVerticalNavIcon]', host: { class: 'nav-icon' } },] }
    ];
    /** @nocollapse */
    ClrVerticalNavIcon.ctorParameters = function () { return [
        { type: VerticalNavIconService }
    ]; };
    return ClrVerticalNavIcon;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrVerticalNavLink = /** @class */ (function () {
    function ClrVerticalNavLink(_navGroupService) {
        this._navGroupService = _navGroupService;
    }
    /**
     * @return {?}
     */
    ClrVerticalNavLink.prototype.expandParentNavGroup = /**
     * @return {?}
     */
    function () {
        if (this._navGroupService) {
            this._navGroupService.expand();
        }
    };
    ClrVerticalNavLink.decorators = [
        { type: Component, args: [{
                    selector: '[clrVerticalNavLink]',
                    template: "\n        <ng-content select=\"[clrVerticalNavIcon]\"></ng-content>\n        <span class=\"nav-text\">\n            <ng-content></ng-content>    \n        </span>\n    ",
                    host: { class: 'nav-link' }
                }] }
    ];
    /** @nocollapse */
    ClrVerticalNavLink.ctorParameters = function () { return [
        { type: VerticalNavGroupService, decorators: [{ type: Optional }] }
    ]; };
    ClrVerticalNavLink.propDecorators = {
        expandParentNavGroup: [{ type: HostListener, args: ['click',] }]
    };
    return ClrVerticalNavLink;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_VERTICAL_NAV_DIRECTIVES = [
    ClrVerticalNav,
    ClrVerticalNavLink,
    ClrVerticalNavGroup,
    ClrVerticalNavGroupChildren,
    ClrVerticalNavIcon,
];
var ClrVerticalNavModule = /** @class */ (function () {
    function ClrVerticalNavModule() {
    }
    ClrVerticalNavModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule, ClrIfExpandModule],
                    declarations: [CLR_VERTICAL_NAV_DIRECTIVES],
                    exports: [CLR_VERTICAL_NAV_DIRECTIVES, ClrIfExpandModule, ClrIconModule],
                },] }
    ];
    return ClrVerticalNavModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrLayoutModule = /** @class */ (function () {
    function ClrLayoutModule() {
    }
    ClrLayoutModule.decorators = [
        { type: NgModule, args: [{ exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule] },] }
    ];
    return ClrLayoutModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ScrollingService = /** @class */ (function () {
    function ScrollingService(_document) {
        this._document = _document;
    }
    /**
     * @return {?}
     */
    ScrollingService.prototype.stopScrolling = /**
     * @return {?}
     */
    function () {
        this._document.body.classList.add('no-scrolling');
    };
    /**
     * @return {?}
     */
    ScrollingService.prototype.resumeScrolling = /**
     * @return {?}
     */
    function () {
        if (this._document.body.classList.contains('no-scrolling')) {
            this._document.body.classList.remove('no-scrolling');
        }
    };
    ScrollingService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    ScrollingService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    return ScrollingService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrModal = /** @class */ (function () {
    function ClrModal(_scrollingService, commonStrings, modalId) {
        this._scrollingService = _scrollingService;
        this.commonStrings = commonStrings;
        this.modalId = modalId;
        this._open = false;
        this._openChanged = new EventEmitter(false);
        this.closable = true;
        this.staticBackdrop = true;
        this.skipAnimation = 'false';
        // presently this is only used by wizards
        this.bypassScrollService = false;
        this.stopClose = false;
        this.altClose = new EventEmitter(false);
    }
    Object.defineProperty(ClrModal.prototype, "sizeClass", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.size) {
                return 'modal-' + this.size;
            }
            else {
                return '';
            }
        },
        enumerable: true,
        configurable: true
    });
    // Detect when _open is set to true and set no-scrolling to true
    // Detect when _open is set to true and set no-scrolling to true
    /**
     * @param {?} changes
     * @return {?}
     */
    ClrModal.prototype.ngOnChanges = 
    // Detect when _open is set to true and set no-scrolling to true
    /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!this.bypassScrollService && changes && changes.hasOwnProperty('_open')) {
            if (changes._open.currentValue) {
                this._scrollingService.stopScrolling();
            }
            else {
                this._scrollingService.resumeScrolling();
            }
        }
    };
    /**
     * @return {?}
     */
    ClrModal.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._scrollingService.resumeScrolling();
    };
    /**
     * @return {?}
     */
    ClrModal.prototype.open = /**
     * @return {?}
     */
    function () {
        if (this._open) {
            return;
        }
        this._open = true;
        this._openChanged.emit(true);
    };
    /**
     * @return {?}
     */
    ClrModal.prototype.close = /**
     * @return {?}
     */
    function () {
        if (this.stopClose) {
            this.altClose.emit(false);
            return;
        }
        if (!this.closable || !this._open) {
            return;
        }
        this._open = false;
        // todo: remove this after animation bug is fixed https://github.com/angular/angular/issues/15798
        // this was handled by the fadeDone event below, but that AnimationEvent is not firing in Angular 4.0.
        this._openChanged.emit(false);
        // SPECME
        this.focusTrap.setPreviousFocus(); // Handles moving focus back to the element that had it before.
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ClrModal.prototype.fadeDone = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
        if (e.toState === 'void') {
            this._openChanged.emit(false);
        }
    };
    ClrModal.decorators = [
        { type: Component, args: [{
                    selector: 'clr-modal',
                    viewProviders: [ScrollingService],
                    template: "\n<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div clrFocusTrap class=\"modal\" *ngIf=\"_open\">\n    <!--fixme: revisit when ngClass works with exit animation-->\n    <div [@fadeDown]=\"skipAnimation\" (@fadeDown.done)=\"fadeDone($event)\"\n         class=\"modal-dialog\"\n         [class.modal-sm]=\"size == 'sm'\"\n         [class.modal-lg]=\"size == 'lg'\"\n         [class.modal-xl]=\"size == 'xl'\"\n         role=\"dialog\"\n         [attr.aria-hidden]=\"!_open\"\n         [attr.aria-labelledby]=\"modalId\">\n\n      <div class=\"modal-content-wrapper\">\n        <!-- only used in wizards -->\n        <ng-content select=\".modal-nav\"></ng-content>\n\n        <div class=\"modal-content\">\n          <div class=\"modal-header\">\n            <button type=\"button\" class=\"close\" *ngIf=\"closable\" (click)=\"close()\">\n              <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n            </button>\n            <div class=\"modal-title-wrapper\" id=\"{{modalId}}\">\n              <ng-content select=\".modal-title\"></ng-content>\n            </div>\n          </div>\n          <ng-content select=\".modal-body\"></ng-content>\n          <ng-content select=\".modal-footer\"></ng-content>\n        </div>\n      </div>\n    </div>\n\n    <div [@fade] class=\"modal-backdrop\"\n         aria-hidden=\"true\"\n         (click)=\"staticBackdrop || close()\"></div>\n</div>\n\n",
                    animations: [
                        trigger('fadeDown', [
                            transition('* => false', [style({ opacity: 0, transform: 'translate(0, -25%)' }), animate('0.2s ease-in-out')]),
                            transition('false => *', [animate('0.2s ease-in-out', style({ opacity: 0, transform: 'translate(0, -25%)' }))]),
                        ]),
                        trigger('fade', [
                            transition('void => *', [style({ opacity: 0 }), animate('0.2s ease-in-out', style({ opacity: 0.85 }))]),
                            transition('* => void', [animate('0.2s ease-in-out', style({ opacity: 0 }))]),
                        ]),
                    ],
                    providers: [UNIQUE_ID_PROVIDER],
                    styles: ["\n        :host { display: none; }\n        :host.open { display: inline; }\n    "]
                }] }
    ];
    /** @nocollapse */
    ClrModal.ctorParameters = function () { return [
        { type: ScrollingService },
        { type: ClrCommonStrings },
        { type: String, decorators: [{ type: Inject, args: [UNIQUE_ID,] }] }
    ]; };
    ClrModal.propDecorators = {
        focusTrap: [{ type: ViewChild, args: [FocusTrapDirective,] }],
        _open: [{ type: HostBinding, args: ['class.open',] }, { type: Input, args: ['clrModalOpen',] }],
        _openChanged: [{ type: Output, args: ['clrModalOpenChange',] }],
        closable: [{ type: Input, args: ['clrModalClosable',] }],
        size: [{ type: Input, args: ['clrModalSize',] }],
        staticBackdrop: [{ type: Input, args: ['clrModalStaticBackdrop',] }],
        skipAnimation: [{ type: Input, args: ['clrModalSkipAnimation',] }],
        bypassScrollService: [{ type: Input, args: ['clrModalOverrideScrollService',] }],
        stopClose: [{ type: Input, args: ['clrModalPreventClose',] }],
        altClose: [{ type: Output, args: ['clrModalAlternateClose',] }],
        close: [{ type: HostListener, args: ['body:keyup.escape',] }]
    };
    return ClrModal;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_MODAL_DIRECTIVES = [ClrModal];
var ClrModalModule = /** @class */ (function () {
    function ClrModalModule() {
    }
    ClrModalModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrIconModule, ClrFocusTrapModule],
                    declarations: [CLR_MODAL_DIRECTIVES],
                    exports: [CLR_MODAL_DIRECTIVES],
                },] }
    ];
    return ClrModalModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var SIGNPOST_POSITIONS = {
    'top-left': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_RIGHT, offsetY: -10, offsetX: 0 },
    'top-middle': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_CENTER, offsetY: -10, offsetX: 0 },
    'top-right': { anchorPoint: Point.TOP_CENTER, popoverPoint: Point.BOTTOM_LEFT, offsetY: -10, offsetX: 0 },
    'right-top': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_BOTTOM, offsetY: 2, offsetX: 14 },
    'right-middle': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
    'right-bottom': { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_TOP, offsetY: -1, offsetX: 14 },
    'bottom-right': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_LEFT, offsetY: 9, offsetX: -1 },
    'bottom-middle': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_CENTER, offsetY: 9, offsetX: 12 },
    'bottom-left': { anchorPoint: Point.BOTTOM_CENTER, popoverPoint: Point.TOP_RIGHT, offsetY: 9, offsetX: 0 },
    'left-bottom': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_TOP, offsetY: 0, offsetX: -14 },
    'left-middle': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_CENTER, offsetY: 4, offsetX: -14 },
    'left-top': { anchorPoint: Point.LEFT_CENTER, popoverPoint: Point.RIGHT_BOTTOM, offsetY: 0, offsetX: -14 },
    default: { anchorPoint: Point.RIGHT_CENTER, popoverPoint: Point.LEFT_CENTER, offsetY: 6, offsetX: 14 },
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
// aka where the arrow / pointer is at in relation to the anchor
/** @type {?} */
var POSITIONS = [
    'top-left',
    'top-middle',
    'top-right',
    'right-top',
    'right-middle',
    'right-bottom',
    'bottom-right',
    'bottom-middle',
    'bottom-left',
    'left-bottom',
    'left-middle',
    'left-top',
];
var ClrSignpostContent = /** @class */ (function (_super) {
    __extends(ClrSignpostContent, _super);
    function ClrSignpostContent(injector, parentHost, commonStrings) {
        var _this = this;
        if (!parentHost) {
            throw new Error('clr-signpost-content should only be used inside of a clr-signpost');
        }
        _this = _super.call(this, injector, parentHost) || this;
        _this.commonStrings = commonStrings;
        // Defaults
        _this.position = 'right-middle';
        _this.closeOnOutsideClick = true;
        return _this;
    }
    /**********
     *
     * @description
     * Close function that uses the signpost instance to toggle the state of the content popover.
     *
     */
    /**
     * *******
     *
     * \@description
     * Close function that uses the signpost instance to toggle the state of the content popover.
     *
     * @return {?}
     */
    ClrSignpostContent.prototype.close = /**
     * *******
     *
     * \@description
     * Close function that uses the signpost instance to toggle the state of the content popover.
     *
     * @return {?}
     */
    function () {
        this.ifOpenService.open = false;
    };
    Object.defineProperty(ClrSignpostContent.prototype, "position", {
        get: /**
         * @return {?}
         */
        function () {
            return this._position;
        },
        /*********
         *
         * @description
         * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
         * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
         * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
         * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
         * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
         * There are 12 possible positions to place a ClrSignpostContent container:
         * - top-left
         * - top-middle
         * - top-right
         * - right-top
         * - right-middle
         * - right-bottom
         * - bottom-right
         * - bottom-middle
         * - bottom-left
         * - left-bottom
         * - left-middle
         * - left-top
         *
         * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
         * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
         * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
         * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
         *
         * @param newPosition
         */
        set: /**
         * ******
         *
         * \@description
         * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
         * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
         * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
         * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
         * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
         * There are 12 possible positions to place a ClrSignpostContent container:
         * - top-left
         * - top-middle
         * - top-right
         * - right-top
         * - right-middle
         * - right-bottom
         * - bottom-right
         * - bottom-middle
         * - bottom-left
         * - left-bottom
         * - left-middle
         * - left-top
         *
         * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
         * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
         * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
         * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
         *
         * @param {?} position
         * @return {?}
         */
        function (position) {
            // Ugh
            this.renderer.removeClass(this.el.nativeElement, this.position);
            if (position && POSITIONS.indexOf(position) > -1) {
                this._position = position;
            }
            else {
                this._position = 'right-middle';
            }
            // Ugh
            this.renderer.addClass(this.el.nativeElement, this.position);
            /** @type {?} */
            var setPosition = SIGNPOST_POSITIONS[this.position];
            this.anchorPoint = setPosition.anchorPoint;
            this.popoverPoint = setPosition.popoverPoint;
            this.popoverOptions.offsetY = setPosition.offsetY;
            this.popoverOptions.offsetX = setPosition.offsetX;
        },
        enumerable: true,
        configurable: true
    });
    ClrSignpostContent.decorators = [
        { type: Component, args: [{
                    selector: 'clr-signpost-content',
                    template: "\n        <div class=\"signpost-flex-wrap\">\n            <div class=\"popover-pointer\"></div>\n            <div class=\"signpost-content-header\">\n                <button type=\"button\" class=\"signpost-action close\" (click)=\"close()\">\n                    <clr-icon shape=\"close\" [attr.title]=\"commonStrings.close\"></clr-icon>\n                </button>\n            </div>\n            <div class=\"signpost-content-body\">\n                <ng-content></ng-content>\n            </div>\n        </div>\n    ",
                    host: { '[class.signpost-content]': 'true' }
                }] }
    ];
    /** @nocollapse */
    ClrSignpostContent.ctorParameters = function () { return [
        { type: Injector },
        { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [POPOVER_HOST_ANCHOR,] }] },
        { type: ClrCommonStrings }
    ]; };
    ClrSignpostContent.propDecorators = {
        position: [{ type: Input, args: ['clrPosition',] }]
    };
    return ClrSignpostContent;
}(AbstractPopover));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_SIGNPOST_DIRECTIVES = [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger];
var ClrSignpostModule = /** @class */ (function () {
    function ClrSignpostModule() {
    }
    ClrSignpostModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrCommonPopoverModule, ClrIconModule],
                    declarations: [CLR_SIGNPOST_DIRECTIVES],
                    exports: [CLR_SIGNPOST_DIRECTIVES, ClrConditionalModule],
                },] }
    ];
    return ClrSignpostModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTooltip = /** @class */ (function () {
    function ClrTooltip() {
    }
    ClrTooltip.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tooltip',
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: {
                        '[class.tooltip]': 'true',
                    },
                    providers: [IfOpenService, { provide: POPOVER_HOST_ANCHOR, useExisting: ElementRef }]
                }] }
    ];
    return ClrTooltip;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var POSITIONS$1 = ['bottom-left', 'bottom-right', 'top-left', 'top-right', 'right', 'left'];
/** @type {?} */
var SIZES = ['xs', 'sm', 'md', 'lg'];
var ClrTooltipContent = /** @class */ (function (_super) {
    __extends(ClrTooltipContent, _super);
    function ClrTooltipContent(injector, parentHost) {
        var _this = this;
        if (!parentHost) {
            throw new Error('clr-tooltip-content should only be used inside of a clr-tooltip');
        }
        _this = _super.call(this, injector, parentHost) || this;
        // Defaults
        _this.position = 'right';
        _this.size = 'sm';
        return _this;
    }
    Object.defineProperty(ClrTooltipContent.prototype, "position", {
        get: /**
         * @return {?}
         */
        function () {
            return this._position;
        },
        set: /**
         * @param {?} position
         * @return {?}
         */
        function (position) {
            // Ugh
            this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.position);
            if (position && POSITIONS$1.indexOf(position) > -1) {
                this._position = position;
            }
            else {
                this._position = 'right';
            }
            // Ugh
            this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.position);
            // set the popover values based on direction
            switch (position) {
                case 'top-right':
                    this.anchorPoint = Point.TOP_CENTER;
                    this.popoverPoint = Point.LEFT_BOTTOM;
                    break;
                case 'top-left':
                    this.anchorPoint = Point.TOP_CENTER;
                    this.popoverPoint = Point.RIGHT_BOTTOM;
                    break;
                case 'bottom-right':
                    this.anchorPoint = Point.BOTTOM_CENTER;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
                case 'bottom-left':
                    this.anchorPoint = Point.BOTTOM_CENTER;
                    this.popoverPoint = Point.RIGHT_TOP;
                    break;
                case 'right':
                    this.anchorPoint = Point.RIGHT_CENTER;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
                case 'left':
                    this.anchorPoint = Point.LEFT_CENTER;
                    this.popoverPoint = Point.RIGHT_TOP;
                    break;
                default:
                    this.anchorPoint = Point.RIGHT_CENTER;
                    this.popoverPoint = Point.LEFT_TOP;
                    break;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrTooltipContent.prototype, "size", {
        get: /**
         * @return {?}
         */
        function () {
            return this._size;
        },
        set: /**
         * @param {?} size
         * @return {?}
         */
        function (size) {
            // Ugh
            this.renderer.removeClass(this.el.nativeElement, 'tooltip-' + this.size);
            if (size && SIZES.indexOf(size) > -1) {
                this._size = size;
            }
            else {
                this._size = 'sm';
            }
            // Ugh
            this.renderer.addClass(this.el.nativeElement, 'tooltip-' + this.size);
        },
        enumerable: true,
        configurable: true
    });
    ClrTooltipContent.decorators = [
        { type: Component, args: [{
                    selector: 'clr-tooltip-content',
                    template: "\n        <ng-content></ng-content>\n    ",
                    host: {
                        '[class.tooltip-content]': 'true',
                        // I'm giving up on animation, they did not work before and will not work now.
                        // Too many conflicts with Clarity UI.
                        '[style.opacity]': '1',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrTooltipContent.ctorParameters = function () { return [
        { type: Injector },
        { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [POPOVER_HOST_ANCHOR,] }] }
    ]; };
    ClrTooltipContent.propDecorators = {
        position: [{ type: Input, args: ['clrPosition',] }],
        size: [{ type: Input, args: ['clrSize',] }]
    };
    return ClrTooltipContent;
}(AbstractPopover));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrTooltipTrigger = /** @class */ (function () {
    function ClrTooltipTrigger(ifOpenService) {
        this.ifOpenService = ifOpenService;
    }
    /**
     * @return {?}
     */
    ClrTooltipTrigger.prototype.showTooltip = /**
     * @return {?}
     */
    function () {
        this.ifOpenService.open = true;
    };
    /**
     * @return {?}
     */
    ClrTooltipTrigger.prototype.hideTooltip = /**
     * @return {?}
     */
    function () {
        this.ifOpenService.open = false;
    };
    ClrTooltipTrigger.decorators = [
        { type: Directive, args: [{ selector: '[clrTooltipTrigger]', host: { '[attr.tabindex]': '0', '[class.tooltip-trigger]': 'true' } },] }
    ];
    /** @nocollapse */
    ClrTooltipTrigger.ctorParameters = function () { return [
        { type: IfOpenService }
    ]; };
    ClrTooltipTrigger.propDecorators = {
        showTooltip: [{ type: HostListener, args: ['mouseenter',] }, { type: HostListener, args: ['focus',] }],
        hideTooltip: [{ type: HostListener, args: ['mouseleave',] }, { type: HostListener, args: ['blur',] }]
    };
    return ClrTooltipTrigger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_TOOLTIP_DIRECTIVES = [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent];
var ClrTooltipModule = /** @class */ (function () {
    function ClrTooltipModule() {
    }
    ClrTooltipModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrCommonPopoverModule],
                    declarations: [CLR_TOOLTIP_DIRECTIVES],
                    exports: [CLR_TOOLTIP_DIRECTIVES, ClrConditionalModule, ClrIconModule],
                },] }
    ];
    return ClrTooltipModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrPopoverModule = /** @class */ (function () {
    function ClrPopoverModule() {
    }
    ClrPopoverModule.decorators = [
        { type: NgModule, args: [{ exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule] },] }
    ];
    return ClrPopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ButtonHubService = /** @class */ (function () {
    function ButtonHubService() {
        this.buttonsReady = false;
        this._previousBtnClicked = new Subject();
        this._nextBtnClicked = new Subject();
        this._dangerBtnClicked = new Subject();
        this._cancelBtnClicked = new Subject();
        this._finishBtnClicked = new Subject();
        this._customBtnClicked = new Subject();
    }
    Object.defineProperty(ButtonHubService.prototype, "previousBtnClicked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._previousBtnClicked.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonHubService.prototype, "nextBtnClicked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._nextBtnClicked.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonHubService.prototype, "dangerBtnClicked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dangerBtnClicked.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonHubService.prototype, "cancelBtnClicked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._cancelBtnClicked.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonHubService.prototype, "finishBtnClicked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._finishBtnClicked.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ButtonHubService.prototype, "customBtnClicked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._customBtnClicked.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} buttonType
     * @return {?}
     */
    ButtonHubService.prototype.buttonClicked = /**
     * @param {?} buttonType
     * @return {?}
     */
    function (buttonType) {
        if ('previous' === buttonType) {
            this._previousBtnClicked.next();
        }
        else if ('next' === buttonType) {
            this._nextBtnClicked.next();
        }
        else if ('finish' === buttonType) {
            this._finishBtnClicked.next();
        }
        else if ('danger' === buttonType) {
            this._dangerBtnClicked.next();
        }
        else if ('cancel' === buttonType) {
            this._cancelBtnClicked.next();
        }
        else {
            this._customBtnClicked.next(buttonType);
        }
    };
    ButtonHubService.decorators = [
        { type: Injectable }
    ];
    return ButtonHubService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * PageCollectionService manages the collection of pages assigned to the wizard and offers
 * a number of functions useful across the wizards providers and subcomponents -- all related
 * to essentially lookups on the collection of pages.
 *
 * The easiest way to access PageCollectionService is via the wizard. The
 * following example would allow you to access your instance of the wizard from your host
 * component and thereby access the page collection via YourHostComponent.wizard.pageCollection.
 *
 * \@example
 * <clr-wizard #wizard ...>
 *
 * \@example
 * export class YourHostComponent {
 * \@ViewChild("wizard") wizard: Wizard;
 *   ...
 * }
 *
 * The heart of the page collection is the query list of pages, which it is assigned as a
 * reference to the Wizard.pages QueryList when the wizard is created.
 *
 */
var PageCollectionService = /** @class */ (function () {
    function PageCollectionService() {
        // used by the navService to navigate back to first possible step after
        // pages are reset
        /**
         *
         * \@memberof PageCollectionService
         */
        this._pagesReset = new Subject();
    }
    Object.defineProperty(PageCollectionService.prototype, "pagesAsArray", {
        /**
         * Converts the PageCollectionService.pages QueryList to an array and returns it.
         *
         * Useful for many instances when you would prefer a QueryList to act like an array.
         *
         * @memberof PageCollectionService
         */
        get: /**
         * Converts the PageCollectionService.pages QueryList to an array and returns it.
         *
         * Useful for many instances when you would prefer a QueryList to act like an array.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        function () {
            return this.pages ? this.pages.toArray() : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageCollectionService.prototype, "pagesCount", {
        /**
         * Returns the length of the pages query list.
         *
         * @memberof PageCollectionService
         */
        get: /**
         * Returns the length of the pages query list.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        function () {
            return this.pages ? this.pages.length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageCollectionService.prototype, "penultimatePage", {
        /**
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * @memberof PageCollectionService
         */
        get: /**
         * Returns the next-to-last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        function () {
            /** @type {?} */
            var pageCount = this.pagesCount;
            if (pageCount < 2) {
                return;
            }
            return this.pagesAsArray[pageCount - 2];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageCollectionService.prototype, "lastPage", {
        /**
         * Returns the last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * @memberof PageCollectionService
         */
        get: /**
         * Returns the last page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        function () {
            /** @type {?} */
            var pageCount = this.pagesCount;
            if (pageCount < 1) {
                return;
            }
            return this.pagesAsArray[pageCount - 1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageCollectionService.prototype, "firstPage", {
        /**
         * Returns the first page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * @memberof PageCollectionService
         */
        get: /**
         * Returns the first page in the query list of pages. Operates as a getter
         * so that it isn't working with stale data.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        function () {
            if (!this.pagesCount) {
                return;
            }
            return this.pagesAsArray[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
     * object that matches the ID passed. Note that IDs here should include the prefix
     * "clr-wizard-page-".
     *
     * Returns the next-to-last page in the query list of pages. Operates as a getter
     * so that it isn't working with stale data.
     *
     * @memberof PageCollectionService
     */
    /**
     * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
     * object that matches the ID passed. Note that IDs here should include the prefix
     * "clr-wizard-page-".
     *
     * Returns the next-to-last page in the query list of pages. Operates as a getter
     * so that it isn't working with stale data.
     *
     * \@memberof PageCollectionService
     * @param {?} id
     * @return {?}
     */
    PageCollectionService.prototype.getPageById = /**
     * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
     * object that matches the ID passed. Note that IDs here should include the prefix
     * "clr-wizard-page-".
     *
     * Returns the next-to-last page in the query list of pages. Operates as a getter
     * so that it isn't working with stale data.
     *
     * \@memberof PageCollectionService
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var foundPages = this.pages.filter(function (page) { return id === page.id; });
        return this.checkResults(foundPages, id);
    };
    /**
     * Accepts s number as a parameter and treats that number as the index of the page
     * you're looking for in the collection of pages. Returns a  wizard page object.
     *
     * @memberof PageCollectionService
     */
    /**
     * Accepts s number as a parameter and treats that number as the index of the page
     * you're looking for in the collection of pages. Returns a  wizard page object.
     *
     * \@memberof PageCollectionService
     * @param {?} index
     * @return {?}
     */
    PageCollectionService.prototype.getPageByIndex = /**
     * Accepts s number as a parameter and treats that number as the index of the page
     * you're looking for in the collection of pages. Returns a  wizard page object.
     *
     * \@memberof PageCollectionService
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var pageCount = this.pagesCount;
        /** @type {?} */
        var pagesLastIndex = pageCount > 1 ? pageCount - 1 : 0;
        if (index < 0) {
            throw new Error('Cannot retrieve page with index of ' + index);
        }
        if (index > pagesLastIndex) {
            throw new Error('Page index is greater than length of pages array.');
        }
        return this.pagesAsArray[index];
    };
    /**
     * Takes a wizard page object as a parameter and returns its index in the
     * collection of pages.
     *
     * @memberof PageCollectionService
     */
    /**
     * Takes a wizard page object as a parameter and returns its index in the
     * collection of pages.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    PageCollectionService.prototype.getPageIndex = /**
     * Takes a wizard page object as a parameter and returns its index in the
     * collection of pages.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    function (page) {
        /** @type {?} */
        var index = this.pagesAsArray.indexOf(page);
        if (index < 0) {
            throw new Error('Requested page cannot be found in collection of pages.');
        }
        return index;
    };
    /**
     * Consolidates guard logic that prevents a couple of unfortunate edge cases with
     * look ups on the collection of pages.
     *
     * @memberof PageCollectionService
     */
    /**
     * Consolidates guard logic that prevents a couple of unfortunate edge cases with
     * look ups on the collection of pages.
     *
     * \@memberof PageCollectionService
     * @param {?} results
     * @param {?} requestedPageId
     * @return {?}
     */
    PageCollectionService.prototype.checkResults = /**
     * Consolidates guard logic that prevents a couple of unfortunate edge cases with
     * look ups on the collection of pages.
     *
     * \@memberof PageCollectionService
     * @param {?} results
     * @param {?} requestedPageId
     * @return {?}
     */
    function (results, requestedPageId) {
        /** @type {?} */
        var foundPagesCount = results.length || 0;
        if (foundPagesCount > 1) {
            throw new Error('More than one page has the requested id ' + requestedPageId + '.');
        }
        else if (foundPagesCount < 1) {
            throw new Error('No page can be found with the id ' + requestedPageId + '.');
        }
        else {
            return results[0];
        }
    };
    /**
     * Accepts two numeric indexes and returns an array of wizard page objects that include
     * all wizard pages in the page collection from the first index to the second.
     *
     * @memberof PageCollectionService
     */
    /**
     * Accepts two numeric indexes and returns an array of wizard page objects that include
     * all wizard pages in the page collection from the first index to the second.
     *
     * \@memberof PageCollectionService
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    PageCollectionService.prototype.pageRange = /**
     * Accepts two numeric indexes and returns an array of wizard page objects that include
     * all wizard pages in the page collection from the first index to the second.
     *
     * \@memberof PageCollectionService
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (start, end) {
        /** @type {?} */
        var pages = [];
        if (start < 0 || end < 0) {
            return [];
        }
        if (start === null || typeof start === 'undefined' || isNaN(start)) {
            return [];
        }
        if (end === null || typeof end === 'undefined' || isNaN(end)) {
            return [];
        }
        if (end > this.pagesCount) {
            end = this.pagesCount;
        }
        pages = this.pagesAsArray;
        if (end - start === 0) {
            // just return the one page they want
            return [this.getPageByIndex(start)];
        }
        // slice end does not include item referenced by end index, which is weird for users
        // incrementing end index here to correct that so users and other methods
        // don't have to think about it
        end = end + 1;
        // slice does not return the last one in the range but it does include the first one
        // does not modify original array
        return pages.slice(start, end);
    };
    /**
     * Accepts two wizard page objects and returns those page objects with all other page
     * objects between them in the page collection. It doesn't care which page is ahead of the
     * other in the parameters. It will be smart enough to figure that out  on its own.
     *
     * @memberof PageCollectionService
     */
    /**
     * Accepts two wizard page objects and returns those page objects with all other page
     * objects between them in the page collection. It doesn't care which page is ahead of the
     * other in the parameters. It will be smart enough to figure that out  on its own.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @param {?} otherPage
     * @return {?}
     */
    PageCollectionService.prototype.getPageRangeFromPages = /**
     * Accepts two wizard page objects and returns those page objects with all other page
     * objects between them in the page collection. It doesn't care which page is ahead of the
     * other in the parameters. It will be smart enough to figure that out  on its own.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @param {?} otherPage
     * @return {?}
     */
    function (page, otherPage) {
        /** @type {?} */
        var pageIndex = this.getPageIndex(page);
        /** @type {?} */
        var otherPageIndex = this.getPageIndex(otherPage);
        /** @type {?} */
        var startIndex;
        /** @type {?} */
        var endIndex;
        if (pageIndex <= otherPageIndex) {
            startIndex = pageIndex;
            endIndex = otherPageIndex;
        }
        else {
            startIndex = otherPageIndex;
            endIndex = pageIndex;
        }
        return this.pageRange(startIndex, endIndex);
    };
    /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately before it in the page collection. Returns null if there is
     * no page before the page it is passed.
     *
     * @memberof PageCollectionService
     */
    /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately before it in the page collection. Returns null if there is
     * no page before the page it is passed.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    PageCollectionService.prototype.getPreviousPage = /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately before it in the page collection. Returns null if there is
     * no page before the page it is passed.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    function (page) {
        /** @type {?} */
        var myPageIndex = this.getPageIndex(page);
        /** @type {?} */
        var previousPageIndex = myPageIndex - 1;
        if (previousPageIndex < 0) {
            return null;
        }
        return this.getPageByIndex(previousPageIndex);
    };
    /**
     * Accepts a wizard page object as a parameter and returns a Boolean that says if
     * the page you sent it is complete.
     *
     * @memberof PageCollectionService
     */
    /**
     * Accepts a wizard page object as a parameter and returns a Boolean that says if
     * the page you sent it is complete.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    PageCollectionService.prototype.previousPageIsCompleted = /**
     * Accepts a wizard page object as a parameter and returns a Boolean that says if
     * the page you sent it is complete.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    function (page) {
        /** @type {?} */
        var previousPage;
        if (!page) {
            return false;
        }
        previousPage = this.getPreviousPage(page);
        if (null === previousPage) {
            // page is the first page. no previous page.
            return true;
        }
        return previousPage.completed;
    };
    /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately after it in the page collection. Returns null if there is
     * no page after the page it is passed.
     *
     * @memberof PageCollectionService
     */
    /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately after it in the page collection. Returns null if there is
     * no page after the page it is passed.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    PageCollectionService.prototype.getNextPage = /**
     * Takes a wizard page object as a parameter and returns the wizard page object of
     * the page immediately after it in the page collection. Returns null if there is
     * no page after the page it is passed.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    function (page) {
        /** @type {?} */
        var myPageIndex = this.getPageIndex(page);
        /** @type {?} */
        var nextPageIndex = myPageIndex + 1;
        if (nextPageIndex >= this.pagesAsArray.length) {
            return null;
        }
        return this.getPageByIndex(nextPageIndex);
    };
    /**
     * Takes a wizard page object as a parameter and generates a step item id from the
     * page ID. Returns the generated step item ID as a string.
     *
     * @memberof PageCollectionService
     */
    /**
     * Takes a wizard page object as a parameter and generates a step item id from the
     * page ID. Returns the generated step item ID as a string.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    PageCollectionService.prototype.getStepItemIdForPage = /**
     * Takes a wizard page object as a parameter and generates a step item id from the
     * page ID. Returns the generated step item ID as a string.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    function (page) {
        /** @type {?} */
        var pageId = page.id;
        /** @type {?} */
        var pageIdParts = pageId.split('-').reverse();
        pageIdParts[1] = 'step';
        return pageIdParts.reverse().join('-');
    };
    /**
     * Generally only used internally to mark that a specific page has been "committed".
     * This involves marking the page complete and firing the ClrWizardPage.onCommit
     * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
     * mark completed as a parameter.
     *
     * @memberof PageCollectionService
     */
    /**
     * Generally only used internally to mark that a specific page has been "committed".
     * This involves marking the page complete and firing the ClrWizardPage.onCommit
     * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
     * mark completed as a parameter.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    PageCollectionService.prototype.commitPage = /**
     * Generally only used internally to mark that a specific page has been "committed".
     * This involves marking the page complete and firing the ClrWizardPage.onCommit
     * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
     * mark completed as a parameter.
     *
     * \@memberof PageCollectionService
     * @param {?} page
     * @return {?}
     */
    function (page) {
        /** @type {?} */
        var pageHasOverrides = page.stopNext || page.preventDefault;
        page.completed = true;
        if (!pageHasOverrides) {
            // prevent loop of event emission; alternate flows work off
            // of event emitters this is how they break that cycle.
            page.onCommit.emit(page.id);
        }
    };
    Object.defineProperty(PageCollectionService.prototype, "pagesReset", {
        /**
         * An observable that the navigation service listens to in order to know when
         * the page collection completed states have been reset to false so that way it
         * can also reset the navigation to make the first page in the page collection
         * current/active.
         *
         * @memberof PageCollectionService
         */
        get: /**
         * An observable that the navigation service listens to in order to know when
         * the page collection completed states have been reset to false so that way it
         * can also reset the navigation to make the first page in the page collection
         * current/active.
         *
         * \@memberof PageCollectionService
         * @return {?}
         */
        function () {
            return this._pagesReset.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets all completed states of the pages in the page collection to false and
     * notifies the navigation service to likewise reset the navigation.
     *
     * @memberof PageCollectionService
     */
    /**
     * Sets all completed states of the pages in the page collection to false and
     * notifies the navigation service to likewise reset the navigation.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    PageCollectionService.prototype.reset = /**
     * Sets all completed states of the pages in the page collection to false and
     * notifies the navigation service to likewise reset the navigation.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    function () {
        this.pagesAsArray.forEach(function (page) {
            page.completed = false;
        });
        this._pagesReset.next(true);
    };
    /**
     * Rolls through all the pages in the page collection to make sure there are no
     * incomplete pages sandwiched between completed pages in the workflow. Identifies
     * the first incomplete page index and sets all pages behind it to a completed
     * state of false.
     *
     * @memberof PageCollectionService
     */
    /**
     * Rolls through all the pages in the page collection to make sure there are no
     * incomplete pages sandwiched between completed pages in the workflow. Identifies
     * the first incomplete page index and sets all pages behind it to a completed
     * state of false.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    PageCollectionService.prototype.updateCompletedStates = /**
     * Rolls through all the pages in the page collection to make sure there are no
     * incomplete pages sandwiched between completed pages in the workflow. Identifies
     * the first incomplete page index and sets all pages behind it to a completed
     * state of false.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    function () {
        /** @type {?} */
        var firstIncompleteIndex = this.findFirstIncompletePageIndex();
        if (firstIncompleteIndex === this.pagesAsArray.length - 1) {
            // all complete no need to do anything
            return;
        }
        this.pagesAsArray.forEach(function (page, index) {
            if (index > firstIncompleteIndex) {
                page.completed = false;
            }
        });
    };
    /**
     * Retrieves the index of the first incomplete page in the page collection.
     *
     * @memberof PageCollectionService
     */
    /**
     * Retrieves the index of the first incomplete page in the page collection.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    PageCollectionService.prototype.findFirstIncompletePageIndex = /**
     * Retrieves the index of the first incomplete page in the page collection.
     *
     * \@memberof PageCollectionService
     * @return {?}
     */
    function () {
        /** @type {?} */
        var returnIndex = null;
        this.pagesAsArray.forEach(function (page, index) {
            if (null === returnIndex && false === page.completed) {
                returnIndex = index;
            }
        });
        // fallthrough, all completed, return last page
        if (null === returnIndex) {
            returnIndex = this.pagesCount - 1;
        }
        return returnIndex;
    };
    /**
     * @return {?}
     */
    PageCollectionService.prototype.findFirstIncompletePage = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var myIncompleteIndex = this.findFirstIncompletePageIndex();
        return this.pagesAsArray[myIncompleteIndex];
    };
    PageCollectionService.decorators = [
        { type: Injectable }
    ];
    return PageCollectionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Performs navigation functions for a wizard and manages the current page. Presented as a
 * separate service to encapsulate the behavior of navigating and completing the wizard so
 * that it can be shared across the wizard and its sub-components.
 *
 * The easiest way to access the navigation service is there a reference on your wizard. The
 * Following example would allow you to access your instance of the wizard from your host
 * component and thereby access the navigation service via YourHostComponent.wizard.navService.
 *
 * \@example
 * <clr-wizard #wizard ...>
 *
 * \@example
 * export class YourHostComponent {
 * \@ViewChild("wizard") wizard: Wizard;
 *   ...
 * }
 *
 */
var WizardNavigationService = /** @class */ (function () {
    /**
     * Creates an instance of WizardNavigationService. Also sets up subscriptions
     * that listen to the button service to determine when a button has been clicked
     * in the wizard. Is also responsible for taking action when the page collection
     * requests that navigation be reset to its pristine state.
     *
     * @memberof WizardNavigationService
     */
    function WizardNavigationService(pageCollection, buttonService) {
        var _this = this;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        /**
         *
         * \@memberof WizardNavigationService
         */
        this._currentChanged = new Subject();
        /**
         * A Boolean flag used by the ClrWizardPage to avoid a race condition when pages are
         * loading and there is no current page defined.
         *
         * \@memberof WizardNavigationService
         */
        this.navServiceLoaded = false;
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.forceForward (clrWizardForceForwardNavigation) input. When true,
         * navigating backwards in the stepnav menu will reset any skipped pages' completed
         * state to false.
         *
         * This is useful when a wizard executes validation on a page-by-page basis when
         * the next button is clicked.
         *
         * \@memberof WizardNavigationService
         */
        this.forceForwardNavigation = false;
        /**
         * \@memberof WizardNavigationService
         */
        this._movedToNextPage = new Subject();
        /**
         * \@memberof WizardNavigationService
         */
        this._wizardFinished = new Subject();
        /**
         * \@memberof WizardNavigationService
         */
        this._movedToPreviousPage = new Subject();
        /**
         * \@memberof WizardNavigationService
         */
        this._cancelWizard = new Subject();
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.stopCancel (clrWizardPreventDefaultCancel) input. When true, the cancel
         * routine is subverted and must be reinstated in the host component calling Wizard.close()
         * at some point.
         *
         * \@memberof WizardNavigationService
         */
        this.wizardHasAltCancel = false;
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.stopNext (clrWizardPreventDefaultNext) input. When true, the next and finish
         * routines are subverted and must be reinstated in the host component calling Wizard.next(),
         * Wizard.forceNext(), Wizard.finish(), or Wizard.forceFinish().
         *
         * \@memberof WizardNavigationService
         */
        this.wizardHasAltNext = false;
        /**
         * A boolean flag shared across the Wizard subcomponents that follows the value
         * of the Wizard.stopNavigation (clrWizardPreventNavigation) input. When true, all
         * navigational elements in the wizard are disabled.
         *
         * This is intended to freeze the wizard in place. Events are not fired so this is
         * not a way to implement alternate functionality for navigation.
         *
         * \@memberof WizardNavigationService
         */
        this.wizardStopNavigation = false;
        /**
         * A boolean flag shared with the stepnav items that prevents user clicks on
         * stepnav items from navigating the wizard.
         *
         * \@memberof WizardNavigationService
         */
        this.wizardDisableStepnav = false;
        this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(function () {
            /** @type {?} */
            var currentPage = _this.currentPage;
            if (_this.currentPageIsFirst || currentPage.previousStepDisabled) {
                return;
            }
            currentPage.previousButtonClicked.emit(currentPage);
            if (!currentPage.preventDefault) {
                _this.previous();
            }
        });
        this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(function () {
            _this.checkAndCommitCurrentPage('next');
        });
        this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(function () {
            _this.checkAndCommitCurrentPage('danger');
        });
        this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(function () {
            _this.checkAndCommitCurrentPage('finish');
        });
        this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe(function (type) {
            if (!_this.wizardStopNavigation) {
                _this.currentPage.customButtonClicked.emit(type);
            }
        });
        this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(function () {
            if (_this.wizardStopNavigation) {
                return;
            }
            if (_this.currentPage.preventDefault) {
                _this.currentPage.pageOnCancel.emit(_this.currentPage);
            }
            else {
                _this.cancel();
            }
        });
        this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(function () {
            _this.setFirstPageCurrent();
        });
    }
    /**
     *
     * @memberof WizardNavigationService
     */
    /**
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.ngOnDestroy = /**
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        this.previousButtonSubscription.unsubscribe();
        this.nextButtonSubscription.unsubscribe();
        this.dangerButtonSubscription.unsubscribe();
        this.finishButtonSubscription.unsubscribe();
        this.customButtonSubscription.unsubscribe();
        this.cancelButtonSubscription.unsubscribe();
        this.pagesResetSubscription.unsubscribe();
    };
    Object.defineProperty(WizardNavigationService.prototype, "currentPageChanged", {
        /**
         * An Observable that is predominantly used amongst the subcomponents and services
         * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output instead of this Observable.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * An Observable that is predominantly used amongst the subcomponents and services
         * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
         * (clrWizardPageOnLoad) output instead of this Observable.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            // TODO: MAKE SURE EXTERNAL OUTPUTS SAY 'CHANGE' NOT 'CHANGED'
            // A BREAKING CHANGE SO AWAITING MINOR RELEASE
            return this._currentChanged.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageTitle", {
        /**
         * @memberof WizardNavigationService
         */
        get: /**
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            // when the querylist of pages is empty. this is the first place it fails...
            if (!this.currentPage) {
                return null;
            }
            return this.currentPage.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsFirst", {
        /**
         * Returns a Boolean that tells you whether or not the current page is the first
         * page in the Wizard.
         *
         * This is helpful for determining whether a page is navigable.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * Returns a Boolean that tells you whether or not the current page is the first
         * page in the Wizard.
         *
         * This is helpful for determining whether a page is navigable.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            return this.pageCollection.firstPage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPageIsLast", {
        /**
         * Returns a Boolean that tells you whether or not the current page is the
         * last page in the Wizard.
         *
         * This is used to determine which buttons should display in the wizard footer.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * Returns a Boolean that tells you whether or not the current page is the
         * last page in the Wizard.
         *
         * This is used to determine which buttons should display in the wizard footer.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            return this.pageCollection.lastPage === this.currentPage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "currentPage", {
        /**
         * Returns the ClrWizardPage object of the current page or null.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * Returns the ClrWizardPage object of the current page or null.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            if (!this._currentPage) {
                return null;
            }
            return this._currentPage;
        },
        /**
         * Accepts a ClrWizardPage object, since that object to be the current/active
         * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
         * event for that page.
         *
         * Note that all of this work is bypassed if the ClrWizardPage object is already
         * the current page.
         *
         * @memberof WizardNavigationService
         */
        set: /**
         * Accepts a ClrWizardPage object, since that object to be the current/active
         * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
         * event for that page.
         *
         * Note that all of this work is bypassed if the ClrWizardPage object is already
         * the current page.
         *
         * \@memberof WizardNavigationService
         * @param {?} page
         * @return {?}
         */
        function (page) {
            if (this._currentPage !== page && !this.wizardStopNavigation) {
                this._currentPage = page;
                page.onLoad.emit(page.id);
                this._currentChanged.next(page);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "movedToNextPage", {
        /**
         * An observable used internally to alert the wizard that forward navigation
         * has occurred. It is recommended that you use the Wizard.onMoveNext
         * (clrWizardOnNext) output instead of this one.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * An observable used internally to alert the wizard that forward navigation
         * has occurred. It is recommended that you use the Wizard.onMoveNext
         * (clrWizardOnNext) output instead of this one.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            return this._movedToNextPage.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardNavigationService.prototype, "wizardFinished", {
        /**
         * An observable used internally to alert the wizard that the nav service
         * has approved completion of the wizard.
         *
         * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
         * output instead of this one.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * An observable used internally to alert the wizard that the nav service
         * has approved completion of the wizard.
         *
         * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
         * output instead of this one.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            return this._wizardFinished.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This is a public function that can be used to programmatically advance
     * the user to the next page.
     *
     * When invoked, this method will move the wizard to the next page after
     * successful validation. Note that this method goes through all checks
     * and event emissions as if Wizard.next(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.next(false).
     *
     * @memberof WizardNavigationService
     */
    /**
     * This is a public function that can be used to programmatically advance
     * the user to the next page.
     *
     * When invoked, this method will move the wizard to the next page after
     * successful validation. Note that this method goes through all checks
     * and event emissions as if Wizard.next(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.next(false).
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.next = /**
     * This is a public function that can be used to programmatically advance
     * the user to the next page.
     *
     * When invoked, this method will move the wizard to the next page after
     * successful validation. Note that this method goes through all checks
     * and event emissions as if Wizard.next(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.next(false).
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        if (this.currentPageIsLast) {
            this.checkAndCommitCurrentPage('finish');
            return;
        }
        this.checkAndCommitCurrentPage('next');
        if (!this.wizardHasAltNext && !this.wizardStopNavigation) {
            this._movedToNextPage.next(true);
        }
    };
    /**
     * Bypasses checks and most event emissions to force a page to navigate forward.
     *
     * Comparable to calling Wizard.next() or Wizard.forceNext().
     *
     * @memberof WizardNavigationService
     */
    /**
     * Bypasses checks and most event emissions to force a page to navigate forward.
     *
     * Comparable to calling Wizard.next() or Wizard.forceNext().
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.forceNext = /**
     * Bypasses checks and most event emissions to force a page to navigate forward.
     *
     * Comparable to calling Wizard.next() or Wizard.forceNext().
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentPage = this.currentPage;
        /** @type {?} */
        var nextPage = this.pageCollection.getNextPage(currentPage);
        // catch errant null or undefineds that creep in
        if (!nextPage) {
            throw new Error('The wizard has no next page to go to.');
        }
        if (this.wizardStopNavigation) {
            return;
        }
        if (!currentPage.completed) {
            // this is a state that alt next flows can get themselves in...
            this.pageCollection.commitPage(currentPage);
        }
        this.currentPage = nextPage;
    };
    /**
     * Accepts a button/action type as a parameter. Encapsulates all logic for
     * event emissions, state of the current page, and wizard and page level overrides.
     *
     * Avoid calling this function directly unless you really know what you're doing.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Accepts a button/action type as a parameter. Encapsulates all logic for
     * event emissions, state of the current page, and wizard and page level overrides.
     *
     * Avoid calling this function directly unless you really know what you're doing.
     *
     * \@memberof WizardNavigationService
     * @param {?} buttonType
     * @return {?}
     */
    WizardNavigationService.prototype.checkAndCommitCurrentPage = /**
     * Accepts a button/action type as a parameter. Encapsulates all logic for
     * event emissions, state of the current page, and wizard and page level overrides.
     *
     * Avoid calling this function directly unless you really know what you're doing.
     *
     * \@memberof WizardNavigationService
     * @param {?} buttonType
     * @return {?}
     */
    function (buttonType) {
        /** @type {?} */
        var currentPage = this.currentPage;
        /** @type {?} */
        var iAmTheLastPage;
        /** @type {?} */
        var isNext;
        /** @type {?} */
        var isDanger;
        /** @type {?} */
        var isDangerNext;
        /** @type {?} */
        var isDangerFinish;
        /** @type {?} */
        var isFinish;
        if (!currentPage.readyToComplete || this.wizardStopNavigation) {
            return;
        }
        iAmTheLastPage = this.currentPageIsLast;
        isNext = buttonType === 'next';
        isDanger = buttonType === 'danger';
        isDangerNext = isDanger && !iAmTheLastPage;
        isDangerFinish = isDanger && iAmTheLastPage;
        isFinish = buttonType === 'finish' || isDangerFinish;
        if (isFinish && !iAmTheLastPage) {
            return;
        }
        currentPage.primaryButtonClicked.emit(buttonType);
        if (isFinish) {
            currentPage.finishButtonClicked.emit(currentPage);
        }
        else if (isDanger) {
            currentPage.dangerButtonClicked.emit();
        }
        else if (isNext) {
            currentPage.nextButtonClicked.emit();
        }
        if (currentPage.stopNext || currentPage.preventDefault) {
            currentPage.onCommit.emit(currentPage.id);
            return;
        }
        // order is very important with these emitters!
        if (isFinish) {
            // mark page as complete
            if (!this.wizardHasAltNext) {
                this.pageCollection.commitPage(currentPage);
            }
            this._wizardFinished.next();
        }
        if (this.wizardHasAltNext) {
            this.pageCollection.commitPage(currentPage);
            if (isNext || isDangerNext) {
                this._movedToNextPage.next(true);
            }
            // jump out here, no matter what type we're looking at
            return;
        }
        if (isNext || isDangerNext) {
            this.forceNext();
        }
    };
    /**
     * This is a public function that can be used to programmatically conclude
     * the wizard.
     *
     * When invoked, this method will  initiate the work involved with finalizing
     * and finishing the wizard workflow. Note that this method goes through all
     * checks and event emissions as if Wizard.finish(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.finish(false).
     *
     * @memberof WizardNavigationService
     */
    /**
     * This is a public function that can be used to programmatically conclude
     * the wizard.
     *
     * When invoked, this method will  initiate the work involved with finalizing
     * and finishing the wizard workflow. Note that this method goes through all
     * checks and event emissions as if Wizard.finish(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.finish(false).
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.finish = /**
     * This is a public function that can be used to programmatically conclude
     * the wizard.
     *
     * When invoked, this method will  initiate the work involved with finalizing
     * and finishing the wizard workflow. Note that this method goes through all
     * checks and event emissions as if Wizard.finish(false) had been called.
     *
     * In most cases, it makes more sense to use Wizard.finish(false).
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        this.checkAndCommitCurrentPage('finish');
    };
    Object.defineProperty(WizardNavigationService.prototype, "movedToPreviousPage", {
        /**
         * Notifies the wizard when backwards navigation has occurred via the
         * previous button.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * Notifies the wizard when backwards navigation has occurred via the
         * previous button.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            return this._movedToPreviousPage.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Programmatically moves the wizard to the page before the current page.
     *
     * In most instances, it makes more sense to call Wizard.previous()
     * which does the same thing.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Programmatically moves the wizard to the page before the current page.
     *
     * In most instances, it makes more sense to call Wizard.previous()
     * which does the same thing.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.previous = /**
     * Programmatically moves the wizard to the page before the current page.
     *
     * In most instances, it makes more sense to call Wizard.previous()
     * which does the same thing.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        /** @type {?} */
        var previousPage;
        if (this.currentPageIsFirst || this.wizardStopNavigation) {
            return;
        }
        previousPage = this.pageCollection.getPreviousPage(this.currentPage);
        if (!previousPage) {
            return;
        }
        this._movedToPreviousPage.next(true);
        if (this.forceForwardNavigation) {
            this.currentPage.completed = false;
        }
        this.currentPage = previousPage;
    };
    Object.defineProperty(WizardNavigationService.prototype, "notifyWizardCancel", {
        /**
         * Notifies the wizard that a user is trying to cancel it.
         *
         * @memberof WizardNavigationService
         */
        get: /**
         * Notifies the wizard that a user is trying to cancel it.
         *
         * \@memberof WizardNavigationService
         * @return {?}
         */
        function () {
            return this._cancelWizard.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
     * this route goes through all checks and event emissions as if a cancel button had
     * been clicked.
     *
     * In most cases, users looking for a hook into the cancel routine are actually looking
     * for a way to close the wizard from their host component because they have prevented
     * the default cancel action.
     *
     * In this instance, it is recommended that you use Wizard.close() to avoid any event
     * emission loop resulting from an event handler calling back into routine that will
     * again evoke the events it handles.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
     * this route goes through all checks and event emissions as if a cancel button had
     * been clicked.
     *
     * In most cases, users looking for a hook into the cancel routine are actually looking
     * for a way to close the wizard from their host component because they have prevented
     * the default cancel action.
     *
     * In this instance, it is recommended that you use Wizard.close() to avoid any event
     * emission loop resulting from an event handler calling back into routine that will
     * again evoke the events it handles.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.cancel = /**
     * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
     * this route goes through all checks and event emissions as if a cancel button had
     * been clicked.
     *
     * In most cases, users looking for a hook into the cancel routine are actually looking
     * for a way to close the wizard from their host component because they have prevented
     * the default cancel action.
     *
     * In this instance, it is recommended that you use Wizard.close() to avoid any event
     * emission loop resulting from an event handler calling back into routine that will
     * again evoke the events it handles.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        this._cancelWizard.next();
    };
    /**
     * Performs all required checks to determine if a user can navigate to a page. Checking at each
     * point if a page is navigable -- completed where the page immediately after the last completed
     * page.
     *
     * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
     * ClrWizardPage object that you want to make the current page.
     *
     * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
     * is the Wizard will mark all pages between the current page and the page you want to navigate
     * to as completed. This is useful for informational wizards that do not require user action,
     * allowing an easy means for users to jump ahead.
     *
     * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Performs all required checks to determine if a user can navigate to a page. Checking at each
     * point if a page is navigable -- completed where the page immediately after the last completed
     * page.
     *
     * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
     * ClrWizardPage object that you want to make the current page.
     *
     * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
     * is the Wizard will mark all pages between the current page and the page you want to navigate
     * to as completed. This is useful for informational wizards that do not require user action,
     * allowing an easy means for users to jump ahead.
     *
     * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
     *
     * \@memberof WizardNavigationService
     * @param {?} pageToGoToOrId
     * @param {?=} lazyComplete
     * @return {?}
     */
    WizardNavigationService.prototype.goTo = /**
     * Performs all required checks to determine if a user can navigate to a page. Checking at each
     * point if a page is navigable -- completed where the page immediately after the last completed
     * page.
     *
     * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
     * ClrWizardPage object that you want to make the current page.
     *
     * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
     * is the Wizard will mark all pages between the current page and the page you want to navigate
     * to as completed. This is useful for informational wizards that do not require user action,
     * allowing an easy means for users to jump ahead.
     *
     * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
     *
     * \@memberof WizardNavigationService
     * @param {?} pageToGoToOrId
     * @param {?=} lazyComplete
     * @return {?}
     */
    function (pageToGoToOrId, lazyComplete) {
        if (lazyComplete === void 0) { lazyComplete = false; }
        /** @type {?} */
        var pageToGoTo;
        /** @type {?} */
        var currentPage;
        /** @type {?} */
        var myPages;
        /** @type {?} */
        var pagesToCheck;
        /** @type {?} */
        var okayToMove;
        /** @type {?} */
        var goingForward;
        /** @type {?} */
        var currentPageIndex;
        /** @type {?} */
        var goToPageIndex;
        myPages = this.pageCollection;
        pageToGoTo = typeof pageToGoToOrId === 'string' ? myPages.getPageById(pageToGoToOrId) : pageToGoToOrId;
        currentPage = this.currentPage;
        // no point in going to the current page. you're there already!
        // also hard block on any navigation when stopNavigation is true
        if (pageToGoTo === currentPage || this.wizardStopNavigation) {
            return;
        }
        currentPageIndex = myPages.getPageIndex(currentPage);
        goToPageIndex = myPages.getPageIndex(pageToGoTo);
        goingForward = goToPageIndex > currentPageIndex;
        pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
        okayToMove = lazyComplete || this.canGoTo(pagesToCheck);
        if (!okayToMove) {
            return;
        }
        if (goingForward && lazyComplete) {
            pagesToCheck.forEach(function (page) {
                if (page !== pageToGoTo) {
                    page.completed = true;
                }
            });
        }
        else if (!goingForward && this.forceForwardNavigation) {
            pagesToCheck.forEach(function (page) {
                page.completed = false;
            });
        }
        this.currentPage = pageToGoTo;
    };
    /**
     * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
     * those objects to determine if navigation can be accomplished.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
     * those objects to determine if navigation can be accomplished.
     *
     * \@memberof WizardNavigationService
     * @param {?} pagesToCheck
     * @return {?}
     */
    WizardNavigationService.prototype.canGoTo = /**
     * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
     * those objects to determine if navigation can be accomplished.
     *
     * \@memberof WizardNavigationService
     * @param {?} pagesToCheck
     * @return {?}
     */
    function (pagesToCheck) {
        /** @type {?} */
        var okayToMove = true;
        /** @type {?} */
        var myPages = this.pageCollection;
        // previous page can be important when moving because if it's completed it
        // allows us to move to the page even if it's incomplete...
        /** @type {?} */
        var previousPagePasses;
        if (!pagesToCheck || pagesToCheck.length < 1) {
            return false;
        }
        pagesToCheck.forEach(function (page) {
            /** @type {?} */
            var previousPage;
            if (!okayToMove) {
                return;
            }
            if (page.completed) {
                // default is true. just jump out instead of complicating it.
                return;
            }
            // so we know our page is not completed...
            previousPage = myPages.getPageIndex(page) > 0 ? myPages.getPreviousPage(page) : null;
            previousPagePasses = previousPage === null || previousPage.completed === true;
            // we are false if not the current page AND previous page is not completed
            // (but must have a previous page)
            if (!page.current && !previousPagePasses) {
                okayToMove = false;
            }
            // falls through to true as default
        });
        return okayToMove;
    };
    /**
     * Looks through the collection of pages to find the first one that is incomplete
     * and makes that page the current/active page.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Looks through the collection of pages to find the first one that is incomplete
     * and makes that page the current/active page.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.setLastEnabledPageCurrent = /**
     * Looks through the collection of pages to find the first one that is incomplete
     * and makes that page the current/active page.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        /** @type {?} */
        var allPages = this.pageCollection.pagesAsArray;
        /** @type {?} */
        var lastCompletedPageIndex = null;
        allPages.forEach(function (page, index) {
            if (page.completed) {
                lastCompletedPageIndex = index;
            }
        });
        if (lastCompletedPageIndex === null) {
            // always is at least the first item...
            lastCompletedPageIndex = 0;
        }
        else if (lastCompletedPageIndex + 1 < allPages.length) {
            lastCompletedPageIndex = lastCompletedPageIndex + 1;
        }
        this.currentPage = allPages[lastCompletedPageIndex];
    };
    /**
     * Finds the first page in the collection of pages and makes that page the
     * current/active page.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Finds the first page in the collection of pages and makes that page the
     * current/active page.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.setFirstPageCurrent = /**
     * Finds the first page in the collection of pages and makes that page the
     * current/active page.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        this.currentPage = this.pageCollection.pagesAsArray[0];
    };
    /**
     * Updates the stepnav on the left side of the wizard when pages are dynamically
     * added or removed from the collection of pages.
     *
     * @memberof WizardNavigationService
     */
    /**
     * Updates the stepnav on the left side of the wizard when pages are dynamically
     * added or removed from the collection of pages.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    WizardNavigationService.prototype.updateNavigation = /**
     * Updates the stepnav on the left side of the wizard when pages are dynamically
     * added or removed from the collection of pages.
     *
     * \@memberof WizardNavigationService
     * @return {?}
     */
    function () {
        /** @type {?} */
        var toSetCurrent;
        /** @type {?} */
        var currentPageRemoved;
        this.pageCollection.updateCompletedStates();
        currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
        if (currentPageRemoved) {
            toSetCurrent = this.pageCollection.findFirstIncompletePage();
            this.currentPage = toSetCurrent;
        }
    };
    WizardNavigationService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    WizardNavigationService.ctorParameters = function () { return [
        { type: PageCollectionService },
        { type: ButtonHubService }
    ]; };
    return WizardNavigationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var HeaderActionService = /** @class */ (function () {
    // this service communicates information about the presence/display of header actions
    // across the wizard
    function HeaderActionService(navService) {
        this.navService = navService;
    }
    Object.defineProperty(HeaderActionService.prototype, "wizardHasHeaderActions", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var wizardHdrActions = this.wizardHeaderActions;
            if (!wizardHdrActions) {
                return false;
            }
            return wizardHdrActions.toArray().length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeaderActionService.prototype, "currentPageHasHeaderActions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.navService.currentPage ? this.navService.currentPage.hasHeaderActions : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeaderActionService.prototype, "showWizardHeaderActions", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.currentPageHasHeaderActions && this.wizardHasHeaderActions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HeaderActionService.prototype, "displayHeaderActionsWrapper", {
        get: /**
         * @return {?}
         */
        function () {
            return this.currentPageHasHeaderActions || this.wizardHasHeaderActions;
        },
        enumerable: true,
        configurable: true
    });
    HeaderActionService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HeaderActionService.ctorParameters = function () { return [
        { type: WizardNavigationService }
    ]; };
    return HeaderActionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var wizardHeaderActionIndex = 0;
var ClrWizardHeaderAction = /** @class */ (function () {
    function ClrWizardHeaderAction() {
        // title is explanatory text added to the header action
        this.title = '';
        // If our host has an ID attribute, we use this instead of our index.
        this._id = (wizardHeaderActionIndex++).toString();
        this.disabled = false;
        this.headerActionClicked = new EventEmitter(false);
    }
    Object.defineProperty(ClrWizardHeaderAction.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return "clr-wizard-header-action-" + this._id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrWizardHeaderAction.prototype.click = /**
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        // passing the header action id allows users to have one method that
        // routes to many different actions based on the type of header action
        // clicked. this is further aided by users being able to specify ids
        // for their header actions.
        this.headerActionClicked.emit(this._id);
    };
    ClrWizardHeaderAction.decorators = [
        { type: Component, args: [{
                    selector: 'clr-wizard-header-action',
                    template: "\n        <button \n            type=\"button\"\n            class=\"btn clr-wizard-header-action btn-link\"\n            [id]=\"id\"\n            [class.disabled]=\"disabled\"\n            (click)=\"click()\"\n            [title]=\"title\">\n            <ng-content></ng-content>\n        </button>\n    ",
                    host: { class: 'clr-wizard-header-action-wrapper' }
                }] }
    ];
    ClrWizardHeaderAction.propDecorators = {
        title: [{ type: Input, args: ['title',] }],
        _id: [{ type: Input, args: ['id',] }],
        disabled: [{ type: Input, args: ['clrWizardHeaderActionDisabled',] }],
        headerActionClicked: [{ type: Output, args: ['actionClicked',] }]
    };
    return ClrWizardHeaderAction;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrWizardPageButtons = /** @class */ (function () {
    function ClrWizardPageButtons(pageButtonsTemplateRef) {
        this.pageButtonsTemplateRef = pageButtonsTemplateRef;
    }
    ClrWizardPageButtons.decorators = [
        { type: Directive, args: [{ selector: '[clrPageButtons]' },] }
    ];
    /** @nocollapse */
    ClrWizardPageButtons.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return ClrWizardPageButtons;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrWizardPageHeaderActions = /** @class */ (function () {
    function ClrWizardPageHeaderActions(pageHeaderActionsTemplateRef) {
        this.pageHeaderActionsTemplateRef = pageHeaderActionsTemplateRef;
    }
    ClrWizardPageHeaderActions.decorators = [
        { type: Directive, args: [{ selector: '[clrPageHeaderActions]' },] }
    ];
    /** @nocollapse */
    ClrWizardPageHeaderActions.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return ClrWizardPageHeaderActions;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrWizardPageNavTitle = /** @class */ (function () {
    function ClrWizardPageNavTitle(pageNavTitleTemplateRef) {
        this.pageNavTitleTemplateRef = pageNavTitleTemplateRef;
    }
    ClrWizardPageNavTitle.decorators = [
        { type: Directive, args: [{ selector: '[clrPageNavTitle]' },] }
    ];
    /** @nocollapse */
    ClrWizardPageNavTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return ClrWizardPageNavTitle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrWizardPageTitle = /** @class */ (function () {
    function ClrWizardPageTitle(pageTitleTemplateRef) {
        this.pageTitleTemplateRef = pageTitleTemplateRef;
    }
    ClrWizardPageTitle.decorators = [
        { type: Directive, args: [{ selector: '[clrPageTitle]' },] }
    ];
    /** @nocollapse */
    ClrWizardPageTitle.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return ClrWizardPageTitle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var wizardPageIndex = 0;
/**
 * The ClrWizardPage component is responsible for displaying the content of each step
 * in the wizard workflow.
 *
 * ClrWizardPage component has hooks into the navigation service (ClrWizardPage.navService),
 * page collection (ClrWizardPage.pageCollection), and button service
 * (ClrWizardPage.buttonService). These three providers are shared across the components
 * within each instance of a Wizard.
 *
 */
var ClrWizardPage = /** @class */ (function () {
    /**
     * Creates an instance of ClrWizardPage.
     *
     * @memberof WizardPage
     */
    function ClrWizardPage(navService, pageCollection, buttonService) {
        this.navService = navService;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._nextStepDisabled = false;
        /**
         * Emits when the value of ClrWizardPage.nextStepDisabled changes.
         * Should emit the new value of nextStepDisabled.
         *
         * \@memberof WizardPage
         *
         */
        this.nextStepDisabledChange = new EventEmitter();
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._previousStepDisabled = false;
        /**
         * Emits when the value of ClrWizardPage.previousStepDisabled changes.
         * Should emit the new value of previousStepDisabled.
         *
         * \@memberof WizardPage
         *
         */
        this.previousStepDisabledChange = new EventEmitter();
        /**
         * Overrides all actions from the page level, so you can use an alternate function for
         * validation or data-munging with a ClrWizardPage.onCommit (clrWizardPageOnCommit output),
         * ClrWizardPage.onCancel (clrWizardPageOnCancel output), or one
         * of the granular page-level button click event emitters.
         *
         * \@memberof WizardPage
         *
         */
        this.preventDefault = false;
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._stopCancel = false;
        /**
         *
         * \@memberof WizardPage
         *
         */
        this.stopCancelChange = new EventEmitter();
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._stopNext = false;
        /**
         * An event emitter carried over from a legacy version of ClrWizardPage.
         * Fires an event on ClrWizardPage whenever the next or finish buttons
         * are clicked and the page is the current page of the Wizard.
         *
         * Note that this does not automatically emit an event when a custom
         * button is used in place of a next or finish button.
         *
         * \@memberof WizardPage
         *
         */
        this.onCommit = new EventEmitter(false);
        /**
         * Emits an event when ClrWizardPage becomes the current page of the
         * Wizard.
         *
         * \@memberof WizardPage
         *
         */
        this.onLoad = new EventEmitter();
        /**
         * Emits an event when the ClrWizardPage invokes the cancel routine for the wizard.
         *
         * Can be used in conjunction with the ClrWizardPage.stopCancel
         * (clrWizardPagePreventDefaultCancel) or ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) inputs to implement custom cancel
         * functionality at the page level. This is useful if you would like to do
         * validation, save data, or warn users before cancelling the wizard.
         *
         * Note that this requires you to call Wizard.close() from the host component.
         * This constitues a full replacement of the cancel functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.pageOnCancel = new EventEmitter();
        /**
         * Emits an event when the finish button is clicked and the ClrWizardPage is
         * the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom finish
         * functionality at the page level. This is useful if you would like to do
         * validation, save data, or warn users before allowing them to complete
         * the wizard.
         *
         * Note that this requires you to call Wizard.finish() or Wizard.forceFinish()
         * from the host component. This combination creates a full replacement of
         * the finish functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.finishButtonClicked = new EventEmitter();
        /**
         * Emits an event when the previous button is clicked and the ClrWizardPage is
         * the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom backwards
         * navigation at the page level. This is useful if you would like to do
         * validation, save data, or warn users before allowing them to go
         * backwards in the wizard.
         *
         * Note that this requires you to call Wizard.previous()
         * from the host component. This combination creates a full replacement of
         * the backwards navigation functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.previousButtonClicked = new EventEmitter();
        /**
         * Emits an event when the next button is clicked and the ClrWizardPage is
         * the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom forwards
         * navigation at the page level. This is useful if you would like to do
         * validation, save data, or warn users before allowing them to go
         * to the next page in the wizard.
         *
         * Note that this requires you to call Wizard.forceNext() or Wizard.next()
         * from the host component. This combination creates a full replacement of
         * the forward navigation functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.nextButtonClicked = new EventEmitter();
        /**
         * Emits an event when a danger button is clicked and the ClrWizardPage is
         * the wizard's current page. By default, a danger button will act as
         * either a "next" or "finish" button depending on if the ClrWizardPage is the
         * last page or not.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom forwards
         * or finish navigation at the page level when the danger button is clicked.
         * This is useful if you would like to do validation, save data, or warn
         * users before allowing them to go to the next page in the wizard or
         * finish the wizard.
         *
         * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
         * Wizard.forceNext() or Wizard.next() from the host component. This
         * combination creates a full replacement of the forward navigation and
         * finish functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.dangerButtonClicked = new EventEmitter();
        /**
         * Emits an event when a next, finish, or danger button is clicked and the
         * ClrWizardPage is the wizard's current page.
         *
         * Can be used in conjunction with the ClrWizardPage.preventDefault
         * (clrWizardPagePagePreventDefault) input to implement custom forwards
         * or finish navigation at the page level, regardless of the type of
         * primary button.
         *
         * This is useful if you would like to do validation, save data, or warn
         * users before allowing them to go to the next page in the wizard or
         * finish the wizard.
         *
         * Note that this requires you to call Wizard.finish(), Wizard.forceFinish(),
         * Wizard.forceNext() or Wizard.next() from the host component. This
         * combination creates a full replacement of the forward navigation and
         * finish functionality.
         *
         * \@memberof WizardPage
         *
         */
        this.primaryButtonClicked = new EventEmitter();
        this.customButtonClicked = new EventEmitter();
        /**
         * An input value that is used internally to generate the ClrWizardPage ID as
         * well as the step nav item ID.
         *
         * Typed as any because it should be able to accept numbers as well as
         * strings. Passing an index for wizard whose pages are created with an
         * ngFor loop is a common use case.
         *
         * \@memberof WizardPage
         *
         */
        this._id = (wizardPageIndex++).toString();
        /**
         *
         * \@memberof WizardPage
         *
         */
        this._complete = false;
    }
    Object.defineProperty(ClrWizardPage.prototype, "nextStepDisabled", {
        /**
         * A getter that tells whether or not the wizard should be allowed
         * to move to the next page.
         *
         * Useful for in-page validation because it prevents forward navigation
         * and visibly disables the next button.
         *
         * Does not require that you re-implement navigation routines like you
         * would if you were using ClrWizardPage.preventDefault or
         * Wizard.preventDefault.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A getter that tells whether or not the wizard should be allowed
         * to move to the next page.
         *
         * Useful for in-page validation because it prevents forward navigation
         * and visibly disables the next button.
         *
         * Does not require that you re-implement navigation routines like you
         * would if you were using ClrWizardPage.preventDefault or
         * Wizard.preventDefault.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this._nextStepDisabled;
        },
        /**
         * Sets whether the page should allow forward navigation.
         *
         * @memberof WizardPage
         *
         */
        set: /**
         * Sets whether the page should allow forward navigation.
         *
         * \@memberof WizardPage
         *
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var valBool = !!val;
            if (valBool !== this._nextStepDisabled) {
                this._nextStepDisabled = valBool;
                this.nextStepDisabledChange.emit(valBool);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "previousStepDisabled", {
        /**
         * A getter that tells whether or not the wizard should be allowed
         * to move to the previous page.
         *
         * Useful for in-page validation because it prevents backward navigation
         * and visibly disables the previous button.
         *
         * Does not require that you re-implement navigation routines like you
         * would if you were using ClrWizardPage.preventDefault or
         * Wizard.preventDefault.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A getter that tells whether or not the wizard should be allowed
         * to move to the previous page.
         *
         * Useful for in-page validation because it prevents backward navigation
         * and visibly disables the previous button.
         *
         * Does not require that you re-implement navigation routines like you
         * would if you were using ClrWizardPage.preventDefault or
         * Wizard.preventDefault.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this._previousStepDisabled;
        },
        /**
         * Sets whether the page should allow backward navigation.
         *
         * @memberof WizardPage
         *
         */
        set: /**
         * Sets whether the page should allow backward navigation.
         *
         * \@memberof WizardPage
         *
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var valBool = !!val;
            if (valBool !== this._previousStepDisabled) {
                this._previousStepDisabled = valBool;
                this.previousStepDisabledChange.emit(valBool);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "stopCancel", {
        /**
         * A getter that retrieves whether the page is preventing the cancel action.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A getter that retrieves whether the page is preventing the cancel action.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this._stopCancel;
        },
        /**
         * Overrides the cancel action from the page level. Allows you to use an
         * alternate function for validation or data-munging before cancelling the
         * wizard when combined with the ClrWizardPage.onCancel
         * (the clrWizardPageOnCancel output).
         *
         * Requires that you manually close the wizard from your host component,
         * usually with a call to Wizard.forceNext() or wizard.next();
         *
         * @memberof ClrWizardPage
         */
        set: /**
         * Overrides the cancel action from the page level. Allows you to use an
         * alternate function for validation or data-munging before cancelling the
         * wizard when combined with the ClrWizardPage.onCancel
         * (the clrWizardPageOnCancel output).
         *
         * Requires that you manually close the wizard from your host component,
         * usually with a call to Wizard.forceNext() or wizard.next();
         *
         * \@memberof ClrWizardPage
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var valBool = !!val;
            if (valBool !== this._stopCancel) {
                this._stopCancel = valBool;
                this.stopCancelChange.emit(valBool);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "stopNext", {
        /**
         * A getter that tells you whether the page is preventing the next action.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A getter that tells you whether the page is preventing the next action.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this._stopNext;
        },
        /**
         * Overrides forward navigation from the page level. Allows you to use an
         * alternate function for validation or data-munging before moving the
         * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
         * (clrWizardPageNext) outputs.
         *
         * Requires that you manually tell the wizard to navigate forward from
         * the hostComponent, usually with a call to Wizard.forceNext() or
         * wizard.next();
         *
         * @memberof ClrWizardPage
         */
        set: /**
         * Overrides forward navigation from the page level. Allows you to use an
         * alternate function for validation or data-munging before moving the
         * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
         * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
         * (clrWizardPageNext) outputs.
         *
         * Requires that you manually tell the wizard to navigate forward from
         * the hostComponent, usually with a call to Wizard.forceNext() or
         * wizard.next();
         *
         * \@memberof ClrWizardPage
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var valBool = !!val;
            if (valBool !== this._stopNext) {
                this._stopNext = valBool;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "id", {
        /**
         * A read-only getter that generates an ID string for the wizard page from
         * either the value passed to the ClrWizardPage "id" input or a wizard page
         * counter shared across all wizard pages in the application.
         *
         * Note that the value passed into the ID input Will be prefixed with
         * "clr-wizard-page-".
         *
         * @readonly
         *
         * @memberof ClrWizardPage
         */
        get: /**
         * A read-only getter that generates an ID string for the wizard page from
         * either the value passed to the ClrWizardPage "id" input or a wizard page
         * counter shared across all wizard pages in the application.
         *
         * Note that the value passed into the ID input Will be prefixed with
         * "clr-wizard-page-".
         *
         * \@readonly
         *
         * \@memberof ClrWizardPage
         * @return {?}
         */
        function () {
            // covers things like null, undefined, false, and empty string
            // while allowing zero to pass
            /** @type {?} */
            var idIsNonZeroFalsy = !this._id && this._id !== 0;
            // in addition to non-zero falsy we also want to make sure _id is not a negative
            // number.
            if (idIsNonZeroFalsy || this._id < 0) {
                // guard here in the event that input becomes undefined or null by accident
                this._id = (wizardPageIndex++).toString();
            }
            return "clr-wizard-page-" + this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "readyToComplete", {
        /**
         * A read-only getter that serves as a convenience for those who would rather
         * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
         * ClrWizardPage.readyToComplete is more logical and declarative.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A read-only getter that serves as a convenience for those who would rather
         * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
         * ClrWizardPage.readyToComplete is more logical and declarative.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return !this.nextStepDisabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "completed", {
        /**
         * A page is marked as completed if it is both readyToComplete and completed,
         * as in the next or finish action has been executed while this page was current.
         *
         * Note there is and open question about how to handle pages that are marked
         * complete but who are no longer readyToComplete. This might indicate an error
         * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
         * and only returns that the page is incomplete.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A page is marked as completed if it is both readyToComplete and completed,
         * as in the next or finish action has been executed while this page was current.
         *
         * Note there is and open question about how to handle pages that are marked
         * complete but who are no longer readyToComplete. This might indicate an error
         * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
         * and only returns that the page is incomplete.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this._complete && this.readyToComplete;
            // FOR V2: UNWIND COMPLETED, READYTOCOMPLETE, AND ERRORS
            // SUCH THAT ERRORS IS ITS OWN INPUT. IF A STEP IS
            // INCOMPLETE AND ERRORED, ERRORED WILL NOT SHOW.
            // FIRST QUESTION: AM I GREY OR COLORED?
            // SECOND QUESTION: AM I GREEN OR RED?
        },
        /**
         * A ClrWizardPage can be manually set to completed using this boolean setter.
         * It is recommended that users rely on the convenience functions in the wizard
         * and navigation service instead of manually setting pages’ completion state.
         *
         * @memberof ClrWizardPage
         */
        set: /**
         * A ClrWizardPage can be manually set to completed using this boolean setter.
         * It is recommended that users rely on the convenience functions in the wizard
         * and navigation service instead of manually setting pages’ completion state.
         *
         * \@memberof ClrWizardPage
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._complete = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "current", {
        /**
         * Checks with the navigation service to see if it is the current page.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * Checks with the navigation service to see if it is the current page.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this.navService.currentPage === this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.enabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "enabled", {
        /**
         * A read-only getter that returns whether or not the page is navigable
         * in the wizard. A wizard page can be navigated to if it is completed
         * or the page before it is completed.
         *
         * This getter handles the logic for enabling or disabling the links in
         * the step nav on the left Side of the wizard.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A read-only getter that returns whether or not the page is navigable
         * in the wizard. A wizard page can be navigated to if it is completed
         * or the page before it is completed.
         *
         * This getter handles the logic for enabling or disabling the links in
         * the step nav on the left Side of the wizard.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this.current || this.completed || this.previousCompleted;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "previousCompleted", {
        /**
         * A read-only getter that returns whether or not the page before this
         * ClrWizardPage is completed. This is useful for determining whether or not
         * a page is navigable if it is not current or already completed.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A read-only getter that returns whether or not the page before this
         * ClrWizardPage is completed. This is useful for determining whether or not
         * a page is navigable if it is not current or already completed.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            /** @type {?} */
            var previousPage = this.pageCollection.getPreviousPage(this);
            if (!previousPage) {
                return true;
            }
            return previousPage.completed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "title", {
        /**
         *
         * @memberof WizardPage
         *
         */
        get: /**
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this.pageTitle.pageTitleTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "navTitle", {
        /**
         *
         * @memberof WizardPage
         *
         */
        get: /**
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            if (this.pageNavTitle) {
                return this.pageNavTitle.pageNavTitleTemplateRef;
            }
            return this.pageTitle.pageTitleTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "headerActions", {
        /**
         *
         * @memberof WizardPage
         *
         */
        get: /**
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            if (!this._headerActions) {
                return;
            }
            return this._headerActions.pageHeaderActionsTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "hasHeaderActions", {
        /**
         *
         * @memberof WizardPage
         *
         */
        get: /**
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return !!this._headerActions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "buttons", {
        /**
         *
         * @memberof WizardPage
         *
         */
        get: /**
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            if (!this._buttons) {
                return;
            }
            return this._buttons.pageButtonsTemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardPage.prototype, "hasButtons", {
        /**
         * A read-only getter that returns a boolean that says whether or
         * not the ClrWizardPage includes buttons. Used to determine if the
         * Wizard should override the default button set defined as
         * its direct children.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A read-only getter that returns a boolean that says whether or
         * not the ClrWizardPage includes buttons. Used to determine if the
         * Wizard should override the default button set defined as
         * its direct children.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return !!this._buttons;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Uses the nav service to make the ClrWizardPage the current page in the
     * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
     * (clrWizardPageOnLoad) output.
     *
     * In most cases, it is better to use the default navigation functions
     * in Wizard.
     *
     * @memberof WizardPage
     *
     */
    /**
     * Uses the nav service to make the ClrWizardPage the current page in the
     * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
     * (clrWizardPageOnLoad) output.
     *
     * In most cases, it is better to use the default navigation functions
     * in Wizard.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    ClrWizardPage.prototype.makeCurrent = /**
     * Uses the nav service to make the ClrWizardPage the current page in the
     * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
     * (clrWizardPageOnLoad) output.
     *
     * In most cases, it is better to use the default navigation functions
     * in Wizard.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    function () {
        this.navService.currentPage = this;
    };
    /**
     * Links the nav service and establishes the current page if one is not defined.
     *
     * @memberof WizardPage
     *
     */
    /**
     * Links the nav service and establishes the current page if one is not defined.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    ClrWizardPage.prototype.ngOnInit = /**
     * Links the nav service and establishes the current page if one is not defined.
     *
     * \@memberof WizardPage
     *
     * @return {?}
     */
    function () {
        /** @type {?} */
        var navService = this.navService;
        if (!navService.currentPage && !navService.navServiceLoaded) {
            this.makeCurrent();
            this.navService.navServiceLoaded = true;
        }
    };
    Object.defineProperty(ClrWizardPage.prototype, "stepItemId", {
        /**
         * A read-only getter that returns the id used by the step nav item associated with the page.
         *
         * ClrWizardPage needs this ID string for aria information.
         *
         * @memberof WizardPage
         *
         */
        get: /**
         * A read-only getter that returns the id used by the step nav item associated with the page.
         *
         * ClrWizardPage needs this ID string for aria information.
         *
         * \@memberof WizardPage
         *
         * @return {?}
         */
        function () {
            return this.pageCollection.getStepItemIdForPage(this);
        },
        enumerable: true,
        configurable: true
    });
    ClrWizardPage.decorators = [
        { type: Component, args: [{
                    selector: 'clr-wizard-page',
                    template: '<ng-content></ng-content>',
                    host: {
                        '[id]': 'id',
                        role: 'tabpanel',
                        '[attr.aria-hidden]': '!current',
                        '[attr.aria-labelledby]': 'stepItemId',
                        '[class.active]': 'current',
                        '[class.clr-wizard-page]': 'true',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrWizardPage.ctorParameters = function () { return [
        { type: WizardNavigationService },
        { type: PageCollectionService },
        { type: ButtonHubService }
    ]; };
    ClrWizardPage.propDecorators = {
        pageTitle: [{ type: ContentChild, args: [ClrWizardPageTitle,] }],
        pageNavTitle: [{ type: ContentChild, args: [ClrWizardPageNavTitle,] }],
        _buttons: [{ type: ContentChild, args: [ClrWizardPageButtons,] }],
        _headerActions: [{ type: ContentChild, args: [ClrWizardPageHeaderActions,] }],
        nextStepDisabled: [{ type: Input, args: ['clrWizardPageNextDisabled',] }],
        nextStepDisabledChange: [{ type: Output, args: ['clrWizardPageNextDisabledChange',] }],
        previousStepDisabled: [{ type: Input, args: ['clrWizardPagePreviousDisabled',] }],
        previousStepDisabledChange: [{ type: Output, args: ['clrWizardPagePreviousDisabledChange',] }],
        preventDefault: [{ type: Input, args: ['clrWizardPagePreventDefault',] }],
        stopCancel: [{ type: Input, args: ['clrWizardPagePreventDefaultCancel',] }],
        stopCancelChange: [{ type: Output, args: ['clrWizardPagePreventDefaultCancelChange',] }],
        stopNext: [{ type: Input, args: ['clrWizardPagePreventDefaultNext',] }],
        onCommit: [{ type: Output, args: ['clrWizardPageOnCommit',] }],
        onLoad: [{ type: Output, args: ['clrWizardPageOnLoad',] }],
        pageOnCancel: [{ type: Output, args: ['clrWizardPageOnCancel',] }],
        finishButtonClicked: [{ type: Output, args: ['clrWizardPageFinish',] }],
        previousButtonClicked: [{ type: Output, args: ['clrWizardPagePrevious',] }],
        nextButtonClicked: [{ type: Output, args: ['clrWizardPageNext',] }],
        dangerButtonClicked: [{ type: Output, args: ['clrWizardPageDanger',] }],
        primaryButtonClicked: [{ type: Output, args: ['clrWizardPagePrimary',] }],
        customButtonClicked: [{ type: Output, args: ['clrWizardPageCustomButton',] }],
        _id: [{ type: Input, args: ['id',] }]
    };
    return ClrWizardPage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * The Wizard component
 *
 */
var ClrWizard = /** @class */ (function () {
    /**
     * Creates an instance of Wizard.
     *
     * @memberof Wizard
     *
     */
    function ClrWizard(navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
        var _this = this;
        this.navService = navService;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        this.headerActionService = headerActionService;
        this.elementRef = elementRef;
        /**
         * Contains the size defined by the clrWizardSize input
         *
         * \@memberof Wizard
         *
         */
        this.size = 'xl';
        this._forceForward = false;
        /**
         * Tells the modal part of the wizard whether it should have a close "X"
         * in the top right corner. Set with the clrWizardClosable input.
         *
         * \@memberof Wizard
         *
         */
        this.closable = true;
        /**
         * Toggles open/close of the wizard component. Set using the clrWizardOpen
         * input.
         *
         * \@memberof Wizard
         *
         */
        this._open = false;
        /**
         * Emits when the wizard is opened or closed. Emits through the
         * clrWizardOpenChange output. Works in conjunction with the
         * clrWizardOpen binding so you can use...
         *
         * <clr-wizard [(clrWizardOpen)]="blah"
         * ...or...
         * <clr-wizard [clrWizardOpen]="something" (clrWizardOpenChange)="doSomethign($event)">
         *
         * ...for two-way binding.
         *
         * \@memberof Wizard
         *
         */
        this._openChanged = new EventEmitter(false);
        /**
         * Emits when the wizard is canceled. Can be observed through the clrWizardOnCancel
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultCancel input to create
         * wizard-level custom cancel routines.
         *
         * \@memberof Wizard
         *
         */
        this.onCancel = new EventEmitter(false);
        /**
         * Emits when the wizard is completed. Can be observed through the clrWizardOnFinish
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultNext input to create
         * wizard-level custom completion routines.
         *
         * \@memberof Wizard
         *
         */
        this.wizardFinished = new EventEmitter(false);
        /**
         * Emits when the wizard is reset. See .reset(). Can be observed through
         * the clrWizardOnReset output.
         *
         * \@memberof Wizard
         *
         */
        this.onReset = new EventEmitter(false);
        /**
         * Emits when the current page has changed. Can be observed through the clrWizardCurrentPageChanged
         * output. This can happen on .next() or .previous().
         * Useful for non-blocking validation.
         *
         * \@memberof Wizard
         *
         */
        this.currentPageChanged = new EventEmitter(false);
        /**
         * Emits when the wizard moves to the next page. Can be observed through the clrWizardOnNext
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultNext input to create
         * wizard-level custom navigation routines, which are useful for validation.
         *
         * \@memberof Wizard
         *
         */
        this.onMoveNext = new EventEmitter(false);
        /**
         * Emits when the wizard moves to the previous page. Can be observed through the
         * clrWizardOnPrevious output.
         *
         * Can be useful for validation.
         *
         * \@memberof Wizard
         *
         */
        this.onMovePrevious = new EventEmitter(false);
        this._stopNext = false;
        this._stopCancel = false;
        this._stopNavigation = false;
        this._disableStepnav = false;
        /**
         * Used only to communicate to the underlying modal that animations are not
         * wanted. Primary use is for the display of static/inline wizards.
         *
         * Set using clrWizardPreventModalAnimation input. But you should never set it.
         *
         * \@memberof Wizard
         *
         */
        this._stopModalAnimations = false;
        this.goNextSubscription = this.navService.movedToNextPage.subscribe(function () {
            _this.onMoveNext.emit();
        });
        this.goPreviousSubscription = this.navService.movedToPreviousPage.subscribe(function () {
            _this.onMovePrevious.emit();
        });
        this.cancelSubscription = this.navService.notifyWizardCancel.subscribe(function () {
            _this.checkAndCancel();
        });
        this.wizardFinishedSubscription = this.navService.wizardFinished.subscribe(function () {
            if (!_this.stopNext) {
                _this.forceFinish();
            }
            _this.wizardFinished.emit();
        });
        this.differ = differs.find([]).create(null);
    }
    Object.defineProperty(ClrWizard.prototype, "forceForward", {
        get: /**
         * @return {?}
         */
        function () {
            return this._forceForward;
        },
        /**
         * Resets page completed states when navigating backwards. Can be set using
         * the clrWizardForceForwardNavigation input.
         *
         * @memberof Wizard
         *
         */
        set: /**
         * Resets page completed states when navigating backwards. Can be set using
         * the clrWizardForceForwardNavigation input.
         *
         * \@memberof Wizard
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._forceForward = !!value;
            this.navService.forceForwardNavigation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "clrWizardOpen", {
        set: /**
         * @param {?} open
         * @return {?}
         */
        function (open) {
            if (open) {
                this.buttonService.buttonsReady = true;
            }
            this._open = open;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "stopNext", {
        get: /**
         * @return {?}
         */
        function () {
            return this._stopNext;
        },
        /**
         * Prevents ClrWizard from moving to the next page or closing itself on finishing.
         * Set using the clrWizardPreventDefaultNext input.
         *
         * Note that using stopNext will require you to create your own calls to
         * .next() and .finish() in your host component to make the ClrWizard work as
         * expected.
         *
         * Primarily used for validation.
         *
         * @memberof Wizard
         *
         */
        set: /**
         * Prevents ClrWizard from moving to the next page or closing itself on finishing.
         * Set using the clrWizardPreventDefaultNext input.
         *
         * Note that using stopNext will require you to create your own calls to
         * .next() and .finish() in your host component to make the ClrWizard work as
         * expected.
         *
         * Primarily used for validation.
         *
         * \@memberof Wizard
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._stopNext = !!value;
            this.navService.wizardHasAltNext = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "stopCancel", {
        get: /**
         * @return {?}
         */
        function () {
            return this._stopCancel;
        },
        /**
         * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
         * Set using the clrWizardPreventDefaultCancel input.
         *
         * Note that using stopCancel will require you to create your own calls to
         * .close() in your host component to make the ClrWizard work as expected.
         *
         * Useful for doing checks or prompts before closing a ClrWizard.
         *
         * @memberof Wizard
         *
         */
        set: /**
         * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
         * Set using the clrWizardPreventDefaultCancel input.
         *
         * Note that using stopCancel will require you to create your own calls to
         * .close() in your host component to make the ClrWizard work as expected.
         *
         * Useful for doing checks or prompts before closing a ClrWizard.
         *
         * \@memberof Wizard
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._stopCancel = !!value;
            this.navService.wizardHasAltCancel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "stopNavigation", {
        get: /**
         * @return {?}
         */
        function () {
            return this._stopNavigation;
        },
        /**
         * Prevents ClrWizard from performing any form of navigation away from the current
         * page. Set using the clrWizardPreventNavigation input.
         *
         * Note that stopNavigation is meant to freeze the wizard in place, typically
         * during a long validation or background action where you want the wizard to
         * display loading content but not allow the user to execute navigation in
         * the stepnav, close X, or the  back, finish, or next buttons.
         *
         * @memberof Wizard
         *
         */
        set: /**
         * Prevents ClrWizard from performing any form of navigation away from the current
         * page. Set using the clrWizardPreventNavigation input.
         *
         * Note that stopNavigation is meant to freeze the wizard in place, typically
         * during a long validation or background action where you want the wizard to
         * display loading content but not allow the user to execute navigation in
         * the stepnav, close X, or the  back, finish, or next buttons.
         *
         * \@memberof Wizard
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._stopNavigation = !!value;
            this.navService.wizardStopNavigation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "disableStepnav", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disableStepnav;
        },
        /**
         * Prevents clicks on the links in the stepnav from working.
         *
         * A more granular bypassing of navigation which can be useful when your
         * ClrWizard is in a state of completion and you don't want users to be
         * able to jump backwards and change things.
         *
         * @memberof Wizard
         *
         */
        set: /**
         * Prevents clicks on the links in the stepnav from working.
         *
         * A more granular bypassing of navigation which can be useful when your
         * ClrWizard is in a state of completion and you don't want users to be
         * able to jump backwards and change things.
         *
         * \@memberof Wizard
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disableStepnav = !!value;
            this.navService.wizardDisableStepnav = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "stopModalAnimations", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._stopModalAnimations) {
                return 'true';
            }
            return 'false';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrWizard.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.currentPageSubscription = this.navService.currentPageChanged.subscribe(function (page) {
            _this.currentPageChanged.emit();
        });
    };
    /**
     * @return {?}
     */
    ClrWizard.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.goNextSubscription) {
            this.goNextSubscription.unsubscribe();
        }
        if (this.goPreviousSubscription) {
            this.goPreviousSubscription.unsubscribe();
        }
        if (this.cancelSubscription) {
            this.cancelSubscription.unsubscribe();
        }
        if (this.currentPageSubscription) {
            this.currentPageSubscription.unsubscribe();
        }
        if (this.wizardFinishedSubscription) {
            this.wizardFinishedSubscription.unsubscribe();
        }
    };
    /**
     * Sets up references that are needed by the providers.
     *
     * @name ngAfterContentInit
     * @memberof Wizard
     *
     */
    /**
     * Sets up references that are needed by the providers.
     *
     * \@name ngAfterContentInit
     * \@memberof Wizard
     *
     * @return {?}
     */
    ClrWizard.prototype.ngAfterContentInit = /**
     * Sets up references that are needed by the providers.
     *
     * \@name ngAfterContentInit
     * \@memberof Wizard
     *
     * @return {?}
     */
    function () {
        this.pageCollection.pages = this.pages;
        this.headerActionService.wizardHeaderActions = this.headerActions;
        // Only trigger buttons ready if default is open (inlined)
        if (this._open) {
            this.buttonService.buttonsReady = true;
        }
    };
    /**
     * Used for keeping track of when pages are added or removed from this.pages
     *
     * @name ngDoCheck
     * @memberof Wizard
     *
     */
    /**
     * Used for keeping track of when pages are added or removed from this.pages
     *
     * \@name ngDoCheck
     * \@memberof Wizard
     *
     * @return {?}
     */
    ClrWizard.prototype.ngDoCheck = /**
     * Used for keeping track of when pages are added or removed from this.pages
     *
     * \@name ngDoCheck
     * \@memberof Wizard
     *
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var changes = this.differ.diff(this.pages);
        if (changes) {
            changes.forEachAddedItem(function (r) {
                _this.navService.updateNavigation();
            });
            changes.forEachRemovedItem(function (r) {
                _this.navService.updateNavigation();
            });
        }
    };
    Object.defineProperty(ClrWizard.prototype, "isStatic", {
        /**
         * Convenient property for determining whether a wizard is static/in-line or not.
         *
         * @name isStatic
         *
         * @memberof Wizard
         *
         */
        get: /**
         * Convenient property for determining whether a wizard is static/in-line or not.
         *
         * \@name isStatic
         *
         * \@memberof Wizard
         *
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement.classList.contains('clr-wizard--inline');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "currentPage", {
        /**
         * As a getter, current page is a convenient way to retrieve the current page from
         * the WizardNavigationService.
         *
         * As a setter, current page accepts a ClrWizardPage and passes it to WizardNavigationService
         * to be made the current page. currentPage performs checks to make sure it can navigate
         * to the designated page.
         *
         * @name currentPage
         *
         * @memberof Wizard
         *
         */
        get: /**
         * As a getter, current page is a convenient way to retrieve the current page from
         * the WizardNavigationService.
         *
         * As a setter, current page accepts a ClrWizardPage and passes it to WizardNavigationService
         * to be made the current page. currentPage performs checks to make sure it can navigate
         * to the designated page.
         *
         * \@name currentPage
         *
         * \@memberof Wizard
         *
         * @return {?}
         */
        function () {
            return this.navService.currentPage;
        },
        set: /**
         * @param {?} page
         * @return {?}
         */
        function (page) {
            this.navService.goTo(page, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "isLast", {
        /**
         * Convenient property for determining if the current page is the last page of
         * the wizard.
         *
         * @name isLast
         *
         * @memberof Wizard
         *
         */
        get: /**
         * Convenient property for determining if the current page is the last page of
         * the wizard.
         *
         * \@name isLast
         *
         * \@memberof Wizard
         *
         * @return {?}
         */
        function () {
            return this.navService.currentPageIsLast;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizard.prototype, "isFirst", {
        /**
         * Convenient property for determining if the current page is the first page of
         * the wizard.
         *
         * @name isFirst
         *
         * @memberof Wizard
         *
         */
        get: /**
         * Convenient property for determining if the current page is the first page of
         * the wizard.
         *
         * \@name isFirst
         *
         * \@memberof Wizard
         *
         * @return {?}
         */
        function () {
            return this.navService.currentPageIsFirst;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Performs the actions needed to open the wizard. If there is no current
     * page defined, sets the first page in the wizard to be current.
     *
     * @name open
     * @memberof ClrWizard
     */
    /**
     * Performs the actions needed to open the wizard. If there is no current
     * page defined, sets the first page in the wizard to be current.
     *
     * \@name open
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.open = /**
     * Performs the actions needed to open the wizard. If there is no current
     * page defined, sets the first page in the wizard to be current.
     *
     * \@name open
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        this._open = true;
        if (!this.currentPage) {
            this.navService.setFirstPageCurrent();
        }
        // Only render buttons when wizard is opened, to avoid chocolate errors
        this.buttonService.buttonsReady = true;
        this._openChanged.emit(true);
    };
    /**
     * Does the work involved with closing the wizard. Call this directly instead
     * of cancel() to implement alternative cancel functionality.
     *
     * @name close
     * @memberof ClrWizard
     */
    /**
     * Does the work involved with closing the wizard. Call this directly instead
     * of cancel() to implement alternative cancel functionality.
     *
     * \@name close
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.close = /**
     * Does the work involved with closing the wizard. Call this directly instead
     * of cancel() to implement alternative cancel functionality.
     *
     * \@name close
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        if (this.stopNavigation) {
            return;
        }
        this._open = false;
        this._openChanged.emit(false);
    };
    /**
     * Convenient function that can be used to open and close the wizard. It operates
     * by checking a Boolean parameter. If true, the wizard is opened. If false,
     * it is closed.
     *
     * There is no default value for this parameter, so by default the wizard will
     * close if invoked with no parameter.
     *
     * @name toggle
     *
     * @memberof ClrWizard
     */
    /**
     * Convenient function that can be used to open and close the wizard. It operates
     * by checking a Boolean parameter. If true, the wizard is opened. If false,
     * it is closed.
     *
     * There is no default value for this parameter, so by default the wizard will
     * close if invoked with no parameter.
     *
     * \@name toggle
     *
     * \@memberof ClrWizard
     * @param {?} value
     * @return {?}
     */
    ClrWizard.prototype.toggle = /**
     * Convenient function that can be used to open and close the wizard. It operates
     * by checking a Boolean parameter. If true, the wizard is opened. If false,
     * it is closed.
     *
     * There is no default value for this parameter, so by default the wizard will
     * close if invoked with no parameter.
     *
     * \@name toggle
     *
     * \@memberof ClrWizard
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.open();
        }
        else {
            this.close();
        }
    };
    /**
     * Moves the wizard to the previous page.
     *
     * @name previous
     * @memberof ClrWizard
     */
    /**
     * Moves the wizard to the previous page.
     *
     * \@name previous
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.previous = /**
     * Moves the wizard to the previous page.
     *
     * \@name previous
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        this.navService.previous();
    };
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will move to the next page regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * Generally, with alternative navigation, users are supplying their own checks
     * and validation. So there is no point in superseding their business logic
     * with our default behavior.
     *
     * If false, the wizard will execute default checks and emit events as normal.
     * This is useful for custom buttons or programmatic workflows that are not
     * executing the wizards default checks and emissions. It is another way to
     * navigate without having to rewrite the wizard’s default functionality
     * from scratch.
     *
     * By default, next() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * @name next
     * @memberof ClrWizard
     */
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will move to the next page regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * Generally, with alternative navigation, users are supplying their own checks
     * and validation. So there is no point in superseding their business logic
     * with our default behavior.
     *
     * If false, the wizard will execute default checks and emit events as normal.
     * This is useful for custom buttons or programmatic workflows that are not
     * executing the wizards default checks and emissions. It is another way to
     * navigate without having to rewrite the wizard’s default functionality
     * from scratch.
     *
     * By default, next() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * \@name next
     * \@memberof ClrWizard
     * @param {?=} skipChecksAndEmits
     * @return {?}
     */
    ClrWizard.prototype.next = /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will move to the next page regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * Generally, with alternative navigation, users are supplying their own checks
     * and validation. So there is no point in superseding their business logic
     * with our default behavior.
     *
     * If false, the wizard will execute default checks and emit events as normal.
     * This is useful for custom buttons or programmatic workflows that are not
     * executing the wizards default checks and emissions. It is another way to
     * navigate without having to rewrite the wizard’s default functionality
     * from scratch.
     *
     * By default, next() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * \@name next
     * \@memberof ClrWizard
     * @param {?=} skipChecksAndEmits
     * @return {?}
     */
    function (skipChecksAndEmits) {
        if (skipChecksAndEmits === void 0) { skipChecksAndEmits = true; }
        if (skipChecksAndEmits) {
            this.forceNext();
        }
        else {
            this.navService.next();
        }
    };
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will  complete and close regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * If false, the wizard will execute default checks and emit events before
     * completing and closing.
     *
     * By default, finish() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * @name finish
     * @memberof ClrWizard
     */
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will  complete and close regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * If false, the wizard will execute default checks and emit events before
     * completing and closing.
     *
     * By default, finish() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * \@name finish
     * \@memberof ClrWizard
     * @param {?=} skipChecksAndEmits
     * @return {?}
     */
    ClrWizard.prototype.finish = /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will  complete and close regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * If false, the wizard will execute default checks and emit events before
     * completing and closing.
     *
     * By default, finish() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * \@name finish
     * \@memberof ClrWizard
     * @param {?=} skipChecksAndEmits
     * @return {?}
     */
    function (skipChecksAndEmits) {
        if (skipChecksAndEmits === void 0) { skipChecksAndEmits = true; }
        if (skipChecksAndEmits) {
            this.forceFinish();
        }
        else {
            this.navService.finish();
        }
    };
    /**
     * Does the work of finishing up the wizard and closing it but doesn't do the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.finish(true) or ClrWizard.finish()
     * without a parameter.
     *
     * @name forceFinish
     * @memberof ClrWizard
     */
    /**
     * Does the work of finishing up the wizard and closing it but doesn't do the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.finish(true) or ClrWizard.finish()
     * without a parameter.
     *
     * \@name forceFinish
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.forceFinish = /**
     * Does the work of finishing up the wizard and closing it but doesn't do the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.finish(true) or ClrWizard.finish()
     * without a parameter.
     *
     * \@name forceFinish
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        if (this.stopNavigation) {
            return;
        }
        this.close();
    };
    /**
     * Does the work of moving the wizard to the next page without the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.next(true) or ClrWizard.next()
     * without a parameter.
     *
     * @name forceNext
     * @memberof ClrWizard
     */
    /**
     * Does the work of moving the wizard to the next page without the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.next(true) or ClrWizard.next()
     * without a parameter.
     *
     * \@name forceNext
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.forceNext = /**
     * Does the work of moving the wizard to the next page without the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling ClrWizard.next(true) or ClrWizard.next()
     * without a parameter.
     *
     * \@name forceNext
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        this.navService.forceNext();
    };
    /**
     * Initiates the functionality that cancels and closes the wizard.
     *
     * Do not use this for an override of the cancel the functionality
     * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
     * or clrWizardPagePreventDefault because it will initiate the same checks
     * and event emissions that invoked your event handler.
     *
     * Use ClrWizard.close() instead.
     *
     * @name cancel
     * @memberof ClrWizard
     */
    /**
     * Initiates the functionality that cancels and closes the wizard.
     *
     * Do not use this for an override of the cancel the functionality
     * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
     * or clrWizardPagePreventDefault because it will initiate the same checks
     * and event emissions that invoked your event handler.
     *
     * Use ClrWizard.close() instead.
     *
     * \@name cancel
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.cancel = /**
     * Initiates the functionality that cancels and closes the wizard.
     *
     * Do not use this for an override of the cancel the functionality
     * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
     * or clrWizardPagePreventDefault because it will initiate the same checks
     * and event emissions that invoked your event handler.
     *
     * Use ClrWizard.close() instead.
     *
     * \@name cancel
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        this.navService.cancel();
    };
    /**
     * Overrides behavior of the underlying modal to avoid collisions with
     * alternative cancel functionality.
     *
     * In most cases, use ClrWizard.cancel() instead.
     *
     * @name modalCancel
     * @memberof ClrWizard
     */
    /**
     * Overrides behavior of the underlying modal to avoid collisions with
     * alternative cancel functionality.
     *
     * In most cases, use ClrWizard.cancel() instead.
     *
     * \@name modalCancel
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.modalCancel = /**
     * Overrides behavior of the underlying modal to avoid collisions with
     * alternative cancel functionality.
     *
     * In most cases, use ClrWizard.cancel() instead.
     *
     * \@name modalCancel
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        this.checkAndCancel();
    };
    /**
     * Checks for alternative cancel flows defined at the current page or
     * wizard level. Performs a canceled if not. Emits events that initiate
     * the alternative cancel outputs (clrWizardPageOnCancel and
     * clrWizardOnCancel) if so.
     *
     * @name checkAndCancel
     * @memberof ClrWizard
     */
    /**
     * Checks for alternative cancel flows defined at the current page or
     * wizard level. Performs a canceled if not. Emits events that initiate
     * the alternative cancel outputs (clrWizardPageOnCancel and
     * clrWizardOnCancel) if so.
     *
     * \@name checkAndCancel
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.checkAndCancel = /**
     * Checks for alternative cancel flows defined at the current page or
     * wizard level. Performs a canceled if not. Emits events that initiate
     * the alternative cancel outputs (clrWizardPageOnCancel and
     * clrWizardOnCancel) if so.
     *
     * \@name checkAndCancel
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentPage = this.currentPage;
        /** @type {?} */
        var currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
        if (this.stopNavigation) {
            return;
        }
        currentPage.pageOnCancel.emit();
        if (!currentPageHasOverrides) {
            this.onCancel.emit();
        }
        if (!this.stopCancel && !currentPageHasOverrides) {
            this.close();
        }
    };
    /**
     * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
     * to navigate to the page with that ID. Navigation will invoke the wizard’s default
     * checks and event emissions.
     *
     * Probably less useful than calling directly to ClrWizard.navService.goTo() because the
     * nav service method can accept either a string ID or a page object.
     *
     * The format of the expected ID parameter can be found in the return of the
     * ClrWizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
     * numeric ID or the ID specified for the ClrWizardPage component’s “id” input.
     *
     * @name goTo
     *
     * @memberof ClrWizard
     */
    /**
     * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
     * to navigate to the page with that ID. Navigation will invoke the wizard’s default
     * checks and event emissions.
     *
     * Probably less useful than calling directly to ClrWizard.navService.goTo() because the
     * nav service method can accept either a string ID or a page object.
     *
     * The format of the expected ID parameter can be found in the return of the
     * ClrWizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
     * numeric ID or the ID specified for the ClrWizardPage component’s “id” input.
     *
     * \@name goTo
     *
     * \@memberof ClrWizard
     * @param {?} pageId
     * @return {?}
     */
    ClrWizard.prototype.goTo = /**
     * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
     * to navigate to the page with that ID. Navigation will invoke the wizard’s default
     * checks and event emissions.
     *
     * Probably less useful than calling directly to ClrWizard.navService.goTo() because the
     * nav service method can accept either a string ID or a page object.
     *
     * The format of the expected ID parameter can be found in the return of the
     * ClrWizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
     * numeric ID or the ID specified for the ClrWizardPage component’s “id” input.
     *
     * \@name goTo
     *
     * \@memberof ClrWizard
     * @param {?} pageId
     * @return {?}
     */
    function (pageId) {
        if (!pageId) {
            return;
        }
        this.navService.goTo(pageId);
    };
    /**
     * A convenience function that calls to PageCollectionService.reset() and emits the
     * ClrWizard.onReset event.
     *
     * Reset sets all WizardPages to incomplete and sets the first page in the ClrWizard to
     * be the current page, essentially resetting the wizard navigation.
     *
     * Users would then use the onReset event to reset the data or model in their
     * host component.
     *
     * It could be useful to call a reset without firing the onReset event. To do this,
     * just call ClrWizard.pageCollection.reset() directly.
     *
     * @name reset
     * @memberof ClrWizard
     */
    /**
     * A convenience function that calls to PageCollectionService.reset() and emits the
     * ClrWizard.onReset event.
     *
     * Reset sets all WizardPages to incomplete and sets the first page in the ClrWizard to
     * be the current page, essentially resetting the wizard navigation.
     *
     * Users would then use the onReset event to reset the data or model in their
     * host component.
     *
     * It could be useful to call a reset without firing the onReset event. To do this,
     * just call ClrWizard.pageCollection.reset() directly.
     *
     * \@name reset
     * \@memberof ClrWizard
     * @return {?}
     */
    ClrWizard.prototype.reset = /**
     * A convenience function that calls to PageCollectionService.reset() and emits the
     * ClrWizard.onReset event.
     *
     * Reset sets all WizardPages to incomplete and sets the first page in the ClrWizard to
     * be the current page, essentially resetting the wizard navigation.
     *
     * Users would then use the onReset event to reset the data or model in their
     * host component.
     *
     * It could be useful to call a reset without firing the onReset event. To do this,
     * just call ClrWizard.pageCollection.reset() directly.
     *
     * \@name reset
     * \@memberof ClrWizard
     * @return {?}
     */
    function () {
        this.pageCollection.reset();
        this.onReset.next();
    };
    ClrWizard.decorators = [
        { type: Component, args: [{
                    selector: 'clr-wizard',
                    providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
                    template: "<!--\n  ~ Copyright (c) 2016-2018 VMware, Inc. All Rights Reserved.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-modal\n    [clrModalOpen]=\"_open\"\n    [clrModalSize]=\"size\"\n    [clrModalClosable]=\"closable\"\n    [clrModalStaticBackdrop]=\"true\"\n    [clrModalSkipAnimation]=\"stopModalAnimations\"\n    [clrModalOverrideScrollService]=\"isStatic\"\n    [clrModalPreventClose]=\"true\"\n    (clrModalAlternateClose)=\"modalCancel()\">\n\n    <nav class=\"modal-nav clr-wizard-stepnav-wrapper\">\n        <h3 class=\"clr-wizard-title\"><ng-content select=\"clr-wizard-title\"></ng-content></h3>\n        <clr-wizard-stepnav></clr-wizard-stepnav>\n    </nav>\n\n    <h3 class=\"modal-title\">\n        <span class=\"modal-title-text\">\n            <ng-template [ngTemplateOutlet]=\"navService.currentPageTitle\"></ng-template>\n        </span>\n\n        <div class=\"modal-header-actions-wrapper\" *ngIf=\"headerActionService.displayHeaderActionsWrapper\">\n            <div *ngIf=\"headerActionService.showWizardHeaderActions\">\n                <ng-content select=\"clr-wizard-header-action\"></ng-content>\n            </div>\n            <div *ngIf=\"headerActionService.currentPageHasHeaderActions\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.headerActions\"></ng-template>\n            </div>\n        </div>\n    </h3>\n\n    <div class=\"modal-body\">\n        <main clr-wizard-pages-wrapper class=\"clr-wizard-content\">\n            <ng-content></ng-content>\n        </main>\n    </div>\n    <div class=\"modal-footer clr-wizard-footer\">\n        <div class=\"clr-wizard-footer-buttons\">\n            <div *ngIf=\"navService.currentPage && !navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-content select=\"clr-wizard-button\"></ng-content>\n            </div>\n            <div *ngIf=\"navService.currentPage && navService.currentPage.hasButtons\"\n                class=\"clr-wizard-footer-buttons-wrapper\">\n                <ng-template [ngTemplateOutlet]=\"navService.currentPage.buttons\"></ng-template>\n            </div>\n        </div>\n    </div>\n</clr-modal>\n",
                    host: {
                        '[class.clr-wizard]': 'true',
                        '[class.wizard-md]': "size == 'md'",
                        '[class.wizard-lg]': "size == 'lg'",
                        '[class.wizard-xl]': "size == 'xl'",
                        '[class.lastPage]': 'navService.currentPageIsLast',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrWizard.ctorParameters = function () { return [
        { type: WizardNavigationService },
        { type: PageCollectionService },
        { type: ButtonHubService },
        { type: HeaderActionService },
        { type: ElementRef },
        { type: IterableDiffers }
    ]; };
    ClrWizard.propDecorators = {
        size: [{ type: Input, args: ['clrWizardSize',] }],
        forceForward: [{ type: Input, args: ['clrWizardForceForwardNavigation',] }],
        closable: [{ type: Input, args: ['clrWizardClosable',] }],
        clrWizardOpen: [{ type: Input, args: ['clrWizardOpen',] }],
        _openChanged: [{ type: Output, args: ['clrWizardOpenChange',] }],
        onCancel: [{ type: Output, args: ['clrWizardOnCancel',] }],
        wizardFinished: [{ type: Output, args: ['clrWizardOnFinish',] }],
        onReset: [{ type: Output, args: ['clrWizardOnReset',] }],
        pages: [{ type: ContentChildren, args: [ClrWizardPage,] }],
        headerActions: [{ type: ContentChildren, args: [ClrWizardHeaderAction,] }],
        currentPageChanged: [{ type: Output, args: ['clrWizardCurrentPageChanged',] }],
        onMoveNext: [{ type: Output, args: ['clrWizardOnNext',] }],
        onMovePrevious: [{ type: Output, args: ['clrWizardOnPrevious',] }],
        stopNext: [{ type: Input, args: ['clrWizardPreventDefaultNext',] }],
        stopCancel: [{ type: Input, args: ['clrWizardPreventDefaultCancel',] }],
        stopNavigation: [{ type: Input, args: ['clrWizardPreventNavigation',] }],
        disableStepnav: [{ type: Input, args: ['clrWizardDisableStepnav',] }],
        _stopModalAnimations: [{ type: Input, args: ['clrWizardPreventModalAnimation',] }]
    };
    return ClrWizard;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_BUTTON_TYPES = {
    cancel: 'cancel',
    previous: 'previous',
    next: 'next',
    finish: 'finish',
    danger: 'danger',
};
/** @type {?} */
var CUSTOM_BUTTON_TYPES = {
    cancel: 'custom-cancel',
    previous: 'custom-previous',
    next: 'custom-next',
    finish: 'custom-finish',
    danger: 'custom-danger',
};
var ClrWizardButton = /** @class */ (function () {
    function ClrWizardButton(navService, buttonService) {
        this.navService = navService;
        this.buttonService = buttonService;
        this.type = '';
        this.disabled = false;
        this.hidden = false;
        // EventEmitter which is emitted when a button is clicked.
        this.wasClicked = new EventEmitter(false);
    }
    /**
     * @param {?=} valueToCheck
     * @param {?=} typeToLookUp
     * @return {?}
     */
    ClrWizardButton.prototype.checkDefaultAndCustomType = /**
     * @param {?=} valueToCheck
     * @param {?=} typeToLookUp
     * @return {?}
     */
    function (valueToCheck, typeToLookUp) {
        if (valueToCheck === void 0) { valueToCheck = ''; }
        if (DEFAULT_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
            return true;
        }
        if (CUSTOM_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
            return true;
        }
        return false;
    };
    Object.defineProperty(ClrWizardButton.prototype, "isCancel", {
        get: /**
         * @return {?}
         */
        function () {
            return this.checkDefaultAndCustomType(this.type, 'cancel');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "isNext", {
        get: /**
         * @return {?}
         */
        function () {
            return this.checkDefaultAndCustomType(this.type, 'next');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "isPrevious", {
        get: /**
         * @return {?}
         */
        function () {
            return this.checkDefaultAndCustomType(this.type, 'previous');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "isFinish", {
        get: /**
         * @return {?}
         */
        function () {
            return this.checkDefaultAndCustomType(this.type, 'finish');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "isDanger", {
        get: /**
         * @return {?}
         */
        function () {
            return this.checkDefaultAndCustomType(this.type, 'danger');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "isPrimaryAction", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isNext || this.isDanger || this.isFinish;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "_disabledAttribute", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.isDisabled) {
                return '';
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            // dealing with negatives here. cognitively easier to think of it like this...
            /** @type {?} */
            var disabled = true;
            /** @type {?} */
            var nav = this.navService;
            /** @type {?} */
            var page = this.navService.currentPage;
            // Ensure we don't change the response until buttons are ready to avoid chocolate
            if (!this.buttonService.buttonsReady) {
                return !disabled;
            }
            if (this.disabled || nav.wizardStopNavigation || !page) {
                return true;
            }
            if (this.isCancel) {
                return !disabled;
            }
            if (this.isPrevious && (nav.currentPageIsFirst || page.previousStepDisabled)) {
                return disabled;
            }
            if (this.isDanger && !page.readyToComplete) {
                return disabled;
            }
            if (this.isNext && (nav.currentPageIsLast || !page.readyToComplete)) {
                return disabled;
            }
            if (this.isFinish && (!nav.currentPageIsLast || !page.readyToComplete)) {
                return disabled;
            }
            return !disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardButton.prototype, "isHidden", {
        get: /**
         * @return {?}
         */
        function () {
            // dealing with negatives here. cognitively easier to think of it like this...
            /** @type {?} */
            var hidden = true;
            /** @type {?} */
            var nav = this.navService;
            // Ensure we don't change the response until buttons are ready to avoid chocolate
            if (!this.buttonService.buttonsReady) {
                return !hidden;
            }
            if (this.hidden) {
                return true;
            }
            if (this.isCancel) {
                return !hidden;
            }
            if (this.isPrevious && nav.currentPageIsFirst) {
                return hidden;
            }
            if (this.isNext && nav.currentPageIsLast) {
                return hidden;
            }
            if (this.isFinish && !nav.currentPageIsLast) {
                return hidden;
            }
            return !hidden;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrWizardButton.prototype.click = /**
     * @return {?}
     */
    function () {
        if (this.isDisabled) {
            return;
        }
        this.wasClicked.emit(this.type);
        this.buttonService.buttonClicked(this.type);
    };
    ClrWizardButton.decorators = [
        { type: Component, args: [{
                    selector: 'clr-wizard-button',
                    template: "\n        <button\n            type=\"button\"\n            class=\"btn clr-wizard-btn\"\n            [class.btn-link]=\"isCancel\"\n            [class.clr-wizard-btn--tertiary]=\"isCancel\"\n            [class.btn-outline]=\"isPrevious\"\n            [class.clr-wizard-btn--secondary]=\"isPrevious\"\n            [class.btn-primary]=\"isPrimaryAction\"\n            [class.clr-wizard-btn--primary]=\"isPrimaryAction\"\n            [class.btn-success]=\"isFinish\"\n            [class.btn-danger]=\"isDanger\"\n            [class.disabled]=\"isDisabled\"\n            [attr.disabled]=\"_disabledAttribute\"\n            (click)=\"click()\">\n            <ng-content></ng-content>\n        </button>\n    ",
                    host: { class: 'clr-wizard-btn-wrapper', '[attr.aria-hidden]': 'isHidden' },
                    styles: ['[aria-hidden="true"] { display: none; }']
                }] }
    ];
    /** @nocollapse */
    ClrWizardButton.ctorParameters = function () { return [
        { type: WizardNavigationService },
        { type: ButtonHubService }
    ]; };
    ClrWizardButton.propDecorators = {
        type: [{ type: Input, args: ['type',] }],
        disabled: [{ type: Input, args: ['clrWizardButtonDisabled',] }],
        hidden: [{ type: Input, args: ['clrWizardButtonHidden',] }],
        wasClicked: [{ type: Output, args: ['clrWizardButtonClicked',] }]
    };
    return ClrWizardButton;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrWizardCustomTags = /** @class */ (function () {
    function ClrWizardCustomTags() {
    }
    ClrWizardCustomTags.decorators = [
        { type: Directive, args: [{ selector: 'clr-wizard-title, clr-wizard-pagetitle' },] }
    ];
    return ClrWizardCustomTags;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrWizardStepnav = /** @class */ (function () {
    function ClrWizardStepnav(pageService) {
        this.pageService = pageService;
    }
    ClrWizardStepnav.decorators = [
        { type: Component, args: [{
                    selector: 'clr-wizard-stepnav',
                    template: "\n        <ol class=\"clr-wizard-stepnav-list\" role=\"tablist\">\n            <li *ngFor=\"let page of pageService.pages\" clr-wizard-stepnav-item \n            [page]=\"page\" class=\"clr-wizard-stepnav-item\"></li>\n        </ol>\n    ",
                    host: { class: 'clr-wizard-stepnav' }
                }] }
    ];
    /** @nocollapse */
    ClrWizardStepnav.ctorParameters = function () { return [
        { type: PageCollectionService }
    ]; };
    return ClrWizardStepnav;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrWizardStepnavItem = /** @class */ (function () {
    function ClrWizardStepnavItem(navService, pageCollection) {
        this.navService = navService;
        this.pageCollection = pageCollection;
    }
    /**
     * @return {?}
     */
    ClrWizardStepnavItem.prototype.pageGuard = /**
     * @return {?}
     */
    function () {
        if (!this.page) {
            throw new Error('Wizard stepnav item is not associated with a wizard page.');
        }
    };
    Object.defineProperty(ClrWizardStepnavItem.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            this.pageGuard();
            return this.pageCollection.getStepItemIdForPage(this.page);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardStepnavItem.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            this.pageGuard();
            return this.page.disabled || this.navService.wizardStopNavigation || this.navService.wizardDisableStepnav;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardStepnavItem.prototype, "isCurrent", {
        get: /**
         * @return {?}
         */
        function () {
            this.pageGuard();
            return this.page.current;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardStepnavItem.prototype, "isComplete", {
        get: /**
         * @return {?}
         */
        function () {
            this.pageGuard();
            return this.page.completed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrWizardStepnavItem.prototype, "canNavigate", {
        get: /**
         * @return {?}
         */
        function () {
            this.pageGuard();
            return this.pageCollection.previousPageIsCompleted(this.page);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ClrWizardStepnavItem.prototype.click = /**
     * @return {?}
     */
    function () {
        this.pageGuard();
        // if we click on our own stepnav or a disabled stepnav, we don't want to do anything
        if (this.isDisabled || this.isCurrent) {
            return;
        }
        this.navService.goTo(this.page);
    };
    ClrWizardStepnavItem.decorators = [
        { type: Component, args: [{
                    selector: '[clr-wizard-stepnav-item]',
                    template: "\n        <button type=\"button\" class=\"btn btn-link clr-wizard-stepnav-link\" (click)=\"click()\">\n            <ng-template [ngTemplateOutlet]=\"page.navTitle\"></ng-template>\n        </button>\n    ",
                    host: {
                        '[id]': 'id',
                        '[attr.aria-selected]': 'isCurrent',
                        '[attr.aria-controls]': 'id',
                        role: 'tab',
                        '[class.clr-nav-link]': 'true',
                        '[class.nav-item]': 'true',
                        '[class.active]': 'isCurrent',
                        '[class.disabled]': 'isDisabled',
                        '[class.no-click]': '!canNavigate',
                        '[class.complete]': 'isComplete',
                    }
                }] }
    ];
    /** @nocollapse */
    ClrWizardStepnavItem.ctorParameters = function () { return [
        { type: WizardNavigationService },
        { type: PageCollectionService }
    ]; };
    ClrWizardStepnavItem.propDecorators = {
        page: [{ type: Input, args: ['page',] }]
    };
    return ClrWizardStepnavItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_WIZARD_DIRECTIVES = [
    ClrWizard,
    ClrWizardPage,
    ClrWizardStepnav,
    ClrWizardStepnavItem,
    ClrWizardButton,
    ClrWizardHeaderAction,
    ClrWizardCustomTags,
    ClrWizardPageTitle,
    ClrWizardPageNavTitle,
    ClrWizardPageButtons,
    ClrWizardPageHeaderActions,
];
var ClrWizardModule = /** @class */ (function () {
    function ClrWizardModule() {
    }
    ClrWizardModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, ClrModalModule, ClrAlertModule],
                    declarations: [CLR_WIZARD_DIRECTIVES],
                    exports: [CLR_WIZARD_DIRECTIVES],
                },] }
    ];
    return ClrWizardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClarityModule = /** @class */ (function () {
    function ClarityModule() {
    }
    ClarityModule.decorators = [
        { type: NgModule, args: [{
                    exports: [
                        ClrEmphasisModule,
                        ClrDataModule,
                        ClrIconModule,
                        ClrModalModule,
                        ClrLoadingModule,
                        ClrIfExpandModule,
                        ClrConditionalModule,
                        ClrFocusTrapModule,
                        ClrButtonModule,
                        ClrFormsModule,
                        ClrLayoutModule,
                        ClrPopoverModule,
                        ClrWizardModule,
                        ClrDragAndDropModule,
                    ],
                },] }
    ];
    return ClarityModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Private counter to generate unique IDs for the checkboxes, to bind the labels to them.
 * @type {?}
 */
var latestId = 0;
/**
 * @deprecated ClrCheckbox will be renamed to ClrCheckboxDeprecated in 0.12, and will be replaced with a new
 * implementation in 0.13, so if you import it you will need to update your references.
 */
var ClrCheckboxDeprecated = /** @class */ (function () {
    function ClrCheckboxDeprecated() {
        // If our host has an ID attribute, we use this instead of our index.
        this._id = (latestId++).toString();
        // If host provides an clrAriaLabeledBy input, we apply it to the checkbox
        this.clrAriaLabeledBy = null;
        // If our host has a name attribute, we apply it to the checkbox.
        this.name = null;
        // If the host is disabled we apply it to the checkbox
        this.disabled = false;
        // Support for inline checkboxes, adds the necessary class to the host
        this.inline = false;
        this._checked = false;
        this._indeterminate = false;
        this.indeterminateChange = new EventEmitter(false);
        this.change = new EventEmitter(false);
        /*
             * These callbacks will be given to us through the ControlValueAccessor interface,
             * and we need to call them when the user interacts with the checkbox.
             */
        this.onChangeCallback = function (_) { };
        this.onTouchedCallback = function () { };
    }
    Object.defineProperty(ClrCheckboxDeprecated.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return "clr-checkbox-" + this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrCheckboxDeprecated.prototype, "checked", {
        get: /**
         * @return {?}
         */
        function () {
            return this._checked;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._checked) {
                if (this._indeterminate) {
                    this.setIndeterminate(false);
                }
                this.setChecked(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClrCheckboxDeprecated.prototype, "indeterminate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._indeterminate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._indeterminate !== value) {
                if (this._checked) {
                    this.setChecked(false);
                }
                this.setIndeterminate(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.setIndeterminate = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._indeterminate = value;
        this.indeterminateChange.emit(this._indeterminate);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.setChecked = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._checked = value;
        this.change.emit(this._checked);
    };
    /**
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.checked = !this.checked;
        this.onChangeCallback(this.checked);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value === null) {
            value = false;
        }
        if (value !== this.checked) {
            this.checked = value;
        }
    };
    /**
     * @param {?} onChange
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.registerOnChange = /**
     * @param {?} onChange
     * @return {?}
     */
    function (onChange) {
        this.onChangeCallback = onChange;
    };
    /**
     * @param {?} onTouched
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.registerOnTouched = /**
     * @param {?} onTouched
     * @return {?}
     */
    function (onTouched) {
        this.onTouchedCallback = onTouched;
    };
    /**
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.touch = /**
     * @return {?}
     */
    function () {
        this.onTouchedCallback();
    };
    /**
     * @return {?}
     */
    ClrCheckboxDeprecated.prototype.checkIndeterminateState = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this.toggle();
        }
    };
    ClrCheckboxDeprecated.decorators = [
        { type: Component, args: [{
                    selector: 'clr-checkbox',
                    template: "\n        <!--\n            FIXME: We are not subscribed to the change event but the click event here.\n            The reason for that is because checkboxes behave differently on IE & Edge.\n            https://stackoverflow.com/a/19447939\n            \n            To fix that, we listen to every click event and then toggle the checkbox manually\n            to make it behave the same way across the browsers we support.\n            \n            This works for cases when users toggle the checkbox using the keyboard too:\n            https://stackoverflow.com/questions/27878940/spacebar-triggering-click-event-on-checkbox\n        -->\n        <input type=\"checkbox\" [attr.aria-labelledby]=\"clrAriaLabeledBy\"\n               [id]=\"id\" [name]=\"name\" [checked]=\"checked\"\n               [indeterminate]=\"indeterminate\" [disabled]=\"disabled\"\n               (blur)=\"touch()\" (click)=\"checkIndeterminateState()\">\n        <label [attr.for]=\"id\">\n            <ng-content></ng-content>\n        </label>\n    ",
                    host: { '[class.checkbox]': '!inline', '[class.checkbox-inline]': 'inline', '[class.disabled]': 'disabled' },
                    /*
                         * This provider lets us declare our checkbox as a ControlValueAccessor,
                         * which allows us to use [(ngModel)] directly on our component,
                         * with all the automatic features wiring that come with it.
                         */
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return ClrCheckboxDeprecated; }), multi: true }]
                }] }
    ];
    ClrCheckboxDeprecated.propDecorators = {
        _id: [{ type: Input, args: ['id',] }],
        clrAriaLabeledBy: [{ type: Input, args: ['clrAriaLabeledBy',] }],
        name: [{ type: Input, args: ['name',] }],
        disabled: [{ type: Input, args: ['clrDisabled',] }],
        inline: [{ type: Input, args: ['clrInline',] }],
        checked: [{ type: Input, args: ['clrChecked',] }],
        indeterminate: [{ type: Input, args: ['clrIndeterminate',] }],
        indeterminateChange: [{ type: Output, args: ['clrIndeterminateChange',] }],
        change: [{ type: Output, args: ['clrCheckedChange',] }]
    };
    return ClrCheckboxDeprecated;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
var CLR_CHECKBOX_DIRECTIVES = [ClrCheckboxDeprecated];
var ClrCheckboxDeprecatedModule = /** @class */ (function () {
    function ClrCheckboxDeprecatedModule() {
    }
    ClrCheckboxDeprecatedModule.decorators = [
        { type: NgModule, args: [{ imports: [CommonModule], declarations: [CLR_CHECKBOX_DIRECTIVES], exports: [CLR_CHECKBOX_DIRECTIVES] },] }
    ];
    return ClrCheckboxDeprecatedModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
var ClrFormsDeprecatedModule = /** @class */ (function () {
    function ClrFormsDeprecatedModule() {
    }
    ClrFormsDeprecatedModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule],
                    exports: [ClrCheckboxDeprecatedModule, ClrDatepickerModule],
                },] }
    ];
    return ClrFormsDeprecatedModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function collapse() {
    return [
        state('true', style({ height: 0, 'overflow-y': 'hidden' })),
        transition('true => false', [animate('0.2s ease-in-out', style({ height: '*', 'overflow-y': 'hidden' }))]),
        transition('false => true', [style({ height: '*', 'overflow-y': 'hidden' }), animate('0.2s ease-in-out')]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?=} opacity
 * @return {?}
 */
function fade(opacity) {
    if (opacity === void 0) { opacity = 1; }
    return [
        transition('void => *', [style({ opacity: 0 }), animate('0.2s ease-in-out', style({ opacity: opacity }))]),
        transition('* => void', [animate('0.2s ease-in-out', style({ opacity: 0 }))]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} direction
 * @return {?}
 */
function fadeSlide(direction) {
    /** @type {?} */
    var transform = null;
    if (direction === 'up') {
        transform = 'translate(0, 25%)';
    }
    else if (direction === 'down') {
        transform = 'translate(0, -25%)';
    }
    else if (direction === 'left') {
        transform = 'translate(25%, 0)';
    }
    else if (direction === 'right') {
        transform = 'translate(-25%, 0)';
    }
    else {
        throw new Error('Unknown direction ' + direction + ' for slide animation.');
    }
    return [
        transition('void => *', [style({ opacity: 0, transform: transform }), animate('0.2s ease-in-out')]),
        transition('* => void', [animate('0.2s ease-in-out', style({ opacity: 0, transform: transform }))]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * @param {?} direction
 * @return {?}
 */
function slide(direction) {
    /** @type {?} */
    var transform = null;
    if (direction === 'up') {
        transform = 'translate(0, 25%)';
    }
    else if (direction === 'down') {
        transform = 'translate(0, -25%)';
    }
    else if (direction === 'left') {
        transform = 'translate(25%, 0)';
    }
    else if (direction === 'right') {
        transform = 'translate(-25%, 0)';
    }
    else {
        throw new Error('Unknown direction ' + direction + ' for slide animation.');
    }
    return [
        transition('void => *', [style({ transform: transform }), animate('0.2s ease-in-out')]),
        transition('* => void', [animate('0.2s ease-in-out', style({ transform: transform }))]),
    ];
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { FocusTrapTracker as ÇlrFocusTrapTracker, ClarityModule, ClrButtonModule, ClrButton, ClrButtonGroup, CLR_BUTTON_GROUP_DIRECTIVES, ClrButtonGroupModule, ClrLoadingButton, CLR_LOADING_BUTTON_DIRECTIVES, ClrLoadingButtonModule, ClrDataModule, ClrDatagrid, ClrDatagridActionBar, ClrDatagridActionOverflow, ClrDatagridColumn, ClrDatagridColumnToggle, ClrDatagridHideableColumn, ClrDatagridFilter, ClrDatagridItems, ClrDatagridRow, ClrDatagridRowDetail, ClrDatagridCell, ClrDatagridFooter, ClrDatagridPagination, ClrDatagridPlaceholder, ClrDatagridSortOrder, DatagridStringFilter, DatagridPropertyStringFilter, DatagridPropertyComparator, CLR_DATAGRID_DIRECTIVES, ClrDatagridModule, ClrSelectedState, ClrTree, ClrTreeNode, ClrRecursiveForOf, CLR_TREE_VIEW_DIRECTIVES, ClrTreeViewModule, ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackInput, ClrStackSelect, CLR_STACK_VIEW_DIRECTIVES, ClrStackViewModule, ClrStackViewCustomTags, ClrEmphasisModule, ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, CLR_ALERT_DIRECTIVES, ClrAlertModule, ClrIfError, ClrControlError, ClrForm, ClrControlHelper, ClrLabel, ClrLayout, ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, isToggleFactory, IS_TOGGLE, IS_TOGGLE_PROVIDER, ClrCheckboxWrapper, ClrCheckboxModule, ClrDateContainer, ClrDateInput, ClrDatepickerViewManager, ClrDaypicker, ClrMonthpicker, ClrYearpicker, ClrCalendar, ClrDay, CLR_DATEPICKER_DIRECTIVES, ClrDatepickerModule, ClrInput, ClrInputContainer, ClrInputModule, ClrPassword, ToggleServiceFactory, TOGGLE_SERVICE, TOGGLE_SERVICE_PROVIDER, ClrPasswordContainer, ClrPasswordModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper, ClrRadioModule, ClrSelect, ClrSelectContainer, ClrSelectModule, ClrTextarea, ClrTextareaContainer, ClrTextareaModule, ClrFormsModule, ClrCheckboxDeprecated, CLR_CHECKBOX_DIRECTIVES, ClrCheckboxDeprecatedModule, ClrFormsDeprecatedModule, ClrIconCustomTag, CLR_ICON_DIRECTIVES, ClrIconModule, ClrLayoutModule, ClrMainContainer, CLR_LAYOUT_DIRECTIVES, ClrMainContainerModule, MainContainerWillyWonka, NavDetectionOompaLoompa, ClrHeader, ClrNavLevel, CLR_NAVIGATION_DIRECTIVES, ClrNavigationModule, ClrTabs, ClrTab, ClrTabContent, ClrTabOverflowContent, ClrTabLink, CLR_TABS_DIRECTIVES, ClrTabsModule, ClrVerticalNavGroupChildren, ClrVerticalNavGroup, ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavIcon, CLR_VERTICAL_NAV_DIRECTIVES, ClrVerticalNavModule, ClrModal, CLR_MODAL_DIRECTIVES, ClrModalModule, ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem, CLR_MENU_POSITIONS, CLR_DROPDOWN_DIRECTIVES, ClrDropdownModule, ClrPopoverModule, ClrSignpost, ClrSignpostContent, ClrSignpostTrigger, CLR_SIGNPOST_DIRECTIVES, ClrSignpostModule, ClrTooltip, ClrTooltipTrigger, ClrTooltipContent, CLR_TOOLTIP_DIRECTIVES, ClrTooltipModule, collapse, fade, fadeSlide, slide, ClrLoadingState, ClrLoading, LoadingListener, CLR_LOADING_DIRECTIVES, ClrLoadingModule, CONDITIONAL_DIRECTIVES, ClrIfActive, ClrIfOpen, EXPAND_DIRECTIVES, ClrIfExpanded, ClrCommonStrings, ClrDraggable, ClrDroppable, ClrIfDragged, ClrDragHandle, ClrDraggableGhost, ClrDragEvent, CLR_DRAG_AND_DROP_DIRECTIVES, ClrDragAndDropModule, ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, DEFAULT_BUTTON_TYPES, CUSTOM_BUTTON_TYPES, ClrWizardButton, ClrWizardHeaderAction, ClrWizardCustomTags, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions, CLR_WIZARD_DIRECTIVES, ClrWizardModule, ButtonInGroupService as ɵds, DatagridRowExpandAnimation as ɵdk, ActionableOompaLoompa as ɵdh, DatagridWillyWonka as ɵdf, ExpandableOompaLoompa as ɵdj, ClrDatagridColumnSeparator as ɵcn, ClrDatagridColumnToggleButton as ɵct, ClrDatagridColumnToggleTitle as ɵcs, DatagridDetailRegisterer as ɵcv, ClrDatagridItemsTrackBy as ɵcu, ClrDatagridPageSize as ɵcw, ColumnResizerService as ɵcr, ColumnToggleButtonsService as ɵcg, ColumnsService as ɵci, CustomFilter as ɵcl, DisplayModeService as ɵcj, FiltersProvider as ɵbx, ExpandableRowsCount as ɵcd, HideableColumnService as ɵce, Items as ɵbw, Page as ɵby, RowActionService as ɵcc, Selection as ɵbv, Sort as ɵca, StateDebouncer as ɵbz, StateProvider as ɵcf, TableSizeService as ɵch, DatagridCellRenderer as ɵde, DatagridHeaderRenderer as ɵdc, DatagridMainRenderer as ɵdb, domAdapterFactory as ɵda, DatagridRenderOrganizer as ɵcb, DatagridRowRenderer as ɵdd, DatagridFilterRegistrar as ɵck, WrappedCell as ɵcx, WrappedColumn as ɵcy, WrappedRow as ɵcz, StackControl as ɵdm, RecursiveChildren as ɵdq, TREE_FEATURES_PROVIDER as ɵdp, TreeFeaturesService as ɵdn, treeFeaturesFactory as ɵdo, AlertIconAndTypesService as ɵo, MultiAlertService as ɵp, IfErrorService as ɵt, ControlClassService as ɵba, ControlIdService as ɵq, FocusService as ɵbh, LayoutService as ɵr, MarkControlService as ɵu, IS_NEW_FORMS_LAYOUT as ɵv, IS_NEW_FORMS_LAYOUT_TRUE_PROVIDER as ɵw, NgControlService as ɵs, WrappedFormControl as ɵz, DateFormControlService as ɵbf, DateIOService as ɵbi, DateNavigationService as ɵbe, DatepickerEnabledService as ɵbj, DatepickerFocusService as ɵbk, LocaleHelperService as ɵbg, ViewManagerService as ɵbl, ResponsiveNavigationService as ɵdt, ActiveOompaLoompa as ɵed, TabsWillyWonka as ɵec, AriaService as ɵdx, TabsService as ɵeb, TABS_ID as ɵdy, TABS_ID_PROVIDER as ɵea, tokenFactory$1 as ɵdz, VerticalNavGroupRegistrationService as ɵeg, VerticalNavGroupService as ɵeh, VerticalNavIconService as ɵef, VerticalNavService as ɵee, AbstractPopover as ɵi, POPOVER_DIRECTIVES as ɵb, POPOVER_HOST_ANCHOR as ɵh, PopoverDirectiveOld as ɵc, ClrCommonPopoverModule as ɵa, ROOT_DROPDOWN_PROVIDER as ɵg, RootDropdownService as ɵe, clrRootDropdownFactory as ɵf, OompaLoompa as ɵdi, WillyWonka as ɵdg, ClrConditionalModule as ɵj, IF_ACTIVE_ID as ɵk, IF_ACTIVE_ID_PROVIDER as ɵm, IfActiveService as ɵn, tokenFactory as ɵl, IfOpenService as ɵd, DomAdapter as ɵbt, DragAndDropEventBusService as ɵbq, DragEventListenerService as ɵbp, DragHandleRegistrarService as ɵbr, DraggableSnapshotService as ɵbs, GlobalDragModeService as ɵbu, ClrIfExpandModule as ɵdl, Expand as ɵcm, FocusTrapDirective as ɵbd, ClrFocusTrapModule as ɵbb, FOCUS_TRAP_DIRECTIVES as ɵbc, EmptyAnchor as ɵy, ClrHostWrappingModule as ɵx, UNIQUE_ID as ɵco, UNIQUE_ID_PROVIDER as ɵcq, uniqueIdFactory as ɵcp, OUSTIDE_CLICK_DIRECTIVES as ɵbn, OutsideClick as ɵbo, ClrOutsideClickModule as ɵbm, ScrollingService as ɵdr, TEMPLATE_REF_DIRECTIVES as ɵdv, TemplateRefContainer as ɵdw, ClrTemplateRefModule as ɵdu, ButtonHubService as ɵek, HeaderActionService as ɵel, PageCollectionService as ɵej, WizardNavigationService as ɵei };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xyLWFuZ3VsYXIuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BjbHIvYW5ndWxhci9pY29uL2ljb24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9pY29uL2ljb24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vcG9wb3Zlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvY29tbW9uL3BvcG92ZXItb2xkLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvY29tbW9uL2luZGV4LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vcG9wb3Zlci5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9sb2FkaW5nL2xvYWRpbmcudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vcHJvdmlkZXJzL2J1dHRvbi1pbi1ncm91cC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvYnV0dG9uL2J1dHRvbi1ncm91cC9idXR0b24udHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2Ryb3Bkb3duL21lbnUtcG9zaXRpb25zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLWdyb3VwL2J1dHRvbi1ncm91cC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tZ3JvdXAvYnV0dG9uLWdyb3VwLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tbG9hZGluZy9sb2FkaW5nLWJ1dHRvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2J1dHRvbi9idXR0b24tbG9hZGluZy9sb2FkaW5nLWJ1dHRvbi5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9idXR0b24vYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZW1wdHktYW5jaG9yLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9lcnJvci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9oZWxwZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL25nLWNvbnRyb2wuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL2xhYmVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9uZXctZm9ybXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvbWFyay1jb250cm9sLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vZm9ybS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9sYXlvdXQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9jb21tb24vY29tbW9uLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LXdyYXBwZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3dyYXBwZWQtY29udHJvbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2NoZWNrYm94L2NoZWNrYm94LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY2hlY2tib3gvY2hlY2tib3gtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY2hlY2tib3gvY2hlY2tib3gubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5kaXJlY3RpdmUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jb25kaXRpb25hbC9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC10cmFja2VyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZm9jdXMtdHJhcC9pbmRleC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9rZXktY29kZXMva2V5LWNvZGVzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci91dGlscy9jb25zdGFudHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3V0aWxzL2RhdGUtdXRpbHMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL21vZGVsL2RheS12aWV3Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC9jYWxlbmRhci5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvbW9kZWwvZGF5Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC9jYWxlbmRhci12aWV3Lm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL2NhbGVuZGFyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL2RhdGUtaW8uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2JyZWFrcG9pbnRzL2JyZWFrcG9pbnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9wcm92aWRlcnMvZGF0ZXBpY2tlci1lbmFibGVkLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL2RhdGUtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlLWlucHV0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9jb21tb24vYWJzdHJhY3QtcG9wb3Zlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvcHJvdmlkZXJzL3ZpZXctbWFuYWdlci5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLXZpZXctbWFuYWdlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2RhdGVwaWNrZXIvZGF5LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXlwaWNrZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9kYXRlcGlja2VyL21vbnRocGlja2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9tb2RlbC95ZWFyLXJhbmdlLm1vZGVsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci95ZWFycGlja2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZGF0ZXBpY2tlci9kYXRlcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2lucHV0L2lucHV0LWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL2lucHV0L2lucHV0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvaW5wdXQvaW5wdXQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcGFzc3dvcmQvcGFzc3dvcmQtY29udGFpbmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcGFzc3dvcmQvcGFzc3dvcmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9wYXNzd29yZC9wYXNzd29yZC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby13cmFwcGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvcmFkaW8vcmFkaW8udHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9yYWRpby9yYWRpby5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9zZWxlY3Qvc2VsZWN0LWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3NlbGVjdC9zZWxlY3QudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy9zZWxlY3Qvc2VsZWN0Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3RleHRhcmVhL3RleHRhcmVhLWNvbnRhaW5lci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zL3RleHRhcmVhL3RleHRhcmVhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvdGV4dGFyZWEvdGV4dGFyZWEubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZm9ybXMvZm9ybXMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaWYtZXhwYW5kZWQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9vdXRzaWRlLWNsaWNrL291dHNpZGUtY2xpY2sudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9vdXRzaWRlLWNsaWNrL2luZGV4LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvb3V0c2lkZS1jbGljay9vdXRzaWRlLWNsaWNrLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnLWV2ZW50LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9wcm92aWRlcnMvZHJhZy1hbmQtZHJvcC1ldmVudC1idXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2RyYWctZXZlbnQtbGlzdGVuZXIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2RyYWdnYWJsZS1zbmFwc2hvdC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnZ2FibGUtZ2hvc3QudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2lmLWRyYWdnZWQudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL3Byb3ZpZGVycy9kcmFnLWhhbmRsZS1yZWdpc3RyYXIuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvcHJvdmlkZXJzL2dsb2JhbC1kcmFnLW1vZGUuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZ2dhYmxlL2RyYWdnYWJsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJvcHBhYmxlL2Ryb3BwYWJsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1oYW5kbGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWctYW5kLWRyb3AubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9hbmltYXRpb24taGFjay9yb3ctZXhwYW5kLWFuaW1hdGlvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2N1c3RvbS1maWx0ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9wYWdlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZmlsdGVycy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvdXRpbHMvZGF0YWdyaWQtZmlsdGVyLXJlZ2lzdHJhci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtZmlsdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9idWlsdC1pbi9uZXN0ZWQtcHJvcGVydHkudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtcHJvcGVydHktc3RyaW5nLWZpbHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLWltcGwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2J1aWx0LWluL2ZpbHRlcnMvZGF0YWdyaWQtc3RyaW5nLWZpbHRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2Nob2NvbGF0ZS9vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9jaG9jb2xhdGUvd2lsbHktd29ua2EudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2Nob2NvbGF0ZS9kYXRhZ3JpZC13aWxseS13b25rYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvY2hvY29sYXRlL2FjdGlvbmFibGUtb29tcGEtbG9vbXBhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZ2xvYmFsLWV4cGFuZGFibGUtcm93cy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvY2hvY29sYXRlL2V4cGFuZGFibGUtb29tcGEtbG9vbXBhLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9idWlsdC1pbi9jb21wYXJhdG9ycy9kYXRhZ3JpZC1wcm9wZXJ0eS1jb21wYXJhdG9yLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9lbnVtcy9zb3J0LW9yZGVyLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zb3J0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC93cmFwcGVkLWNvbHVtbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY29sdW1uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvaXRlbXMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWl0ZW1zLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1wbGFjZWhvbGRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4udHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LXRyaWdnZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3dyYXBwZWQtY2VsbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtY2VsbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZW51bXMvZGlzcGxheS1tb2RlLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2VudW1zL3JlbmRlci1zdGVwLmVudW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9yZW5kZXItb3JnYW5pemVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvZGlzcGxheS1tb2RlLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2VudW1zL3NlbGVjdGlvbi10eXBlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvc2VsZWN0aW9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC93cmFwcGVkLXJvdy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtcm93LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9wcm92aWRlcnMvY29sdW1uLXRvZ2dsZS1idXR0b25zLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3Byb3ZpZGVycy9zdGF0ZS5wcm92aWRlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL3RhYmxlLXNpemUuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2NvbHVtbnMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWFjdGlvbi1iYXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWFjdGlvbi1vdmVyZmxvdy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcHJvdmlkZXJzL2NvbHVtbi1yZXNpemVyLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9pZC1nZW5lcmF0b3IvaWQtZ2VuZXJhdG9yLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNvbHVtbi1zZXBhcmF0b3IudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtYnV0dG9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLXRpdGxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1kZXRhaWwtcmVnaXN0ZXJlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtZm9vdGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtaXRlbXMtdHJhY2tieS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvZGF0YWdyaWQtcGFnZS1zaXplLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1wYWdpbmF0aW9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC1yb3ctZGV0YWlsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvY29uc3RhbnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9lbnVtcy9jb2x1bW4tY2hhbmdlcy5lbnVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9yZW5kZXIvY2VsbC1yZW5kZXJlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL2hlYWRlci1yZW5kZXJlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YWdyaWQvcmVuZGVyL25vb3AtZG9tLWFkYXB0ZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9yb3ctcmVuZGVyZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL2RhdGFncmlkL3JlbmRlci9tYWluLXJlbmRlcmVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS9kYXRhZ3JpZC9kYXRhZ3JpZC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stYmxvY2sudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stdmlldy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1oZWFkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stY29udHJvbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1pbnB1dC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay1zZWxlY3QudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3N0YWNrLXZpZXcvc3RhY2stdmlldy1jdXN0b20tdGFncy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvc3RhY2stdmlldy9zdGFjay12aWV3Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L21vZGVscy9zZWxlY3RlZC1zdGF0ZS5lbnVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvbW9kZWxzL3RyZWUtbm9kZS5tb2RlbC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvdHJlZS12aWV3L21vZGVscy9kZWNsYXJhdGl2ZS10cmVlLW5vZGUubW9kZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy90cmVlLWZlYXR1cmVzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy90cmVlLW5vZGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy90cmVlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvbW9kZWxzL2FzeW5jLWFycmF5LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvbW9kZWxzL3JlY3Vyc2l2ZS10cmVlLW5vZGUubW9kZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9kYXRhL3RyZWUtdmlldy9yZWN1cnNpdmUtZm9yLW9mLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvcmVjdXJzaXZlLWNoaWxkcmVuLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZGF0YS90cmVlLXZpZXcvdHJlZS12aWV3Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2RhdGEvZGF0YS5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL2Ryb3Bkb3duL3Byb3ZpZGVycy9kcm9wZG93bi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24taXRlbS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24tbWVudS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24tdHJpZ2dlci50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvdXRpbHMvYWxlcnQtdHlwZXMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9wcm92aWRlcnMvaWNvbi1hbmQtdHlwZXMuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2VtcGhhc2lzL2FsZXJ0L3Byb3ZpZGVycy9tdWx0aS1hbGVydC5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9lbXBoYXNpcy9hbGVydC9hbGVydC1pdGVtLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnRzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnRzLXBhZ2VyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvYWxlcnQvYWxlcnQubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvZW1waGFzaXMvZW1waGFzaXMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9yZXNwb25zaXZlLW5hdi1jb2Rlcy50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvcmVzcG9uc2l2ZS1uYXYtY29udHJvbC1tZXNzYWdlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9wcm92aWRlcnMvcmVzcG9uc2l2ZS1uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbWFpbi1jb250YWluZXIvbWFpbi1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbWFpbi1jb250YWluZXIvbWFpbi1jb250YWluZXIubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9jaG9jb2xhdGUvbWFpbi1jb250YWluZXItd2lsbHktd29ua2EudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L2Nob2NvbGF0ZS9uYXYtZGV0ZWN0aW9uLW9vbXBhLWxvb21wYS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC9uYXYvaGVhZGVyLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L25hdi9uYXYtbGV2ZWwudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbmF2L25hdmlnYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi1jb250YWluZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy90ZW1wbGF0ZS1yZWYvaW5kZXgudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy90ZW1wbGF0ZS1yZWYvdGVtcGxhdGUtcmVmLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL2Nob2NvbGF0ZS90YWJzLXdpbGx5LXdvbmthLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvY2hvY29sYXRlL2FjdGl2ZS1vb21wYS1sb29tcGEudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy9wcm92aWRlcnMvYXJpYS5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3RhYnMvZW51bXMvdGFicy1sYXlvdXQuZW51bS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3Byb3ZpZGVycy90YWJzLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy90YWItY29udGVudC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYnMtaWQucHJvdmlkZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy90YWItbGluay5kaXJlY3RpdmUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy90YWIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy90YWItb3ZlcmZsb3ctY29udGVudC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC90YWJzL3RhYnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdGFicy90YWJzLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1ncm91cC1yZWdpc3RyYXRpb24uc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1pY29uLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYuc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi1ncm91cC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2LWdyb3VwLWNoaWxkcmVuLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbGF5b3V0L3ZlcnRpY2FsLW5hdi92ZXJ0aWNhbC1uYXYtaWNvbi50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2xheW91dC92ZXJ0aWNhbC1uYXYvdmVydGljYWwtbmF2LWxpbmsudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9sYXlvdXQvbGF5b3V0Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL3Njcm9sbGluZy9zY3JvbGxpbmctc2VydmljZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL21vZGFsL21vZGFsLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvbW9kYWwvbW9kYWwubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci9zaWducG9zdC9zaWducG9zdC1wb3NpdGlvbnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0LWNvbnRlbnQudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvdG9vbHRpcC90b29sdGlwLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvcG9wb3Zlci90b29sdGlwL3Rvb2x0aXAtY29udGVudC50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3BvcG92ZXIvdG9vbHRpcC90b29sdGlwLXRyaWdnZXIudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3Rvb2x0aXAvdG9vbHRpcC5tb2R1bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci9wb3BvdmVyL3BvcG92ZXIubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3Byb3ZpZGVycy9idXR0b24taHViLnNlcnZpY2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvcHJvdmlkZXJzL3BhZ2UtY29sbGVjdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3Byb3ZpZGVycy93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3Byb3ZpZGVycy9oZWFkZXItYWN0aW9ucy5zZXJ2aWNlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1oZWFkZXItYWN0aW9uLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1wYWdlLWJ1dHRvbnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXBhZ2UtaGVhZGVyLWFjdGlvbnMudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXBhZ2UtbmF2dGl0bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXBhZ2UtdGl0bGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLXBhZ2UudHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1idXR0b24udHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLWN1c3RvbS10YWdzLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1zdGVwbmF2LnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvd2l6YXJkL3dpemFyZC1zdGVwbmF2LWl0ZW0udHMiLCJuZzovL0BjbHIvYW5ndWxhci93aXphcmQvd2l6YXJkLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Nsci1hbmd1bGFyLm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zLWRlcHJlY2F0ZWQvY2hlY2tib3gvY2hlY2tib3gudHMiLCJuZzovL0BjbHIvYW5ndWxhci9mb3Jtcy1kZXByZWNhdGVkL2NoZWNrYm94L2NoZWNrYm94Lm1vZHVsZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL2Zvcm1zLWRlcHJlY2F0ZWQvZm9ybXMubW9kdWxlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvYW5pbWF0aW9ucy9jb2xsYXBzZS9jb2xsYXBzZS50cyIsIm5nOi8vQGNsci9hbmd1bGFyL3V0aWxzL2FuaW1hdGlvbnMvZmFkZS9mYWRlLnRzIiwibmc6Ly9AY2xyL2FuZ3VsYXIvdXRpbHMvYW5pbWF0aW9ucy9mYWRlLXNsaWRlL2ZhZGUtc2xpZGUudHMiLCJuZzovL0BjbHIvYW5ndWxhci91dGlscy9hbmltYXRpb25zL3NsaWRlL3NsaWRlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItaWNvbicgfSlcbmV4cG9ydCBjbGFzcyBDbHJJY29uQ3VzdG9tVGFnIHtcbiAgLy8gTm8gYmVoYXZpb3JcbiAgLy8gVGhlIG9ubHkgcHVycG9zZSBpcyB0byBcImRlY2xhcmVcIiB0aGUgdGFnIGluIEFuZ3VsYXJcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJJY29uQ3VzdG9tVGFnIH0gZnJvbSAnLi9pY29uJztcblxuZXhwb3J0IGNvbnN0IENMUl9JQ09OX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0Nsckljb25DdXN0b21UYWddO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbQ0xSX0lDT05fRElSRUNUSVZFU10sIGV4cG9ydHM6IFtDTFJfSUNPTl9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsckljb25Nb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLypcbiAqIERvIE5PVCBBbmd1bGFyIHRoaXMgdXAuIEl0IGFzc3VtZXMgd2UncmUgaW4gdGhlIERPTSwgcGxheXMgd2l0aCBuYXRpdmUgZWxlbWVudHMsIC4uLlxuICogSXQgY291bGQgcG90ZW50aWFsbHkgYmUgdXNlZCBhcyBwYXJ0IG9mIEBjbHIvdWkgYXMgYSB2YW5pbGxhIEphdmFzY3JpcHQgaGVscGVyLlxuICovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFBvcG92ZXJPcHRpb25zIH0gZnJvbSAnLi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcbmV4cG9ydCBlbnVtIFBvaW50IHtcbiAgUklHSFRfQ0VOVEVSLFxuICBSSUdIVF9UT1AsXG4gIFJJR0hUX0JPVFRPTSxcbiAgVE9QX0NFTlRFUixcbiAgVE9QX1JJR0hULFxuICBUT1BfTEVGVCxcbiAgQk9UVE9NX0NFTlRFUixcbiAgQk9UVE9NX1JJR0hULFxuICBCT1RUT01fTEVGVCxcbiAgTEVGVF9DRU5URVIsXG4gIExFRlRfVE9QLFxuICBMRUZUX0JPVFRPTSxcbn1cblxuY29uc3QgUE9TSVRJT05fUkVMQVRJVkUgPSAncmVsYXRpdmUnO1xuY29uc3QgUE9TSVRJT05fQUJTT0xVVEUgPSAnYWJzb2x1dGUnO1xuY29uc3QgUE9TSVRJT05fRklYRUQgPSAnZml4ZWQnO1xuXG5jb25zdCBPVkVSRkxPV19TQ1JPTEwgPSAnc2Nyb2xsJztcbmNvbnN0IE9WRVJGTE9XX0FVVE8gPSAnYXV0byc7XG5cbmV4cG9ydCBjbGFzcyBQb3BvdmVyIHtcbiAgcHJpdmF0ZSBfc2Nyb2xsOiBTdWJqZWN0PHZvaWQ+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogYW55KSB7XG4gICAgLy8gQnJvd3NlcnMgZG9uJ3QgYWdyZWUgd2l0aCB3aGF0IHRvIGRvIGlmIHNvbWUgb2YgdGhlc2UgYXJlIG5vdCBzcGVjaWZpZWQsIHNvIHdlIHNldCB0aGVtIGFsbCB0byBiZSBzYWZlLlxuICAgIGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBQT1NJVElPTl9BQlNPTFVURTtcbiAgICBlbGVtZW50LnN0eWxlLnRvcCA9IDA7XG4gICAgZWxlbWVudC5zdHlsZS5ib3R0b20gPSAnYXV0byc7XG4gICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgICBlbGVtZW50LnN0eWxlLnJpZ2h0ID0gJ2F1dG8nO1xuICB9XG5cbiAgLy8gVE9ETzogbmVlZCBhIHdheSB0byBhY2NvdW50IGZvciBwYXJhbWV0ZXJzIHRoYXQgY2hhbmdlIGR5bmFtaWNhbGx5IChwb3NpdGlvbmluZykuXG4gIHB1YmxpYyBhbmNob3IoXG4gICAgYW5jaG9yOiBhbnksXG4gICAgYW5jaG9yQWxpZ246IFBvaW50LFxuICAgIHBvcG92ZXJBbGlnbjogUG9pbnQsXG4gICAgeyBvZmZzZXRYID0gMCwgb2Zmc2V0WSA9IDAsIHVzZUFuY2hvclBhcmVudCA9IGZhbHNlIH06IFBvcG92ZXJPcHRpb25zID0ge31cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAvLyBUT0RPOiB3ZSBhcmUgYXNzdW1pbmcgaGVyZSB0aGF0IHRoZSBwb3BvdmVyIGlzIGluc2lkZSBvciBuZXh0IHRvIHRoZSBhbmNob3IuXG4gICAgLy8gV2UnZCBuZWVkIHRvIGdvIHVwIHRoZSBwb3BvdmVyIHRyZWUgdG9vIG90aGVyd2lzZVxuXG4gICAgdGhpcy5hZGRTY3JvbGxFdmVudExpc3RlbmVycyhhbmNob3IpO1xuICAgIGlmICh1c2VBbmNob3JQYXJlbnQpIHtcbiAgICAgIGFuY2hvciA9IGFuY2hvci5wYXJlbnROb2RlO1xuICAgIH1cbiAgICAvLyBleHBsaWNpdGx5IG92ZXJyaWRlIGFuY2hvcidzIHN0eWxlIHRvIHN0YXRpY1xuICAgIGFuY2hvci5zdHlsZS5wb3NpdGlvbiA9ICdzdGF0aWMnO1xuXG4gICAgY29uc3QgYW5jaG9yUmVjdCA9IGFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBwb3BvdmVyUmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIC8vIHBvc2l0aW9uIG9mIGxlZnQgdG9wIGNvcm5lciBvZiBhbmNob3IgKyB0aGUgb2Zmc2V0XG4gICAgbGV0IGxlZnREaWZmOiBudW1iZXIgPSBhbmNob3JSZWN0LmxlZnQgLSBwb3BvdmVyUmVjdC5sZWZ0ICsgb2Zmc2V0WDtcbiAgICBsZXQgdG9wRGlmZjogbnVtYmVyID0gYW5jaG9yUmVjdC50b3AgLSBwb3BvdmVyUmVjdC50b3AgKyBvZmZzZXRZO1xuXG4gICAgLy8gZmlyc3QsIGFkanVzdCBwb3NpdGlvbmluZyBiYXNlZCBvbiBhbmNob3IncyBhbGlnbiBwb2ludFxuICAgIHN3aXRjaCAoYW5jaG9yQWxpZ24pIHtcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9UT1A6XG4gICAgICBjYXNlIFBvaW50LlRPUF9MRUZUOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0NFTlRFUjpcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5UT1BfUklHSFQ6XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9UT1A6XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0JPVFRPTTpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9MRUZUOlxuICAgICAgICB0b3BEaWZmICs9IGFuY2hvclJlY3QuaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgKz0gYW5jaG9yUmVjdC53aWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fUklHSFQ6XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9CT1RUT006XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQ7XG4gICAgICAgIGxlZnREaWZmICs9IGFuY2hvclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBhbmNob3JSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gYW5jaG9yUmVjdC5oZWlnaHQgLyAyO1xuICAgICAgICBsZWZ0RGlmZiArPSBhbmNob3JSZWN0LndpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuXG4gICAgLy8gc2Vjb25kLCBhZGp1c3QgcG9zaXRpb25pbmcgYmFzZWQgb24gcG9wb3ZlcidzIGFsaWduIHBvaW50XG4gICAgc3dpdGNoIChwb3BvdmVyQWxpZ24pIHtcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9UT1A6XG4gICAgICBjYXNlIFBvaW50LlRPUF9MRUZUOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0NFTlRFUjpcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX1JJR0hUOlxuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LlJJR0hUX1RPUDpcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0JPVFRPTTpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fTEVGVDpcbiAgICAgICAgdG9wRGlmZiAtPSBwb3BvdmVyUmVjdC5oZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5CT1RUT01fQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX1JJR0hUOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodDtcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9CT1RUT006XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0O1xuICAgICAgICBsZWZ0RGlmZiAtPSBwb3BvdmVyUmVjdC53aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfQ0VOVEVSOlxuICAgICAgICB0b3BEaWZmIC09IHBvcG92ZXJSZWN0LmhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgLT0gcG9wb3ZlclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgbGVmdERpZmYgLT0gcG9wb3ZlclJlY3Qud2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG5cbiAgICAvLyBUaGlyZCwgYWRqdXN0IHdpdGggcG9wb3ZlcidzIG1hcmdpbnMgYmFzZWQgb24gdGhlIHR3byBhbGlnbiBwb2ludHMuXG4gICAgLy8gSGVyZSwgd2UgbWFrZSBhbiBhc3N1bXB0aW9uIHRoYXQgcG9wb3ZlciBpcyBwcmltYXJpbHkgcG9zaXRpb25lZCBvdXRzaWRlIHRoZVxuICAgIC8vIGFuY2hvciB3aXRoIG1pbm9yIG9mZnNldC4gV2l0aG91dCB0aGlzIGFzc3VtcHRpb24sIGl0J3MgaW1wb3NzaWJsZSB0byBhcHBseVxuICAgIC8vIHRoZSBwb3BvdmVyJ3MgbWFyZ2lucyBpbiBhIHByZWRpY3RhYmxlIHdheS4gRm9yIGV4YW1wbGUsIGFzc3VtZSB0aGF0IGEgcG9wb3ZlclxuICAgIC8vIGFuZCBpdHMgYW5jaG9yIGFyZSBleGFjdGx5IHRoZSBzYW1lIHNpemUuIGlmIGEgcG9wb3ZlciBpcyBwb3NpdGlvbmVkIGluc2lkZSB0aGVcbiAgICAvLyBhbmNob3IgKHdoaWNoIGlzIHRlY2huaWNhbGx5IHBvc3NpYmxlKSwgdGhlbiBpdCBiZWNvbWVzIGltcG9zc2libGUgdG8ga25vdyB3aGF0IHRvIGRvXG4gICAgLy8gaWYgdGhlIHBvcG92ZXIgaGFzIGEgbm9uLXplcm8gbWFyZ2luIHZhbHVlIGFsbCBhcm91bmQgKGJlY2F1c2UgYXBwbHlpbmcgdGhlIG1hcmdpbiBpblxuICAgIC8vIGFsbCBmb3VyIGRpcmVjdGlvbnMgd2lsbCByZXN1bHQgaW4gbm8gbWFyZ2luIHZpc3VhbGx5LCB3aGljaCBpc24ndCB3aGF0IHdlIHdhbnQpLlxuICAgIC8vIFRoZXJlZm9yZSwgb3VyIGxvZ2ljIG1ha2VzIGFzc3VtcHRpb25zIGFib3V0IG1hcmdpbnMgb2YgaW50ZXJlc3QgZ2l2ZW4gdGhlIHBvaW50cyxcbiAgICAvLyBhbmQgb25seSBjb3ZlcnMgdGhlIGNhc2VzIHdoZXJlIHBvcG92ZXIgaXMgb3V0c2lkZSB0aGUgYW5jaG9yLlxuXG4gICAgY29uc3QgcG9wb3ZlckNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XG4gICAgY29uc3QgbWFyZ2luTGVmdCA9IHBhcnNlSW50KHBvcG92ZXJDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQsIDEwKTtcbiAgICBjb25zdCBtYXJnaW5SaWdodCA9IHBhcnNlSW50KHBvcG92ZXJDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LCAxMCk7XG4gICAgY29uc3QgbWFyZ2luVG9wID0gcGFyc2VJbnQocG9wb3ZlckNvbXB1dGVkU3R5bGUubWFyZ2luVG9wLCAxMCk7XG4gICAgY29uc3QgbWFyZ2luQm90dG9tID0gcGFyc2VJbnQocG9wb3ZlckNvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLCAxMCk7XG5cbiAgICBzd2l0Y2ggKGFuY2hvckFsaWduKSB7XG4gICAgICBjYXNlIFBvaW50LkxFRlRfVE9QOlxuICAgICAgY2FzZSBQb2ludC5UT1BfTEVGVDpcbiAgICAgIGNhc2UgUG9pbnQuVE9QX1JJR0hUOlxuICAgICAgY2FzZSBQb2ludC5SSUdIVF9UT1A6XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LkJPVFRPTV9SSUdIVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LlJJR0hUX0JPVFRPTSkge1xuICAgICAgICAgIHRvcERpZmYgLT0gbWFyZ2luQm90dG9tO1xuICAgICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LkJPVFRPTV9MRUZUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuTEVGVF9CT1RUT00pIHtcbiAgICAgICAgICB0b3BEaWZmIC09IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LlRPUF9MRUZUIHx8IHBvcG92ZXJBbGlnbiA9PT0gUG9pbnQuTEVGVF9UT1ApIHtcbiAgICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiArPSBtYXJnaW5MZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BvdmVyQWxpZ24gPT09IFBvaW50LlRPUF9SSUdIVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LlJJR0hUX1RPUCkge1xuICAgICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5MRUZUX0JPVFRPTTpcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0xFRlQ6XG4gICAgICBjYXNlIFBvaW50LkJPVFRPTV9SSUdIVDpcbiAgICAgIGNhc2UgUG9pbnQuUklHSFRfQk9UVE9NOlxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5CT1RUT01fTEVGVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LkxFRlRfQk9UVE9NKSB7XG4gICAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5CT1RUT01fUklHSFQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5SSUdIVF9CT1RUT00pIHtcbiAgICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5UT1BfTEVGVCB8fCBwb3BvdmVyQWxpZ24gPT09IFBvaW50LkxFRlRfVE9QKSB7XG4gICAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wb3ZlckFsaWduID09PSBQb2ludC5UT1BfUklHSFQgfHwgcG9wb3ZlckFsaWduID09PSBQb2ludC5SSUdIVF9UT1ApIHtcbiAgICAgICAgICB0b3BEaWZmICs9IG1hcmdpblRvcDtcbiAgICAgICAgICBsZWZ0RGlmZiAtPSBtYXJnaW5SaWdodDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuVE9QX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiAtPSBtYXJnaW5Cb3R0b207XG4gICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuQk9UVE9NX0NFTlRFUjpcbiAgICAgICAgdG9wRGlmZiArPSBtYXJnaW5Ub3A7XG4gICAgICAgIGxlZnREaWZmICs9IG1hcmdpbkxlZnQ7XG4gICAgICAgIGxlZnREaWZmIC09IG1hcmdpblJpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUG9pbnQuTEVGVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgbGVmdERpZmYgLT0gbWFyZ2luUmlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQb2ludC5SSUdIVF9DRU5URVI6XG4gICAgICAgIHRvcERpZmYgKz0gbWFyZ2luVG9wO1xuICAgICAgICB0b3BEaWZmIC09IG1hcmdpbkJvdHRvbTtcbiAgICAgICAgbGVmdERpZmYgKz0gbWFyZ2luTGVmdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke01hdGgucm91bmQobGVmdERpZmYpfXB4KSB0cmFuc2xhdGVZKCR7TWF0aC5yb3VuZCh0b3BEaWZmKX1weClgO1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGwuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgcmVsZWFzZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gICAgdGhpcy5yZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc1Bvc2l0aW9uZWQoY29udGFpbmVyOiBhbnkpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09IFBPU0lUSU9OX1JFTEFUSVZFIHx8IHBvc2l0aW9uID09PSBQT1NJVElPTl9BQlNPTFVURSB8fCBwb3NpdGlvbiA9PT0gUE9TSVRJT05fRklYRUQ7XG4gIH1cblxuICAvKlxuICAgICAqIENvbnRhaW5lcnMgdXAgdG8gdGhlIGZpcnN0IHBvc2l0aW9uZWQgb25lIHdpbGwgaGF2ZSBhbiBldmVudCBvbiBzY3JvbGxcbiAgICAgKi9cblxuICBwcml2YXRlIHNjcm9sbGFibGVFbGVtZW50czogSFRNTEVsZW1lbnRbXSA9IFtdO1xuXG4gIHByaXZhdGUgZW1pdFNjcm9sbEV2ZW50KCkge1xuICAgIHRoaXMuX3Njcm9sbC5uZXh0KCk7XG4gIH1cblxuICBwcml2YXRlIGJvdW5kT25TY3JvbGxMaXN0ZW5lcjogYW55ID0gdGhpcy5lbWl0U2Nyb2xsRXZlbnQuYmluZCh0aGlzKTtcblxuICBwcml2YXRlIGFkZFNjcm9sbEV2ZW50TGlzdGVuZXJzKGU6IGFueSkge1xuICAgIHRoaXMuX3Njcm9sbCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgY29uc3QgYW5jaG9yOiBhbnkgPSBlO1xuICAgIGxldCBjdXJyZW50OiBhbnkgPSBlO1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxzKGN1cnJlbnQpKSB7XG4gICAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5ib3VuZE9uU2Nyb2xsTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgIT09IGFuY2hvciAmJiB0aGlzLmlzUG9zaXRpb25lZChjdXJyZW50KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdGhpcy5zY3JvbGxhYmxlRWxlbWVudHMpIHtcbiAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5ib3VuZE9uU2Nyb2xsTGlzdGVuZXIpO1xuICAgIH1cbiAgICB0aGlzLnNjcm9sbGFibGVFbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9zY3JvbGwpIHtcbiAgICAgIHRoaXMuX3Njcm9sbC5jb21wbGV0ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX3Njcm9sbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNjcm9sbHMoY29udGFpbmVyOiBhbnkpOiBib29sZWFuIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICByZXR1cm4gKFxuICAgICAgY29tcHV0ZWRTdHlsZXMub3ZlcmZsb3dYID09PSBPVkVSRkxPV19TQ1JPTEwgfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzLm92ZXJmbG93WCA9PT0gT1ZFUkZMT1dfQVVUTyB8fFxuICAgICAgY29tcHV0ZWRTdHlsZXMub3ZlcmZsb3dZID09PSBPVkVSRkxPV19TQ1JPTEwgfHxcbiAgICAgIGNvbXB1dGVkU3R5bGVzLm92ZXJmbG93WSA9PT0gT1ZFUkZMT1dfQVVUT1xuICAgICk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRW1iZWRkZWRWaWV3UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUG9pbnQsIFBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXInO1xuaW1wb3J0IHsgUG9wb3Zlck9wdGlvbnMgfSBmcm9tICcuL3BvcG92ZXItb3B0aW9ucy5pbnRlcmZhY2UnO1xuXG5sZXQgb3BlbkNvdW50OiBudW1iZXIgPSAwO1xuY29uc3Qgd2FpdGluZzogQXJyYXk8KCkgPT4gdm9pZD4gPSBbXTsgLy8gcGVuZGluZyBjcmVhdGUgZnVuY3Rpb25zXG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQb3BvdmVyT2xkXScgfSlcbmV4cG9ydCBjbGFzcyBQb3BvdmVyRGlyZWN0aXZlT2xkIHtcbiAgcHJpdmF0ZSBfcG9wb3Zlckluc3RhbmNlOiBQb3BvdmVyO1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBASW5wdXQoJ2NsclBvcG92ZXJPbGRBbmNob3InKSBhbmNob3JFbGVtOiBhbnk7XG4gIEBJbnB1dCgnY2xyUG9wb3Zlck9sZEFuY2hvclBvaW50JykgYW5jaG9yUG9pbnQ6IFBvaW50O1xuICBASW5wdXQoJ2NsclBvcG92ZXJPbGRQb3BvdmVyUG9pbnQnKSBwb3BvdmVyUG9pbnQ6IFBvaW50O1xuICBASW5wdXQoJ2NsclBvcG92ZXJPbGRPcHRpb25zJykgcG9wb3Zlck9wdGlvbnM6IFBvcG92ZXJPcHRpb25zID0ge307XG4gIEBPdXRwdXQoJ2NsclBvcG92ZXJPbGRDaGFuZ2UnKSBjbHJQb3BvdmVyT2xkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PiwgcHJpdmF0ZSB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmKSB7fVxuXG4gIEBJbnB1dCgpXG4gIHNldCBjbHJQb3BvdmVyT2xkKG9wZW46IGJvb2xlYW4pIHtcbiAgICBpZiAob3Blbikge1xuICAgICAgaWYgKHRoaXMucG9wb3Zlck9wdGlvbnMuYWxsb3dNdWx0aXBsZU9wZW4pIHtcbiAgICAgICAgdGhpcy5jcmVhdGVQb3BvdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3BlbkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVQb3BvdmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FpdGluZy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUG9wb3ZlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgdGhpcy5kZXN0cm95UG9wb3ZlcigpO1xuXG4gICAgICBpZiAoIXRoaXMucG9wb3Zlck9wdGlvbnMuYWxsb3dNdWx0aXBsZU9wZW4pIHtcbiAgICAgICAgaWYgKHdhaXRpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGNyZWF0ZVBvcG92ZXJGbiA9IHdhaXRpbmcuc2hpZnQoKTtcbiAgICAgICAgICBjcmVhdGVQb3BvdmVyRm4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZVBvcG92ZXIoKSB7XG4gICAgY29uc3QgZW1iZWRkZWRWaWV3UmVmOiBFbWJlZGRlZFZpZXdSZWY8YW55PiA9IDxFbWJlZGRlZFZpZXdSZWY8YW55Pj50aGlzLnZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgdGhpcy50ZW1wbGF0ZVJlZlxuICAgICk7XG5cbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSBvZiB0aGUgcmlza3MgYXNzb2NpYXRlZCB3aXRoIHVzaW5nIHRoaXMuIEZpbmQgYW4gYWx0ZXJuYXRpdmUuXG4gICAgLy8gTmVlZGVkIGZvciBmaW5kIHRoZSBjb3JyZWN0IGhlaWdodCBhbmQgd2lkdGggb2YgZHluYW1pY2FsbHkgY3JlYXRlZCB2aWV3c1xuICAgIC8vIGluc2lkZSBvZiB0aGUgcG9wb3Zlci4gRm9yIEVnOiBCdXR0b24gR3JvdXBzXG4gICAgZW1iZWRkZWRWaWV3UmVmLmRldGVjdENoYW5nZXMoKTtcblxuICAgIC8vIGZpbHRlciBvdXQgb3RoZXIgbm9kZXMgaW4gdGhlIHZpZXcgcmVmIHNvIHdlIGFyZSBvbmx5IGxlZnQgd2l0aCBlbGVtZW50IG5vZGVzXG4gICAgY29uc3QgZWxlbWVudE5vZGVzOiBIVE1MRWxlbWVudFtdID0gZW1iZWRkZWRWaWV3UmVmLnJvb3ROb2Rlcy5maWx0ZXIoKG5vZGU6IGFueSkgPT4ge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IDE7XG4gICAgfSk7XG5cbiAgICAvLyB3ZSB0YWtlIHRoZSBmaXJzdCBlbGVtZW50IG5vZGUgaW4gdGhlIGVtYmVkZGVkIHZpZXc7IHVzdWFsbHkgdGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIGFueXdheXNcbiAgICB0aGlzLl9wb3BvdmVySW5zdGFuY2UgPSBuZXcgUG9wb3ZlcihlbGVtZW50Tm9kZXNbMF0pO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3BvcG92ZXJJbnN0YW5jZVxuICAgICAgLmFuY2hvcih0aGlzLmFuY2hvckVsZW0sIHRoaXMuYW5jaG9yUG9pbnQsIHRoaXMucG9wb3ZlclBvaW50LCB0aGlzLnBvcG92ZXJPcHRpb25zKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xyUG9wb3Zlck9sZENoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIG9wZW5Db3VudCsrO1xuICB9XG5cbiAgZGVzdHJveVBvcG92ZXIoKSB7XG4gICAgaWYgKHRoaXMuX3BvcG92ZXJJbnN0YW5jZSkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLl9wb3BvdmVySW5zdGFuY2UucmVsZWFzZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuX3BvcG92ZXJJbnN0YW5jZTtcbiAgICAgIG9wZW5Db3VudC0tO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveVBvcG92ZXIoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUG9wb3ZlckRpcmVjdGl2ZU9sZCB9IGZyb20gJy4vcG9wb3Zlci1vbGQuZGlyZWN0aXZlJztcblxuZXhwb3J0ICogZnJvbSAnLi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcbmV4cG9ydCAqIGZyb20gJy4vcG9wb3Zlci1vbGQuZGlyZWN0aXZlJztcblxuZXhwb3J0IGNvbnN0IFBPUE9WRVJfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbUG9wb3ZlckRpcmVjdGl2ZU9sZF07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQT1BPVkVSX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW1BPUE9WRVJfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtQT1BPVkVSX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDbHJMb2FkaW5nU3RhdGUgfSBmcm9tICcuL2xvYWRpbmcnO1xuXG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgY2xhc3MgYmVjYXVzZSB3ZSBuZWVkIGl0IHRvIHN0aWxsIGJlIGEgdmFsaWQgdG9rZW4gZm9yIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGFmdGVyIHRyYW5zcGlsaW5nLlxuICogVGhpcyBkb2VzIG5vdCBtZWFuIHlvdSBzaG91bGQgZXh0ZW5kIGl0LCBzaW1wbHkgaW1wbGVtZW50aW5nIGl0IGlzIGZpbmUuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMb2FkaW5nTGlzdGVuZXIge1xuICBhYnN0cmFjdCBsb2FkaW5nU3RhdGVDaGFuZ2Uoc3RhdGU6IENsckxvYWRpbmdTdGF0ZSk6IHZvaWQ7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4vbG9hZGluZy1saXN0ZW5lcic7XG5cbmV4cG9ydCBlbnVtIENsckxvYWRpbmdTdGF0ZSB7XG4gIERFRkFVTFQsXG4gIExPQURJTkcsXG4gIFNVQ0NFU1MsXG4gIEVSUk9SLFxufVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyTG9hZGluZ10nIH0pXG5leHBvcnQgY2xhc3MgQ2xyTG9hZGluZyBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIC8vIFdlIGZpbmQgdGhlIGZpcnN0IHBhcmVudCB0aGF0IGhhbmRsZXMgc29tZXRoaW5nIGxvYWRpbmdcbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJpdmF0ZSBsaXN0ZW5lcjogTG9hZGluZ0xpc3RlbmVyKSB7fVxuXG4gIHByaXZhdGUgX2xvYWRpbmdTdGF0ZTogQ2xyTG9hZGluZ1N0YXRlID0gQ2xyTG9hZGluZ1N0YXRlLkRFRkFVTFQ7XG5cbiAgcHVibGljIGdldCBsb2FkaW5nU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvYWRpbmdTdGF0ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyTG9hZGluZycpXG4gIHB1YmxpYyBzZXQgbG9hZGluZ1N0YXRlKHZhbHVlOiBib29sZWFuIHwgQ2xyTG9hZGluZ1N0YXRlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB2YWx1ZSA9IENsckxvYWRpbmdTdGF0ZS5MT0FESU5HO1xuICAgIH0gZWxzZSBpZiAoIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fbG9hZGluZ1N0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbG9hZGluZ1N0YXRlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMubGlzdGVuZXIpIHtcbiAgICAgIHRoaXMubGlzdGVuZXIubG9hZGluZ1N0YXRlQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmxvYWRpbmdTdGF0ZSA9IENsckxvYWRpbmdTdGF0ZS5ERUZBVUxUO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyQnV0dG9uIH0gZnJvbSAnLi4vYnV0dG9uLWdyb3VwL2J1dHRvbic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBCdXR0b25Jbkdyb3VwU2VydmljZSB7XG4gIHByaXZhdGUgX2NoYW5nZXM6IFN1YmplY3Q8Q2xyQnV0dG9uPiA9IG5ldyBTdWJqZWN0PENsckJ1dHRvbj4oKTtcblxuICBnZXQgY2hhbmdlcygpOiBPYnNlcnZhYmxlPENsckJ1dHRvbj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgdXBkYXRlQnV0dG9uR3JvdXAoYnV0dG9uOiBDbHJCdXR0b24pOiB2b2lkIHtcbiAgICB0aGlzLl9jaGFuZ2VzLm5leHQoYnV0dG9uKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9wdGlvbmFsLCBPdXRwdXQsIFNraXBTZWxmLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckxvYWRpbmdTdGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZyc7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuaW1wb3J0IHsgQnV0dG9uSW5Hcm91cFNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvYnV0dG9uLWluLWdyb3VwLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYnV0dG9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNidXR0b25Qcm9qZWN0ZWRSZWY+XG4gICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIFtjbGFzc109XCJjbGFzc05hbWVzXCIgXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImVtaXRDbGljaygpXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50eXBlXT1cInR5cGVcIlxuICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIFtpZF09XCJpZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3Bpbm5lciBzcGlubmVyLWlubGluZVwiICpuZ0lmPVwibG9hZGluZ1wiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IExvYWRpbmdMaXN0ZW5lciwgdXNlRXhpc3Rpbmc6IENsckJ1dHRvbiB9XSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQnV0dG9uIGltcGxlbWVudHMgTG9hZGluZ0xpc3RlbmVyIHtcbiAgcHJpdmF0ZSBfZW5hYmxlU2VydmljZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBWaWV3Q2hpbGQoJ2J1dHRvblByb2plY3RlZFJlZicpIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxDbHJCdXR0b24+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBTa2lwU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBwdWJsaWMgYnV0dG9uSW5Hcm91cFNlcnZpY2U6IEJ1dHRvbkluR3JvdXBTZXJ2aWNlXG4gICkge31cblxuICBwcml2YXRlIF9pbk1lbnU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgaW5NZW51KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pbk1lbnU7XG4gIH1cblxuICBASW5wdXQoJ2NsckluTWVudScpXG4gIHNldCBpbk1lbnUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMuX2luTWVudSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2luTWVudSA9IHZhbHVlO1xuICAgICAgLy8gV2UgY2hlY2sgaWYgdGhlIHNlcnZpY2UgZmxhZyBpcyBlbmFibGVkXG4gICAgICAvLyBhbmQgaWYgdGhlIHNlcnZpY2UgZXhpc3RzIGJlY2F1c2UgdGhlIHNlcnZpY2UgaXMgb3B0aW9uYWxcbiAgICAgIGlmICh0aGlzLl9lbmFibGVTZXJ2aWNlICYmIHRoaXMuYnV0dG9uSW5Hcm91cFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5idXR0b25Jbkdyb3VwU2VydmljZS51cGRhdGVCdXR0b25Hcm91cCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jbGFzc05hbWVzOiBzdHJpbmcgPSAnYnRuJztcblxuICBnZXQgY2xhc3NOYW1lcygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWVzO1xuICB9XG5cbiAgQElucHV0KCdjbGFzcycpXG4gIHNldCBjbGFzc05hbWVzKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lczogc3RyaW5nW10gPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgaWYgKGNsYXNzTmFtZXMuaW5kZXhPZignYnRuJykgPT09IC0xKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnYnRuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGFzc05hbWVzID0gY2xhc3NOYW1lcy5qb2luKCcgJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbmFtZTogc3RyaW5nID0gbnVsbDtcblxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgQElucHV0KCduYW1lJylcbiAgc2V0IG5hbWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdHlwZTogc3RyaW5nID0gbnVsbDtcblxuICBnZXQgdHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl90eXBlO1xuICB9XG5cbiAgQElucHV0KCd0eXBlJylcbiAgc2V0IHR5cGUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl90eXBlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaWQ6IHN0cmluZyA9IG51bGw7XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG5cbiAgQElucHV0KCdpZCcpXG4gIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZGlzYWJsZWQ6IGFueSA9IG51bGw7XG5cbiAgZ2V0IGRpc2FibGVkKCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICB9XG5cbiAgQElucHV0KCdkaXNhYmxlZCcpXG4gIHNldCBkaXNhYmxlZCh2YWx1ZTogYW55KSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZWQgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzYWJsZWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBsb2FkaW5nOiBib29sZWFuO1xuXG4gIGxvYWRpbmdTdGF0ZUNoYW5nZShzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlKTogdm9pZCB7XG4gICAgdGhpcy5sb2FkaW5nID0gc3RhdGUgPT09IENsckxvYWRpbmdTdGF0ZS5MT0FESU5HO1xuICB9XG5cbiAgQE91dHB1dCgnY2xpY2snKSBfY2xpY2s6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIGVtaXRDbGljaygpOiB2b2lkIHtcbiAgICB0aGlzLl9jbGljay5lbWl0KHRydWUpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuX2VuYWJsZVNlcnZpY2UgPSB0cnVlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5leHBvcnQgY29uc3QgQ0xSX01FTlVfUE9TSVRJT05TOiBzdHJpbmdbXSA9IFtcbiAgJ2JvdHRvbS1sZWZ0JyxcbiAgJ2JvdHRvbS1yaWdodCcsXG4gICd0b3AtbGVmdCcsXG4gICd0b3AtcmlnaHQnLFxuICAnbGVmdC1ib3R0b20nLFxuICAnbGVmdC10b3AnLFxuICAncmlnaHQtYm90dG9tJyxcbiAgJ3JpZ2h0LXRvcCcsXG5dO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgU2tpcFNlbGYsIE9wdGlvbmFsLCBJbmplY3RhYmxlUHJvdmlkZXIsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuLy8gQFRPRE8gUHV0IHRoZSBSZXF1aXJlZCB0eXBlIGJhY2sgaW4gd2hlbiBvdXIgbWluaW11bWx5IHN1cHBvcnRlZCB2ZXJzaW9uIG9mIEFuZ3VsYXIgdXNlc1xuLy8gVFMgMi44IG9yIGdyZWF0ZXIgKHNob3VsZCBiZSBBbmd1bGFyIDcpXG4vLyBleHBvcnQgY2xhc3MgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgaW1wbGVtZW50cyBSZXF1aXJlZDxDbHJDb21tb25TdHJpbmdzPiB7XG5leHBvcnQgY2xhc3MgQ2xyQ29tbW9uU3RyaW5nc1NlcnZpY2UgaW1wbGVtZW50cyBDbHJDb21tb25TdHJpbmdzIHtcbiAgb3BlbiA9ICdPcGVuJztcbiAgY2xvc2UgPSAnQ2xvc2UnO1xuICBzaG93ID0gJ1Nob3cnO1xuICBoaWRlID0gJ0hpZGUnO1xuICBleHBhbmQgPSAnRXhwYW5kJztcbiAgY29sbGFwc2UgPSAnQ29sbGFwc2UnO1xuICBtb3JlID0gJ01vcmUnO1xuICBzZWxlY3QgPSAnU2VsZWN0JztcbiAgc2VsZWN0QWxsID0gJ1NlbGVjdCBBbGwnO1xuICBwcmV2aW91cyA9ICdQcmV2aW91cyc7XG4gIG5leHQgPSAnTmV4dCc7XG4gIGN1cnJlbnQgPSAnSnVtcCB0byBjdXJyZW50JztcbiAgaW5mbyA9ICdJbmZvJztcbiAgc3VjY2VzcyA9ICdTdWNjZXNzJztcbiAgd2FybmluZyA9ICdXYXJuaW5nJztcbiAgZGFuZ2VyID0gJ0Vycm9yJztcbiAgcm93QWN0aW9ucyA9ICdBdmFpbGFibGUgYWN0aW9ucyc7XG4gIHBpY2tDb2x1bW5zID0gJ1Nob3cgb3IgaGlkZSBjb2x1bW5zJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblN0cmluZ3NGYWN0b3J5KGV4aXN0aW5nPzogQ2xyQ29tbW9uU3RyaW5ncyk6IENsckNvbW1vblN0cmluZ3Mge1xuICBjb25zdCBkZWZhdWx0cyA9IG5ldyBDbHJDb21tb25TdHJpbmdzU2VydmljZSgpO1xuICBpZiAoZXhpc3RpbmcpIHtcbiAgICByZXR1cm4geyAuLi5kZWZhdWx0cywgLi4uZXhpc3RpbmcgfTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdHM7XG59XG5cbmV4cG9ydCBjb25zdCBDT01NT05fU1RSSU5HU19QUk9WSURFUjogSW5qZWN0YWJsZVByb3ZpZGVyID0ge1xuICB1c2VGYWN0b3J5OiBjb21tb25TdHJpbmdzRmFjdG9yeSxcbiAgLy8gV2UgaGF2ZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgZm9yIG5vdywgd2UgY2FuIGFkZHJlc3MgaXQgbGF0ZXIgb25jZSB0aGVzZVxuICAvLyB0cmVlLXNoYWtlYWJsZSBwcm92aWRlcnMgaGF2ZSBwcm9wZXIgZG9jdW1lbnRhdGlvbi5cbiAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIGZvcndhcmRSZWYoKCkgPT4gQ2xyQ29tbW9uU3RyaW5ncyldXSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ09NTU9OX1NUUklOR1NfUFJPVklERVIgfSBmcm9tICcuL2NvbW1vbi1zdHJpbmdzLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290JyxcbiAgLi4uQ09NTU9OX1NUUklOR1NfUFJPVklERVIsXG59KVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENsckNvbW1vblN0cmluZ3Mge1xuICAvKipcbiAgICogT3BlbiBidXR0b25cbiAgICovXG4gIG9wZW4/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDbG9zZSBidXR0b25cbiAgICovXG4gIGNsb3NlPzogc3RyaW5nO1xuICAvKipcbiAgICogU2hvdyBidXR0b25cbiAgICovXG4gIHNob3c/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBIaWRlIGJ1dHRvblxuICAgKi9cbiAgaGlkZT86IHN0cmluZztcbiAgLyoqXG4gICAqIEV4cGFuZGFibGUgY29tcG9uZW50czogZXhwYW5kIGNhcmV0XG4gICAqL1xuICBleHBhbmQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBFeHBhbmRhYmxlIGNvbXBvbmVudHM6IGNvbGxhcHNlIGNhcmV0XG4gICAqL1xuICBjb2xsYXBzZT86IHN0cmluZztcbiAgLyoqXG4gICAqIE92ZXJmbG93IG1lbnVzOiBlbGxpcHNpcyBidXR0b25cbiAgICovXG4gIG1vcmU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTZWxlY3RhYmxlIGNvbXBvbmVudHM6IGNoZWNrYm94IG9yIHJhZGlvXG4gICAqL1xuICBzZWxlY3Q/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBTZWxlY3RhYmxlIGNvbXBvbmVudHM6IGNoZWNrYm94IHRvIHNlbGVjdCBhbGxcbiAgICovXG4gIHNlbGVjdEFsbD86IHN0cmluZztcbiAgLyoqXG4gICAqIFBhZ2luYXRpb246IHByZXZpb3VzIGJ1dHRvblxuICAgKi9cbiAgcHJldmlvdXM/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBQYWdpbmF0aW9uOiBuZXh0IGJ1dHRvblxuICAgKi9cbiAgbmV4dD86IHN0cmluZztcbiAgLyoqXG4gICAqIFBhZ2luYXRpb246IGdvIHRvIGN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbGVydCBsZXZlbHM6IGluZm9cbiAgICovXG4gIGluZm8/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbGVydCBsZXZlbHM6IHN1Y2Nlc3NcbiAgICovXG4gIHN1Y2Nlc3M/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbGVydCBsZXZlbHM6IHdhcm5pbmdcbiAgICovXG4gIHdhcm5pbmc/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBbGVydCBsZXZlbHM6IGRhbmdlclxuICAgKi9cbiAgZGFuZ2VyPzogc3RyaW5nO1xuICAvKipcbiAgICogRGF0YWdyaWQ6IHJvdyBhY3Rpb25zXG4gICAqL1xuICByb3dBY3Rpb25zPzogc3RyaW5nO1xuICAvKipcbiAgICogRGF0YWdyaWQ6IHBpY2sgY29sdW1uc1xuICAgKi9cbiAgcGlja0NvbHVtbnM/OiBzdHJpbmc7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIElucHV0LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcbmltcG9ydCB7IENMUl9NRU5VX1BPU0lUSU9OUyB9IGZyb20gJy4uLy4uL3BvcG92ZXIvZHJvcGRvd24vbWVudS1wb3NpdGlvbnMnO1xuaW1wb3J0IHsgQnV0dG9uSW5Hcm91cFNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvYnV0dG9uLWluLWdyb3VwLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgQ2xyQnV0dG9uIH0gZnJvbSAnLi9idXR0b24nO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItYnV0dG9uLWdyb3VwJyxcbiAgdGVtcGxhdGVVcmw6ICdidXR0b24tZ3JvdXAuaHRtbCcsXG4gIHByb3ZpZGVyczogW0J1dHRvbkluR3JvdXBTZXJ2aWNlXSxcbiAgaG9zdDogeyAnW2NsYXNzLmJ0bi1ncm91cF0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQnV0dG9uR3JvdXAge1xuICBAQ29udGVudENoaWxkcmVuKENsckJ1dHRvbikgYnV0dG9uczogUXVlcnlMaXN0PENsckJ1dHRvbj47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGJ1dHRvbkdyb3VwTmV3U2VydmljZTogQnV0dG9uSW5Hcm91cFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge31cblxuICBpbmxpbmVCdXR0b25zOiBDbHJCdXR0b25bXSA9IFtdO1xuICBtZW51QnV0dG9uczogQ2xyQnV0dG9uW10gPSBbXTtcblxuICAvKipcbiAgICogMS4gSW5pdGlhbGl6ZXMgdGhlIGluaXRpYWwgQnV0dG9uIEdyb3VwIFZpZXdcbiAgICogMi4gU3Vic2NyaWJlcyB0byBjaGFuZ2VzIG9uIHRoZSBDb250ZW50Q2hpbGRyZW5cbiAgICogICAgaW4gY2FzZSB0aGUgdXNlciBjb250ZW50IHByb2plY3Rpb24gY2hhbmdlc1xuICAgKi9cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZUJ1dHRvbnMoKTtcbiAgICB0aGlzLmJ1dHRvbkdyb3VwTmV3U2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZShidXR0b24gPT4gdGhpcy5yZWFycmFuZ2VCdXR0b24oYnV0dG9uKSk7XG4gICAgdGhpcy5idXR0b25zLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUJ1dHRvbnMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgYnV0dG9uIGludG8gdGhlIG90aGVyIFZpZXdDb250YWluZXJcbiAgICogd2hlbiBhbiB1cGRhdGUgaXMgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBidXR0b25cbiAgICovXG4gIHJlYXJyYW5nZUJ1dHRvbihidXR0b246IENsckJ1dHRvbik6IHZvaWQge1xuICAgIGxldCBmcm9tVmlldzogQ2xyQnV0dG9uW107XG4gICAgbGV0IHRvVmlldzogQ2xyQnV0dG9uW107XG4gICAgaWYgKGJ1dHRvbi5pbk1lbnUpIHtcbiAgICAgIGZyb21WaWV3ID0gdGhpcy5pbmxpbmVCdXR0b25zO1xuICAgICAgdG9WaWV3ID0gdGhpcy5tZW51QnV0dG9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbVZpZXcgPSB0aGlzLm1lbnVCdXR0b25zO1xuICAgICAgdG9WaWV3ID0gdGhpcy5pbmxpbmVCdXR0b25zO1xuICAgIH1cbiAgICBjb25zdCBpbmRleDogbnVtYmVyID0gZnJvbVZpZXcuaW5kZXhPZihidXR0b24pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBmcm9tVmlldy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY29uc3QgbW92ZUluZGV4ID0gdGhpcy5nZXRNb3ZlSW5kZXgoYnV0dG9uKTtcbiAgICAgIGlmIChtb3ZlSW5kZXggPD0gdG9WaWV3Lmxlbmd0aCkge1xuICAgICAgICB0b1ZpZXcuc3BsaWNlKG1vdmVJbmRleCwgMCwgYnV0dG9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXV0aG9yOiBFdWRlc1xuICAgKlxuICAgKiBGaW5kcyB0aGUgb3JkZXIgb2YgYSBidXR0b24gdy5yLnQgb3RoZXIgYnV0dG9uc1xuICAgKlxuICAgKiBAcGFyYW0gYnV0dG9uVG9Nb3ZlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXRNb3ZlSW5kZXgoYnV0dG9uVG9Nb3ZlOiBDbHJCdXR0b24pOiBudW1iZXIge1xuICAgIGNvbnN0IHRlbXBBcnI6IENsckJ1dHRvbltdID0gdGhpcy5idXR0b25zLmZpbHRlcihidXR0b24gPT4gYnV0dG9uLmluTWVudSA9PT0gYnV0dG9uVG9Nb3ZlLmluTWVudSk7XG4gICAgcmV0dXJuIHRlbXBBcnIuaW5kZXhPZihidXR0b25Ub01vdmUpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZUJ1dHRvbnMoKTogdm9pZCB7XG4gICAgY29uc3QgdGVtcElubGluZUJ1dHRvbnM6IENsckJ1dHRvbltdID0gW107XG4gICAgY29uc3QgdGVtcEluTWVudUJ1dHRvbnM6IENsckJ1dHRvbltdID0gW107XG4gICAgdGhpcy5idXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGlmIChidXR0b24uaW5NZW51KSB7XG4gICAgICAgIHRlbXBJbk1lbnVCdXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBJbmxpbmVCdXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmlubGluZUJ1dHRvbnMgPSB0ZW1wSW5saW5lQnV0dG9ucztcbiAgICB0aGlzLm1lbnVCdXR0b25zID0gdGVtcEluTWVudUJ1dHRvbnM7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcmZsb3cgTWVudVxuICAgKlxuICAgKi9cblxuICAvLyBJbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVyZmxvdyBtZW51XG4gIHByaXZhdGUgX21lbnVQb3NpdGlvbjogc3RyaW5nO1xuXG4gIGdldCBtZW51UG9zaXRpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbWVudVBvc2l0aW9uO1xuICB9XG5cbiAgQElucHV0KCdjbHJNZW51UG9zaXRpb24nKVxuICBzZXQgbWVudVBvc2l0aW9uKHBvczogc3RyaW5nKSB7XG4gICAgaWYgKHBvcyAmJiBDTFJfTUVOVV9QT1NJVElPTlMuaW5kZXhPZihwb3MpID4gLTEpIHtcbiAgICAgIHRoaXMuX21lbnVQb3NpdGlvbiA9IHBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWVudVBvc2l0aW9uID0gJ2JvdHRvbS1sZWZ0JztcbiAgICB9XG4gICAgLy8gc2V0IHRoZSBwb3BvdmVyIHZhbHVlcyBiYXNlZCBvbiBtZW51IHBvc2l0aW9uXG4gICAgc3dpdGNoICh0aGlzLl9tZW51UG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfUklHSFQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fUklHSFQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0LXRvcCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQtYm90dG9tJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0LXRvcCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdC1ib3R0b20nOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfb3Blbk1lbnU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgb3Blbk1lbnUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW5NZW51O1xuICB9XG5cbiAgc2V0IG9wZW5NZW51KHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fb3Blbk1lbnUgPSB2YWx1ZTtcbiAgfVxuXG4gIHB1YmxpYyBhbmNob3JQb2ludDogUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDsgLy8gZGVmYXVsdCBpZiBtZW51UG9zaXRpb24gaXNuJ3Qgc2V0XG4gIHB1YmxpYyBwb3BvdmVyUG9pbnQ6IFBvaW50ID0gUG9pbnQuTEVGVF9UT1A7IC8vIGRlZmF1bHQgaWYgbWVudVBvc2l0aW9uIGlzbid0IHNldFxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIENsckRyb3Bkb3duIE1lbnUgd2hlbiB0aGUgQ2xyRHJvcGRvd24gVG9nZ2xlIGlzXG4gICAqIGNsaWNrZWQuIEFsc28gc2V0IGEgZmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IHRoZSB0b2dnbGVcbiAgICogd2FzIGNsaWNrZWQgc28gdGhhdCB3ZSBkb24ndCB0cmF2ZXJzZSB0aGUgRE9NIHRvIGZpbmQgdGhlXG4gICAqIGxvY2F0aW9uIG9mIHRoZSBjbGljay5cbiAgICovXG4gIHRvZ2dsZU1lbnUoKTogdm9pZCB7XG4gICAgdGhpcy5vcGVuTWVudSA9ICF0aGlzLm9wZW5NZW51O1xuICAgIHRoaXMuX292ZXJmbG93TWVudVRvZ2dsZUNsaWNrZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsYWcgd2l0aCBpbmRpY2F0ZXMgaWYgdGhlIG92ZXJmbG93IG1lbnUgdG9nZ2xlIHdhcyBjbGlja2VkLlxuICAgKiBJZiB0cnVlLCB0aGlzIGNhbiBzYXZlIHVzIHRyYXZlcnNpbmcgdGhlIERPTSB0byBmaW5kXG4gICAqIHdoZXRoZXIgdGhlIGNsaWNrIHdhcyB3aXRoaW5nIHRoZSBidXR0b24gZ3JvdXAgdG9nZ2xlXG4gICAqIG9yIG1lbnUgaW4gdGhlIG9uTW91c2VDbGljayBtZXRob2RcbiAgICovXG4gIHByaXZhdGUgX292ZXJmbG93TWVudVRvZ2dsZUNsaWNrZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvLyBUT0RPOiBHZW5lcmljIERpcmVjdGl2ZSB0byBoYW5kbGUgdGhpc1xuICAvKipcbiAgICogQ2FsbGVkIG9uIG1vdXNlIGNsaWNrcyBhbnl3aGVyZSBpbiB0aGUgRE9NLlxuICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBtb3VzZWNsaWNrIGhhcHBlbmVkIG9uIHRoZSBob3N0IG9yIG91dHNpZGVcbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQudGFyZ2V0J10pXG4gIG9uTW91c2VDbGljayh0YXJnZXQ6IGFueSk6IHZvaWQge1xuICAgIGlmICh0aGlzLm9wZW5NZW51ICYmICF0aGlzLl9vdmVyZmxvd01lbnVUb2dnbGVDbGlja2VkKSB7XG4gICAgICAvLyBSZXNldCB0aGUgb3ZlcmZsb3cgbWVudSB0b2dnbGUgY2xpY2tlZCBmbGFnXG4gICAgICB0aGlzLl9vdmVyZmxvd01lbnVUb2dnbGVDbGlja2VkID0gZmFsc2U7XG4gICAgICBsZXQgY3VycmVudDogYW55ID0gdGFyZ2V0OyAvLyBHZXQgdGhlIGVsZW1lbnQgaW4gdGhlIERPTSBvbiB3aGljaCB0aGUgbW91c2Ugd2FzIGNsaWNrZWRcbiAgICAgIGNvbnN0IGhvc3Q6IGFueSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50OyAvLyBDdXJyZW50IEJ1dHRvbiBHcm91cFxuXG4gICAgICBpZiAoY3VycmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2Ryb3Bkb3duLW1lbnUnKSkge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgdGhpcy5vcGVuTWVudSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGNsaWNrZWQgb24gZHJvcGRvd24gbWVudSBhbmQgbWVudSBpcyBpbiBob3N0XG4gICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBob3N0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub3Blbk1lbnUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fb3ZlcmZsb3dNZW51VG9nZ2xlQ2xpY2tlZCA9IGZhbHNlOyAvLyBSZXNldCB0aGUgb3ZlcmZsb3cgbWVudSB0b2dnbGUgY2xpY2tlZCBmbGFnXG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vblBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckJ1dHRvbiB9IGZyb20gJy4vYnV0dG9uJztcbmltcG9ydCB7IENsckJ1dHRvbkdyb3VwIH0gZnJvbSAnLi9idXR0b24tZ3JvdXAnO1xuXG5leHBvcnQgY29uc3QgQ0xSX0JVVFRPTl9HUk9VUF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJCdXR0b24sIENsckJ1dHRvbkdyb3VwXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9CVVRUT05fR1JPVVBfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfQlVUVE9OX0dST1VQX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJCdXR0b25Hcm91cE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBhbmltYXRlLCBrZXlmcmFtZXMsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJMb2FkaW5nU3RhdGUgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmcnO1xuaW1wb3J0IHsgTG9hZGluZ0xpc3RlbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLWxpc3RlbmVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnYnV0dG9uW2NsckxvYWRpbmddJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwic3RhdGVcIj5cbiAgICAgICAgICAgIDxzcGFuICpuZ1N3aXRjaENhc2U9XCJidXR0b25TdGF0ZS5MT0FESU5HXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gQHNwaW5uZXIgY2xhc3M9XCJzcGlubmVyIHNwaW5uZXItaW5saW5lXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gKm5nU3dpdGNoQ2FzZT1cImJ1dHRvblN0YXRlLlNVQ0NFU1NcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBAdmFsaWRhdGVkIChAdmFsaWRhdGVkLmRvbmUpPVwidGhpcy5sb2FkaW5nU3RhdGVDaGFuZ2UodGhpcy5idXR0b25TdGF0ZS5ERUZBVUxUKVwiIGNsYXNzPVwic3Bpbm5lciBzcGlubmVyLWlubGluZSBzcGlubmVyLWNoZWNrXCI+PC9zcGFuPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gKm5nU3dpdGNoQ2FzZT1cImJ1dHRvblN0YXRlLkRFRkFVTFRcIiBAZGVmYXVsdEJ1dHRvbj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIGAsXG4gIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTG9hZGluZ0xpc3RlbmVyLCB1c2VFeGlzdGluZzogQ2xyTG9hZGluZ0J1dHRvbiB9XSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ2RlZmF1bHRCdXR0b24nLCBbXG4gICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbc3R5bGUoeyBvcGFjaXR5OiAwIH0pLCBhbmltYXRlKCcyMDBtcyAxMDBtcyBlYXNlLWluJywgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKV0pLFxuICAgICAgLy8gVE9ETzogc2VlIGlmIHdlIGNhbiBnZXQgbGVhdmUgYW5pbWF0aW9uIHRvIHdvcmsgYmVmb3JlIHNwaW5uZXIncyBlbnRlciBhbmltYXRpb25cbiAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSldKSxcbiAgICBdKSxcbiAgICB0cmlnZ2VyKCdzcGlubmVyJywgW1xuICAgICAgdHJhbnNpdGlvbignOmVudGVyJywgW3N0eWxlKHsgb3BhY2l0eTogMCB9KSwgYW5pbWF0ZSgnMjAwbXMgMTAwbXMgZWFzZS1pbicsIHN0eWxlKHsgb3BhY2l0eTogMSB9KSldKSxcbiAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtzdHlsZSh7IG9wYWNpdHk6IDEgfSksIGFuaW1hdGUoJzEwMG1zIGVhc2Utb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKV0pLFxuICAgIF0pLFxuICAgIHRyaWdnZXIoJ3ZhbGlkYXRlZCcsIFtcbiAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtcbiAgICAgICAgYW5pbWF0ZShcbiAgICAgICAgICAnNjAwbXMnLFxuICAgICAgICAgIGtleWZyYW1lcyhbXG4gICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3NjYWxlKDAsMCknLCBvZmZzZXQ6IDAgfSksXG4gICAgICAgICAgICBzdHlsZSh7IG9wYWNpdHk6IDEsIG9mZnNldDogMC4yIH0pLFxuICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSgxLjIsMS4yKScsIG9mZnNldDogMC40IH0pLFxuICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICdzY2FsZSguOSwuOSknLCBvZmZzZXQ6IDAuNiB9KSxcbiAgICAgICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAnc2NhbGUoMSwxKScsIG9mZnNldDogMSB9KSxcbiAgICAgICAgICBdKVxuICAgICAgICApLFxuICAgICAgXSksXG4gICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbc3R5bGUoeyBvcGFjaXR5OiAxIH0pLCBhbmltYXRlKCcxMDBtcyBlYXNlLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSldKSxcbiAgICBdKSxcbiAgXSxcbiAgaG9zdDogeyAnW2F0dHIuZGlzYWJsZWRdJzogXCJkaXNhYmxlZD8gJycgOiBudWxsXCIgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTG9hZGluZ0J1dHRvbiBpbXBsZW1lbnRzIExvYWRpbmdMaXN0ZW5lciB7XG4gIHB1YmxpYyBidXR0b25TdGF0ZSA9IENsckxvYWRpbmdTdGF0ZTtcbiAgcHVibGljIHN0YXRlOiBDbHJMb2FkaW5nU3RhdGUgPSBDbHJMb2FkaW5nU3RhdGUuREVGQVVMVDtcblxuICBASW5wdXQoJ2Rpc2FibGVkJykgcHVibGljIGRpc2FibGVkOiBib29sZWFuO1xuXG4gIEBPdXRwdXQoJ2NsckxvYWRpbmdDaGFuZ2UnKVxuICBwdWJsaWMgY2xyTG9hZGluZ0NoYW5nZTogRXZlbnRFbWl0dGVyPENsckxvYWRpbmdTdGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPENsckxvYWRpbmdTdGF0ZT4oZmFsc2UpO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlbDogRWxlbWVudFJlZiwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7fVxuXG4gIGxvYWRpbmdTdGF0ZUNoYW5nZShzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlKTogdm9pZCB7XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLnN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcblxuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgQ2xyTG9hZGluZ1N0YXRlLkRFRkFVTFQ6XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlU3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nKTsgLy8gZm9yIGNocm9taXVtIHJlbmRlciBidWcgc2VlIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMjcwMFxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuTE9BRElORzpcbiAgICAgICAgdGhpcy5zZXRFeHBsaWNpdEJ1dHRvbldpZHRoKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZXooMCknKTsgLy8gZm9yIGNocm9taXVtIHJlbmRlciBidWcgc2VlIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMjcwMFxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsICcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsckxvYWRpbmdTdGF0ZS5TVUNDRVNTOlxuICAgICAgICB0aGlzLnNldEV4cGxpY2l0QnV0dG9uV2lkdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsckxvYWRpbmdTdGF0ZS5FUlJPUjpcbiAgICAgICAgdGhpcy5sb2FkaW5nU3RhdGVDaGFuZ2UoQ2xyTG9hZGluZ1N0YXRlLkRFRkFVTFQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLmNsckxvYWRpbmdDaGFuZ2UuZW1pdChzdGF0ZSk7XG4gIH1cblxuICBwcml2YXRlIHNldEV4cGxpY2l0QnV0dG9uV2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuZWwubmF0aXZlRWxlbWVudCAmJiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICBjb25zdCBib3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgYCR7Ym91bmRpbmdDbGllbnRSZWN0LndpZHRofXB4YCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJMb2FkaW5nQnV0dG9uIH0gZnJvbSAnLi9sb2FkaW5nLWJ1dHRvbic7XG5cbmV4cG9ydCBjb25zdCBDTFJfTE9BRElOR19CVVRUT05fRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyTG9hZGluZ0J1dHRvbl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfTE9BRElOR19CVVRUT05fRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfTE9BRElOR19CVVRUT05fRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsckxvYWRpbmdCdXR0b25Nb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQnV0dG9uR3JvdXBNb2R1bGUgfSBmcm9tICcuL2J1dHRvbi1ncm91cC9idXR0b24tZ3JvdXAubW9kdWxlJztcbmltcG9ydCB7IENsckxvYWRpbmdCdXR0b25Nb2R1bGUgfSBmcm9tICcuL2J1dHRvbi1sb2FkaW5nL2xvYWRpbmctYnV0dG9uLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGV4cG9ydHM6IFtDbHJMb2FkaW5nQnV0dG9uTW9kdWxlLCBDbHJCdXR0b25Hcm91cE1vZHVsZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckJ1dHRvbk1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICB0ZW1wbGF0ZTogJycsXG59KVxuZXhwb3J0IGNsYXNzIEVtcHR5QW5jaG9yIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBFbXB0eUFuY2hvciB9IGZyb20gJy4vZW1wdHktYW5jaG9yJztcblxuLyoqXG4gKiBJbnRlcm5hbCBtb2R1bGUsIHBsZWFzZSBkbyBub3QgZXhwb3J0IVxuICovXG5ATmdNb2R1bGUoeyBkZWNsYXJhdGlvbnM6IFtFbXB0eUFuY2hvcl0sIGV4cG9ydHM6IFtFbXB0eUFuY2hvcl0sIGVudHJ5Q29tcG9uZW50czogW0VtcHR5QW5jaG9yXSB9KVxuZXhwb3J0IGNsYXNzIENsckhvc3RXcmFwcGluZ01vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jb250cm9sLWVycm9yJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmNsci1zdWJ0ZXh0XSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJDb250cm9sRXJyb3Ige31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItY29udHJvbC1oZWxwZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuY2xyLXN1YnRleHRdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNvbnRyb2xIZWxwZXIge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmdDb250cm9sU2VydmljZSB7XG4gIC8vIE9ic2VydmFibGUgdG8gc3Vic2NyaWJlIHRvIHRoZSBjb250cm9sLCBzaW5jZSBpdHMgbm90IGF2YWlsYWJsZSBpbW1lZGlhdGVseSBmb3IgcHJvamVjdGVkIGNvbnRlbnRcbiAgcHJpdmF0ZSBfY29udHJvbENoYW5nZXM6IFN1YmplY3Q8TmdDb250cm9sPiA9IG5ldyBTdWJqZWN0PE5nQ29udHJvbD4oKTtcbiAgZ2V0IGNvbnRyb2xDaGFuZ2VzKCk6IE9ic2VydmFibGU8TmdDb250cm9sPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgc2V0Q29udHJvbChjb250cm9sOiBOZ0NvbnRyb2wpIHtcbiAgICB0aGlzLl9jb250cm9sQ2hhbmdlcy5uZXh0KGNvbnRyb2wpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElmRXJyb3JTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLy8gSW1wbGVtZW50IG91ciBvd24gc3RhdHVzIGNoYW5nZXMgb2JzZXJ2YWJsZSwgc2luY2UgQW5ndWxhciBjb250cm9scyBkb24ndFxuICAvLyBmaXJlIG9uIGV2ZW50cyBsaWtlIGJsdXIsIGFuZCB3ZSB3YW50IHRvIHJldHVybiB0aGUgYm9vbGVhbiBzdGF0ZSBpbnN0ZWFkIG9mIGEgc3RyaW5nXG4gIHByaXZhdGUgX3N0YXR1c0NoYW5nZXM6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdCgpO1xuICBnZXQgc3RhdHVzQ2hhbmdlcygpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgLy8gV2FpdCBmb3IgdGhlIGNvbnRyb2wgdG8gYmUgYXZhaWxhYmxlXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICAgIHRoaXMuY29udHJvbCA9IGNvbnRyb2w7XG4gICAgICAgICAgdGhpcy5saXN0ZW5Gb3JDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8vIFN1YnNjcmliZSB0byB0aGUgc3RhdHVzIGNoYW5nZSBldmVudHMsIG9ubHkgYWZ0ZXIgdG91Y2hlZCBhbmQgZW1pdCB0aGUgY29udHJvbFxuICBwcml2YXRlIGxpc3RlbkZvckNoYW5nZXMoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmNvbnRyb2wuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnNlbmRWYWxpZGl0eSgpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzZW5kVmFsaWRpdHkoKSB7XG4gICAgaWYgKCh0aGlzLmNvbnRyb2wudG91Y2hlZCB8fCB0aGlzLmNvbnRyb2wuZGlydHkpICYmIHRoaXMuY29udHJvbC5pbnZhbGlkKSB7XG4gICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLm5leHQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMubmV4dChmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWxsb3dzIGEgY29udHJvbCB0byBwdXNoIGEgc3RhdHVzIGNoZWNrIHVwc3RyZWFtLCBzdWNoIGFzIG9uIGJsdXJcbiAgdHJpZ2dlclN0YXR1c0NoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5jb250cm9sKSB7XG4gICAgICB0aGlzLnNlbmRWYWxpZGl0eSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFuIHVwIHN1YnNjcmlwdGlvbnNcbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT3B0aW9uYWwsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xySWZFcnJvcl0nIH0pXG5leHBvcnQgY2xhc3MgQ2xySWZFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZSxcbiAgICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIGlmICghdGhpcy5pZkVycm9yU2VydmljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHJJZkVycm9yIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIGEgZm9ybSBjb250cm9sIGNvbnRhaW5lciBlbGVtZW50IGxpa2UgY2xyLWlucHV0LWNvbnRhaW5lcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BsYXlFcnJvcihmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2Uuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoaW52YWxpZCA9PiB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgc3BlY2lmaWMgZXJyb3IgdG8gdHJhY2ssIGNoZWNrIGl0LCBvdGhlcndpc2UgY2hlY2sgb3ZlcmFsbCB2YWxpZGl0eVxuICAgICAgICBpZiAodGhpcy5lcnJvciAmJiB0aGlzLmNvbnRyb2wpIHtcbiAgICAgICAgICB0aGlzLmRpc3BsYXlFcnJvcih0aGlzLmNvbnRyb2wuaGFzRXJyb3IodGhpcy5lcnJvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yKGludmFsaWQpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBASW5wdXQoJ2NscklmRXJyb3InKSBlcnJvcjogc3RyaW5nO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBkaXNwbGF5ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIHByaXZhdGUgZGlzcGxheUVycm9yKGludmFsaWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoaW52YWxpZCAmJiAhdGhpcy5kaXNwbGF5ZWQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlKTtcbiAgICAgIHRoaXMuZGlzcGxheWVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFpbnZhbGlkKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5sZXQgY291bnRlciA9IDA7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb250cm9sSWRTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfaWQgPSAnY2xyLWZvcm0tY29udHJvbC0nICsgKytjb3VudGVyO1xuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIHRoaXMuX2lkQ2hhbmdlLm5leHQodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaWRDaGFuZ2U6IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+ID0gbmV3IEJlaGF2aW9yU3ViamVjdCh0aGlzLl9pZCk7XG4gIHB1YmxpYyBnZXQgaWRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5faWRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgZW51bSBMYXlvdXRzIHtcbiAgVkVSVElDQUwgPSAndmVydGljYWwnLFxuICBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnLFxuICBDT01QQUNUID0gJ2NvbXBhY3QnLFxufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTGF5b3V0U2VydmljZSB7XG4gIGxheW91dDogTGF5b3V0cyA9IExheW91dHMuSE9SSVpPTlRBTDtcbiAgLy8gVGhpcyBpcyBiYXNpY2FsbHkgYSByZXBsYWNlbWVudCBmb3IgT2JqZWN0LnZhbHVlcygpLCB3aGljaCBJRTExIGFuZCBOb2RlIDw5IGRvbid0IHN1cHBvcnQgOihcbiAgLy8gU3RyaW5nIGVudW1zIGNhbm5vdCBiZSByZXZlcnNlLW1hcHBlZCwgbWVhbmluZyBMYXlvdXRzWydDT01QQUNUJ10gZG9lcyBub3QgcmV0dXJuICdjb21wYWN0JyBzb1xuICAvLyB0aGlzIGV4aXN0cyB0byBkZWFsIHdpdGggdGhpcyBsaXR0bGUgY2F2ZWF0IHRvIGdldCB0aGUgbGlzdCBvZiB0aGUgdmFsdWVzIGFzIGFuIGFycmF5LlxuICBwcml2YXRlIGxheW91dFZhbHVlczogc3RyaW5nW10gPSBPYmplY3Qua2V5cyhMYXlvdXRzKS5tYXAoa2V5ID0+IExheW91dHNba2V5XSk7XG5cbiAgaXNWZXJ0aWNhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQgPT09IExheW91dHMuVkVSVElDQUw7XG4gIH1cblxuICBpc0hvcml6b250YWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0ID09PSBMYXlvdXRzLkhPUklaT05UQUw7XG4gIH1cblxuICBpc0NvbXBhY3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubGF5b3V0ID09PSBMYXlvdXRzLkNPTVBBQ1Q7XG4gIH1cblxuICBnZXQgbGF5b3V0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNsci1mb3JtLSR7dGhpcy5sYXlvdXR9YDtcbiAgfVxuXG4gIGlzVmFsaWQobGF5b3V0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5sYXlvdXRWYWx1ZXMuaW5kZXhPZihsYXlvdXQpID4gLTE7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3B0aW9uYWwsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdsYWJlbCcgfSlcbmV4cG9ydCBjbGFzcyBDbHJMYWJlbCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sSWRTZXJ2aWNlOiBDb250cm9sSWRTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWZcbiAgKSB7fVxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5mb3InKVxuICBASW5wdXQoJ2ZvcicpXG4gIGZvckF0dHI6IHN0cmluZztcblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHByaXZhdGUgZW5hYmxlR3JpZCA9IHRydWU7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLy8gT25seSBhZGQgdGhlIGNsci1jb250cm9sLWxhYmVsIGlmIGl0IGlzIGluc2lkZSBhIGNvbnRyb2wgY29udGFpbmVyXG4gICAgaWYgKHRoaXMuY29udHJvbElkU2VydmljZSB8fCB0aGlzLm5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xyLWNvbnRyb2wtbGFiZWwnKTtcbiAgICB9XG4gICAgLy8gT25seSBzZXQgdGhlIGdyaWQgY29sdW1uIGNsYXNzZXMgaWYgd2UgYXJlIGluIHRoZSByaWdodCBjb250ZXh0IGFuZCBpZiB0aGV5IGFyZW4ndCBhbHJlYWR5IHNldFxuICAgIGlmIChcbiAgICAgIHRoaXMuZW5hYmxlR3JpZCAmJlxuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlICYmXG4gICAgICAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSAmJlxuICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50ICYmXG4gICAgICB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2Nsci1jb2wnKSA8IDBcbiAgICApIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xyLWNvbC0xMicpO1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbHItY29sLW1kLTInKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29udHJvbElkU2VydmljZSAmJiAhdGhpcy5mb3JBdHRyKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLmNvbnRyb2xJZFNlcnZpY2UuaWRDaGFuZ2Uuc3Vic2NyaWJlKGlkID0+ICh0aGlzLmZvckF0dHIgPSBpZCkpKTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlR3JpZCgpIHtcbiAgICB0aGlzLmVuYWJsZUdyaWQgPSBmYWxzZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGNvbnN0IElTX05FV19GT1JNU19MQVlPVVQgPSBuZXcgSW5qZWN0aW9uVG9rZW48Ym9vbGVhbj4oJ0lTX05FV19GT1JNU19MQVlPVVQnKTtcbmV4cG9ydCBjb25zdCBJU19ORVdfRk9STVNfTEFZT1VUX1RSVUVfUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IElTX05FV19GT1JNU19MQVlPVVQsXG4gIHVzZVZhbHVlOiB0cnVlLFxufTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWFya0NvbnRyb2xTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfZGlydHk6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdCgpO1xuXG4gIGdldCBkaXJ0eUNoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHkuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBtYXJrQXNEaXJ0eSgpIHtcbiAgICB0aGlzLl9kaXJ0eS5uZXh0KCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IElTX05FV19GT1JNU19MQVlPVVRfVFJVRV9QUk9WSURFUiB9IGZyb20gJy4vcHJvdmlkZXJzL25ldy1mb3Jtcy5zZXJ2aWNlJztcbmltcG9ydCB7IE1hcmtDb250cm9sU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL21hcmstY29udHJvbC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsckZvcm1dJyxcbiAgcHJvdmlkZXJzOiBbTGF5b3V0U2VydmljZSwgTWFya0NvbnRyb2xTZXJ2aWNlLCBJU19ORVdfRk9STVNfTEFZT1VUX1RSVUVfUFJPVklERVJdLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybV0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1ob3Jpem9udGFsXSc6ICdsYXlvdXRTZXJ2aWNlLmlzSG9yaXpvbnRhbCgpJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbXBhY3RdJzogJ2xheW91dFNlcnZpY2UuaXNDb21wYWN0KCknLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJGb3JtIHtcbiAgY29uc3RydWN0b3IocHVibGljIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsIHByaXZhdGUgbWFya0NvbnRyb2xTZXJ2aWNlOiBNYXJrQ29udHJvbFNlcnZpY2UpIHt9XG5cbiAgbWFya0FzRGlydHkoKSB7XG4gICAgdGhpcy5tYXJrQ29udHJvbFNlcnZpY2UubWFya0FzRGlydHkoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMYXlvdXRzLCBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRm9ybV1bY2xyTGF5b3V0XScsXG59KVxuZXhwb3J0IGNsYXNzIENsckxheW91dCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBJbnB1dCgnY2xyTGF5b3V0JykgbGF5b3V0OiBMYXlvdXRzO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIC8vIE9ubHkgc2V0IHRoZSBsYXlvdXQgaWYgaXQgaXMgYSB2YWxpZCBvcHRpb25cbiAgICBpZiAodGhpcy5sYXlvdXQgJiYgdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmFsaWQodGhpcy5sYXlvdXQpKSB7XG4gICAgICB0aGlzLmxheW91dFNlcnZpY2UubGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQ29udHJvbEVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBDbHJDb250cm9sSGVscGVyIH0gZnJvbSAnLi9oZWxwZXInO1xuaW1wb3J0IHsgQ2xySWZFcnJvciB9IGZyb20gJy4vaWYtZXJyb3IvaWYtZXJyb3InO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuL2xhYmVsJztcbmltcG9ydCB7IENsckZvcm0gfSBmcm9tICcuL2Zvcm0nO1xuaW1wb3J0IHsgQ2xyTGF5b3V0IH0gZnJvbSAnLi9sYXlvdXQnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xyTGFiZWwsIENsckNvbnRyb2xFcnJvciwgQ2xyQ29udHJvbEhlbHBlciwgQ2xySWZFcnJvciwgQ2xyRm9ybSwgQ2xyTGF5b3V0XSxcbiAgZXhwb3J0czogW0NsckxhYmVsLCBDbHJDb250cm9sRXJyb3IsIENsckNvbnRyb2xIZWxwZXIsIENscklmRXJyb3IsIENsckZvcm0sIENsckxheW91dF0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNvbW1vbkZvcm1zTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgQ29udGVudENoaWxkLCBJbmplY3QsIEluamVjdGlvblRva2VuLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsJztcblxuZXhwb3J0IGNvbnN0IElTX1RPR0dMRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4+KCdJU19UT0dHTEUnKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1RvZ2dsZUZhY3RvcnkoKSB7XG4gIHJldHVybiBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbn1cbmV4cG9ydCBjb25zdCBJU19UT0dHTEVfUFJPVklERVIgPSB7IHByb3ZpZGU6IElTX1RPR0dMRSwgdXNlRmFjdG9yeTogaXNUb2dnbGVGYWN0b3J5IH07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1jaGVja2JveC13cmFwcGVyLGNsci10b2dnbGUtd3JhcHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsckNoZWNrYm94XSxbY2xyVG9nZ2xlXVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWxcIj48L2xhYmVsPlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItY2hlY2tib3gtd3JhcHBlcl0nOiAnIXRvZ2dsZScsXG4gICAgJ1tjbGFzcy5jbHItdG9nZ2xlLXdyYXBwZXJdJzogJ3RvZ2dsZScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0NvbnRyb2xJZFNlcnZpY2UsIElTX1RPR0dMRV9QUk9WSURFUl0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94V3JhcHBlciBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBPbkluaXQsIE9uRGVzdHJveSB7XG4gIC8vIFdlIG5lZWQgYm90aCBfZHluYW1pYyBmb3IgSG9zdFdyYXBwZXIgYW5kIENvbnRlbnRDaGlsZChDbHJMYWJlbCkgaW4gY2FzZXMgd2hlcmVcbiAgLy8gdGhlIHVzZXIgcHV0cyBhIHJhZGlvIGluc2lkZSBhIHdyYXBwZXIgd2l0aG91dCBhIGxhYmVsLCBob3N0IHdyYXBwaW5nIGRvZXNuJ3QgYXBwbHlcbiAgLy8gYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0byBpbnNlcnQgYSBsYWJlbFxuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIHRvZ2dsZSA9IGZhbHNlO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChJU19UT0dHTEUpIHRvZ2dsZVNlcnZpY2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPikge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdG9nZ2xlU2VydmljZS5zdWJzY3JpYmUoc3RhdGUgPT4ge1xuICAgICAgICB0aGlzLnRvZ2dsZSA9IHN0YXRlO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMubGFiZWwpIHtcbiAgICAgIHRoaXMubGFiZWwuZGlzYWJsZUdyaWQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBDb21wb25lbnRGYWN0b3J5LFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIEVsZW1lbnRSZWYsXG4gIEluamVjdGlvblRva2VuLFxuICBJbmplY3RvcixcbiAgVHlwZSxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgRW1wdHlBbmNob3IgfSBmcm9tICcuL2VtcHR5LWFuY2hvcic7XG5cbi8qKlxuICogSG9zdFdyYXBwZXIgbXVzdCBiZSBjYWxsZWQgaW4gT25Jbml0IHRvIGVuc3VyZSB0aGF0IHRoZSBWaWV3cyBhcmUgcmVhZHkuIElmIGl0cyBjYWxsZWQgaW4gYSBjb25zdHJ1Y3RvciB0aGUgdmlldyBpc1xuICogc3RpbGwgdW5kZWZpbmVkLlxuICogVE9ETyAtIG1ha2Ugc3VyZSB0aGVzZSBjb21tZW50IGFubm90YXRpb25zIGRvIG5vdCBicmVhayBuZy1wYWNrZ3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb3N0V3JhcHBlcjxXIGV4dGVuZHMgRHluYW1pY1dyYXBwZXI+IGltcGxlbWVudHMgSW5qZWN0b3Ige1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXJUeXBlOiBUeXBlPFc+LCB2Y3I6IFZpZXdDb250YWluZXJSZWYsIGluZGV4OiBudW1iZXIgPSAwKSB7XG4gICAgdGhpcy5pbmplY3RvciA9IHZjci5pbmplY3RvcjtcbiAgICAvLyBJZiB0aGUgaG9zdCBpcyBhbHJlYWR5IHdyYXBwZWQsIHdlIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKCF0aGlzLmluamVjdG9yLmdldChjb250YWluZXJUeXBlLCBudWxsKSkge1xuICAgICAgY29uc3QgY2ZyID0gdGhpcy5pbmplY3Rvci5nZXQoQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKTtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5pbmplY3Rvci5nZXQoRWxlbWVudFJlZik7XG5cbiAgICAgIC8vIFdlIG5lZWQgYSBuZXcgYW5jaG9yLCBzaW5jZSB3ZSdyZSBwcm9qZWN0aW5nIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgIHZjci5jcmVhdGVDb21wb25lbnQoY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KEVtcHR5QW5jaG9yKSk7XG4gICAgICBjb25zdCBmYWN0b3J5OiBDb21wb25lbnRGYWN0b3J5PFc+ID0gY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbnRhaW5lclR5cGUpO1xuICAgICAgLy8gQ3JhZnQgdGhlIGVsZW1lbnQgYXJyYXkgYmFzZWQgb24gd2hhdCBzbG90IHRvIHVzZS4gQW5ndWxhciBvbmx5IHVzZXMgdGhlIGluZGV4IHRvIGRldGVybWluZVxuICAgICAgLy8gd2hpY2ggbmctY29udGVudCB0byBwcm9qZWN0IGludG8sIHNvIGlmIHlvdSBoYXZlIG1vcmUgdGhhbiBvbmUgbmctY29udGVudCB5b3UnbGwgbmVlZCB0byBzZXRcbiAgICAgIC8vIHRoZSBpbmRleCBpbiB0aGUgY29uc3RydWN0b3IgYXBwcm9wcmlhdGVseVxuICAgICAgY29uc3QgZWxlbWVudCA9IFtdO1xuICAgICAgZWxlbWVudFtpbmRleF0gPSBbZWwubmF0aXZlRWxlbWVudF07XG4gICAgICAvLyBXZSdyZSBhc3N1bWluZyBvbmx5IG9uZSBwcm9qZWN0aW9uIHNsb3QsIGJ1dCBpbiBtb3JlIGNvbXBsZXggY2FzZXMgd2UgbWlnaHQgd2FudCB0byBwcm92aWRlXG4gICAgICAvLyBhIGRpZmZlcmVudCBhcnJheSBvZiBwcm9qZWN0ZWQgZWxlbWVudHMuXG4gICAgICBjb25zdCBjb250YWluZXJSZWYgPSB2Y3IuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBlbGVtZW50KTtcbiAgICAgIC8vIFdlIGNhbiBub3cgcmVtb3ZlIHRoZSB1c2VsZXNzIGFuY2hvclxuICAgICAgdmNyLnJlbW92ZSgwKTtcblxuICAgICAgLy8gV2Ugbm90ZSB0aGF0IHRoZSBjb250YWluZXIgd2FzIGR5bmFtaWNhbGx5IGNyZWF0ZWRcbiAgICAgIGNvbnRhaW5lclJlZi5pbnN0YW5jZS5fZHluYW1pYyA9IHRydWU7XG5cbiAgICAgIC8vIFdlIGtlZXAgdGhlIHdyYXBwZXIncyBpbmplY3RvciB0byBhY2Nlc3MgdGhlIGRlcGVuZGVuY2llcyB0aGF0IHdlcmVuJ3QgYXZhaWxhYmxlIGJlZm9yZS5cbiAgICAgIHRoaXMuaW5qZWN0b3IgPSBjb250YWluZXJSZWYuaW5qZWN0b3I7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgZ2V0PFQ+KHRva2VuOiBUeXBlPFQ+IHwgSW5qZWN0aW9uVG9rZW48VD4sIG5vdEZvdW5kVmFsdWU/OiBUKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuaW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb250cm9sQ2xhc3NTZXJ2aWNlIHtcbiAgY2xhc3NOYW1lID0gJyc7XG5cbiAgY29udHJvbENsYXNzKGludmFsaWQgPSBmYWxzZSwgZ3JpZCA9IGZhbHNlLCBhZGRpdGlvbmFsID0gJycpIHtcbiAgICBjb25zdCBjb250cm9sQ2xhc3NlcyA9IFt0aGlzLmNsYXNzTmFtZSwgYWRkaXRpb25hbF07XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIGNvbnRyb2xDbGFzc2VzLnB1c2goJ2Nsci1lcnJvcicpO1xuICAgIH1cbiAgICBpZiAoZ3JpZCAmJiB0aGlzLmNsYXNzTmFtZS5pbmRleE9mKCdjbHItY29sJykgPT09IC0xKSB7XG4gICAgICBjb250cm9sQ2xhc3Nlcy5wdXNoKCdjbHItY29sLW1kLTEwIGNsci1jb2wtMTInKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xDbGFzc2VzLmpvaW4oJyAnKS50cmltKCk7XG4gIH1cblxuICAvLyBXZSB3YW50IHRvIHJlbW92ZSB0aGUgY29sdW1uIGNsYXNzZXMgZnJvbSB0aGUgaW5wdXQgdXAgdG8gdGhlIGNvbnRhaW5lclxuICBpbml0Q29udHJvbENsYXNzKHJlbmRlcmVyLCBlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lO1xuICAgICAgY29uc3Qga2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICBrbGFzc2VzLmZvckVhY2goa2xhc3MgPT4ge1xuICAgICAgICBpZiAoa2xhc3Muc3RhcnRzV2l0aCgnY2xyLWNvbCcpKSB7XG4gICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudCwga2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBIb3N0QmluZGluZyxcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkluaXQsXG4gIFR5cGUsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFJlbmRlcmVyMixcbiAgRWxlbWVudFJlZixcbiAgT25EZXN0cm95LFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi9pZi1lcnJvci9pZi1lcnJvci5zZXJ2aWNlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTWFya0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbWFyay1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBjbGFzcyBXcmFwcGVkRm9ybUNvbnRyb2w8VyBleHRlbmRzIER5bmFtaWNXcmFwcGVyPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlO1xuICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZTtcbiAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlO1xuICBwcml2YXRlIG1hcmtDb250cm9sU2VydmljZTogTWFya0NvbnRyb2xTZXJ2aWNlO1xuXG4gIHByb3RlY3RlZCBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcm90ZWN0ZWQgaW5kZXggPSAwO1xuICBwcm90ZWN0ZWQgY29udHJvbElkU2VydmljZTogQ29udHJvbElkU2VydmljZTtcblxuICBfaWQ6IHN0cmluZztcblxuICAvLyBJIGxvc3Qgd2F5IHRvbyBtdWNoIHRpbWUgdHJ5aW5nIHRvIG1ha2UgdGhpcyB3b3JrIHdpdGhvdXQgaW5qZWN0aW5nIHRoZSBWaWV3Q29udGFpbmVyUmVmIGFuZCB0aGUgSW5qZWN0b3IsXG4gIC8vIEknbSBnaXZpbmcgdXAuIFNvIHdlIGhhdmUgdG8gaW5qZWN0IHRoZXNlIHR3byBtYW51YWxseSBmb3Igbm93LlxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByb3RlY3RlZCB3cmFwcGVyVHlwZTogVHlwZTxXPixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2w6IE5nQ29udHJvbCxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UgPSBpbmplY3Rvci5nZXQoTmdDb250cm9sU2VydmljZSk7XG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KElmRXJyb3JTZXJ2aWNlKTtcbiAgICAgIHRoaXMuY29udHJvbENsYXNzU2VydmljZSA9IGluamVjdG9yLmdldChDb250cm9sQ2xhc3NTZXJ2aWNlKTtcbiAgICAgIHRoaXMubWFya0NvbnRyb2xTZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KE1hcmtDb250cm9sU2VydmljZSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIGlmICh0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UpIHtcbiAgICAgIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5pbml0Q29udHJvbENsYXNzKHJlbmRlcmVyLCBlbC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWFya0NvbnRyb2xTZXJ2aWNlKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgICAgdGhpcy5tYXJrQ29udHJvbFNlcnZpY2UuZGlydHlDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm5nQ29udHJvbC5jb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgdGhpcy5uZ0NvbnRyb2wuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0QmluZGluZygpXG4gIEBJbnB1dCgpXG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmNvbnRyb2xJZFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuY29udHJvbElkU2VydmljZS5pZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICB0cmlnZ2VyVmFsaWRhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pZkVycm9yU2VydmljZSkge1xuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS50cmlnZ2VyU3RhdHVzQ2hhbmdlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY29udGFpbmVySW5qZWN0b3I6IEluamVjdG9yO1xuXG4gIC8vIEBUT0RPIFRoaXMgbWV0aG9kIGhhcyBhIHRyeS9jYXRjaCBkdWUgdG8gYW4gdW5rbm93biBpc3N1ZSB0aGF0IGNhbWUgd2hlbiBidWlsZGluZyB0aGUgY2xyVG9nZ2xlIGZlYXR1cmVcbiAgLy8gV2UgbmVlZCB0byBmaWd1cmUgb3V0IHdoeSB0aGlzIGZhaWxzIGZvciB0aGUgQ2xyVG9nZ2xlIHNjZW5hcmlvIGJ1dCB3b3JrcyBmb3IgRGF0ZSBwaWNrZXIuLi5cbiAgLy8gVG8gc2VlIHRoZSBlcnJvciwgcmVtb3ZlIHRoZSB0cnkvY2F0Y2ggaGVyZSBhbmQgcnVuIHRoZSBDbHJUb2dnbGUgc3VpdGUgdG8gc2VlIGlzc3VlcyBnZXR0aW5nIHRoZSBjb250YWluZXJcbiAgLy8gaW5qZWN0b3IgaW4gdGltZSwgYW5kIHRoaXMgT05MWSBIQVBQRU5TIGluIHRlc3RzIGFuZCBub3QgaW4gZGV2L3Byb2QgbW9kZS5cbiAgcHJvdGVjdGVkIGdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcjxUPih0b2tlbjogVHlwZTxUPiB8IEluamVjdGlvblRva2VuPFQ+LCBub3RGb3VuZFZhbHVlPzogVCk6IFQge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVySW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbm90Rm91bmRWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLl9jb250YWluZXJJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcih0aGlzLndyYXBwZXJUeXBlLCB0aGlzLnZjciwgdGhpcy5pbmRleCk7XG4gICAgdGhpcy5jb250cm9sSWRTZXJ2aWNlID0gdGhpcy5fY29udGFpbmVySW5qZWN0b3IuZ2V0KENvbnRyb2xJZFNlcnZpY2UpO1xuICAgIGlmICh0aGlzLl9pZCkge1xuICAgICAgdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkID0gdGhpcy5faWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lkID0gdGhpcy5jb250cm9sSWRTZXJ2aWNlLmlkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5nQ29udHJvbFNlcnZpY2UpIHtcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5zZXRDb250cm9sKHRoaXMubmdDb250cm9sKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIFNlbGYsIE9wdGlvbmFsLCBWaWV3Q29udGFpbmVyUmVmLCBBdHRyaWJ1dGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJDaGVja2JveFdyYXBwZXIsIElTX1RPR0dMRSB9IGZyb20gJy4vY2hlY2tib3gtd3JhcHBlcic7XG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcblxuLyoqXG4gKiBUaGlzIGltcGxlbWVudHMgYm90aCB0aGUgY2xyQ2hlY2tib3ggYW5kIGNsclRvZ2dsZSBmdW5jdGlvbmFsaXR5LCBzaW5jZSB0aGV5IGFyZSBib3RoIGp1c3QgY2hlY2tib3hlcyB3aXRoIGRpZmZlcmVudFxuICogdmlzdWFsIHN0eWxpbmcuIFRoZSBjaGFsbGVuZ2UgaXMgdGhhdCB0aGUgY29udGFpbmVyIG5lZWRzIHRvIGtub3cgd2hpY2ggc2VsZWN0b3Igd2FzIHVzZWQsIHdoaWNoIHRoZSBAQXR0cmlidXRlXG4gKiBkZWNvcmF0b3IgZ2V0cyBmb3IgdXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSB0b2dnbGUgaXMgdXNlZCwgYW5kIGVtaXRzIGEgdmFsdWUgdG8gdGhlIHdyYXBwZXIgY29udGFpbmVyIHRvIHRlbGwgaXRcbiAqIHRoZXJlIGlzIGEgdG9nZ2xlIHN3aXRjaCBpbnN0ZWFkLlxuICovXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyQ2hlY2tib3hdLFtjbHJUb2dnbGVdJyB9KVxuZXhwb3J0IGNsYXNzIENsckNoZWNrYm94IGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsckNoZWNrYm94V3JhcHBlcj4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmLFxuICAgIEBBdHRyaWJ1dGUoJ2NsclRvZ2dsZScpIHByaXZhdGUgdG9nZ2xlOiBzdHJpbmdcbiAgKSB7XG4gICAgc3VwZXIodmNyLCBDbHJDaGVja2JveFdyYXBwZXIsIGluamVjdG9yLCBjb250cm9sLCByZW5kZXJlciwgZWwpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgIGNvbnN0IHRvZ2dsZVNlcnZpY2UgPSB0aGlzLmdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcjxCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4+KElTX1RPR0dMRSwgbnVsbCk7XG5cbiAgICBpZiAodG9nZ2xlU2VydmljZSAmJiB0aGlzLnRvZ2dsZSAhPT0gbnVsbCkge1xuICAgICAgdG9nZ2xlU2VydmljZS5uZXh0KHRydWUpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNoZWNrYm94LWNvbnRhaW5lcixjbHItdG9nZ2xlLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgPGxhYmVsICpuZ0lmPVwiIWxhYmVsICYmIGFkZEdyaWQoKVwiPjwvbGFiZWw+XG4gICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtjbGFzcy5jbHItY29udHJvbC1pbmxpbmVdPVwiY2xySW5saW5lXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jaGVja2JveC13cmFwcGVyLGNsci10b2dnbGUtd3JhcHBlclwiPjwvbmctY29udGVudD5cbiAgICAgIDxkaXYgY2xhc3M9XCJjbHItc3VidGV4dC13cmFwcGVyXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2wtZGlzYWJsZWRdJzogJ2NvbnRyb2w/LmRpc2FibGVkJyxcbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW05nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2UsIElmRXJyb3JTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hDb250YWluZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGludmFsaWQgPSBmYWxzZTtcbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuICBwcml2YXRlIGlubGluZSA9IGZhbHNlO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG4gIC8vIHByaXZhdGUgZm9ybUdyb3VwOiBBYnN0cmFjdENvbnRyb2w7XG5cbiAgLypcbiAgICogSGVyZSB3ZSB3YW50IHRvIHN1cHBvcnQgdGhlIGZvbGxvd2luZyBjYXNlc1xuICAgKiBjbHJJbmxpbmUgLSB0cnVlIGJ5IHByZXNlbmNlXG4gICAqIGNscklubGluZT1cInRydWV8ZmFsc2VcIiAtIHVubGVzcyBpdCBpcyBleHBsaWNpdGx5IGZhbHNlLCBzdHJpbmdzIGFyZSBjb25zaWRlcmVkIHRydWVcbiAgICogW2NscklubGluZV09XCJ0cnVlfGZhbHNlXCIgLSBleHBlY3QgYSBib29sZWFuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgY2xySW5saW5lKHZhbHVlOiBib29sZWFuIHwgc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuaW5saW5lID0gdmFsdWUgPT09ICdmYWxzZScgPyBmYWxzZSA6IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5saW5lID0gISF2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNscklubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmxpbmU7XG4gIH1cblxuICAvLyBAVE9ETyBTb2x2ZSBmb3IgZ3JvdXAgdmFsaWRhdGlvbiwgd2hpY2ggZG9lc24ndCB3b3JrIG5vdyB3aXRoIG5nTW9kZWxHcm91cFxuICAvLyBCbG9ja2VkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIwMjY4XG4gIC8vIEBJbnB1dCgpXG4gIC8vIHNldCBjbHJGb3JtR3JvdXAodmFsdWU6IEZvcm1Hcm91cCkge1xuICAvLyAgIHRoaXMuZm9ybUdyb3VwID0gdmFsdWU7XG4gIC8vIH1cblxuICAvLyBASW5wdXQoKVxuICAvLyBzZXQgY2xyRm9ybUFycmF5KHZhbHVlOiBGb3JtQXJyYXkpIHtcbiAgLy8gICB0aGlzLmZvcm1Hcm91cCA9IHZhbHVlO1xuICAvLyB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm5nQ29udHJvbFNlcnZpY2UuY29udHJvbENoYW5nZXMuc3Vic2NyaWJlKGNvbnRyb2wgPT4ge1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgLy8gQFRPRE8gcHV0IGEgc29sdXRpb24gaW4gZm9yIGZvcm0gZ3JvdXAgdmFsaWRhdGlvblxuICAgIC8vIGlmICghdGhpcy5mb3JtR3JvdXApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaWZFcnJvclNlcnZpY2Uuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoaW52YWxpZCA9PiB7XG4gICAgICAgIHRoaXMuaW52YWxpZCA9IGludmFsaWQ7XG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIC8vIEJlY2F1c2UgbmdNb2RlbCBkb2VzIHRoaXMsIHdlIGhhdmUgdG8gZGVsYXkgYSB0aWNrIHRvIGdldCB0aGUgcmVzdWx0XG4gICAgLy8gICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAvLyAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgLy8gICAgICAgdGhpcy5mb3JtR3JvdXAuc3RhdHVzQ2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIC8vICAgICAgICAgdGhpcy5pbnZhbGlkID0gdGhpcy5mb3JtR3JvdXAuaW52YWxpZDtcbiAgICAvLyAgICAgICB9KVxuICAgIC8vICAgICApO1xuICAgIC8vICAgfSk7XG4gICAgLy8gfVxuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCksIHRoaXMuaW5saW5lID8gJ2Nsci1jb250cm9sLWlubGluZScgOiAnJyk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJIb3N0V3JhcHBpbmdNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBpbmcubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJDaGVja2JveCB9IGZyb20gJy4vY2hlY2tib3gnO1xuaW1wb3J0IHsgQ2xyQ2hlY2tib3hDb250YWluZXIgfSBmcm9tICcuL2NoZWNrYm94LWNvbnRhaW5lcic7XG5pbXBvcnQgeyBDbHJDaGVja2JveFdyYXBwZXIgfSBmcm9tICcuL2NoZWNrYm94LXdyYXBwZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xySG9zdFdyYXBwaW5nTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2xyQ2hlY2tib3gsIENsckNoZWNrYm94Q29udGFpbmVyLCBDbHJDaGVja2JveFdyYXBwZXJdLFxuICBleHBvcnRzOiBbQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsckNoZWNrYm94LCBDbHJDaGVja2JveENvbnRhaW5lciwgQ2xyQ2hlY2tib3hXcmFwcGVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyQ2hlY2tib3hXcmFwcGVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmxldCBhY3RpdmVDb3VudGVyID0gMDtcblxuZXhwb3J0IGNvbnN0IElGX0FDVElWRV9JRCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxudW1iZXI+KCdJRl9BQ1RJVkVfSUQnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuRmFjdG9yeSgpIHtcbiAgcmV0dXJuICsrYWN0aXZlQ291bnRlcjtcbn1cblxuZXhwb3J0IGNvbnN0IElGX0FDVElWRV9JRF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogSUZfQUNUSVZFX0lELFxuICB1c2VGYWN0b3J5OiB0b2tlbkZhY3RvcnksXG59O1xuXG5ASW5qZWN0YWJsZSgpXG5cbi8qKioqKioqKipcbiAqIEBjbGFzcyBJZkFjdGl2ZVNlcnZpY2VcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuIGluamVjdGFibGUgc2VydmljZSB1c2VkIGJ5IElmQWN0aXZlIHN0cnVjdHVyYWwgZGlyZWN0aXZlcyBhbmQgdGhlIGNvbXBvbmVudHMgdGhhdCBpbXBsZW1lbnQgSWZBY3RpdmUgaW4gdGhlaXJcbiAqIHRlbXBsYXRlcy4gSXQgaG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBwcm92aWRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgYm90aCB0aGUgZGlyZWN0aXZlIGFuZCB0aGVcbiAqIGltcGxlbWVudGluZyBjb21wb25lbnQgY2FuIHN1YnNjcmliZSB0byBpbiBvcmRlciB0byB0YWtlIGFjdGlvbiBvbiBjdXJyZW50IHZhbHVlIGNoYW5nZXMuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgSWZBY3RpdmVTZXJ2aWNlIHtcbiAgLyoqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBfY3VycmVudENoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBSWEpTIFN1YmplY3QgdGhhdCB1cGRhdGVzIGFuZCBwcm92aWRlcyBzdWJzY3JpcHRpb25zIHRvIGZvciB0aGUgY3VycmVudCBjdXJyZW50IHN0YXRlIG9mIGEgY29tcG9uZW50IHRlbXBsYXRlXG4gICAqIGltcGxlbXRpbmcgdGhlIElmQWN0aXZlIHN0cnVjdHVyYWwgZGlyZWN0aXZlLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudENoYW5nZTogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuXG4gIC8qKioqKioqKipcbiAgICogQHByb3BlcnR5IF9jdXJyZW50XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHByb3BlcnR5IGhvbGRpbmcgdGhlIGN1cnJlbnQgdmFsdWUgZm9yIGN1cnJlbnQvY2xvc2VkIHN0YXRlIG9mIGFuIElmQWN0aXZlIHN0cnVjdHVyYWwgZGlyZWN0aXZlLlxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudDogbnVtYmVyO1xuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBmb3IgdGhlIF9jdXJyZW50IFN1YmplY3QuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgc2V0dGVyIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBfY3VycmVudCBmb3IgdGhpcyBpbnN0YW5jZSBvZiBJZkFjdGl2ZSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICogQW5kLCBicm9hZGNhc3RzIHRoZSBuZXcgdmFsdWUgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgY3VycmVudCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG4gICAgICB0aGlzLl9jdXJyZW50Q2hhbmdlLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzIElmQWN0aXZlIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgVGVtcGxhdGVSZWYsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElGX0FDVElWRV9JRCwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi9pZi1hY3RpdmUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkFjdGl2ZV0nIH0pXG5cbi8qKioqKioqKioqXG4gKlxuICogQGNsYXNzIENscklmQWN0aXZlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHN0cnVjdHVyYWwgZGlyZWN0aXZlIHRoYXQgY29udHJvbHMgd2hldGhlciBvciBub3QgdGhlIGFzc29jaWF0ZWQgVGVtcGxhdGVSZWYgaXMgaW5zdGFudGlhdGVkIG9yIG5vdC5cbiAqIEl0IG1ha2VzIHVzZSBvZiBhIENvbXBvbmVudCBpbnN0YW5jZSBsZXZlbCBzZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UgdG8gbWFpbnRhaW4gc3RhdGUgYmV0d2VlbiBpdHNlbGYgYW5kXG4gKiB0aGUgY29tcG9uZW50IHVzaW5nIGl0IGluIHRoZSBjb21wb25lbnQgdGVtcGxhdGUuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xySWZBY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIHdhc0FjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgQEluamVjdChJRl9BQ1RJVkVfSUQpIHByaXZhdGUgaWQ6IG51bWJlcixcbiAgICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIHRoaXMuY2hlY2tBbmRVcGRhdGVWaWV3KGlmQWN0aXZlU2VydmljZS5jdXJyZW50KTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudENoYW5nZS5zdWJzY3JpYmUobmV3Q3VycmVudElkID0+IHtcbiAgICAgIHRoaXMuY2hlY2tBbmRVcGRhdGVWaWV3KG5ld0N1cnJlbnRJZCk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrQW5kVXBkYXRlVmlldyhjdXJyZW50SWQ6IG51bWJlcikge1xuICAgIGNvbnN0IGlzTm93QWN0aXZlID0gY3VycmVudElkID09PSB0aGlzLmlkO1xuICAgIC8vIG9ubHkgZW1pdCBpZiB0aGUgbmV3IGFjdGl2ZSBzdGF0ZSBpcyBjaGFuZ2VkIHNpbmNlIGxhc3QgdGltZS5cbiAgICBpZiAoaXNOb3dBY3RpdmUgIT09IHRoaXMud2FzQWN0aXZlKSB7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXcoaXNOb3dBY3RpdmUpO1xuICAgICAgdGhpcy5hY3RpdmVDaGFuZ2UuZW1pdChpc05vd0FjdGl2ZSk7XG4gICAgICB0aGlzLndhc0FjdGl2ZSA9IGlzTm93QWN0aXZlO1xuICAgIH1cbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgc2V0dGVyIHRoYXQgdXBkYXRlcyBJZkFjdGl2ZVNlcnZpY2UuYWN0aXZlIHdpdGggdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgQElucHV0KCdjbHJJZkFjdGl2ZScpXG4gIHB1YmxpYyBzZXQgYWN0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmlmQWN0aXZlU2VydmljZS5jdXJyZW50ID0gdGhpcy5pZDtcbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKiBAcHJvcGVydHkgYWN0aXZlQ2hhbmdlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBldmVudCBlbWl0dGVyIHRoYXQgZW1pdHMgd2hlbiB0aGUgYWN0aXZlIHByb3BlcnR5IGlzIHNldCB0byBhbGxvdyBmb3IgMndheSBiaW5kaW5nIHdoZW4gdGhlIGRpcmVjdGl2ZSBpc1xuICAgKiB1c2VkIHdpdGggZGUtc3RydWN0dXJlZCAvIGRlLXN1Z2FyZWQgc3ludGF4LlxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xySWZBY3RpdmVDaGFuZ2UnKSBhY3RpdmVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIC8qKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IElmQWN0aXZlU2VydmljZS5hY3RpdmUgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxuXG4gIC8qKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBhbnkgdmFsdWUgYW5kIGVpdGhlciBjcmVhdGVkIGFuIGVtYmVkZGVkIHZpZXcgZm9yIHRoZSBhc3NvY2lhdGVkIFZpZXdDb250YWluZXJSZWYgb3IsXG4gICAqIENsZWFycyBhbGwgdmlld3MgZnJvbSB0aGUgVmlld0NvbnRhaW5lclJlZlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVWaWV3KHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy50ZW1wbGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5cbi8qKioqKioqKipcbiAqIEBjbGFzcyBJZk9wZW5TZXJ2aWNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBpbmplY3RhYmxlIHNlcnZpY2UgdXNlZCBieSBJZk9wZW4gc3RydWN0dXJhbCBkaXJlY3RpdmVzIGFuZCB0aGUgY29tcG9uZW50cyB0aGF0IGltcGxlbW50IElmT3BlbiBpbiB0aGVpclxuICogdGVtcGxhdGVzLiBJdCBob2xkcyB0aGUgdmFsdWUgb2YgdGhlIG9wZW4gc3RhdGUgYW5kIHByb3ZpZGVzIGFuIE9ic2VydmFibGUgdGhhdCBib3RoIHRoZSBkaXJlY3RpdmUgYW5kIHRoZVxuICogaW1wbGVtZW50aW5nIGNvbXBvbmVudCBjYW4gc3Vic2NyaWJlIHRvIGluIG9yZGVyIHRvIHRha2UgYWN0aW9uIG9uIG9wZW4gdmFsdWUgY2hhbmdlcy5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBJZk9wZW5TZXJ2aWNlIHtcbiAgLyoqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBfb3BlbkNoYW5nZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBSWEpTIFN1YmplY3QgdGhhdCB1cGRhdGVzIGFuZCBwcm92aWRlcyBzdWJzY3JpcHRpb25zIHRvIGZvciB0aGUgY3VycmVudCBvcGVuIHN0YXRlIG9mIGEgY29tcG9uZW50IHRlbXBsYXRlXG4gICAqIGltcGxlbXRpbmcgdGhlIElmT3BlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICovXG4gIHByaXZhdGUgX29wZW5DaGFuZ2U6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKioqKioqKipcbiAgICogQHByb3BlcnR5IF9vcGVuXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHByb3BlcnR5IGhvbGRpbmcgdGhlIGN1cnJlbnQgdmFsdWUgZm9yIG9wZW4vY2xvc2VkIHN0YXRlIG9mIGFuIElmT3BlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX29wZW46IGJvb2xlYW47XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBhbiBvYnNlcnZhYmxlIGZvciB0aGUgX29wZW5lZCBTdWJqZWN0LlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBvcGVuQ2hhbmdlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9vcGVuQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIF9vcGVuIGZvciB0aGlzIGluc3RhbmNlIG9mIElmT3BlbiBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS4gQW5kLFxuICAgKiBicm9hZGNhc3RzIHRoZSBuZXcgdmFsdWUgdG8gYWxsIHN1YnNjcmliZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgb3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodGhpcy5fb3BlbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX29wZW4gPSB2YWx1ZTtcbiAgICAgIHRoaXMuX29wZW5DaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoaXMgSWZPcGVuIGluc3RhbmNlLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBvcGVuKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNvbWV0aW1lcywgd2UgbmVlZCB0byByZW1lbWJlciB0aGUgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHRvZ2dsaW5nIHRvIGF2b2lkIGxvb3BzLlxuICAgKiBUaGlzIGlzIGZvciBpbnN0YW5jZSB0aGUgY2FzZSBvZiBjb21wb25lbnRzIHRoYXQgb3BlbiBvbiBhIGNsaWNrLCBidXQgY2xvc2Ugb24gYSBjbGljayBvdXRzaWRlLlxuICAgKi9cbiAgcHVibGljIG9yaWdpbmFsRXZlbnQ6IGFueTtcbiAgcHVibGljIHRvZ2dsZVdpdGhFdmVudChldmVudDogYW55KSB7XG4gICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcbiAgICBkZWxldGUgdGhpcy5vcmlnaW5hbEV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqICBQb3BvdmVycyBtaWdodCBuZWVkIHRvIGlnbm9yZSBjbGljayBldmVudHMgb24gYW4gZWxlbWVudFxuICAgKiAgKGVnOiBwb3BvdmVyIG9wZW5zIG9uIGZvY3VzIG9uIGFuIGlucHV0IGZpZWxkLiBDbGlja3Mgc2hvdWxkIGJlIGlnbm9yZWQgaW4gdGhpcyBjYXNlKVxuICAgKi9cbiAgcHJpdmF0ZSBfaWdub3JlZEVsZW1lbnRDaGFuZ2U6IFN1YmplY3Q8RWxlbWVudFJlZj4gPSBuZXcgU3ViamVjdDxFbGVtZW50UmVmPigpO1xuXG4gIGdldCBpZ25vcmVkRWxlbWVudENoYW5nZSgpOiBPYnNlcnZhYmxlPEVsZW1lbnRSZWY+IHtcbiAgICByZXR1cm4gdGhpcy5faWdub3JlZEVsZW1lbnRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICByZWdpc3Rlcklnbm9yZWRFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcbiAgICB0aGlzLl9pZ25vcmVkRWxlbWVudENoYW5nZS5uZXh0KGVsZW1lbnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuL2lmLW9wZW4uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZk9wZW5dJyB9KVxuXG4vKioqKioqKioqKlxuICpcbiAqIEBjbGFzcyBDbHJJZk9wZW5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RydWN0dXJhbCBkaXJlY3RpdmUgdGhhdCBjb250cm9scyB3aGV0aGVyIG9yIG5vdCB0aGUgYXNzb2NpYXRlZCBUZW1wbGF0ZVJlZiBpcyBpbnN0YW50aWF0ZWQgb3Igbm90LlxuICogSXQgbWFrZXMgdXNlIG9mIGEgQ29tcG9uZW50IGluc3RhbmNlIGxldmVsIHNlcnZpY2U6IElmT3BlblNlcnZpY2UgdG8gbWFpbnRhaW4gc3RhdGUgYmV0d2VlbiBpdHNlbGYgYW5kIHRoZSBjb21wb25lbnRcbiAqIHVzaW5nIGl0IGluIHRoZSBjb21wb25lbnQgdGVtcGxhdGUuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xySWZPcGVuIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHNldHRlciB0aGF0IHVwZGF0ZXMgSWZPcGVuU2VydmljZS5vcGVuIHdpdGggdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgQElucHV0KCdjbHJJZk9wZW4nKVxuICBwdWJsaWMgc2V0IG9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IG9wZW5DaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBlbWl0cyB3aGVuIHRoZSBvcGVuIHByb3BlcnR5IGlzIHNldCB0byBhbGxvdyBmb3IgMndheSBiaW5kaW5nIHdoZW4gdGhlIGRpcmVjdGl2ZSBpc1xuICAgKiB1c2VkIHdpdGggZGUtc3RydWN0dXJlZCAvIGRlLXN1Z2FyZWQgc3ludGF4LlxuICAgKi9cbiAgQE91dHB1dCgnY2xySWZPcGVuQ2hhbmdlJykgb3BlbkNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgLyoqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIGdldHRlciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgSWZPcGVuU2VydmljZS5vcGVuIHZhbHVlLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBvcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbjtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSxcbiAgICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZVZpZXcoY2hhbmdlKTtcbiAgICAgIHRoaXMub3BlbkNoYW5nZS5lbWl0KGNoYW5nZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGdW5jdGlvbiB0aGF0IHRha2VzIGEgYm9vbGVhbiB2YWx1ZSBhbmQgZWl0aGVyIGNyZWF0ZWQgYW4gZW1iZWRkZWQgdmlldyBmb3IgdGhlIGFzc29jaWF0ZWQgVmlld0NvbnRhaW5lclJlZiBvcixcbiAgICogQ2xlYXJzIGFsbCB2aWV3cyBmcm9tIHRoZSBWaWV3Q29udGFpbmVyUmVmXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgcHVibGljIHVwZGF0ZVZpZXcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJJZkFjdGl2ZSB9IGZyb20gJy4vaWYtYWN0aXZlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJJZk9wZW4gfSBmcm9tICcuL2lmLW9wZW4uZGlyZWN0aXZlJztcblxuZXhwb3J0ICogZnJvbSAnLi9pZi1hY3RpdmUuZGlyZWN0aXZlJztcbmV4cG9ydCAqIGZyb20gJy4vaWYtb3Blbi5kaXJlY3RpdmUnO1xuXG5leHBvcnQgY29uc3QgQ09ORElUSU9OQUxfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xySWZBY3RpdmUsIENscklmT3Blbl07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ09ORElUSU9OQUxfRElSRUNUSVZFUyB9IGZyb20gJy4vaW5kZXgnO1xuXG5ATmdNb2R1bGUoeyBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSwgZGVjbGFyYXRpb25zOiBbQ09ORElUSU9OQUxfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtDT05ESVRJT05BTF9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENsckNvbmRpdGlvbmFsTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c1RyYXBEaXJlY3RpdmUgfSBmcm9tICcuL2ZvY3VzLXRyYXAuZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBGb2N1c1RyYXBUcmFja2VyIHtcbiAgcHJpdmF0ZSBfcHJldmlvdXNGb2N1c1RyYXBzOiBGb2N1c1RyYXBEaXJlY3RpdmVbXSA9IFtdO1xuICBwcml2YXRlIF9jdXJyZW50OiBGb2N1c1RyYXBEaXJlY3RpdmU7XG5cbiAgZ2V0IGN1cnJlbnQoKTogRm9jdXNUcmFwRGlyZWN0aXZlIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuXG4gIHNldCBjdXJyZW50KHZhbHVlOiBGb2N1c1RyYXBEaXJlY3RpdmUpIHtcbiAgICB0aGlzLl9wcmV2aW91c0ZvY3VzVHJhcHMucHVzaCh0aGlzLl9jdXJyZW50KTtcbiAgICB0aGlzLl9jdXJyZW50ID0gdmFsdWU7XG4gIH1cblxuICBnZXQgbmJGb2N1c1RyYXBwZXJzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRm9jdXNUcmFwcy5sZW5ndGg7XG4gIH1cblxuICBhY3RpdmF0ZVByZXZpb3VzVHJhcHBlcigpIHtcbiAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fcHJldmlvdXNGb2N1c1RyYXBzLnBvcCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBET0NVTUVOVCwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdCxcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgUExBVEZPUk1fSUQsXG4gIFJlbmRlcmVyMixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZvY3VzVHJhcFRyYWNrZXIgfSBmcm9tICcuL2ZvY3VzLXRyYXAtdHJhY2tlci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckZvY3VzVHJhcF0nIH0pXG5leHBvcnQgY2xhc3MgRm9jdXNUcmFwRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBwcmV2aW91c0FjdGl2ZUVsZW1lbnQ6IGFueTtcbiAgcHJpdmF0ZSBkb2N1bWVudDogRG9jdW1lbnQ7XG5cbiAgcHJpdmF0ZSB0b3BSZWJvdW5kRWw6IGFueTtcbiAgcHJpdmF0ZSBib3R0b21SZWJvdW5kRWw6IGFueTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgZm9jdXNUcmFwc1RyYWNrZXI6IEZvY3VzVHJhcFRyYWNrZXIsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0XG4gICkge1xuICAgIHRoaXMuZG9jdW1lbnQgPSB0aGlzLmluamVjdG9yLmdldChET0NVTUVOVCk7XG4gICAgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5jdXJyZW50ID0gdGhpcztcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3RhYmluZGV4JywgJzAnKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmZvY3VzaW4nLCBbJyRldmVudCddKVxuICBvbkZvY3VzSW4oZXZlbnQ6IGFueSkge1xuICAgIGNvbnN0IG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuXG4gICAgaWYgKHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIuY3VycmVudCA9PT0gdGhpcyAmJiBldmVudC50YXJnZXQgJiYgIW5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgbmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRm9jdXNhYmxlT2ZmU2NyZWVuRWwoKTogYW55IHtcbiAgICAvLyBOb3QgdXNpbmcgUmVuZGVyZXIyJ3MgY3JlYXRlRWxlbWVudCBtZXRob2QgYmVjYXVzZSB0aGF0IGxlYWRzIHRvIERPTSBsZWFrYWdlLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzI2OTU0XG4gICAgY29uc3Qgb2ZmU2NyZWVuU3BhbiA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKG9mZlNjcmVlblNwYW4sICd0YWJpbmRleCcsICcwJyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhvZmZTY3JlZW5TcGFuLCAnb2Zmc2NyZWVuLWZvY3VzLXJlYm91bmRlcicpO1xuXG4gICAgcmV0dXJuIG9mZlNjcmVlblNwYW47XG4gIH1cblxuICBwcml2YXRlIGFkZFJlYm91bmRFbHMoKSB7XG4gICAgLy8gV2Ugd2lsbCBhZGQgdGhlc2UgZm9jdXMgcmVib3VuZGluZyBlbGVtZW50cyBvbmx5IGluIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgICAvLyAxLiBJdCBzaG91bGQgYmUgcnVubmluZyBpbnNpZGUgYnJvd3NlciBwbGF0Zm9ybSBhcyBpdCBhY2Nlc3NlcyBkb2N1bWVudC5ib2R5IGVsZW1lbnRcbiAgICAvLyAyLiBXZSBzaG91bGQgTk9UIGFkZCB0aGVtIG1vcmUgdGhhbiBvbmNlLiBIZW5jZSwgd2UgYXJlIGNvdW50aW5nIGEgbnVtYmVyIG9mIGZvY3VzIHRyYXBwZXJzXG4gICAgLy8gICAgYW5kIG9ubHkgYWRkIG9uIHRoZSBmaXJzdCBmb2N1cyB0cmFwcGVyLlxuXG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgdGhpcy5mb2N1c1RyYXBzVHJhY2tlci5uYkZvY3VzVHJhcHBlcnMgPT09IDEpIHtcbiAgICAgIHRoaXMudG9wUmVib3VuZEVsID0gdGhpcy5jcmVhdGVGb2N1c2FibGVPZmZTY3JlZW5FbCgpO1xuICAgICAgdGhpcy5ib3R0b21SZWJvdW5kRWwgPSB0aGlzLmNyZWF0ZUZvY3VzYWJsZU9mZlNjcmVlbkVsKCk7XG4gICAgICAvLyBBZGQgcmVib3VuZEJlZm9yZVRyYXBFbCB0byB0aGUgZG9jdW1lbnQgYm9keSBhcyB0aGUgZmlyc3QgY2hpbGRcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0QmVmb3JlKHRoaXMuZG9jdW1lbnQuYm9keSwgdGhpcy50b3BSZWJvdW5kRWwsIHRoaXMuZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcbiAgICAgIC8vIEFkZCByZWJvdW5kQWZ0ZXJUcmFwRWwgdG8gdGhlIGRvY3VtZW50IGJvZHkgYXMgdGhlIGxhc3QgY2hpbGRcbiAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5kb2N1bWVudC5ib2R5LCB0aGlzLmJvdHRvbVJlYm91bmRFbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZW1vdmVSZWJvdW5kRWxzKCkge1xuICAgIGlmIChcbiAgICAgIGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiZcbiAgICAgIHRoaXMuZm9jdXNUcmFwc1RyYWNrZXIubmJGb2N1c1RyYXBwZXJzID09PSAxICYmXG4gICAgICB0aGlzLnRvcFJlYm91bmRFbCAmJlxuICAgICAgdGhpcy5ib3R0b21SZWJvdW5kRWxcbiAgICApIHtcbiAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQodGhpcy5kb2N1bWVudC5ib2R5LCB0aGlzLnRvcFJlYm91bmRFbCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNoaWxkKHRoaXMuZG9jdW1lbnQuYm9keSwgdGhpcy5ib3R0b21SZWJvdW5kRWwpO1xuXG4gICAgICAvLyBUaGVzZSBhcmUgaGVyZSB0byB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgLy8gd2UgY29tcGxldGVseSBkZWxldGUgYWxsIHRyYWNlcyBvZiB0aGUgcmVtb3ZlZCBET00gb2JqZWN0cy5cbiAgICAgIGRlbGV0ZSB0aGlzLnRvcFJlYm91bmRFbDtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvdHRvbVJlYm91bmRFbDtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc2V0UHJldmlvdXNGb2N1cygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgJiYgdGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMpIHtcbiAgICAgIHRoaXMucHJldmlvdXNBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IDxIVE1MRWxlbWVudD50aGlzLmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRSZWJvdW5kRWxzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZVJlYm91bmRFbHMoKTtcbiAgICB0aGlzLnNldFByZXZpb3VzRm9jdXMoKTtcbiAgICB0aGlzLmZvY3VzVHJhcHNUcmFja2VyLmFjdGl2YXRlUHJldmlvdXNUcmFwcGVyKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvY3VzVHJhcERpcmVjdGl2ZSB9IGZyb20gJy4vZm9jdXMtdHJhcC5kaXJlY3RpdmUnO1xuXG5leHBvcnQgY29uc3QgRk9DVVNfVFJBUF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtGb2N1c1RyYXBEaXJlY3RpdmVdO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZPQ1VTX1RSQVBfRElSRUNUSVZFUyB9IGZyb20gJy4vaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbRk9DVVNfVFJBUF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0ZPQ1VTX1RSQVBfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsckZvY3VzVHJhcE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNyBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFVQX0FSUk9XOiBudW1iZXIgPSAzODtcbmV4cG9ydCBjb25zdCBET1dOX0FSUk9XOiBudW1iZXIgPSA0MDtcbmV4cG9ydCBjb25zdCBSSUdIVF9BUlJPVzogbnVtYmVyID0gMzk7XG5leHBvcnQgY29uc3QgTEVGVF9BUlJPVzogbnVtYmVyID0gMzc7XG5leHBvcnQgY29uc3QgRU5URVI6IG51bWJlciA9IDEzO1xuZXhwb3J0IGNvbnN0IFNQQUNFOiBudW1iZXIgPSAzMjtcbmV4cG9ydCBjb25zdCBUQUI6IG51bWJlciA9IDk7XG5leHBvcnQgY29uc3QgRVNDOiBudW1iZXIgPSAyNztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBlbi0wMDEgc2hvcnQgbG9jYWxlIGRhdGUgZm9ybWF0LiBTZXR0aW5nIGFzIGRlZmF1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0xPQ0FMRV9GT1JNQVQ6IHN0cmluZyA9ICdkZC9NTS95JztcblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0ZV9mb3JtYXRfYnlfY291bnRyeVxuZXhwb3J0IGNvbnN0IExJVFRMRV9FTkRJQU5fUkVHRVg6IFJlZ0V4cCA9IC9kKy4rbSsuK3krL2k7XG5leHBvcnQgY29uc3QgTUlERExFX0VORElBTl9SRUdFWDogUmVnRXhwID0gL20rLitkKy4reSsvaTtcbi8vIE5vIG5lZWQgZm9yIEJJR19FTkRJQU5fUkVHRVggYmVjYXVzZSBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc2F0aXNmeSB0aGUgYWJvdmUgMlxuLy8gaXMgYXV0b21hdGljYWxseSBCSUdfRU5ESUFOXG5cbmV4cG9ydCBjb25zdCBERUxJTUlURVJfUkVHRVg6IFJlZ0V4cCA9IC9kK3xtK3x5Ky9pO1xuXG5leHBvcnQgY29uc3QgVVNFUl9JTlBVVF9SRUdFWDogUmVnRXhwID0gL1xcZCsvZztcblxuZXhwb3J0IGNvbnN0IE1PQklMRV9VU0VSQUdFTlRfUkVHRVg6IFJlZ0V4cCA9IC9Nb2JpL2k7XG5cbmV4cG9ydCBjb25zdCBSVExfUkVHRVg6IFJlZ0V4cCA9IC9cXHUyMDBmL2c7XG5cbmV4cG9ydCBjb25zdCBZRUFSOiBzdHJpbmcgPSAnWVlZWSc7XG5leHBvcnQgY29uc3QgTU9OVEg6IHN0cmluZyA9ICdNTSc7XG5leHBvcnQgY29uc3QgREFURTogc3RyaW5nID0gJ0REJztcblxuZXhwb3J0IHR5cGUgRm9ybWF0VHlwZSA9ICdMSVRUTEVfRU5ESUFOJyB8ICdNSURETEVfRU5ESUFOJyB8ICdCSUdfRU5ESUFOJztcblxuZXhwb3J0IHR5cGUgSW5wdXREYXRlRGlzcGxheUZvcm1hdCA9IHtcbiAgcmVhZG9ubHkgbmFtZTogRm9ybWF0VHlwZTtcbiAgcmVhZG9ubHkgZm9ybWF0OiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ107XG59O1xuXG5leHBvcnQgY29uc3QgTElUVExFX0VORElBTjogSW5wdXREYXRlRGlzcGxheUZvcm1hdCA9IHtcbiAgbmFtZTogJ0xJVFRMRV9FTkRJQU4nLFxuICBmb3JtYXQ6IFtEQVRFLCBNT05USCwgWUVBUl0sXG59O1xuXG5leHBvcnQgY29uc3QgTUlERExFX0VORElBTjogSW5wdXREYXRlRGlzcGxheUZvcm1hdCA9IHtcbiAgbmFtZTogJ01JRERMRV9FTkRJQU4nLFxuICBmb3JtYXQ6IFtNT05USCwgREFURSwgWUVBUl0sXG59O1xuXG5leHBvcnQgY29uc3QgQklHX0VORElBTjogSW5wdXREYXRlRGlzcGxheUZvcm1hdCA9IHtcbiAgbmFtZTogJ0JJR19FTkRJQU4nLFxuICBmb3JtYXQ6IFtZRUFSLCBNT05USCwgREFURV0sXG59O1xuXG5leHBvcnQgY29uc3QgTk9fT0ZfREFZU19JTl9BX1dFRUs6IG51bWJlciA9IDc7XG5leHBvcnQgY29uc3QgTk9fT0ZfUk9XU19JTl9DQUxFTkRBUl9WSUVXOiBudW1iZXIgPSA2O1xuZXhwb3J0IGNvbnN0IFRPVEFMX0RBWVNfSU5fREFZU19WSUVXOiBudW1iZXIgPSBOT19PRl9EQVlTX0lOX0FfV0VFSyAqIE5PX09GX1JPV1NfSU5fQ0FMRU5EQVJfVklFVztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgV2Vla0RheSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE51bWJlck9mRGF5c0luVGhlTW9udGgoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogbnVtYmVyIHtcbiAgLy8gSWYgd2UgZ28gdG8gdGhlIG5leHQgbW9udGgsIGJ1dCB1c2UgYSBkYXkgb2YgMCwgaXQgcmV0dXJucyB0aGUgbGFzdCBkYXkgZnJvbSB0aGUgcHJldmlvdXMgbW9udGhcbiAgcmV0dXJuIG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgMCkuZ2V0RGF0ZSgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRheSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgZGF0ZSB3aGVyZSAwIHJlcHJlc2VudHMgU3VuZGF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF5KHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF0ZTogbnVtYmVyKTogV2Vla0RheSB7XG4gIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSkuZ2V0RGF5KCk7XG59XG5cbi8qKlxuICogVGFrZXMgaW4gYSB5ZWFyIGFuZCBpZiBpdCBpcyBhIDIgZGlnaXQgeWVhciwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyA0IGRpZ2l0IHllYXIuXG4gKiBXaW5kb3cgb2YgODAgeWVhcnMgYmVmb3JlIGFuZCAyMCB5ZWFycyBhZnRlciB0aGUgcHJlc2VudCB5ZWFyLlxuICogQ3JlZGl0OiBodHRwczovL2dpdGh1Yi5jb20vZ2xvYmFsaXplanMvZ2xvYmFsaXplL2Jsb2IvZTFiMzFjZDZhNGYxY2ZmNzViMTg1YjY4YjdhMzIyMjBhYWM1MTk2Zi9zcmMvZGF0ZS9wYXJzZS5qc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUb0ZvdXJEaWdpdFllYXIoeWVhcjogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKHllYXIgPiA5OTk5IHx8ICh5ZWFyID4gMTAwICYmIHllYXIgPCA5OTkpIHx8IHllYXIgPCAxMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeWVhciA+IDk5OSkge1xuICAgIHJldHVybiB5ZWFyO1xuICB9XG4gIGNvbnN0IGN1cnJZZWFyOiBudW1iZXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IGNlbnR1cnk6IG51bWJlciA9IE1hdGguZmxvb3IoY3VyclllYXIgLyAxMDApICogMTAwO1xuICBsZXQgcmVzdWx0OiBudW1iZXIgPSB5ZWFyICsgY2VudHVyeTtcbiAgaWYgKHJlc3VsdCA+IGN1cnJZZWFyICsgMjApIHtcbiAgICByZXN1bHQgPSByZXN1bHQgLSAxMDA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRhdGVzQXJlRXF1YWwoZGF0ZTE6IERhdGUsIGRhdGUyOiBEYXRlKSB7XG4gIGlmIChkYXRlMSBpbnN0YW5jZW9mIERhdGUgJiYgZGF0ZTIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGRhdGUxLmdldEZ1bGxZZWFyKCkgPT09IGRhdGUyLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgIGRhdGUxLmdldE1vbnRoKCkgPT09IGRhdGUyLmdldE1vbnRoKCkgJiZcbiAgICAgIGRhdGUxLmdldERhdGUoKSA9PT0gZGF0ZTIuZ2V0RGF0ZSgpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL2RheS5tb2RlbCc7XG5cbmV4cG9ydCBjbGFzcyBEYXlWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgZGF5TW9kZWw6IERheU1vZGVsLFxuICAgIHB1YmxpYyBpc1RvZGF5c0RhdGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICBwdWJsaWMgaXNEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlLFxuICAgIHB1YmxpYyBpc1NlbGVjdGVkOiBib29sZWFuID0gZmFsc2UsXG4gICAgcHVibGljIGlzRm9jdXNhYmxlOiBib29sZWFuID0gZmFsc2VcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0YWIgaW5kZXggYmFzZWQgb24gdGhlIGlzRm9jdXNhYmxlIGZsYWcuXG4gICAqL1xuICBnZXQgdGFiSW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5pc0ZvY3VzYWJsZSA/IDAgOiAtMTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoIH0gZnJvbSAnLi4vdXRpbHMvZGF0ZS11dGlscyc7XG5cbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi9kYXkubW9kZWwnO1xuXG5leHBvcnQgY2xhc3MgQ2FsZW5kYXJNb2RlbCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB5ZWFyOiBudW1iZXIsIHB1YmxpYyByZWFkb25seSBtb250aDogbnVtYmVyKSB7XG4gICAgdGhpcy5pbml0aWFsaXplRGF5c0luQ2FsZW5kYXIoKTtcbiAgfVxuXG4gIGRheXM6IERheU1vZGVsW107XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyB0aGUgZGF5cyBhcnJheSB3aXRoIHRoZSBEYXlNb2RlbHMgaW4gdGhlIGN1cnJlbnQgQ2FsZW5kYXIuXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVEYXlzSW5DYWxlbmRhcigpOiB2b2lkIHtcbiAgICBjb25zdCBub09mRGF5c0luQ2FsZW5kYXI6IG51bWJlciA9IGdldE51bWJlck9mRGF5c0luVGhlTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgICB0aGlzLmRheXMgPSBBcnJheShub09mRGF5c0luQ2FsZW5kYXIpXG4gICAgICAuZmlsbChudWxsKVxuICAgICAgLm1hcCgoZGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXlNb2RlbCh0aGlzLnllYXIsIHRoaXMubW9udGgsIGluZGV4ICsgMSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGNhbGVuZGFyIHBhc3NlZCBpcyBlcXVhbCB0byB0aGUgY3VycmVudCBjYWxlbmRhci5cbiAgICovXG4gIGlzRXF1YWwoY2FsZW5kYXI6IENhbGVuZGFyTW9kZWwpIHtcbiAgICBpZiAoY2FsZW5kYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnllYXIgPT09IGNhbGVuZGFyLnllYXIgJiYgdGhpcy5tb250aCA9PT0gY2FsZW5kYXIubW9udGg7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBEYXlNb2RlbCBpcyBpbiB0aGUgQ2FsZW5kYXJcbiAgICovXG4gIGlzRGF5SW5DYWxlbmRhcihkYXk6IERheU1vZGVsKTogYm9vbGVhbiB7XG4gICAgaWYgKGRheSkge1xuICAgICAgcmV0dXJuIHRoaXMueWVhciA9PT0gZGF5LnllYXIgJiYgdGhpcy5tb250aCA9PT0gZGF5Lm1vbnRoO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBDYWxlbmRhck1vZGVsIG9mIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICovXG4gIHByZXZpb3VzTW9udGgoKTogQ2FsZW5kYXJNb2RlbCB7XG4gICAgaWYgKHRoaXMubW9udGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnllYXIgLSAxLCAxMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnllYXIsIHRoaXMubW9udGggLSAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBDYWxlbmRhck1vZGVsIG9mIHRoZSBuZXh0IG1vbnRoLlxuICAgKi9cbiAgbmV4dE1vbnRoKCk6IENhbGVuZGFyTW9kZWwge1xuICAgIGlmICh0aGlzLm1vbnRoID09PSAxMSkge1xuICAgICAgcmV0dXJuIG5ldyBDYWxlbmRhck1vZGVsKHRoaXMueWVhciArIDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IENhbGVuZGFyTW9kZWwodGhpcy55ZWFyLCB0aGlzLm1vbnRoICsgMSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENhbGVuZGFyTW9kZWwgfSBmcm9tICcuL2NhbGVuZGFyLm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIERheU1vZGVsIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHllYXI6IG51bWJlciwgcHVibGljIHJlYWRvbmx5IG1vbnRoOiBudW1iZXIsIHB1YmxpYyByZWFkb25seSBkYXRlOiBudW1iZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIENhbGVuZGFyIGZvciB0aGUgY3VycmVudCBEYXlNb2RlbC5cbiAgICovXG4gIGdldCBjYWxlbmRhcigpOiBDYWxlbmRhck1vZGVsIHtcbiAgICByZXR1cm4gbmV3IENhbGVuZGFyTW9kZWwodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHBhc3NlZCBDYWxlbmRhckRhdGUgaXMgZXF1YWwgdG8gaXRzZWxmLlxuICAgKi9cbiAgaXNFcXVhbChkYXk6IERheU1vZGVsKSB7XG4gICAgaWYgKGRheSkge1xuICAgICAgcmV0dXJuIHRoaXMueWVhciA9PT0gZGF5LnllYXIgJiYgdGhpcy5tb250aCA9PT0gZGF5Lm1vbnRoICYmIHRoaXMuZGF0ZSA9PT0gZGF5LmRhdGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgQ2FsZW5kYXJEYXRlIGludG8gdGhlIEphdmFzY3JpcHQgRGF0ZSBvYmplY3QuXG4gICAqL1xuICB0b0RhdGUoKTogRGF0ZSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IERheU1vZGVsIHdoaWNoIGlzIGluY3JlbWVudGVkIGJhc2VkIG9uIHRoZSB2YWx1ZSBwYXNzZWQuXG4gICAqL1xuICBpbmNyZW1lbnRCeSh2YWx1ZTogbnVtYmVyKTogRGF5TW9kZWwge1xuICAgIC8vIENyZWF0aW5nIG5ldyBKYXZhc2NyaXB0IERhdGUgb2JqZWN0IHRvIGluY3JlbWVudCBiZWNhdXNlXG4gICAgLy8gaXQgd2lsbCBhdXRvbWF0aWNhbGx5IHRha2UgY2FyZSBvZiBzd2l0Y2hpbmcgdG8gbmV4dCBvciBwcmV2aW91c1xuICAgIC8vIG1vbnRocyAmIHllYXJzIHdpdGhvdXQgd2UgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGl0LlxuICAgIGNvbnN0IGRhdGU6IERhdGUgPSBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF0ZSArIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IERheU1vZGVsKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBjdXJyZW50IGRheSBtb2RlbC5cbiAgICovXG4gIGNsb25lKCk6IERheU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IERheU1vZGVsKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXRlKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBOT19PRl9EQVlTX0lOX0FfV0VFSywgTk9fT0ZfUk9XU19JTl9DQUxFTkRBUl9WSUVXLCBUT1RBTF9EQVlTX0lOX0RBWVNfVklFVyB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREYXkgfSBmcm9tICcuLi91dGlscy9kYXRlLXV0aWxzJztcblxuaW1wb3J0IHsgQ2FsZW5kYXJNb2RlbCB9IGZyb20gJy4vY2FsZW5kYXIubW9kZWwnO1xuaW1wb3J0IHsgRGF5Vmlld01vZGVsIH0gZnJvbSAnLi9kYXktdmlldy5tb2RlbCc7XG5pbXBvcnQgeyBEYXlNb2RlbCB9IGZyb20gJy4vZGF5Lm1vZGVsJztcblxuZXhwb3J0IGNsYXNzIENhbGVuZGFyVmlld01vZGVsIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNhbGVuZGFyOiBDYWxlbmRhck1vZGVsLFxuICAgIHByaXZhdGUgc2VsZWN0ZWREYXk6IERheU1vZGVsLFxuICAgIHByaXZhdGUgZm9jdXNhYmxlRGF5OiBEYXlNb2RlbCxcbiAgICBwcml2YXRlIHRvZGF5OiBEYXlNb2RlbCxcbiAgICBwdWJsaWMgZmlyc3REYXlPZldlZWs6IG51bWJlclxuICApIHtcbiAgICB0aGlzLmluaXRpYWxpemVDYWxlbmRhclZpZXcoKTtcbiAgfVxuXG4gIHByaXZhdGUgY3Vyck1vbnRoRGF5Vmlld3M6IERheVZpZXdNb2RlbFtdID0gW107XG5cbiAgcHJpdmF0ZSBfY2FsZW5kYXJWaWV3OiBEYXlWaWV3TW9kZWxbXVtdO1xuXG4gIC8qKlxuICAgKiBEYXlWaWV3TW9kZWwgbWF0cml4LiBTaXplIDZ4N1xuICAgKi9cbiAgZ2V0IGNhbGVuZGFyVmlldygpOiBEYXlWaWV3TW9kZWxbXVtdIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXJWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIDZ4NyBtYXRyaXggb2YgRGF5Vmlld01vZGVsIGJhc2VkIG9uIHRoZSBDYWxlbmRhci5cbiAgICogVGhlIDZ4NyBtYXRyaXggaXMgc3RydWN0dXJlZCBhY2NvcmRpbmcgdG8gdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICogNiByb3dzIHRvIGFjY29tbW9kYXRlIG1vbnRocyB3aGljaCBtaWdodCBoYXZlIGRhdGVzIHNwYW5uaW5nIG92ZXIgNiB3ZWVrcy5cbiAgICogNyBjb2x1bW5zIGJlY2F1c2UgdGhlcmUgYXJlIDcgZGF5cyBpbiBhIHdlZWsgOlAgOkRcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUNhbGVuZGFyVmlldygpOiB2b2lkIHtcbiAgICAvLyBHZW5lcmF0ZSBwcmV2IGFuZCBuZXh0IG1vbnRoIGNhbGVuZGFyIG1vZGVscy5cbiAgICBjb25zdCBwcmV2TW9udGhDYWxlbmRhcjogQ2FsZW5kYXJNb2RlbCA9IHRoaXMuY2FsZW5kYXIucHJldmlvdXNNb250aCgpO1xuICAgIGNvbnN0IG5leHRNb250aENhbGVuZGFyOiBDYWxlbmRhck1vZGVsID0gdGhpcy5jYWxlbmRhci5uZXh0TW9udGgoKTtcblxuICAgIC8vIEdldCBubyBvZiBkYXlzIGZyb20gcHJldiBhbmQgbmV4dCBtb250aHMuXG4gICAgY29uc3QgZGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXc6IG51bWJlciA9IHRoaXMubnVtRGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcoXG4gICAgICB0aGlzLmNhbGVuZGFyLnllYXIsXG4gICAgICB0aGlzLmNhbGVuZGFyLm1vbnRoXG4gICAgKTtcbiAgICBjb25zdCBkYXlzRnJvbU5leHRNb250aEluQ2FsVmlldzogbnVtYmVyID1cbiAgICAgIFRPVEFMX0RBWVNfSU5fREFZU19WSUVXIC0gKHRoaXMuY2FsZW5kYXIuZGF5cy5sZW5ndGggKyBkYXlzRnJvbVByZXZNb250aEluQ2FsVmlldyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBwcmV2LCBjdXJyIGFuZCBuZXh0IGRheSB2aWV3IG1vZGVsc1xuICAgIGxldCBwcmV2TW9udGhEYXlWaWV3czogRGF5Vmlld01vZGVsW10gPSBbXTtcbiAgICBsZXQgbmV4dE1vbnRoRGF5Vmlld3M6IERheVZpZXdNb2RlbFtdID0gW107XG5cbiAgICBpZiAoZGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcgPiAwKSB7XG4gICAgICBwcmV2TW9udGhEYXlWaWV3cyA9IHRoaXMuZ2VuZXJhdGVEYXlWaWV3TW9kZWxzKFxuICAgICAgICBwcmV2TW9udGhDYWxlbmRhci5kYXlzLnNsaWNlKC0xICogZGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcpLFxuICAgICAgICB0cnVlLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJNb250aERheVZpZXdzID0gdGhpcy5nZW5lcmF0ZURheVZpZXdNb2RlbHModGhpcy5jYWxlbmRhci5kYXlzLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICBpZiAoZGF5c0Zyb21OZXh0TW9udGhJbkNhbFZpZXcgPiAwKSB7XG4gICAgICBuZXh0TW9udGhEYXlWaWV3cyA9IHRoaXMuZ2VuZXJhdGVEYXlWaWV3TW9kZWxzKFxuICAgICAgICBuZXh0TW9udGhDYWxlbmRhci5kYXlzLnNsaWNlKDAsIGRheXNGcm9tTmV4dE1vbnRoSW5DYWxWaWV3KSxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgY2FsZW5kYXIgdmlldyBhbmQgaW5pdGlhbGl6ZSBmbGFnc1xuICAgIHRoaXMuX2NhbGVuZGFyVmlldyA9IHRoaXMuZ2VuZXJhdGVDYWxlbmRhclZpZXcocHJldk1vbnRoRGF5Vmlld3MsIHRoaXMuY3Vyck1vbnRoRGF5Vmlld3MsIG5leHRNb250aERheVZpZXdzKTtcbiAgICB0aGlzLmluaXRpYWxpemVTZWxlY3RlZERheSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUZvY3VzYWJsZURheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIERheVZpZXdNb2RlbCBhcnJheSBiYXNlZCBvbiB0aGUgRGF5TW9kZWwgcGFzc2VkXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlRGF5Vmlld01vZGVscyhkYXlzOiBEYXlNb2RlbFtdLCBpc0Rpc2FibGVkOiBib29sZWFuLCBpc0N1cnJlbnRDYWxlbmRhcjogYm9vbGVhbik6IERheVZpZXdNb2RlbFtdIHtcbiAgICBjb25zdCBkYXlWaWV3czogRGF5Vmlld01vZGVsW10gPSBkYXlzLm1hcChkYXkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBEYXlWaWV3TW9kZWwoZGF5LCBmYWxzZSwgaXNEaXNhYmxlZCwgZmFsc2UsIGZhbHNlKTtcbiAgICB9KTtcbiAgICBpZiAoaXNDdXJyZW50Q2FsZW5kYXIgJiYgdGhpcy5jYWxlbmRhci5pc0RheUluQ2FsZW5kYXIodGhpcy50b2RheSkpIHtcbiAgICAgIGRheVZpZXdzW3RoaXMudG9kYXkuZGF0ZSAtIDFdLmlzVG9kYXlzRGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkYXlWaWV3cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIGN1cnJlbnQgbW9udGggdG8gZmlndXJlIG91dCBob3cgbWFueSBkYXRlcyBvZiBwcmV2aW91cyBtb250aFxuICAgKiBhcmUgbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBDYWxlbmRhciBWaWV3IGJhc2VkIG9uIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAqIGVnOiBBc3N1bWluZyBsb2NhbGUgZW4tVVMsIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMgU3VuZGF5LFxuICAgKiBpZiBmaXJzdCBkYXkgb2YgdGhlIGN1cnJlbnQgbW9udGggbGFuZHMgb24gV2VkbmVzZGF5LCB0aGVuXG4gICAqICh0aGlzLmdldERheSBmdW5jdGlvbiB3b3VsZCByZXR1cm4gMyBzaW5jZVxuICAgKiBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgaXMgMCksIHdlIG5lZWQgdGhlIDMgZGF5cyBmcm9tIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICovXG4gIHByaXZhdGUgbnVtRGF5c0Zyb21QcmV2TW9udGhJbkNhbFZpZXcoY3VycmVudFllYXI6IG51bWJlciwgY3VycmVudE1vbnRoOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGNvbnN0IGZpcnN0RGF5T2ZDdXJyTW9udGg6IG51bWJlciA9IGdldERheShjdXJyZW50WWVhciwgY3VycmVudE1vbnRoLCAxKTtcblxuICAgIGlmIChmaXJzdERheU9mQ3Vyck1vbnRoID49IHRoaXMuZmlyc3REYXlPZldlZWspIHtcbiAgICAgIHJldHVybiBmaXJzdERheU9mQ3Vyck1vbnRoIC0gdGhpcy5maXJzdERheU9mV2VlaztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE5PX09GX0RBWVNfSU5fQV9XRUVLICsgZmlyc3REYXlPZkN1cnJNb250aCAtIHRoaXMuZmlyc3REYXlPZldlZWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgRGF5IHBhc3NlZCBpcyBpbiB0aGUgQ2FsZW5kYXJWaWV3LlxuICAgKi9cbiAgcHJpdmF0ZSBpc0RheUluQ2FsZW5kYXJWaWV3KGRheTogRGF5TW9kZWwpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuY2FsZW5kYXIuaXNEYXlJbkNhbGVuZGFyKGRheSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVXNpbmcgdGhlIERheVZpZXdNb2RlbHMgZnJvbSB0aGUgcHJldmlvdXMsIGN1cnJlbnQgYW5kIG5leHQgbW9udGgsIHRoaXMgZnVuY3Rpb25cbiAgICogZ2VuZXJhdGVzIHRoZSBDYWxlbmRhclZpZXcuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlQ2FsZW5kYXJWaWV3KHByZXY6IERheVZpZXdNb2RlbFtdLCBjdXJyOiBEYXlWaWV3TW9kZWxbXSwgbmV4dDogRGF5Vmlld01vZGVsW10pOiBEYXlWaWV3TW9kZWxbXVtdIHtcbiAgICBjb25zdCBjb21iaW5hdGlvbkFycjogRGF5Vmlld01vZGVsW10gPSBbLi4ucHJldiwgLi4uY3VyciwgLi4ubmV4dF07XG5cbiAgICBjb25zdCBjYWxlbmRhclZpZXc6IERheVZpZXdNb2RlbFtdW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5PX09GX1JPV1NfSU5fQ0FMRU5EQVJfVklFVzsgaSsrKSB7XG4gICAgICBjYWxlbmRhclZpZXdbaV0gPSBjb21iaW5hdGlvbkFyci5zbGljZShpICogTk9fT0ZfREFZU19JTl9BX1dFRUssIChpICsgMSkgKiBOT19PRl9EQVlTX0lOX0FfV0VFSyk7XG4gICAgfVxuICAgIHJldHVybiBjYWxlbmRhclZpZXc7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgc2VsZWN0ZWQgZGF5IGlmIHRoZSBkYXkgaXMgaW4gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplU2VsZWN0ZWREYXkoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWREYXkgJiYgdGhpcy5pc0RheUluQ2FsZW5kYXJWaWV3KHRoaXMuc2VsZWN0ZWREYXkpKSB7XG4gICAgICB0aGlzLmN1cnJNb250aERheVZpZXdzW3RoaXMuc2VsZWN0ZWREYXkuZGF0ZSAtIDFdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgZm9jdXNhYmxlIGRheSBpZiB0aGUgZGF5IGlzIGluIHRoZSBjYWxlbmRhci4gSWYgZm9jdXNhYmxlIGRheSBpcyBub3Qgc2V0LCB0aGVuXG4gICAqIHdlIGNoZWNrIGZvciB0aGUgc2VsZWN0ZWQgZGF5LiBJZiBzZWxlY3RlZCBkYXkgaXMgbm90IHNldCB0aGVuIGNoZWNrIGlmIHRvZGF5IGlzIGluIHRoZSBjdXJyZW50XG4gICAqIGNhbGVuZGFyLiBJZiBub3QgdGhlbiBqdXN0IHNldCB0aGUgMTV0aCBvZiB0aGUgY3VycmVudCBjYWxlbmRhciBtb250aC5cbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUZvY3VzYWJsZURheSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5mb2N1c2FibGVEYXkgJiYgdGhpcy5pc0RheUluQ2FsZW5kYXJWaWV3KHRoaXMuZm9jdXNhYmxlRGF5KSkge1xuICAgICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMuZm9jdXNhYmxlRGF5LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWREYXkgJiYgdGhpcy5pc0RheUluQ2FsZW5kYXJWaWV3KHRoaXMuc2VsZWN0ZWREYXkpKSB7XG4gICAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcodGhpcy5zZWxlY3RlZERheSwgdHJ1ZSk7XG4gICAgICB0aGlzLmZvY3VzYWJsZURheSA9IHRoaXMuc2VsZWN0ZWREYXkuY2xvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNEYXlJbkNhbGVuZGFyVmlldyh0aGlzLnRvZGF5KSkge1xuICAgICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMudG9kYXksIHRydWUpO1xuICAgICAgdGhpcy5mb2N1c2FibGVEYXkgPSB0aGlzLnRvZGF5LmNsb25lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9jdXNhYmxlRGF5ID0gbmV3IERheU1vZGVsKHRoaXMuY2FsZW5kYXIueWVhciwgdGhpcy5jYWxlbmRhci5tb250aCwgMTUpO1xuICAgICAgdGhpcy5zZXRGb2N1c2FibGVGbGFnKHRoaXMuZm9jdXNhYmxlRGF5LCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldEZvY3VzYWJsZUZsYWcoZGF5OiBEYXlNb2RlbCwgZmxhZzogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmIChkYXkpIHtcbiAgICAgIHRoaXMuY3Vyck1vbnRoRGF5Vmlld3NbZGF5LmRhdGUgLSAxXS5pc0ZvY3VzYWJsZSA9IGZsYWc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZvY3VzYWJsZSBkYXkgaW4gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgdXBkYXRlRm9jdXNhYmxlRGF5KGRheTogRGF5TW9kZWwpOiB2b2lkIHtcbiAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcodGhpcy5mb2N1c2FibGVEYXksIGZhbHNlKTtcbiAgICB0aGlzLnNldEZvY3VzYWJsZUZsYWcoZGF5LCB0cnVlKTtcbiAgICB0aGlzLmZvY3VzYWJsZURheSA9IGRheTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDYWxlbmRhck1vZGVsIH0gZnJvbSAnLi4vbW9kZWwvY2FsZW5kYXIubW9kZWwnO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuLi9tb2RlbC9kYXkubW9kZWwnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBpcyByZXNwb25zaWJsZSBmb3I6XG4gKiAxLiBJbml0aWFsaXppbmcgdGhlIGRpc3BsYXllZCBjYWxlbmRhci5cbiAqIDIuIE1vdmluZyB0aGUgY2FsZW5kYXIgdG8gdGhlIG5leHQsIHByZXZpb3VzIG9yIGN1cnJlbnQgbW9udGhzXG4gKiAzLiBNYW5hZ2luZyB0aGUgZm9jdXNlZCBhbmQgc2VsZWN0ZWQgZGF5IG1vZGVscy5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVOYXZpZ2F0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgX2Rpc3BsYXllZENhbGVuZGFyOiBDYWxlbmRhck1vZGVsO1xuXG4gIGdldCBkaXNwbGF5ZWRDYWxlbmRhcigpOiBDYWxlbmRhck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXI7XG4gIH1cblxuICAvLyBub3QgYSBzZXR0ZXIgYmVjYXVzZSBpIHdhbnQgdGhpcyB0byByZW1haW4gcHJpdmF0ZVxuICBwcml2YXRlIHNldERpc3BsYXllZENhbGVuZGFyKHZhbHVlOiBDYWxlbmRhck1vZGVsKSB7XG4gICAgaWYgKCF0aGlzLl9kaXNwbGF5ZWRDYWxlbmRhci5pc0VxdWFsKHZhbHVlKSkge1xuICAgICAgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyQ2hhbmdlLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmFyaWFibGUgdG8gc3RvcmUgdG9kYXkncyBkYXRlLlxuICAgKi9cbiAgcHJpdmF0ZSBfdG9kYXlzRnVsbERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICBwcml2YXRlIF90b2RheTogRGF5TW9kZWw7XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplVG9kYXlzRGF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl90b2RheXNGdWxsRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5fdG9kYXkgPSBuZXcgRGF5TW9kZWwoXG4gICAgICB0aGlzLl90b2RheXNGdWxsRGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgdGhpcy5fdG9kYXlzRnVsbERhdGUuZ2V0TW9udGgoKSxcbiAgICAgIHRoaXMuX3RvZGF5c0Z1bGxEYXRlLmdldERhdGUoKVxuICAgICk7XG4gIH1cblxuICBnZXQgdG9kYXkoKTogRGF5TW9kZWwge1xuICAgIHJldHVybiB0aGlzLl90b2RheTtcbiAgfVxuXG4gIHB1YmxpYyBzZWxlY3RlZERheTogRGF5TW9kZWw7XG5cbiAgcHJpdmF0ZSBfc2VsZWN0ZWREYXlDaGFuZ2U6IFN1YmplY3Q8RGF5TW9kZWw+ID0gbmV3IFN1YmplY3Q8RGF5TW9kZWw+KCk7XG5cbiAgZ2V0IHNlbGVjdGVkRGF5Q2hhbmdlKCk6IE9ic2VydmFibGU8RGF5TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWREYXlDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhhdCB0aGUgc2VsZWN0ZWQgZGF5IGhhcyBjaGFuZ2VkIHNvIHRoYXQgdGhlIGRhdGUgY2FuIGJlIGVtaXR0ZWQgdG8gdGhlIHVzZXIuXG4gICAqIE5vdGU6IE9ubHkgdG8gYmUgY2FsbGVkIGZyb20gZGF5LnRzXG4gICAqL1xuICBub3RpZnlTZWxlY3RlZERheUNoYW5nZWQoZGF5TW9kZWw6IERheU1vZGVsKSB7XG4gICAgaWYgKGRheU1vZGVsLmlzRXF1YWwodGhpcy5zZWxlY3RlZERheSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZERheSA9IGRheU1vZGVsO1xuICAgIHRoaXMuX3NlbGVjdGVkRGF5Q2hhbmdlLm5leHQoZGF5TW9kZWwpO1xuICB9XG5cbiAgcHVibGljIGZvY3VzZWREYXk6IERheU1vZGVsO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2FsZW5kYXIgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRheS5cbiAgICovXG4gIGluaXRpYWxpemVDYWxlbmRhcigpOiB2b2lkIHtcbiAgICB0aGlzLmZvY3VzZWREYXkgPSBudWxsOyAvLyBDYW4gYmUgcmVtb3ZlZCBsYXRlciBvbiB0aGUgc3RvcmUgZm9jdXNcbiAgICB0aGlzLmluaXRpYWxpemVUb2RheXNEYXRlKCk7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWREYXkpIHtcbiAgICAgIHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyID0gbmV3IENhbGVuZGFyTW9kZWwodGhpcy5zZWxlY3RlZERheS55ZWFyLCB0aGlzLnNlbGVjdGVkRGF5Lm1vbnRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXJNb2RlbCh0aGlzLnRvZGF5LnllYXIsIHRoaXMudG9kYXkubW9udGgpO1xuICAgIH1cbiAgfVxuXG4gIGNoYW5nZU1vbnRoKG1vbnRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKG5ldyBDYWxlbmRhck1vZGVsKHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLnllYXIsIG1vbnRoKSk7XG4gIH1cblxuICBjaGFuZ2VZZWFyKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIobmV3IENhbGVuZGFyTW9kZWwoeWVhciwgdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIubW9udGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0aGUgZGlzcGxheWVkIGNhbGVuZGFyIHRvIHRoZSBuZXh0IG1vbnRoLlxuICAgKi9cbiAgbW92ZVRvTmV4dE1vbnRoKCk6IHZvaWQge1xuICAgIHRoaXMuc2V0RGlzcGxheWVkQ2FsZW5kYXIodGhpcy5fZGlzcGxheWVkQ2FsZW5kYXIubmV4dE1vbnRoKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmVzIHRoZSBkaXNwbGF5ZWQgY2FsZW5kYXIgdG8gdGhlIHByZXZpb3VzIG1vbnRoLlxuICAgKi9cbiAgbW92ZVRvUHJldmlvdXNNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLnByZXZpb3VzTW9udGgoKSk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGRpc3BsYXllZCBjYWxlbmRhciB0byB0aGUgY3VycmVudCBtb250aCBhbmQgeWVhci5cbiAgICovXG4gIG1vdmVUb0N1cnJlbnRNb250aCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuZGlzcGxheWVkQ2FsZW5kYXIuaXNEYXlJbkNhbGVuZGFyKHRoaXMudG9kYXkpKSB7XG4gICAgICB0aGlzLnNldERpc3BsYXllZENhbGVuZGFyKG5ldyBDYWxlbmRhck1vZGVsKHRoaXMudG9kYXkueWVhciwgdGhpcy50b2RheS5tb250aCkpO1xuICAgIH1cbiAgICB0aGlzLl9mb2N1c09uQ2FsZW5kYXJDaGFuZ2UubmV4dCgpO1xuICB9XG5cbiAgaW5jcmVtZW50Rm9jdXNEYXkodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuZm9jdXNlZERheSA9IHRoaXMuZm9jdXNlZERheS5pbmNyZW1lbnRCeSh2YWx1ZSk7XG4gICAgaWYgKHRoaXMuX2Rpc3BsYXllZENhbGVuZGFyLmlzRGF5SW5DYWxlbmRhcih0aGlzLmZvY3VzZWREYXkpKSB7XG4gICAgICB0aGlzLl9mb2N1c2VkRGF5Q2hhbmdlLm5leHQodGhpcy5mb2N1c2VkRGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREaXNwbGF5ZWRDYWxlbmRhcih0aGlzLmZvY3VzZWREYXkuY2FsZW5kYXIpO1xuICAgIH1cbiAgICB0aGlzLl9mb2N1c09uQ2FsZW5kYXJDaGFuZ2UubmV4dCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2U6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG9ic2VydmFibGUgbGV0cyB0aGUgc3Vic2NyaWJlciBrbm93IHRoYXQgdGhlIGRpc3BsYXllZCBjYWxlbmRhciBoYXMgY2hhbmdlZC5cbiAgICovXG4gIGdldCBkaXNwbGF5ZWRDYWxlbmRhckNoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9mb2N1c09uQ2FsZW5kYXJDaGFuZ2U6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBUaGlzIG9ic2VydmFibGUgbGV0cyB0aGUgc3Vic2NyaWJlciBrbm93IHRoYXQgdGhlIGZvY3VzIHNob3VsZCBiZSBhcHBsaWVkIG9uIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIGdldCBmb2N1c09uQ2FsZW5kYXJDaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzT25DYWxlbmRhckNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZvY3VzZWREYXlDaGFuZ2U6IFN1YmplY3Q8RGF5TW9kZWw+ID0gbmV3IFN1YmplY3Q8RGF5TW9kZWw+KCk7XG5cbiAgLyoqXG4gICAqIFRoaXMgb2JzZXJ2YWJsZSBsZXRzIHRoZSBzdWJzY3JpYmVyIGtub3cgdGhhdCB0aGUgZm9jdXNlZCBkYXkgaW4gdGhlIGRpc3BsYXllZCBjYWxlbmRhciBoYXMgY2hhbmdlZC5cbiAgICovXG4gIGdldCBmb2N1c2VkRGF5Q2hhbmdlKCk6IE9ic2VydmFibGU8RGF5TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNlZERheUNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIE5nWm9uZSwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpcnN0LCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIGZvY3VzZXMgdGhlIGRheSB0aGF0IGlzIGZvY3VzYWJsZSBpbiB0aGUgY2FsZW5kYXIuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUsIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0KSB7fVxuXG4gIGZvY3VzQ2VsbChlbFJlZjogRWxlbWVudFJlZik6IHZvaWQge1xuICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICB0aGlzLm5nWm9uZUlzU3RhYmxlSW5Ccm93c2VyKCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgY29uc3QgZm9jdXNFbCA9IGVsUmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignW3RhYmluZGV4PVwiMFwiXScpO1xuICAgICAgICBpZiAoZm9jdXNFbCkge1xuICAgICAgICAgIGZvY3VzRWwuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmb2N1c0lucHV0KGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4gdGhpcy5uZ1pvbmVJc1N0YWJsZUluQnJvd3NlcigpLnN1YnNjcmliZSgoKSA9PiBlbGVtZW50LmZvY3VzKCkpKTtcbiAgfVxuXG4gIGVsZW1lbnRJc0ZvY3VzZWQoZWxlbWVudDogSFRNTElucHV0RWxlbWVudCkge1xuICAgIHJldHVybiBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gIH1cblxuICBwcml2YXRlIG5nWm9uZUlzU3RhYmxlSW5Ccm93c2VyKCkge1xuICAgIC8vIENyZWRpdDogTWF0ZXJpYWw6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9ibG9iL21hc3Rlci9zcmMvbGliL2RhdGVwaWNrZXIvY2FsZW5kYXIudHNcbiAgICByZXR1cm4gdGhpcy5fbmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUoZmlyc3QoKSwgZmlsdGVyKCgpID0+IGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBGb3JtYXRXaWR0aCxcbiAgRm9ybVN0eWxlLFxuICBnZXRMb2NhbGVEYXRlRm9ybWF0LFxuICBnZXRMb2NhbGVEYXlOYW1lcyxcbiAgZ2V0TG9jYWxlRmlyc3REYXlPZldlZWssXG4gIGdldExvY2FsZU1vbnRoTmFtZXMsXG4gIFRyYW5zbGF0aW9uV2lkdGgsXG59IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUsIExPQ0FMRV9JRCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBleHRyYWN0cyB0aGUgQW5ndWxhciBDTERSIGRhdGEgbmVlZGVkIGJ5IHRoZSBkYXRlcGlja2VyLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTG9jYWxlSGVscGVyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoTE9DQUxFX0lEKSBwdWJsaWMgbG9jYWxlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmluaXRpYWxpemVMb2NhbGVEYXRhKCk7XG4gIH1cblxuICBwcml2YXRlIF9maXJzdERheU9mV2VlazogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfbG9jYWxlRGF5c05hcnJvdzogUmVhZG9ubHlBcnJheTxzdHJpbmc+O1xuICBwcml2YXRlIF9sb2NhbGVNb250aHNBYmJyZXZpYXRlZDogUmVhZG9ubHlBcnJheTxzdHJpbmc+O1xuICBwcml2YXRlIF9sb2NhbGVNb250aHNXaWRlOiBSZWFkb25seUFycmF5PHN0cmluZz47XG4gIHByaXZhdGUgX2xvY2FsZURhdGVGb3JtYXQ6IHN0cmluZztcblxuICBnZXQgZmlyc3REYXlPZldlZWsoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3REYXlPZldlZWs7XG4gIH1cblxuICBnZXQgbG9jYWxlRGF5c05hcnJvdygpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVEYXlzTmFycm93O1xuICB9XG5cbiAgZ2V0IGxvY2FsZU1vbnRoc0FiYnJldmlhdGVkKCk6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZU1vbnRoc0FiYnJldmlhdGVkO1xuICB9XG5cbiAgZ2V0IGxvY2FsZU1vbnRoc1dpZGUoKTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlTW9udGhzV2lkZTtcbiAgfVxuXG4gIGdldCBsb2NhbGVEYXRlRm9ybWF0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsZURhdGVGb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsZSBkYXRhLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlRGF0YSgpOiB2b2lkIHtcbiAgICAvLyBPcmRlciBpbiB3aGljaCB0aGVzZSBmdW5jdGlvbnMgaXMgY2FsbGVkIGlzIHZlcnkgaW1wb3J0YW50LlxuICAgIHRoaXMuaW5pdGlhbGl6ZUZpcnN0RGF5T2ZXZWVrKCk7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlRGF0ZUZvcm1hdCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZU1vbnRoc0FiYnJldmlhdGVkKCk7XG4gICAgdGhpcy5pbml0aWFsaXplTG9jYWxlTW9udGhzV2lkZSgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZURheXNOYXJyb3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGRheSBuYW1lcyBpbiB0aGUgVHJhbnNsYXRpb25XaWR0aC5OYXJyb3cgZm9ybWF0IGJhc2VkIG9uIHRoZSBsb2NhbGUuXG4gICAqIGVnOiBbUywgTSwgVC4uLl0gZm9yIGVuLVVTLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplTG9jYWxlRGF5c05hcnJvdygpOiB2b2lkIHtcbiAgICAvLyBHZXQgbG9jYWxlIGRheSBuYW1lcyBzdGFydGluZyB3aXRoIFN1bmRheVxuICAgIGNvbnN0IHRlbXBBcnI6IHN0cmluZ1tdID0gZ2V0TG9jYWxlRGF5TmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5TdGFuZGFsb25lLCBUcmFuc2xhdGlvbldpZHRoLk5hcnJvdykuc2xpY2UoKTtcbiAgICAvLyBHZXQgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgICBjb25zdCBmaXJzdERheU9mV2VlazogbnVtYmVyID0gdGhpcy5maXJzdERheU9mV2VlaztcbiAgICAvLyBSZWFycmFuZ2UgdGhlIHRlbXBBcnIgdG8gc3RhcnQgd2l0aCB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrIGJhc2VkIG9uIHRoZSBsb2NhbGUuXG4gICAgaWYgKGZpcnN0RGF5T2ZXZWVrID4gMCkge1xuICAgICAgY29uc3QgcHJldkRheXM6IHN0cmluZ1tdID0gdGVtcEFyci5zcGxpY2UoMCwgZmlyc3REYXlPZldlZWspO1xuICAgICAgdGVtcEFyci5wdXNoKC4uLnByZXZEYXlzKTtcbiAgICB9XG4gICAgdGhpcy5fbG9jYWxlRGF5c05hcnJvdyA9IHRlbXBBcnI7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGFycmF5IG9mIG1vbnRoIG5hbWVzIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkIGZvcm1hdC5cbiAgICogZS5nLiBgW0phbiwgRmViLCAuLi5dYCBmb3IgZW4tVVNcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZU1vbnRoc0FiYnJldmlhdGVkKCk6IHZvaWQge1xuICAgIHRoaXMuX2xvY2FsZU1vbnRoc0FiYnJldmlhdGVkID0gZ2V0TG9jYWxlTW9udGhOYW1lcyhcbiAgICAgIHRoaXMubG9jYWxlLFxuICAgICAgRm9ybVN0eWxlLlN0YW5kYWxvbmUsXG4gICAgICBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkXG4gICAgKS5zbGljZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBhcnJheSBvZiBtb250aCBuYW1lcyBpbiB0aGUgVHJhbnNsYXRpb25XaWR0aC5XaWRlIGZvcm1hdC5cbiAgICogZS5nLiBgW0phbnVhcnksIEZlYnJ1YXJ5LCAuLi5dYCBmb3IgZW4tVVNcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZU1vbnRoc1dpZGUoKTogdm9pZCB7XG4gICAgdGhpcy5fbG9jYWxlTW9udGhzV2lkZSA9IGdldExvY2FsZU1vbnRoTmFtZXModGhpcy5sb2NhbGUsIEZvcm1TdHlsZS5TdGFuZGFsb25lLCBUcmFuc2xhdGlvbldpZHRoLldpZGUpLnNsaWNlKCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayBiYXNlZCBvbiB0aGUgbG9jYWxlLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplRmlyc3REYXlPZldlZWsoKTogdm9pZCB7XG4gICAgdGhpcy5fZmlyc3REYXlPZldlZWsgPSBnZXRMb2NhbGVGaXJzdERheU9mV2Vlayh0aGlzLmxvY2FsZSk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVMb2NhbGVEYXRlRm9ybWF0KCk6IHZvaWQge1xuICAgIHRoaXMuX2xvY2FsZURhdGVGb3JtYXQgPSBnZXRMb2NhbGVEYXRlRm9ybWF0KHRoaXMubG9jYWxlLCBGb3JtYXRXaWR0aC5TaG9ydCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBET1dOX0FSUk9XLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICcuLi8uLi91dGlscy9rZXktY29kZXMva2V5LWNvZGVzJztcblxuaW1wb3J0IHsgQ2FsZW5kYXJWaWV3TW9kZWwgfSBmcm9tICcuL21vZGVsL2NhbGVuZGFyLXZpZXcubW9kZWwnO1xuaW1wb3J0IHsgQ2FsZW5kYXJNb2RlbCB9IGZyb20gJy4vbW9kZWwvY2FsZW5kYXIubW9kZWwnO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL21vZGVsL2RheS5tb2RlbCc7XG5pbXBvcnQgeyBEYXRlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZXBpY2tlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgTk9fT0ZfREFZU19JTl9BX1dFRUsgfSBmcm9tICcuL3V0aWxzL2NvbnN0YW50cyc7XG5cbkBDb21wb25lbnQoeyBzZWxlY3RvcjogJ2Nsci1jYWxlbmRhcicsIHRlbXBsYXRlVXJsOiAnLi9jYWxlbmRhci5odG1sJyB9KVxuZXhwb3J0IGNsYXNzIENsckNhbGVuZGFyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBfc3ViczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9sb2NhbGVIZWxwZXJTZXJ2aWNlOiBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2U6IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZWxSZWY6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgdGhpcy5nZW5lcmF0ZUNhbGVuZGFyVmlldygpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN1YnNjcmlwdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxlbmRhciBWaWV3IE1vZGVsIHRvIGdlbmVyYXRlIHRoZSBDYWxlbmRhci5cbiAgICovXG4gIGNhbGVuZGFyVmlld01vZGVsOiBDYWxlbmRhclZpZXdNb2RlbDtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbG9jYWxlIGRheXMgYWNjb3JkaW5nIHRvIHRoZSBUcmFuc2xhdGlvbldpZHRoLk5hcnJvdyBmb3JtYXQuXG4gICAqL1xuICBnZXQgbG9jYWxlRGF5c05hcnJvdygpOiBSZWFkb25seUFycmF5PHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZURheXNOYXJyb3c7XG4gIH1cblxuICBnZXQgY2FsZW5kYXIoKTogQ2FsZW5kYXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhcjtcbiAgfVxuXG4gIGdldCBzZWxlY3RlZERheSgpOiBEYXlNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheTtcbiAgfVxuXG4gIGdldCBmb2N1c2VkRGF5KCk6IERheU1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzZWREYXk7XG4gIH1cblxuICBnZXQgdG9kYXkoKTogRGF5TW9kZWwge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UudG9kYXk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBzdWJzY3JpcHRpb25zIHRvOlxuICAgKiAxLiB1cGRhdGUgdGhlIGNhbGVuZGFyIHZpZXcgbW9kZWwuXG4gICAqIDIuIHVwZGF0ZSB0aGUgZm9jdXNhYmxlIGRheSBpbiB0aGUgY2FsZW5kYXIgdmlldyBtb2RlbC5cbiAgICogMy4gZm9jdXMgb24gdGhlIGZvY3VzYWJsZSBkYXkgaW4gdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgcHJpdmF0ZSBpbml0aWFsaXplU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzLnB1c2goXG4gICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZGlzcGxheWVkQ2FsZW5kYXJDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNhbGVuZGFyVmlldygpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fc3Vicy5wdXNoKFxuICAgICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzZWREYXlDaGFuZ2Uuc3Vic2NyaWJlKChmb2N1c2VkRGF5OiBEYXlNb2RlbCkgPT4ge1xuICAgICAgICB0aGlzLmNhbGVuZGFyVmlld01vZGVsLnVwZGF0ZUZvY3VzYWJsZURheShmb2N1c2VkRGF5KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuX3N1YnMucHVzaChcbiAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5mb2N1c09uQ2FsZW5kYXJDaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgQ2FsZW5kYXIgVmlldyBiYXNlZCBvbiB0aGUgY2FsZW5kYXIgcmV0cmlldmVkIGZyb20gdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZS5cbiAgICovXG4gIHByaXZhdGUgZ2VuZXJhdGVDYWxlbmRhclZpZXcoKTogdm9pZCB7XG4gICAgdGhpcy5jYWxlbmRhclZpZXdNb2RlbCA9IG5ldyBDYWxlbmRhclZpZXdNb2RlbChcbiAgICAgIHRoaXMuY2FsZW5kYXIsXG4gICAgICB0aGlzLnNlbGVjdGVkRGF5LFxuICAgICAgdGhpcy5mb2N1c2VkRGF5LFxuICAgICAgdGhpcy50b2RheSxcbiAgICAgIHRoaXMuX2xvY2FsZUhlbHBlclNlcnZpY2UuZmlyc3REYXlPZldlZWtcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGVnYXRlcyBLZXlib2FyZCBhcnJvdyBuYXZpZ2F0aW9uIHRvIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIHRoaXMuZm9jdXNlZERheSkge1xuICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5jcmVtZW50Rm9jdXNEYXkoLTEgKiBOT19PRl9EQVlTX0lOX0FfV0VFSyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5pbmNyZW1lbnRGb2N1c0RheShOT19PRl9EQVlTX0lOX0FfV0VFSyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5pbmNyZW1lbnRGb2N1c0RheSgtMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUklHSFRfQVJST1c6XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5jcmVtZW50Rm9jdXNEYXkoMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7IC8vIE5vIGRlZmF1bHQgY2FzZS4gVFNMaW50IHgtKFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIG9uIHRoZSBmb2N1c2FibGUgZGF5IHdoZW4gdGhlIENhbGVuZGFyIFZpZXcgaXMgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gc3Vic2NyaXB0aW9ucy5cbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZvY3VzU2VydmljZSB7XG4gIHByaXZhdGUgX2ZvY3VzZWQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuICBnZXQgZm9jdXNDaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cbiAgc2V0IGZvY3VzZWQoc3RhdGU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9mb2N1c2VkLm5leHQoc3RhdGUpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVGb3JtQ29udHJvbFNlcnZpY2Uge1xuICBwcml2YXRlIF90b3VjaGVkQ2hhbmdlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBnZXQgdG91Y2hlZENoYW5nZSgpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fdG91Y2hlZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2RpcnR5Q2hhbmdlOiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBnZXQgZGlydHlDaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5Q2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbWFya0FzVG91Y2hlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl90b3VjaGVkQ2hhbmdlLm5leHQoKTtcbiAgfVxuXG4gIG1hcmtBc0RpcnR5KCk6IHZvaWQge1xuICAgIHRoaXMuX2RpcnR5Q2hhbmdlLm5leHQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7XG4gIEJJR19FTkRJQU4sXG4gIERFRkFVTFRfTE9DQUxFX0ZPUk1BVCxcbiAgREVMSU1JVEVSX1JFR0VYLFxuICBJbnB1dERhdGVEaXNwbGF5Rm9ybWF0LFxuICBMSVRUTEVfRU5ESUFOLFxuICBMSVRUTEVfRU5ESUFOX1JFR0VYLFxuICBNSURETEVfRU5ESUFOLFxuICBNSURETEVfRU5ESUFOX1JFR0VYLFxuICBSVExfUkVHRVgsXG4gIFVTRVJfSU5QVVRfUkVHRVgsXG59IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXROdW1iZXJPZkRheXNJblRoZU1vbnRoLCBwYXJzZVRvRm91ckRpZ2l0WWVhciB9IGZyb20gJy4uL3V0aWxzL2RhdGUtdXRpbHMnO1xuXG5pbXBvcnQgeyBMb2NhbGVIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnLi9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0ZUlPU2VydmljZSB7XG4gIHB1YmxpYyBjbGRyTG9jYWxlRGF0ZUZvcm1hdDogc3RyaW5nID0gREVGQVVMVF9MT0NBTEVfRk9STUFUO1xuICBwcml2YXRlIGxvY2FsZURpc3BsYXlGb3JtYXQ6IElucHV0RGF0ZURpc3BsYXlGb3JtYXQgPSBMSVRUTEVfRU5ESUFOO1xuICBwcml2YXRlIGRlbGltaXRlcnM6IFtzdHJpbmcsIHN0cmluZ10gPSBbJy8nLCAnLyddO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2xvY2FsZUhlbHBlclNlcnZpY2U6IExvY2FsZUhlbHBlclNlcnZpY2UpIHtcbiAgICB0aGlzLmNsZHJMb2NhbGVEYXRlRm9ybWF0ID0gdGhpcy5fbG9jYWxlSGVscGVyU2VydmljZS5sb2NhbGVEYXRlRm9ybWF0O1xuICAgIHRoaXMuaW5pdGlhbGl6ZUxvY2FsZURpc3BsYXlGb3JtYXQoKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZUxvY2FsZURpc3BsYXlGb3JtYXQoKTogdm9pZCB7XG4gICAgY29uc3QgZm9ybWF0OiBzdHJpbmcgPSB0aGlzLmNsZHJMb2NhbGVEYXRlRm9ybWF0LnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKExJVFRMRV9FTkRJQU5fUkVHRVgudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPSBMSVRUTEVfRU5ESUFOO1xuICAgIH0gZWxzZSBpZiAoTUlERExFX0VORElBTl9SRUdFWC50ZXN0KGZvcm1hdCkpIHtcbiAgICAgIHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9IE1JRERMRV9FTkRJQU47XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZSBpcyBzZXQgdG8gQklHLUVORElBTiBGT1JNQVRcbiAgICAgIHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9IEJJR19FTkRJQU47XG4gICAgfVxuICAgIHRoaXMuZXh0cmFjdERlbGltaXRlcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdERlbGltaXRlcnMoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQpIHtcbiAgICAgIC8vIFNhbml0aXplIERhdGUgRm9ybWF0LiBSZW1vdmUgUlRMIGNoYXJhY3RlcnMuXG4gICAgICAvLyBGSVhNRTogV2hlbiB3ZSBzdXBwb3J0IFJUTCwgcmVtb3ZlIHRoaXMgYW5kIGhhbmRsZSBpdCBjb3JyZWN0bHkuXG4gICAgICBjb25zdCBsb2NhbGVGb3JtYXQ6IHN0cmluZyA9IHRoaXMuY2xkckxvY2FsZURhdGVGb3JtYXQucmVwbGFjZShSVExfUkVHRVgsICcnKTtcbiAgICAgIGNvbnN0IGRlbGltaXRlcnM6IHN0cmluZ1tdID0gbG9jYWxlRm9ybWF0LnNwbGl0KERFTElNSVRFUl9SRUdFWCk7XG5cbiAgICAgIC8vIE5PVEU6IFRoZSBzcGxpdCBmcm9tIHRoZSBDTERSIGRhdGUgZm9ybWF0IHNob3VsZCBhbHdheXMgcmVzdWx0XG4gICAgICAvLyBpbiBhbiBhcmFyeSB3aXRoIDQgZWxlbWVudHMuIFRoZSAxc3QgYW5kIHRoZSAybmQgdmFsdWVzIGFyZSB0aGUgZGVsaW1pdGVyc1xuICAgICAgLy8gd2Ugd2lsbCB1c2UgaW4gb3JkZXIuXG4gICAgICAvLyBFZzogXCJkZC9NTS95XCIuc3BsaXQoL2QrfG0rfHkrL2kpIHJlc3VsdHMgaW4gW1wiXCIsIFwiL1wiLCBcIi9cIiwgXCJcIl1cbiAgICAgIGlmIChkZWxpbWl0ZXJzICYmIGRlbGltaXRlcnMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHRoaXMuZGVsaW1pdGVycyA9IFtkZWxpbWl0ZXJzWzFdLCBkZWxpbWl0ZXJzWzJdXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuZXhwZWN0ZWQgZGF0ZSBmb3JtYXQgcmVjZWl2ZWQuIERlbGltaXRlcnMgZXh0cmFjdGVkOiAnLCBkZWxpbWl0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b0xvY2FsZURpc3BsYXlGb3JtYXRTdHJpbmcoZGF0ZTogRGF0ZSk6IHN0cmluZyB7XG4gICAgaWYgKGRhdGUpIHtcbiAgICAgIGlmIChpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0ZU5vOiBudW1iZXIgPSBkYXRlLmdldERhdGUoKTtcbiAgICAgIGNvbnN0IG1vbnRoTm86IG51bWJlciA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICBjb25zdCBkYXRlU3RyOiBzdHJpbmcgPSBkYXRlTm8gPiA5ID8gZGF0ZU5vLnRvU3RyaW5nKCkgOiAnMCcgKyBkYXRlTm87XG4gICAgICBjb25zdCBtb250aFN0cjogc3RyaW5nID0gbW9udGhObyA+IDkgPyBtb250aE5vLnRvU3RyaW5nKCkgOiAnMCcgKyBtb250aE5vO1xuICAgICAgaWYgKHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdCA9PT0gTElUVExFX0VORElBTikge1xuICAgICAgICByZXR1cm4gZGF0ZVN0ciArIHRoaXMuZGVsaW1pdGVyc1swXSArIG1vbnRoU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzFdICsgZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPT09IE1JRERMRV9FTkRJQU4pIHtcbiAgICAgICAgcmV0dXJuIG1vbnRoU3RyICsgdGhpcy5kZWxpbWl0ZXJzWzBdICsgZGF0ZVN0ciArIHRoaXMuZGVsaW1pdGVyc1sxXSArIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldEZ1bGxZZWFyKCkgKyB0aGlzLmRlbGltaXRlcnNbMF0gKyBtb250aFN0ciArIHRoaXMuZGVsaW1pdGVyc1sxXSArIGRhdGVTdHI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGdldCBwbGFjZWhvbGRlclRleHQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBmb3JtYXQ6IFtzdHJpbmcsIHN0cmluZywgc3RyaW5nXSA9IHRoaXMubG9jYWxlRGlzcGxheUZvcm1hdC5mb3JtYXQ7XG4gICAgcmV0dXJuIGZvcm1hdFswXSArIHRoaXMuZGVsaW1pdGVyc1swXSArIGZvcm1hdFsxXSArIHRoaXMuZGVsaW1pdGVyc1sxXSArIGZvcm1hdFsyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG1vbnRoIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgdmFsaWQgb3Igbm90LlxuICAgKiBOb3RlOiBNb250aCBpcyAwIGJhc2VkLlxuICAgKi9cbiAgcHJpdmF0ZSBpc1ZhbGlkTW9udGgobW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBtb250aCA+IC0xICYmIG1vbnRoIDwgMTI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBkYXRlIGlzIHZhbGlkIGRlcGVuZGluZyBvbiB0aGUgeWVhciBhbmQgbW9udGggcHJvdmlkZWQuXG4gICAqL1xuICBwcml2YXRlIGlzVmFsaWREYXRlKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF0ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRhdGUgPiAwICYmIGRhdGUgPD0gZ2V0TnVtYmVyT2ZEYXlzSW5UaGVNb250aCh5ZWFyLCBtb250aCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBwYXJhbWV0ZXJzIHByb3ZpZGVkIGFuZCByZXR1cm5zIHRoZSBkYXRlLlxuICAgKiBJZiB0aGUgcGFyYW1ldGVycyBhcmUgbm90XG4gICAqIHZhbGlkIHRoZW4gcmV0dXJuIG51bGwuXG4gICAqIE5PVEU6IChNb250aCBoZXJlIGlzIDEgYmFzZWQgc2luY2UgdGhlIHVzZXIgaGFzIHByb3ZpZGVkIHRoYXQgYXMgYW4gaW5wdXQpXG4gICAqL1xuICBwcml2YXRlIHZhbGlkYXRlQW5kR2V0RGF0ZSh5ZWFyOiBzdHJpbmcsIG1vbnRoOiBzdHJpbmcsIGRhdGU6IHN0cmluZyk6IERhdGUge1xuICAgIC8vIEkgZG9uJ3Qga25vdyB3aGF0cyB3cm9uZyB3aXRoIHRoZSBUUyBjb21waWxlci4gSXQgdGhyb3dzIGFuIGVycm9yIGlmIEkgd3JpdGVcbiAgICAvLyB0aGUgYmVsb3cgaWYgc3RhdGVtZW50LiBUaGUgZXJyb3IgaXM6XG4gICAgLy8gT3BlcmF0b3IgJyE9PScgY2Fubm90IGJlIGFwcGxpZWQgdG8gdHlwZXMgJzInIGFuZCAnNCdcbiAgICAvLyBNb3JlIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xMjc5NCNpc3N1ZWNvbW1lbnQtMjcwMzQyOTM2XG4gICAgLypcbiAgICAgICAgaWYgKHllYXIubGVuZ3RoICE9PSAyIHx8IHllYXIubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgLy8gSW5zdGVhZCBJIGhhdmUgdG8gd3JpdGUgdGhlIGxvZ2ljIGxpa2UgdGhpcyB4LShcbiAgICBjb25zdCB5OiBudW1iZXIgPSAreWVhcjtcbiAgICBjb25zdCBtOiBudW1iZXIgPSArbW9udGggLSAxOyAvLyBtb250aCBpcyAwIGJhc2VkXG4gICAgY29uc3QgZDogbnVtYmVyID0gK2RhdGU7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWRNb250aChtKSB8fCAhdGhpcy5pc1ZhbGlkRGF0ZSh5LCBtLCBkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdDogbnVtYmVyID0gcGFyc2VUb0ZvdXJEaWdpdFllYXIoeSk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPT0gLTEgPyBuZXcgRGF0ZShyZXN1bHQsIG0sIGQpIDogbnVsbDtcbiAgfVxuXG4gIGdldERhdGVWYWx1ZUZyb21EYXRlU3RyaW5nKGRhdGU6IHN0cmluZyk6IERhdGUge1xuICAgIGlmICghZGF0ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRhdGVQYXJ0czogc3RyaW5nW10gPSBkYXRlLm1hdGNoKFVTRVJfSU5QVVRfUkVHRVgpO1xuICAgIGlmICghZGF0ZVBhcnRzIHx8IGRhdGVQYXJ0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0LCB0aGlyZFBhcnRdID0gZGF0ZVBhcnRzO1xuICAgIGlmICh0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPT09IExJVFRMRV9FTkRJQU4pIHtcbiAgICAgIC8vIHNlY29uZFBhcnQgaXMgbW9udGggJiYgZmlyc3RQYXJ0IGlzIGRhdGVcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQW5kR2V0RGF0ZSh0aGlyZFBhcnQsIHNlY29uZFBhcnQsIGZpcnN0UGFydCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxvY2FsZURpc3BsYXlGb3JtYXQgPT09IE1JRERMRV9FTkRJQU4pIHtcbiAgICAgIC8vIGZpcnN0UGFydCBpcyBtb250aCAmJiBzZWNvbmRQYXJ0IGlzIGRhdGVcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQW5kR2V0RGF0ZSh0aGlyZFBhcnQsIGZpcnN0UGFydCwgc2Vjb25kUGFydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNlY29uZFBhcnQgaXMgbW9udGggJiYgdGhpcmRQYXJ0IGlzIGRhdGVcbiAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQW5kR2V0RGF0ZShmaXJzdFBhcnQsIHNlY29uZFBhcnQsIHRoaXJkUGFydCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8vIGlQYWQgbWluaSBzY3JlZW4gd2lkdGhcbi8vIGh0dHA6Ly9zdGVwaGVuLmlvL21lZGlhcXVlcmllcy8jaVBhZE1pbmlcbmV4cG9ydCBjb25zdCBEQVRFUElDS0VSX0VOQUJMRV9CUkVBS1BPSU5UOiBudW1iZXIgPSA3Njg7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEQVRFUElDS0VSX0VOQUJMRV9CUkVBS1BPSU5UIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvYnJlYWtwb2ludHMvYnJlYWtwb2ludHMnO1xuaW1wb3J0IHsgTU9CSUxFX1VTRVJBR0VOVF9SRUdFWCB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlcGlja2VyRW5hYmxlZFNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7XG4gICAgaWYgKHRoaXMuX2RvY3VtZW50KSB7XG4gICAgICB0aGlzLl9pc1VzZXJBZ2VudE1vYmlsZSA9IE1PQklMRV9VU0VSQUdFTlRfUkVHRVgudGVzdChfZG9jdW1lbnQuZGVmYXVsdFZpZXcubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB0aGlzLl9pbm5lcldpZHRoID0gX2RvY3VtZW50LmRlZmF1bHRWaWV3LmlubmVyV2lkdGg7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaXNVc2VyQWdlbnRNb2JpbGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaW5uZXJXaWR0aDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgYWN0aXZlIG9yIG5vdC5cbiAgICogSWYgdGhlIHVzZXIgYWdlbnQgaXMgbW9iaWxlIGFuZCB0aGUgc2NyZWVuIHdpZHRoIGlzIGxlc3MgdGhhbiBEQVRFUElDS0VSX0FDVElWRV9CUkVBS1BPSU5UXG4gICAqIHRoZW4gdGhlIGNhbGVuZGFyIGlzIGluYWN0aXZlLlxuICAgKi9cbiAgZ2V0IGlzRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0Jyb3dzZXJfZGV0ZWN0aW9uX3VzaW5nX3RoZV91c2VyX2FnZW50XG4gICAgLy8gV2hhdCB0aGV5IHJlY29tbWVuZCBpczpcbiAgICAvL1wiSW4gc3VtbWFyeSwgd2UgcmVjb21tZW5kIGxvb2tpbmcgZm9yIHRoZSBzdHJpbmcgJ01vYmknXG4gICAgLy8gYW55d2hlcmUgaW4gdGhlIFVzZXIgQWdlbnQgdG8gZGV0ZWN0IGEgbW9iaWxlIGRldmljZS5cIlxuICAgIGlmICh0aGlzLl9kb2N1bWVudCkge1xuICAgICAgaWYgKHRoaXMuX2lubmVyV2lkdGggPCBEQVRFUElDS0VSX0VOQUJMRV9CUkVBS1BPSU5UICYmIHRoaXMuX2lzVXNlckFnZW50TW9iaWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgSW5qZWN0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBDb250ZW50Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IEZvY3VzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBMYXlvdXRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9sYXlvdXQuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5pbXBvcnQgeyBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlSU9TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1pby5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZW5hYmxlZC5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IElTX05FV19GT1JNU19MQVlPVVQgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25ldy1mb3Jtcy5zZXJ2aWNlJztcblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCBjb250YWlucyB0d28gdGVtcGxhdGUgZm9yIHRoZSBvbGQgYW5kIG5ldyBmb3JtcyBsYXlvdXRzLlxuICogV2hlbiBpdCBpcyB0aW1lIHRvIHJlbW92ZSB0aGUgb2xkIGZvcm1zIGxheW91dHMgc3VwcG9ydCwgcmVtb3ZlIHRoZSBuZy10ZW1wbGF0ZXNcbiAqIGFuZCBuZy1jb250YWluZXIsIGFuZCBqdXN0IGtlZXAgdGhlIGlubmVyIGNvbnRlbnQgb2YgdGhlICNuZXdMYXlvdXQgYXMgdGhlIHRlbXBsYXRlXG4gKiBhbmQgbW92ZSB0aGUgbmctY29udGVudCBmb3IgY2xyRGF0ZS5cbiAqL1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGF0ZS1jb250YWluZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZSAjb2xkTGF5b3V0PlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjbHJEYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJkYXRlcGlja2VyLXRyaWdnZXJcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZURhdGVwaWNrZXIoJGV2ZW50KVwiXG4gICAgICAgICAgICAqbmdJZj1cImlzRW5hYmxlZFwiPlxuICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiY2FsZW5kYXJcIiBjbGFzcz1cImRhdGVwaWNrZXItdHJpZ2dlci1pY29uXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5vcGVuXCI+PC9jbHItaWNvbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxjbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXIgKmNscklmT3BlbiBjbHJGb2N1c1RyYXA+PC9jbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBcbiAgICA8bmctdGVtcGxhdGUgI25ld0xheW91dD5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGxhYmVsICpuZ0lmPVwiIWxhYmVsICYmIGFkZEdyaWQoKVwiPjwvbGFiZWw+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2xyLWNvbnRyb2wtY29udGFpbmVyXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1pbnB1dC13cmFwcGVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNsci1pbnB1dC1ncm91cFwiIFtjbGFzcy5jbHItZm9jdXNdPVwiZm9jdXNcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjbHJEYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsci1pbnB1dC1ncm91cC1pY29uLWFjdGlvblwiIChjbGljayk9XCJ0b2dnbGVEYXRlcGlja2VyKCRldmVudClcIiAqbmdJZj1cImlzRW5hYmxlZFwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mub3BlblwiIFtkaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZFwiPlxuICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJjYWxlbmRhclwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDxjbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXIgKmNscklmT3BlbiBjbHJGb2N1c1RyYXA+PC9jbHItZGF0ZXBpY2tlci12aWV3LW1hbmFnZXI+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGNsci1pY29uIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiPjwvY2xyLWljb24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgXG4gICAgPG5nLXRlbXBsYXRlICNjbHJEYXRlPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsckRhdGVdXCI+PC9uZy1jb250ZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIm5ld0Zvcm1zTGF5b3V0OyB0aGVuIG5ld0xheW91dCBlbHNlIG9sZExheW91dFwiPjwvbmctY29udGFpbmVyPlxuICAgIGAsXG4gIHByb3ZpZGVyczogW1xuICAgIENvbnRyb2xJZFNlcnZpY2UsXG4gICAgSWZPcGVuU2VydmljZSxcbiAgICBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIElmRXJyb3JTZXJ2aWNlLFxuICAgIENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgRm9jdXNTZXJ2aWNlLFxuICAgIE5nQ29udHJvbFNlcnZpY2UsXG4gICAgRGF0ZUlPU2VydmljZSxcbiAgICBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlLFxuICAgIERhdGVGb3JtQ29udHJvbFNlcnZpY2UsXG4gIF0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGUtY29udGFpbmVyXSc6ICchbmV3Rm9ybXNMYXlvdXQnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZF0nOiAnY29udHJvbD8uZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAnbmV3Rm9ybXNMYXlvdXQnLFxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0ZUNvbnRhaW5lciBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBPbkRlc3Ryb3kge1xuICBfZHluYW1pYzogYm9vbGVhbiA9IGZhbHNlO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIGZvY3VzID0gZmFsc2U7XG4gIGNvbnRyb2w6IE5nQ29udHJvbDtcbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9pZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJFbmFibGVkU2VydmljZTogRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlLFxuICAgIHByaXZhdGUgZGF0ZUZvcm1Db250cm9sU2VydmljZTogRGF0ZUZvcm1Db250cm9sU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncyxcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBwcml2YXRlIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KElTX05FV19GT1JNU19MQVlPVVQpXG4gICAgcHVibGljIG5ld0Zvcm1zTGF5b3V0OiBib29sZWFuLFxuICAgIHByaXZhdGUgbmdDb250cm9sU2VydmljZTogTmdDb250cm9sU2VydmljZVxuICApIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX2lmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUob3BlbiA9PiB7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplQ2FsZW5kYXIoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHN0YXRlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBjb250cm9sXG4gICAqL1xuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY29udHJvbCBuZWVkcyB0byBhZGQgZ3JpZCBjbGFzc2VzXG4gICAqL1xuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgRGF0ZXBpY2tlciBpcyBlbmFibGVkIG9yIG5vdC4gSWYgZGlzYWJsZWQsIGhpZGVzIHRoZSBkYXRlcGlja2VyIHRyaWdnZXIuXG4gICAqL1xuICBnZXQgaXNFbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UuaXNFbmFibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgdXNlciBpbnB1dCBhbmQgSW5pdGlhbGl6ZXMgdGhlIENhbGVuZGFyIGV2ZXJ5dGltZSB0aGUgZGF0ZXBpY2tlciBwb3BvdmVyIGlzIG9wZW4uXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVDYWxlbmRhcigpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuaW5pdGlhbGl6ZUNhbGVuZGFyKCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgRGF0ZXBpY2tlciBQb3BvdmVyLlxuICAgKi9cbiAgdG9nZ2xlRGF0ZXBpY2tlcihldmVudDogTW91c2VFdmVudCkge1xuICAgIHRoaXMuX2lmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgICB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UubWFya0FzVG91Y2hlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gc3Vic2NyaXB0aW9ucy5cbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBQTEFURk9STV9JRCxcbiAgUmVuZGVyZXIyLFxuICBTZWxmLFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGZpbHRlciwgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgQ2xyRGF0ZUNvbnRhaW5lciB9IGZyb20gJy4vZGF0ZS1jb250YWluZXInO1xuaW1wb3J0IHsgRGF5TW9kZWwgfSBmcm9tICcuL21vZGVsL2RheS5tb2RlbCc7XG5pbXBvcnQgeyBEYXRlRm9ybUNvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1mb3JtLWNvbnRyb2wuc2VydmljZSc7XG5pbXBvcnQgeyBEYXRlSU9TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1pby5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZW5hYmxlZC5zZXJ2aWNlJztcbmltcG9ydCB7IElTX05FV19GT1JNU19MQVlPVVQgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL25ldy1mb3Jtcy5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgZGF0ZXNBcmVFcXVhbCB9IGZyb20gJy4vdXRpbHMvZGF0ZS11dGlscyc7XG5cbi8vIFRoZXJlIGFyZSBmb3VyIHdheXMgdGhlIGRhdGVwaWNrZXIgdmFsdWUgaXMgc2V0XG4vLyAxLiBWYWx1ZSBzZXQgYnkgdXNlciB0eXBpbmcgaW50byB0ZXh0IGlucHV0IGFzIGEgc3RyaW5nIGV4OiAnMDEvMjgvMjAxNSdcbi8vIDIuIFZhbHVlIHNldCBleHBsaWNpdGx5IGJ5IEFuZ3VsYXIgRm9ybXMgQVBJcyBhcyBhIHN0cmluZyBleDogJzAxLzI4LzIwMTUnXG4vLyAzLiBWYWx1ZSBzZXQgYnkgdXNlciB2aWEgZGF0ZXBpY2tlciBVSSBhcyBhIERhdGUgT2JqZWN0XG4vLyA0LiBWYWx1ZSBzZXQgdmlhIGBjbHJEYXRlYCBpbnB1dCBhcyBhIERhdGUgT2JqZWN0XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJEYXRlXScsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGUtaW5wdXRdJzogJyFuZXdGb3Jtc0xheW91dCcsXG4gICAgJ1tjbGFzcy5jbHItaW5wdXRdJzogJ25ld0Zvcm1zTGF5b3V0JyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbRGF0ZXBpY2tlckZvY3VzU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVJbnB1dCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJEYXRlQ29udGFpbmVyPiBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZztcbiAgQElucHV0KCkgY2xyTmV3TGF5b3V0OiBib29sZWFuO1xuICBAT3V0cHV0KCdjbHJEYXRlQ2hhbmdlJykgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPihmYWxzZSk7XG4gIEBJbnB1dCgnY2xyRGF0ZScpXG4gIHNldCBkYXRlKGRhdGU6IERhdGUpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgIT09IGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh0aGlzLmdldFZhbGlkRGF0ZVZhbHVlRnJvbURhdGUoZGF0ZSkpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pbml0aWFsQ2xyRGF0ZUlucHV0VmFsdWUpIHtcbiAgICAgIHRoaXMuaW5pdGlhbENsckRhdGVJbnB1dFZhbHVlID0gZGF0ZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgaW5kZXggPSA0O1xuICBwcml2YXRlIGluaXRpYWxDbHJEYXRlSW5wdXRWYWx1ZTogRGF0ZTtcbiAgcHJpdmF0ZSBwcmV2aW91c0RhdGVDaGFuZ2U6IERhdGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgcHJvdGVjdGVkIGVsOiBFbGVtZW50UmVmLFxuICAgIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByb3RlY3RlZCBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250YWluZXI6IENsckRhdGVDb250YWluZXIsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkYXRlSU9TZXJ2aWNlOiBEYXRlSU9TZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZGF0ZU5hdmlnYXRpb25TZXJ2aWNlOiBEYXRlTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkYXRlcGlja2VyRW5hYmxlZFNlcnZpY2U6IERhdGVwaWNrZXJFbmFibGVkU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRhdGVGb3JtQ29udHJvbFNlcnZpY2U6IERhdGVGb3JtQ29udHJvbFNlcnZpY2UsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBmb2N1c1NlcnZpY2U6IEZvY3VzU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoSVNfTkVXX0ZPUk1TX0xBWU9VVClcbiAgICBwdWJsaWMgbmV3Rm9ybXNMYXlvdXQ6IGJvb2xlYW4sXG4gICAgcHJpdmF0ZSBkYXRlcGlja2VyRm9jdXNTZXJ2aWNlOiBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlXG4gICkge1xuICAgIHN1cGVyKHZpZXdDb250YWluZXJSZWYsIENsckRhdGVDb250YWluZXIsIGluamVjdG9yLCBjb250cm9sLCByZW5kZXJlciwgZWwpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB0aGlzLnNldEZvcm1MYXlvdXQoKTtcbiAgICB0aGlzLnBvcHVsYXRlU2VydmljZXNGcm9tQ29udGFpbmVyQ29tcG9uZW50KCk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubGlzdGVuRm9yVXNlclNlbGVjdGVkRGF5Q2hhbmdlcygpLFxuICAgICAgdGhpcy5saXN0ZW5Gb3JDb250cm9sVmFsdWVDaGFuZ2VzKCksXG4gICAgICB0aGlzLmxpc3RlbkZvclRvdWNoQ2hhbmdlcygpLFxuICAgICAgdGhpcy5saXN0ZW5Gb3JEaXJ0eUNoYW5nZXMoKSxcbiAgICAgIHRoaXMubGlzdGVuRm9ySW5wdXRSZWZvY3VzKClcbiAgICApO1xuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIEkgZG9uJ3Qga25vdyB3aHkgSSBoYXZlIHRvIGRvIHRoaXMgYnV0IGFmdGVyIHVzaW5nIHRoZSBuZXcgSG9zdFdyYXBwaW5nIE1vZHVsZSBJIGhhdmUgdG8gZGVsYXkgdGhlIHByb2Nlc3NpbmdcbiAgICAvLyBvZiB0aGUgaW5pdGlhbCBJbnB1dCBzZXQgYnkgdGhlIHVzZXIgdG8gaGVyZS4gSWYgSSBkbyBub3QgMiBpc3N1ZXMgb2NjdXI6XG4gICAgLy8gMS4gVGhlIElucHV0IHNldHRlciBpcyBjYWxsZWQgYmVmb3JlIG5nT25Jbml0LiBuZ09uSW5pdCBpbml0aWFsaXplcyB0aGUgc2VydmljZXMgd2l0aG91dCB3aGljaCB0aGUgc2V0dGVyIGZhaWxzLlxuICAgIC8vIDIuIFRoZSBSZW5kZXJlciBkb2Vzbid0IHdvcmsgYmVmb3JlIG5nQWZ0ZXJWaWV3SW5pdCAoSXQgdXNlZCB0byBiZWZvcmUgdGhlIG5ldyBIb3N0V3JhcHBpbmcgTW9kdWxlIGZvciBzb21lIHJlYXNvbikuXG4gICAgLy8gSSBuZWVkIHRoZSByZW5kZXJlciB0byBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IG9uIHRoZSBpbnB1dCB0byBtYWtlIHN1cmUgdGhhdCBpZiB0aGUgdXNlciBoYXMgc3VwcGxpZWQgYSBEYXRlXG4gICAgLy8gaW5wdXQgb2JqZWN0LCB3ZSByZWZsZWN0IGl0IHdpdGggdGhlIHJpZ2h0IGRhdGUgb24gdGhlIGlucHV0IGZpZWxkIHVzaW5nIHRoZSBJTyBzZXJ2aWNlLiBJIGFtIG5vdCBzdXJlIGlmXG4gICAgLy8gdGhlc2UgYXJlIG1ham9yIGlzc3VlcyBvciBub3QgYnV0IGp1c3Qgbm90aW5nIHRoZW0gZG93biBoZXJlLlxuICAgIHRoaXMucHJvY2Vzc0luaXRpYWxJbnB1dHMoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgc2V0Rm9jdXNTdGF0ZXMoKSB7XG4gICAgdGhpcy5zZXRGb2N1cyh0cnVlKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKVxuICB0cmlnZ2VyVmFsaWRhdGlvbigpIHtcbiAgICBzdXBlci50cmlnZ2VyVmFsaWRhdGlvbigpO1xuICAgIHRoaXMuc2V0Rm9jdXMoZmFsc2UpO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnBsYWNlaG9sZGVyJylcbiAgZ2V0IHBsYWNlaG9sZGVyVGV4dCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBsYWNlaG9sZGVyID8gdGhpcy5wbGFjZWhvbGRlciA6IHRoaXMuZGF0ZUlPU2VydmljZS5wbGFjZWhvbGRlclRleHQ7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpXG4gIGdldCBpbnB1dFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSAmJiB0aGlzLnVzaW5nTmF0aXZlRGF0ZXBpY2tlcigpID8gJ2RhdGUnIDogJ3RleHQnO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJywgWyckZXZlbnQudGFyZ2V0J10pXG4gIG9uVmFsdWVDaGFuZ2UodGFyZ2V0OiBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgY29uc3QgdmFsaWREYXRlVmFsdWUgPSB0aGlzLmRhdGVJT1NlcnZpY2UuZ2V0RGF0ZVZhbHVlRnJvbURhdGVTdHJpbmcodGFyZ2V0LnZhbHVlKTtcbiAgICBpZiAodGhpcy51c2luZ0NsYXJpdHlEYXRlcGlja2VyKCkgJiYgdmFsaWREYXRlVmFsdWUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh2YWxpZERhdGVWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVzaW5nTmF0aXZlRGF0ZXBpY2tlcigpKSB7XG4gICAgICBjb25zdCBbeWVhciwgbW9udGgsIGRheV0gPSB0YXJnZXQudmFsdWUuc3BsaXQoJy0nKTtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZShuZXcgRGF0ZSgreWVhciwgK21vbnRoIC0gMSwgK2RheSksIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXREYXRlT3V0cHV0KG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXNpbmdDbGFyaXR5RGF0ZXBpY2tlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlcGlja2VyRW5hYmxlZFNlcnZpY2UuaXNFbmFibGVkO1xuICB9XG5cbiAgcHJpdmF0ZSB1c2luZ05hdGl2ZURhdGVwaWNrZXIoKSB7XG4gICAgcmV0dXJuICF0aGlzLmRhdGVwaWNrZXJFbmFibGVkU2VydmljZS5pc0VuYWJsZWQ7XG4gIH1cblxuICBwcml2YXRlIHNldEZvY3VzKGZvY3VzOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuZm9jdXNTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmZvY3VzU2VydmljZS5mb2N1c2VkID0gZm9jdXM7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwb3B1bGF0ZVNlcnZpY2VzRnJvbUNvbnRhaW5lckNvbXBvbmVudCgpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmRhdGVJT1NlcnZpY2UgPSB0aGlzLmdldFByb3ZpZGVyRnJvbUNvbnRhaW5lcihEYXRlSU9TZXJ2aWNlKTtcbiAgICAgIHRoaXMuZGF0ZU5hdmlnYXRpb25TZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXIoRGF0ZU5hdmlnYXRpb25TZXJ2aWNlKTtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlID0gdGhpcy5nZXRQcm92aWRlckZyb21Db250YWluZXIoRGF0ZXBpY2tlckVuYWJsZWRTZXJ2aWNlKTtcbiAgICAgIHRoaXMuZGF0ZUZvcm1Db250cm9sU2VydmljZSA9IHRoaXMuZ2V0UHJvdmlkZXJGcm9tQ29udGFpbmVyKERhdGVGb3JtQ29udHJvbFNlcnZpY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvY2Vzc0luaXRpYWxJbnB1dHMoKSB7XG4gICAgaWYgKHRoaXMuZGF0ZXBpY2tlckhhc0Zvcm1Db250cm9sKCkpIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh0aGlzLmRhdGVJT1NlcnZpY2UuZ2V0RGF0ZVZhbHVlRnJvbURhdGVTdHJpbmcodGhpcy5jb250cm9sLnZhbHVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlRGF0ZSh0aGlzLmluaXRpYWxDbHJEYXRlSW5wdXRWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRGb3JtTGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmNsck5ld0xheW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm5ld0Zvcm1zTGF5b3V0ID0gISF0aGlzLmNsck5ld0xheW91dDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZURhdGUodmFsdWU6IERhdGUsIHNldEJ5VXNlckludGVyYWN0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCBkYXRlID0gdGhpcy5nZXRWYWxpZERhdGVWYWx1ZUZyb21EYXRlKHZhbHVlKTtcblxuICAgIGlmIChzZXRCeVVzZXJJbnRlcmFjdGlvbikge1xuICAgICAgdGhpcy5lbWl0RGF0ZU91dHB1dChkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgPSBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhdGVOYXZpZ2F0aW9uU2VydmljZSkge1xuICAgICAgdGhpcy5kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXkgPSBkYXRlXG4gICAgICAgID8gbmV3IERheU1vZGVsKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSlcbiAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlSW5wdXQoZGF0ZSk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZUlucHV0KGRhdGU6IERhdGUpIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgY29uc3QgZGF0ZVN0cmluZyA9IHRoaXMuZGF0ZUlPU2VydmljZS50b0xvY2FsZURpc3BsYXlGb3JtYXRTdHJpbmcoZGF0ZSk7XG5cbiAgICAgIGlmICh0aGlzLmRhdGVwaWNrZXJIYXNGb3JtQ29udHJvbCgpICYmIGRhdGVTdHJpbmcgIT09IHRoaXMuY29udHJvbC52YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbnRyb2wuY29udHJvbC5zZXRWYWx1ZShkYXRlU3RyaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy51c2luZ05hdGl2ZURhdGVwaWNrZXIoKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3ZhbHVlQXNEYXRlJywgZGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgZGF0ZVN0cmluZyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRWYWxpZERhdGVWYWx1ZUZyb21EYXRlKGRhdGU6IERhdGUpIHtcbiAgICBpZiAodGhpcy5kYXRlSU9TZXJ2aWNlKSB7XG4gICAgICBjb25zdCBkYXRlU3RyaW5nID0gdGhpcy5kYXRlSU9TZXJ2aWNlLnRvTG9jYWxlRGlzcGxheUZvcm1hdFN0cmluZyhkYXRlKTtcbiAgICAgIHJldHVybiB0aGlzLmRhdGVJT1NlcnZpY2UuZ2V0RGF0ZVZhbHVlRnJvbURhdGVTdHJpbmcoZGF0ZVN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW1pdERhdGVPdXRwdXQoZGF0ZTogRGF0ZSkge1xuICAgIGlmICghZGF0ZXNBcmVFcXVhbChkYXRlLCB0aGlzLnByZXZpb3VzRGF0ZUNoYW5nZSkpIHtcbiAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KGRhdGUpO1xuICAgICAgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgPSBkYXRlO1xuICAgIH0gZWxzZSBpZiAoIWRhdGUgJiYgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KG51bGwpO1xuICAgICAgdGhpcy5wcmV2aW91c0RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZGF0ZXBpY2tlckhhc0Zvcm1Db250cm9sKCkge1xuICAgIHJldHVybiAhIXRoaXMuY29udHJvbDtcbiAgfVxuXG4gIHByaXZhdGUgbGlzdGVuRm9yQ29udHJvbFZhbHVlQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gb2YodGhpcy5kYXRlcGlja2VySGFzRm9ybUNvbnRyb2woKSlcbiAgICAgIC5waXBlKFxuICAgICAgICBmaWx0ZXIoaGFzQ29udHJvbCA9PiBoYXNDb250cm9sKSxcbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRoaXMuY29udHJvbC52YWx1ZUNoYW5nZXMpLFxuICAgICAgICAvLyBvbmx5IHVwZGF0ZSBkYXRlIHZhbHVlIGlmIG5vdCBiZWluZyBzZXQgYnkgdXNlclxuICAgICAgICBmaWx0ZXIoKCkgPT4gIXRoaXMuZGF0ZXBpY2tlckZvY3VzU2VydmljZS5lbGVtZW50SXNGb2N1c2VkKHRoaXMuZWwubmF0aXZlRWxlbWVudCkpXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCh2YWx1ZTogc3RyaW5nKSA9PiB0aGlzLnVwZGF0ZURhdGUodGhpcy5kYXRlSU9TZXJ2aWNlLmdldERhdGVWYWx1ZUZyb21EYXRlU3RyaW5nKHZhbHVlKSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBsaXN0ZW5Gb3JVc2VyU2VsZWN0ZWREYXlDaGFuZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVOYXZpZ2F0aW9uU2VydmljZS5zZWxlY3RlZERheUNoYW5nZS5zdWJzY3JpYmUoZGF5TW9kZWwgPT4gdGhpcy51cGRhdGVEYXRlKGRheU1vZGVsLnRvRGF0ZSgpLCB0cnVlKSk7XG4gIH1cblxuICBwcml2YXRlIGxpc3RlbkZvclRvdWNoQ2hhbmdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlRm9ybUNvbnRyb2xTZXJ2aWNlLnRvdWNoZWRDaGFuZ2VcbiAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmRhdGVwaWNrZXJIYXNGb3JtQ29udHJvbCgpKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb250cm9sLmNvbnRyb2wubWFya0FzVG91Y2hlZCgpKTtcbiAgfVxuXG4gIHByaXZhdGUgbGlzdGVuRm9yRGlydHlDaGFuZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UuZGlydHlDaGFuZ2VcbiAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmRhdGVwaWNrZXJIYXNGb3JtQ29udHJvbCgpKSlcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb250cm9sLmNvbnRyb2wubWFya0FzRGlydHkoKSk7XG4gIH1cblxuICBwcml2YXRlIGxpc3RlbkZvcklucHV0UmVmb2N1cygpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlTmF2aWdhdGlvblNlcnZpY2Uuc2VsZWN0ZWREYXlDaGFuZ2VcbiAgICAgIC5waXBlKGZpbHRlcihkYXRlID0+ICEhZGF0ZSkpXG4gICAgICAuc3Vic2NyaWJlKHYgPT4gdGhpcy5kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzSW5wdXQodGhpcy5lbC5uYXRpdmVFbGVtZW50KSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyVmlld0NoZWNrZWQsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBJbmplY3RhYmxlLFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBSZW5kZXJlcjIsXG4gIFNraXBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IEVTQyB9IGZyb20gJy4uLy4uL3V0aWxzL2tleS1jb2Rlcy9rZXktY29kZXMnO1xuXG5pbXBvcnQgeyBQb2ludCwgUG9wb3ZlciB9IGZyb20gJy4vcG9wb3Zlcic7XG5pbXBvcnQgeyBQb3BvdmVyT3B0aW9ucyB9IGZyb20gJy4vcG9wb3Zlci1vcHRpb25zLmludGVyZmFjZSc7XG5cbi8vIExpdGVyYWxseSBhbnkgYW5ub3RhdGlvbiB3b3VsZCB3b3JrIGhlcmUsIGJ1dCB3cml0aW5nIG91ciBvd24gQEhvbmV5QmFkZ2VyIGFubm90YXRpb24gZmVlbHMgb3ZlcmtpbGwuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RQb3BvdmVyIGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCwgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IoaW5qZWN0b3I6IEluamVjdG9yLCBAU2tpcFNlbGYoKSBwcm90ZWN0ZWQgcGFyZW50SG9zdDogRWxlbWVudFJlZikge1xuICAgIHRoaXMuZWwgPSBpbmplY3Rvci5nZXQoRWxlbWVudFJlZik7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlID0gaW5qZWN0b3IuZ2V0KElmT3BlblNlcnZpY2UpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBpbmplY3Rvci5nZXQoUmVuZGVyZXIyKTtcbiAgICAvLyBEZWZhdWx0IGFuY2hvciBpcyB0aGUgcGFyZW50IGhvc3RcbiAgICB0aGlzLmFuY2hvckVsZW0gPSBwYXJlbnRIb3N0Lm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICB0aGlzLnBvcG92ZXJJbnN0YW5jZSA9IG5ldyBQb3BvdmVyKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5hbmNob3IoKTtcbiAgICAgICAgdGhpcy5hdHRhY2hFU0NMaXN0ZW5lcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMuZGV0YWNoRVNDTGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4pIHtcbiAgICAgIHRoaXMuYW5jaG9yKCk7XG4gICAgICB0aGlzLmF0dGFjaEVTQ0xpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGVsOiBFbGVtZW50UmVmO1xuICBwcm90ZWN0ZWQgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZTtcbiAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjI7XG5cbiAgcHJpdmF0ZSBwb3BvdmVySW5zdGFuY2U6IFBvcG92ZXI7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSB1cGRhdGVBbmNob3IgPSBmYWxzZTtcblxuICBwcm90ZWN0ZWQgYW5jaG9yRWxlbTogYW55O1xuICBwcm90ZWN0ZWQgYW5jaG9yUG9pbnQ6IFBvaW50O1xuICBwcm90ZWN0ZWQgcG9wb3ZlclBvaW50OiBQb2ludDtcbiAgcHJvdGVjdGVkIHBvcG92ZXJPcHRpb25zOiBQb3BvdmVyT3B0aW9ucyA9IHt9O1xuXG4gIHByb3RlY3RlZCBpZ25vcmVkRWxlbWVudDogYW55O1xuXG4gIHByb3RlY3RlZCBhbmNob3IoKSB7XG4gICAgdGhpcy51cGRhdGVBbmNob3IgPSB0cnVlO1xuICAgIC8vIFVnaFxuICAgIHRoaXMuaWdub3JlID0gdGhpcy5pZk9wZW5TZXJ2aWNlLm9yaWdpbmFsRXZlbnQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgcmVsZWFzZSgpIHtcbiAgICB0aGlzLmRldGFjaE91dHNpZGVDbGlja0xpc3RlbmVyKCk7XG4gICAgdGhpcy5wb3BvdmVySW5zdGFuY2UucmVsZWFzZSgpO1xuICB9XG5cbiAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUFuY2hvcikge1xuICAgICAgdGhpcy51cGRhdGVBbmNob3IgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9wb3Zlckluc3RhbmNlXG4gICAgICAgIC5hbmNob3IodGhpcy5hbmNob3JFbGVtLCB0aGlzLmFuY2hvclBvaW50LCB0aGlzLnBvcG92ZXJQb2ludCwgdGhpcy5wb3BvdmVyT3B0aW9ucylcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgLy8gaWYgYSBzY3JvbGwgZXZlbnQgaXMgZGV0ZWN0ZWQsIGNsb3NlIHRoZSBwb3BvdmVyXG4gICAgICAgICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB0aGlzLmF0dGFjaE91dHNpZGVDbGlja0xpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZWxlYXNlKCk7XG4gICAgdGhpcy5kZXRhY2hFU0NMaXN0ZW5lcigpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKlxuICAgICAqIEZhbGxiYWNrIHRvIGhpZGUgd2hlbiAqY2xySWZPcGVuIGlzIG5vdCBiZWluZyB1c2VkXG4gICAgICovXG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pcy1vZmYtc2NyZWVuJylcbiAgZ2V0IGlzT2ZmU2NyZWVuKCkge1xuICAgIHJldHVybiB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA/IGZhbHNlIDogdHJ1ZTtcbiAgfVxuXG4gIC8qXG4gICAgICogVW50aWwgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvODc4NSBpcyBzdXBwb3J0ZWQsIHdlIGRvbid0IGhhdmUgYW55IHdheSB0byBpbnN0YW50aWF0ZVxuICAgICAqIGEgc2VwYXJhdGUgZGlyZWN0aXZlIG9uIHRoZSBob3N0LiBTbyBsZXQncyBkbyBkaXJ0eSBidXQgcGVyZm9ybWFudCBmb3Igbm93LlxuICAgICAqL1xuICBwdWJsaWMgY2xvc2VPbk91dHNpZGVDbGljayA9IGZhbHNlO1xuICBwcml2YXRlIGhvc3RDbGlja0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIGRvY3VtZW50Q2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBkb2N1bWVudEVTQ0xpc3RlbmVyOiAoKSA9PiB2b2lkO1xuICBwcml2YXRlIGlnbm9yZWRFbGVtZW50Q2xpY2tMaXN0ZW5lcjogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBpZ25vcmU6IGFueTtcblxuICBwcml2YXRlIGF0dGFjaEVTQ0xpc3RlbmVyKCk6IHZvaWQge1xuICAgIHRoaXMuZG9jdW1lbnRFU0NMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdrZXlkb3duJywgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LmtleUNvZGUgPT09IEVTQykge1xuICAgICAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXRhY2hFU0NMaXN0ZW5lcigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5kb2N1bWVudEVTQ0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRvY3VtZW50RVNDTGlzdGVuZXIoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmRvY3VtZW50RVNDTGlzdGVuZXI7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhdHRhY2hPdXRzaWRlQ2xpY2tMaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrKSB7XG4gICAgICB0aGlzLmhvc3RDbGlja0xpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCBldmVudCA9PiAodGhpcy5pZ25vcmUgPSBldmVudCkpO1xuICAgICAgaWYgKHRoaXMuaWdub3JlZEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihcbiAgICAgICAgICB0aGlzLmlnbm9yZWRFbGVtZW50LFxuICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgZXZlbnQgPT4gKHRoaXMuaWdub3JlID0gZXZlbnQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lciA9IHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdjbGljaycsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50ID09PSB0aGlzLmlnbm9yZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmlnbm9yZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRldGFjaE91dHNpZGVDbGlja0xpc3RlbmVyKCkge1xuICAgIGlmICh0aGlzLmNsb3NlT25PdXRzaWRlQ2xpY2spIHtcbiAgICAgIGlmICh0aGlzLmhvc3RDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuaG9zdENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaG9zdENsaWNrTGlzdGVuZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5pZ25vcmVkRWxlbWVudENsaWNrTGlzdGVuZXIoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWdub3JlZEVsZW1lbnRDbGlja0xpc3RlbmVyO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5jb25zdCBlbnVtIERhdGVwaWNrZXJWaWV3RW51bSB7XG4gIE1PTlRIVklFVyA9ICdNT05USFZJRVcnLFxuICBZRUFSVklFVyA9ICdZRUFSVklFVycsXG4gIERBWVZJRVcgPSAnREFZVklFVycsXG59XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIG1hbmFnZXMgd2hpY2ggdmlldyBpcyB2aXNpYmxlIGluIHRoZSBkYXRlcGlja2VyIHBvcG92ZXIuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWaWV3TWFuYWdlclNlcnZpY2Uge1xuICBwcml2YXRlIF9jdXJyZW50VmlldzogRGF0ZXBpY2tlclZpZXdFbnVtID0gRGF0ZXBpY2tlclZpZXdFbnVtLkRBWVZJRVc7XG5cbiAgZ2V0IGlzRGF5VmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFZpZXcgPT09IERhdGVwaWNrZXJWaWV3RW51bS5EQVlWSUVXO1xuICB9XG5cbiAgZ2V0IGlzWWVhclZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBEYXRlcGlja2VyVmlld0VudW0uWUVBUlZJRVc7XG4gIH1cblxuICBnZXQgaXNNb250aFZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaWV3ID09PSBEYXRlcGlja2VyVmlld0VudW0uTU9OVEhWSUVXO1xuICB9XG5cbiAgY2hhbmdlVG9Nb250aFZpZXcoKTogdm9pZCB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSBEYXRlcGlja2VyVmlld0VudW0uTU9OVEhWSUVXO1xuICB9XG5cbiAgY2hhbmdlVG9ZZWFyVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IERhdGVwaWNrZXJWaWV3RW51bS5ZRUFSVklFVztcbiAgfVxuXG4gIGNoYW5nZVRvRGF5VmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IERhdGVwaWNrZXJWaWV3RW51bS5EQVlWSUVXO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFic3RyYWN0UG9wb3ZlciB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL2Fic3RyYWN0LXBvcG92ZXInO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcblxuaW1wb3J0IHsgRGF0ZXBpY2tlckZvY3VzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBWaWV3TWFuYWdlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92aWV3LW1hbmFnZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kYXRlcGlja2VyLXZpZXctbWFuYWdlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRlcGlja2VyLXZpZXctbWFuYWdlci5odG1sJyxcbiAgcHJvdmlkZXJzOiBbVmlld01hbmFnZXJTZXJ2aWNlLCBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlXSxcbiAgaG9zdDogeyAnW2NsYXNzLmRhdGVwaWNrZXJdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVwaWNrZXJWaWV3TWFuYWdlciBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKEBTa2lwU2VsZigpIHBhcmVudDogRWxlbWVudFJlZiwgX2luamVjdG9yOiBJbmplY3RvciwgcHJpdmF0ZSBfdmlld01hbmFnZXJTZXJ2aWNlOiBWaWV3TWFuYWdlclNlcnZpY2UpIHtcbiAgICBzdXBlcihfaW5qZWN0b3IsIHBhcmVudCk7XG4gICAgdGhpcy5jb25maWd1cmVQb3BvdmVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlIFBvcG92ZXIgRGlyZWN0aW9uIGFuZCBDbG9zZSBpbmRpY2F0b3JzXG4gICAqL1xuICBwcml2YXRlIGNvbmZpZ3VyZVBvcG92ZXIoKTogdm9pZCB7XG4gICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBjdXJyZW50IHZpZXcgaXMgdGhlIG1vbnRocGlja2VyLlxuICAgKi9cbiAgZ2V0IGlzTW9udGhWaWV3KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuaXNNb250aFZpZXc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgY3VycmVudCB2aWV3IGlzIHRoZSB5ZWFycGlja2VyLlxuICAgKi9cbiAgZ2V0IGlzWWVhclZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5pc1llYXJWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGN1cnJlbnQgdmlldyBpcyB0aGUgZGF5cGlja2VyLlxuICAgKi9cbiAgZ2V0IGlzRGF5VmlldygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld01hbmFnZXJTZXJ2aWNlLmlzRGF5VmlldztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBEYXlWaWV3TW9kZWwgfSBmcm9tICcuL21vZGVsL2RheS12aWV3Lm1vZGVsJztcbmltcG9ydCB7IERheU1vZGVsIH0gZnJvbSAnLi9tb2RlbC9kYXkubW9kZWwnO1xuaW1wb3J0IHsgRGF0ZUZvcm1Db250cm9sU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtZm9ybS1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGF5JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3M9XCJkYXktYnRuXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgW2NsYXNzLmlzLXRvZGF5XT1cImRheVZpZXcuaXNUb2RheXNEYXRlXCJcbiAgICAgICAgICAgIFtjbGFzcy5pcy1kaXNhYmxlZF09XCJkYXlWaWV3LmlzRGlzYWJsZWRcIlxuICAgICAgICAgICAgW2NsYXNzLmlzLXNlbGVjdGVkXT1cImRheVZpZXcuaXNTZWxlY3RlZFwiXG4gICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJkYXlWaWV3LnRhYkluZGV4XCJcbiAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3REYXkoKVwiXG4gICAgICAgICAgICAoZm9jdXMpPVwib25EYXlWaWV3Rm9jdXMoKVwiPlxuICAgICAgICAgICAge3tkYXlWaWV3LmRheU1vZGVsLmRhdGV9fVxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuZGF5XSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXkge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9pZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgZGF0ZUZvcm1Db250cm9sU2VydmljZTogRGF0ZUZvcm1Db250cm9sU2VydmljZVxuICApIHt9XG5cbiAgLyoqXG4gICAqIERheVZpZXdNb2RlbCBpbnB1dCB3aGljaCBpcyB1c2VkIHRvIGJ1aWxkIHRoZSBEYXkgVmlldy5cbiAgICovXG4gIEBJbnB1dCgnY2xyRGF5VmlldycpIGRheVZpZXc6IERheVZpZXdNb2RlbDtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZm9jdXNlZERheSBpbiB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHdoZW4gdGhlIENsckRheSBpcyBmb2N1c2VkLlxuICAgKi9cbiAgb25EYXlWaWV3Rm9jdXMoKSB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmZvY3VzZWREYXkgPSB0aGlzLmRheVZpZXcuZGF5TW9kZWw7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc2VsZWN0ZWREYXkgd2hlbiB0aGUgQ2xyRGF5IGlzIHNlbGVjdGVkIGFuZCBjbG9zZXMgdGhlIGRhdGVwaWNrZXIgcG9wb3Zlci5cbiAgICovXG4gIHNlbGVjdERheSgpOiB2b2lkIHtcbiAgICBjb25zdCBkYXk6IERheU1vZGVsID0gdGhpcy5kYXlWaWV3LmRheU1vZGVsO1xuICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5ub3RpZnlTZWxlY3RlZERheUNoYW5nZWQoZGF5KTtcbiAgICB0aGlzLmRhdGVGb3JtQ29udHJvbFNlcnZpY2UubWFya0FzRGlydHkoKTtcbiAgICB0aGlzLl9pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IExvY2FsZUhlbHBlclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9sb2NhbGUtaGVscGVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7IHNlbGVjdG9yOiAnY2xyLWRheXBpY2tlcicsIHRlbXBsYXRlVXJsOiAnLi9kYXlwaWNrZXIuaHRtbCcsIGhvc3Q6IHsgJ1tjbGFzcy5kYXlwaWNrZXJdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJEYXlwaWNrZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF92aWV3TWFuYWdlclNlcnZpY2U6IFZpZXdNYW5hZ2VyU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9sb2NhbGVIZWxwZXJTZXJ2aWNlOiBMb2NhbGVIZWxwZXJTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge31cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIFZpZXdNYW5hZ2VyU2VydmljZSB0byBjaGFuZ2UgdG8gdGhlIG1vbnRocGlja2VyIHZpZXcuXG4gICAqL1xuICBjaGFuZ2VUb01vbnRoVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuY2hhbmdlVG9Nb250aFZpZXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgVmlld01hbmFnZXJTZXJ2aWNlIHRvIGNoYW5nZSB0byB0aGUgeWVhcnBpY2tlciB2aWV3LlxuICAgKi9cbiAgY2hhbmdlVG9ZZWFyVmlldygpOiB2b2lkIHtcbiAgICB0aGlzLl92aWV3TWFuYWdlclNlcnZpY2UuY2hhbmdlVG9ZZWFyVmlldygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vbnRoIHZhbHVlIG9mIHRoZSBjYWxlbmRhciBpbiB0aGUgVHJhbnNsYXRpb25XaWR0aC5BYmJyZXZpYXRlZCBmb3JtYXQuXG4gICAqL1xuICBnZXQgY2FsZW5kYXJNb250aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGVIZWxwZXJTZXJ2aWNlLmxvY2FsZU1vbnRoc0FiYnJldmlhdGVkW3RoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhci5tb250aF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgeWVhciB2YWx1ZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAqL1xuICBnZXQgY2FsZW5kYXJZZWFyKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5kaXNwbGF5ZWRDYWxlbmRhci55ZWFyO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gbW92ZSB0byB0aGUgbmV4dCBtb250aC5cbiAgICovXG4gIG5leHRNb250aCgpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UubW92ZVRvTmV4dE1vbnRoKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgdGhlIERhdGVOYXZpZ2F0aW9uU2VydmljZSB0byBtb3ZlIHRvIHRoZSBwcmV2aW91cyBtb250aC5cbiAgICovXG4gIHByZXZpb3VzTW9udGgoKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLm1vdmVUb1ByZXZpb3VzTW9udGgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyB0aGUgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIHRvIG1vdmUgdG8gdGhlIGN1cnJlbnQgbW9udGguXG4gICAqL1xuICBjdXJyZW50TW9udGgoKTogdm9pZCB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLm1vdmVUb0N1cnJlbnRNb250aCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBET1dOX0FSUk9XLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICcuLi8uLi91dGlscy9rZXktY29kZXMva2V5LWNvZGVzJztcblxuaW1wb3J0IHsgRGF0ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGF0ZS1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZXBpY2tlckZvY3VzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGVwaWNrZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBMb2NhbGVIZWxwZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbG9jYWxlLWhlbHBlci5zZXJ2aWNlJztcbmltcG9ydCB7IFZpZXdNYW5hZ2VyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZpZXctbWFuYWdlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLW1vbnRocGlja2VyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImNhbGVuZGFyLWJ0biBtb250aFwiXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgbW9udGggb2YgbW9udGhOYW1lczsgbGV0IG1vbnRoSW5kZXggPSBpbmRleFwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2hhbmdlTW9udGgobW9udGhJbmRleClcIlxuICAgICAgICAgICAgW2NsYXNzLmlzLXNlbGVjdGVkXT1cIm1vbnRoSW5kZXggPT09IGNhbGVuZGFyTW9udGhJbmRleFwiXG4gICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJnZXRUYWJJbmRleChtb250aEluZGV4KVwiPlxuICAgICAgICAgICAge3ttb250aH19XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLm1vbnRocGlja2VyXSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTW9udGhwaWNrZXIgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfdmlld01hbmFnZXJTZXJ2aWNlOiBWaWV3TWFuYWdlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbG9jYWxlSGVscGVyU2VydmljZTogTG9jYWxlSGVscGVyU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlTmF2aWdhdGlvblNlcnZpY2U6IERhdGVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICBwcml2YXRlIF9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlOiBEYXRlcGlja2VyRm9jdXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2VsUmVmOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID0gdGhpcy5jYWxlbmRhck1vbnRoSW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZm9jdXNlZCBtb250aC5cbiAgICovXG4gIHByaXZhdGUgX2ZvY3VzZWRNb250aEluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1vbnRocyBhcnJheSB3aGljaCBpcyB1c2VkIHRvIHJlbmRlcmVkIHRoZSBtb250aHBpY2tlciB2aWV3LlxuICAgKiBNb250aHMgYXJlIGluIHRoZSBUcmFuc2xhdGlvbldpZHRoLldpZGUgZm9ybWF0LlxuICAgKi9cbiAgZ2V0IG1vbnRoTmFtZXMoKTogUmVhZG9ubHlBcnJheTxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlSGVscGVyU2VydmljZS5sb2NhbGVNb250aHNXaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1vbnRoIHZhbHVlIG9mIHRoZSBDYWxlbmRhci5cbiAgICovXG4gIGdldCBjYWxlbmRhck1vbnRoSW5kZXgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmRpc3BsYXllZENhbGVuZGFyLm1vbnRoO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gdXBkYXRlIHRoZSBtb250aCB2YWx1ZSBvZiB0aGUgY2FsZW5kYXIuXG4gICAqIEFsc28gY2hhbmdlcyB0aGUgdmlldyB0byB0aGUgZGF5cGlja2VyLlxuICAgKi9cbiAgY2hhbmdlTW9udGgobW9udGhJbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5fZGF0ZU5hdmlnYXRpb25TZXJ2aWNlLmNoYW5nZU1vbnRoKG1vbnRoSW5kZXgpO1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb0RheVZpZXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGUgbW9udGggcGFzc2VkIHRvIHRoZSBmb2N1c2VkIG1vbnRoIGFuZCByZXR1cm5zIHRoZSB0YWIgaW5kZXguXG4gICAqL1xuICBnZXRUYWJJbmRleChtb250aEluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBtb250aEluZGV4ID09PSB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA/IDAgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBLZXlib2FyZCBhcnJvdyBuYXZpZ2F0aW9uIGZvciB0aGUgbW9udGhwaWNrZXIuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgb25LZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgLy8gTk9URTogRGlkbid0IG1vdmUgdGhpcyB0byB0aGUgZGF0ZSBuYXZpZ2F0aW9uIHNlcnZpY2UgYmVjYXVzZVxuICAgIC8vIHRoZSBsb2dpYyBpcyBmYWlybHkgc2ltcGxlIGFuZCBpdCBkaWRuJ3QgbWFrZSBzZW5zZSBmb3IgbWVcbiAgICAvLyB0byBjcmVhdGUgZXh0cmEgb2JzZXJ2YWJsZXMganVzdCB0byBtb3ZlIHRoaXMgbG9naWMgdG8gdGhlIHNlcnZpY2UuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb25zdCBrZXlDb2RlOiBudW1iZXIgPSBldmVudC5rZXlDb2RlO1xuICAgICAgaWYgKGtleUNvZGUgPT09IFVQX0FSUk9XICYmIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID4gMCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleC0tO1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IERPV05fQVJST1cgJiYgdGhpcy5fZm9jdXNlZE1vbnRoSW5kZXggPCAxMSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCsrO1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IFJJR0hUX0FSUk9XICYmIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4IDwgNikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA9IHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ICsgNjtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBMRUZUX0FSUk9XICYmIHRoaXMuX2ZvY3VzZWRNb250aEluZGV4ID4gNSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9mb2N1c2VkTW9udGhJbmRleCA9IHRoaXMuX2ZvY3VzZWRNb250aEluZGV4IC0gNjtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1c2VzIG9uIHRoZSBjdXJyZW50IGNhbGVuZGFyIG1vbnRoIHdoZW4gdGhlIFZpZXcgaXMgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmNvbnN0IFlFQVJTX1RPX0RJU1BMQVk6IG51bWJlciA9IDEwO1xuXG5leHBvcnQgY2xhc3MgWWVhclJhbmdlTW9kZWwge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHllYXI6IG51bWJlcikge1xuICAgIHRoaXMuZ2VuZXJhdGVZZWFyUmFuZ2UoKTtcbiAgfVxuXG4gIHllYXJSYW5nZTogbnVtYmVyW10gPSBbXTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIGluIHRoZSBtaWRkbGUgb2YgdGhlIHJhbmdlLlxuICAgKi9cbiAgZ2V0IG1pZGRsZVllYXIoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyUmFuZ2VbTWF0aC5mbG9vcih0aGlzLnllYXJSYW5nZS5sZW5ndGggLyAyKV07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSB5ZWFyIHJhbmdlIGJhc2VkIG9uIHRoZSB5ZWFyIHBhcmFtZXRlci5cbiAgICogZWc6IElmIDIwMTggaXMgcGFzc2VkIHRoZSBvdXRwdXQgd2lsbCBiZSBbMjAxMCwgMjAxMSwgLi4uLCAyMDE5XVxuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVllYXJSYW5nZSgpIHtcbiAgICBjb25zdCByZW1haW5kZXI6IG51bWJlciA9IHRoaXMueWVhciAlIFlFQVJTX1RPX0RJU1BMQVk7XG4gICAgY29uc3QgZmxvb3I6IG51bWJlciA9IHRoaXMueWVhciAtIHJlbWFpbmRlcjtcbiAgICBjb25zdCBjZWlsOiBudW1iZXIgPSBmbG9vciArIFlFQVJTX1RPX0RJU1BMQVk7XG4gICAgdGhpcy55ZWFyUmFuZ2UgPSB0aGlzLmdlbmVyYXRlUmFuZ2UoZmxvb3IsIGNlaWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlIGEgcmFuZ2Ugb2YgbnVtYmVycyBmcm9tIGZsb29yIHRvIGNlaWwuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlUmFuZ2UoZmxvb3I6IG51bWJlciwgY2VpbDogbnVtYmVyKTogbnVtYmVyW10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjZWlsIC0gZmxvb3IgfSwgKHYsIGspID0+IGsgKyBmbG9vcik7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCBmb3IgdGhlIG5leHQgZGVjYWRlLlxuICAgKi9cbiAgbmV4dERlY2FkZSgpOiBZZWFyUmFuZ2VNb2RlbCB7XG4gICAgcmV0dXJuIG5ldyBZZWFyUmFuZ2VNb2RlbCh0aGlzLnllYXIgKyAxMCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCBmb3IgdGhlIHByZXZpb3VzIGRlY2FkZS5cbiAgICovXG4gIHByZXZpb3VzRGVjYWRlKCk6IFllYXJSYW5nZU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IFllYXJSYW5nZU1vZGVsKHRoaXMueWVhciAtIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGZvciB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqL1xuICBjdXJyZW50RGVjYWRlKCk6IFllYXJSYW5nZU1vZGVsIHtcbiAgICByZXR1cm4gbmV3IFllYXJSYW5nZU1vZGVsKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBpbiB0aGUgWWVhclJhbmdlTW9kZWwuXG4gICAqL1xuICBpblJhbmdlKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyUmFuZ2UuaW5kZXhPZih2YWx1ZSkgPiAtMTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRE9XTl9BUlJPVywgTEVGVF9BUlJPVywgUklHSFRfQVJST1csIFVQX0FSUk9XIH0gZnJvbSAnLi4vLi4vdXRpbHMva2V5LWNvZGVzL2tleS1jb2Rlcyc7XG5cbmltcG9ydCB7IFllYXJSYW5nZU1vZGVsIH0gZnJvbSAnLi9tb2RlbC95ZWFyLXJhbmdlLm1vZGVsJztcbmltcG9ydCB7IERhdGVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RhdGUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kYXRlcGlja2VyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmlld01hbmFnZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmlldy1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXllYXJwaWNrZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwieWVhci1zd2l0Y2hlcnNcIj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJjYWxlbmRhci1idG4gc3dpdGNoZXJcIiB0eXBlPVwiYnV0dG9uXCIgKGNsaWNrKT1cInByZXZpb3VzRGVjYWRlKClcIj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJhbmdsZVwiIGRpcj1cImxlZnRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLnByZXZpb3VzXCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImNhbGVuZGFyLWJ0biBzd2l0Y2hlclwiIHR5cGU9XCJidXR0b25cIiAoY2xpY2spPVwiY3VycmVudERlY2FkZSgpXCI+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZXZlbnRcIiBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLmN1cnJlbnRcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY2FsZW5kYXItYnRuIHN3aXRjaGVyXCIgdHlwZT1cImJ1dHRvblwiIChjbGljayk9XCJuZXh0RGVjYWRlKClcIj5cbiAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJhbmdsZVwiIGRpcj1cInJpZ2h0XCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5uZXh0XCI+PC9jbHItaWNvbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInllYXJzXCI+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IHllYXIgb2YgeWVhclJhbmdlTW9kZWwueWVhclJhbmdlXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImNhbGVuZGFyLWJ0biB5ZWFyXCJcbiAgICAgICAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJnZXRUYWJJbmRleCh5ZWFyKVwiXG4gICAgICAgICAgICAgICAgW2NsYXNzLmlzLXNlbGVjdGVkXT1cInllYXIgPT09IGNhbGVuZGFyWWVhclwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImNoYW5nZVllYXIoeWVhcilcIj5cbiAgICAgICAgICAgICAgICB7e3llYXJ9fVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnllYXJwaWNrZXJdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJZZWFycGlja2VyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2RhdGVOYXZpZ2F0aW9uU2VydmljZTogRGF0ZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX3ZpZXdNYW5hZ2VyU2VydmljZTogVmlld01hbmFnZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgX2RhdGVwaWNrZXJGb2N1c1NlcnZpY2U6IERhdGVwaWNrZXJGb2N1c1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBfZWxSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7XG4gICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IG5ldyBZZWFyUmFuZ2VNb2RlbCh0aGlzLmNhbGVuZGFyWWVhcik7XG4gICAgdGhpcy5fZm9jdXNlZFllYXIgPSB0aGlzLmNhbGVuZGFyWWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBZZWFyUmFuZ2VNb2RlbCB3aGljaCBpcyB1c2VkIHRvIGJ1aWxkIHRoZSBZZWFyUGlja2VyIHZpZXcuXG4gICAqL1xuICB5ZWFyUmFuZ2VNb2RlbDogWWVhclJhbmdlTW9kZWw7XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGZvY3VzZWQgeWVhci5cbiAgICovXG4gIHByaXZhdGUgX2ZvY3VzZWRZZWFyOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHllYXIgd2hpY2ggdGhlIHVzZXIgaXMgY3VycmVudGx5IG9uLlxuICAgKi9cbiAgZ2V0IGNhbGVuZGFyWWVhcigpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9kYXRlTmF2aWdhdGlvblNlcnZpY2UuZGlzcGxheWVkQ2FsZW5kYXIueWVhcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBmb2N1cyB5ZWFyIGJ5IHRoZSB2YWx1ZSBwYXNzZWQuIFVwZGF0ZXMgdGhlIFllYXJSYW5nZU1vZGVsIGlmIHRoZVxuICAgKiBuZXcgdmFsdWUgaXMgbm90IGluIHRoZSBjdXJyZW50IGRlY2FkZS5cbiAgICovXG4gIHByaXZhdGUgaW5jcmVtZW50Rm9jdXNZZWFyQnkodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2ZvY3VzZWRZZWFyID0gdGhpcy5fZm9jdXNlZFllYXIgKyB2YWx1ZTtcbiAgICBpZiAoIXRoaXMueWVhclJhbmdlTW9kZWwuaW5SYW5nZSh0aGlzLl9mb2N1c2VkWWVhcikpIHtcbiAgICAgIGlmICh2YWx1ZSA+IDApIHtcbiAgICAgICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwubmV4dERlY2FkZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwucHJldmlvdXNEZWNhZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBEYXRlTmF2aWdhdGlvblNlcnZpY2UgdG8gdXBkYXRlIHRoZSB5ZWFyIHZhbHVlIG9mIHRoZSBjYWxlbmRhci5cbiAgICogQWxzbyBjaGFuZ2VzIHRoZSB2aWV3IHRvIHRoZSBkYXlwaWNrZXIuXG4gICAqL1xuICBjaGFuZ2VZZWFyKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS5jaGFuZ2VZZWFyKHllYXIpO1xuICAgIHRoaXMuX3ZpZXdNYW5hZ2VyU2VydmljZS5jaGFuZ2VUb0RheVZpZXcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCB0byB0aGUgcHJldmlvdXMgZGVjYWRlLlxuICAgKi9cbiAgcHJldmlvdXNEZWNhZGUoKTogdm9pZCB7XG4gICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwucHJldmlvdXNEZWNhZGUoKTtcbiAgICAvLyBZZWFyIGluIHRoZSB5ZWFycGlja2VyIGlzIG5vdCBmb2N1c2VkIGJlY2F1c2Ugd2hpbGUgbmF2aWdhdGluZyB0byBhIGRpZmZlcmVudCBkZWNhZGUsXG4gICAgLy8geW91IHdhbnQgdGhlIGZvY3VzIHRvIHJlbWFpbiBvbiB0aGUgZGVjYWRlIHN3aXRjaGVyIGFycm93cy5cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBZZWFyUmFuZ2VNb2RlbCB0byB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqL1xuICBjdXJyZW50RGVjYWRlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy55ZWFyUmFuZ2VNb2RlbC5pblJhbmdlKHRoaXMuX2RhdGVOYXZpZ2F0aW9uU2VydmljZS50b2RheS55ZWFyKSkge1xuICAgICAgdGhpcy55ZWFyUmFuZ2VNb2RlbCA9IHRoaXMueWVhclJhbmdlTW9kZWwuY3VycmVudERlY2FkZSgpO1xuICAgIH1cbiAgICB0aGlzLl9kYXRlcGlja2VyRm9jdXNTZXJ2aWNlLmZvY3VzQ2VsbCh0aGlzLl9lbFJlZik7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgWWVhclJhbmdlTW9kZWwgdG8gdGhlIG5leHQgZGVjYWRlLlxuICAgKi9cbiAgbmV4dERlY2FkZSgpOiB2b2lkIHtcbiAgICB0aGlzLnllYXJSYW5nZU1vZGVsID0gdGhpcy55ZWFyUmFuZ2VNb2RlbC5uZXh0RGVjYWRlKCk7XG4gICAgLy8gWWVhciBpbiB0aGUgeWVhcnBpY2tlciBpcyBub3QgZm9jdXNlZCBiZWNhdXNlIHdoaWxlIG5hdmlnYXRpbmcgdG8gYSBkaWZmZXJlbnQgZGVjYWRlLFxuICAgIC8vIHlvdSB3YW50IHRoZSBmb2N1cyB0byByZW1haW4gb24gdGhlIGRlY2FkZSBzd2l0Y2hlciBhcnJvd3MuXG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdGhlIHllYXIgcGFzc2VkIHRvIHRoZSBmb2N1c2VkIHllYXIgYW5kIHJldHVybnMgdGhlIHRhYiBpbmRleC5cbiAgICovXG4gIGdldFRhYkluZGV4KHllYXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLnllYXJSYW5nZU1vZGVsLmluUmFuZ2UodGhpcy5fZm9jdXNlZFllYXIpKSB7XG4gICAgICBpZiAodGhpcy55ZWFyUmFuZ2VNb2RlbC5pblJhbmdlKHRoaXMuY2FsZW5kYXJZZWFyKSkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkWWVhciA9IHRoaXMuY2FsZW5kYXJZZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZFllYXIgPSB0aGlzLnllYXJSYW5nZU1vZGVsLm1pZGRsZVllYXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mb2N1c2VkWWVhciA9PT0geWVhciA/IDAgOiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBLZXlib2FyZCBhcnJvdyBuYXZpZ2F0aW9uIGZvciB0aGUgeWVhcnBpY2tlci5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAvLyBOT1RFOiBEaWRuJ3QgbW92ZSB0aGlzIHRvIHRoZSBkYXRlIG5hdmlnYXRpb24gc2VydmljZSBiZWNhdXNlXG4gICAgLy8gdGhlIGxvZ2ljIGlzIGZhaXJseSBzaW1wbGUgYW5kIGl0IGRpZG4ndCBtYWtlIHNlbnNlIGZvciBtZVxuICAgIC8vIHRvIGNyZWF0ZSBleHRyYSBvYnNlcnZhYmxlcyBqdXN0IHRvIG1vdmUgdGhpcyBsb2dpYyB0byB0aGUgc2VydmljZS5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGtleUNvZGU6IG51bWJlciA9IGV2ZW50LmtleUNvZGU7XG4gICAgICBpZiAoa2V5Q29kZSA9PT0gVVBfQVJST1cpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c1llYXJCeSgtMSk7XG4gICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IERPV05fQVJST1cpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c1llYXJCeSgxKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gUklHSFRfQVJST1cpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRGb2N1c1llYXJCeSg1KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0gTEVGVF9BUlJPVykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmluY3JlbWVudEZvY3VzWWVhckJ5KC01KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyBvbiB0aGUgY3VycmVudCBjYWxlbmRhciB5ZWFyIHdoZW4gdGhlIFZpZXcgaXMgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5fZGF0ZXBpY2tlckZvY3VzU2VydmljZS5mb2N1c0NlbGwodGhpcy5fZWxSZWYpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJGb2N1c1RyYXBNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAubW9kdWxlJztcbmltcG9ydCB7IENsckhvc3RXcmFwcGluZ01vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvaG9zdC13cmFwcGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uRm9ybXNNb2R1bGUgfSBmcm9tICcuLi9jb21tb24vY29tbW9uLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckNhbGVuZGFyIH0gZnJvbSAnLi9jYWxlbmRhcic7XG5pbXBvcnQgeyBDbHJEYXRlQ29udGFpbmVyIH0gZnJvbSAnLi9kYXRlLWNvbnRhaW5lcic7XG5pbXBvcnQgeyBDbHJEYXRlSW5wdXQgfSBmcm9tICcuL2RhdGUtaW5wdXQnO1xuaW1wb3J0IHsgQ2xyRGF0ZXBpY2tlclZpZXdNYW5hZ2VyIH0gZnJvbSAnLi9kYXRlcGlja2VyLXZpZXctbWFuYWdlcic7XG5pbXBvcnQgeyBDbHJEYXkgfSBmcm9tICcuL2RheSc7XG5pbXBvcnQgeyBDbHJEYXlwaWNrZXIgfSBmcm9tICcuL2RheXBpY2tlcic7XG5pbXBvcnQgeyBDbHJNb250aHBpY2tlciB9IGZyb20gJy4vbW9udGhwaWNrZXInO1xuaW1wb3J0IHsgQ2xyWWVhcnBpY2tlciB9IGZyb20gJy4veWVhcnBpY2tlcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfREFURVBJQ0tFUl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyRGF5LFxuICBDbHJEYXRlQ29udGFpbmVyLFxuICBDbHJEYXRlSW5wdXQsXG4gIENsckRhdGVwaWNrZXJWaWV3TWFuYWdlcixcbiAgQ2xyTW9udGhwaWNrZXIsXG4gIENsclllYXJwaWNrZXIsXG4gIENsckRheXBpY2tlcixcbiAgQ2xyQ2FsZW5kYXIsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIENsckhvc3RXcmFwcGluZ01vZHVsZSxcbiAgICBDbHJDb25kaXRpb25hbE1vZHVsZSxcbiAgICBDbHJJY29uTW9kdWxlLFxuICAgIENsckZvY3VzVHJhcE1vZHVsZSxcbiAgICBDbHJDb21tb25Gb3Jtc01vZHVsZSxcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0RBVEVQSUNLRVJfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfREFURVBJQ0tFUl9ESVJFQ1RJVkVTXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyRGF0ZUNvbnRhaW5lcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGVwaWNrZXJNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWlucHV0LWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLWlucHV0LXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xySW5wdXRdXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2xdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZF0nOiAnY29udHJvbD8uZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbSWZFcnJvclNlcnZpY2UsIE5nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xJZFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJJbnB1dENvbnRhaW5lciBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGludmFsaWQgPSBmYWxzZTtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpKTtcbiAgfVxuXG4gIGFkZEdyaWQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0U2VydmljZSAmJiAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYsIFJlbmRlcmVyMiwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xySW5wdXRDb250YWluZXIgfSBmcm9tICcuL2lucHV0LWNvbnRhaW5lcic7XG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklucHV0XScsIGhvc3Q6IHsgJ1tjbGFzcy5jbHItaW5wdXRdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJJbnB1dCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJJbnB1dENvbnRhaW5lcj4ge1xuICBwcm90ZWN0ZWQgaW5kZXggPSAxO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgY29udHJvbDogTmdDb250cm9sLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgZWw6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgc3VwZXIodmNyLCBDbHJJbnB1dENvbnRhaW5lciwgaW5qZWN0b3IsIGNvbnRyb2wsIHJlbmRlcmVyLCBlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJJbnB1dCB9IGZyb20gJy4vaW5wdXQnO1xuaW1wb3J0IHsgQ2xySW5wdXRDb250YWluZXIgfSBmcm9tICcuL2lucHV0LWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NscklucHV0LCBDbHJJbnB1dENvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xySW5wdXQsIENscklucHV0Q29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xySW5wdXRDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJJbnB1dE1vZHVsZSB7fVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcbmltcG9ydCB7IENvbnRyb2xJZFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtaWQuc2VydmljZSc7XG5pbXBvcnQgeyBGb2N1c1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2ZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbmV4cG9ydCBjb25zdCBUT0dHTEVfU0VSVklDRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4+KHVuZGVmaW5lZCk7XG5leHBvcnQgZnVuY3Rpb24gVG9nZ2xlU2VydmljZUZhY3RvcnkoKSB7XG4gIHJldHVybiBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbn1cbmV4cG9ydCBjb25zdCBUT0dHTEVfU0VSVklDRV9QUk9WSURFUiA9IHsgcHJvdmlkZTogVE9HR0xFX1NFUlZJQ0UsIHVzZUZhY3Rvcnk6IFRvZ2dsZVNlcnZpY2VGYWN0b3J5IH07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1wYXNzd29yZC1jb250YWluZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgIDxsYWJlbCAqbmdJZj1cIiFsYWJlbCAmJiBhZGRHcmlkKClcIj48L2xhYmVsPlxuICAgIDxkaXYgY2xhc3M9XCJjbHItY29udHJvbC1jb250YWluZXJcIiBbbmdDbGFzc109XCJjb250cm9sQ2xhc3MoKVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNsci1pbnB1dC13cmFwcGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjbHItaW5wdXQtZ3JvdXBcIiBbY2xhc3MuY2xyLWZvY3VzXT1cImZvY3VzXCI+XG4gICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclBhc3N3b3JkXVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAqbmdJZj1cImNsclRvZ2dsZVwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlKClcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImNvbnRyb2w/LmRpc2FibGVkXCJcbiAgICAgICAgICAgIGNsYXNzPVwiY2xyLWlucHV0LWdyb3VwLWljb24tYWN0aW9uXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgIDxjbHItaWNvblxuICAgICAgICAgICAgW2F0dHIuc2hhcGVdPVwic2hvdyA/ICdleWUtaGlkZScgOiAnZXllJ1wiXG4gICAgICAgICAgICBbYXR0ci50aXRsZV09XCJzaG93ID8gY29tbW9uU3RyaW5ncy5oaWRlIDogY29tbW9uU3RyaW5ncy5zaG93XCI+PC9jbHItaWNvbj5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgPC9kaXY+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtcbiAgICBJZkVycm9yU2VydmljZSxcbiAgICBOZ0NvbnRyb2xTZXJ2aWNlLFxuICAgIENvbnRyb2xJZFNlcnZpY2UsXG4gICAgQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBGb2N1c1NlcnZpY2UsXG4gICAgVE9HR0xFX1NFUlZJQ0VfUFJPVklERVIsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsclBhc3N3b3JkQ29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG4gIF9keW5hbWljID0gZmFsc2U7XG4gIHNob3cgPSBmYWxzZTtcbiAgZm9jdXMgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfdG9nZ2xlID0gdHJ1ZTtcblxuICBASW5wdXQoJ2NsclRvZ2dsZScpXG4gIHNldCBjbHJUb2dnbGUoc3RhdGU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl90b2dnbGUgPSBzdGF0ZTtcbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNsclRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9nZ2xlO1xuICB9XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGlmRXJyb3JTZXJ2aWNlOiBJZkVycm9yU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGxheW91dFNlcnZpY2U6IExheW91dFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb250cm9sQ2xhc3NTZXJ2aWNlOiBDb250cm9sQ2xhc3NTZXJ2aWNlLFxuICAgIHB1YmxpYyBmb2N1c1NlcnZpY2U6IEZvY3VzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2UsXG4gICAgQEluamVjdChUT0dHTEVfU0VSVklDRSkgcHJpdmF0ZSB0b2dnbGVTZXJ2aWNlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4sXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNDaGFuZ2Uuc3Vic2NyaWJlKHN0YXRlID0+IHtcbiAgICAgICAgdGhpcy5mb2N1cyA9IHN0YXRlO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnNob3cgPSAhdGhpcy5zaG93O1xuICAgIHRoaXMudG9nZ2xlU2VydmljZS5uZXh0KHRoaXMuc2hvdyk7XG4gIH1cblxuICBjb250cm9sQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbENsYXNzU2VydmljZS5jb250cm9sQ2xhc3ModGhpcy5pbnZhbGlkLCB0aGlzLmFkZEdyaWQoKSk7XG4gIH1cblxuICBhZGRHcmlkKCkge1xuICAgIGlmICh0aGlzLmxheW91dFNlcnZpY2UgJiYgIXRoaXMubGF5b3V0U2VydmljZS5pc1ZlcnRpY2FsKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubWFwKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBSZW5kZXJlcjIsXG4gIFNlbGYsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsclBhc3N3b3JkQ29udGFpbmVyLCBUT0dHTEVfU0VSVklDRSB9IGZyb20gJy4vcGFzc3dvcmQtY29udGFpbmVyJztcbmltcG9ydCB7IFdyYXBwZWRGb3JtQ29udHJvbCB9IGZyb20gJy4uL2NvbW1vbi93cmFwcGVkLWNvbnRyb2wnO1xuaW1wb3J0IHsgRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9mb2N1cy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhc3N3b3JkXScsIGhvc3Q6IHsgJ1tjbGFzcy5jbHItaW5wdXRdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJQYXNzd29yZCBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJQYXNzd29yZENvbnRhaW5lcj4gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIHByb3RlY3RlZCBpbmRleCA9IDE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGZvY3VzU2VydmljZTogRm9jdXNTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChUT0dHTEVfU0VSVklDRSlcbiAgICBwcml2YXRlIHRvZ2dsZVNlcnZpY2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENsclBhc3N3b3JkQ29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcblxuICAgIGlmICghdGhpcy5mb2N1c1NlcnZpY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyUGFzc3dvcmQgcmVxdWlyZXMgYmVpbmcgd3JhcHBlZCBpbiA8Y2xyLXBhc3N3b3JkLWNvbnRhaW5lcj4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMudG9nZ2xlU2VydmljZS5zdWJzY3JpYmUodG9nZ2xlID0+IHtcbiAgICAgICAgcmVuZGVyZXIuc2V0UHJvcGVydHkoZWwubmF0aXZlRWxlbWVudCwgJ3R5cGUnLCB0b2dnbGUgPyAndGV4dCcgOiAncGFzc3dvcmQnKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgdHJpZ2dlckZvY3VzKCkge1xuICAgIGlmICh0aGlzLmZvY3VzU2VydmljZSkge1xuICAgICAgdGhpcy5mb2N1c1NlcnZpY2UuZm9jdXNlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignYmx1cicpXG4gIHRyaWdnZXJWYWxpZGF0aW9uKCkge1xuICAgIHN1cGVyLnRyaWdnZXJWYWxpZGF0aW9uKCk7XG4gICAgaWYgKHRoaXMuZm9jdXNTZXJ2aWNlKSB7XG4gICAgICB0aGlzLmZvY3VzU2VydmljZS5mb2N1c2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyUGFzc3dvcmQgfSBmcm9tICcuL3Bhc3N3b3JkJztcbmltcG9ydCB7IENsclBhc3N3b3JkQ29udGFpbmVyIH0gZnJvbSAnLi9wYXNzd29yZC1jb250YWluZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyQ29tbW9uRm9ybXNNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDbHJQYXNzd29yZCwgQ2xyUGFzc3dvcmRDb250YWluZXJdLFxuICBleHBvcnRzOiBbQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsclBhc3N3b3JkLCBDbHJQYXNzd29yZENvbnRhaW5lcl0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsclBhc3N3b3JkQ29udGFpbmVyXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyUGFzc3dvcmRNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmFkaW8td3JhcHBlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclJhZGlvXVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJsYWJlbFwiPjwvbmctY29udGVudD5cbiAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWxcIj48L2xhYmVsPlxuICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5jbHItcmFkaW8td3JhcHBlcl0nOiAndHJ1ZScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0NvbnRyb2xJZFNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJSYWRpb1dyYXBwZXIgaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgT25Jbml0IHtcbiAgLy8gV2UgbmVlZCBib3RoIF9keW5hbWljIGZvciBIb3N0V3JhcHBlciBhbmQgQ29udGVudENoaWxkKENsckxhYmVsKSBpbiBjYXNlcyB3aGVyZVxuICAvLyB0aGUgdXNlciBwdXRzIGEgcmFkaW8gaW5zaWRlIGEgd3JhcHBlciB3aXRob3V0IGEgbGFiZWwsIGhvc3Qgd3JhcHBpbmcgZG9lc24ndCBhcHBseVxuICAvLyBidXQgd2UnZCBzdGlsbCBuZWVkIHRvIGluc2VydCBhIGxhYmVsXG4gIF9keW5hbWljID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAodGhpcy5sYWJlbCkge1xuICAgICAgdGhpcy5sYWJlbC5kaXNhYmxlR3JpZCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgT3B0aW9uYWwsIFJlbmRlcmVyMiwgU2VsZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcbmltcG9ydCB7IENsclJhZGlvV3JhcHBlciB9IGZyb20gJy4uL3JhZGlvL3JhZGlvLXdyYXBwZXInO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUmFkaW9dJyB9KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvIGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsclJhZGlvV3JhcHBlcj4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIEBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgICByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIGVsOiBFbGVtZW50UmVmXG4gICkge1xuICAgIHN1cGVyKHZjciwgQ2xyUmFkaW9XcmFwcGVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJMYWJlbCB9IGZyb20gJy4uL2NvbW1vbi9sYWJlbCc7XG5pbXBvcnQgeyBDb250cm9sQ2xhc3NTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWNsYXNzLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXJhZGlvLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgPGxhYmVsICpuZ0lmPVwiIWxhYmVsICYmIGFkZEdyaWQoKVwiPjwvbGFiZWw+XG4gICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtjbGFzcy5jbHItY29udHJvbC1pbmxpbmVdPVwiY2xySW5saW5lXCIgW25nQ2xhc3NdPVwiY29udHJvbENsYXNzKClcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1yYWRpby13cmFwcGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGRpdiBjbGFzcz1cImNsci1zdWJ0ZXh0LXdyYXBwZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtaGVscGVyXCIgKm5nSWY9XCIhaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWVycm9yXCIgKm5nSWY9XCJpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5jbHItcm93XSc6ICdhZGRHcmlkKCknLFxuICB9LFxuICBwcm92aWRlcnM6IFtOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlLCBJZkVycm9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvQ29udGFpbmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBpbnZhbGlkID0gZmFsc2U7XG4gIEBDb250ZW50Q2hpbGQoQ2xyTGFiZWwpIGxhYmVsOiBDbHJMYWJlbDtcbiAgcHJpdmF0ZSBpbmxpbmUgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuXG4gIC8qXG4gICAqIEhlcmUgd2Ugd2FudCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmcgY2FzZXNcbiAgICogY2xySW5saW5lIC0gdHJ1ZSBieSBwcmVzZW5jZVxuICAgKiBjbHJJbmxpbmU9XCJ0cnVlfGZhbHNlXCIgLSB1bmxlc3MgaXQgaXMgZXhwbGljaXRseSBmYWxzZSwgc3RyaW5ncyBhcmUgY29uc2lkZXJlZCB0cnVlXG4gICAqIFtjbHJJbmxpbmVdPVwidHJ1ZXxmYWxzZVwiIC0gZXhwZWN0IGEgYm9vbGVhblxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGNscklubGluZSh2YWx1ZTogYm9vbGVhbiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmlubGluZSA9IHZhbHVlID09PSAnZmFsc2UnID8gZmFsc2UgOiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlubGluZSA9ICEhdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldCBjbHJJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5saW5lO1xuICB9XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpLCB0aGlzLmlubGluZSA/ICdjbHItY29udHJvbC1pbmxpbmUnIDogJycpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xySG9zdFdyYXBwaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9jb21tb24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyUmFkaW8gfSBmcm9tICcuL3JhZGlvJztcbmltcG9ydCB7IENsclJhZGlvQ29udGFpbmVyIH0gZnJvbSAnLi9yYWRpby1jb250YWluZXInO1xuaW1wb3J0IHsgQ2xyUmFkaW9XcmFwcGVyIH0gZnJvbSAnLi9yYWRpby13cmFwcGVyJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xyQ29tbW9uRm9ybXNNb2R1bGUsIENsckhvc3RXcmFwcGluZ01vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclJhZGlvLCBDbHJSYWRpb0NvbnRhaW5lciwgQ2xyUmFkaW9XcmFwcGVyXSxcbiAgZXhwb3J0czogW0NsckNvbW1vbkZvcm1zTW9kdWxlLCBDbHJSYWRpbywgQ2xyUmFkaW9Db250YWluZXIsIENsclJhZGlvV3JhcHBlcl0sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsclJhZGlvV3JhcHBlcl0sXG59KVxuZXhwb3J0IGNsYXNzIENsclJhZGlvTW9kdWxlIHt9XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElmRXJyb3JTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL2lmLWVycm9yL2lmLWVycm9yLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmdDb250cm9sU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbmctY29udHJvbC5zZXJ2aWNlJztcbmltcG9ydCB7IExheW91dFNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2xheW91dC5zZXJ2aWNlJztcbmltcG9ydCB7IER5bmFtaWNXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9keW5hbWljLXdyYXBwZXInO1xuaW1wb3J0IHsgQ29udHJvbElkU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1pZC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckxhYmVsIH0gZnJvbSAnLi4vY29tbW9uL2xhYmVsJztcbmltcG9ydCB7IENvbnRyb2xDbGFzc1NlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vcHJvdmlkZXJzL2NvbnRyb2wtY2xhc3Muc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zZWxlY3QtY29udGFpbmVyJyxcbiAgdGVtcGxhdGU6IGAgICAgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cIndyYXBwZXJDbGFzcygpXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiW2NsclNlbGVjdF1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2xyLXZhbGlkYXRlLWljb25cIiBzaGFwZT1cImV4Y2xhbWF0aW9uLWNpcmNsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1jb250cm9sLWhlbHBlclwiICpuZ0lmPVwiIWludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1lcnJvclwiICpuZ0lmPVwiaW52YWxpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItZm9ybS1jb250cm9sLWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG5cbiAgICAnW2NsYXNzLmNsci1yb3ddJzogJ2FkZEdyaWQoKScsXG4gIH0sXG4gIHByb3ZpZGVyczogW0lmRXJyb3JTZXJ2aWNlLCBOZ0NvbnRyb2xTZXJ2aWNlLCBDb250cm9sSWRTZXJ2aWNlLCBDb250cm9sQ2xhc3NTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU2VsZWN0Q29udGFpbmVyIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgaW52YWxpZCA9IGZhbHNlO1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAQ29udGVudENoaWxkKENsckxhYmVsKSBsYWJlbDogQ2xyTGFiZWw7XG4gIEBDb250ZW50Q2hpbGQoU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcikgbXVsdGlwbGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gIHByaXZhdGUgbXVsdGkgPSBmYWxzZTtcbiAgY29udHJvbDogTmdDb250cm9sO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaWZFcnJvclNlcnZpY2U6IElmRXJyb3JTZXJ2aWNlLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbGF5b3V0U2VydmljZTogTGF5b3V0U2VydmljZSxcbiAgICBwcml2YXRlIGNvbnRyb2xDbGFzc1NlcnZpY2U6IENvbnRyb2xDbGFzc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBuZ0NvbnRyb2xTZXJ2aWNlOiBOZ0NvbnRyb2xTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5pZkVycm9yU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMubmdDb250cm9sU2VydmljZS5jb250cm9sQ2hhbmdlcy5zdWJzY3JpYmUoY29udHJvbCA9PiB7XG4gICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgdGhpcy5tdWx0aSA9IGNvbnRyb2wudmFsdWVBY2Nlc3NvciBpbnN0YW5jZW9mIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgd3JhcHBlckNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpID8gJ2Nsci1tdWx0aXNlbGVjdC13cmFwcGVyJyA6ICdjbHItc2VsZWN0LXdyYXBwZXInO1xuICB9XG5cbiAgY29udHJvbENsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xDbGFzc1NlcnZpY2UuY29udHJvbENsYXNzKHRoaXMuaW52YWxpZCwgdGhpcy5hZGRHcmlkKCkpO1xuICB9XG5cbiAgYWRkR3JpZCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRTZXJ2aWNlICYmICF0aGlzLmxheW91dFNlcnZpY2UuaXNWZXJ0aWNhbCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9ucykge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm1hcChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBWaWV3Q29udGFpbmVyUmVmLCBSZW5kZXJlcjIsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBPcHRpb25hbCwgU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBXcmFwcGVkRm9ybUNvbnRyb2wgfSBmcm9tICcuLi9jb21tb24vd3JhcHBlZC1jb250cm9sJztcbmltcG9ydCB7IENsclNlbGVjdENvbnRhaW5lciB9IGZyb20gJy4vc2VsZWN0LWNvbnRhaW5lcic7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJTZWxlY3RdJywgaG9zdDogeyAnW2NsYXNzLmNsci1zZWxlY3RdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJTZWxlY3QgZXh0ZW5kcyBXcmFwcGVkRm9ybUNvbnRyb2w8Q2xyU2VsZWN0Q29udGFpbmVyPiB7XG4gIHByb3RlY3RlZCBpbmRleCA9IDE7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBjb250cm9sOiBOZ0NvbnRyb2wsXG4gICAgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBlbDogRWxlbWVudFJlZlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENsclNlbGVjdENvbnRhaW5lciwgaW5qZWN0b3IsIGNvbnRyb2wsIHJlbmRlcmVyLCBlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJTZWxlY3QgfSBmcm9tICcuL3NlbGVjdCc7XG5pbXBvcnQgeyBDbHJTZWxlY3RDb250YWluZXIgfSBmcm9tICcuL3NlbGVjdC1jb250YWluZXInO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyQ29tbW9uRm9ybXNNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDbHJTZWxlY3QsIENsclNlbGVjdENvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyU2VsZWN0LCBDbHJTZWxlY3RDb250YWluZXJdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtDbHJTZWxlY3RDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTZWxlY3RNb2R1bGUge31cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSWZFcnJvclNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtZXJyb3IvaWYtZXJyb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2xTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9uZy1jb250cm9sLnNlcnZpY2UnO1xuaW1wb3J0IHsgTGF5b3V0U2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvbGF5b3V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5pbXBvcnQgeyBDb250cm9sSWRTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3Byb3ZpZGVycy9jb250cm9sLWlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyTGFiZWwgfSBmcm9tICcuLi9jb21tb24vbGFiZWwnO1xuaW1wb3J0IHsgQ29udHJvbENsYXNzU2VydmljZSB9IGZyb20gJy4uL2NvbW1vbi9wcm92aWRlcnMvY29udHJvbC1jbGFzcy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXRleHRhcmVhLWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImxhYmVsXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8bGFiZWwgKm5nSWY9XCIhbGFiZWwgJiYgYWRkR3JpZCgpXCI+PC9sYWJlbD5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNsci1jb250cm9sLWNvbnRhaW5lclwiIFtuZ0NsYXNzXT1cImNvbnRyb2xDbGFzcygpXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2xyLXRleHRhcmVhLXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbY2xyVGV4dGFyZWFdXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDxjbHItaWNvbiAqbmdJZj1cImludmFsaWRcIiBjbGFzcz1cImNsci12YWxpZGF0ZS1pY29uXCIgc2hhcGU9XCJleGNsYW1hdGlvbi1jaXJjbGVcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItY29udHJvbC1oZWxwZXJcIiAqbmdJZj1cIiFpbnZhbGlkXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWNvbnRyb2wtZXJyb3JcIiAqbmdJZj1cImludmFsaWRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci1mb3JtLWNvbnRyb2xdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuY2xyLWZvcm0tY29udHJvbC1kaXNhYmxlZF0nOiAnY29udHJvbD8uZGlzYWJsZWQnLFxuICAgICdbY2xhc3MuY2xyLXJvd10nOiAnYWRkR3JpZCgpJyxcbiAgfSxcbiAgcHJvdmlkZXJzOiBbSWZFcnJvclNlcnZpY2UsIE5nQ29udHJvbFNlcnZpY2UsIENvbnRyb2xJZFNlcnZpY2UsIENvbnRyb2xDbGFzc1NlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUZXh0YXJlYUNvbnRhaW5lciBpbXBsZW1lbnRzIER5bmFtaWNXcmFwcGVyLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIGludmFsaWQgPSBmYWxzZTtcbiAgX2R5bmFtaWMgPSBmYWxzZTtcbiAgQENvbnRlbnRDaGlsZChDbHJMYWJlbCkgbGFiZWw6IENsckxhYmVsO1xuICBjb250cm9sOiBOZ0NvbnRyb2w7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpZkVycm9yU2VydmljZTogSWZFcnJvclNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBsYXlvdXRTZXJ2aWNlOiBMYXlvdXRTZXJ2aWNlLFxuICAgIHByaXZhdGUgY29udHJvbENsYXNzU2VydmljZTogQ29udHJvbENsYXNzU2VydmljZSxcbiAgICBwcml2YXRlIG5nQ29udHJvbFNlcnZpY2U6IE5nQ29udHJvbFNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmRXJyb3JTZXJ2aWNlLnN0YXR1c0NoYW5nZXMuc3Vic2NyaWJlKGludmFsaWQgPT4ge1xuICAgICAgICB0aGlzLmludmFsaWQgPSBpbnZhbGlkO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5uZ0NvbnRyb2xTZXJ2aWNlLmNvbnRyb2xDaGFuZ2VzLnN1YnNjcmliZShjb250cm9sID0+IHtcbiAgICAgICAgdGhpcy5jb250cm9sID0gY29udHJvbDtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIGNvbnRyb2xDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sQ2xhc3NTZXJ2aWNlLmNvbnRyb2xDbGFzcyh0aGlzLmludmFsaWQsIHRoaXMuYWRkR3JpZCgpKTtcbiAgfVxuXG4gIGFkZEdyaWQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0U2VydmljZSAmJiAhdGhpcy5sYXlvdXRTZXJ2aWNlLmlzVmVydGljYWwoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5tYXAoc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgVmlld0NvbnRhaW5lclJlZiwgUmVuZGVyZXIyLCBFbGVtZW50UmVmLCBJbmplY3RvciwgT3B0aW9uYWwsIFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5pbXBvcnQgeyBDbHJUZXh0YXJlYUNvbnRhaW5lciB9IGZyb20gJy4vdGV4dGFyZWEtY29udGFpbmVyJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclRleHRhcmVhXScsIGhvc3Q6IHsgJ1tjbGFzcy5jbHItdGV4dGFyZWFdJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJUZXh0YXJlYSBleHRlbmRzIFdyYXBwZWRGb3JtQ29udHJvbDxDbHJUZXh0YXJlYUNvbnRhaW5lcj4ge1xuICBwcm90ZWN0ZWQgaW5kZXggPSAxO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHZjcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQFNlbGYoKVxuICAgIEBPcHRpb25hbCgpXG4gICAgY29udHJvbDogTmdDb250cm9sLFxuICAgIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgZWw6IEVsZW1lbnRSZWZcbiAgKSB7XG4gICAgc3VwZXIodmNyLCBDbHJUZXh0YXJlYUNvbnRhaW5lciwgaW5qZWN0b3IsIGNvbnRyb2wsIHJlbmRlcmVyLCBlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckNvbW1vbkZvcm1zTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJUZXh0YXJlYSB9IGZyb20gJy4vdGV4dGFyZWEnO1xuaW1wb3J0IHsgQ2xyVGV4dGFyZWFDb250YWluZXIgfSBmcm9tICcuL3RleHRhcmVhLWNvbnRhaW5lcic7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIEZvcm1zTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJDb21tb25Gb3Jtc01vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NsclRleHRhcmVhLCBDbHJUZXh0YXJlYUNvbnRhaW5lcl0sXG4gIGV4cG9ydHM6IFtDbHJDb21tb25Gb3Jtc01vZHVsZSwgQ2xyVGV4dGFyZWEsIENsclRleHRhcmVhQ29udGFpbmVyXSxcbiAgZW50cnlDb21wb25lbnRzOiBbQ2xyVGV4dGFyZWFDb250YWluZXJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUZXh0YXJlYU1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQ2hlY2tib3hNb2R1bGUgfSBmcm9tICcuL2NoZWNrYm94L2NoZWNrYm94Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Gb3Jtc01vZHVsZSB9IGZyb20gJy4vY29tbW9uL2NvbW1vbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRGF0ZXBpY2tlck1vZHVsZSB9IGZyb20gJy4vZGF0ZXBpY2tlci9kYXRlcGlja2VyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJbnB1dE1vZHVsZSB9IGZyb20gJy4vaW5wdXQvaW5wdXQubW9kdWxlJztcbmltcG9ydCB7IENsclBhc3N3b3JkTW9kdWxlIH0gZnJvbSAnLi9wYXNzd29yZC9wYXNzd29yZC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyUmFkaW9Nb2R1bGUgfSBmcm9tICcuL3JhZGlvL3JhZGlvLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTZWxlY3RNb2R1bGUgfSBmcm9tICcuL3NlbGVjdC9zZWxlY3QubW9kdWxlJztcbmltcG9ydCB7IENsclRleHRhcmVhTW9kdWxlIH0gZnJvbSAnLi90ZXh0YXJlYS90ZXh0YXJlYS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZXhwb3J0czogW1xuICAgIENsckNvbW1vbkZvcm1zTW9kdWxlLFxuICAgIENsckNoZWNrYm94TW9kdWxlLFxuICAgIENsckRhdGVwaWNrZXJNb2R1bGUsXG4gICAgQ2xySW5wdXRNb2R1bGUsXG4gICAgQ2xyUGFzc3dvcmRNb2R1bGUsXG4gICAgQ2xyUmFkaW9Nb2R1bGUsXG4gICAgQ2xyU2VsZWN0TW9kdWxlLFxuICAgIENsclRleHRhcmVhTW9kdWxlLFxuICBdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJGb3Jtc01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBDbHJMb2FkaW5nU3RhdGUgfSBmcm9tICcuLi8uLi9sb2FkaW5nL2xvYWRpbmcnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXhwYW5kIGltcGxlbWVudHMgTG9hZGluZ0xpc3RlbmVyIHtcbiAgcHVibGljIGV4cGFuZGFibGU6IG51bWJlciA9IDA7XG5cbiAgLy8gcHJpdmF0ZSBfcmVwbGFjZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9yZXBsYWNlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGZhbHNlKTtcbiAgcHVibGljIGdldCByZXBsYWNlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9yZXBsYWNlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG4gIHNldFJlcGxhY2UocmVwbGFjZVZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVwbGFjZS5uZXh0KHJlcGxhY2VWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF9sb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBsb2FkaW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9sb2FkaW5nO1xuICB9XG5cbiAgc2V0IGxvYWRpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9sb2FkaW5nKSB7XG4gICAgICB0aGlzLl9sb2FkaW5nID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRlZDtcbiAgfVxuXG4gIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHZhbHVlID0gISF2YWx1ZTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX2V4cGFuZGVkKSB7XG4gICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuICAgICAgdGhpcy5fYW5pbWF0ZS5uZXh0KCk7XG4gICAgICB0aGlzLl9leHBhbmRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuX2V4cGFuZGVkO1xuICB9XG5cbiAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIHRoZSBkYXRhZ3JpZCBSb3dFeHBhbmQuXG4gIC8vIEkgc3BlbnQgc29tZSB0aW1lIGRvaW5nIHRoaXMgYnV0IHJhbiBpbnRvIGEgY291cGxlIG9mIGlzc3Vlc1xuICAvLyBXaWxsIHRha2UgY2FyZSBvZiB0aGlzIGxhdGVyLlxuICBwcml2YXRlIF9hbmltYXRlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgcHVibGljIGdldCBhbmltYXRlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9hbmltYXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZXhwYW5kQ2hhbmdlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgcHVibGljIGdldCBleHBhbmRDaGFuZ2UoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGFuZENoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGxvYWRpbmdTdGF0ZUNoYW5nZShzdGF0ZTogQ2xyTG9hZGluZ1N0YXRlKTogdm9pZCB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBDbHJMb2FkaW5nU3RhdGUuTE9BRElORzpcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZS5uZXh0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIE91dHB1dCxcbiAgUmVuZGVyZXIyLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi9wcm92aWRlcnMvZXhwYW5kJztcblxuLyoqXG4gKiBUT0RPOiBtYWtlIHRoaXMgYSByZXVzYWJsZSBkaXJlY3RpdmUgb3V0c2lkZSBvZiBEYXRhZ3JpZCwgbGlrZSBbY2xyTG9hZGluZ10uXG4gKi9cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkV4cGFuZGVkXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJJZkV4cGFuZGVkIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9leHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWQ7XG4gIH1cblxuICBASW5wdXQoJ2NscklmRXhwYW5kZWQnKVxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHRoaXMuZXhwYW5kLmV4cGFuZGVkID0gdmFsdWU7XG4gICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NscklmRXhwYW5kZWRDaGFuZ2UnKSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByaXZhdGUgY29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgZXhwYW5kOiBFeHBhbmRcbiAgKSB7XG4gICAgZXhwYW5kLmV4cGFuZGFibGUrKztcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBleHBhbmQuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQodGhpcy5leHBhbmQuZXhwYW5kZWQpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbnMgdG8gYWxsIHRoZSBzZXJ2aWNlcyBhbmQgcXVlcmllcyBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIHByaXZhdGUgdXBkYXRlVmlldygpIHtcbiAgICBpZiAodGhpcy5leHBhbmQuZXhwYW5kZWQgJiYgdGhpcy5jb250YWluZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRlbXBsYXRlKSB7XG4gICAgICBpZiAodGhpcy5leHBhbmQuZXhwYW5kZWQpIHtcbiAgICAgICAgLy8gU2hvdWxkIHdlIHBhc3MgYSBjb250ZXh0PyBJIGRvbid0IHNlZSBhbnl0aGluZyB1c2VmdWwgdG8gcGFzcyByaWdodCBub3csXG4gICAgICAgIC8vIGJ1dCB3ZSBjYW4gY29tZSBiYWNrIHRvIGl0IGluIHRoZSBmdXR1cmUgYXMgYSBzb2x1dGlvbiBmb3IgYWRkaXRpb25hbCBmZWF0dXJlcy5cbiAgICAgICAgdGhpcy5jb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB3aGVuIHdlIG1vdmUgdGhlIGFuaW1hdGlvbiBsb2dpYyB0byBEYXRhZ3JpZCBSb3cgRXhwYW5kXG4gICAgICAgIC8vIFdlIGNsZWFyIGJlZm9yZSB0aGUgYW5pbWF0aW9uIGlzIG92ZXIuIE5vdCBpZGVhbCwgYnV0IGRvaW5nIGJldHRlciB3b3VsZCBpbnZvbHZlIGEgbXVjaCBoZWF2aWVyXG4gICAgICAgIC8vIHByb2Nlc3MgZm9yIHZlcnkgbGl0dGxlIGdhaW4uIE9uY2UgQW5ndWxhciBhbmltYXRpb25zIGFyZSBkeW5hbWljIGVub3VnaCwgd2Ugc2hvdWxkIGJlIGFibGUgdG9cbiAgICAgICAgLy8gZ2V0IHRoZSBvcHRpbWFsIGJlaGF2aW9yLlxuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgdGVtcGxhdGUgcmVmLCB3ZSBmYWxsYmFjayB0byBhIGNydWRlIGRpc3BsYXk6IG5vbmUgZm9yIG5vdy5cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kLmV4cGFuZGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXNwbGF5JywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBXZSBjYXRjaCB0aGUgY2FzZSB3aGVyZSBjbHJJZkV4cGFuZGVkIHdhcyBwdXQgb24gYSBub24tRE9NIGVsZW1lbnQsIGFuZCB3ZSBqdXN0IGRvIG5vdGhpbmdcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnVwZGF0ZVZpZXcoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZXhwYW5kLmV4cGFuZGFibGUtLTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENscklmRXhwYW5kZWQgfSBmcm9tICcuL2lmLWV4cGFuZGVkJztcblxuZXhwb3J0ICogZnJvbSAnLi9pZi1leHBhbmRlZCc7XG5cbmV4cG9ydCBjb25zdCBFWFBBTkRfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xySWZFeHBhbmRlZF07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRVhQQU5EX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0VYUEFORF9ESVJFQ1RJVkVTXSwgZXhwb3J0czogW0VYUEFORF9ESVJFQ1RJVkVTXSB9KVxuZXhwb3J0IGNsYXNzIENscklmRXhwYW5kTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyTG9hZGluZyB9IGZyb20gJy4vbG9hZGluZyc7XG5cbmV4cG9ydCBjb25zdCBDTFJfTE9BRElOR19ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJMb2FkaW5nXTtcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW0NMUl9MT0FESU5HX0RJUkVDVElWRVNdLCBleHBvcnRzOiBbQ0xSX0xPQURJTkdfRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJMb2FkaW5nTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJPdXRzaWRlQ2xpY2tdJyB9KVxuZXhwb3J0IGNsYXNzIE91dHNpZGVDbGljayB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYpIHt9XG5cbiAgQElucHV0KCdjbHJTdHJpY3QnKSBzdHJpY3QgPSBmYWxzZTtcblxuICBAT3V0cHV0KCdjbHJPdXRzaWRlQ2xpY2snKSBvdXRzaWRlQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgZG9jdW1lbnRDbGljayhldmVudDogTW91c2VFdmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDsgLy8gR2V0IHRoZSBlbGVtZW50IGluIHRoZSBET00gb24gd2hpY2ggdGhlIG1vdXNlIHdhcyBjbGlja2VkXG4gICAgY29uc3QgaG9zdCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDsgLy8gR2V0IHRoZSBjdXJyZW50IGFjdGlvbk1lbnUgbmF0aXZlIEhUTUwgZWxlbWVudFxuXG4gICAgaWYgKHRhcmdldCA9PT0gaG9zdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RyaWN0ICYmIGhvc3QuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm91dHNpZGVDbGljay5lbWl0KGV2ZW50KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT3V0c2lkZUNsaWNrIH0gZnJvbSAnLi9vdXRzaWRlLWNsaWNrJztcblxuZXhwb3J0ICogZnJvbSAnLi9vdXRzaWRlLWNsaWNrJztcblxuZXhwb3J0IGNvbnN0IE9VU1RJREVfQ0xJQ0tfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbT3V0c2lkZUNsaWNrXTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBPVVNUSURFX0NMSUNLX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHsgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGRlY2xhcmF0aW9uczogW09VU1RJREVfQ0xJQ0tfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtPVVNUSURFX0NMSUNLX0RJUkVDVElWRVNdIH0pXG5leHBvcnQgY2xhc3MgQ2xyT3V0c2lkZUNsaWNrTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8qXG4gKiBJZiB3ZSBzb21lZGF5IHdhbnQgdG8gYmUgYWJsZSB0byByZW5kZXIgdGhlIGRhdGFncmlkIGluIGEgd2Vid29ya2VyLFxuICogdGhpcyBpcyB3aGVyZSB3ZSB3b3VsZCB0ZXN0IGlmIHdlJ3JlIGluIGhlYWRsZXNzIG1vZGUuIFJpZ2h0IG5vdyBpdCdzIG5vdCB0ZXN0aW5nIGFueXRoaW5nLCBidXQgYW55IGFjY2Vzc1xuICogdG8gbmF0aXZlIERPTSBlbGVtZW50cycgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBpbiB0aGUgRGF0YWdyaWQgaGFwcGVucyBoZXJlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERvbUFkYXB0ZXIge1xuICB1c2VyRGVmaW5lZFdpZHRoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogbnVtYmVyIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RhdGFncmlkLWNlbGwtd2lkdGgtemVybycpO1xuICAgIGNvbnN0IHVzZXJEZWZpbmVkV2lkdGggPSB0aGlzLmNsaWVudFJlY3QoZWxlbWVudCkud2lkdGg7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkYXRhZ3JpZC1jZWxsLXdpZHRoLXplcm8nKTtcbiAgICByZXR1cm4gdXNlckRlZmluZWRXaWR0aDtcbiAgfVxuXG4gIHNjcm9sbEJhcldpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIHNjcm9sbFdpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFdpZHRoIHx8IDA7XG4gIH1cblxuICBjb21wdXRlZEhlaWdodChlbGVtZW50OiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ2hlaWdodCcpLCAxMCk7XG4gIH1cblxuICBjbGllbnRSZWN0KGVsZW1lbnQ6IGFueSk6IENsaWVudFJlY3Qge1xuICAgIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC50b3AsIDEwKSxcbiAgICAgIGJvdHRvbTogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QuYm90dG9tLCAxMCksXG4gICAgICBsZWZ0OiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC5sZWZ0LCAxMCksXG4gICAgICByaWdodDogcGFyc2VJbnQoZWxlbWVudENsaWVudFJlY3QucmlnaHQsIDEwKSxcbiAgICAgIHdpZHRoOiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC53aWR0aCwgMTApLFxuICAgICAgaGVpZ2h0OiBwYXJzZUludChlbGVtZW50Q2xpZW50UmVjdC5oZWlnaHQsIDEwKSxcbiAgICB9O1xuICB9XG5cbiAgbWluV2lkdGgoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdtaW4td2lkdGgnKSwgMTApO1xuICB9XG5cbiAgZm9jdXMoZWxlbWVudDogYW55KTogdm9pZCB7XG4gICAgZWxlbWVudC5mb2N1cygpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UsIERyYWdQb2ludFBvc2l0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcblxuLy8gVGhpcyBjbGFzcyBpcyB1c2VkIHRvIGNvbnZlcnQgYW4gaW50ZXJuYWwgZXZlbnRcbi8vIHRvIGFuIGV4dGVybmFsIGV2ZW50IHRvIGJlIGVtaXR0ZWQuXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ0V2ZW50PFQ+IHtcbiAgcHVibGljIGRyYWdQb3NpdGlvbjogRHJhZ1BvaW50UG9zaXRpb247XG4gIHB1YmxpYyBncm91cDogc3RyaW5nIHwgc3RyaW5nW107XG4gIHB1YmxpYyBkcmFnRGF0YVRyYW5zZmVyOiBUO1xuICBwdWJsaWMgZHJvcFBvaW50UG9zaXRpb246IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuXG4gIGNvbnN0cnVjdG9yKGRyYWdFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSB7XG4gICAgdGhpcy5kcmFnUG9zaXRpb24gPSBkcmFnRXZlbnQuZHJhZ1Bvc2l0aW9uO1xuICAgIHRoaXMuZ3JvdXAgPSBkcmFnRXZlbnQuZ3JvdXA7XG4gICAgdGhpcy5kcmFnRGF0YVRyYW5zZmVyID0gZHJhZ0V2ZW50LmRyYWdEYXRhVHJhbnNmZXI7XG4gICAgdGhpcy5kcm9wUG9pbnRQb3NpdGlvbiA9IGRyYWdFdmVudC5kcm9wUG9pbnRQb3NpdGlvbjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuZXhwb3J0IGVudW0gRHJhZ0V2ZW50VHlwZSB7XG4gIERSQUdfU1RBUlQsXG4gIERSQUdfTU9WRSxcbiAgRFJBR19FTkQsXG4gIERSQUdfRU5URVIsXG4gIERSQUdfTEVBVkUsXG4gIERST1AsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ1BvaW50UG9zaXRpb24ge1xuICBwYWdlWDogbnVtYmVyO1xuICBwYWdlWTogbnVtYmVyO1xuICBtb3ZlWDogbnVtYmVyO1xuICBtb3ZlWTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYWdFdmVudEludGVyZmFjZTxUPiB7XG4gIHR5cGU6IERyYWdFdmVudFR5cGU7XG4gIGdyb3VwPzogc3RyaW5nIHwgc3RyaW5nW107XG4gIGdob3N0RWxlbWVudD86IGFueTtcbiAgZHJhZ1Bvc2l0aW9uOiBEcmFnUG9pbnRQb3NpdGlvbjtcbiAgZHJhZ0RhdGFUcmFuc2Zlcj86IFQ7XG4gIC8vIEZvciBkZWZhdWx0IGdob3N0cywgdGhpcyBkcm9wUG9pbnRQb3NpdGlvbiBkZW5vdGVzIHRoZSBjZW50ZXIgcG9pbnQgb2YgdGhlIGdob3N0IGVsZW1lbnQuXG4gIC8vIFRoaXMgY2VudGVyIHBvaW50IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdob3N0IGlzIG92ZXIgZHJvcHBhYmxlIGVsZW1lbnRzIG9yIG5vdC5cbiAgZHJvcFBvaW50UG9zaXRpb24/OiB7IHBhZ2VYOiBudW1iZXI7IHBhZ2VZOiBudW1iZXIgfTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4ge1xuICBwcml2YXRlIGRyYWdTdGFydDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyYWdNb3ZlOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ0VuZDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyb3A6IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiA9IG5ldyBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4oKTtcblxuICBnZXQgZHJhZ1N0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ01vdmVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ01vdmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ0VuZGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGdldCBkcm9wcGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGJyb2FkY2FzdChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19TVEFSVDpcbiAgICAgICAgdGhpcy5kcmFnU3RhcnQubmV4dChldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBEcmFnRXZlbnRUeXBlLkRSQUdfTU9WRTpcbiAgICAgICAgdGhpcy5kcmFnTW92ZS5uZXh0KGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19FTkQ6XG4gICAgICAgIHRoaXMuZHJhZ0VuZC5uZXh0KGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJPUDpcbiAgICAgICAgdGhpcy5kcm9wLm5leHQoZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBEcmFnQW5kRHJvcEV2ZW50QnVzU2VydmljZSB9IGZyb20gJy4vZHJhZy1hbmQtZHJvcC1ldmVudC1idXMuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD4ge1xuICBwcml2YXRlIGRyYWdnYWJsZUVsOiBhbnk7XG5cbiAgLy8gY29udGFpbnMgdGhlIHN0YXJ0aW5nIGV2ZW50cyBzdWNoIGFzIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydFxuICBwcml2YXRlIGxpc3RlbmVyczogKCgpID0+IHZvaWQpW107XG4gIC8vIGNvbnRhaW5zIHRoZSBuZXN0ZWQgZXZlbnRzIHRoYXQgaGFwcGVucyBhZnRlci9pbnNpZGUgdGhlIHN0YXJ0aW5nIGV2ZW50c1xuICAvLyBzdWNoIGFzIHNlbGVjdHN0YXJ0LCBtb3VzZW1vdmUvdG91Y2htb3ZlLCBtb3VzZXVwL3RvdWNoZW5kXG4gIHByaXZhdGUgbmVzdGVkTGlzdGVuZXJzOiAoKCkgPT4gdm9pZClbXTtcblxuICBwcml2YXRlIGRyYWdTdGFydDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuICBwcml2YXRlIGRyYWdNb3ZlOiBTdWJqZWN0PERyYWdFdmVudEludGVyZmFjZTxUPj4gPSBuZXcgU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+KCk7XG4gIHByaXZhdGUgZHJhZ0VuZDogU3ViamVjdDxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+ID0gbmV3IFN1YmplY3Q8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PigpO1xuXG4gIHByaXZhdGUgaGFzRHJhZ1N0YXJ0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgZHJhZ1N0YXJ0ZWQoKTogT2JzZXJ2YWJsZTxEcmFnRXZlbnRJbnRlcmZhY2U8VD4+IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnU3RhcnQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ01vdmVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ01vdmUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBnZXQgZHJhZ0VuZGVkKCk6IE9ic2VydmFibGU8RHJhZ0V2ZW50SW50ZXJmYWNlPFQ+PiB7XG4gICAgcmV0dXJuIHRoaXMuZHJhZ0VuZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmdab25lOiBOZ1pvbmUsIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBldmVudEJ1czogRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4pIHt9XG5cbiAgcHJpdmF0ZSBpbml0aWFsUG9zaXRpb246IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuXG4gIC8vIERyYWdnYWJsZSBjb21wb25lbnQgc2V0cyB0aGVzZSBwcm9wZXJ0aWVzOlxuICBwdWJsaWMgZHJhZ0RhdGFUcmFuc2Zlcj86IFQ7XG4gIHB1YmxpYyBncm91cD86IHN0cmluZyB8IHN0cmluZ1tdO1xuXG4gIC8vIERyYWdnYWJsZUdob3N0IGNvbXBvbmVudCBzZXRzIHRoZXNlIHByb3BlcnRpZXM6XG4gIHB1YmxpYyBnaG9zdEVsZW1lbnQ/OiBhbnk7XG4gIHB1YmxpYyBkcm9wUG9pbnRQb3NpdGlvbj86IHsgcGFnZVg6IG51bWJlcjsgcGFnZVk6IG51bWJlciB9O1xuXG4gIHB1YmxpYyBhdHRhY2hEcmFnTGlzdGVuZXJzKGRyYWdnYWJsZUVsOiBOb2RlKSB7XG4gICAgdGhpcy5kcmFnZ2FibGVFbCA9IGRyYWdnYWJsZUVsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gW1xuICAgICAgdGhpcy5jdXN0b21EcmFnRXZlbnQodGhpcy5kcmFnZ2FibGVFbCwgJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcpLFxuICAgICAgdGhpcy5jdXN0b21EcmFnRXZlbnQodGhpcy5kcmFnZ2FibGVFbCwgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJyksXG4gICAgXTtcbiAgfVxuXG4gIHB1YmxpYyBkZXRhY2hEcmFnTGlzdGVuZXJzKCkge1xuICAgIGlmICh0aGlzLmxpc3RlbmVycykge1xuICAgICAgdGhpcy5saXN0ZW5lcnMubWFwKGV2ZW50ID0+IGV2ZW50KCkpO1xuICAgIH1cblxuICAgIC8vIEluIG1vc3QgY2FzZXMsIG9uY2UgdXNlcnMgc3RhcnQgZHJhZ2dpbmcgd2l0aCBtb3VzZWRvd24vdG91Y2hzdGFydCBldmVudHMsXG4gICAgLy8gdGhleSB3aWxsIGVuZCBkcmFnZ2luZyBhdCBvbmUgcG9pbnQgd2l0aCBtb3VzZXVwL3RvdWNoZW5kLlxuICAgIC8vIEhvd2V2ZXIsIHRoZXJlIG1pZ2h0IGJlIGEgZmV3IGNhc2VzIHdoZXJlIG1vdXNlZG93bi90b3VjaHN0YXJ0IGV2ZW50cyBnZXQgcmVnaXN0ZXJlZCxcbiAgICAvLyBidXQgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGdldHMgcmVtb3ZlZCBiZWZvcmUgdXNlciBlbmRzIGRyYWdnaW5nLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byByZW1vdmUgdGhlIGF0dGFjaGVkIGxpc3RlbmVycyB0aGF0IGhhcHBlbmVkIGR1cmluZyB0aGUgbW91c2Vkb3duL3RvdWNoc3RhcnQgZXZlbnRzLlxuICAgIGlmICh0aGlzLm5lc3RlZExpc3RlbmVycykge1xuICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMubWFwKGV2ZW50ID0+IGV2ZW50KCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TmF0aXZlRXZlbnRPYmplY3QoZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KTogYW55IHtcbiAgICBpZiAoKDxUb3VjaEV2ZW50PmV2ZW50KS5oYXNPd25Qcm9wZXJ0eSgnY2hhbmdlZFRvdWNoZXMnKSkge1xuICAgICAgcmV0dXJuICg8VG91Y2hFdmVudD5ldmVudCkuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGN1c3RvbURyYWdFdmVudChlbGVtZW50OiBOb2RlLCBzdGFydE9uRXZlbnQ6IHN0cmluZywgbW92ZU9uRXZlbnQ6IHN0cmluZywgZW5kT25FdmVudDogc3RyaW5nKTogKCkgPT4gdm9pZCB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdGVuKGVsZW1lbnQsIHN0YXJ0T25FdmVudCwgKHN0YXJ0RXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7XG4gICAgICAvLyBzYXZlIHRoZSBpbml0aWFsIHBvaW50IHRvIGluaXRpYWxQb3NpdGlvblxuICAgICAgLy8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGhvdyBmYXIgdGhlIGRyYWdnYWJsZSBoYXMgYmVlbiBkcmFnZ2VkIGZyb20gaXRzIGluaXRpYWwgcG9zaXRpb25cbiAgICAgIHRoaXMuaW5pdGlhbFBvc2l0aW9uID0ge1xuICAgICAgICBwYWdlWDogdGhpcy5nZXROYXRpdmVFdmVudE9iamVjdChzdGFydEV2ZW50KS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IHRoaXMuZ2V0TmF0aXZlRXZlbnRPYmplY3Qoc3RhcnRFdmVudCkucGFnZVksXG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIG5lc3RlZCBsaXN0ZW5lcnMnIHByb3BlcnR5IHdpdGggYSBuZXcgZW1wdHkgYXJyYXk7XG4gICAgICB0aGlzLm5lc3RlZExpc3RlbmVycyA9IFtdO1xuXG4gICAgICAvLyBUaGlzIGlzIG5lZWRlZCB0byBkaXNhYmxlIHNlbGVjdGlvbiBkdXJpbmcgZHJhZ2dpbmcgKGVzcGVjaWFsbHkgaW4gRURHRS9JRTExKS5cbiAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzLnB1c2goXG4gICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsICdzZWxlY3RzdGFydCcsIChzZWxlY3RFdmVudDogRXZlbnQpID0+IHtcbiAgICAgICAgICBzZWxlY3RFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNlbGVjdEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgLy8gTGlzdGVuIHRvIG1vdXNlbW92ZS90b3VjaG1vdmUgZXZlbnRzIG91dHNpZGUgb2YgYW5ndWxhciB6b25lLlxuICAgICAgdGhpcy5uZXN0ZWRMaXN0ZW5lcnMucHVzaChcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmxpc3RlbignZG9jdW1lbnQnLCBtb3ZlT25FdmVudCwgKG1vdmVFdmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIGlzIG5lZWRlZCBoZXJlIHRvIHByZXZlbnQgbmVzdGVkIGRyYWdnYWJsZXMgZnJvbSBnZXR0aW5nIGRyYWdnZWRcbiAgICAgICAgICAgIC8vIGFsdG9nZXRoZXIuIFdlIHNob3VsZG4ndCB1c2UgRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgaGVyZSBhcyB3ZSBhcmUgbGlzdGVuaW5nIHRvIHRoZSBldmVudHNcbiAgICAgICAgICAgIC8vIG9uIHRoZSBnbG9iYWwgZWxlbWVudCBsZXZlbC5cblxuICAgICAgICAgICAgLy8gV2l0aCBFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgaXQgcmVnaXN0ZXJzIHRoZSBldmVudHMgc2VudCBmcm9tIHRoZSBpbm5lciBtb3N0IGRyYWdnYWJsZVxuICAgICAgICAgICAgLy8gZmlyc3QuIFRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhhdCwgaXQgc3RvcHMgbGlzdGVuaW5nIHRvIHRoZSBzYW1lIHR5cGUgb2YgZXZlbnRzIG9uIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBlbGVtZW50LiBTbyB0aGlzIHdpbGwgaGVscCB1cyB0byBub3QgcmVnaXN0ZXIgdGhlIHNhbWUgZXZlbnRzIHRoYXQgd291bGQgY29tZSBmcm9tIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIGxldmVsIGRyYWdnYWJsZXMgZXZlbnR1YWxseS5cblxuICAgICAgICAgICAgbW92ZUV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5oYXNEcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIEZpcmUgXCJkcmFnc3RhcnRcIlxuICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChtb3ZlRXZlbnQsIERyYWdFdmVudFR5cGUuRFJBR19TVEFSVCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGaXJlIFwiZHJhZ21vdmVcIlxuICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChtb3ZlRXZlbnQsIERyYWdFdmVudFR5cGUuRFJBR19NT1ZFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIExpc3RlbiB0byBtb3VzZXVwL3RvdWNoZW5kIGV2ZW50cy5cbiAgICAgIHRoaXMubmVzdGVkTGlzdGVuZXJzLnB1c2goXG4gICAgICAgIHRoaXMucmVuZGVyZXIubGlzdGVuKCdkb2N1bWVudCcsIGVuZE9uRXZlbnQsIChlbmRFdmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5oYXNEcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgLy8gRmlyZSBcImRyYWdlbmRcIiBvbmx5IGlmIGRyYWdzdGFydCBpcyByZWdpc3RlcmVkXG4gICAgICAgICAgICB0aGlzLmhhc0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdChlbmRFdmVudCwgRHJhZ0V2ZW50VHlwZS5EUkFHX0VORCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2UgbXVzdCByZW1vdmUgdGhlIHRoZSBuZXN0ZWQgbGlzdGVuZXJzIGV2ZXJ5IHRpbWUgZHJhZyBjb21wbGV0ZXMuXG4gICAgICAgICAgaWYgKHRoaXMubmVzdGVkTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLm5lc3RlZExpc3RlbmVycy5tYXAoZXZlbnQgPT4gZXZlbnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYnJvYWRjYXN0KGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCwgZXZlbnRUeXBlOiBEcmFnRXZlbnRUeXBlKTogdm9pZCB7XG4gICAgY29uc3QgZHJhZ0V2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4gPSB0aGlzLmdlbmVyYXRlRHJhZ0V2ZW50KGV2ZW50LCBldmVudFR5cGUpO1xuXG4gICAgc3dpdGNoIChkcmFnRXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBEcmFnRXZlbnRUeXBlLkRSQUdfU1RBUlQ6XG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0Lm5leHQoZHJhZ0V2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19NT1ZFOlxuICAgICAgICB0aGlzLmRyYWdNb3ZlLm5leHQoZHJhZ0V2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYWdFdmVudFR5cGUuRFJBR19FTkQ6XG4gICAgICAgIHRoaXMuZHJhZ0VuZC5uZXh0KGRyYWdFdmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBzZXQgYWZ0ZXIgdGhleSBhcmUgYnJvYWRjYXN0ZWQgdG8gdGhlIERyYWdnYWJsZUdob3N0IGNvbXBvbmVudC5cbiAgICBkcmFnRXZlbnQuZ2hvc3RFbGVtZW50ID0gdGhpcy5naG9zdEVsZW1lbnQ7XG4gICAgZHJhZ0V2ZW50LmRyb3BQb2ludFBvc2l0aW9uID0gdGhpcy5kcm9wUG9pbnRQb3NpdGlvbjtcblxuICAgIHRoaXMuZXZlbnRCdXMuYnJvYWRjYXN0KGRyYWdFdmVudCk7XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlRHJhZ0V2ZW50KGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCwgZXZlbnRUeXBlOiBEcmFnRXZlbnRUeXBlKTogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+IHtcbiAgICBjb25zdCBuYXRpdmVFdmVudDogYW55ID0gdGhpcy5nZXROYXRpdmVFdmVudE9iamVjdChldmVudCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogZXZlbnRUeXBlLFxuICAgICAgZHJhZ1Bvc2l0aW9uOiB7XG4gICAgICAgIHBhZ2VYOiBuYXRpdmVFdmVudC5wYWdlWCxcbiAgICAgICAgcGFnZVk6IG5hdGl2ZUV2ZW50LnBhZ2VZLFxuICAgICAgICBtb3ZlWDogbmF0aXZlRXZlbnQucGFnZVggLSB0aGlzLmluaXRpYWxQb3NpdGlvbi5wYWdlWCxcbiAgICAgICAgbW92ZVk6IG5hdGl2ZUV2ZW50LnBhZ2VZIC0gdGhpcy5pbml0aWFsUG9zaXRpb24ucGFnZVksXG4gICAgICB9LFxuICAgICAgZ3JvdXA6IHRoaXMuZ3JvdXAsXG4gICAgICBkcmFnRGF0YVRyYW5zZmVyOiB0aGlzLmRyYWdEYXRhVHJhbnNmZXIsXG4gICAgICBnaG9zdEVsZW1lbnQ6IHRoaXMuZ2hvc3RFbGVtZW50LFxuICAgIH07XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcblxuLy8gVGhpcyBzZXJ2aWNlIGlzIHVzZWQgdG8gY2FwdHVyZSB0aGUgc3RhdGUgb2YgY2xyRHJhZ2dhYmxlIGVsZW1lbnRcbi8vIGF0IGEgY2VydGFpbiBldmVudCBhbmQgcGFzc2VzIGl0IHRvIGNsckRyYWdnYWJsZUdob3N0IGNvbXBvbmVudC5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2U8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIpIHt9XG5cbiAgcHJpdmF0ZSBkcmFnZ2FibGVFbENsaWVudFJlY3Q6IENsaWVudFJlY3Q7XG4gIHByaXZhdGUgc25hcHNob3REcmFnRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPjtcblxuICBwdWJsaWMgY2FwdHVyZShlbDogTm9kZSwgZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPik6IHZvaWQge1xuICAgIHRoaXMuZHJhZ2dhYmxlRWxDbGllbnRSZWN0ID0gdGhpcy5kb21BZGFwdGVyLmNsaWVudFJlY3QoZWwpO1xuICAgIHRoaXMuc25hcHNob3REcmFnRXZlbnQgPSBldmVudDtcbiAgfVxuICBwdWJsaWMgZGlzY2FyZCgpOiB2b2lkIHtcbiAgICBkZWxldGUgdGhpcy5kcmFnZ2FibGVFbENsaWVudFJlY3Q7XG4gICAgZGVsZXRlIHRoaXMuc25hcHNob3REcmFnRXZlbnQ7XG4gIH1cbiAgZ2V0IGhhc0RyYWdnYWJsZVN0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIXRoaXMuc25hcHNob3REcmFnRXZlbnQgJiYgISF0aGlzLmRyYWdnYWJsZUVsQ2xpZW50UmVjdDtcbiAgfVxuICBnZXQgY2xpZW50UmVjdCgpOiBDbGllbnRSZWN0IHtcbiAgICByZXR1cm4gdGhpcy5kcmFnZ2FibGVFbENsaWVudFJlY3Q7XG4gIH1cbiAgZ2V0IGRyYWdFdmVudCgpOiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4ge1xuICAgIHJldHVybiB0aGlzLnNuYXBzaG90RHJhZ0V2ZW50O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBhbmltYXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgTmdab25lLCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJhZy1ldmVudC1saXN0ZW5lci5zZXJ2aWNlJztcbmltcG9ydCB7IERyYWdnYWJsZVNuYXBzaG90U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RyYWdnYWJsZS1zbmFwc2hvdC5zZXJ2aWNlJztcblxudHlwZSBQYWdlUG9zaXRpb24gPSB7XG4gIHBhZ2VYOiBudW1iZXI7XG4gIHBhZ2VZOiBudW1iZXI7XG59O1xudHlwZSBPZmZzZXRQb3NpdGlvbiA9IHtcbiAgdG9wOiBudW1iZXI7XG4gIGxlZnQ6IG51bWJlcjtcbn07XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kcmFnZ2FibGUtZ2hvc3QnLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignbGVhdmVBbmltYXRpb24nLCBbXG4gICAgICB0cmFuc2l0aW9uKCc6bGVhdmUnLCBbXG4gICAgICAgIHN0eWxlKHsgbGVmdDogJyonLCB0b3A6ICcqJyB9KSxcbiAgICAgICAgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgdG9wOiAne3t0b3B9fScsIGxlZnQ6ICd7e2xlZnR9fScgfSkpLFxuICAgICAgXSksXG4gICAgXSksXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyYWdnYWJsZUdob3N0PFQ+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBkcmFnZ2FibGVHaG9zdEVsOiBhbnk7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIEBIb3N0QmluZGluZygnQGxlYXZlQW5pbWF0aW9uJykgbGVhdmVBbmltQ29uZmlnID0geyB2YWx1ZTogMCwgcGFyYW1zOiB7IHRvcDogJzBweCcsIGxlZnQ6ICcwcHgnIH0gfTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIEBPcHRpb25hbCgpIHByaXZhdGUgZHJhZ0V2ZW50TGlzdGVuZXI6IERyYWdFdmVudExpc3RlbmVyU2VydmljZTxUPixcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIGRyYWdnYWJsZVNuYXBzaG90OiBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmVcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmRyYWdFdmVudExpc3RlbmVyIHx8ICF0aGlzLmRyYWdnYWJsZVNuYXBzaG90KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbHItZHJhZ2dhYmxlLWdob3N0IGNvbXBvbmVudCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsckRyYWdnYWJsZSBkaXJlY3RpdmUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnZ2FibGVHaG9zdEVsID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuXG4gICAgLy8gTmVlZCB0byB1c2UgUmVuZGVyZXIyIGFzIGl0IHJ1bnMgb3V0c2lkZSBvZiBOZ1pvbmVcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZHJhZ2dhYmxlR2hvc3RFbCwgJ2RyYWdnYWJsZS1naG9zdCcpO1xuXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGdob3N0IGVsZW1lbnQgaW4gRHJhZ0V2ZW50TGlzdGVuZXIgdG8gcGFzcyBpbiBhIENsckRyYWdFdmVudC5cbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmdob3N0RWxlbWVudCA9IHRoaXMuZHJhZ2dhYmxlR2hvc3RFbDtcblxuICAgIC8vIERlZmF1bHQgZ2hvc3Qgc2l6ZSBnZXRzIHRoZSBzaXplIG9mIENsckRyYWdnYWJsZSBlbGVtZW50LlxuICAgIHRoaXMuc2V0RGVmYXVsdEdob3N0U2l6ZSh0aGlzLmRyYWdnYWJsZUdob3N0RWwpO1xuXG4gICAgY29uc3Qgb2Zmc2V0OiBPZmZzZXRQb3NpdGlvbiA9IHtcbiAgICAgIHRvcDogdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5oYXNEcmFnZ2FibGVTdGF0ZVxuICAgICAgICA/IHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuZHJhZ0V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWSAtIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC50b3BcbiAgICAgICAgOiAwLFxuICAgICAgbGVmdDogdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5oYXNEcmFnZ2FibGVTdGF0ZVxuICAgICAgICA/IHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuZHJhZ0V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWCAtIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5sZWZ0XG4gICAgICAgIDogMCxcbiAgICB9O1xuXG4gICAgbGV0IGlzQW5pbWF0aW9uQ29uZmlndXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdNb3ZlZC5zdWJzY3JpYmUoKGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgICAgLy8gT24gdGhlIGZpcnN0IGRyYWcgbW92ZSBldmVudCwgd2UgY29uZmlndXJlIHRoZSBhbmltYXRpb24gYXMgaXQncyBkZXBlbmRlbnQgb24gdGhlIGZpcnN0IGRyYWcgZXZlbnQuXG4gICAgICAgIGlmICghaXNBbmltYXRpb25Db25maWd1cmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuaGFzRHJhZ2dhYmxlU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZVRvT25MZWF2ZShcbiAgICAgICAgICAgICAgYCR7dGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LnRvcH1weGAsXG4gICAgICAgICAgICAgIGAke3RoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5sZWZ0fXB4YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRlVG9PbkxlYXZlKGAke2V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWX1weGAsIGAke2V2ZW50LmRyYWdQb3NpdGlvbi5wYWdlWH1weGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc0FuaW1hdGlvbkNvbmZpZ3VyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIGRyYWdnYWJsZSBnaG9zdC5cbiAgICAgICAgY29uc3QgdG9wTGVmdFBvc2l0aW9uOiBQYWdlUG9zaXRpb24gPSB0aGlzLmZpbmRUb3BMZWZ0UG9zaXRpb24oZXZlbnQuZHJhZ1Bvc2l0aW9uLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uU3R5bGUodGhpcy5kcmFnZ2FibGVHaG9zdEVsLCB0b3BMZWZ0UG9zaXRpb24ucGFnZVgsIHRvcExlZnRQb3NpdGlvbi5wYWdlWSk7XG4gICAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJvcFBvaW50UG9zaXRpb24gPSB0aGlzLmZpbmREcm9wUG9pbnRQb3NpdGlvbih0b3BMZWZ0UG9zaXRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXREZWZhdWx0R2hvc3RTaXplKGVsOiBOb2RlKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuaGFzRHJhZ2dhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuc2V0U2l6ZVN0eWxlKGVsLCB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNsaWVudFJlY3Qud2lkdGgsIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5oZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYW5pbWF0ZVRvT25MZWF2ZSh0b3A6IHN0cmluZywgbGVmdDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHtcbiAgICAgIHRoaXMubGVhdmVBbmltQ29uZmlnID0geyB2YWx1ZTogMCwgcGFyYW1zOiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH0gfTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZFRvcExlZnRQb3NpdGlvbihkcmFnUG9zaXRpb246IFBhZ2VQb3NpdGlvbiwgb2Zmc2V0OiBPZmZzZXRQb3NpdGlvbik6IFBhZ2VQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHsgcGFnZVg6IGRyYWdQb3NpdGlvbi5wYWdlWCAtIG9mZnNldC5sZWZ0LCBwYWdlWTogZHJhZ1Bvc2l0aW9uLnBhZ2VZIC0gb2Zmc2V0LnRvcCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kRHJvcFBvaW50UG9zaXRpb24odG9wTGVmdFBvc2l0aW9uOiBQYWdlUG9zaXRpb24pOiBQYWdlUG9zaXRpb24ge1xuICAgIGlmICh0aGlzLmRyYWdnYWJsZVNuYXBzaG90Lmhhc0RyYWdnYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYWdlWDogdG9wTGVmdFBvc2l0aW9uLnBhZ2VYICsgdGhpcy5kcmFnZ2FibGVTbmFwc2hvdC5jbGllbnRSZWN0LndpZHRoIC8gMixcbiAgICAgICAgcGFnZVk6IHRvcExlZnRQb3NpdGlvbi5wYWdlWSArIHRoaXMuZHJhZ2dhYmxlU25hcHNob3QuY2xpZW50UmVjdC5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRvcExlZnRQb3NpdGlvbjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldFNpemVTdHlsZShlbDogTm9kZSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAnd2lkdGgnLCBgJHt3aWR0aH1weGApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICdoZWlnaHQnLCBgJHtoZWlnaHR9cHhgKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0UG9zaXRpb25TdHlsZShlbDogTm9kZSwgbGVmdDogbnVtYmVyLCB0b3A6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICdsZWZ0JywgYCR7bGVmdH1weGApO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoZWwsICd0b3AnLCBgJHt0b3B9cHhgKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGVsLCAndmlzaWJpbGl0eScsICd2aXNpYmxlJyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBTa2lwU2VsZiwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvZHJhZy1ldmVudC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJhZy1ldmVudC1saXN0ZW5lci5zZXJ2aWNlJztcblxuLy8gVGhpcyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSB3aWxsIGJlIHVzZWQgbWFpbmx5IHRvZ2V0aGVyIHdpdGggYGNsci1kcmFnZ2FibGUtZ2hvc3RgIGRpcmVjdGl2ZSBpbnNpZGUgb2YgY2xyRHJhZ2dhYmxlXG4vLyBkaXJlY3RpdmUuIFRoZSBkaXJlY3RpdmUgaXMgcmVzcG9uc2libGUgZm9yIGluc3RhbnRpYXRpbmcgYGNsci1kcmFnZ2FibGUtZ2hvc3RgIGRpcmVjdGl2ZSBvbmx5IGR1cmluZyBkcmFnZ2luZyBzb1xuLy8gdGhhdCBBbmd1bGFyIENoYW5nZSBEZXRlY3Rpb24gaXMgcHJldmVudGVkIGZyb20gcnVubmluZyBpZiBhIGNvbXBvbmVudCBvciBkaXJlY3RpdmUgaXMgcGxhY2VkIGluc2lkZSBvZiB0aGVcbi8vIGBjbHItZHJhZ2dhYmxlLWdob3N0YCBkaXJlY3RpdmUuXG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJJZkRyYWdnZWRdJyB9KVxuZXhwb3J0IGNsYXNzIENscklmRHJhZ2dlZDxUPiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcHJpdmF0ZSBjb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkcmFnRXZlbnRMaXN0ZW5lcjogRHJhZ0V2ZW50TGlzdGVuZXJTZXJ2aWNlPFQ+XG4gICkge1xuICAgIGlmICghdGhpcy5kcmFnRXZlbnRMaXN0ZW5lciB8fCAhdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlICpjbHJJZkRyYWdnZWQgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyRHJhZ2dhYmxlIGRpcmVjdGl2ZS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ1N0YXJ0ZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLnRlbXBsYXRlKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZHJhZ0VuZGVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGVhcigpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2UgfSBmcm9tICcuL2RyYWctZXZlbnQtbGlzdGVuZXIuc2VydmljZSc7XG5cbi8vIFRoaXMgcHJvdmlkZXIgcmVnaXN0ZXJzIHRoZSBkcmFnIGhhbmRsZSBlbGVtZW50LlxuLy8gV2hlbiBpdCByZWdpc3RlcnMgYSBlbGVtZW50IGFzIGEgZHJhZyBoYW5kbGUsIGl0IGF0dGFjaGVzIHRoYXQgZWxlbWVudCB0byB0aGUgbGlzdGVuZXJzIGZyb20gQ2xyRHJhZ0V2ZW50TGlzdGVuZXIuXG4vLyBBbHNvLCBpdCBhZGRzIHRoZSBcImRyYWctaGFuZGxlXCIgY3NzIGNsYXNzIHRvIHRoZSByZWdpc3RlcmVkIGVsZW1lbnQgdGhyb3VnaCBSZW5kZXJlci5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZTxUPiB7XG4gIHByaXZhdGUgX2N1c3RvbUhhbmRsZUVsOiBhbnk7XG4gIHByaXZhdGUgX2RlZmF1bHRIYW5kbGVFbDogYW55O1xuXG4gIGdldCBkZWZhdWx0SGFuZGxlRWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRIYW5kbGVFbDtcbiAgfVxuXG4gIHNldCBkZWZhdWx0SGFuZGxlRWwoZWw6IE5vZGUpIHtcbiAgICB0aGlzLl9kZWZhdWx0SGFuZGxlRWwgPSBlbDsgLy8gZGVmYXVsdEhhbmRsZUVsIHdpbGwgYmUgdXN1YWxseSB0aGUgY2xyRHJhZ2dhYmxlIGVsZW1lbnQuXG5cbiAgICAvLyBJZiB0aGUgY3VzdG9tSGFuZGxlRWwgaGFzIGJlZW4gcmVnaXN0ZXJlZCxcbiAgICAvLyBkb24ndCBtYWtlIHRoZSBkZWZhdWx0SGFuZGxlRWwgdGhlIGRyYWcgaGFuZGxlIHlldCB1bnRpbCB0aGUgY3VzdG9tSGFuZGxlRWwgaXMgdW5yZWdpc3RlcmVkLlxuICAgIGlmICghdGhpcy5fY3VzdG9tSGFuZGxlRWwpIHtcbiAgICAgIHRoaXMubWFrZUVsZW1lbnRIYW5kbGUodGhpcy5fZGVmYXVsdEhhbmRsZUVsKTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRyYWdFdmVudExpc3RlbmVyOiBEcmFnRXZlbnRMaXN0ZW5lclNlcnZpY2U8VD4sIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMikge31cblxuICBwcml2YXRlIG1ha2VFbGVtZW50SGFuZGxlKGVsOiBOb2RlKSB7XG4gICAgaWYgKHRoaXMuX2RlZmF1bHRIYW5kbGVFbCAmJiB0aGlzLl9kZWZhdWx0SGFuZGxlRWwgIT09IGVsKSB7XG4gICAgICAvLyBCZWZvcmUgbWFraW5nIGFuIGVsZW1lbnQgdGhlIGN1c3RvbSBoYW5kbGUgZWxlbWVudCxcbiAgICAgIC8vIHdlIHNob3VsZCByZW1vdmUgdGhlIGV4aXN0aW5nIGRyYWctaGFuZGxlIGNsYXNzIGZyb20gdGhlIGRyYWdnYWJsZSBlbGVtZW50LlxuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLl9kZWZhdWx0SGFuZGxlRWwsICdkcmFnLWhhbmRsZScpO1xuICAgIH1cbiAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmF0dGFjaERyYWdMaXN0ZW5lcnMoZWwpO1xuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZWwsICdkcmFnLWhhbmRsZScpO1xuICB9XG5cbiAgZ2V0IGN1c3RvbUhhbmRsZUVsKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXN0b21IYW5kbGVFbDtcbiAgfVxuXG4gIHB1YmxpYyByZWdpc3RlckN1c3RvbUhhbmRsZShlbDogTm9kZSkge1xuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZGV0YWNoRHJhZ0xpc3RlbmVycygpOyAvLyByZW1vdmVzIHRoZSBleGlzdGluZyBsaXN0ZW5lcnNcbiAgICB0aGlzLl9jdXN0b21IYW5kbGVFbCA9IGVsO1xuICAgIHRoaXMubWFrZUVsZW1lbnRIYW5kbGUodGhpcy5fY3VzdG9tSGFuZGxlRWwpO1xuICB9XG5cbiAgcHVibGljIHVucmVnaXN0ZXJDdXN0b21IYW5kbGUoKSB7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kZXRhY2hEcmFnTGlzdGVuZXJzKCk7IC8vIHJlbW92ZXMgdGhlIGV4aXN0aW5nIGxpc3RlbmVyc1xuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fY3VzdG9tSGFuZGxlRWwsICdkcmFnLWhhbmRsZScpO1xuICAgIGRlbGV0ZSB0aGlzLl9jdXN0b21IYW5kbGVFbDtcbiAgICAvLyBpZiBkZWZhdWx0IGhhbmRsZSBpcyBzZXQsIG1ha2UgdGhhdCBoYW5kbGVcbiAgICBpZiAodGhpcy5fZGVmYXVsdEhhbmRsZUVsKSB7XG4gICAgICB0aGlzLm1ha2VFbGVtZW50SGFuZGxlKHRoaXMuX2RlZmF1bHRIYW5kbGVFbCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gVGhpcyBzZXJ2aWNlIGNsYXNzIGFkZHMgYW5kIHJlbW92ZXMgdGhlIFwiaW4tZHJhZ1wiIGNsYXNzIHRvIHRoZSBkb2N1bWVudCBib2R5IGVsZW1lbnRcbi8vIHRocm91Z2ggaXRzIHB1YmxpYyBlbnRlcigpIGFuZCBleGl0KCkgbWV0aG9kcy5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBHbG9iYWxEcmFnTW9kZVNlcnZpY2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHt9XG5cbiAgZW50ZXIoKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnaW4tZHJhZycpO1xuICB9XG5cbiAgZXhpdCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdpbi1kcmFnJyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudEZhY3RvcnksXG4gIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgQ29udGVudENoaWxkLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IENsckRyYWdFdmVudCB9IGZyb20gJy4uL2RyYWctZXZlbnQnO1xuaW1wb3J0IHsgQ2xyRHJhZ2dhYmxlR2hvc3QgfSBmcm9tICcuLi9kcmFnZ2FibGUtZ2hvc3QnO1xuaW1wb3J0IHsgQ2xySWZEcmFnZ2VkIH0gZnJvbSAnLi4vaWYtZHJhZ2dlZCc7XG5pbXBvcnQgeyBEcmFnRXZlbnRJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RyYWctZXZlbnQuaW50ZXJmYWNlJztcbmltcG9ydCB7IERyYWdFdmVudExpc3RlbmVyU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9kcmFnLWV2ZW50LWxpc3RlbmVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvZHJhZy1oYW5kbGUtcmVnaXN0cmFyLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlU25hcHNob3RTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2RyYWdnYWJsZS1zbmFwc2hvdC5zZXJ2aWNlJztcbmltcG9ydCB7IEdsb2JhbERyYWdNb2RlU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9nbG9iYWwtZHJhZy1tb2RlLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRHJhZ2dhYmxlXScsXG4gIHByb3ZpZGVyczogW1xuICAgIERyYWdFdmVudExpc3RlbmVyU2VydmljZSxcbiAgICBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZSxcbiAgICBEcmFnZ2FibGVTbmFwc2hvdFNlcnZpY2UsXG4gICAgR2xvYmFsRHJhZ01vZGVTZXJ2aWNlLFxuICAgIERvbUFkYXB0ZXIsXG4gIF0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kcmFnZ2FibGVdJzogJ3RydWUnLCAnW2NsYXNzLmJlaW5nLWRyYWdnZWRdJzogJ2RyYWdPbicgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ2dhYmxlPFQ+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBkcmFnZ2FibGVFbDogYW55O1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHByaXZhdGUgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxDbHJEcmFnZ2FibGVHaG9zdDxUPj47XG4gIHB1YmxpYyBkcmFnT246IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgZHJhZ0V2ZW50TGlzdGVuZXI6IERyYWdFdmVudExpc3RlbmVyU2VydmljZTxUPixcbiAgICBwcml2YXRlIGRyYWdIYW5kbGVSZWdpc3RyYXI6IERyYWdIYW5kbGVSZWdpc3RyYXJTZXJ2aWNlPFQ+LFxuICAgIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgZHJhZ2dhYmxlU25hcHNob3Q6IERyYWdnYWJsZVNuYXBzaG90U2VydmljZTxUPixcbiAgICBwcml2YXRlIGdsb2JhbERyYWdNb2RlOiBHbG9iYWxEcmFnTW9kZVNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5kcmFnZ2FibGVFbCA9IHRoaXMuZWwubmF0aXZlRWxlbWVudDtcbiAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLmNmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeTxDbHJEcmFnZ2FibGVHaG9zdDxUPj4oQ2xyRHJhZ2dhYmxlR2hvc3QpO1xuICB9XG5cbiAgQENvbnRlbnRDaGlsZChDbHJJZkRyYWdnZWQpIGN1c3RvbUdob3N0OiBDbHJJZkRyYWdnZWQ8VD47XG5cbiAgQElucHV0KCdjbHJEcmFnZ2FibGUnKVxuICBzZXQgZGF0YVRyYW5zZmVyKHZhbHVlOiBUKSB7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnRGF0YVRyYW5zZmVyID0gdmFsdWU7XG4gIH1cblxuICBASW5wdXQoJ2Nsckdyb3VwJylcbiAgc2V0IGdyb3VwKHZhbHVlOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICAgIHRoaXMuZHJhZ0V2ZW50TGlzdGVuZXIuZ3JvdXAgPSB2YWx1ZTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGVmYXVsdEdob3N0KGV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pIHtcbiAgICB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmNhcHR1cmUodGhpcy5kcmFnZ2FibGVFbCwgZXZlbnQpO1xuICAgIC8vIE5PVEU6IFRoZSBkZWZhdWx0IGdob3N0IGVsZW1lbnQgd2lsbCBhcHBlYXJcbiAgICAvLyBuZXh0IHRvIHRoZSBjbHJEcmFnZ2FibGUgaW4gdGhlIERPTSBhcyBhIHNpYmxpbmcgZWxlbWVudC5cbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KHRoaXMuY29tcG9uZW50RmFjdG9yeSwgMCwgdGhpcy5pbmplY3RvciwgW1xuICAgICAgW3RoaXMuZHJhZ2dhYmxlRWwuY2xvbmVOb2RlKHRydWUpXSxcbiAgICBdKTtcbiAgfVxuXG4gIHByaXZhdGUgZGVzdHJveURlZmF1bHRHaG9zdCgpIHtcbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY2xlYXIoKTtcbiAgICB0aGlzLmRyYWdnYWJsZVNuYXBzaG90LmRpc2NhcmQoKTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRyYWdTdGFydCcpIGRyYWdTdGFydEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnTW92ZScpIGRyYWdNb3ZlRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyYWdFbmQnKSBkcmFnRW5kRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuZHJhZ0hhbmRsZVJlZ2lzdHJhci5kZWZhdWx0SGFuZGxlRWwgPSB0aGlzLmRyYWdnYWJsZUVsO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRyYWdFdmVudExpc3RlbmVyLmRyYWdTdGFydGVkLnN1YnNjcmliZSgoZXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLmdsb2JhbERyYWdNb2RlLmVudGVyKCk7XG4gICAgICAgIHRoaXMuZHJhZ09uID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUdob3N0KSB7XG4gICAgICAgICAgdGhpcy5jcmVhdGVEZWZhdWx0R2hvc3QoZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kcmFnU3RhcnRFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChldmVudCkpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnTW92ZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuZHJhZ01vdmVFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChldmVudCkpO1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kcmFnRW5kZWQuc3Vic2NyaWJlKChldmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRHJhZ01vZGUuZXhpdCgpO1xuICAgICAgICB0aGlzLmRyYWdPbiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tR2hvc3QpIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lEZWZhdWx0R2hvc3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdFbmRFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChldmVudCkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YjogU3Vic2NyaXB0aW9uKSA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgdGhpcy5kcmFnRXZlbnRMaXN0ZW5lci5kZXRhY2hEcmFnTGlzdGVuZXJzKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IENsckRyYWdFdmVudCB9IGZyb20gJy4uL2RyYWctZXZlbnQnO1xuaW1wb3J0IHsgRHJhZ0V2ZW50SW50ZXJmYWNlLCBEcmFnRXZlbnRUeXBlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcmFnLWV2ZW50LmludGVyZmFjZSc7XG5pbXBvcnQgeyBDbHJEcm9wVG9sZXJhbmNlSW50ZXJmYWNlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9kcm9wLXRvbGVyYW5jZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvZHJhZy1hbmQtZHJvcC1ldmVudC1idXMuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tjbHJEcm9wcGFibGVdJyxcbiAgcHJvdmlkZXJzOiBbRG9tQWRhcHRlcl0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kcm9wcGFibGVdJzogJ3RydWUnLCAnW2NsYXNzLmRyYWdnYWJsZS1tYXRjaF0nOiAnaXNEcmFnZ2FibGVNYXRjaCcgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJvcHBhYmxlPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGRyYWdTdGFydFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIGRyYWdNb3ZlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgZHJhZ0VuZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIHByaXZhdGUgZHJvcHBhYmxlRWw6IGFueTtcbiAgcHJpdmF0ZSBjbGllbnRSZWN0OiBDbGllbnRSZWN0O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBldmVudEJ1czogRHJhZ0FuZERyb3BFdmVudEJ1c1NlcnZpY2U8VD4sXG4gICAgcHJpdmF0ZSBkb21BZGFwdGVyOiBEb21BZGFwdGVyLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHtcbiAgICB0aGlzLmRyb3BwYWJsZUVsID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgcHJpdmF0ZSBpc0RyYWdnYWJsZU1hdGNoOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2lzRHJhZ2dhYmxlT3ZlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHNldCBpc0RyYWdnYWJsZU92ZXIodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAvLyBXZSBuZWVkIHRvIGFkZC9yZW1vdmUgdGhpcyBkcmFnZ2FibGUtb3ZlciBjbGFzcyB2aWEgUmVuZGVyZXIyXG4gICAgLy8gYmVjYXVzZSBpc0RyYWdnYWJsZU92ZXIgaXMgc2V0IG91dHNpZGUgb2YgTmdab25lLlxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmRyb3BwYWJsZUVsLCAnZHJhZ2dhYmxlLW92ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmRyb3BwYWJsZUVsLCAnZHJhZ2dhYmxlLW92ZXInKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGVPdmVyID0gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIF9ncm91cDogc3RyaW5nIHwgc3RyaW5nW107XG5cbiAgQElucHV0KCdjbHJHcm91cCcpXG4gIHNldCBncm91cCh2YWx1ZTogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICB0aGlzLl9ncm91cCA9IHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSBfZHJvcFRvbGVyYW5jZTogQ2xyRHJvcFRvbGVyYW5jZUludGVyZmFjZSA9IHsgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwIH07XG5cbiAgcHJpdmF0ZSBkcm9wVG9sZXJhbmNlR2VuZXJhdG9yKHRvcCA9IDAsIHJpZ2h0ID0gdG9wLCBib3R0b20gPSB0b3AsIGxlZnQgPSByaWdodCk6IENsckRyb3BUb2xlcmFuY2VJbnRlcmZhY2Uge1xuICAgIHJldHVybiB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9O1xuICB9XG5cbiAgQElucHV0KCdjbHJEcm9wVG9sZXJhbmNlJylcbiAgc2V0IGRyb3BUb2xlcmFuY2UodmFsdWU6IG51bWJlciB8IHN0cmluZyB8IENsckRyb3BUb2xlcmFuY2VJbnRlcmZhY2UpIHtcbiAgICAvLyBJZiB1c2VyIHByb3ZpZGVzIGFuIG9iamVjdCBoZXJlIGFuZCB3YW50cyB0byBtYW5pcHVsYXRlL3VwZGF0ZSBwcm9wZXJ0aWVzIGluZGl2aWR1YWxseSxcbiAgICAvLyB0aGUgb2JqZWN0IG11c3QgYmUgaW1tdXRhYmxlIGFzIHdlIGdlbmVyYXRlIG5ldyBvYmplY3QgYmFzZWQgdXNlcidzIGdpdmVuIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5fZHJvcFRvbGVyYW5jZSA9IHRoaXMuZHJvcFRvbGVyYW5jZUdlbmVyYXRvcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB0b2xlcmFuY2VWYWx1ZXMgPSB2YWx1ZVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAgIC5tYXAodG9sZXJhbmNlID0+IHBhcnNlSW50KHRvbGVyYW5jZSwgMTApKTtcbiAgICAgIHRoaXMuX2Ryb3BUb2xlcmFuY2UgPSB0aGlzLmRyb3BUb2xlcmFuY2VHZW5lcmF0b3IoLi4udG9sZXJhbmNlVmFsdWVzKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAvLyBUaGUgdmFsdWUgY291bGQgYmUgcGFzc2VkIGluIGFzIHtsZWZ0OiAyMCwgdG9wOiAzMCB9XG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZXN0IG9mIHRoZSBkaXJlY3Rpb24gcHJvcGVydGllcyBzaG91bGQgYmUgMC5cbiAgICAgIC8vIFRoYXQncyB3aHkgd2UgaW5pdGlhbGl6ZSBwcm9wZXJ0aWVzIHdpdGggMCBmaXJzdCwgdGhlbiBvdmVycmlkZSB3aXRoIHVzZXIncyBnaXZlbiB2YWx1ZS5cbiAgICAgIHRoaXMuX2Ryb3BUb2xlcmFuY2UgPSB7IC4uLnRoaXMuZHJvcFRvbGVyYW5jZUdlbmVyYXRvcigwKSwgLi4udmFsdWUgfTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEcmFnU3RhcnQnKSBkcmFnU3RhcnRFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ01vdmUnKSBkcmFnTW92ZUVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnRW5kJykgZHJhZ0VuZEVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxDbHJEcmFnRXZlbnQ8VD4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICBAT3V0cHV0KCdjbHJEcmFnTGVhdmUnKSBkcmFnTGVhdmVFbWl0dGVyOiBFdmVudEVtaXR0ZXI8Q2xyRHJhZ0V2ZW50PFQ+PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgnY2xyRHJhZ0VudGVyJykgZHJhZ0VudGVyRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoJ2NsckRyb3AnKSBkcm9wRW1pdHRlcjogRXZlbnRFbWl0dGVyPENsckRyYWdFdmVudDxUPj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgcHJpdmF0ZSB1bnN1YnNjcmliZUZyb20oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNoZWNrR3JvdXBNYXRjaChkcmFnZ2FibGVHcm91cDogc3RyaW5nIHwgc3RyaW5nW10pOiBib29sZWFuIHtcbiAgICAvLyBCb3RoIERyYWdnYWJsZSBhbmQgRHJvcHBhYmxlIGhhdmUgY2xyR3JvdXAgaW5wdXQuXG4gICAgLy8gVGhlIGNsckdyb3VwIGlucHV0IGNhbiBiZSBib3RoIGEgc3RyaW5nIGtleSBvciBhcnJheSBvZiBzdHJpbmcga2V5cyBpbiBEcmFnZ2FibGUgYW5kIERyb3BwYWJsZS5cblxuICAgIC8vIEl0J3Mgbm90IG1hdGNoIGlmIERyYWdnYWJsZSBoYXMgbm8gZGVmaW5lZCB2YWx1ZSBhc3NpZ25lZCB0byBjbHJHcm91cCwgYnV0IERyb3BwYWJsZSBoYXMgYSBkZWZpbmVkIGNsckdyb3VwLlxuICAgIGlmICghZHJhZ2dhYmxlR3JvdXAgJiYgdGhpcy5fZ3JvdXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlIHNhbWUgaXMgdHJ1ZSB0aGUgb3RoZXIgd2F5IHJvdW5kLlxuICAgIGlmICghdGhpcy5fZ3JvdXAgJiYgZHJhZ2dhYmxlR3JvdXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJdCdzIG1hdGNoIGlmIGJvdGggRHJhZ2dhYmxlIGFuZCBEcm9wcGFibGUgaGF2ZSBubyBhc3NpZ25lZCB2YWx1ZSBmb3IgY2xyR3JvdXAuXG4gICAgaWYgKCF0aGlzLl9ncm91cCAmJiAhZHJhZ2dhYmxlR3JvdXApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEl0J3MgbWF0Y2ggaWYgYm90aCBEcmFnZ2FibGUgYW5kIERyb3BwYWJsZSBoYXZlIHNpbXBsZSBzdHJpbmcga2V5cyB0aGF0IGFyZSBtYXRjaGluZy5cbiAgICAvLyBJdCdzIG1hdGNoIGlmIERyYWdnYWJsZSdzIHNpbXBsZSBjbHJHcm91cCBrZXkgaXMgbWF0Y2hpbmcgd2l0aCBvbmUgb2YgdGhlIGNsckdyb3VwIGtleXMgb2YgRHJvcHBhYmxlLiBUaGVcbiAgICAvLyBzYW1lIGlzIHRydWUgdGhlIG90aGVyIHdheSByb3VuZC5cbiAgICAvLyBpdCdzIG1hdGNoIGlmIG9uZSBvZiB0aGUgY2xyR3JvdXAga2V5cyBvZiBEcm9wcGFibGUgaXMgbWF0Y2hpbmcgd2l0aCBvbmUgb2YgdGhlIGNsckdyb3VwIGtleXMgb2YgRHJhZ2dhYmxlLlxuICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlR3JvdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2dyb3VwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXAgPT09IGRyYWdnYWJsZUdyb3VwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwLmluZGV4T2YoZHJhZ2dhYmxlR3JvdXApID4gLTE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZ3JvdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkcmFnZ2FibGVHcm91cC5pbmRleE9mKHRoaXMuX2dyb3VwKSA+IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9ncm91cCBhcyBzdHJpbmdbXSkuc29tZShncm91cEtleSA9PiBkcmFnZ2FibGVHcm91cC5pbmRleE9mKGdyb3VwS2V5KSA+IC0xKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzSW5Ecm9wQXJlYShwb2ludDogeyBwYWdlWDogbnVtYmVyOyBwYWdlWTogbnVtYmVyIH0pOiBib29sZWFuIHtcbiAgICBpZiAoIXBvaW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNsaWVudFJlY3QpIHtcbiAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuZG9tQWRhcHRlci5jbGllbnRSZWN0KHRoaXMuZHJvcHBhYmxlRWwpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHBvaW50LnBhZ2VYID49IHRoaXMuY2xpZW50UmVjdC5sZWZ0IC0gdGhpcy5fZHJvcFRvbGVyYW5jZS5sZWZ0ICYmXG4gICAgICBwb2ludC5wYWdlWCA8PSB0aGlzLmNsaWVudFJlY3QucmlnaHQgKyB0aGlzLl9kcm9wVG9sZXJhbmNlLnJpZ2h0ICYmXG4gICAgICBwb2ludC5wYWdlWSA+PSB0aGlzLmNsaWVudFJlY3QudG9wIC0gdGhpcy5fZHJvcFRvbGVyYW5jZS50b3AgJiZcbiAgICAgIHBvaW50LnBhZ2VZIDw9IHRoaXMuY2xpZW50UmVjdC5ib3R0b20gKyB0aGlzLl9kcm9wVG9sZXJhbmNlLmJvdHRvbVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9uRHJhZ1N0YXJ0KGRyYWdTdGFydEV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBkcmFnZ2FibGUgYW5kIGRyb3BwYWJsZSBoYXZlIGEgbWF0Y2hpbmcgZ3JvdXAga2V5LlxuICAgIHRoaXMuaXNEcmFnZ2FibGVNYXRjaCA9IHRoaXMuY2hlY2tHcm91cE1hdGNoKGRyYWdTdGFydEV2ZW50Lmdyb3VwKTtcblxuICAgIC8vIFN1YnNjcmliZSB0byBkcmFnTW92ZWQgYW5kIGRyYWdFbmRlZCBvbmx5IGlmIGRyYWdnYWJsZSBhbmQgZHJvcHBhYmxlIGhhdmUgYSBtYXRjaGluZyBncm91cCBrZXkuXG4gICAgaWYgKHRoaXMuaXNEcmFnZ2FibGVNYXRjaCkge1xuICAgICAgdGhpcy5kcmFnU3RhcnRFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcmFnU3RhcnRFdmVudCkpO1xuICAgICAgdGhpcy5kcmFnTW92ZVN1YnNjcmlwdGlvbiA9IHRoaXMuZXZlbnRCdXMuZHJhZ01vdmVkLnN1YnNjcmliZSgoZHJhZ01vdmVFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KSA9PiB7XG4gICAgICAgIHRoaXMub25EcmFnTW92ZShkcmFnTW92ZUV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kcmFnRW5kU3Vic2NyaXB0aW9uID0gdGhpcy5ldmVudEJ1cy5kcmFnRW5kZWQuc3Vic2NyaWJlKChkcmFnRW5kRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPikgPT4ge1xuICAgICAgICB0aGlzLm9uRHJhZ0VuZChkcmFnRW5kRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBvbkRyYWdNb3ZlKGRyYWdNb3ZlRXZlbnQ6IERyYWdFdmVudEludGVyZmFjZTxUPik6IHZvaWQge1xuICAgIGNvbnN0IGlzSW5Ecm9wQXJlYSA9IHRoaXMuaXNJbkRyb3BBcmVhKGRyYWdNb3ZlRXZlbnQuZHJvcFBvaW50UG9zaXRpb24pO1xuICAgIGlmICghdGhpcy5faXNEcmFnZ2FibGVPdmVyICYmIGlzSW5Ecm9wQXJlYSkge1xuICAgICAgdGhpcy5pc0RyYWdnYWJsZU92ZXIgPSB0cnVlO1xuICAgICAgY29uc3QgZHJhZ0VudGVyRXZlbnQgPSB7IC4uLmRyYWdNb3ZlRXZlbnQsIHR5cGU6IERyYWdFdmVudFR5cGUuRFJBR19FTlRFUiB9O1xuICAgICAgdGhpcy5ldmVudEJ1cy5icm9hZGNhc3QoZHJhZ0VudGVyRXZlbnQpO1xuICAgICAgdGhpcy5kcmFnRW50ZXJFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcmFnRW50ZXJFdmVudCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faXNEcmFnZ2FibGVPdmVyICYmICFpc0luRHJvcEFyZWEpIHtcbiAgICAgIHRoaXMuaXNEcmFnZ2FibGVPdmVyID0gZmFsc2U7XG4gICAgICBjb25zdCBkcmFnTGVhdmVFdmVudCA9IHsgLi4uZHJhZ01vdmVFdmVudCwgdHlwZTogRHJhZ0V2ZW50VHlwZS5EUkFHX0xFQVZFIH07XG4gICAgICB0aGlzLmV2ZW50QnVzLmJyb2FkY2FzdChkcmFnTGVhdmVFdmVudCk7XG4gICAgICB0aGlzLmRyYWdMZWF2ZUVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdMZWF2ZUV2ZW50KSk7XG4gICAgfVxuXG4gICAgdGhpcy5kcmFnTW92ZUVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdNb3ZlRXZlbnQpKTtcbiAgfVxuXG4gIHByaXZhdGUgb25EcmFnRW5kKGRyYWdFbmRFdmVudDogRHJhZ0V2ZW50SW50ZXJmYWNlPFQ+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX2lzRHJhZ2dhYmxlT3Zlcikge1xuICAgICAgaWYgKGRyYWdFbmRFdmVudC5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgLy8gQnkgdGhpcyBwb2ludCwgdGhlIGRyYWdnYWJsZSBnaG9zdCBjb21wb25lbnQgaXMgZGVzdHJveWVkLFxuICAgICAgICAvLyBidXQgdGhlIGVsZW1lbnQgd291bGQgYmUgYWN0aXZlIHVudGlsIGl0cyBhbmltYXRpb24gY29tcGxldGVzLlxuICAgICAgICAvLyBBcyBzdWNoLCBvbmNlIHRoZSBnaG9zdCBpcyBkcm9wcGVkIG92ZXIsIHdlIHdpbGwgZ2l2ZSBpdCBcImRyb3BwZWRcIiBjbGFzcy5cblxuICAgICAgICAvLyBUaGlzIHByb2Nlc3MgY2Fubm90IGJlIGRvbmUgaW4gdGhlIGdob3N0IGNvbXBvbmVudFxuICAgICAgICAvLyBiZWNhdXNlIGFueSBzdWJzY3JpcHRpb24gdG8gdGhlIGRyb3AgZXZlbnQgaXMgaW5lZmZlY3RpdmUgb3IgaW52YWxpZFxuICAgICAgICAvLyBhcyB0aGUgY29tcG9uZW50IGhhZCBiZWVuIGFscmVhZHkgZGVzdHJveWVkLlxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGRyYWdFbmRFdmVudC5naG9zdEVsZW1lbnQsICdkcm9wcGVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRyb3BFdmVudCA9IHsgLi4uZHJhZ0VuZEV2ZW50LCB0eXBlOiBEcmFnRXZlbnRUeXBlLkRST1AgfTtcbiAgICAgIHRoaXMuZXZlbnRCdXMuYnJvYWRjYXN0KGRyb3BFdmVudCk7XG4gICAgICB0aGlzLmRyb3BFbWl0dGVyLmVtaXQobmV3IENsckRyYWdFdmVudChkcm9wRXZlbnQpKTtcbiAgICAgIHRoaXMuaXNEcmFnZ2FibGVPdmVyID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZHJhZ0VuZEVtaXR0ZXIuZW1pdChuZXcgQ2xyRHJhZ0V2ZW50KGRyYWdFbmRFdmVudCkpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ01vdmVTdWJzY3JpcHRpb24pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ0VuZFN1YnNjcmlwdGlvbik7XG4gICAgdGhpcy5pc0RyYWdnYWJsZU1hdGNoID0gZmFsc2U7XG4gICAgZGVsZXRlIHRoaXMuY2xpZW50UmVjdDtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHRoaXMuZHJhZ1N0YXJ0U3Vic2NyaXB0aW9uID0gdGhpcy5ldmVudEJ1cy5kcmFnU3RhcnRlZC5zdWJzY3JpYmUoKGRyYWdTdGFydEV2ZW50OiBEcmFnRXZlbnRJbnRlcmZhY2U8VD4pID0+IHtcbiAgICAgIHRoaXMub25EcmFnU3RhcnQoZHJhZ1N0YXJ0RXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnN1YnNjcmliZUZyb20odGhpcy5kcmFnU3RhcnRTdWJzY3JpcHRpb24pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ01vdmVTdWJzY3JpcHRpb24pO1xuICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tKHRoaXMuZHJhZ0VuZFN1YnNjcmlwdGlvbik7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEcmFnSGFuZGxlUmVnaXN0cmFyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2RyYWctaGFuZGxlLXJlZ2lzdHJhci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckRyYWdIYW5kbGVdJywgaG9zdDogeyAnW2NsYXNzLmRyYWctaGFuZGxlXSc6ICd0cnVlJyB9IH0pXG5leHBvcnQgY2xhc3MgQ2xyRHJhZ0hhbmRsZTxUPiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsIEBPcHRpb25hbCgpIHByaXZhdGUgZHJhZ0hhbmRsZVJlZ2lzdHJhcjogRHJhZ0hhbmRsZVJlZ2lzdHJhclNlcnZpY2U8VD4pIHtcbiAgICBpZiAoIXRoaXMuZHJhZ0hhbmRsZVJlZ2lzdHJhcikge1xuICAgICAgLy8gQ2xyRHJhZ0hhbmRsZVJlZ2lzdHJhciBpcyBwcm92aWRlZCBpbiBDbHJEcmFnZ2FibGUgc28gd2UgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnQgaGVyZVxuICAgICAgLy8gYXMgY2xyRHJhZ0hhbmRsZSBpcyByZXF1aXJlZCB0byBiZSB1c2VkIG9ubHkgaW5zaWRlIG9mIGEgY2xyRHJhZ2dhYmxlIGRpcmVjdGl2ZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNsckRyYWdIYW5kbGUgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyRHJhZ2dhYmxlIGRpcmVjdGl2ZS4nKTtcbiAgICB9XG4gICAgdGhpcy5kcmFnSGFuZGxlUmVnaXN0cmFyLnJlZ2lzdGVyQ3VzdG9tSGFuZGxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLmRyYWdIYW5kbGVSZWdpc3RyYXIudW5yZWdpc3RlckN1c3RvbUhhbmRsZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRHJhZ2dhYmxlIH0gZnJvbSAnLi9kcmFnZ2FibGUvZHJhZ2dhYmxlJztcbmltcG9ydCB7IENsckRyb3BwYWJsZSB9IGZyb20gJy4vZHJvcHBhYmxlL2Ryb3BwYWJsZSc7XG5pbXBvcnQgeyBDbHJJZkRyYWdnZWQgfSBmcm9tICcuL2lmLWRyYWdnZWQnO1xuaW1wb3J0IHsgQ2xyRHJhZ0hhbmRsZSB9IGZyb20gJy4vZHJhZy1oYW5kbGUnO1xuaW1wb3J0IHsgQ2xyRHJhZ2dhYmxlR2hvc3QgfSBmcm9tICcuL2RyYWdnYWJsZS1naG9zdCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfRFJBR19BTkRfRFJPUF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyRHJhZ2dhYmxlLFxuICBDbHJEcm9wcGFibGUsXG4gIENscklmRHJhZ2dlZCxcbiAgQ2xyRHJhZ0hhbmRsZSxcbiAgQ2xyRHJhZ2dhYmxlR2hvc3QsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0RSQUdfQU5EX0RST1BfRElSRUNUSVZFU10sXG4gIGVudHJ5Q29tcG9uZW50czogW0NsckRyYWdnYWJsZUdob3N0XSxcbiAgZXhwb3J0czogW0NMUl9EUkFHX0FORF9EUk9QX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcmFnQW5kRHJvcE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vKlxuICogVGhpcyBpcyBhIGhhY2sgdGhhdCB3ZSBoYXZlIHRvIHdyaXRlIGZvciBub3cgYmVjYXVzZSBvZiBidWdzIGFuZCBsaW1pdGF0aW9ucyBpbiBBbmd1bGFyLFxuICogcGxlYXNlIGRvIG5vdCB1c2UgdGhpcyBhcyBhbiBleGFtcGxlLlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEV4cGFuZCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2V4cGFuZC9wcm92aWRlcnMvZXhwYW5kJztcbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1yb3cnIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRSb3dFeHBhbmRBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBleHBhbmQ6IEV4cGFuZFxuICApIHtcbiAgICBpZiAoZXhwYW5kICYmIGV4cGFuZC5hbmltYXRlKSB7XG4gICAgICBleHBhbmQuYW5pbWF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAvLyBXZSBhbHJlYWR5IGhhZCBhbiBhbmltYXRpb24gd2FpdGluZywgc28gd2UganVzdCBoYXZlIHRvIHJ1biBpbiwgbm90IHByZXBhcmUgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMub2xkSGVpZ2h0KSB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJ1bigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBydW5uaW5nOiBhbnk7XG4gIHByaXZhdGUgb2xkSGVpZ2h0OiBudW1iZXI7XG5cbiAgLypcbiAgICAgKiBEaXJ0eSBtYW51YWwgYW5pbWF0aW9uIGhhbmRsaW5nLCBidXQgd2UgaGF2ZSBubyB3YXkgdG8gdXNlIGR5bmFtaWMgaGVpZ2h0cyBpbiBBbmd1bGFyJ3MgY3VycmVudCBBUEkuXG4gICAgICogVGhleSdyZSB3b3JraW5nIG9uIGl0LCBidXQgaGF2ZSBubyBFVEEuXG4gICAgICovXG4gIHByaXZhdGUgYW5pbWF0ZSgpIHtcbiAgICAvLyBDaGVjayBpZiB3ZSBkbyBoYXZlIHdlYi1hbmltYXRpb25zIGF2YWlsYWJsZS4gSWYgbm90LCBqdXN0IHNraXAgdGhlIGFuaW1hdGlvbi5cbiAgICBpZiAoIXRoaXMuZWwubmF0aXZlRWxlbWVudC5hbmltYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gV2UgaGFkIGFuIGFuaW1hdGlvbiBydW5uaW5nLCB3ZSBza2lwIHRvIHRoZSBlbmRcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcuZmluaXNoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5vbGRIZWlnaHQgPSB0aGlzLmRvbUFkYXB0ZXIuY29tcHV0ZWRIZWlnaHQodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICAvLyBJbiBjYXNlIGhlaWdodCBoYXMgbm90IHlldCBiZWVuIHNldC4gV2hlbiBzdGFydGluZyBleHBhbmRlZCwgZm9yIGV4YW1wbGUuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMjkwNFxuICAgIGlmIChpc05hTih0aGlzLm9sZEhlaWdodCkpIHtcbiAgICAgIHRoaXMub2xkSGVpZ2h0ID0gMDtcbiAgICB9XG4gICAgLy8gV2Ugc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgaW1tZWRpYXRlbHkgdG8gYXZvaWQgYSBmbGlja2VyIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIHRoaXMub2xkSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvdy15JywgJ2hpZGRlbicpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZXhwYW5kLmxvYWRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcnVuKCkge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgbnVsbCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5kb21BZGFwdGVyLmNvbXB1dGVkSGVpZ2h0KHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgdGhpcy5ydW5uaW5nID0gdGhpcy5lbC5uYXRpdmVFbGVtZW50LmFuaW1hdGUoXG4gICAgICB7IGhlaWdodDogW3RoaXMub2xkSGVpZ2h0ICsgJ3B4JywgbmV3SGVpZ2h0ICsgJ3B4J10sIGVhc2luZzogJ2Vhc2UtaW4tb3V0JyB9LFxuICAgICAgeyBkdXJhdGlvbjogMjAwIH1cbiAgICApO1xuICAgIHRoaXMucnVubmluZy5vbmZpbmlzaCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnb3ZlcmZsb3cteScsIG51bGwpO1xuICAgICAgZGVsZXRlIHRoaXMucnVubmluZztcbiAgICB9O1xuICAgIGRlbGV0ZSB0aGlzLm9sZEhlaWdodDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEN1c3RvbUZpbHRlciB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qXG4gKiBUaGlzIHByb3ZpZGVyIGltcGxlbWVudHMgc29tZSBmb3JtIG9mIHN5bmNocm9ub3VzIGRlYm91bmNpbmcgdGhyb3VnaCBhIGxvY2sgcGF0dGVyblxuICogdG8gYXZvaWQgZW1pdHRpbmcgbXVsdGlwbGUgc3RhdGUgY2hhbmdlcyBmb3IgYSBzaW5nbGUgdXNlciBhY3Rpb24uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdGF0ZURlYm91bmNlciB7XG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gZ2xvYmFsIHN0YXRlIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qXG4gICAgICogVGhpcyBpcyB0aGUgbG9jaywgdG8gb25seSBlbWl0IG9uY2UgYWxsIHRoZSBjaGFuZ2VzIGhhdmUgZmluaXNoZWQgcHJvY2Vzc2luZ1xuICAgICAqL1xuICBwcml2YXRlIG5iQ2hhbmdlcyA9IDA7XG5cbiAgcHVibGljIGNoYW5nZVN0YXJ0KCkge1xuICAgIHRoaXMubmJDaGFuZ2VzKys7XG4gIH1cblxuICBwdWJsaWMgY2hhbmdlRG9uZSgpIHtcbiAgICBpZiAoLS10aGlzLm5iQ2hhbmdlcyA9PT0gMCkge1xuICAgICAgdGhpcy5fY2hhbmdlLm5leHQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOSBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN0YXRlRGVib3VuY2VyIH0gZnJvbSAnLi9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RhdGVEZWJvdW5jZXI6IFN0YXRlRGVib3VuY2VyKSB7fVxuXG4gIHB1YmxpYyBhY3RpdmF0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogUGFnZSBzaXplLCBhIHZhbHVlIG9mIDAgbWVhbnMgbm8gcGFnaW5hdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBfc2l6ZSA9IDA7XG4gIHB1YmxpYyBnZXQgc2l6ZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG4gIHB1YmxpYyBzZXQgc2l6ZShzaXplOiBudW1iZXIpIHtcbiAgICBjb25zdCBvbGRTaXplID0gdGhpcy5fc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0gb2xkU2l6ZSkge1xuICAgICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VTdGFydCgpO1xuICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFllYXAuIFRoYXQncyB0aGUgZm9ybXVsYSB0byBrZWVwIHRoZSBmaXJzdCBpdGVtIGZyb20gdGhlIG9sZCBwYWdlIHN0aWxsXG4gICAgICAgIC8vIGRpc3BsYXllZCBpbiB0aGUgbmV3IG9uZS5cbiAgICAgICAgdGhpcy5fY3VycmVudCA9IE1hdGguZmxvb3Iob2xkU2l6ZSAvIHNpemUgKiAodGhpcy5fY3VycmVudCAtIDEpKSArIDE7XG4gICAgICB9XG4gICAgICAvLyBXZSBhbHdheXMgZW1pdCBhbiBldmVudCBldmVuIGlmIHRoZSBjdXJyZW50IHBhZ2UgaW5kZXggZGlkbid0IGNoYW5nZSwgYmVjYXVzZVxuICAgICAgLy8gdGhlIHNpemUgY2hhbmdpbmcgbWVhbnMgdGhlIGl0ZW1zIGluc2lkZSB0aGUgcGFnZSBhcmUgZGlmZmVyZW50XG4gICAgICB0aGlzLl9jaGFuZ2UubmV4dCh0aGlzLl9jdXJyZW50KTtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2UubmV4dCh0aGlzLl9zaXplKTtcbiAgICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb3RhbCBpdGVtcyAobmVlZGVkIHRvIGd1ZXNzIHRoZSBsYXN0IHBhZ2UpXG4gICAqL1xuICBwcml2YXRlIF90b3RhbEl0ZW1zID0gMDtcbiAgcHVibGljIGdldCB0b3RhbEl0ZW1zKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsSXRlbXM7XG4gIH1cbiAgcHVibGljIHNldCB0b3RhbEl0ZW1zKHRvdGFsOiBudW1iZXIpIHtcbiAgICB0aGlzLl90b3RhbEl0ZW1zID0gdG90YWw7XG4gICAgLy8gSWYgd2UgaGF2ZSBsZXNzIGl0ZW1zIHRoYW4gYmVmb3JlLCB3ZSBtaWdodCBuZWVkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBwYWdlXG4gICAgaWYgKHRoaXMuY3VycmVudCA+IHRoaXMubGFzdCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5sYXN0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMYXN0IHBhZ2VcbiAgICovXG4gIHByaXZhdGUgX2xhc3Q6IG51bWJlcjtcbiAgcHVibGljIGdldCBsYXN0KCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuX2xhc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXN0O1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGFzdCBwYWdlIGlzbid0IGtub3duLCB3ZSBjb21wdXRlIGl0IGZyb20gdGhlIGxhc3QgaXRlbSdzIGluZGV4XG4gICAgaWYgKHRoaXMuc2l6ZSA+IDAgJiYgdGhpcy50b3RhbEl0ZW1zKSB7XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMudG90YWxJdGVtcyAvIHRoaXMuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9XG4gIHB1YmxpYyBzZXQgbGFzdChwYWdlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9sYXN0ID0gcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gcGFnZSBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2UgPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2l6ZUNoYW5nZSA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcblxuICBwdWJsaWMgZ2V0IHNpemVDaGFuZ2UoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZUNoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IHBhZ2VcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnQgPSAxO1xuICBwdWJsaWMgZ2V0IGN1cnJlbnQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuICBwdWJsaWMgc2V0IGN1cnJlbnQocGFnZTogbnVtYmVyKSB7XG4gICAgaWYgKHBhZ2UgIT09IHRoaXMuX2N1cnJlbnQpIHtcbiAgICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnQgPSBwYWdlO1xuICAgICAgdGhpcy5fY2hhbmdlLm5leHQocGFnZSk7XG4gICAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZURvbmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdG8gdGhlIHByZXZpb3VzIHBhZ2UgaWYgaXQgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgcHJldmlvdXMoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCA+IDEpIHtcbiAgICAgIHRoaXMuY3VycmVudC0tO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0byB0aGUgbmV4dCBwYWdlIGlmIGl0IGV4aXN0c1xuICAgKi9cbiAgcHVibGljIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudCA8IHRoaXMubGFzdCkge1xuICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBmaXJzdCBpdGVtIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCBwYWdlLCBzdGFydGluZyBhdCAwXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpcnN0SXRlbSgpOiBudW1iZXIge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuY3VycmVudCAtIDEpICogdGhpcy5zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGV4IG9mIHRoZSBsYXN0IGl0ZW0gZGlzcGxheWVkIG9uIHRoZSBjdXJyZW50IHBhZ2UsIHN0YXJ0aW5nIGF0IDBcbiAgICovXG4gIHB1YmxpYyBnZXQgbGFzdEl0ZW0oKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1zIC0gMTtcbiAgICB9XG4gICAgbGV0IGxhc3RJblBhZ2UgPSB0aGlzLmN1cnJlbnQgKiB0aGlzLnNpemUgLSAxO1xuICAgIGlmICh0aGlzLnRvdGFsSXRlbXMpIHtcbiAgICAgIGxhc3RJblBhZ2UgPSBNYXRoLm1pbihsYXN0SW5QYWdlLCB0aGlzLnRvdGFsSXRlbXMgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3RJblBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBwYWdlIHNpemUgdG8gMFxuICAgKi9cbiAgcHVibGljIHJlc2V0UGFnZVNpemUoKTogdm9pZCB7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wYWdlJztcbmltcG9ydCB7IFN0YXRlRGVib3VuY2VyIH0gZnJvbSAnLi9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRmlsdGVyc1Byb3ZpZGVyPFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFnZTogUGFnZSwgcHJpdmF0ZSBzdGF0ZURlYm91bmNlcjogU3RhdGVEZWJvdW5jZXIpIHt9XG4gIC8qKlxuICAgKiBUaGlzIHN1YmplY3QgaXMgdGhlIGxpc3Qgb2YgZmlsdGVycyB0aGF0IGNoYW5nZWQgbGFzdCwgbm90IHRoZSB3aG9sZSBsaXN0LlxuICAgKiBXZSBlbWl0IGEgbGlzdCByYXRoZXIgdGhhbiBqdXN0IG9uZSBmaWx0ZXIgdG8gYWxsb3cgYmF0Y2ggY2hhbmdlcyB0byBzZXZlcmFsIGF0IG9uY2UuXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2UgPSBuZXcgU3ViamVjdDxDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPltdPigpO1xuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8Q2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXT4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBvZiBhbGwgZmlsdGVycywgd2hldGhlciB0aGV5J3JlIGFjdGl2ZSBvciBub3RcbiAgICovXG4gIHByaXZhdGUgX2FsbDogUmVnaXN0ZXJlZEZpbHRlcjxULCBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPj5bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhdCBsZWFzdCBvbmUgZmlsdGVyIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICovXG4gIHB1YmxpYyBoYXNBY3RpdmVGaWx0ZXJzKCk6IGJvb2xlYW4ge1xuICAgIC8vIFdlIGRvIG5vdCB1c2UgZ2V0QWN0aXZlRmlsdGVycygpIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBtdWNoIG1vcmUgb2Z0ZW5cbiAgICAvLyBhbmQgc3RvcHBpbmcgdGhlIGxvb3AgZWFybHkgbWlnaHQgYmUgcmVsZXZhbnQuXG4gICAgZm9yIChjb25zdCB7IGZpbHRlciB9IG9mIHRoaXMuX2FsbCkge1xuICAgICAgaWYgKGZpbHRlciAmJiBmaWx0ZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBjdXJyZW50bHkgYWN0aXZlIGZpbHRlcnNcbiAgICovXG4gIHB1YmxpYyBnZXRBY3RpdmVGaWx0ZXJzKCk6IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+W10ge1xuICAgIGNvbnN0IHJldDogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSA9IFtdO1xuICAgIGZvciAoY29uc3QgeyBmaWx0ZXIgfSBvZiB0aGlzLl9hbGwpIHtcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgcmV0LnB1c2goZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBmaWx0ZXIsIGFuZCByZXR1cm5zIGEgZGVyZWdpc3RyYXRpb24gZnVuY3Rpb25cbiAgICovXG4gIHB1YmxpYyBhZGQ8RiBleHRlbmRzIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PihmaWx0ZXI6IEYpOiBSZWdpc3RlcmVkRmlsdGVyPFQsIEY+IHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FsbC5sZW5ndGg7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZmlsdGVyLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVzZXRQYWdlQW5kRW1pdEZpbHRlckNoYW5nZShbZmlsdGVyXSkpO1xuICAgIGxldCBoYXNVbnJlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICBjb25zdCByZWdpc3RlcmVkID0gbmV3IFJlZ2lzdGVyZWRGaWx0ZXIoZmlsdGVyLCAoKSA9PiB7XG4gICAgICBpZiAoaGFzVW5yZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5fYWxsLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBpZiAoZmlsdGVyLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5yZXNldFBhZ2VBbmRFbWl0RmlsdGVyQ2hhbmdlKFtdKTtcbiAgICAgIH1cbiAgICAgIGhhc1VucmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5fYWxsLnB1c2gocmVnaXN0ZXJlZCk7XG4gICAgaWYgKGZpbHRlci5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLnJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoW2ZpbHRlcl0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0ZXJlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGFuIGl0ZW0gaWYgaXQgaXMgYWNjZXB0ZWQgYnkgYWxsIGN1cnJlbnRseSBhY3RpdmUgZmlsdGVyc1xuICAgKi9cbiAgcHVibGljIGFjY2VwdHMoaXRlbTogVCk6IGJvb2xlYW4ge1xuICAgIGZvciAoY29uc3QgeyBmaWx0ZXIgfSBvZiB0aGlzLl9hbGwpIHtcbiAgICAgIGlmIChmaWx0ZXIgJiYgZmlsdGVyLmlzQWN0aXZlKCkgJiYgIWZpbHRlci5hY2NlcHRzKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0UGFnZUFuZEVtaXRGaWx0ZXJDaGFuZ2UoZmlsdGVyczogQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD5bXSkge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICAvLyBmaWx0ZXJpbmcgbWF5IGNoYW5nZSB0aGUgcGFnZSBudW1iZXIgc3VjaCB0aGF0IGN1cnJlbnQgcGFnZSBudW1iZXIgZG9lc24ndCBleGlzdCBpbiB0aGUgZmlsdGVyZWQgZGF0YXNldC5cbiAgICAvLyBTbyBoZXJlIHdlIGFsd2F5cyBzZXQgdGhlIGN1cnJlbnQgcGFnZSB0byAxIHNvIHRoYXQgaXQnbGwgZmV0Y2ggZmlyc3QgcGFnZSdzIGRhdGEgd2l0aCB0aGUgZ2l2ZW4gZmlsdGVyLlxuICAgIHRoaXMuX3BhZ2UuY3VycmVudCA9IDE7XG4gICAgdGhpcy5fY2hhbmdlLm5leHQoZmlsdGVycyk7XG4gICAgdGhpcy5zdGF0ZURlYm91bmNlci5jaGFuZ2VEb25lKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRiBleHRlbmRzIENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQ+PiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEYsIHB1YmxpYyB1bnJlZ2lzdGVyOiAoKSA9PiB2b2lkKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIsIFJlZ2lzdGVyZWRGaWx0ZXIgfSBmcm9tICcuLi9wcm92aWRlcnMvZmlsdGVycyc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhcjxULCBGIGV4dGVuZHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmaWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4pIHt9XG5cbiAgcHVibGljIHJlZ2lzdGVyZWQ6IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRj47XG5cbiAgcHVibGljIGdldCBmaWx0ZXIoKTogRiB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJlZCAmJiB0aGlzLnJlZ2lzdGVyZWQuZmlsdGVyO1xuICB9XG5cbiAgcHVibGljIHNldEZpbHRlcihmaWx0ZXI6IEYgfCBSZWdpc3RlcmVkRmlsdGVyPFQsIEY+KSB7XG4gICAgLy8gSWYgd2UgcHJldmlvdXNseSBoYWQgYW5vdGhlciBmaWx0ZXIsIHdlIHVucmVnaXN0ZXIgaXRcbiAgICB0aGlzLmRlbGV0ZUZpbHRlcigpO1xuICAgIGlmIChmaWx0ZXIgaW5zdGFuY2VvZiBSZWdpc3RlcmVkRmlsdGVyKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyZWQgPSBmaWx0ZXI7XG4gICAgfSBlbHNlIGlmIChmaWx0ZXIpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZCA9IHRoaXMuZmlsdGVycy5hZGQoZmlsdGVyKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZGVsZXRlRmlsdGVyKCkge1xuICAgIGlmICh0aGlzLnJlZ2lzdGVyZWQpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJlZC51bnJlZ2lzdGVyKCk7XG4gICAgICBkZWxldGUgdGhpcy5yZWdpc3RlcmVkO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlbGV0ZUZpbHRlcigpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuaW1wb3J0IHsgUG9wb3Zlck9wdGlvbnMgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyLW9wdGlvbnMuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvZmlsdGVyLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDdXN0b21GaWx0ZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9jdXN0b20tZmlsdGVyJztcbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciwgUmVnaXN0ZXJlZEZpbHRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2ZpbHRlcnMnO1xuaW1wb3J0IHsgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXIgfSBmcm9tICcuL3V0aWxzL2RhdGFncmlkLWZpbHRlci1yZWdpc3RyYXInO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuLyoqXG4gKiBDdXN0b20gZmlsdGVyIHRoYXQgY2FuIGJlIGFkZGVkIGluIGFueSBjb2x1bW4gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2JqZWN0IHByb3BlcnR5IHN0cmluZyBmaWx0ZXIuXG4gKiBUaGUgcmVhc29uIHRoaXMgaXMgbm90IGp1c3QgYW4gaW5wdXQgb24gRGF0YWdyaWRDb2x1bW4gaXMgYmVjYXVzZSB3ZSBuZWVkIHRoZSBmaWx0ZXIncyB0ZW1wbGF0ZSB0byBiZSBwcm9qZWN0ZWQsXG4gKiBzaW5jZSBpdCBjYW4gYmUgYW55dGhpbmcgKG5vdCBqdXN0IGEgdGV4dCBpbnB1dCkuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1maWx0ZXInLFxuICAvLyBXZSByZWdpc3RlciB0aGlzIGNvbXBvbmVudCBhcyBhIEN1c3RvbUZpbHRlciwgZm9yIHRoZSBwYXJlbnQgY29sdW1uIHRvIGRldGVjdCBpdC5cbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDdXN0b21GaWx0ZXIsIHVzZUV4aXN0aW5nOiBDbHJEYXRhZ3JpZEZpbHRlciB9XSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiAjYW5jaG9yIGNsYXNzPVwiZGF0YWdyaWQtZmlsdGVyLXRvZ2dsZVwiIChjbGljayk9XCJ0b2dnbGUoKVwiXG4gICAgICAgICAgICBbY2xhc3MuZGF0YWdyaWQtZmlsdGVyLW9wZW5dPVwib3BlblwiIFtjbGFzcy5kYXRhZ3JpZC1maWx0ZXJlZF09XCJhY3RpdmVcIlxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiPjwvYnV0dG9uPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbKGNsclBvcG92ZXJPbGQpXT1cIm9wZW5cIiBbY2xyUG9wb3Zlck9sZEFuY2hvcl09XCJhbmNob3JcIiBbY2xyUG9wb3Zlck9sZEFuY2hvclBvaW50XT1cImFuY2hvclBvaW50XCJcbiAgICAgICAgICAgICBbY2xyUG9wb3Zlck9sZFBvcG92ZXJQb2ludF09XCJwb3BvdmVyUG9pbnRcIiBbY2xyUG9wb3Zlck9sZE9wdGlvbnNdPVwicG9wb3Zlck9wdGlvbnNcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1maWx0ZXJcIj5cbiAgICAgICAgICAgICAgICA8IS0tIEZJWE1FOiB0aGlzIHdob2xlIGZpbHRlciBwYXJ0IG5lZWRzIGEgZmluYWwgZGVzaWduIGJlZm9yZSB3ZSBjYW4gdHJ5IHRvIGhhdmUgYSBjbGVhbmVyIERPTSAtLT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtZmlsdGVyLWNsb3NlLXdyYXBwZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIChjbGljayk9XCJvcGVuID0gZmFsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNsb3NlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5jbG9zZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgIFxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkRmlsdGVyPFQgPSBhbnk+IGV4dGVuZHMgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXI8VCwgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+XG4gIGltcGxlbWVudHMgQ3VzdG9tRmlsdGVyIHtcbiAgY29uc3RydWN0b3IoX2ZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPiwgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MpIHtcbiAgICBzdXBlcihfZmlsdGVycyk7XG4gIH1cblxuICBwdWJsaWMgYW5jaG9yUG9pbnQ6IFBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICBwdWJsaWMgcG9wb3ZlclBvaW50OiBQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgcHVibGljIHBvcG92ZXJPcHRpb25zOiBQb3BvdmVyT3B0aW9ucyA9IHsgYWxsb3dNdWx0aXBsZU9wZW46IHRydWUgfTtcbiAgLyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIHRoZSBmaWx0ZXIgZHJvcGRvd24gaXMgb3BlbiBvciBub3RcbiAgICovXG4gIHByaXZhdGUgX29wZW4gPSBmYWxzZTtcbiAgcHVibGljIGdldCBvcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0ZpbHRlck9wZW4nKVxuICBwdWJsaWMgc2V0IG9wZW4ob3BlbjogYm9vbGVhbikge1xuICAgIGNvbnN0IGJvb2xPcGVuID0gISFvcGVuO1xuICAgIGlmIChib29sT3BlbiAhPT0gdGhpcy5fb3Blbikge1xuICAgICAgdGhpcy5fb3BlbiA9IGJvb2xPcGVuO1xuICAgICAgdGhpcy5vcGVuQ2hhbmdlZC5lbWl0KGJvb2xPcGVuKTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ0ZpbHRlck9wZW5DaGFuZ2UnKSBwdWJsaWMgb3BlbkNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBASW5wdXQoJ2NsckRnRmlsdGVyJylcbiAgcHVibGljIHNldCBjdXN0b21GaWx0ZXIoZmlsdGVyOiBDbHJEYXRhZ3JpZEZpbHRlckludGVyZmFjZTxUPiB8IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4+KSB7XG4gICAgdGhpcy5zZXRGaWx0ZXIoZmlsdGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGZpbHRlciBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLmZpbHRlciAmJiB0aGlzLmZpbHRlci5pc0FjdGl2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3dzL2hpZGVzIHRoZSBmaWx0ZXIgZHJvcGRvd25cbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuLyoqXG4gKiBHZW5lcmljIGFjY2Vzc29yIGZvciBkZWVwIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiB0aGF0IGNhbiBiZSBzcGVjaWZpZWQgYXMgc2ltcGxlIGRvdC1zZXBhcmF0ZWQgc3RyaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5lc3RlZFByb3BlcnR5PFQgPSBhbnk+IHtcbiAgcHJpdmF0ZSBzcGxpdFByb3A6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcHJvcDogc3RyaW5nKSB7XG4gICAgaWYgKHByb3AuaW5kZXhPZignLicpID49IDApIHtcbiAgICAgIHRoaXMuc3BsaXRQcm9wID0gcHJvcC5zcGxpdCgnLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNhZmUgZ2V0dGVyIGZvciBhIGRlZXAgb2JqZWN0IHByb3BlcnR5LCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvciBidXQgcmV0dXJuXG4gIC8vIHVuZGVmaW5lZCBpZiBvbmUgb2YgdGhlIGludGVybWVkaWF0ZSBwcm9wZXJ0aWVzIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICBwdWJsaWMgZ2V0UHJvcFZhbHVlKGl0ZW06IFQpOiBhbnkge1xuICAgIGlmICh0aGlzLnNwbGl0UHJvcCkge1xuICAgICAgbGV0IHZhbHVlID0gaXRlbTtcbiAgICAgIGZvciAoY29uc3QgbmVzdGVkUHJvcCBvZiB0aGlzLnNwbGl0UHJvcCkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB2YWx1ZVtuZXN0ZWRQcm9wXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWVbbmVzdGVkUHJvcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVtW3RoaXMucHJvcF07XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFN0cmluZ0ZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvc3RyaW5nLWZpbHRlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTmVzdGVkUHJvcGVydHkgfSBmcm9tICcuLi9uZXN0ZWQtcHJvcGVydHknO1xuXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlcjxUID0gYW55PiBpbXBsZW1lbnRzIENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlPFQ+IHtcbiAgcHJpdmF0ZSBuZXN0ZWRQcm9wOiBOZXN0ZWRQcm9wZXJ0eTxUPjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcHJvcDogc3RyaW5nLCBwdWJsaWMgZXhhY3QgPSBmYWxzZSkge1xuICAgIHRoaXMubmVzdGVkUHJvcCA9IG5ldyBOZXN0ZWRQcm9wZXJ0eShwcm9wKTtcbiAgfVxuXG4gIGFjY2VwdHMoaXRlbTogVCwgc2VhcmNoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBwcm9wVmFsdWUgPSB0aGlzLm5lc3RlZFByb3AuZ2V0UHJvcFZhbHVlKGl0ZW0pO1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5leGFjdCkge1xuICAgICAgcmV0dXJuICgnJyArIHByb3BWYWx1ZSkudG9Mb3dlckNhc2UoKSA9PT0gc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCcnICsgcHJvcFZhbHVlKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoc2VhcmNoKSA+PSAwO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL2ZpbHRlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbnRlcmZhY2UgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3N0cmluZy1maWx0ZXIuaW50ZXJmYWNlJztcbmltcG9ydCB7IERhdGFncmlkUHJvcGVydHlTdHJpbmdGaWx0ZXIgfSBmcm9tICcuL2RhdGFncmlkLXByb3BlcnR5LXN0cmluZy1maWx0ZXInO1xuXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsPFQgPSBhbnk+IGltcGxlbWVudHMgQ2xyRGF0YWdyaWRGaWx0ZXJJbnRlcmZhY2U8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgZmlsdGVyRm46IENsckRhdGFncmlkU3RyaW5nRmlsdGVySW50ZXJmYWNlPFQ+KSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSByZXF1aXJlZCBhcyBwYXJ0IG9mIHRoZSBGaWx0ZXIgaW50ZXJmYWNlXG4gICAqL1xuICBwcml2YXRlIF9jaGFuZ2VzID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlcygpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJhdyBpbnB1dCB2YWx1ZVxuICAgKi9cbiAgcHJpdmF0ZSBfcmF3VmFsdWU6IHN0cmluZyA9ICcnO1xuICBwdWJsaWMgZ2V0IHZhbHVlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd1ZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBJbnB1dCB2YWx1ZSBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlXG4gICAqL1xuICBwcml2YXRlIF9sb3dlckNhc2VWYWx1ZTogc3RyaW5nID0gJyc7XG4gIHB1YmxpYyBnZXQgbG93ZXJDYXNlVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvd2VyQ2FzZVZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBDb21tb24gc2V0dGVyIGZvciB0aGUgaW5wdXQgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgdmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcmF3VmFsdWUpIHtcbiAgICAgIHRoaXMuX3Jhd1ZhbHVlID0gdmFsdWU7XG4gICAgICB0aGlzLl9sb3dlckNhc2VWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgdGhpcy5fY2hhbmdlcy5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBmaWx0ZXIgaXMgY3VycmVudGx5IGFjdGl2ZSwgbWVhbmluZyB0aGUgaW5wdXQgaXMgbm90IGVtcHR5XG4gICAqL1xuICBwdWJsaWMgaXNBY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiBhbiBpdGVtIG1hdGNoZXMgYSBzZWFyY2ggdGV4dFxuICAgKi9cbiAgcHVibGljIGFjY2VwdHMoaXRlbTogVCk6IGJvb2xlYW4ge1xuICAgIC8vIFdlIGFsd2F5cyB0ZXN0IHdpdGggdGhlIGxvd2VyY2FzZSB2YWx1ZSBvZiB0aGUgaW5wdXQsIHRvIHN0YXkgY2FzZSBpbnNlbnNpdGl2ZVxuICAgIHJldHVybiB0aGlzLmZpbHRlckZuLmFjY2VwdHMoaXRlbSwgdGhpcy5sb3dlckNhc2VWYWx1ZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHN0YXRlKCkge1xuICAgIGlmICh0aGlzLmZpbHRlckZuIGluc3RhbmNlb2YgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcGVydHk6IHRoaXMuZmlsdGVyRm4ucHJvcCxcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBlcXVhbHMob3RoZXI6IENsckRhdGFncmlkRmlsdGVySW50ZXJmYWNlPFQsIGFueT4pOiBib29sZWFuIHtcbiAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGwpIHtcbiAgICAgIGlmIChvdGhlci5maWx0ZXJGbiBpbnN0YW5jZW9mIERhdGFncmlkUHJvcGVydHlTdHJpbmdGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0aGlzLmZpbHRlckZuIGluc3RhbmNlb2YgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlciAmJlxuICAgICAgICAgIG90aGVyLmZpbHRlckZuLnByb3AgPT09IHRoaXMuZmlsdGVyRm4ucHJvcCAmJlxuICAgICAgICAgIG90aGVyLnZhbHVlID09PSB0aGlzLnZhbHVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXIgPT09IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlciB9IGZyb20gJy4uLy4uL2RhdGFncmlkLWZpbHRlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFN0cmluZ0ZpbHRlckludGVyZmFjZSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvc3RyaW5nLWZpbHRlci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ3VzdG9tRmlsdGVyIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL2N1c3RvbS1maWx0ZXInO1xuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyLCBSZWdpc3RlcmVkRmlsdGVyIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL2ZpbHRlcnMnO1xuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGFncmlkRmlsdGVyUmVnaXN0cmFyIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGF0YWdyaWQtZmlsdGVyLXJlZ2lzdHJhcic7XG5cbmltcG9ydCB7IERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCB9IGZyb20gJy4vZGF0YWdyaWQtc3RyaW5nLWZpbHRlci1pbXBsJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXN0cmluZy1maWx0ZXInLFxuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IEN1c3RvbUZpbHRlciwgdXNlRXhpc3Rpbmc6IERhdGFncmlkU3RyaW5nRmlsdGVyIH1dLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8Y2xyLWRnLWZpbHRlciBbY2xyRGdGaWx0ZXJdPVwicmVnaXN0ZXJlZFwiIFsoY2xyRGdGaWx0ZXJPcGVuKV09XCJvcGVuXCI+XG4gICAgICAgICAgICA8IS0tXG4gICAgICAgICAgICAgICAgRXZlbiB0aG91Z2ggdGhpcyAqbmdJZiBsb29rcyB1c2VsZXNzIGJlY2F1c2UgdGhlIGZpbHRlciBjb250YWluZXIgYWxyZWFkeSBoYXMgb25lLFxuICAgICAgICAgICAgICAgIGl0IHByZXZlbnRzIE5nQ29udHJvbFN0YXR1cyBhbmQgb3RoZXIgZGlyZWN0aXZlcyBhdXRvbWF0aWNhbGx5IGFkZGVkIGJ5IEFuZ3VsYXJcbiAgICAgICAgICAgICAgICBvbiBpbnB1dHMgd2l0aCBOZ01vZGVsIGZyb20gZnJlYWtpbmcgb3V0IGJlY2F1c2Ugb2YgdGhlaXIgaG9zdCBiaW5kaW5nIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgbWlkLWNoYW5nZSBkZXRlY3Rpb24gd2hlbiB0aGUgaW5wdXQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgICAgLS0+XG4gICAgICAgICAgICA8aW5wdXQgI2lucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cInNlYXJjaFwiIFsobmdNb2RlbCldPVwidmFsdWVcIiAqbmdJZj1cIm9wZW5cIlxuICAgICAgICAgICAgICAgIChrZXl1cC5lbnRlcik9XCJjbG9zZSgpXCIgKGtleXVwLmVzY2FwZSk9XCJjbG9zZSgpXCIvPlxuICAgICAgICA8L2Nsci1kZy1maWx0ZXI+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRTdHJpbmdGaWx0ZXI8VCA9IGFueT4gZXh0ZW5kcyBEYXRhZ3JpZEZpbHRlclJlZ2lzdHJhcjxULCBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGw8VD4+XG4gIGltcGxlbWVudHMgQ3VzdG9tRmlsdGVyLCBBZnRlclZpZXdJbml0IHtcbiAgY29uc3RydWN0b3IoZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LCBwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIpIHtcbiAgICBzdXBlcihmaWx0ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXN0b21pemFibGUgZmlsdGVyIGxvZ2ljIGJhc2VkIG9uIGEgc2VhcmNoIHRleHRcbiAgICovXG4gIEBJbnB1dCgnY2xyRGdTdHJpbmdGaWx0ZXInKVxuICBzZXQgY3VzdG9tU3RyaW5nRmlsdGVyKFxuICAgIHZhbHVlOiBDbHJEYXRhZ3JpZFN0cmluZ0ZpbHRlckludGVyZmFjZTxUPiB8IFJlZ2lzdGVyZWRGaWx0ZXI8VCwgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsPFQ+PlxuICApIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdpc3RlcmVkRmlsdGVyKSB7XG4gICAgICB0aGlzLnNldEZpbHRlcih2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RmlsdGVyKG5ldyBEYXRhZ3JpZFN0cmluZ0ZpbHRlckltcGwodmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHRoZSBmaWx0ZXIgZHJvcGRvd24gaXMgb3BlblxuICAgKi9cbiAgcHVibGljIG9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogV2UgbmVlZCB0aGUgYWN0dWFsIGlucHV0IGVsZW1lbnQgdG8gYXV0b21hdGljYWxseSBmb2N1cyBvbiBpdFxuICAgKi9cbiAgQFZpZXdDaGlsZCgnaW5wdXQnKSBwdWJsaWMgaW5wdXQ6IEVsZW1lbnRSZWY7XG5cbiAgLyoqXG4gICAqIFdlIGdyYWIgdGhlIENsckRhdGFncmlkRmlsdGVyIHdlIHdyYXAgdG8gcmVnaXN0ZXIgdGhpcyBTdHJpbmdGaWx0ZXIgdG8gaXQuXG4gICAqL1xuICBAVmlld0NoaWxkKENsckRhdGFncmlkRmlsdGVyKSBwdWJsaWMgZmlsdGVyQ29udGFpbmVyOiBDbHJEYXRhZ3JpZEZpbHRlcjxUPjtcbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuZmlsdGVyQ29udGFpbmVyLm9wZW5DaGFuZ2VkLnN1YnNjcmliZSgob3BlbjogYm9vbGVhbikgPT4ge1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0aGUgdGltZW91dCBiZWNhdXNlIGF0IHRoZSB0aW1lIHRoaXMgZXhlY3V0ZXMsIHRoZSBpbnB1dCBpc24ndFxuICAgICAgICAvLyBkaXNwbGF5ZWQgeWV0LlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmRvbUFkYXB0ZXIuZm9jdXModGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tbW9uIHNldHRlciBmb3IgdGhlIGlucHV0IHZhbHVlXG4gICAqL1xuICBwdWJsaWMgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlci52YWx1ZTtcbiAgfVxuICBASW5wdXQoJ2NsckZpbHRlclZhbHVlJylcbiAgcHVibGljIHNldCB2YWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHRoaXMuZmlsdGVyLnZhbHVlKSB7XG4gICAgICB0aGlzLmZpbHRlci52YWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5maWx0ZXJWYWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJGaWx0ZXJWYWx1ZUNoYW5nZScpIGZpbHRlclZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIHB1YmxpYyBjbG9zZSgpIHtcbiAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBXaWxseVdvbmthIH0gZnJvbSAnLi93aWxseS13b25rYSc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBPb21wYUxvb21wYSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudENoZWNrZWQsIE9uRGVzdHJveSB7XG4gIC8vIEZJWE1FOiBSZXF1ZXN0IEluamVjdG9yIG9uY2Ugd2UgbW92ZSB0byBBbmd1bGFyIDQuMissIGl0J2xsIGFsbG93IGVhc2llciByZWZhY3RvcnNcbiAgY29uc3RydWN0b3IoY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgd2lsbHlXb25rYTogV2lsbHlXb25rYSkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gd2lsbHlXb25rYS5jaG9jb2xhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmxhdGVzdEZsYXZvciAhPT0gdGhpcy5mbGF2b3IpIHtcbiAgICAgICAgY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSBsYXRlc3RGbGF2b3I6IGFueTtcblxuICBhYnN0cmFjdCBnZXQgZmxhdm9yKCk6IGFueTtcblxuICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKSB7XG4gICAgdGhpcy5sYXRlc3RGbGF2b3IgPSB0aGlzLmZsYXZvcjtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUm93QWN0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgYWN0aW9uYWJsZUNvdW50ID0gMDtcblxuICBwdWJsaWMgcmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5hY3Rpb25hYmxlQ291bnQrKztcbiAgfVxuXG4gIHB1YmxpYyB1bnJlZ2lzdGVyKCkge1xuICAgIHRoaXMuYWN0aW9uYWJsZUNvdW50LS07XG4gIH1cblxuICAvKipcbiAgICogZmFsc2UgbWVhbnMgbm8gcm93cyB3aXRoIGFjdGlvblxuICAgKi9cbiAgcHVibGljIGdldCBoYXNBY3Rpb25hYmxlUm93KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbmFibGVDb3VudCA+IDA7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0NoZWNrZWQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuLypcbiAqIEFmdGVyIGEgY29udmVyc2F0aW9uIHdpdGggdGhlIEFuZ3VsYXIgY29yZSB0ZWFtLCBpdCB0dXJucyBvdXQgd2UgZG9uJ3QgaGF2ZSBtdWNoIG9mIGEgY2hvaWNlIGZvciBvdXJcbiAqIGRlY2xhcmF0aXZlIEFQSSwgd2UgbmVlZCB0byBmaWdodCBhZ2FpbnN0IGNoYW5nZSBkZXRlY3Rpb24gYW5kIGl0cyBvbmUtd2F5IGZsb3cuIFRoaXMgaXNcbiAqIGN1cnJlbnRseSB0aGUgbGVhc3QgZGlydHkgc29sdXRpb24gdG8gZG8gd2hhdCB3ZSB3YW50LlxuICpcbiAqIERvIG5vdCBtb2RpZnkgb3IgZXZlbiB1c2UgdGhpcyBjbGFzcyB1bmxlc3MgeW91IGtub3cgZXhhY3RseSB3aGF0IHlvdSdyZSBkb2luZy5cbiAqIEl0IGhhcyB0aGUgcG90ZW50aWFsIHRvIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiBsb29wcyBvciBraWxsIGFwcCBwZXJmb3JtYW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBXaWxseVdvbmthIGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCB7XG4gIHByaXZhdGUgX2Nob2NvbGF0ZSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgcHVibGljIGdldCBjaG9jb2xhdGUoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2Nob2NvbGF0ZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICB0aGlzLl9jaG9jb2xhdGUubmV4dCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFdpbGx5V29ua2EgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGF0YWdyaWQnIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRXaWxseVdvbmthIGV4dGVuZHMgV2lsbHlXb25rYSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9vbXBhTG9vbXBhIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL29vbXBhLWxvb21wYSc7XG5pbXBvcnQgeyBSb3dBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBEYXRhZ3JpZFdpbGx5V29ua2EgfSBmcm9tICcuL2RhdGFncmlkLXdpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLWRhdGFncmlkLCBjbHItZGctcm93JyB9KVxuZXhwb3J0IGNsYXNzIEFjdGlvbmFibGVPb21wYUxvb21wYSBleHRlbmRzIE9vbXBhTG9vbXBhIHtcbiAgcHJpdmF0ZSByb3dBY3Rpb25zOiBSb3dBY3Rpb25TZXJ2aWNlO1xuXG4gIGNvbnN0cnVjdG9yKGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIEBPcHRpb25hbCgpIHdpbGx5V29ua2E6IERhdGFncmlkV2lsbHlXb25rYSwgcm93QWN0aW9uczogUm93QWN0aW9uU2VydmljZSkge1xuICAgIGlmICghd2lsbHlXb25rYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItZGctcm93IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLWRhdGFncmlkJyk7XG4gICAgfVxuICAgIHN1cGVyKGNkciwgd2lsbHlXb25rYSk7XG4gICAgdGhpcy5yb3dBY3Rpb25zID0gcm93QWN0aW9ucztcbiAgfVxuXG4gIGdldCBmbGF2b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93QWN0aW9ucy5oYXNBY3Rpb25hYmxlUm93O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBFeHBhbmRhYmxlUm93c0NvdW50IHtcbiAgcHJpdmF0ZSBleHBhbmRhYmxlQ291bnQgPSAwO1xuXG4gIHB1YmxpYyByZWdpc3RlcigpIHtcbiAgICB0aGlzLmV4cGFuZGFibGVDb3VudCsrO1xuICB9XG5cbiAgcHVibGljIHVucmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5leHBhbmRhYmxlQ291bnQtLTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmYWxzZSBtZWFucyBubyByb3dzIHdpdGggYWN0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhhc0V4cGFuZGFibGVSb3coKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZUNvdW50ID4gMDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIERpcmVjdGl2ZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9vbXBhTG9vbXBhIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL29vbXBhLWxvb21wYSc7XG5pbXBvcnQgeyBFeHBhbmRhYmxlUm93c0NvdW50IH0gZnJvbSAnLi4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuaW1wb3J0IHsgRGF0YWdyaWRXaWxseVdvbmthIH0gZnJvbSAnLi9kYXRhZ3JpZC13aWxseS13b25rYSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kYXRhZ3JpZCwgY2xyLWRnLXJvdycgfSlcbmV4cG9ydCBjbGFzcyBFeHBhbmRhYmxlT29tcGFMb29tcGEgZXh0ZW5kcyBPb21wYUxvb21wYSB7XG4gIHByaXZhdGUgZXhwYW5kYWJsZUNvdW50OiBFeHBhbmRhYmxlUm93c0NvdW50O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQE9wdGlvbmFsKCkgd2lsbHlXb25rYTogRGF0YWdyaWRXaWxseVdvbmthLFxuICAgIGV4cGFuZGFibGVDb3VudDogRXhwYW5kYWJsZVJvd3NDb3VudFxuICApIHtcbiAgICBpZiAoIXdpbGx5V29ua2EpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xyLWRnLXJvdyBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBvZiBhIGNsci1kYXRhZ3JpZCcpO1xuICAgIH1cbiAgICBzdXBlcihjZHIsIHdpbGx5V29ua2EpO1xuICAgIHRoaXMuZXhwYW5kYWJsZUNvdW50ID0gZXhwYW5kYWJsZUNvdW50O1xuICB9XG5cbiAgZ2V0IGZsYXZvcigpIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlQ291bnQuaGFzRXhwYW5kYWJsZVJvdztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlIH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9jb21wYXJhdG9yLmludGVyZmFjZSc7XG5pbXBvcnQgeyBOZXN0ZWRQcm9wZXJ0eSB9IGZyb20gJy4uL25lc3RlZC1wcm9wZXJ0eSc7XG5cbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcjxUID0gYW55PiBpbXBsZW1lbnRzIENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiB7XG4gIHByaXZhdGUgbmVzdGVkUHJvcDogTmVzdGVkUHJvcGVydHk8VD47XG5cbiAgY29uc3RydWN0b3IocHVibGljIHByb3A6IHN0cmluZykge1xuICAgIHRoaXMubmVzdGVkUHJvcCA9IG5ldyBOZXN0ZWRQcm9wZXJ0eShwcm9wKTtcbiAgfVxuXG4gIHB1YmxpYyBjb21wYXJlKGE6IFQsIGI6IFQpOiBudW1iZXIge1xuICAgIGxldCBwcm9wQSA9IHRoaXMubmVzdGVkUHJvcC5nZXRQcm9wVmFsdWUoYSk7XG4gICAgbGV0IHByb3BCID0gdGhpcy5uZXN0ZWRQcm9wLmdldFByb3BWYWx1ZShiKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcEEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm9wQSA9IHByb3BBLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcm9wQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByb3BCID0gcHJvcEIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByb3BBID09PSAndW5kZWZpbmVkJyB8fCBwcm9wQSA9PT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wQiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcEIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm9wQiA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcEIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChwcm9wQSA8IHByb3BCKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcEEgPiBwcm9wQikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vKipcbiAqIEVudW1lcmF0aW9uIHJlcHJlc2VudGluZyB0aGUgc29ydGluZyBvcmRlciBvZiBhIGRhdGFncmlkIGNvbHVtbi4gSXQgaXMgYSBjb25zdGFudCBFbnVtLFxuICogaS5lLiBlYWNoIHZhbHVlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXMgYSBgbnVtYmVyYCwgc3RhcnRpbmcgYXQgaW5kZXggMC5cbiAqXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5leHBvcnQgZW51bSBDbHJEYXRhZ3JpZFNvcnRPcmRlciB7XG4gIFVOU09SVEVEID0gMCxcbiAgQVNDID0gMSxcbiAgREVTQyA9IC0xLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbXBhcmF0b3IuaW50ZXJmYWNlJztcbmltcG9ydCB7IFN0YXRlRGVib3VuY2VyIH0gZnJvbSAnLi9zdGF0ZS1kZWJvdW5jZXIucHJvdmlkZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU29ydDxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3RhdGVEZWJvdW5jZXI6IFN0YXRlRGVib3VuY2VyKSB7fVxuXG4gIC8qKlxuICAgKiBDdXJyZW50bHkgYWN0aXZlIGNvbXBhcmF0b3JcbiAgICovXG4gIHByaXZhdGUgX2NvbXBhcmF0b3I6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPjtcbiAgcHVibGljIGdldCBjb21wYXJhdG9yKCk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBhcmF0b3I7XG4gIH1cbiAgcHVibGljIHNldCBjb21wYXJhdG9yKHZhbHVlOiBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2U8VD4pIHtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZVN0YXJ0KCk7XG4gICAgdGhpcy5fY29tcGFyYXRvciA9IHZhbHVlO1xuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzY2VuZGluZyBvcmRlciBpZiBmYWxzZSwgZGVzY2VuZGluZyBpZiB0cnVlXG4gICAqL1xuICBwcml2YXRlIF9yZXZlcnNlOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgcmV2ZXJzZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZTtcbiAgfVxuICBwdWJsaWMgc2V0IHJldmVyc2UodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZVN0YXJ0KCk7XG4gICAgdGhpcy5fcmV2ZXJzZSA9IHZhbHVlO1xuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlRG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBzb3J0IGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PFNvcnQ8VD4+KCk7XG4gIHByaXZhdGUgZW1pdENoYW5nZSgpIHtcbiAgICB0aGlzLl9jaGFuZ2UubmV4dCh0aGlzKTtcbiAgfVxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8U29ydDxUPj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIGNvbXBhcmF0b3IgYXMgdGhlIGN1cnJlbnQgb25lLCBvciB0b2dnbGVzIHJldmVyc2UgaWYgdGhlIGNvbXBhcmF0b3IgaXMgYWxyZWFkeSB1c2VkLiBUaGVcbiAgICogb3B0aW9uYWwgZm9yY2VSZXZlcnNlIGlucHV0IHBhcmFtZXRlciBhbGxvd3MgdG8gb3ZlcnJpZGUgdGhhdCB0b2dnbGluZyBiZWhhdmlvciBieSBzb3J0aW5nIGluXG4gICAqIHJldmVyc2Ugb3JkZXIgaWYgYHRydWVgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgU29ydFxuICAgKi9cbiAgcHVibGljIHRvZ2dsZShzb3J0Qnk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiwgZm9yY2VSZXZlcnNlPzogYm9vbGVhbikge1xuICAgIHRoaXMuc3RhdGVEZWJvdW5jZXIuY2hhbmdlU3RhcnQoKTtcbiAgICAvLyBXZSBtb2RpZnkgcHJpdmF0ZSBwcm9wZXJ0aWVzIGRpcmVjdGx5LCB0byBiYXRjaCB0aGUgY2hhbmdlIGV2ZW50XG4gICAgaWYgKHRoaXMuY29tcGFyYXRvciA9PT0gc29ydEJ5KSB7XG4gICAgICB0aGlzLl9yZXZlcnNlID0gdHlwZW9mIGZvcmNlUmV2ZXJzZSAhPT0gJ3VuZGVmaW5lZCcgPyBmb3JjZVJldmVyc2UgfHwgIXRoaXMuX3JldmVyc2UgOiAhdGhpcy5fcmV2ZXJzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29tcGFyYXRvciA9IHNvcnRCeTtcbiAgICAgIHRoaXMuX3JldmVyc2UgPSB0eXBlb2YgZm9yY2VSZXZlcnNlICE9PSAndW5kZWZpbmVkJyA/IGZvcmNlUmV2ZXJzZSA6IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICB0aGlzLnN0YXRlRGVib3VuY2VyLmNoYW5nZURvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGN1cnJlbnQgc29ydGluZyBvcmRlclxuICAgKi9cbiAgcHVibGljIGNsZWFyKCkge1xuICAgIHRoaXMuY29tcGFyYXRvciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdHdvIG9iamVjdHMgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGNvbXBhcmF0b3JcbiAgICovXG4gIHB1YmxpYyBjb21wYXJlKGE6IFQsIGI6IFQpOiBudW1iZXIge1xuICAgIHJldHVybiAodGhpcy5yZXZlcnNlID8gLTEgOiAxKSAqIHRoaXMuY29tcGFyYXRvci5jb21wYXJlKGEsIGIpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVtYmVkZGVkVmlld1JlZiwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEeW5hbWljV3JhcHBlciB9IGZyb20gJy4uLy4uL3V0aWxzL2hvc3Qtd3JhcHBpbmcvZHluYW1pYy13cmFwcGVyJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGctd3JhcHBlZC1jb2x1bW4nLFxuICB0ZW1wbGF0ZTogYCAgICAgICAgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjY29sdW1uUG9ydGFsPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIFdyYXBwZWRDb2x1bW4gaW1wbGVtZW50cyBEeW5hbWljV3JhcHBlciwgQWZ0ZXJWaWV3SW5pdCB7XG4gIF9keW5hbWljID0gZmFsc2U7XG5cbiAgQFZpZXdDaGlsZCgnY29sdW1uUG9ydGFsJykgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPHZvaWQ+O1xuICBjb2x1bW5WaWV3OiBFbWJlZGRlZFZpZXdSZWY8dm9pZD47IC8vIHRoZSBjb2x1bW5zIHByb2plY3RlZCB2aWV3IChpbiBtZW1vcnkpXG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIENyZWF0ZSB0aGUgY2VsbHMgdmlldyBpbiBtZW1vcnksIG5vdCB0aGUgRE9NLlxuICAgIHRoaXMuY29sdW1uVmlldyA9IHRoaXMudGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KG51bGwpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEhvc3RXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRQcm9wZXJ0eUNvbXBhcmF0b3IgfSBmcm9tICcuL2J1aWx0LWluL2NvbXBhcmF0b3JzL2RhdGFncmlkLXByb3BlcnR5LWNvbXBhcmF0b3InO1xuaW1wb3J0IHsgRGF0YWdyaWRQcm9wZXJ0eVN0cmluZ0ZpbHRlciB9IGZyb20gJy4vYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1wcm9wZXJ0eS1zdHJpbmctZmlsdGVyJztcbmltcG9ydCB7IERhdGFncmlkU3RyaW5nRmlsdGVySW1wbCB9IGZyb20gJy4vYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyLWltcGwnO1xuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTb3J0T3JkZXIgfSBmcm9tICcuL2VudW1zL3NvcnQtb3JkZXIuZW51bSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbXBhcmF0b3JJbnRlcmZhY2UgfSBmcm9tICcuL2ludGVyZmFjZXMvY29tcGFyYXRvci5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ3VzdG9tRmlsdGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvY3VzdG9tLWZpbHRlcic7XG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL3Byb3ZpZGVycy9maWx0ZXJzJztcbmltcG9ydCB7IFNvcnQgfSBmcm9tICcuL3Byb3ZpZGVycy9zb3J0JztcbmltcG9ydCB7IERhdGFncmlkRmlsdGVyUmVnaXN0cmFyIH0gZnJvbSAnLi91dGlscy9kYXRhZ3JpZC1maWx0ZXItcmVnaXN0cmFyJztcbmltcG9ydCB7IFdyYXBwZWRDb2x1bW4gfSBmcm9tICcuL3dyYXBwZWQtY29sdW1uJztcblxubGV0IG5iQ291bnQ6IG51bWJlciA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgPGRpdiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi1mbGV4XCI+XG4gICAgICAgICAgPCEtLSBJJ20gcmVhbGx5IG5vdCBoYXBweSB3aXRoIHRoYXQgc2VsZWN0IHNpbmNlIGl0J3Mgbm90IHZlcnkgc2NhbGFibGUgLS0+XG4gICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWZpbHRlciwgY2xyLWRnLXN0cmluZy1maWx0ZXJcIj48L25nLWNvbnRlbnQ+XG5cbiAgICAgICAgICA8Y2xyLWRnLXN0cmluZy1maWx0ZXJcbiAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZmllbGQgJiYgIWN1c3RvbUZpbHRlclwiXG4gICAgICAgICAgICAgICAgICBbY2xyRGdTdHJpbmdGaWx0ZXJdPVwicmVnaXN0ZXJlZFwiXG4gICAgICAgICAgICAgICAgICBbKGNsckZpbHRlclZhbHVlKV09XCJmaWx0ZXJWYWx1ZVwiPjwvY2xyLWRnLXN0cmluZy1maWx0ZXI+XG5cbiAgICAgICAgICA8bmctdGVtcGxhdGUgI2NvbHVtblRpdGxlPlxuICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkYXRhZ3JpZC1jb2x1bW4tdGl0bGVcIiAqbmdJZj1cInNvcnRhYmxlXCIgKGNsaWNrKT1cInNvcnQoKVwiIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbHVtblRpdGxlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgIDxjbHItaWNvblxuICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwic29ydEljb25cIlxuICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnNoYXBlXT1cInNvcnRJY29uXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInNvcnQtaWNvblwiPjwvY2xyLWljb24+XG4gICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImRhdGFncmlkLWNvbHVtbi10aXRsZVwiICpuZ0lmPVwiIXNvcnRhYmxlXCI+XG4gICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sdW1uVGl0bGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgIDxjbHItZGctY29sdW1uLXNlcGFyYXRvcj48L2Nsci1kZy1jb2x1bW4tc2VwYXJhdG9yPlxuICAgICAgPC9kaXY+XG4gIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLWNvbHVtbl0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1jb2x1bW4tLWhpZGRlbl0nOiAnaGlkZGVuJyxcbiAgICAnW2F0dHIuYXJpYS1zb3J0XSc6ICdhcmlhU29ydCcsXG4gICAgcm9sZTogJ2NvbHVtbmhlYWRlcicsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ29sdW1uPFQgPSBhbnk+IGV4dGVuZHMgRGF0YWdyaWRGaWx0ZXJSZWdpc3RyYXI8VCwgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsPFQ+PlxuICBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc29ydDogU29ydDxUPiwgZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LCBwcml2YXRlIHZjcjogVmlld0NvbnRhaW5lclJlZikge1xuICAgIHN1cGVyKGZpbHRlcnMpO1xuICAgIHRoaXMuX3NvcnRTdWJzY3JpcHRpb24gPSBfc29ydC5jaGFuZ2Uuc3Vic2NyaWJlKHNvcnQgPT4ge1xuICAgICAgLy8gV2UncmUgb25seSBsaXN0ZW5pbmcgdG8gbWFrZSBzdXJlIHdlIGVtaXQgYW4gZXZlbnQgd2hlbiB0aGUgY29sdW1uIGdvZXMgZnJvbSBzb3J0ZWQgdG8gdW5zb3J0ZWRcbiAgICAgIGlmICh0aGlzLnNvcnRPcmRlciAhPT0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuVU5TT1JURUQgJiYgc29ydC5jb21wYXJhdG9yICE9PSB0aGlzLl9zb3J0QnkpIHtcbiAgICAgICAgdGhpcy5fc29ydE9yZGVyID0gQ2xyRGF0YWdyaWRTb3J0T3JkZXIuVU5TT1JURUQ7XG4gICAgICAgIHRoaXMuc29ydE9yZGVyQ2hhbmdlLmVtaXQodGhpcy5fc29ydE9yZGVyKTtcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgc29ydEljb24gd2hlbiBjb2x1bW4gYmVjb21lcyB1bnNvcnRlZFxuICAgICAgICB0aGlzLnNvcnRJY29uID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIGRlcHJlY2F0ZWQ6IHRvIGJlIHJlbW92ZWQgLSBTVEFSVFxuICAgICAgaWYgKHRoaXMuc29ydGVkICYmIHNvcnQuY29tcGFyYXRvciAhPT0gdGhpcy5fc29ydEJ5KSB7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvcnRlZENoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIC8vIGRlcHJlY2F0ZWQ6IHRvIGJlIHJlbW92ZWQgLSBFTkRcbiAgICB9KTtcblxuICAgIHRoaXMuY29sdW1uSWQgPSAnZGctY29sLScgKyBuYkNvdW50LnRvU3RyaW5nKCk7IC8vIEFwcHJveGltYXRlIGEgR1VJRFxuICAgIG5iQ291bnQrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY29sdW1uSWRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgQ2xyRGF0YWdyaWRDb2x1bW4gY2xhc3MgdmFyaWFibGUgdGhhdCBob2xkcyB0aGUgbnVtYmVyIG9mIENsckRhdGFncmlkQ29sdW1uIGluc3RhbmNlcyBmb3IgYSBEYXRhZ3JpZC5cbiAgICogSXQgaXMgdXNlZCB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBpZCBmb3IgdGhlIENsckRhdGFncmlkQ29sdW1uIGluc3RhbmNlLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGNvbHVtbklkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoaWRkZW5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgcHJvcGVydHkgdGhhdCBhbGxvd3MgdGhlIGNvbHVtbiB0byBiZSBoaWRkZW4gLyBzaG93biB3aXRoIGNzc1xuICAgKiBOb3RlIHRoZSBkZWZhdWx0IGFsbG93cyB0aGUgQ2xyRGF0YWdyaWRDb2x1bW4gdG8gaGF2ZSBhbiAqbmdJZiBvbiBpdC4gKEVIQ0FJV0MgLSB3aWxsIG9jY3VyIGlmIGl0cyBub3RcbiAgICogaW5pdGlhbGl6ZWQpXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhpZGRlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmhpZGVhYmxlICYmIHRoaXMuaGlkZWFibGUuaGlkZGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbiB0byB0aGUgc29ydCBzZXJ2aWNlIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX3NvcnRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zb3J0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKlxuICAgICAqIFNpbXBsZSBvYmplY3QgcHJvcGVydHkgc2hvcnRjdXQsIGFjdGl2YXRlcyBib3RoIHNvcnRpbmcgYW5kIGZpbHRlcmluZ1xuICAgICAqIGJhc2VkIG9uIG5hdGl2ZSBjb21wYXJpc29uIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgb24gdGhlIGl0ZW1zLlxuICAgICAqL1xuICBwcml2YXRlIF9maWVsZDogc3RyaW5nO1xuICBwdWJsaWMgZ2V0IGZpZWxkKCkge1xuICAgIHJldHVybiB0aGlzLl9maWVsZDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdGaWVsZCcpXG4gIHB1YmxpYyBzZXQgZmllbGQoZmllbGQ6IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9maWVsZCA9IGZpZWxkO1xuICAgICAgaWYgKCF0aGlzLmN1c3RvbUZpbHRlcikge1xuICAgICAgICB0aGlzLnNldEZpbHRlcihuZXcgRGF0YWdyaWRTdHJpbmdGaWx0ZXJJbXBsKG5ldyBEYXRhZ3JpZFByb3BlcnR5U3RyaW5nRmlsdGVyKGZpZWxkKSkpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3J0QnkpIHtcbiAgICAgICAgdGhpcy5fc29ydEJ5ID0gbmV3IERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yKGZpZWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xyRGF0YWdyaWRDb21wYXJhdG9ySW50ZXJmYWNlIHRvIHVzZSB3aGVuIHNvcnRpbmcgdGhlIGNvbHVtblxuICAgKi9cblxuICBwcml2YXRlIF9zb3J0Qnk6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPjtcblxuICBwdWJsaWMgZ2V0IHNvcnRCeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydEJ5O1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NvcnRCeScpXG4gIHB1YmxpYyBzZXQgc29ydEJ5KGNvbXBhcmF0b3I6IENsckRhdGFncmlkQ29tcGFyYXRvckludGVyZmFjZTxUPiB8IHN0cmluZykge1xuICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3NvcnRCeSA9IG5ldyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcihjb21wYXJhdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy5fc29ydEJ5ID0gY29tcGFyYXRvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9maWVsZCkge1xuICAgICAgICAgIHRoaXMuX3NvcnRCeSA9IG5ldyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcih0aGlzLl9maWVsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3NvcnRCeTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZVxuICAgKi9cbiAgcHVibGljIGdldCBzb3J0YWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9zb3J0Qnk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgY29sdW1uIGlzIGN1cnJlbnRseSBzb3J0ZWRcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgc29vbiwgaW4gZmF2b3Igb2YgdGhlIHNvcnRPcmRlciBtZWNoYW5pc21cbiAgICovXG4gIHByaXZhdGUgX3NvcnRlZCA9IGZhbHNlO1xuICBwdWJsaWMgZ2V0IHNvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAqL1xuICBASW5wdXQoJ2NsckRnU29ydGVkJylcbiAgcHVibGljIHNldCBzb3J0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAoIXZhbHVlICYmIHRoaXMuc29ydGVkKSB7XG4gICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NvcnQuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmICF0aGlzLnNvcnRlZCkge1xuICAgICAgdGhpcy5zb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgd2lsbCBiZSByZW1vdmVkIHNvb24sIGluIGZhdm9yIG9mIHRoZSBzb3J0T3JkZXIgbWVjaGFuaXNtXG4gICAqL1xuICBAT3V0cHV0KCdjbHJEZ1NvcnRlZENoYW5nZScpIHB1YmxpYyBzb3J0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIEVORFxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaG93IHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHNvcnRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydE9yZGVyOiBDbHJEYXRhZ3JpZFNvcnRPcmRlciA9IENsckRhdGFncmlkU29ydE9yZGVyLlVOU09SVEVEO1xuICBwdWJsaWMgZ2V0IHNvcnRPcmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ydE9yZGVyO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1NvcnRPcmRlcicpXG4gIHB1YmxpYyBzZXQgc29ydE9yZGVyKHZhbHVlOiBDbHJEYXRhZ3JpZFNvcnRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb25seSBpZiB0aGUgaW5jb21pbmcgb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgb25lXG4gICAgaWYgKHRoaXMuX3NvcnRPcmRlciA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAvLyB0aGUgVW5zb3J0ZWQgY2FzZSBoYXBwZW5zIHdoZW4gdGhlIGN1cnJlbnQgc3RhdGUgaXMgZWl0aGVyIEFzYyBvciBEZXNjXG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRDpcbiAgICAgICAgdGhpcy5fc29ydC5jbGVhcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuQVNDOlxuICAgICAgICB0aGlzLnNvcnQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuREVTQzpcbiAgICAgICAgdGhpcy5zb3J0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFyaWFTb3J0KCkge1xuICAgIHN3aXRjaCAodGhpcy5fc29ydE9yZGVyKSB7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5VTlNPUlRFRDpcbiAgICAgICAgcmV0dXJuICdub25lJztcbiAgICAgIGNhc2UgQ2xyRGF0YWdyaWRTb3J0T3JkZXIuQVNDOlxuICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XG4gICAgICBjYXNlIENsckRhdGFncmlkU29ydE9yZGVyLkRFU0M6XG4gICAgICAgIHJldHVybiAnZGVzY2VuZGluZyc7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdTb3J0T3JkZXJDaGFuZ2UnKSBwdWJsaWMgc29ydE9yZGVyQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJEYXRhZ3JpZFNvcnRPcmRlcj4oKTtcblxuICAvKipcbiAgICogU29ydHMgdGhlIGRhdGFncmlkIGJhc2VkIG9uIHRoaXMgY29sdW1uXG4gICAqL1xuICBwdWJsaWMgc29ydChyZXZlcnNlPzogYm9vbGVhbikge1xuICAgIGlmICghdGhpcy5zb3J0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NvcnQudG9nZ2xlKHRoaXMuX3NvcnRCeSwgcmV2ZXJzZSk7XG5cbiAgICAvLyBzZXR0aW5nIHRoZSBwcml2YXRlIHZhcmlhYmxlIHRvIG5vdCByZXRyaWdnZXIgdGhlIHNldHRlciBsb2dpY1xuICAgIHRoaXMuX3NvcnRPcmRlciA9IHRoaXMuX3NvcnQucmV2ZXJzZSA/IENsckRhdGFncmlkU29ydE9yZGVyLkRFU0MgOiBDbHJEYXRhZ3JpZFNvcnRPcmRlci5BU0M7XG4gICAgLy8gU2V0cyB0aGUgY29ycmVjdCBpY29uIGZvciBjdXJyZW50IHNvcnQgb3JkZXJcbiAgICB0aGlzLnNvcnRJY29uID0gdGhpcy5fc29ydE9yZGVyID09PSBDbHJEYXRhZ3JpZFNvcnRPcmRlci5ERVNDID8gJ2Fycm93IGRvd24nIDogJ2Fycm93JztcbiAgICB0aGlzLnNvcnRPcmRlckNoYW5nZS5lbWl0KHRoaXMuX3NvcnRPcmRlcik7XG5cbiAgICAvLyBkZXByZWNhdGVkOiB0byBiZSByZW1vdmVkIC0gU1RBUlRcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIHRoaXMuc29ydGVkQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgLy8gZGVwcmVjYXRlZDogdG8gYmUgcmVtb3ZlZCAtIEVORFxuICB9XG5cbiAgcHVibGljIHNvcnRJY29uO1xuXG4gIC8qKlxuICAgKiBBIGN1c3RvbSBmaWx0ZXIgZm9yIHRoaXMgY29sdW1uIHRoYXQgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBwcm9qZWN0ZWQgY29udGVudFxuICAgKi9cbiAgcHVibGljIGN1c3RvbUZpbHRlciA9IGZhbHNlO1xuXG4gIEBDb250ZW50Q2hpbGQoQ3VzdG9tRmlsdGVyKVxuICBwdWJsaWMgc2V0IHByb2plY3RlZEZpbHRlcihjdXN0b206IGFueSkge1xuICAgIGlmIChjdXN0b20pIHtcbiAgICAgIHRoaXMuZGVsZXRlRmlsdGVyKCk7XG4gICAgICB0aGlzLmN1c3RvbUZpbHRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBmaWx0ZXJWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIudmFsdWU7XG4gIH1cblxuICBASW5wdXQoJ2NsckZpbHRlclZhbHVlJylcbiAgcHVibGljIHNldCB1cGRhdGVGaWx0ZXJWYWx1ZShuZXdWYWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5ld1ZhbHVlKSB7XG4gICAgICBuZXdWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuZmlsdGVyLnZhbHVlKSB7XG4gICAgICB0aGlzLmZpbHRlci52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzZXQgZmlsdGVyVmFsdWUobmV3VmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMudXBkYXRlRmlsdGVyVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB0aGlzLmZpbHRlclZhbHVlQ2hhbmdlLmVtaXQodGhpcy5maWx0ZXIudmFsdWUpO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyRmlsdGVyVmFsdWVDaGFuZ2UnKSBmaWx0ZXJWYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKioqKioqKioqKipcbiAgICpcbiAgICogQHByb3BlcnR5IGhpZGVhYmxlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBXaGVuIGEgY29sdW1uIGlzIGhpZGVhYmxlIHRoaXMgaXMgZGVmaW5lZCB3aXRoIGFuIGluc3RhbmNlIG9mIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbC5cbiAgICogV2hlbiBpdHMgbm90IGhpZGVhYmxlIHNob3VsZCBiZSB1bmRlZmluZWQuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgaGlkZWFibGU6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbDtcblxuICBwcml2YXRlIHdyYXBwZWRJbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy53cmFwcGVkSW5qZWN0b3IgPSBuZXcgSG9zdFdyYXBwZXIoV3JhcHBlZENvbHVtbiwgdGhpcy52Y3IpO1xuICB9XG5cbiAgcHVibGljIGdldCBfdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5qZWN0b3IuZ2V0KFdyYXBwZWRDb2x1bW4sIHRoaXMudmNyKS5jb2x1bW5WaWV3O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBGaWx0ZXJzUHJvdmlkZXIgfSBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcGFnZSc7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9zb3J0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEl0ZW1zPFQgPSBhbnk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZmlsdGVyczogRmlsdGVyc1Byb3ZpZGVyPFQ+LCBwcml2YXRlIF9zb3J0OiBTb3J0PFQ+LCBwcml2YXRlIF9wYWdlOiBQYWdlKSB7fVxuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGRhdGEgaXMgY3VycmVudGx5IGxvYWRpbmdcbiAgICovXG4gIHB1YmxpYyBsb2FkaW5nID0gZmFsc2U7XG5cbiAgLy8gVE9ETzogVmVyaWZ5IHRoYXQgdHJhY2tCeSBpcyByZWdpc3RlcmVkIGZvciB0aGUgKm5nRm9yIGNhc2UgdG9vXG4gIC8qKlxuICAgKiBUcmFja2luZyBmdW5jdGlvbiB0byBpZGVudGlmeSBvYmplY3RzLiBEZWZhdWx0IGlzIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAgICovXG4gIHB1YmxpYyB0cmFja0J5OiBUcmFja0J5RnVuY3Rpb248VD4gPSAoaW5kZXg6IG51bWJlciwgaXRlbTogVCkgPT4gaXRlbTtcblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9ucyB0byB0aGUgb3RoZXIgcHJvdmlkZXJzIGNoYW5nZXMuXG4gICAqL1xuICBwcml2YXRlIF9maWx0ZXJzU3ViOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX3NvcnRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBfcGFnZVN1YjogU3Vic2NyaXB0aW9uO1xuICAvKipcbiAgICogQ2xlYW5zIHVwIG91ciBzdWJzY3JpcHRpb25zIHRvIG90aGVyIHByb3ZpZGVyc1xuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlcnNTdWIpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnNTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnRTdWIpIHtcbiAgICAgIHRoaXMuX3NvcnRTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhZ2VTdWIpIHtcbiAgICAgIHRoaXMuX3BhZ2VTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgdXNlIHNtYXJ0IGl0ZW1zIGZvciB0aGlzIGRhdGFncmlkIG9yIGxldCB0aGUgdXNlciBoYW5kbGVcbiAgICogZXZlcnl0aGluZy5cbiAgICovXG4gIHByaXZhdGUgX3NtYXJ0ID0gZmFsc2U7XG4gIHB1YmxpYyBnZXQgc21hcnQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3NtYXJ0O1xuICB9XG4gIHB1YmxpYyBzbWFydGVuVXAoKSB7XG4gICAgdGhpcy5fc21hcnQgPSB0cnVlO1xuICAgIC8qXG4gICAgICAgICAqIFRoZXNlIG9ic2VydmVycyB0cmlnZ2VyIGEgY2hhaW4gb2YgZnVuY3Rpb246IGZpbHRlciAtPiBzb3J0IC0+IHBhZ2luYXRlXG4gICAgICAgICAqIEFuIG9ic2VydmVyIHVwIHRoZSBjaGFpbiByZS10cmlnZ2VycyBhbGwgdGhlIG9wZXJhdGlvbnMgdGhhdCBmb2xsb3cgaXQuXG4gICAgICAgICAqL1xuICAgIHRoaXMuX2ZpbHRlcnNTdWIgPSB0aGlzLl9maWx0ZXJzLmNoYW5nZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZmlsdGVySXRlbXMoKSk7XG4gICAgdGhpcy5fc29ydFN1YiA9IHRoaXMuX3NvcnQuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UsIGlmIHRoZSBkYXRhZ3JpZCB3ZW50IGZyb20gc29ydGVkIHRvIHVuc29ydGVkLCB3ZSBoYXZlIHRvIHJlLWZpbHRlclxuICAgICAgLy8gdG8gZ2V0IHRoZSBvcmlnaW5hbCBvcmRlciBiYWNrXG4gICAgICBpZiAoIXRoaXMuX3NvcnQuY29tcGFyYXRvcikge1xuICAgICAgICB0aGlzLl9maWx0ZXJJdGVtcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc29ydEl0ZW1zKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcGFnZVN1YiA9IHRoaXMuX3BhZ2UuY2hhbmdlLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9jaGFuZ2VQYWdlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYWxsIGl0ZW1zIGluIHRoZSBkYXRhZ3JpZFxuICAgKi9cbiAgcHJpdmF0ZSBfYWxsOiBUW107XG4gIHB1YmxpYyBnZXQgYWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9hbGw7XG4gIH1cbiAgcHVibGljIHNldCBhbGwoaXRlbXM6IFRbXSkge1xuICAgIHRoaXMuX2FsbCA9IGl0ZW1zO1xuICAgIHRoaXMuZW1pdEFsbENoYW5nZXMoaXRlbXMpO1xuICAgIGlmICh0aGlzLnNtYXJ0KSB7XG4gICAgICB0aGlzLl9maWx0ZXJJdGVtcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kaXNwbGF5ZWQgPSBpdGVtcztcbiAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSByZWNvbXB1dGUgdGhlIGxpc3Qgb2YgZGlzcGxheWVkIGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5zbWFydCkge1xuICAgICAgdGhpcy5fZmlsdGVySXRlbXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgdGVtcG9yYXJ5IHN0ZXAsIHdoaWNoIHdlIHByZXNlcnZlIHRvIGF2b2lkIHJlLWZpbHRlcmluZyBvciByZS1zb3J0aW5nIGlmIG5vdCBuZWNlc3NhcnlcbiAgICovXG4gIHByaXZhdGUgX2ZpbHRlcmVkOiBUW107XG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgaXRlbXMgY3VycmVudGx5IGRpc3BsYXllZFxuICAgKi9cbiAgcHJpdmF0ZSBfZGlzcGxheWVkOiBUW10gPSBbXTtcbiAgcHVibGljIGdldCBkaXNwbGF5ZWQoKTogVFtdIHtcbiAgICAvLyBJZGVhbGx5IHdlIGNvdWxkIHJldHVybiBhbiBpbW11dGFibGUgYXJyYXksIGJ1dCB3ZSBkb24ndCBoYXZlIGl0IGluIENsYXJpdHkgeWV0LlxuICAgIHJldHVybiB0aGlzLl9kaXNwbGF5ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIE9ic2VydmFibGUgdGhhdCBsZXRzIG90aGVyIGNsYXNzZXMgc3Vic2NyaWJlIHRvIGl0ZW1zIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZSA9IG5ldyBTdWJqZWN0PFRbXT4oKTtcbiAgcHJpdmF0ZSBlbWl0Q2hhbmdlKCkge1xuICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuZGlzcGxheWVkKTtcbiAgfVxuICAvLyBXZSBkbyBub3Qgd2FudCB0byBleHBvc2UgdGhlIFN1YmplY3QgaXRzZWxmLCBidXQgdGhlIE9ic2VydmFibGUgd2hpY2ggaXMgcmVhZC1vbmx5XG4gIHB1YmxpYyBnZXQgY2hhbmdlKCk6IE9ic2VydmFibGU8VFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2FsbENoYW5nZXMgPSBuZXcgU3ViamVjdDxUW10+KCk7XG4gIHByaXZhdGUgZW1pdEFsbENoYW5nZXMoaXRlbXM6IFRbXSk6IHZvaWQge1xuICAgIHRoaXMuX2FsbENoYW5nZXMubmV4dChpdGVtcyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGFsbENoYW5nZXMoKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICByZXR1cm4gdGhpcy5fYWxsQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgd2UgZG9uJ3QgaGF2ZSBkYXRhIHRvIHByb2Nlc3MgeWV0LCB0byBhYm9ydCBlYXJseSBvcGVyYXRpb25zXG4gICAqL1xuICBwcml2YXRlIGdldCB1bmluaXRpYWxpemVkKCkge1xuICAgIHJldHVybiAhdGhpcy5fYWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbHRlcnNQcm92aWRlciBpdGVtcyBmcm9tIHRoZSByYXcgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfZmlsdGVySXRlbXMoKSB7XG4gICAgaWYgKHRoaXMudW5pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZmlsdGVycy5oYXNBY3RpdmVGaWx0ZXJzKCkpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcmVkID0gdGhpcy5fYWxsLmZpbHRlcihpdGVtID0+IHRoaXMuX2ZpbHRlcnMuYWNjZXB0cyhpdGVtKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdvcmsgb24gYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5LCB0byBub3QgbW9kaWZ5IHRoZSB1c2VyJ3MgbW9kZWxcbiAgICAgIHRoaXMuX2ZpbHRlcmVkID0gdGhpcy5fYWxsLnNsaWNlKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2UudG90YWxJdGVtcyA9IHRoaXMuX2ZpbHRlcmVkLmxlbmd0aDtcbiAgICB0aGlzLl9zb3J0SXRlbXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTb3J0cyBpdGVtcyBpbiB0aGUgZmlsdGVyZWQgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBfc29ydEl0ZW1zKCkge1xuICAgIGlmICh0aGlzLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnQuY29tcGFyYXRvcikge1xuICAgICAgdGhpcy5fZmlsdGVyZWQuc29ydCgoYSwgYikgPT4gdGhpcy5fc29ydC5jb21wYXJlKGEsIGIpKTtcbiAgICB9XG4gICAgdGhpcy5fY2hhbmdlUGFnZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgc29ydGVkIGxpc3RcbiAgICovXG4gIHByaXZhdGUgX2NoYW5nZVBhZ2UoKSB7XG4gICAgLy8gSWYgd2Uga25vdyB3ZSBoYXZlIHBhZ2luYXRpb24gYnV0IHRoZSBwYWdlIHNpemUgaGFzbid0IGJlZW4gc2V0IHlldCwgd2Ugd2FpdCBmb3IgaXQuXG4gICAgaWYgKHRoaXMudW5pbml0aWFsaXplZCB8fCAodGhpcy5fcGFnZS5hY3RpdmF0ZWQgJiYgdGhpcy5fcGFnZS5zaXplID09PSAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFnZS5zaXplID4gMCkge1xuICAgICAgdGhpcy5fZGlzcGxheWVkID0gdGhpcy5fZmlsdGVyZWQuc2xpY2UodGhpcy5fcGFnZS5maXJzdEl0ZW0sIHRoaXMuX3BhZ2UubGFzdEl0ZW0gKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZGlzcGxheWVkID0gdGhpcy5fZmlsdGVyZWQ7XG4gICAgfVxuICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ0Zvck9mLCBOZ0Zvck9mQ29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBEaXJlY3RpdmUsXG4gIERvQ2hlY2ssXG4gIElucHV0LFxuICBJdGVyYWJsZURpZmZlcixcbiAgSXRlcmFibGVEaWZmZXJzLFxuICBUZW1wbGF0ZVJlZixcbiAgVHJhY2tCeUZ1bmN0aW9uLFxuICBWaWV3Q29udGFpbmVyUmVmLFxuICBPbkRlc3Ryb3ksXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vcHJvdmlkZXJzL2l0ZW1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2xyRGdJdGVtc11bY2xyRGdJdGVtc09mXScsXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkSXRlbXM8VD4gaW1wbGVtZW50cyBEb0NoZWNrLCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGl0ZXJhYmxlUHJveHk6IE5nRm9yT2Y8VD47XG4gIHByaXZhdGUgX3Jhd0l0ZW1zOiBUW107XG4gIHByaXZhdGUgZGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPiB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgQElucHV0KCdjbHJEZ0l0ZW1zT2YnKVxuICBwdWJsaWMgc2V0IHJhd0l0ZW1zKGl0ZW1zOiBUW10pIHtcbiAgICB0aGlzLl9yYXdJdGVtcyA9IGl0ZW1zID8gaXRlbXMgOiBbXTsgLy8gbG9jYWwgY29weSBmb3IgbmdPbkNoYW5nZSBkaWZmaW5nXG4gIH1cblxuICBASW5wdXQoJ2NsckRnSXRlbXNUcmFja0J5JylcbiAgc2V0IHRyYWNrQnkodmFsdWU6IFRyYWNrQnlGdW5jdGlvbjxUPikge1xuICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0ZvclRyYWNrQnkgPSB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8TmdGb3JPZkNvbnRleHQ8VD4+LFxuICAgIHByaXZhdGUgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLFxuICAgIHByaXZhdGUgaXRlbXM6IEl0ZW1zLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge1xuICAgIGl0ZW1zLnNtYXJ0ZW5VcCgpO1xuICAgIHRoaXMuaXRlcmFibGVQcm94eSA9IG5ldyBOZ0Zvck9mPFQ+KHRoaXMudmNyLCB0aGlzLnRlbXBsYXRlLCB0aGlzLmRpZmZlcnMpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgaXRlbXMuY2hhbmdlLnN1YnNjcmliZShuZXdJdGVtcyA9PiB7XG4gICAgICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0Zvck9mID0gbmV3SXRlbXM7XG4gICAgICAgIHRoaXMuaXRlcmFibGVQcm94eS5uZ0RvQ2hlY2soKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nRG9DaGVjaygpIHtcbiAgICBpZiAoIXRoaXMuZGlmZmVyKSB7XG4gICAgICB0aGlzLmRpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKHRoaXMuX3Jhd0l0ZW1zKS5jcmVhdGUodGhpcy5pdGVyYWJsZVByb3h5Lm5nRm9yVHJhY2tCeSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpZmZlcikge1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYodGhpcy5fcmF3SXRlbXMpO1xuICAgICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgICAgLy8gVE9ETzogbm90IHZlcnkgZWZmaWNpZW50IHJpZ2h0IG5vdyxcbiAgICAgICAgLy8gYnV0IHByZW1hdHVyZSBvcHRpbWl6YXRpb24gaXMgdGhlIHJvb3Qgb2YgYWxsIGV2aWwuXG4gICAgICAgIHRoaXMuaXRlbXMuYWxsID0gdGhpcy5fcmF3SXRlbXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vcHJvdmlkZXJzL2l0ZW1zJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXBsYWNlaG9sZGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3M9XCJkYXRhZ3JpZC1wbGFjZWhvbGRlclwiXG4gICAgICAgICAgICBbY2xhc3MuZGF0YWdyaWQtZW1wdHldPVwiZW1wdHlEYXRhZ3JpZFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1wbGFjZWhvbGRlci1pbWFnZVwiICpuZ0lmPVwiZW1wdHlEYXRhZ3JpZFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50ICpuZ0lmPVwiZW1wdHlEYXRhZ3JpZFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmRhdGFncmlkLXBsYWNlaG9sZGVyLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRQbGFjZWhvbGRlcjxUID0gYW55PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaXRlbXM6IEl0ZW1zPFQ+KSB7fVxuXG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGUgZGF0YWdyaWQgaXMgZW1wdHksIG1lYW5pbmcgaXQgZG9lc24ndCBjb250YWluIGFueSBpdGVtc1xuICAgKi9cbiAgcHVibGljIGdldCBlbXB0eURhdGFncmlkKCkge1xuICAgIHJldHVybiAhdGhpcy5pdGVtcy5sb2FkaW5nICYmICghdGhpcy5pdGVtcy5kaXNwbGF5ZWQgfHwgdGhpcy5pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoID09PSAwKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5leHBvcnQgY29uc3QgUE9QT1ZFUl9IT1NUX0FOQ0hPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxFbGVtZW50UmVmPignUE9QT1ZFUl9IT1NUX0FOQ0hPUicpO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIE9uRGVzdHJveSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgSWZPcGVuU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLW9wZW4uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJTaWducG9zdFRyaWdnZXJdJywgaG9zdDogeyBjbGFzczogJ3NpZ25wb3N0LXRyaWdnZXInIH0gfSlcblxuLyoqKioqKioqKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSBEaXJlY3RpdmUgYWRkZWQgdG8gdGhlIENsclNpZ25wb3N0IFRyaWdnZXIgYnV0dG9uIHRoYXQgd2lsbCBjYWxsIHRoZSBDbHJTaWducG9zdC50b2dnbGUoKSBmdW5jdGlvbiB0byBoaWRlL3Nob3cgdGhlXG4gKiBDbHJTaWducG9zdENvbnRlbnQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2xyU2lnbnBvc3RUcmlnZ2VyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSwgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsOiBFbGVtZW50UmVmKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmlmT3BlblNlcnZpY2Uub3BlbkNoYW5nZS5zdWJzY3JpYmUoKGlzT3BlbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoaXNPcGVuKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdhY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBjbGljayBoYW5kbGVyIGZvciB0aGUgQ2xyU2lnbnBvc3QgdHJpZ2dlciBidXR0b24gdXNlZCB0byBoaWRlL3Nob3cgQ2xyU2lnbnBvc3RDb250ZW50LlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICBvblNpZ25wb3N0VHJpZ2dlckNsaWNrKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS50b2dnbGVXaXRoRXZlbnQoZXZlbnQpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbmltcG9ydCB7IENsclNpZ25wb3N0VHJpZ2dlciB9IGZyb20gJy4vc2lnbnBvc3QtdHJpZ2dlcic7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc2lnbnBvc3QnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXVzZUN1c3RvbVRyaWdnZXJcIj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInNpZ25wb3N0LWFjdGlvbiBidG4gYnRuLXNtYWxsIGJ0bi1saW5rXCJcbiAgICAgICAgICAgICAgICBjbHJTaWducG9zdFRyaWdnZXI+XG4gICAgICAgICAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiaW5mb1wiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MuaW5mb1wiPjwvY2xyLWljb24+XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLnNpZ25wb3N0XSc6ICd0cnVlJyB9LFxuICBwcm92aWRlcnM6IFtJZk9wZW5TZXJ2aWNlLCB7IHByb3ZpZGU6IFBPUE9WRVJfSE9TVF9BTkNIT1IsIHVzZUV4aXN0aW5nOiBFbGVtZW50UmVmIH1dLFxufSlcblxuLyoqKioqKioqKlxuICpcbiAqIEBjbGFzcyBDbHJTaWducG9zdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ2xhc3MgdXNlZCB0byBjb25maWd1cmUgYW5kIGNvbnRyb2wgdGhlIHN0YXRlIG9mIGEgQ2xyU2lnbnBvc3QgYW5kIGl0cyBhc3NvY2lhdGVkIENsclNpZ25wb3N0Q29udGVudC5cbiAqIEl0IHN1cHBvcnRzIHRoZSBjbHJQb3NpdGlvbiB3aXRoIGEgJ3JpZ2h0LW1pZGRsZScgZGVmYXVsdC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJTaWducG9zdCB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzKSB7fVxuXG4gIC8qKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSB1c2VDdXN0b21UcmlnZ2VyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBGbGFnIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gdXNlIHRoZSBkZWZhdWx0IHRyaWdnZXIgb3IgYSB1c2VyIHN1cHBsaWVkIHRyaWdnZXIgZWxlbWVudC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyB1c2VDdXN0b21UcmlnZ2VyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqKioqKioqKipcbiAgICogQHByb3BlcnR5IHNpZ25Qb3N0VHJpZ2dlclxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVXNlcyBDb250ZW50Q2hpbGQgdG8gY2hlY2sgZm9yIGEgdXNlciBzdXBwbGllZCBlbGVtZW50IHdpdGggdGhlIENsclNpZ25wb3N0VHJpZ2dlciBvbiBpdC5cbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGQoQ2xyU2lnbnBvc3RUcmlnZ2VyKVxuICBzZXQgY3VzdG9tVHJpZ2dlcih0cmlnZ2VyOiBDbHJTaWducG9zdFRyaWdnZXIpIHtcbiAgICB0aGlzLnVzZUN1c3RvbVRyaWdnZXIgPSAhIXRyaWdnZXI7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4uL2RhdGFncmlkLWhpZGVhYmxlLWNvbHVtbi5tb2RlbCc7XG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQW4gQEluamVjdGFibGUgcHJvdmlkZXIgY2xhc3MgdGhhdCBlbmFibGVzXG4gKlxuICogMS4gTWFuYWdpbmcsIHRyYWNrIGhpZGVhYmlsaXR5IG9mIERhdGFncmlkQ29sdW1uc1xuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhpZGVhYmxlQ29sdW1uU2VydmljZSB7XG4gIC8qKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBkZ0hpZGRlbkNvbHVtbk1hcFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQW4gYXJyYXkgb2YgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbi5cbiAgICogTk9URTogYmVjYXVzZSB3ZSBjYW4gaGF2ZSBjb2x1bW5zIHcvbyB0aGUgKmNsckRnSGlkZWFibGVDb2x1bW4gZGlyZWN0aXZlXG4gICAqIHRoaXMgYXJyYXkgd2lsbCBoYXZlIGVtcHR5IHNwYWNlcyBhLmsuYSBudWxscy4gVGhpcyBpcyBuZWVkZWQgdG8gYmUgYWJsZSB0byBtYXBcbiAgICogRGF0YWdyaWRDZWxscyB0byBEYXRhZ3JpZENvbHVtbnMgaW4gdGhlIFJvd1JlbmRlcmVyLlxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfY29sdW1uTGlzdDogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10gPSBbXTtcblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAcHJvcGVydHkgZGdIaWRkZW5Db2x1bW5NYXBDaGFuZ2VcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgYmVoYXZpb3Igc3ViamVjdCB0aGF0IGNhbiBicm9hZGNhc3QgdXBkYXRlcyB0byB0aGUgY29sdW1uIGxpc3QuXG4gICAqIE5PVEU6IEkgYW0gdXNpbmcgQmVoYXZpb3JTdWJqZWN0IGJlY2F1c2UgPGNsci1kZy1jb2x1bW4tdG9nZ2xlPiBpcyBub3QgZ2V0dGluZyB0aGUgbGF0ZXN0IF9jb2x1bW5MaXN0Q2hhbmdlXG4gICAqIG9uIHBhZ2UgbG9hZC5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2NvbHVtbkxpc3RDaGFuZ2U6IEJlaGF2aW9yU3ViamVjdDxEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFxuICAgIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdXG4gID4odGhpcy5fY29sdW1uTGlzdCk7XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQHByb3BlcnR5IGNhbkhpZGVOZXh0Q29sdW1uXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXJ2aWNlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGJ5IGNsci1kZy1jb2x1bW4tdG9nZ2xlIGNvbXBvbmVudC4gVXNlIHRoaXMgaWYgeW91IG5lZWQgdG8gYXNrIGlmIHlvdSBjYW4gaGlkZVxuICAgKiBhIGNvbHVtbi4gSXQgYWN0cyBhcyBhIGd1YXJkIGFnYWluc3QgaGlkaW5nIGFsbCB0aGUgY29sdW1ucyBtYWtpbmcgc3VyZSB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgY29sdW1uIGRpc3BsYXllZC5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY2FuSGlkZU5leHRDb2x1bW4oKTogYm9vbGVhbiB7XG4gICAgY29uc3QgaGlkZGVuQ29sdW1ucyA9IHRoaXMuX2NvbHVtbkxpc3QuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4gIT09IHVuZGVmaW5lZCkuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uaGlkZGVuKTtcbiAgICByZXR1cm4gdGhpcy5fY29sdW1uTGlzdC5sZW5ndGggLSBoaWRkZW5Db2x1bW5zLmxlbmd0aCA+IDE7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAcHJvcGVydHkgY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRm9yIHdoZW4geW91IG5lZWQgdG8ga25vdyBpZiB0aGUgZGF0YWdyaWQncyBjb2x1bW5zIGFyZSBhbGwgc2hvd2luZy5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuX2NvbHVtbkxpc3Quc29tZShjb2x1bW4gPT4gY29sdW1uICYmIGNvbHVtbi5oaWRkZW4pO1xuICB9XG5cbiAgLyoqKioqKioqKioqXG4gICAqIEBwcm9wZXJ0eSBjb2x1bW5MaXN0Q2hhbmdlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHB1YmxpYyBwcm9wZXJ0eSB0aGF0IGVuYWJsZXMgc3Vic2NyaWJlcnMgdG8gaGVhciB1cGRhdGVzIHRvIHRoZSBjb2x1bW4gbWFwLlxuICAgKiBVc2UgdGhpcyBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmcgd2hlbmV2ZXIgdGhlIERhdGFncmlkJ3MgY29sdW1uIGxpc3QgaXMgY2hhbmdlZCAoaS5lICpuZ0lmIG9uIGEgY29sdW1uKS5cbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY29sdW1uTGlzdENoYW5nZSgpOiBPYnNlcnZhYmxlPERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbHVtbkxpc3RDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBsaXN0IG9mIGNvbHVtbnMuIEkgbmVlZGVkIGFuIGFycmF5IG9mIHRvIGl0ZXJhdGUgb24gaW4gdGhlIFJvd1JlbmRlcmVyXG4gICAqIGJ1dCBzdWJzY3JpYmluZyB0byB0aGUgX2NvbHVtbkxpc3RDaGFuZ2UgY2hhbmdlcyBkaWQgbm90IHNlZW0gbGlrZSB0aGUgY29ycmVjdCB3YXkgdG8gZ2V0IGl0LlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldENvbHVtbnMoKTogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10ge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5MaXN0O1xuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY3VycmVudCBfY29sdW1uTGlzdDpcbiAgICogLSBpZiBpdCBoYXMgYSBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIGFuZCBpcyBoaWRkZW4gdGhlbiBzaG93IGl0LlxuICAgKiAtIGlmIGl0J3MgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiB3YXMgcHJldmlvdXNseSB0aGUgbGFzdCBjb2x1bW4gdmlzaWJsZSwgdHVybiB0aGF0IGZsYWcgb2ZmLlxuICAgKlxuICAgKi9cbiAgcHVibGljIHNob3dIaWRkZW5Db2x1bW5zKCkge1xuICAgIHRoaXMuX2NvbHVtbkxpc3QuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4uaGlkZGVuID09PSB0cnVlKSB7XG4gICAgICAgIGNvbHVtbi5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4pIHtcbiAgICAgICAgY29sdW1uLmxhc3RWaXNpYmxlQ29sdW1uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGNvbHVtbnM6IERhdGFncmlkQ29sdW1uW11cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbidzIHx8IG51bGwgYmFzZWQgY29sdW1uIGFycmF5IHBhc3NlZCBhcyBwYXJhbS5cbiAgICogSXMgZGVwZW5kZW50IG9uIHRoZSBvcmRlciBpbiBAQ29udGVudENoaWxkcmVuIGluIERhdGFncmlkLlxuICAgKlxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUNvbHVtbkxpc3QoY29sdW1uczogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsW10pIHtcbiAgICB0aGlzLl9jb2x1bW5MaXN0ID0gY29sdW1uczsgLy8gY2xlYXIgdGhlIGxpc3RcbiAgICB0aGlzLnVwZGF0ZUZvckxhc3RWaXNpYmxlQ29sdW1uKCk7IC8vIFVwZGF0ZSBvdXIgdmlzaWJpbGl0eSBzdGF0ZSBmb3IgVUlcbiAgICB0aGlzLl9jb2x1bW5MaXN0Q2hhbmdlLm5leHQodGhpcy5fY29sdW1uTGlzdCk7IC8vIEJyb2FkY2FzdCBpdFxuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmlzaWJsZSBjb3VudCBmb3IgYWxsIGNvbHVtbnMuXG4gICAqIFdoZW4gaXQgaXMgZ3JlYXRlciB0aGFuIDEgaXQgbWFya3MgZXZlcnl0aGluZyBhcyBmYWxzZSBmb3IgdGhlIGxhc3RWaXNpYmxlQ29sdW1uLlxuICAgKiBXaGVuIHZpc2libGUgY291bnQgaXMgbm90ID4gMSAoaS5lKSAxLiAsIGl0IGZpbmRzIHRoZSBvbmx5IGNvbHVtbiB0aGF0IGlzIG5vdCBoaWRkZW4gYW5kIG1hcmtzIGl0IGFzIHRoZVxuICAgKiBsYXN0VmlzaWJsZUNvbHVtbi5cbiAgICpcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVGb3JMYXN0VmlzaWJsZUNvbHVtbigpOiB2b2lkIHtcbiAgICAvLyBUaGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbHVtbiBzaG93aW5nLCBtYWtlIHN1cmUgbm90aGluZyBpcyBtYXJrZWQgbGFzdFZpc2libGVDb2x1bW5cbiAgICBpZiAodGhpcy5jYW5IaWRlTmV4dENvbHVtbikge1xuICAgICAgdGhpcy5fY29sdW1uTGlzdC5tYXAoY29sdW1uID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbiAmJiBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4pIHtcbiAgICAgICAgICBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSB2aXNpYmxlQ291bnQgaXMgZG93biB0byBvbmx5IG9uZSBjb2x1bW4gc2hvd2luZy4gRmluZCBpdCBhbmQgZmxhZyBpdCBhcyB0aGUgbGFzdFZpc2libGVDb2x1bW5cbiAgICAgIHRoaXMuX2NvbHVtbkxpc3QubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIGlmIChjb2x1bW4gJiYgIWNvbHVtbi5oaWRkZW4pIHtcbiAgICAgICAgICBjb2x1bW4ubGFzdFZpc2libGVDb2x1bW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKioqKioqKioqKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJuIGEgSGlkZWFibGVDb2x1bW4gaW4gdGhpcy5fY29sdW1uTGlzdCBmb3IgdGhlIGdpdmVuIGlkLlxuICAgKlxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldENvbHVtbkJ5SWQoaWQ6IHN0cmluZyk6IHVuZGVmaW5lZCB8IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB7XG4gICAgaWYgKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29sdW1uTGlzdC5maW5kKGNvbHVtbiA9PiBjb2x1bW4gJiYgY29sdW1uLmlkID09PSBpZCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbWJlZGRlZFZpZXdSZWYsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2RnLXdyYXBwZWQtY2VsbCcsXG4gIHRlbXBsYXRlOiBgICAgICAgICBcbiAgICAgICAgPG5nLXRlbXBsYXRlICNjZWxsUG9ydGFsPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGAsXG59KVxuZXhwb3J0IGNsYXNzIFdyYXBwZWRDZWxsIGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIEFmdGVyVmlld0luaXQge1xuICBfZHluYW1pYyA9IGZhbHNlO1xuICBAVmlld0NoaWxkKCdjZWxsUG9ydGFsJykgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPHZvaWQ+O1xuICBjZWxsVmlldzogRW1iZWRkZWRWaWV3UmVmPHZvaWQ+OyAvLyB0aGUgY2VsbHMgcHJvamVjdGVkIHZpZXdcblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5jZWxsVmlldyA9IHRoaXMudGVtcGxhdGVSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KG51bGwpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0b3IsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgQ2xyU2lnbnBvc3QgfSBmcm9tICcuLi8uLi9wb3BvdmVyL3NpZ25wb3N0L3NpZ25wb3N0JztcbmltcG9ydCB7IEhvc3RXcmFwcGVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvaG9zdC13cmFwcGluZy9ob3N0LXdyYXBwZXInO1xuXG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBXcmFwcGVkQ2VsbCB9IGZyb20gJy4vd3JhcHBlZC1jZWxsJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNlbGwnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0YWdyaWQtY2VsbF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1zaWducG9zdC10cmlnZ2VyXSc6ICdzaWducG9zdC5sZW5ndGggPiAwJyxcbiAgICByb2xlOiAnY2VsbCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ2VsbCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgLyoqKioqKioqKlxuICAgKiBAcHJvcGVydHkgc2lnbnBvc3RcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEBDb250ZW50Q2hpbGQgaXMgdXNlZCB0byBkZXRlY3QgdGhlIHByZXNlbmNlIG9mIGEgU2lnbnBvc3QgaW4gdGhlIHByb2plY3RlZCBjb250ZW50LlxuICAgKiBPbiB0aGUgaG9zdCwgd2Ugc2V0IHRoZSAuZGF0YWdyaWQtc2lnbnBvc3QtdHJpZ2dlciBjbGFzcyBvbiB0aGUgY2VsbCB3aGVuIHNpZ25wb3N0Lmxlbmd0aCBpcyBncmVhdGVyIHRoYW4gMC5cbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyU2lnbnBvc3QpIHNpZ25wb3N0OiBRdWVyeUxpc3Q8Q2xyU2lnbnBvc3Q+O1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaWRcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIGlkZW50aWZpZXIgZm9yIGFuIGluc3RhbmNlIG9mIHRoaXMgY2VsbCB0aGF0IG1hcHMgaXQgdG8gYSBzcGVjaWZpYyBjb2x1bW5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG5cbiAgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIHRoaXMubWFwSGlkZWFibGVDb2x1bW4odGhpcy5faWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoaWRkZW5TdGF0ZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwcml2YXRlIF9lbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmXG4gICkge31cblxuICBwcml2YXRlIG1hcEhpZGVhYmxlQ29sdW1uKGNvbHVtbklkOiBzdHJpbmcpIHtcbiAgICBpZiAoIWNvbHVtbklkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGlkZWFibGVDb2x1bW4gPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5CeUlkKHRoaXMuX2lkKTtcblxuICAgIHRoaXMuc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW4uaGlkZGVuKTtcbiAgICB0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uID0gaGlkZWFibGVDb2x1bW4uaGlkZGVuQ2hhbmdlU3RhdGUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW4uaGlkZGVuKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0SGlkZGVuQ2xhc3MoaGlkZWFibGVDb2x1bW5WYWx1ZTogYm9vbGVhbikge1xuICAgIGlmIChoaWRlYWJsZUNvbHVtblZhbHVlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyh0aGlzLl9lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtY2VsbC0taGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1jZWxsLS1oaWRkZW4nKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHdyYXBwZWRJbmplY3RvcjogSW5qZWN0b3I7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy53cmFwcGVkSW5qZWN0b3IgPSBuZXcgSG9zdFdyYXBwZXIoV3JhcHBlZENlbGwsIHRoaXMudmNyKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmhpZGRlblN0YXRlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBfdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVkSW5qZWN0b3IuZ2V0KFdyYXBwZWRDZWxsLCB0aGlzLnZjcikuY2VsbFZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGVudW0gRGF0YWdyaWREaXNwbGF5TW9kZSB7XG4gIERJU1BMQVksXG4gIENBTENVTEFURSxcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGVudW0gRGF0YWdyaWRSZW5kZXJTdGVwIHtcbiAgQUxJR05fQ09MVU1OUyxcbiAgQ0FMQ1VMQVRFX01PREVfT04sXG4gIENBTENVTEFURV9NT0RFX09GRixcbiAgQ0xFQVJfV0lEVEhTLCAvLyBOb3RlIHRoaXMgaXMgbGlzdGVuZWQgdG8gYnkgYm90aCBjZWxscyBhbmQgY29sdW1uc1xuICBDT01QVVRFX0NPTFVNTl9XSURUSFMsXG4gIERFVEVDVF9TVFJJQ1RfV0lEVEhTLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIge1xuICBwcm90ZWN0ZWQgX3JlbmRlclN0ZXA6IFN1YmplY3Q8RGF0YWdyaWRSZW5kZXJTdGVwPiA9IG5ldyBTdWJqZWN0PERhdGFncmlkUmVuZGVyU3RlcD4oKTtcbiAgcHVibGljIGdldCByZW5kZXJTdGVwKCk6IE9ic2VydmFibGU8RGF0YWdyaWRSZW5kZXJTdGVwPiB7XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlclN0ZXAuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgZmlsdGVyUmVuZGVyU3RlcHMoc3RlcDogRGF0YWdyaWRSZW5kZXJTdGVwKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyU3RlcC5waXBlKGZpbHRlcih0ZXN0U3RlcCA9PiBzdGVwID09PSB0ZXN0U3RlcCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhbHJlYWR5U2l6ZWQgPSBmYWxzZTtcblxuICBwdWJsaWMgcmVzaXplKCkge1xuICAgIHRoaXMuX3JlbmRlclN0ZXAubmV4dChEYXRhZ3JpZFJlbmRlclN0ZXAuQ0FMQ1VMQVRFX01PREVfT04pO1xuICAgIGlmICh0aGlzLmFscmVhZHlTaXplZCkge1xuICAgICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5DTEVBUl9XSURUSFMpO1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkRFVEVDVF9TVFJJQ1RfV0lEVEhTKTtcbiAgICB0aGlzLl9yZW5kZXJTdGVwLm5leHQoRGF0YWdyaWRSZW5kZXJTdGVwLkNPTVBVVEVfQ09MVU1OX1dJRFRIUyk7XG4gICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5BTElHTl9DT0xVTU5TKTtcbiAgICB0aGlzLmFscmVhZHlTaXplZCA9IHRydWU7XG4gICAgdGhpcy5fcmVuZGVyU3RlcC5uZXh0KERhdGFncmlkUmVuZGVyU3RlcC5DQUxDVUxBVEVfTU9ERV9PRkYpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWREaXNwbGF5TW9kZSB9IGZyb20gJy4uL2VudW1zL2Rpc3BsYXktbW9kZS5lbnVtJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuLi9yZW5kZXIvcmVuZGVyLW9yZ2FuaXplcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEaXNwbGF5TW9kZVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHByb3RlY3RlZCBfdmlldzogQmVoYXZpb3JTdWJqZWN0PERhdGFncmlkRGlzcGxheU1vZGU+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXRhZ3JpZERpc3BsYXlNb2RlPihcbiAgICBEYXRhZ3JpZERpc3BsYXlNb2RlLkRJU1BMQVlcbiAgKTtcblxuICBjb25zdHJ1Y3RvcihyZW5kZXJPcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICByZW5kZXJPcmdhbml6ZXJcbiAgICAgICAgLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5DQUxDVUxBVEVfTU9ERV9PTilcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLl92aWV3Lm5leHQoRGF0YWdyaWREaXNwbGF5TW9kZS5DQUxDVUxBVEUpKVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHJlbmRlck9yZ2FuaXplclxuICAgICAgICAuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkNBTENVTEFURV9NT0RFX09GRilcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLl92aWV3Lm5leHQoRGF0YWdyaWREaXNwbGF5TW9kZS5ESVNQTEFZKSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCB2aWV3KCk6IE9ic2VydmFibGU8RGF0YWdyaWREaXNwbGF5TW9kZT4ge1xuICAgIHJldHVybiB0aGlzLl92aWV3LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgZW51bSBTZWxlY3Rpb25UeXBlIHtcbiAgTm9uZSxcbiAgU2luZ2xlLFxuICBNdWx0aSxcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFRyYWNrQnlGdW5jdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciB9IGZyb20gJy4vZmlsdGVycyc7XG5pbXBvcnQgeyBJdGVtcyB9IGZyb20gJy4vaXRlbXMnO1xuaW1wb3J0IHsgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4uL2VudW1zL3NlbGVjdGlvbi10eXBlJztcblxubGV0IG5iU2VsZWN0aW9uOiBudW1iZXIgPSAwO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uPFQgPSBhbnk+IHtcbiAgcHVibGljIGlkOiBzdHJpbmc7XG4gIHByaXZhdGUgcHJldlNlbGVjdGlvblJlZnM6IFRbXSA9IFtdOyAvLyBSZWZzIG9mIHNlbGVjdGVkIGl0ZW1zXG4gIHByaXZhdGUgcHJldlNpbmdsZVNlbGVjdGlvblJlZjogVDsgLy8gUmVmIG9mIHNpbmdsZSBzZWxlY3RlZCBpdGVtXG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaXRlbXM6IEl0ZW1zPFQ+LCBwcml2YXRlIF9maWx0ZXJzOiBGaWx0ZXJzUHJvdmlkZXI8VD4pIHtcbiAgICB0aGlzLmlkID0gJ2Nsci1kZy1zZWxlY3Rpb24nICsgbmJTZWxlY3Rpb24rKztcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5fZmlsdGVycy5jaGFuZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5faXRlbXMuYWxsQ2hhbmdlcy5zdWJzY3JpYmUodXBkYXRlZEl0ZW1zID0+IHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNlbGVjdGlvblR5cGUpIHtcbiAgICAgICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTm9uZToge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTZWxlY3Rpb25UeXBlLlNpbmdsZToge1xuICAgICAgICAgICAgbGV0IG5ld1NpbmdsZTogYW55O1xuICAgICAgICAgICAgY29uc3QgdHJhY2tCeTogVHJhY2tCeUZ1bmN0aW9uPFQ+ID0gdGhpcy5faXRlbXMudHJhY2tCeTtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25VcGRhdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50U2luZ2xlIGhhcyBiZWVuIHNldCBiZWZvcmUgZGF0YSB3YXMgbG9hZGVkLCB3ZSBsb29rIHVwIGFuZCBzYXZlIHRoZSByZWYgZnJvbSBjdXJyZW50IGRhdGEgc2V0XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U2luZ2xlICYmICF0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmFsbCAmJiB0aGlzLl9pdGVtcy50cmFja0J5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gdGhpcy5jdXJyZW50U2luZ2xlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYgPSB0aGlzLl9pdGVtcy50cmFja0J5KGxvb2t1cCwgdGhpcy5jdXJyZW50U2luZ2xlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVkSXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVmID0gdHJhY2tCeShpbmRleCwgaXRlbSk7XG4gICAgICAgICAgICAgIC8vIElmIG9uZSBvZiB0aGUgdXBkYXRlZCBpdGVtcyBpcyB0aGUgcHJldmlvdXNseSBzZWxlY3RlZFNpbmdsZSwgc2V0IGl0IGFzIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgIGlmICh0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYgPT09IHJlZikge1xuICAgICAgICAgICAgICAgIG5ld1NpbmdsZSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyBzbWFydCBkYXRhZ3JpZHMsIHdlIGV4cGVjdCBhbGwgaXRlbXMgdG8gYmUgcHJlc2VudCBpbiB0aGUgdXBkYXRlZEl0ZW1zIGFycmF5LlxuICAgICAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSBzaG91bGQgZGVsZXRlIHRoZSBjdXJyZW50U2luZ2xlIGlmIGl0IHVzZWQgdG8gYmUgZGVmaW5lZCBidXQgZG9lc24ndCBleGlzdCBhbnltb3JlLlxuICAgICAgICAgICAgLy8gTm8gZXhwbGljaXQgXCJkZWxldGVcIiBpcyByZXF1aXJlZCwgc2luY2UgbmV3U2luZ2xlIHdvdWxkIGJlIHVuZGVmaW5lZCBhdCB0aGlzIHBvaW50LlxuICAgICAgICAgICAgLy8gTWFya2luZyBpdCBhcyBzZWxlY3Rpb25VcGRhdGVkIGhlcmUgd2lsbCBzZXQgY3VycmVudFNpbmdsZSB0byB1bmRlZmluZWQgYmVsb3cgaW4gdGhlIHNldFRpbWVvdXQuXG4gICAgICAgICAgICBpZiAodGhpcy5faXRlbXMuc21hcnQgJiYgIW5ld1NpbmdsZSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25VcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVE9ETzogRGlzY3Vzc2VkIHRoaXMgd2l0aCBFdWRlcyBhbmQgdGhpcyBpcyBmaW5lIGZvciBub3cuXG4gICAgICAgICAgICAvLyBCdXQgd2UgbmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHBhdHRlcm4gZm9yIHRoZVxuICAgICAgICAgICAgLy8gY2hpbGQgdHJpZ2dlcmluZyB0aGUgcGFyZW50IGNoYW5nZSBkZXRlY3Rpb24gcHJvYmxlbS5cbiAgICAgICAgICAgIC8vIFVzaW5nIHNldFRpbWVvdXQgZm9yIG5vdyB0byBmaXggdGhpcy5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNpbmdsZSA9IG5ld1NpbmdsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFNlbGVjdGlvblR5cGUuTXVsdGk6IHtcbiAgICAgICAgICAgIGxldCBsZWZ0T3ZlcjogYW55W10gPSB0aGlzLmN1cnJlbnQuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrQnk6IFRyYWNrQnlGdW5jdGlvbjxhbnk+ID0gdGhpcy5faXRlbXMudHJhY2tCeTtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb25VcGRhdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGhhcyBiZWVuIHNldCBiZWZvcmUgZGF0YSB3YXMgbG9hZGVkLCB3ZSBsb29rIHVwIGFuZCBzYXZlIHRoZSByZWYgZnJvbSBjdXJyZW50IGRhdGEgc2V0XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Lmxlbmd0aCA+IDAgJiYgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5sZW5ndGggIT09IHRoaXMuY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLmFsbCAmJiB0aGlzLl9pdGVtcy50cmFja0J5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gaXRlbSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLnB1c2godGhpcy5faXRlbXMudHJhY2tCeShsb29rdXAsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSB3b3JrIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUvY2xhcml0eS9pc3N1ZXMvMjM0MlxuICAgICAgICAgICAgLy8gY3VycmVudGx5LCB0aGUgc2VsZWN0aW9uIGlzIGNsZWFyZWQgd2hlbiBmaWx0ZXIgaXMgYXBwbGllZCwgc28gdGhlIGxvZ2ljIGluc2lkZVxuICAgICAgICAgICAgLy8gdGhlIGlmIHN0YXRlbWVudCBiZWxvdyByZXN1bHRzIGluIGJyb2tlbiBiZWhhdmlvci5cbiAgICAgICAgICAgIGlmIChsZWZ0T3Zlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZWRJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRyYWNrQnkoaW5kZXgsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIC8vIExvb2sgaW4gY3VycmVudCBzZWxlY3RlZCByZWZzIGFycmF5IGlmIGl0ZW0gaXMgc2VsZWN0ZWQsIGFuZCB1cGRhdGUgYWN0dWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IHRoaXMucHJldlNlbGVjdGlvblJlZnMuaW5kZXhPZihyZWYpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGxlZnRPdmVyW3NlbGVjdGVkSW5kZXhdID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBhbnkgdW5tYXRjaGVkIGl0ZW1zIGlmIHdlJ3JlIHVzaW5nIHNtYXJ0IGRhdGFncmlkcyB3aGVyZSB3ZSBleHBlY3QgYWxsIGl0ZW1zIHRvIGJlXG4gICAgICAgICAgICAgIC8vIHByZXNlbnRcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2l0ZW1zLnNtYXJ0KSB7XG4gICAgICAgICAgICAgICAgbGVmdE92ZXIgPSBsZWZ0T3Zlci5maWx0ZXIoc2VsZWN0ZWQgPT4gdXBkYXRlZEl0ZW1zLmluZGV4T2Yoc2VsZWN0ZWQpID4gLTEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQubGVuZ3RoICE9PSBsZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIFRPRE86IERpc2N1c3NlZCB0aGlzIHdpdGggRXVkZXMgYW5kIHRoaXMgaXMgZmluZSBmb3Igbm93LlxuICAgICAgICAgICAgICAvLyBCdXQgd2UgbmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHBhdHRlcm4gZm9yIHRoZVxuICAgICAgICAgICAgICAvLyBjaGlsZCB0cmlnZ2VyaW5nIHRoZSBwYXJlbnQgY2hhbmdlIGRldGVjdGlvbiBwcm9ibGVtLlxuICAgICAgICAgICAgICAvLyBVc2luZyBzZXRUaW1lb3V0IGZvciBub3cgdG8gZml4IHRoaXMuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25VcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBsZWZ0T3ZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgY2xlYXJTZWxlY3Rpb24oKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcyA9IFtdO1xuICAgIHRoaXMuX2N1cnJlbnRTaW5nbGUgPSBudWxsO1xuICAgIHRoaXMucHJldlNpbmdsZVNlbGVjdGlvblJlZiA9IG51bGw7XG4gICAgdGhpcy5lbWl0Q2hhbmdlKCk7XG4gIH1cblxuICBwcml2YXRlIF9zZWxlY3Rpb25UeXBlOiBTZWxlY3Rpb25UeXBlID0gU2VsZWN0aW9uVHlwZS5Ob25lO1xuICBwdWJsaWMgZ2V0IHNlbGVjdGlvblR5cGUoKTogU2VsZWN0aW9uVHlwZSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvblR5cGU7XG4gIH1cbiAgcHVibGljIHNldCBzZWxlY3Rpb25UeXBlKHZhbHVlOiBTZWxlY3Rpb25UeXBlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLnNlbGVjdGlvblR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2VsZWN0aW9uVHlwZSA9IHZhbHVlO1xuICAgIGlmICh2YWx1ZSA9PT0gU2VsZWN0aW9uVHlwZS5Ob25lKSB7XG4gICAgICBkZWxldGUgdGhpcy5jdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVwZGF0ZUN1cnJlbnQoW10sIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcm93U2VsZWN0aW9uTW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZ2V0IF9zZWxlY3RhYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk11bHRpIHx8IHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuU2luZ2xlO1xuICB9XG4gIC8qKlxuICAgKiBJZ25vcmUgaXRlbXMgY2hhbmdlcyBpbiB0aGUgc2FtZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgKi9cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gIHByaXZhdGUgZGVib3VuY2U6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9ucyB0byB0aGUgb3RoZXIgcHJvdmlkZXJzIGNoYW5nZXMuXG4gICAqL1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCBvdXIgc3Vic2NyaXB0aW9ucyB0byBvdGhlciBwcm92aWRlcnNcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHNpbmdsZSBzZWxlY3Rpb24gdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudFNpbmdsZTogVDtcbiAgcHVibGljIGdldCBjdXJyZW50U2luZ2xlKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U2luZ2xlO1xuICB9XG4gIHB1YmxpYyBzZXQgY3VycmVudFNpbmdsZSh2YWx1ZTogVCkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fY3VycmVudFNpbmdsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50U2luZ2xlID0gdmFsdWU7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLmFsbCAmJiB0aGlzLl9pdGVtcy50cmFja0J5ICYmIHZhbHVlKSB7XG4gICAgICBjb25zdCBsb29rdXAgPSB0aGlzLl9pdGVtcy5hbGwuZmluZEluZGV4KG1heWJlID0+IG1heWJlID09PSB2YWx1ZSk7XG4gICAgICB0aGlzLnByZXZTaW5nbGVTZWxlY3Rpb25SZWYgPSB0aGlzLl9pdGVtcy50cmFja0J5KGxvb2t1cCwgdmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAvLyBJZ25vcmUgaXRlbXMgY2hhbmdlcyBpbiB0aGUgc2FtZSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLlxuICAgIC8vIEBUT0RPIFRoaXMgY2FuIGxpa2VseSBiZSByZW1vdmVkIVxuICAgIHRoaXMuZGVib3VuY2UgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gKHRoaXMuZGVib3VuY2UgPSBmYWxzZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBfY3VycmVudDogVFtdO1xuICBwdWJsaWMgZ2V0IGN1cnJlbnQoKTogVFtdIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgfVxuICBwdWJsaWMgc2V0IGN1cnJlbnQodmFsdWU6IFRbXSkge1xuICAgIHRoaXMudXBkYXRlQ3VycmVudCh2YWx1ZSwgdHJ1ZSk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlQ3VycmVudCh2YWx1ZTogVFtdLCBlbWl0OiBib29sZWFuKSB7XG4gICAgdGhpcy5fY3VycmVudCA9IHZhbHVlO1xuICAgIGlmIChlbWl0KSB7XG4gICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAgIC8vIElnbm9yZSBpdGVtcyBjaGFuZ2VzIGluIHRoZSBzYW1lIGNoYW5nZSBkZXRlY3Rpb24gY3ljbGUuXG4gICAgICAvLyBAVE9ETyBUaGlzIGNhbiBsaWtlbHkgYmUgcmVtb3ZlZCFcbiAgICAgIHRoaXMuZGVib3VuY2UgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiAodGhpcy5kZWJvdW5jZSA9IGZhbHNlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBzZWxlY3Rpb24gY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8VFtdIHwgVD4oKTtcbiAgcHJpdmF0ZSBlbWl0Q2hhbmdlKCkge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZSkge1xuICAgICAgdGhpcy5fY2hhbmdlLm5leHQodGhpcy5jdXJyZW50U2luZ2xlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuTXVsdGkpIHtcbiAgICAgIHRoaXMuX2NoYW5nZS5uZXh0KHRoaXMuY3VycmVudCk7XG4gICAgfVxuICB9XG4gIC8vIFdlIGRvIG5vdCB3YW50IHRvIGV4cG9zZSB0aGUgU3ViamVjdCBpdHNlbGYsIGJ1dCB0aGUgT2JzZXJ2YWJsZSB3aGljaCBpcyByZWFkLW9ubHlcbiAgcHVibGljIGdldCBjaGFuZ2UoKTogT2JzZXJ2YWJsZTxUW10gfCBUPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcbiAgICovXG4gIHB1YmxpYyBpc1NlbGVjdGVkKGl0ZW06IFQpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSA9PT0gU2VsZWN0aW9uVHlwZS5TaW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTaW5nbGUgPT09IGl0ZW07XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk11bHRpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSkgPj0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgYW4gaXRlbVxuICAgKi9cbiAgcHJpdmF0ZSBzZWxlY3RJdGVtKGl0ZW06IFQpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnQucHVzaChpdGVtKTtcbiAgICBpZiAodGhpcy5faXRlbXMudHJhY2tCeSkge1xuICAgICAgLy8gUHVzaCBzZWxlY3RlZCByZWYgb250byBhcnJheVxuICAgICAgY29uc3QgbG9va3VwID0gdGhpcy5faXRlbXMuYWxsLmZpbmRJbmRleChtYXliZSA9PiBtYXliZSA9PT0gaXRlbSk7XG4gICAgICB0aGlzLnByZXZTZWxlY3Rpb25SZWZzLnB1c2godGhpcy5faXRlbXMudHJhY2tCeShsb29rdXAsIGl0ZW0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVzZWxlY3RzIGFuIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgZGVzZWxlY3RJdGVtKGluZGV4T2ZJdGVtOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnQuc3BsaWNlKGluZGV4T2ZJdGVtLCAxKTtcbiAgICBpZiAodGhpcy5faXRlbXMudHJhY2tCeSAmJiBpbmRleE9mSXRlbSA8IHRoaXMucHJldlNlbGVjdGlvblJlZnMubGVuZ3RoKSB7XG4gICAgICAvLyBLZWVwIHNlbGVjdGVkIHJlZnMgYXJyYXkgaW4gc3luY1xuICAgICAgdGhpcy5wcmV2U2VsZWN0aW9uUmVmcy5zcGxpY2UoaW5kZXhPZkl0ZW0sIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIG9yIGRlc2VsZWN0cyBhbiBpdGVtXG4gICAqL1xuICBwdWJsaWMgc2V0U2VsZWN0ZWQoaXRlbTogVCwgc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3NlbGVjdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5Ob25lOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5TaW5nbGU6XG4gICAgICAgIC8vIGluIHNpbmdsZSBzZWxlY3Rpb24sIHNldCBjdXJyZW50U2luZ2xlIG1ldGhvZCBzaG91bGQgYmUgdXNlZFxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU2VsZWN0aW9uVHlwZS5NdWx0aTpcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmN1cnJlbnQuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgIXNlbGVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5kZXNlbGVjdEl0ZW0oaW5kZXgpO1xuICAgICAgICAgIHRoaXMuZW1pdENoYW5nZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgMCAmJiBzZWxlY3RlZCkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0SXRlbShpdGVtKTtcbiAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYWxsIGN1cnJlbnRseSBkaXNwbGF5ZWQgaXRlbXMgYXJlIHNlbGVjdGVkXG4gICAqL1xuICBwdWJsaWMgaXNBbGxTZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uVHlwZSAhPT0gU2VsZWN0aW9uVHlwZS5NdWx0aSB8fCAhdGhpcy5faXRlbXMuZGlzcGxheWVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRpc3BsYXllZEl0ZW1zOiBUW10gPSB0aGlzLl9pdGVtcy5kaXNwbGF5ZWQ7XG4gICAgY29uc3QgbmJEaXNwbGF5ZWQgPSB0aGlzLl9pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoO1xuICAgIGlmIChuYkRpc3BsYXllZCA8IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGVtcDogVFtdID0gZGlzcGxheWVkSXRlbXMuZmlsdGVyKGl0ZW0gPT4gdGhpcy5jdXJyZW50LmluZGV4T2YoaXRlbSkgPiAtMSk7XG4gICAgcmV0dXJuIHRlbXAubGVuZ3RoID09PSBkaXNwbGF5ZWRJdGVtcy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyBvciBkZXNlbGVjdHMgYWxsIGN1cnJlbnRseSBkaXNwbGF5ZWQgaXRlbXNcbiAgICovXG4gIHB1YmxpYyB0b2dnbGVBbGwoKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuTm9uZSB8fCB0aGlzLl9zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLlNpbmdsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKlxuICAgICAgICAgKiBJZiBldmVyeSBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW0gaXMgYWxyZWFkeSBzZWxlY3RlZCwgd2UgY2xlYXIgdGhlbS5cbiAgICAgICAgICogSWYgYXQgbGVhc3Qgb25lIGl0ZW0gaXNuJ3Qgc2VsZWN0ZWQsIHdlIHNlbGVjdCBldmVyeSBjdXJyZW50bHkgZGlzcGxheWVkIGl0ZW0uXG4gICAgICAgICAqL1xuICAgIGlmICh0aGlzLmlzQWxsU2VsZWN0ZWQoKSkge1xuICAgICAgdGhpcy5faXRlbXMuZGlzcGxheWVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuY3VycmVudC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID4gLTEpIHtcbiAgICAgICAgICB0aGlzLmRlc2VsZWN0SXRlbShjdXJyZW50SW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXRlbXMuZGlzcGxheWVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuaW5kZXhPZihpdGVtKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmVtaXRDaGFuZ2UoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbWJlZGRlZFZpZXdSZWYsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRHluYW1pY1dyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2R5bmFtaWMtd3JhcHBlcic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2RnLXdyYXBwZWQtcm93JyxcbiAgdGVtcGxhdGU6IGAgICAgICAgIFxuICAgICAgICA8bmctdGVtcGxhdGUgI3Jvd1BvcnRhbD5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBXcmFwcGVkUm93IGltcGxlbWVudHMgRHluYW1pY1dyYXBwZXIsIEFmdGVyVmlld0luaXQge1xuICBfZHluYW1pYyA9IGZhbHNlO1xuXG4gIEBWaWV3Q2hpbGQoJ3Jvd1BvcnRhbCcpIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjx2b2lkPjtcbiAgcm93VmlldzogRW1iZWRkZWRWaWV3UmVmPHZvaWQ+OyAvLyB0aGUgcm93cyBwcm9qZWN0ZWQgdmlldyAoaW4gbWVtb3J5KVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAvLyBDcmVhdGUgdGhlIGNlbGxzIHZpZXcgaW4gbWVtb3J5LCBub3QgdGhlIERPTS5cbiAgICB0aGlzLnJvd1ZpZXcgPSB0aGlzLnRlbXBsYXRlUmVmLmNyZWF0ZUVtYmVkZGVkVmlldyhudWxsKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBBZnRlclZpZXdJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuaW1wb3J0IHsgSG9zdFdyYXBwZXIgfSBmcm9tICcuLi8uLi91dGlscy9ob3N0LXdyYXBwaW5nL2hvc3Qtd3JhcHBlcic7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENlbGwgfSBmcm9tICcuL2RhdGFncmlkLWNlbGwnO1xuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgRGF0YWdyaWREaXNwbGF5TW9kZSB9IGZyb20gJy4vZW51bXMvZGlzcGxheS1tb2RlLmVudW0nO1xuaW1wb3J0IHsgRGlzcGxheU1vZGVTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZGlzcGxheS1tb2RlLnNlcnZpY2UnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuaW1wb3J0IHsgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UnO1xuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICcuL3Byb3ZpZGVycy9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgV3JhcHBlZFJvdyB9IGZyb20gJy4vd3JhcHBlZC1yb3cnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlbGVjdGlvblR5cGUgfSBmcm9tICcuL2VudW1zL3NlbGVjdGlvbi10eXBlJztcblxubGV0IG5iUm93OiBudW1iZXIgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctcm93JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGFncmlkLXJvdy5odG1sJyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZGF0YWdyaWQtcm93XSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLXNlbGVjdGVkXSc6ICdzZWxlY3RlZCcsXG4gICAgJ1thdHRyLmFyaWEtb3duc10nOiAnaWQnLFxuICAgIHJvbGU6ICdyb3dncm91cCcsXG4gIH0sXG4gIHByb3ZpZGVyczogW0V4cGFuZCwgeyBwcm92aWRlOiBMb2FkaW5nTGlzdGVuZXIsIHVzZUV4aXN0aW5nOiBFeHBhbmQgfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkUm93PFQgPSBhbnk+IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG4gIHB1YmxpYyBpZDogc3RyaW5nO1xuICBwdWJsaWMgcmFkaW9JZDogc3RyaW5nO1xuICBwdWJsaWMgY2hlY2tib3hJZDogc3RyaW5nO1xuXG4gIC8qIHJlZmVyZW5jZSB0byB0aGUgZW51bSBzbyB0aGF0IHRlbXBsYXRlIGNhbiBhY2Nlc3MgKi9cbiAgcHVibGljIFNFTEVDVElPTl9UWVBFID0gU2VsZWN0aW9uVHlwZTtcblxuICAvKipcbiAgICogTW9kZWwgb2YgdGhlIHJvdywgdG8gdXNlIGZvciBzZWxlY3Rpb25cbiAgICovXG4gIEBJbnB1dCgnY2xyRGdJdGVtJykgaXRlbTogVDtcblxuICBwdWJsaWMgcmVwbGFjZWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uPFQ+LFxuICAgIHB1YmxpYyByb3dBY3Rpb25TZXJ2aWNlOiBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBnbG9iYWxFeHBhbmRhYmxlOiBFeHBhbmRhYmxlUm93c0NvdW50LFxuICAgIHB1YmxpYyBleHBhbmQ6IEV4cGFuZCxcbiAgICBwdWJsaWMgaGlkZWFibGVDb2x1bW5TZXJ2aWNlOiBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBkaXNwbGF5TW9kZTogRGlzcGxheU1vZGVTZXJ2aWNlLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIG5iUm93Kys7XG4gICAgdGhpcy5pZCA9ICdjbHItZGctcm93JyArIG5iUm93O1xuICAgIHRoaXMucmFkaW9JZCA9ICdjbHItZGctcm93LXJkJyArIG5iUm93O1xuICAgIHRoaXMuY2hlY2tib3hJZCA9ICdjbHItZGctcm93LWNiJyArIG5iUm93O1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICBjb21iaW5lTGF0ZXN0KHRoaXMuZXhwYW5kLnJlcGxhY2UsIHRoaXMuZXhwYW5kLmV4cGFuZENoYW5nZSkuc3Vic2NyaWJlKFxuICAgICAgICAoW2V4cGFuZFJlcGxhY2VWYWx1ZSwgZXhwYW5kQ2hhbmdlVmFsdWVdKSA9PiB7XG4gICAgICAgICAgaWYgKGV4cGFuZFJlcGxhY2VWYWx1ZSAmJiBleHBhbmRDaGFuZ2VWYWx1ZSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZWQgYW5kIGV4cGFuZGluZ1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2RhdGFncmlkLXJvdy1yZXBsYWNlZCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBIYW5kbGVzIHRoZXNlIGNhc2VzOiBub3QgcmVwbGFjZWQgYW5kIGNvbGxhcHNpbmcgJiByZXBsYWNlZCBhbmRcbiAgICAgICAgICAgIC8vIGNvbGxhcHNpbmcgYW5kIG5vdCByZXBsYWNlZCBhbmQgZXhwYW5kaW5nLlxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdkYXRhZ3JpZC1yb3ctcmVwbGFjZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBfc2VsZWN0ZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0aGUgcm93IGlzIHNlbGVjdGVkXG4gICAqL1xuICBwdWJsaWMgZ2V0IHNlbGVjdGVkKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk5vbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmlzU2VsZWN0ZWQodGhpcy5pdGVtKTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoJ2NsckRnU2VsZWN0ZWQnKVxuICBwdWJsaWMgc2V0IHNlbGVjdGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuTm9uZSkge1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0U2VsZWN0ZWQodGhpcy5pdGVtLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdTZWxlY3RlZENoYW5nZScpIHNlbGVjdGVkQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHB1YmxpYyB0b2dnbGUoc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZCkge1xuICAgIGlmIChzZWxlY3RlZCAhPT0gdGhpcy5zZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZWQuZW1pdChzZWxlY3RlZCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCBleHBhbmRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmQuZXhwYW5kZWQ7XG4gIH1cblxuICBASW5wdXQoJ2NsckRnRXhwYW5kZWQnKVxuICBwdWJsaWMgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5leHBhbmQuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnRXhwYW5kZWRDaGFuZ2UnKSBleHBhbmRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHB1YmxpYyB0b2dnbGVFeHBhbmQoKSB7XG4gICAgaWYgKHRoaXMuZXhwYW5kLmV4cGFuZGFibGUpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICB9XG4gIH1cblxuICAvKioqKipcbiAgICogcHJvcGVydHkgZGdDZWxsc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBRdWVyeSBMaXN0IG9mIHRoZSBDbHJEYXRhZ3JpZCBjZWxscyBpbiB0aGlzIHJvdy5cbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRDZWxsKSBkZ0NlbGxzOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRDZWxsPjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgLy8gTWFrZSBzdXJlIHRoaW5ncyBnZXQgc3RhcnRlZFxuICAgIGNvbnN0IGNvbHVtbnNMaXN0ID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpO1xuICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbnNMaXN0KTtcblxuICAgIC8vIFRyaWdnZXJlZCB3aGVuIHRoZSBDZWxscyBsaXN0IGNoYW5nZXMgcGVyIHJvdy1yZW5kZXJlclxuICAgIHRoaXMuZGdDZWxscy5jaGFuZ2VzLnN1YnNjcmliZShjZWxsTGlzdCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW5MaXN0ID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuZ2V0Q29sdW1ucygpO1xuICAgICAgaWYgKGNlbGxMaXN0Lmxlbmd0aCA9PT0gY29sdW1uTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uTGlzdCk7XG4gICAgICAgIHRoaXMuZGdDZWxscy5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGVDZWxscy5pbnNlcnQoY2VsbC5fdmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXNlZCB0byBzZXQgdGhpbmdzIHVwIHRoZSBmaXJzdCB0aW1lIGJ1dCBvbmx5IGFmdGVyIGFsbCB0aGUgY29sdW1ucyBhcmUgcmVhZHkuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jb2x1bW5MaXN0Q2hhbmdlLnN1YnNjcmliZShjb2x1bW5MaXN0ID0+IHtcbiAgICAgICAgLy8gUHJldmVudHMgY2VsbCB1cGRhdGVzIHdoZW4gY29scyBhbmQgY2VsbHMgYXJyYXkgYXJlIG5vdCBhbGlnbmVkIC0gb25seSBzZWVtcyB0byBydW4gb24gaW5pdCAvIGZpcnN0IHRpbWUuXG4gICAgICAgIGlmIChjb2x1bW5MaXN0Lmxlbmd0aCA9PT0gdGhpcy5kZ0NlbGxzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3QpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmRpc3BsYXlNb2RlLnZpZXcuc3Vic2NyaWJlKHZpZXdDaGFuZ2UgPT4ge1xuICAgICAgICAvLyBMaXN0ZW4gZm9yIHZpZXcgY2hhbmdlcyBhbmQgbW92ZSBjZWxscyBhcm91bmQgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IGRpc3BsYXlUeXBlXG4gICAgICAgIC8vIHJlbW92ZSBjZWxsIHZpZXdzIGZyb20gZGlzcGxheSB2aWV3XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9zY3JvbGxhYmxlQ2VsbHMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZUNlbGxzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBjZWxsIHZpZXdzIGZyb20gY2FsY3VsYXRlZCB2aWV3XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9jYWxjdWxhdGVkQ2VsbHMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlZENlbGxzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3Q2hhbmdlID09PSBEYXRhZ3JpZERpc3BsYXlNb2RlLkNBTENVTEFURSkge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUNlbGxzID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5kZ0NlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVkQ2VsbHMuaW5zZXJ0KGNlbGwuX3ZpZXcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzcGxheUNlbGxzID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRnQ2VsbHMuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGVDZWxscy5pbnNlcnQoY2VsbC5fdmlldyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAxLiBNYXBzIHRoZSBuZXcgY29sdW1uTGlzdENoYW5nZSB0byB0aGUgZGdDZWxscyBsaXN0IGJ5IGluZGV4XG4gICAqIDIuIFNldHMgdGhlIGhpZGRlbiBzdGF0ZSBvbiB0aGUgY2VsbFxuICAgKiBUYWtlIGEgQ29sdW1uIGxpc3QgYW5kIHVzZSBpbmRleCB0byBhY2Nlc3MgdGhlIGNvbHVtbnMgZm9yIGhpZGVhYmxlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3Q6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdKSB7XG4gICAgLy8gTWFwIGNlbGxzIHRvIGNvbHVtbnMgd2l0aCBBcnJheS5pbmRleFxuICAgIHRoaXMuZGdDZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudENvbHVtbiA9IGNvbHVtbkxpc3RbaW5kZXhdOyAvLyBBY2NvdW50cyBmb3IgbnVsbCBzcGFjZS5cbiAgICAgIGlmIChjdXJyZW50Q29sdW1uKSB7XG4gICAgICAgIGNlbGwuaWQgPSBjdXJyZW50Q29sdW1uLmlkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcHVibGljIGRpc3BsYXlDZWxscyA9IGZhbHNlO1xuXG4gIEBWaWV3Q2hpbGQoJ3N0aWNreUNlbGxzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9zdGlja3lDZWxsczogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgnc2Nyb2xsYWJsZUNlbGxzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9zY3JvbGxhYmxlQ2VsbHM6IFZpZXdDb250YWluZXJSZWY7XG4gIEBWaWV3Q2hpbGQoJ2NhbGN1bGF0ZWRDZWxscycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfY2FsY3VsYXRlZENlbGxzOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gIHByaXZhdGUgd3JhcHBlZEluamVjdG9yOiBJbmplY3RvcjtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLndyYXBwZWRJbmplY3RvciA9IG5ldyBIb3N0V3JhcHBlcihXcmFwcGVkUm93LCB0aGlzLnZjcik7XG4gIH1cblxuICBwdWJsaWMgZ2V0IF92aWV3KCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZWRJbmplY3Rvci5nZXQoV3JhcHBlZFJvdywgdGhpcy52Y3IpLnJvd1ZpZXc7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSB7XG4gIGJ1dHRvbnM6IFRlbXBsYXRlUmVmPGFueT4gPSBudWxsO1xuICBzZWxlY3RBbGxEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX3NlbGVjdEFsbEJ1dHRvbkNsaWNrZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwdWJsaWMgZ2V0IHNlbGVjdEFsbEJ1dHRvbkNsaWNrZWQoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdEFsbEJ1dHRvbkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgYnV0dG9uQ2xpY2tlZCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWxlY3RBbGxCdXR0b25DbGlja2VkLm5leHQoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvciB9IGZyb20gJy4uL2J1aWx0LWluL2NvbXBhcmF0b3JzL2RhdGFncmlkLXByb3BlcnR5LWNvbXBhcmF0b3InO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZSB9IGZyb20gJy4uL2ludGVyZmFjZXMvc3RhdGUuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgRmlsdGVyc1Byb3ZpZGVyIH0gZnJvbSAnLi9maWx0ZXJzJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuL3BhZ2UnO1xuaW1wb3J0IHsgU29ydCB9IGZyb20gJy4vc29ydCc7XG5pbXBvcnQgeyBTdGF0ZURlYm91bmNlciB9IGZyb20gJy4vc3RhdGUtZGVib3VuY2VyLnByb3ZpZGVyJztcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVyIGFnZ3JlZ2F0ZXMgc3RhdGUgY2hhbmdlcyBmcm9tIHRoZSB2YXJpb3VzIHByb3ZpZGVycyBvZiB0aGUgRGF0YWdyaWRcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0YXRlUHJvdmlkZXI8VD4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGZpbHRlcnM6IEZpbHRlcnNQcm92aWRlcjxUPixcbiAgICBwcml2YXRlIHNvcnQ6IFNvcnQ8VD4sXG4gICAgcHJpdmF0ZSBwYWdlOiBQYWdlLFxuICAgIHByaXZhdGUgZGVib3VuY2VyOiBTdGF0ZURlYm91bmNlclxuICApIHt9XG5cbiAgLyoqXG4gICAqIFRoZSBPYnNlcnZhYmxlIHRoYXQgbGV0cyBvdGhlciBjbGFzc2VzIHN1YnNjcmliZSB0byBnbG9iYWwgc3RhdGUgY2hhbmdlc1xuICAgKi9cbiAgY2hhbmdlOiBPYnNlcnZhYmxlPENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2U8VD4+ID0gdGhpcy5kZWJvdW5jZXIuY2hhbmdlLnBpcGUobWFwKCgpID0+IHRoaXMuc3RhdGUpKTtcblxuICAvKlxuICAgICAqIEJ5IG1ha2luZyB0aGlzIGEgZ2V0dGVyLCB3ZSBvcGVuIHRoZSBwb3NzaWJpbGl0eSBmb3IgYSBzZXR0ZXIgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBJdCdzIGJlZW4gcmVxdWVzdGVkIGEgY291cGxlIHRpbWVzLlxuICAgICAqL1xuICBnZXQgc3RhdGUoKTogQ2xyRGF0YWdyaWRTdGF0ZUludGVyZmFjZTxUPiB7XG4gICAgY29uc3Qgc3RhdGU6IENsckRhdGFncmlkU3RhdGVJbnRlcmZhY2U8VD4gPSB7fTtcbiAgICBpZiAodGhpcy5wYWdlLnNpemUgPiAwKSB7XG4gICAgICBzdGF0ZS5wYWdlID0geyBmcm9tOiB0aGlzLnBhZ2UuZmlyc3RJdGVtLCB0bzogdGhpcy5wYWdlLmxhc3RJdGVtLCBzaXplOiB0aGlzLnBhZ2Uuc2l6ZSB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5zb3J0LmNvbXBhcmF0b3IpIHtcbiAgICAgIGlmICh0aGlzLnNvcnQuY29tcGFyYXRvciBpbnN0YW5jZW9mIERhdGFncmlkUHJvcGVydHlDb21wYXJhdG9yKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlIGZvciB0aGUgZGVmYXVsdCBvYmplY3QgcHJvcGVydHkgY29tcGFyYXRvcixcbiAgICAgICAgICAgICAgICAgKiB3ZSBnaXZlIHRoZSBwcm9wZXJ0eSBuYW1lIGluc3RlYWQgb2YgdGhlIGFjdHVhbCBjb21wYXJhdG9yLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICBzdGF0ZS5zb3J0ID0geyBieTogKDxEYXRhZ3JpZFByb3BlcnR5Q29tcGFyYXRvcjxUPj50aGlzLnNvcnQuY29tcGFyYXRvcikucHJvcCwgcmV2ZXJzZTogdGhpcy5zb3J0LnJldmVyc2UgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnNvcnQgPSB7IGJ5OiB0aGlzLnNvcnQuY29tcGFyYXRvciwgcmV2ZXJzZTogdGhpcy5zb3J0LnJldmVyc2UgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVGaWx0ZXJzID0gdGhpcy5maWx0ZXJzLmdldEFjdGl2ZUZpbHRlcnMoKTtcbiAgICBpZiAoYWN0aXZlRmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGF0ZS5maWx0ZXJzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpbHRlciBvZiBhY3RpdmVGaWx0ZXJzKSB7XG4gICAgICAgIGlmIChmaWx0ZXIuc3RhdGUpIHtcbiAgICAgICAgICBzdGF0ZS5maWx0ZXJzLnB1c2goZmlsdGVyLnN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEludGVybmFsIGRhdGFncmlkIHNlcnZpY2UgdGhhdCBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGUgY2xyLWRnLXRhYmxlIGVsZW1lbnQgYW5kIGV4cG9zZXMgYSBtZXRob2QgdG8gZ2V0IGhlaWdodC5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRhYmxlU2l6ZVNlcnZpY2Uge1xuICBwcml2YXRlIF90YWJsZVJlZjogSFRNTEVsZW1lbnQ7XG5cbiAgcHVibGljIGdldCB0YWJsZVJlZigpOiBIVE1MRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX3RhYmxlUmVmO1xuICB9XG5cbiAgcHVibGljIHNldCB0YWJsZVJlZihlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuX3RhYmxlUmVmID0gZWxlbWVudDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0KSB7fVxuICBwdWJsaWMgc2V0IHRhYmxlKHRhYmxlOiBFbGVtZW50UmVmKSB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkgJiYgdGFibGUubmF0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy50YWJsZVJlZiA9IHRhYmxlLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRhdGFncmlkLXRhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlZCB3aGVuIHJlc2l6aW5nIGNvbHVtbnMgdG8gc2hvdyB0aGUgY29sdW1uIGJvcmRlciBiZWluZyBkcmFnZ2VkLlxuICBnZXRDb2x1bW5EcmFnSGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgaWYgKCF0aGlzLnRhYmxlUmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBgJHt0aGlzLnRhYmxlUmVmLmNsaWVudEhlaWdodH1weGA7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IERhdGFncmlkQ29sdW1uU3RhdGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbHVtbi1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4uL3JlbmRlci9yZW5kZXItb3JnYW5pemVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbHVtbnNTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgY29sdW1uczogQmVoYXZpb3JTdWJqZWN0PERhdGFncmlkQ29sdW1uU3RhdGU+W10gPSBbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMub3JnYW5pemVyLmZpbHRlclJlbmRlclN0ZXBzKERhdGFncmlkUmVuZGVyU3RlcC5DTEVBUl9XSURUSFMpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlc2V0KCkpXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0KCkge1xuICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKChjb2x1bW4sIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLmVtaXRTdGF0ZUNoYW5nZShpbmRleCwgeyB3aWR0aDogMCB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEhlbHBlciBtZXRob2QgdG8gZW1pdCBhIGNoYW5nZSB0byBhIGNvbHVtbiBvbmx5IHdoZW4gdGhlcmUgaXMgYW4gYWN0dWFsIGRpZmYgdG8gcHJvY2VzcyBmb3IgdGhhdCBjb2x1bW5cbiAgZW1pdFN0YXRlQ2hhbmdlKGNvbHVtbkluZGV4OiBudW1iZXIsIGRpZmY6IFBhcnRpYWw8RGF0YWdyaWRDb2x1bW5TdGF0ZT4pIHtcbiAgICBpZiAoIXRoaXMuY29sdW1uc1tjb2x1bW5JbmRleF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY29sdW1uc1tjb2x1bW5JbmRleF0udmFsdWU7XG4gICAgY29uc3QgaGFzQ2hhbmdlID0gT2JqZWN0LmtleXMoZGlmZikuZmlsdGVyKGtleSA9PiBkaWZmW2tleV0gIT09IGN1cnJlbnRba2V5XSk7XG5cbiAgICBpZiAoaGFzQ2hhbmdlKSB7XG4gICAgICB0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdLm5leHQoeyAuLi5jdXJyZW50LCAuLi5kaWZmIH0pO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRJdGVtcyB9IGZyb20gJy4vZGF0YWdyaWQtaXRlbXMnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQbGFjZWhvbGRlciB9IGZyb20gJy4vZGF0YWdyaWQtcGxhY2Vob2xkZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRSb3cgfSBmcm9tICcuL2RhdGFncmlkLXJvdyc7XG5pbXBvcnQgeyBEYXRhZ3JpZERpc3BsYXlNb2RlIH0gZnJvbSAnLi9lbnVtcy9kaXNwbGF5LW1vZGUuZW51bSc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFN0YXRlSW50ZXJmYWNlIH0gZnJvbSAnLi9pbnRlcmZhY2VzL3N0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbHVtbi10b2dnbGUtYnV0dG9ucy5zZXJ2aWNlJztcbmltcG9ydCB7IERpc3BsYXlNb2RlU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2Rpc3BsYXktbW9kZS5zZXJ2aWNlJztcbmltcG9ydCB7IEZpbHRlcnNQcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2ZpbHRlcnMnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuaW1wb3J0IHsgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSXRlbXMgfSBmcm9tICcuL3Byb3ZpZGVycy9pdGVtcyc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZSc7XG5pbXBvcnQgeyBSb3dBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcm93LWFjdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJy4vcHJvdmlkZXJzL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBTb3J0IH0gZnJvbSAnLi9wcm92aWRlcnMvc29ydCc7XG5pbXBvcnQgeyBTdGF0ZURlYm91bmNlciB9IGZyb20gJy4vcHJvdmlkZXJzL3N0YXRlLWRlYm91bmNlci5wcm92aWRlcic7XG5pbXBvcnQgeyBTdGF0ZVByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvc3RhdGUucHJvdmlkZXInO1xuaW1wb3J0IHsgVGFibGVTaXplU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RhYmxlLXNpemUuc2VydmljZSc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyL3JlbmRlci1vcmdhbml6ZXInO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlbGVjdGlvblR5cGUgfSBmcm9tICcuL2VudW1zL3NlbGVjdGlvbi10eXBlJztcbmltcG9ydCB7IENvbHVtbnNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvY29sdW1ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRhdGFncmlkJyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RhdGFncmlkLmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICBTZWxlY3Rpb24sXG4gICAgU29ydCxcbiAgICBGaWx0ZXJzUHJvdmlkZXIsXG4gICAgUGFnZSxcbiAgICBJdGVtcyxcbiAgICBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIEV4cGFuZGFibGVSb3dzQ291bnQsXG4gICAgSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIFN0YXRlRGVib3VuY2VyLFxuICAgIFN0YXRlUHJvdmlkZXIsXG4gICAgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UsXG4gICAgVGFibGVTaXplU2VydmljZSxcbiAgICBDb2x1bW5zU2VydmljZSxcbiAgICBEaXNwbGF5TW9kZVNlcnZpY2UsXG4gIF0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5kYXRhZ3JpZC1ob3N0XSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZDxUID0gYW55PiBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY29sdW1uU2VydmljZTogSGlkZWFibGVDb2x1bW5TZXJ2aWNlLFxuICAgIHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBwdWJsaWMgaXRlbXM6IEl0ZW1zPFQ+LFxuICAgIHB1YmxpYyBleHBhbmRhYmxlUm93czogRXhwYW5kYWJsZVJvd3NDb3VudCxcbiAgICBwdWJsaWMgc2VsZWN0aW9uOiBTZWxlY3Rpb248VD4sXG4gICAgcHVibGljIHJvd0FjdGlvblNlcnZpY2U6IFJvd0FjdGlvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBzdGF0ZVByb3ZpZGVyOiBTdGF0ZVByb3ZpZGVyPFQ+LFxuICAgIHByaXZhdGUgZGlzcGxheU1vZGU6IERpc3BsYXlNb2RlU2VydmljZSxcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHt9XG5cbiAgLyogcmVmZXJlbmNlIHRvIHRoZSBlbnVtIHNvIHRoYXQgdGVtcGxhdGUgY2FuIGFjY2VzcyAqL1xuICBwdWJsaWMgU0VMRUNUSU9OX1RZUEUgPSBTZWxlY3Rpb25UeXBlO1xuXG4gIC8qKlxuICAgKiBGcmVlemVzIHRoZSBkYXRhZ3JpZCB3aGlsZSBkYXRhIGlzIGxvYWRpbmdcbiAgICovXG4gIHB1YmxpYyBnZXQgbG9hZGluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcy5sb2FkaW5nO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0xvYWRpbmcnKVxuICBwdWJsaWMgc2V0IGxvYWRpbmcodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLml0ZW1zLmxvYWRpbmcgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdXRwdXQgZW1pdHRlZCB3aGVuZXZlciB0aGUgZGF0YSBuZWVkcyB0byBiZSByZWZyZXNoZWQsIGJhc2VkIG9uIHVzZXIgYWN0aW9uIG9yIGV4dGVybmFsIG9uZXNcbiAgICovXG4gIEBPdXRwdXQoJ2NsckRnUmVmcmVzaCcpIHB1YmxpYyByZWZyZXNoID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJEYXRhZ3JpZFN0YXRlSW50ZXJmYWNlPFQ+PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBtZXRob2QgdG8gcmUtdHJpZ2dlciB0aGUgY29tcHV0YXRpb24gb2YgZGlzcGxheWVkIGl0ZW1zIG1hbnVhbGx5XG4gICAqL1xuICBwdWJsaWMgZGF0YUNoYW5nZWQoKSB7XG4gICAgdGhpcy5pdGVtcy5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogV2UgZ3JhYiB0aGUgc21hcnQgaXRlcmF0b3IgZnJvbSBwcm9qZWN0ZWQgY29udGVudFxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZEl0ZW1zKSBwdWJsaWMgaXRlcmF0b3I6IENsckRhdGFncmlkSXRlbXM8VD47XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGFsbCBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgQElucHV0KCdjbHJEZ1NlbGVjdGVkJylcbiAgc2V0IHNlbGVjdGVkKHZhbHVlOiBUW10pIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPSBTZWxlY3Rpb25UeXBlLk11bHRpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID0gU2VsZWN0aW9uVHlwZS5Ob25lO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGlvbi51cGRhdGVDdXJyZW50KHZhbHVlLCBmYWxzZSk7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ1NlbGVjdGVkQ2hhbmdlJykgc2VsZWN0ZWRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxUW10+KGZhbHNlKTtcblxuICAvKipcbiAgICogU2VsZWN0ZWQgaXRlbSBpbiBzaW5nbGUtc2VsZWN0IG1vZGVcbiAgICovXG4gIEBJbnB1dCgnY2xyRGdTaW5nbGVTZWxlY3RlZCcpXG4gIHNldCBzaW5nbGVTZWxlY3RlZCh2YWx1ZTogVCkge1xuICAgIHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPSBTZWxlY3Rpb25UeXBlLlNpbmdsZTtcbiAgICAvLyB0aGUgY2xyRGdTaW5nbGVTZWxlY3RlZCBpcyB1cGRhdGVkIGluIG9uZSBvZiB0d28gY2FzZXM6XG4gICAgLy8gMS4gYW4gZXhwbGljaXQgdmFsdWUgaXMgcGFzc2VkXG4gICAgLy8gMi4gaXMgYmVpbmcgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3aGVyZSBwcmV2aW91c2x5IGl0IGhhZCBhIHZhbHVlXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5jdXJyZW50U2luZ2xlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5jdXJyZW50U2luZ2xlKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbi5jdXJyZW50U2luZ2xlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ1NpbmdsZVNlbGVjdGVkQ2hhbmdlJykgc2luZ2xlU2VsZWN0ZWRDaGFuZ2VkID0gbmV3IEV2ZW50RW1pdHRlcjxUPihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIFNlbGVjdGlvbi9EZXNlbGVjdGlvbiBvbiByb3cgY2xpY2sgbW9kZVxuICAgKi9cbiAgQElucHV0KCdjbHJEZ1Jvd1NlbGVjdGlvbicpXG4gIHNldCByb3dTZWxlY3Rpb25Nb2RlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZWxlY3Rpb24ucm93U2VsZWN0aW9uTW9kZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiBhbGwgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtcyBhcmUgc2VsZWN0ZWRcbiAgICovXG4gIHB1YmxpYyBnZXQgYWxsU2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uLmlzQWxsU2VsZWN0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzL2Rlc2VsZWN0cyBhbGwgY3VycmVudGx5IGRpc3BsYXllZCBpdGVtc1xuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzZXQgYWxsU2VsZWN0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAvKlxuICAgICAgICAgKiBUaGlzIGlzIGEgc2V0dGVyIGJ1dCB3ZSBpZ25vcmUgdGhlIHZhbHVlLlxuICAgICAgICAgKiBJdCdzIHN0cmFuZ2UsIGJ1dCBpdCBsZXRzIHVzIGhhdmUgYW4gaW5kZXRlcm1pbmF0ZSBzdGF0ZSB3aGVyZSBvbmx5XG4gICAgICAgICAqIHNvbWUgb2YgdGhlIGl0ZW1zIGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgdGhpcy5zZWxlY3Rpb24udG9nZ2xlQWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3VzdG9tIHBsYWNlaG9sZGVyIGRldGVjdGlvblxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZFBsYWNlaG9sZGVyKSBwdWJsaWMgcGxhY2Vob2xkZXI6IENsckRhdGFncmlkUGxhY2Vob2xkZXI8VD47XG5cbiAgLyoqXG4gICAqIEhpZGVhYmxlIENvbHVtbiBkYXRhIHNvdXJjZSAvIGRldGVjdGlvbi5cbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyRGF0YWdyaWRDb2x1bW4pIHB1YmxpYyBjb2x1bW5zOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRDb2x1bW48VD4+O1xuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBkYXRhZ3JpZCBpcyB1c2VyLW1hbmFnZWQgd2l0aG91dCB0aGUgc21hcnQgaXRlcmF0b3IsIHdlIGdldCB0aGUgaXRlbXMgZGlzcGxheWVkXG4gICAqIGJ5IHF1ZXJ5aW5nIHRoZSBwcm9qZWN0ZWQgY29udGVudC4gVGhpcyBpcyBuZWVkZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgbW9kZWxzIGN1cnJlbnRseVxuICAgKiBkaXNwbGF5ZWQsIHR5cGljYWxseSBmb3Igc2VsZWN0aW9uLlxuICAgKi9cblxuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkUm93KSByb3dzOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRSb3c8VD4+O1xuICBAVmlld0NoaWxkKCdzY3JvbGxhYmxlQ29sdW1ucycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBzY3JvbGxhYmxlQ29sdW1uczogVmlld0NvbnRhaW5lclJlZjtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgaWYgKCF0aGlzLml0ZW1zLnNtYXJ0KSB7XG4gICAgICB0aGlzLml0ZW1zLmFsbCA9IHRoaXMucm93cy5tYXAoKHJvdzogQ2xyRGF0YWdyaWRSb3c8VD4pID0+IHJvdy5pdGVtKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLnJvd3MuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaXRlbXMuc21hcnQpIHtcbiAgICAgICAgICB0aGlzLml0ZW1zLmFsbCA9IHRoaXMucm93cy5tYXAoKHJvdzogQ2xyRGF0YWdyaWRSb3c8VD4pID0+IHJvdy5pdGVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgIHRoaXMuX2Rpc3BsYXllZFJvd3MuaW5zZXJ0KHJvdy5fdmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jb2x1bW5zLmNoYW5nZXMuc3Vic2NyaWJlKChjb2x1bW5zOiBDbHJEYXRhZ3JpZENvbHVtbjxUPltdKSA9PiB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VydmljZS51cGRhdGVDb2x1bW5MaXN0KHRoaXMuY29sdW1ucy5tYXAoY29sID0+IGNvbC5oaWRlYWJsZSkpO1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gR2V0IENvbHVtblNlcnZpY2UgcmVhZHkgZm9yIEhpZGVhYmxlQ29sdW1ucy5cbiAgICB0aGlzLmNvbHVtblNlcnZpY2UudXBkYXRlQ29sdW1uTGlzdCh0aGlzLmNvbHVtbnMubWFwKGNvbCA9PiBjb2wuaGlkZWFibGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdXIgc2V0dXAgaGFwcGVucyBpbiB0aGUgdmlldyBvZiBzb21lIG9mIG91ciBjb21wb25lbnRzLCBzbyB3ZSB3YWl0IGZvciBpdCB0byBiZSBkb25lIGJlZm9yZSBzdGFydGluZ1xuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIFRPRE86IGRldGVybWluZSBpZiB3ZSBjYW4gZ2V0IHJpZCBvZiBwcm92aWRlciB3aXJpbmcgaW4gdmlldyBpbml0IHNvIHRoYXQgc3Vic2NyaXB0aW9ucyBjYW4gYmUgZG9uZSBlYXJsaWVyXG4gICAgdGhpcy5yZWZyZXNoLmVtaXQodGhpcy5zdGF0ZVByb3ZpZGVyLnN0YXRlKTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2godGhpcy5zdGF0ZVByb3ZpZGVyLmNoYW5nZS5zdWJzY3JpYmUoc3RhdGUgPT4gdGhpcy5yZWZyZXNoLmVtaXQoc3RhdGUpKSk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5zZWxlY3Rpb24uY2hhbmdlLnN1YnNjcmliZShzID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNlbGVjdGlvblR5cGUuU2luZ2xlKSB7XG4gICAgICAgICAgdGhpcy5zaW5nbGVTZWxlY3RlZENoYW5nZWQuZW1pdCg8VD5zKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTZWxlY3Rpb25UeXBlLk11bHRpKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZWQuZW1pdCg8VFtdPnMpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gQSBzdWJzY3JpcHRpb24gdGhhdCBsaXN0ZW5zIGZvciBkaXNwbGF5TW9kZSBjaGFuZ2VzIG9uIHRoZSBkYXRhZ3JpZFxuICAgIHRoaXMuZGlzcGxheU1vZGUudmlldy5zdWJzY3JpYmUodmlld0NoYW5nZSA9PiB7XG4gICAgICAvLyBSZW1vdmUgYW55IHByb2plY3RlZCBjb2x1bW5zIGZyb20gdGhlIHByb2plY3RlZERpc3BsYXlDb2x1bW5zIGNvbnRhaW5lclxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3Byb2plY3RlZERpc3BsYXlDb2x1bW5zLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICB0aGlzLl9wcm9qZWN0ZWREaXNwbGF5Q29sdW1ucy5kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBhbnkgcHJvamVjdGVkIGNvbHVtbnMgZnJvbSB0aGUgcHJvamVjdGVkQ2FsY3VsYXRpb25Db2x1bW5zIGNvbnRhaW5lclxuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3Byb2plY3RlZENhbGN1bGF0aW9uQ29sdW1ucy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5fcHJvamVjdGVkQ2FsY3VsYXRpb25Db2x1bW5zLmRldGFjaCgpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGFueSBwcm9qZWN0ZWQgcm93cyBmcm9tIHRoZSBjYWxjdWxhdGlvblJvd3MgY29udGFpbmVyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fY2FsY3VsYXRpb25Sb3dzLmxlbmd0aDsgaSA+IDA7IGktLSkge1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGlvblJvd3MuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgYW55IHByb2plY3RlZCByb3dzIGZyb20gdGhlIGRpc3BsYXllZFJvd3MgY29udGFpbmVyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fZGlzcGxheWVkUm93cy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheWVkUm93cy5kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3Q2hhbmdlID09PSBEYXRhZ3JpZERpc3BsYXlNb2RlLkRJU1BMQVkpIHtcbiAgICAgICAgLy8gU2V0IHN0YXRlLCBzdHlsZSBmb3IgdGhlIGRhdGFncmlkIHRvIERJU1BMQVkgYW5kIGluc2VydCByb3cgJiBjb2x1bW5zIGludG8gY29udGFpbmVyc1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ2RhdGFncmlkLWNhbGN1bGF0ZS1tb2RlJyk7XG4gICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PiB7XG4gICAgICAgICAgdGhpcy5fcHJvamVjdGVkRGlzcGxheUNvbHVtbnMuaW5zZXJ0KGNvbHVtbi5fdmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgIHRoaXMuX2Rpc3BsYXllZFJvd3MuaW5zZXJ0KHJvdy5fdmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IHN0YXRlLCBzdHlsZSBmb3IgdGhlIGRhdGFncmlkIHRvIENBTENVTEFURSBhbmQgaW5zZXJ0IHJvdyAmIGNvbHVtbnMgaW50byBjb250YWluZXJzXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnZGF0YWdyaWQtY2FsY3VsYXRlLW1vZGUnKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgICAgICB0aGlzLl9wcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnMuaW5zZXJ0KGNvbHVtbi5fdmlldyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICAgIHRoaXMuX2NhbGN1bGF0aW9uUm93cy5pbnNlcnQocm93Ll92aWV3KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9ucyB0byBhbGwgdGhlIHNlcnZpY2VzIGFuZCBxdWVyaWVzIGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChzdWI6IFN1YnNjcmlwdGlvbikgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG5cbiAgcmVzaXplKCk6IHZvaWQge1xuICAgIHRoaXMub3JnYW5pemVyLnJlc2l6ZSgpO1xuICB9XG5cbiAgQFZpZXdDaGlsZCgncHJvamVjdGVkRGlzcGxheUNvbHVtbnMnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgX3Byb2plY3RlZERpc3BsYXlDb2x1bW5zOiBWaWV3Q29udGFpbmVyUmVmO1xuICBAVmlld0NoaWxkKCdwcm9qZWN0ZWRDYWxjdWxhdGlvbkNvbHVtbnMnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYgfSlcbiAgX3Byb2plY3RlZENhbGN1bGF0aW9uQ29sdW1uczogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgnZGlzcGxheWVkUm93cycsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiB9KVxuICBfZGlzcGxheWVkUm93czogVmlld0NvbnRhaW5lclJlZjtcbiAgQFZpZXdDaGlsZCgnY2FsY3VsYXRpb25Sb3dzJywgeyByZWFkOiBWaWV3Q29udGFpbmVyUmVmIH0pXG4gIF9jYWxjdWxhdGlvblJvd3M6IFZpZXdDb250YWluZXJSZWY7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWFjdGlvbi1iYXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLmRhdGFncmlkLWFjdGlvbi1iYXJdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQWN0aW9uQmFyIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBvaW50IH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlcic7XG5cbmltcG9ydCB7IFJvd0FjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yb3ctYWN0aW9uLXNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWFjdGlvbi1vdmVyZmxvdycsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b24gKGNsaWNrKT1cInRvZ2dsZSgkZXZlbnQpXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZGF0YWdyaWQtYWN0aW9uLXRvZ2dsZVwiICNhbmNob3I+XG4gICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJlbGxpcHNpcy12ZXJ0aWNhbFwiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3Mucm93QWN0aW9uc1wiPjwvY2xyLWljb24+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8bmctdGVtcGxhdGUgWyhjbHJQb3BvdmVyT2xkKV09XCJvcGVuXCIgW2NsclBvcG92ZXJPbGRBbmNob3JdPVwiYW5jaG9yXCIgW2NsclBvcG92ZXJPbGRBbmNob3JQb2ludF09XCJhbmNob3JQb2ludFwiXG4gICAgICAgICAgICAgICAgICAgICBbY2xyUG9wb3Zlck9sZFBvcG92ZXJQb2ludF09XCJwb3BvdmVyUG9pbnRcIj5cbiAgICAgICAgICAgIDxkaXYgI21lbnUgY2xhc3M9XCJkYXRhZ3JpZC1hY3Rpb24tb3ZlcmZsb3dcIiAoY2xyT3V0c2lkZUNsaWNrKT1cImNsb3NlKCRldmVudClcIiBbY2xyU3RyaWN0XT1cInRydWVcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZEFjdGlvbk92ZXJmbG93IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHVibGljIGFuY2hvclBvaW50OiBQb2ludCA9IFBvaW50LlJJR0hUX0NFTlRFUjtcbiAgcHVibGljIHBvcG92ZXJQb2ludDogUG9pbnQgPSBQb2ludC5MRUZUX0NFTlRFUjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJvd0FjdGlvblNlcnZpY2U6IFJvd0FjdGlvblNlcnZpY2UsIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzKSB7XG4gICAgdGhpcy5yb3dBY3Rpb25TZXJ2aWNlLnJlZ2lzdGVyKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJvd0FjdGlvblNlcnZpY2UudW5yZWdpc3RlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWNrcyB3aGV0aGVyIHRoZSBhY3Rpb24gb3ZlcmZsb3cgbWVudSBpcyBvcGVuIG9yIG5vdFxuICAgKi9cbiAgcHJpdmF0ZSBfb3BlbiA9IGZhbHNlO1xuICBwdWJsaWMgZ2V0IG9wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wZW47XG4gIH1cblxuICBASW5wdXQoJ2NsckRnQWN0aW9uT3ZlcmZsb3dPcGVuJylcbiAgcHVibGljIHNldCBvcGVuKG9wZW46IGJvb2xlYW4pIHtcbiAgICBjb25zdCBib29sT3BlbiA9ICEhb3BlbjtcbiAgICBpZiAoYm9vbE9wZW4gIT09IHRoaXMuX29wZW4pIHtcbiAgICAgIHRoaXMuX29wZW4gPSBib29sT3BlbjtcbiAgICAgIHRoaXMub3BlbkNoYW5nZWQuZW1pdChib29sT3Blbik7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdBY3Rpb25PdmVyZmxvd09wZW5DaGFuZ2UnKSBwdWJsaWMgb3BlbkNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICAvKlxuICAgICAqIFdlIG5lZWQgdG8gcmVtZW1iZXIgdGhlIGNsaWNrIHRoYXQgb3BlbnMgdGhlIG1lbnUsIHRvIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IGNsb3NlIHRoZSBtZW51IGluc3RhbnRseVxuICAgICAqIHdoZW4gdGhlIGV2ZW50IGJ1YmJsZXMgdXAgdGhlIERPTSBhbGwgdGhlIHdheSB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIHdlIGFsc28gbGlzdGVuIHRvLlxuICAgICAqL1xuICBwcml2YXRlIG9wZW5pbmdFdmVudDogYW55O1xuXG4gIC8qKlxuICAgKiBTaG93cy9oaWRlcyB0aGUgYWN0aW9uIG92ZXJmbG93IG1lbnVcbiAgICovXG4gIHB1YmxpYyB0b2dnbGUoZXZlbnQ6IGFueSkge1xuICAgIHRoaXMub3BlbmluZ0V2ZW50ID0gZXZlbnQ7XG4gICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcbiAgfVxuXG4gIHB1YmxpYyBjbG9zZShldmVudDogTW91c2VFdmVudCkge1xuICAgIC8qXG4gICAgICAgICAqIEJlY2F1c2UgdGhpcyBsaXN0ZW5lciBpcyBhZGRlZCBzeW5jaG9ub3VzbHksIGJlZm9yZSB0aGUgZXZlbnQgZmluaXNoZXMgYnViYmxpbmcgdXAgdGhlIERPTSxcbiAgICAgICAgICogd2UgZW5kIHVwIGZpcmluZyBvbiB0aGUgdmVyeSBjbGljayB0aGF0IGp1c3Qgb3BlbmVkIHRoZSBtZW51LCBwXG4gICAgICAgICAqIG90ZW50aWFsbHkgY2xvc2luZyBpdCBpbW1lZGlhdGVseSBldmVyeSB0aW1lLiBTbyB3ZSBqdXN0IGlnbm9yZSBpdC5cbiAgICAgICAgICovXG4gICAgaWYgKGV2ZW50ID09PSB0aGlzLm9wZW5pbmdFdmVudCkge1xuICAgICAgZGVsZXRlIHRoaXMub3BlbmluZ0V2ZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZW4gPSBmYWxzZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEb21BZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZG9tLWFkYXB0ZXIvZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgQ2xyRHJhZ0V2ZW50IH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnLWV2ZW50JztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi4vcmVuZGVyL3JlbmRlci1vcmdhbml6ZXInO1xuXG5jb25zdCBNSU5fQ09MVU1OX1dJRFRIID0gOTY7XG5cbi8vIFRoaXMgc2VydmljZSBhbGxvd3MgRGF0YWdyaWRIZWFkZXJSZW5kZXJlciBhbmQgQ2xyRGF0YWdyaWRDb2x1bW5TZXBhcmF0b3Jcbi8vIHRvIHNoYXJlIGNvbHVtbiByZXNpemUgZGF0YSB3aXRoIGVhY2ggb3RoZXIuXG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb2x1bW5SZXNpemVyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlciwgcHJpdmF0ZSBvcmdhbml6ZXI6IERhdGFncmlkUmVuZGVyT3JnYW5pemVyKSB7fVxuXG4gIHByaXZhdGUgd2lkdGhCZWZvcmVSZXNpemU6IG51bWJlcjtcblxuICBwcml2YXRlIF9yZXNpemVkQnk6IG51bWJlciA9IDA7XG5cbiAgcHVibGljIGdldCByZXNpemVkQnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZWRCeTtcbiAgfVxuXG4gIC8vIGlzIGl0IHdpdGhpbiB0aGUgbWF4aW11bSByZXNpemUgcmFuZ2UgdG8gdGhlIGxlZnRcbiAgcHVibGljIGlzV2l0aGluTWF4UmVzaXplUmFuZ2U6IGJvb2xlYW47XG5cbiAgcHVibGljIGdldCBtaW5Db2x1bW5XaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb21BZGFwdGVyLm1pbldpZHRoKHRoaXMuZWwubmF0aXZlRWxlbWVudCkgfHwgTUlOX0NPTFVNTl9XSURUSDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgbWF4UmVzaXplUmFuZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkdGhCZWZvcmVSZXNpemUgLSB0aGlzLm1pbkNvbHVtbldpZHRoO1xuICB9XG5cbiAgcHVibGljIHN0YXJ0UmVzaXplKCk6IHZvaWQge1xuICAgIHRoaXMuX3Jlc2l6ZWRCeSA9IDA7XG4gICAgdGhpcy5pc1dpdGhpbk1heFJlc2l6ZVJhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoQmVmb3JlUmVzaXplID0gdGhpcy5kb21BZGFwdGVyLmNsaWVudFJlY3QodGhpcy5lbC5uYXRpdmVFbGVtZW50KS53aWR0aDtcbiAgfVxuXG4gIHB1YmxpYyBlbmRSZXNpemUoKTogdm9pZCB7XG4gICAgdGhpcy5vcmdhbml6ZXIucmVzaXplKCk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHdpZHRoQWZ0ZXJSZXNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy53aWR0aEJlZm9yZVJlc2l6ZSArIHRoaXMuX3Jlc2l6ZWRCeTtcbiAgfVxuXG4gIHB1YmxpYyBjYWxjdWxhdGVSZXNpemUoZXZlbnQ6IENsckRyYWdFdmVudDxhbnk+KTogdm9pZCB7XG4gICAgY29uc3QgbW92ZVggPSBldmVudC5kcmFnUG9zaXRpb24ubW92ZVg7XG4gICAgLy8gcmV0dXJucyB0aGUgcmVzaXplIGFtb3VudCB3aXRoaW4gdGhlIGFsbG93ZWQgcmFuZ2VcbiAgICBpZiAobW92ZVggPCAtdGhpcy5tYXhSZXNpemVSYW5nZSkge1xuICAgICAgdGhpcy5fcmVzaXplZEJ5ID0gLXRoaXMubWF4UmVzaXplUmFuZ2U7XG4gICAgICB0aGlzLmlzV2l0aGluTWF4UmVzaXplUmFuZ2UgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzaXplZEJ5ID0gbW92ZVg7XG4gICAgICB0aGlzLmlzV2l0aGluTWF4UmVzaXplUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5sZXQgTkJfSU5TVEFOQ0VTID0gMDtcblxuZXhwb3J0IGNvbnN0IFVOSVFVRV9JRCA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+KCdVTklRVUVfSUQnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUlkRmFjdG9yeSgpIHtcbiAgcmV0dXJuICdjbHItaWQtJyArIE5CX0lOU1RBTkNFUysrO1xufVxuXG5leHBvcnQgY29uc3QgVU5JUVVFX0lEX1BST1ZJREVSID0ge1xuICBwcm92aWRlOiBVTklRVUVfSUQsXG4gIHVzZUZhY3Rvcnk6IHVuaXF1ZUlkRmFjdG9yeSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBDb21wb25lbnQsIEluamVjdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRyYWdFdmVudCB9IGZyb20gJy4uLy4uL3V0aWxzL2RyYWctYW5kLWRyb3AvZHJhZy1ldmVudCc7XG5pbXBvcnQgeyBDb2x1bW5SZXNpemVyU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbHVtbi1yZXNpemVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFibGVTaXplU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RhYmxlLXNpemUuc2VydmljZSc7XG5pbXBvcnQgeyBVTklRVUVfSURfUFJPVklERVIsIFVOSVFVRV9JRCB9IGZyb20gJy4uLy4uL3V0aWxzL2lkLWdlbmVyYXRvci9pZC1nZW5lcmF0b3Iuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1jb2x1bW4tc2VwYXJhdG9yJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtY29sdW1uLWhhbmRsZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICBjbHJEcmFnZ2FibGUgXG4gICAgICBbY2xyR3JvdXBdPVwiY29sdW1uU2VwYXJhdG9ySWRcIiBcbiAgICAgIChjbHJEcmFnU3RhcnQpPVwic2hvd1RyYWNrZXIocmVzaXplVHJhY2tlckVsKVwiIFxuICAgICAgKGNsckRyYWdNb3ZlKT1cIm1vdmVUcmFja2VyKCRldmVudCwgcmVzaXplVHJhY2tlckVsKVwiIFxuICAgICAgKGNsckRyYWdFbmQpPVwiaGlkZVRyYWNrZXIocmVzaXplVHJhY2tlckVsKVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1jb2x1bW4tcmVzaXplLXRyYWNrZXJcIiAjcmVzaXplVHJhY2tlckVsPjwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLWNvbHVtbi1zZXBhcmF0b3JdJzogJ3RydWUnLFxuICB9LFxuICBwcm92aWRlcnM6IFtVTklRVUVfSURfUFJPVklERVJdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZENvbHVtblNlcGFyYXRvciB7XG4gIC8vIEV2ZXJ5IGNvbHVtbiBkcmFnZ2FibGUgc2VwYXJhdG9yIHNob3VsZCBoYXZlIGl0cyBvd24gdW5pcXVlIElEXG4gIC8vIGluIG9yZGVyIHRvIG5vdCBjb25mbGljdCB3aXRoIG90aGVyIGRyYWdnYWJsZXMvZHJvcHBhYmxlcy5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb2x1bW5SZXNpemVyU2VydmljZTogQ29sdW1uUmVzaXplclNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgdGFibGVTaXplU2VydmljZTogVGFibGVTaXplU2VydmljZSxcbiAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnksXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBjb2x1bW5TZXBhcmF0b3JJZDogc3RyaW5nXG4gICkge31cblxuICBwdWJsaWMgc2hvd1RyYWNrZXIocmVzaXplVHJhY2tlckVsOiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuY29sdW1uUmVzaXplclNlcnZpY2Uuc3RhcnRSZXNpemUoKTtcbiAgICBjb25zdCB0YWJsZUhlaWdodCA9IHRoaXMudGFibGVTaXplU2VydmljZS5nZXRDb2x1bW5EcmFnSGVpZ2h0KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShyZXNpemVUcmFja2VyRWwsICdoZWlnaHQnLCB0YWJsZUhlaWdodCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShyZXNpemVUcmFja2VyRWwsICdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gIH1cblxuICBwdWJsaWMgbW92ZVRyYWNrZXIoZXZlbnQ6IENsckRyYWdFdmVudDxhbnk+LCByZXNpemVUcmFja2VyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5jb2x1bW5SZXNpemVyU2VydmljZS5jYWxjdWxhdGVSZXNpemUoZXZlbnQpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocmVzaXplVHJhY2tlckVsLCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVgoJHt0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLnJlc2l6ZWRCeX1weClgKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZG9jdW1lbnQuYm9keSwgJ2N1cnNvcicsICdjb2wtcmVzaXplJyk7XG4gICAgdGhpcy5yZWRGbGFnVHJhY2tlcihyZXNpemVUcmFja2VyRWwpO1xuICB9XG5cbiAgcHVibGljIGhpZGVUcmFja2VyKHJlc2l6ZVRyYWNrZXJFbDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLmVuZFJlc2l6ZSgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUocmVzaXplVHJhY2tlckVsLCAnZGlzcGxheScsICdub25lJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShyZXNpemVUcmFja2VyRWwsICd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWCgwcHgpYCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmRvY3VtZW50LmJvZHksICdjdXJzb3InLCAnYXV0bycpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWRGbGFnVHJhY2tlcihyZXNpemVUcmFja2VyRWw6IEhUTUxFbGVtZW50KSB7XG4gICAgbGV0IGlzV2l0aGluTWF4UmVzaXplUmFuZ2U6IGJvb2xlYW47XG4gICAgLy8gQFRPRE8oSkVSRU1ZKSBSZXZpZXcgdGhpcywgaXQgd2lsbCBhbHdheXMgYmUgdHJ1ZSBiZWNhdXNlIGFib3ZlIGlzIGFsd2F5cyBudWxsXG4gICAgaWYgKGlzV2l0aGluTWF4UmVzaXplUmFuZ2UgIT09IHRoaXMuY29sdW1uUmVzaXplclNlcnZpY2UuaXNXaXRoaW5NYXhSZXNpemVSYW5nZSkge1xuICAgICAgaXNXaXRoaW5NYXhSZXNpemVSYW5nZSA9IHRoaXMuY29sdW1uUmVzaXplclNlcnZpY2UuaXNXaXRoaW5NYXhSZXNpemVSYW5nZTtcbiAgICAgIGlmICghaXNXaXRoaW5NYXhSZXNpemVSYW5nZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHJlc2l6ZVRyYWNrZXJFbCwgJ2V4Y2VlZGVkLW1heCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhyZXNpemVUcmFja2VyRWwsICdleGNlZWRlZC1tYXgnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb2x1bW5Ub2dnbGVCdXR0b25zU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbHVtbi10b2dnbGUtYnV0dG9ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbi10b2dnbGUtYnV0dG9uJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmtcIlxuICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUJ1dHRvbnMuYnV0dG9uQ2xpY2tlZCgpXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJ0b2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkXCJcbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdG9nZ2xlQnV0dG9uczogQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UpIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLWNvbHVtbi10b2dnbGUtdGl0bGUnLFxuICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBPbkRlc3Ryb3ksIE9uSW5pdCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi8uLi9wb3BvdmVyL2NvbW1vbi9wb3BvdmVyJztcblxuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtYnV0dG9uJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGUgfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtdGl0bGUnO1xuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgQ29sdW1uVG9nZ2xlQnV0dG9uc1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb2x1bW4tdG9nZ2xlLWJ1dHRvbnMuc2VydmljZSc7XG5pbXBvcnQgeyBIaWRlYWJsZUNvbHVtblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9oaWRlYWJsZS1jb2x1bW4uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJDb21tb25TdHJpbmdzIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uLXRvZ2dsZScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAjYW5jaG9yXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVVJKClcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYnRuIGJ0bi1zbSBidG4tbGluayBjb2x1bW4tdG9nZ2xlLS1hY3Rpb25cIlxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIj5cbiAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInZpZXctY29sdW1uc1wiIFthdHRyLnRpdGxlXT1cImNvbW1vblN0cmluZ3MucGlja0NvbHVtbnNcIj48L2Nsci1pY29uPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbi1zd2l0Y2hcIlxuICAgICAgICAgICAgICpjbHJQb3BvdmVyT2xkPVwib3BlbjsgYW5jaG9yOiBhbmNob3I7IGFuY2hvclBvaW50OiBhbmNob3JQb2ludDsgcG9wb3ZlclBvaW50OiBwb3BvdmVyUG9pbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2gtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiF0aXRsZVwiPlNob3cgQ29sdW1uczwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1jb2x1bW4tdG9nZ2xlLXRpdGxlXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVVJKClcIlxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNsb3NlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5jbG9zZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cInN3aXRjaC1jb250ZW50IGxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBjb2x1bW5zXCI+XG4gICAgICAgICAgICAgICAgICAgIDxjbHItY2hlY2tib3gtd3JhcHBlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbHJDaGVja2JveCB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiY29sdW1uLmxhc3RWaXNpYmxlQ29sdW1uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW25nTW9kZWxdPVwiIWNvbHVtbi5oaWRkZW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJ0b2dnbGVDb2x1bW4oJGV2ZW50LCBjb2x1bW4pXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWw+PG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbHVtbi50ZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPC9jbHItY2hlY2tib3gtd3JhcHBlcj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2gtZm9vdGVyXCIgKm5nSWY9XCJidXR0b25zLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItZGctY29sdW1uLXRvZ2dsZS1idXR0b25cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzd2l0Y2gtZm9vdGVyXCIgKm5nSWY9XCJidXR0b25zLmxlbmd0aCA9PT0gMFwiPlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cImJ0biBidG4tc20gYnRuLWxpbmsgcDYgdGV4dC11cHBlcmNhc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJhbGxDb2x1bW5zVmlzaWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInNlbGVjdEFsbCgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCI+U2VsZWN0IEFsbFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuY29sdW1uLXN3aXRjaC13cmFwcGVyXSc6ICd0cnVlJywgJ1tjbGFzcy5hY3RpdmVdJzogJ29wZW4nIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkQ29sdW1uVG9nZ2xlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gIHByaXZhdGUgX2FsbENvbHVtbnNWaXNpYmxlOiBib29sZWFuO1xuXG4gIC8qKipcbiAgICogUG9wb3ZlciBpbml0XG4gICAqL1xuICBwdWJsaWMgYW5jaG9yUG9pbnQ6IFBvaW50ID0gUG9pbnQuVE9QX0xFRlQ7XG4gIHB1YmxpYyBwb3BvdmVyUG9pbnQ6IFBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gIHB1YmxpYyBvcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqKipcbiAgICogRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIGluaXRcbiAgICovXG4gIHB1YmxpYyBjb2x1bW5zOiBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWxbXSA9IFtdO1xuXG4gIHB1YmxpYyBnZXQgYWxsQ29sdW1uc1Zpc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlO1xuICB9XG5cbiAgcHVibGljIHNldCBhbGxDb2x1bW5zVmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2FsbENvbHVtbnNWaXNpYmxlID0gdmFsdWU7XG4gIH1cblxuICBAQ29udGVudENoaWxkKENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGUpIHRpdGxlOiBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZVRpdGxlO1xuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkQ29sdW1uVG9nZ2xlQnV0dG9uKSBidXR0b25zOiBRdWVyeUxpc3Q8Q2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwcml2YXRlIGNvbHVtblRvZ2dsZUJ1dHRvbnM6IENvbHVtblRvZ2dsZUJ1dHRvbnNTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge31cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNvbHVtbkxpc3QgPT4ge1xuICAgICAgICAvLyBSZXNldCB0aGUgbGlzdCBvZiBjb2x1bW5zXG4gICAgICAgIHRoaXMuY29sdW1ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS51cGRhdGVGb3JMYXN0VmlzaWJsZUNvbHVtbigpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNWaXNpYmxlID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZTtcbiAgICAgICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkID0gdGhpcy5hbGxDb2x1bW5zVmlzaWJsZTtcblxuICAgICAgICAvLyBBZGQgb25seSB0aGUgaGlkZGVuIGNvbHVtbnMgdG8gdGhlIHRvZ2dsZXIuXG4gICAgICAgIGNvbHVtbkxpc3QuZm9yRWFjaChjb2wgPT4ge1xuICAgICAgICAgIGlmIChjb2wpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbEJ1dHRvbkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZWxlY3RBbGwoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICBzZWxlY3RBbGwoKSB7XG4gICAgdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2Uuc2hvd0hpZGRlbkNvbHVtbnMoKTtcbiAgICB0aGlzLmFsbENvbHVtbnNWaXNpYmxlID0gdGhpcy5oaWRlYWJsZUNvbHVtblNlcnZpY2UuY2hlY2tGb3JBbGxDb2x1bW5zVmlzaWJsZTtcbiAgICB0aGlzLmNvbHVtblRvZ2dsZUJ1dHRvbnMuc2VsZWN0QWxsRGlzYWJsZWQgPSB0aGlzLmFsbENvbHVtbnNWaXNpYmxlO1xuICB9XG5cbiAgdG9nZ2xlQ29sdW1uKGV2ZW50OiBib29sZWFuLCBjb2x1bW46IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCkge1xuICAgIGNvbHVtbi5oaWRkZW4gPSAhZXZlbnQ7XG4gICAgdGhpcy5hbGxDb2x1bW5zVmlzaWJsZSA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNoZWNrRm9yQWxsQ29sdW1uc1Zpc2libGU7XG4gICAgdGhpcy5jb2x1bW5Ub2dnbGVCdXR0b25zLnNlbGVjdEFsbERpc2FibGVkID0gdGhpcy5hbGxDb2x1bW5zVmlzaWJsZTtcbiAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS51cGRhdGVGb3JMYXN0VmlzaWJsZUNvbHVtbigpO1xuICB9XG5cbiAgdG9nZ2xlVUkoKSB7XG4gICAgdGhpcy5vcGVuID0gIXRoaXMub3BlbjtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuXG4vKlxuICogSSBkb24ndCB0aGluayB0aGlzIGRlc2VydmVzIHRvIGJlIGluIElmRXhwYW5kZWQgaXRzZWxmLFxuICogc28gSSdtIGFkZGluZyBhIHNlY29uZCBkaXJlY3RpdmUgb24gdGhlIHNhbWUgc2VsZWN0b3IgZm9yIG5vdyBqdXN0IGZvciB0aGUgZGF0YWdyaWRcbiAqL1xuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NscklmRXhwYW5kZWRdJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkRGV0YWlsUmVnaXN0ZXJlciB7XG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByaXZhdGUgZXhwYW5kYWJsZVJvd3NDb3VudDogRXhwYW5kYWJsZVJvd3NDb3VudCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQpIHtcbiAgICAgIHRoaXMuZXhwYW5kYWJsZVJvd3NDb3VudC5yZWdpc3RlcigpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGVSb3dzQ291bnQpIHtcbiAgICAgIHRoaXMuZXhwYW5kYWJsZVJvd3NDb3VudC51bnJlZ2lzdGVyKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4tdG9nZ2xlJztcbmltcG9ydCB7IEhpZGVhYmxlQ29sdW1uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hpZGVhYmxlLWNvbHVtbi5zZXJ2aWNlJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJy4vcHJvdmlkZXJzL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBTZWxlY3Rpb25UeXBlIH0gZnJvbSAnLi9lbnVtcy9zZWxlY3Rpb24tdHlwZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1mb290ZXInLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdJZj1cIihzZWxlY3Rpb24uc2VsZWN0aW9uVHlwZSA9PT0gU0VMRUNUSU9OX1RZUEUuTXVsdGkpICYmIChzZWxlY3Rpb24uY3VycmVudC5sZW5ndGggPiAwKVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjbHItZm9ybS1jb250cm9sLWRpc2FibGVkXCI+XG4gICAgICAgICAgICAgIDxjbHItY2hlY2tib3gtd3JhcHBlciBjbGFzcz1cImRhdGFncmlkLWZvb3Rlci1zZWxlY3RcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgY2xyQ2hlY2tib3ggdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD1cImNoZWNrZWRcIiBkaXNhYmxlZD5cbiAgICAgICAgICAgICAgICA8bGFiZWw+e3tzZWxlY3Rpb24uY3VycmVudC5sZW5ndGh9fTwvbGFiZWw+XG4gICAgICAgICAgICA8L2Nsci1jaGVja2JveC13cmFwcGVyPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLWNvbHVtbi10b2dnbGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDxjbHItZGctY29sdW1uLXRvZ2dsZSAqbmdJZj1cIiF0b2dnbGUgJiYgYWN0aXZlVG9nZ2xlclwiPjwvY2xyLWRnLWNvbHVtbi10b2dnbGU+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1mb290ZXItZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImNsci1kZy1wYWdpbmF0aW9uXCI+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRhdGFncmlkLWZvb3Rlcl0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRhdGFncmlkRm9vdGVyPFQgPSBhbnk+IGltcGxlbWVudHMgT25Jbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uPFQ+LFxuICAgIHB1YmxpYyBoaWRlYWJsZUNvbHVtblNlcnZpY2U6IEhpZGVhYmxlQ29sdW1uU2VydmljZSxcbiAgICBwdWJsaWMgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHt9XG5cbiAgcHVibGljIGFjdGl2ZVRvZ2dsZXI6IGJvb2xlYW47XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICAvKiByZWZlcmVuY2UgdG8gdGhlIGVudW0gc28gdGhhdCB0ZW1wbGF0ZSBjYW4gYWNjZXNzICovXG4gIHB1YmxpYyBTRUxFQ1RJT05fVFlQRSA9IFNlbGVjdGlvblR5cGU7XG5cbiAgQENvbnRlbnRDaGlsZChDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZSkgdG9nZ2xlOiBDbHJEYXRhZ3JpZENvbHVtblRvZ2dsZTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmNvbHVtbkxpc3RDaGFuZ2Uuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgIGNvbnN0IGhpZGRlbkNvbHVtbnNJblN1YiA9IGNoYW5nZS5maWx0ZXIoY29sID0+IGNvbCk7XG4gICAgICAgIGlmIChoaWRkZW5Db2x1bW5zSW5TdWIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZlVG9nZ2xlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnN0IGhpZGRlbkNvbHVtbnMgPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5zKCkuZmlsdGVyKGNvbCA9PiBjb2wpO1xuXG4gICAgaWYgKGhpZGRlbkNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hY3RpdmVUb2dnbGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4ge1xuICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQSB1dGlsaXR5IGNsYXNzIGZvciB0aGF0IGFkZHMgaGlkZS9zaG93IGZ1bmN0aW9uYWxpdHkgdG8gYSBjb2x1bW4sIGl0cyBjZWxscyBhbmQgZW5hYmxlcyBhIHRvZ2dsZXIgaW4gdGhlXG4gKiBEYXRhZ3JpZENvbHVtblRvZ2dsZSBDb21wb25lbnQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIHtcbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBoaWRkZW5DaGFuZ2VzXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHN0cmVhbSBvZiBzdGF0ZSBjaGFuZ2VzIGFuIGluc3RhbmNlIG9mIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB3aWxsIGJyb2FkY2FzdCB0byBzdWJzY3JpYmVycy5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgaGlkZGVuQ2hhbmdlc1N0YXRlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBpbml0IGZ1bmN0aW9uIGZvciBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgaW5zdGFuY2VzIHRoYXQgZG9lcyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAxLiBTZXQgdmFsdWVzIGZvciB0aGUgcHJpdmF0ZSB2YXJpYWJsZXMgdGhhdCBlbmFibGUgYSBoaWRlYWJsZSBjb2x1bW5cbiAgICogMi4gQnJvYWRjYXN0IHRoZSBuZXh0IGhpZGRlbiBjaGFuZ2UgZm9yIGFueW9uZSAoYWxyZWFkeSkgc3Vic2NyaWJlZCB0byB0aGlzIERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4sIHByaXZhdGUgX2lkOiBzdHJpbmcsIHByaXZhdGUgX2hpZGRlbjogYm9vbGVhbiA9IGZhbHNlKSB7fVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBnZXR0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIFRlbXBsYXRlUmVmIG9mIHRoZSBEYXRhZ3JpZENvbHVtbiB0aGF0IGlzIGhpZGVhYmxlLiBUaGlzIGlzIGN1cnJlbnRseSB1c2VkIHRvXG4gICAqIHBvcHVsYXRlIHRoZSBEYXRhZ3JpZENvbHVtblRvZ2dsZSBVSSB3aXRoIHRoZSBjb3JyZWN0IENvbHVtbiBuYW1lLlxuICAgKlxuICAgKi9cbiAgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogcHVibGljIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaWQgb2YgYSBIaWRlYWJsZUNPbHVtbiBpbnN0YW5jZS4gVXNlZCBieSB0aGUgSGlkZWFibGVDT2x1bW5TZXJ2aWNlIGZvciBwYXNzaW5nXG4gICAqIHN0YXRlIGFuZCBhY3Rpb25zIGJldHdlZW4gRGF0ZUdyaWRDb2x1bW5zLCBEYXRhR3JpZENlbGxzICYgdGhlIERhdGFncmlkQ29sdW1uVG9nZ2xlIENvbXBvbmVudHMuXG4gICAqXG4gICAqL1xuICBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5faWQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgaGlkZGVuIHZhbHVlIG9mIGEgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIGluc3RhbmNlLlxuICAgKlxuICAgKi9cbiAgZ2V0IGhpZGRlbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgc2V0dGVyIGZvciBzZXR0aW5nIHRoZSBoaWRkZW4gc3RhdGUgb2YgYSBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwgaW5zdGFuY2UuXG4gICAqIEl0IGFsc28gYnJvYWRjYXN0cyB0aGUgY2hhbmdlIGFmdGVyIGl0cyBzZXQuXG4gICAqXG4gICAqL1xuICBzZXQgaGlkZGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuX2hpZGRlbiA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faGlkZGVuID0gdmFsdWU7XG4gICAgdGhpcy5oaWRkZW5DaGFuZ2VzU3RhdGUubmV4dCh2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFuIE9ic2VydmFibGUgZm9yIHRoZSBIaWRlYWJsZUNvbHVtbnMgaGlkZGVuIGNoYW5nZXMuXG4gICAqXG4gICAqL1xuICBnZXQgaGlkZGVuQ2hhbmdlU3RhdGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuaGlkZGVuQ2hhbmdlc1N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLy8gRmxhZyB0aGlzIHRydWUgd2hlbiB0aGUgc2VydmljZSBvbmx5IGhhcyBvbmUgdmlzaWJsZSBjb2x1bW4gb3Blbi5cblxuICBwdWJsaWMgbGFzdFZpc2libGVDb2x1bW46IGJvb2xlYW4gPSBmYWxzZTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmLCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENvbHVtbiB9IGZyb20gJy4vZGF0YWdyaWQtY29sdW1uJztcbmltcG9ydCB7IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbCB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uLm1vZGVsJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsckRnSGlkZWFibGVDb2x1bW5dJyB9KVxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgc3RydWN0dXJhbCBkaXJlY3RpdmUgbWVhbnQgdG8gYmUgdXNlZCBpbnNpZGUgYSBjbHItZGctY29sdW1uIGNvbXBvbmVudC5cbiAqXG4gKiA8Y2xyLWRnLWNvbHVtbj5cbiAqICAgICAgIDxuZy1jb250YWluZXIgKmNsckRnSGlkZWFibGVDb2x1bW49XCJ7IGhpZGRlbjogdHJ1ZSB9XCI+XG4gKiAgICAgICAgICAgVXNlciBJRFxuICogICAgICAgPC9uZy1jb250YWluZXI+XG4gKiAgIDwvY2xyLWRnLWNvbHVtbj5cbiAqXG4gKiBJdCBzZXRzIHVwIHN0YXRlIGFuZCBwcm9wZXJ0aWVzIHNvIHRoYXQgY29sdW1ucyBjYW4gYmUgbWFuZ2VzIGZvciBoaWRlL3Nob3cgYnkgYSBzZXJ2aWNlIGFuZCBhbiBpbnRlcm5hbFxuICogZGF0YWdyaWQgdG9nZ2xlIGNvbXBvbmVudC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uIHtcbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVc2VkIHRvIGluaXRpYWxpemUgdGhlIGNvbHVtbiB3aXRoIGVpdGhlciBoaWRkZW4gb3IgdmlzaWJsZSBzdGF0ZS5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgX2hpZGRlbjogYm9vbGVhbjtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldHRlciBmbiBmb3IgdGhlIEBJbnB1dCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhpcyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZS5cbiAgICogSXQgYWxsb3dzIHRoZSB1c2VyIHRvIHByZS1jb25maWd1cmUgdGhlIGNvbHVtbidzIGhpZGUvc2hvdyBzdGF0ZS4geyBoaWRkZW46IHRydWUgfVxuICAgKiBJdCdzIG1vcmUgdmVyYm9zZSBidXQgaGFzIG1vcmUgQ2xhcml0eS5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogKmNsckRnSGlkZWFibGVDb2x1bW5cbiAgICogKmNsckRnSGlkZWFibGVDb2x1bW49e2hpZGRlbjogZmFsc2V9XG4gICAqICpjbHJEZ0hpZGVhYmxlQ29sdW1uPXtoaWRkZW46IHRydWV9XG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NsckRnSGlkZWFibGVDb2x1bW4nKVxuICBzZXQgY2xyRGdIaWRlYWJsZUNvbHVtbih2YWx1ZTogeyBoaWRkZW46IGJvb2xlYW4gfSkge1xuICAgIHRoaXMuY2xyRGdIaWRkZW4gPSB2YWx1ZSAmJiB2YWx1ZS5oaWRkZW4gPyB2YWx1ZS5oaWRkZW4gOiBmYWxzZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdIaWRkZW4nKVxuICBzZXQgY2xyRGdIaWRkZW4oaGlkZGVuOiBib29sZWFuKSB7XG4gICAgdGhpcy5faGlkZGVuID0gaGlkZGVuID8gaGlkZGVuIDogZmFsc2U7XG4gICAgaWYgKHRoaXMuZGdDb2x1bW4uaGlkZWFibGUpIHtcbiAgICAgIHRoaXMuZGdDb2x1bW4uaGlkZWFibGUuaGlkZGVuID0gdGhpcy5faGlkZGVuO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckRnSGlkZGVuQ2hhbmdlJykgcHVibGljIGhpZGRlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKipcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgcGFzc2VkIGludG8gdGhlIGRpcmVjdGl2ZSBmcm9tIHRoZSBwYXJlbnQgKEEgRGF0YWdyaWRDb2x1bW4pLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGNvbHVtbklkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiBVdGlsaXR5IGNsYXNzIHRoYXQgaXMgdXNlZCB0bzpcbiAgICogMS4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEhpZGVhYmxlQ29sdW1uIHRoYXQgd2lsbCBtYW5hZ2UgdGhlIFRlbXBsYXRlUmVmLCBzdGF0ZSBhbmQgY29tbXVuaWNhdGlvblxuICAgKiAyLiBNYW5hZ2UgdGhlIGhpZGRlbi9zaG93biBzdGF0ZSBmb3IgdGhlIGNvbHVtbiB0byB3aGljaCB0aGlzIGRpcmVjdGl2ZSBpcyBhcHBsaWVkXG4gICAqIDMuIHRyYWNrIHRoZSBpZCBvZiB0aGUgaGlkZGVuIGNvbHVtbiBzbyBpdCBjYW4gYmUgdXNlZCBpbiBjZWxscyBhcyB3ZWxsIGFzIG9uIHRoZSBjb2x1bW5cbiAgICovXG4gIHB1YmxpYyBjb2x1bW46IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbDtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFVzZWQgdGhlIERhdGFncmlkQ29sdW1uIHRvIGdldCBhbmQgc2V0IGFuIGlkIGZvciB0aGlzIEhpZGRlbkNvbHVtblxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBkZ0NvbHVtbjogQ2xyRGF0YWdyaWRDb2x1bW48YW55PlxuICApIHtcbiAgICB0aGlzLmNvbHVtbklkID0gZGdDb2x1bW4uY29sdW1uSWQ7XG5cbiAgICAvLyBVc2UgdGhlIHRlbXBsYXRlUmVmIHRvIGNyZWF0ZSB0aGlzIHZpZXdcbiAgICB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudGVtcGxhdGVSZWYpO1xuXG4gICAgLy8gQ3JlYXRlIGluc3RhbmNlIG9mIHRoZSB1dGlsaXR5IGNsYXNzIERhdGFncmlkSGlkZWFibGVDb2x1bW4uXG4gICAgLy8gTm90ZSB0aGlzIGlzIG9uIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgRGF0YWdyaWRDb2x1bW4uXG4gICAgdGhpcy5kZ0NvbHVtbi5oaWRlYWJsZSA9IG5ldyBEYXRhZ3JpZEhpZGVhYmxlQ29sdW1uTW9kZWwodGhpcy50ZW1wbGF0ZVJlZiwgdGhpcy5jb2x1bW5JZCwgdGhpcy5faGlkZGVuKTtcbiAgICB0aGlzLmRnQ29sdW1uLmhpZGVhYmxlLmhpZGRlbkNoYW5nZVN0YXRlLnN1YnNjcmliZShzdGF0ZSA9PiB0aGlzLmhpZGRlbkNoYW5nZS5lbWl0KHN0YXRlKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9wdGlvbmFsLCBUcmFja0J5RnVuY3Rpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgSXRlbXMgfSBmcm9tICcuL3Byb3ZpZGVycy9pdGVtcyc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tuZ0ZvclRyYWNrQnldJyxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRJdGVtc1RyYWNrQnk8VCA9IGFueT4ge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIF9pdGVtczogSXRlbXM8VD4pIHt9XG5cbiAgQElucHV0KCduZ0ZvclRyYWNrQnknKVxuICBzZXQgdHJhY2tCeSh2YWx1ZTogVHJhY2tCeUZ1bmN0aW9uPFQ+KSB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zKSB7XG4gICAgICB0aGlzLl9pdGVtcy50cmFja0J5ID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kZy1wYWdlLXNpemUnLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8ZGl2IGNsYXNzPVwiY2xyLXNlbGVjdC13cmFwcGVyXCI+XG4gICAgICA8c2VsZWN0IFtjbGFzcy5jbHItcGFnZS1zaXplLXNlbGVjdF09XCJ0cnVlXCIgWyhuZ01vZGVsKV09XCJwYWdlLnNpemVcIj5cbiAgICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIHBhZ2VTaXplT3B0aW9uc1wiIFtuZ1ZhbHVlXT1cIm9wdGlvblwiPnt7b3B0aW9ufX08L29wdGlvbj5cbiAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFBhZ2VTaXplIHtcbiAgQElucHV0KCdjbHJQYWdlU2l6ZU9wdGlvbnMnKSBwYWdlU2l6ZU9wdGlvbnM6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlOiBQYWdlKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICghdGhpcy5wYWdlU2l6ZU9wdGlvbnMgfHwgdGhpcy5wYWdlU2l6ZU9wdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VTaXplT3B0aW9ucyA9IFt0aGlzLnBhZ2Uuc2l6ZV07XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT25EZXN0cm95LFxuICBPbkluaXQsXG4gIE91dHB1dCxcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQYWdlU2l6ZSB9IGZyb20gJy4vZGF0YWdyaWQtcGFnZS1zaXplJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXBhZ2luYXRpb24nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uLXNpemVcIiAqbmdJZj1cIl9wYWdlU2l6ZUNvbXBvbmVudFwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY2xyLWRnLXBhZ2Utc2l6ZVwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicGFnaW5hdGlvbi1kZXNjcmlwdGlvblwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJwYWdpbmF0aW9uLWxpc3RcIiAqbmdJZj1cInBhZ2UubGFzdCA+IDFcIj5cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGFnaW5hdGlvbi1maXJzdFwiIFtkaXNhYmxlZF09XCJwYWdlLmN1cnJlbnQgPD0gMVwiIChjbGljayk9XCJwYWdlLmN1cnJlbnQgPSAxXCI+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInN0ZXAtZm9yd2FyZC0yIGRvd25cIj48L2Nsci1pY29uPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInBhZ2luYXRpb24tcHJldmlvdXNcIiBbZGlzYWJsZWRdPVwicGFnZS5jdXJyZW50IDw9IDFcIiAoY2xpY2spPVwicGFnZS5jdXJyZW50ID0gcGFnZS5jdXJyZW50IC0gMVwiPlxuICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJhbmdsZSBsZWZ0XCI+PC9jbHItaWNvbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgICAgPGlucHV0ICNjdXJyZW50UGFnZUlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJwYWdpbmF0aW9uLWN1cnJlbnRcIiBbc2l6ZV09XCJwYWdlLmxhc3QudG9TdHJpbmcoKS5sZW5ndGhcIiBbdmFsdWVdPVwicGFnZS5jdXJyZW50XCJcbiAgICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJ1cGRhdGVDdXJyZW50UGFnZSgkZXZlbnQpXCIgKGJsdXIpPVwidXBkYXRlQ3VycmVudFBhZ2UoJGV2ZW50KVwiLz4mbmJzcDsvJm5ic3A7PHNwYW4+e3twYWdlLmxhc3R9fTwvc3Bhbj5cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGFnaW5hdGlvbi1uZXh0XCIgW2Rpc2FibGVkXT1cInBhZ2UuY3VycmVudCA+PSBwYWdlLmxhc3RcIiAoY2xpY2spPVwicGFnZS5jdXJyZW50ID0gcGFnZS5jdXJyZW50ICsgMVwiPlxuICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJhbmdsZSByaWdodFwiPjwvY2xyLWljb24+XG4gICAgICA8L2J1dHRvbj5cbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwicGFnaW5hdGlvbi1sYXN0XCIgW2Rpc2FibGVkXT1cInBhZ2UuY3VycmVudCA+PSBwYWdlLmxhc3RcIiAoY2xpY2spPVwicGFnZS5jdXJyZW50ID0gcGFnZS5sYXN0XCI+XG4gICAgICAgIDxjbHItaWNvbiBzaGFwZT1cInN0ZXAtZm9yd2FyZC0yIHVwXCI+PC9jbHItaWNvbj5cbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICAgIGAsXG4gIGhvc3Q6IHsgJ1tjbGFzcy5wYWdpbmF0aW9uXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEYXRhZ3JpZFBhZ2luYXRpb24gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIEBDb250ZW50Q2hpbGQoQ2xyRGF0YWdyaWRQYWdlU2l6ZSkgX3BhZ2VTaXplQ29tcG9uZW50OiBDbHJEYXRhZ3JpZFBhZ2VTaXplO1xuICBAVmlld0NoaWxkKCdjdXJyZW50UGFnZUlucHV0JykgY3VycmVudFBhZ2VJbnB1dFJlZjogRWxlbWVudFJlZjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZTogUGFnZSkge1xuICAgIHRoaXMucGFnZS5hY3RpdmF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqKioqKioqKipcbiAgICogU3Vic2NyaXB0aW9uIHRvIHRoZSBQYWdlIHNlcnZpY2UgZm9yIHBhZ2UgY2hhbmdlcy5cbiAgICogTm90ZTogdGhpcyBvbmx5IGVtaXRzIGFmdGVyIHRoZSBkYXRhZ3JpZCBpcyBpbml0aWFsaXplZC9zdGFiYWxpemVkIGFuZCB0aGUgcGFnZSBjaGFuZ2VzLlxuICAgKi9cbiAgbmdPbkluaXQoKSB7XG4gICAgLypcbiAgICAgKiBEZWZhdWx0IHBhZ2Ugc2l6ZSBpcyAxMC5cbiAgICAgKiBUaGUgcmVhc29uIHdlIHNldCBpdCBoZXJlIGFuZCBub3QgaW4gdGhlIHByb3ZpZGVyIGl0c2VsZiBpcyBiZWNhdXNlXG4gICAgICogd2UgZG9uJ3Qgd2FudCBwYWdpbmF0aW9uIGlmIHRoaXMgY29tcG9uZW50IGlzbid0IHByZXNlbnQgaW4gdGhlIGRhdGFncmlkLlxuICAgICAqL1xuICAgIGlmICghdGhpcy5wYWdlLnNpemUpIHtcbiAgICAgIHRoaXMucGFnZS5zaXplID0gMTA7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VTdWJzY3JpcHRpb24gPSB0aGlzLnBhZ2UuY2hhbmdlLnN1YnNjcmliZShjdXJyZW50ID0+IHRoaXMuY3VycmVudENoYW5nZWQuZW1pdChjdXJyZW50KSk7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaXB0aW9uIHRvIHRoZSBwYWdlIHNlcnZpY2UgY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfcGFnZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMucGFnZS5yZXNldFBhZ2VTaXplKCk7XG4gICAgaWYgKHRoaXMuX3BhZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuX3BhZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFnZSBzaXplXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5zaXplO1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ1BhZ2VTaXplJylcbiAgcHVibGljIHNldCBwYWdlU2l6ZShzaXplOiBudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhZ2Uuc2l6ZSA9IHNpemU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvdGFsIGl0ZW1zIChuZWVkZWQgdG8gZ3Vlc3MgdGhlIGxhc3QgcGFnZSlcbiAgICovXG4gIHB1YmxpYyBnZXQgdG90YWxJdGVtcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2UudG90YWxJdGVtcztcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdUb3RhbEl0ZW1zJylcbiAgcHVibGljIHNldCB0b3RhbEl0ZW1zKHRvdGFsOiBudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIHRvdGFsID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wYWdlLnRvdGFsSXRlbXMgPSB0b3RhbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGFzdCBwYWdlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxhc3RQYWdlKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5sYXN0O1xuICB9XG5cbiAgQElucHV0KCdjbHJEZ0xhc3RQYWdlJylcbiAgcHVibGljIHNldCBsYXN0UGFnZShsYXN0OiBudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhZ2UubGFzdCA9IGxhc3Q7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEN1cnJlbnQgcGFnZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhZ2UuY3VycmVudDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyRGdQYWdlJylcbiAgcHVibGljIHNldCBjdXJyZW50UGFnZShwYWdlOiBudW1iZXIpIHtcbiAgICBpZiAodHlwZW9mIHBhZ2UgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhZ2UuY3VycmVudCA9IHBhZ2U7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xyRGdQYWdlQ2hhbmdlJykgY3VycmVudENoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBNb3ZlcyB0byB0aGUgcHJldmlvdXMgcGFnZSBpZiBpdCBleGlzdHNcbiAgICovXG4gIHB1YmxpYyBwcmV2aW91cygpIHtcbiAgICB0aGlzLnBhZ2UucHJldmlvdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyB0byB0aGUgbmV4dCBwYWdlIGlmIGl0IGV4aXN0c1xuICAgKi9cbiAgcHVibGljIG5leHQoKSB7XG4gICAgdGhpcy5wYWdlLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgZmlyc3QgaXRlbSBkaXNwbGF5ZWQgb24gdGhlIGN1cnJlbnQgcGFnZSwgc3RhcnRpbmcgYXQgMFxuICAgKi9cbiAgcHVibGljIGdldCBmaXJzdEl0ZW0oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmZpcnN0SXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmRleCBvZiB0aGUgbGFzdCBpdGVtIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCBwYWdlLCBzdGFydGluZyBhdCAwXG4gICAqL1xuICBwdWJsaWMgZ2V0IGxhc3RJdGVtKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZS5sYXN0SXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IGFkZHMgcGFnZSBudW1iZXJzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGN1cnJlbnQgcGFnZVxuICAgKi9cbiAgcHVibGljIGdldCBtaWRkbGVQYWdlcygpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbWlkZGxlUGFnZXM6IG51bWJlcltdID0gW107XG4gICAgaWYgKHRoaXMucGFnZS5jdXJyZW50ID4gMSkge1xuICAgICAgbWlkZGxlUGFnZXMucHVzaCh0aGlzLnBhZ2UuY3VycmVudCAtIDEpO1xuICAgIH1cbiAgICBtaWRkbGVQYWdlcy5wdXNoKHRoaXMucGFnZS5jdXJyZW50KTtcbiAgICBpZiAodGhpcy5wYWdlLmN1cnJlbnQgPCB0aGlzLnBhZ2UubGFzdCkge1xuICAgICAgbWlkZGxlUGFnZXMucHVzaCh0aGlzLnBhZ2UuY3VycmVudCArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbWlkZGxlUGFnZXM7XG4gIH1cblxuICAvKipcbiAgICogV2Ugb25seSB1cGRhdGUgdGhlIHBhZ2luYXRpb24ncyBjdXJyZW50IHBhZ2Ugb24gYmx1ciBvZiB0aGUgaW5wdXQgZmllbGQsIG9yXG4gICAqIHdoZW4gdGhleSBwcmVzcyBlbnRlci5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVDdXJyZW50UGFnZShldmVudDogYW55KTogdm9pZCB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoZXZlbnQudGFyZ2V0LnZhbHVlLCAxMCk7XG5cbiAgICAvLyBpZiB0aGUgaW5wdXQgdmFsdWUsIGlzIG5vdCBhIG51bWJlciwgd2UgZG9uJ3QgdXBkYXRlIHRoZSBwYWdlXG4gICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICBpZiAocGFyc2VkIDwgMSkge1xuICAgICAgICB0aGlzLnBhZ2UuY3VycmVudCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlZCA+IHRoaXMucGFnZS5sYXN0KSB7XG4gICAgICAgIHRoaXMucGFnZS5jdXJyZW50ID0gdGhpcy5wYWdlLmxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhZ2UuY3VycmVudCA9IHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGlucHV0J3MgdmFsdWUgdG8gdGhlIG5ldyBjdXJyZW50IHBhZ2UuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGNvZGVcbiAgICAgKiBhYm92ZSBtYXkgaGF2ZSBjaGFuZ2VkIHRoZSB2YWx1ZSBmcm9tIHdoYXQgdGhlIHVzZXIgZW50ZXJlZCBpbi5cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRQYWdlSW5wdXRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9IHRoaXMucGFnZS5jdXJyZW50O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgSW5wdXQsIE9uRGVzdHJveSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuXG5pbXBvcnQgeyBDbHJEYXRhZ3JpZENlbGwgfSBmcm9tICcuL2RhdGFncmlkLWNlbGwnO1xuaW1wb3J0IHsgRGF0YWdyaWRIaWRlYWJsZUNvbHVtbk1vZGVsIH0gZnJvbSAnLi9kYXRhZ3JpZC1oaWRlYWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgRXhwYW5kYWJsZVJvd3NDb3VudCB9IGZyb20gJy4vcHJvdmlkZXJzL2dsb2JhbC1leHBhbmRhYmxlLXJvd3MnO1xuaW1wb3J0IHsgSGlkZWFibGVDb2x1bW5TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaGlkZWFibGUtY29sdW1uLnNlcnZpY2UnO1xuaW1wb3J0IHsgUm93QWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jvdy1hY3Rpb24tc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICcuL3Byb3ZpZGVycy9zZWxlY3Rpb24nO1xuaW1wb3J0IHsgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4vZW51bXMvc2VsZWN0aW9uLXR5cGUnO1xuXG4vKipcbiAqIEdlbmVyaWMgYmxhbmQgY29udGFpbmVyIHNlcnZpbmcgdmFyaW91cyBwdXJwb3NlcyBmb3IgRGF0YWdyaWQuXG4gKiBGb3IgaW5zdGFuY2UsIGl0IGNhbiBoZWxwIHNwYW4gYSB0ZXh0IG92ZXIgbXVsdGlwbGUgcm93cyBpbiBkZXRhaWwgdmlldy5cbiAqL1xuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRnLXJvdy1kZXRhaWwnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXJlcGxhY2VkUm93XCI+XG4gICAgICAgICAgICA8IS0tIHNwYWNlIGZvciBtdWx0aXNlbGVjdGlvbiBzdGF0ZSAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkYXRhZ3JpZC1jZWxsIGRhdGFncmlkLXNlbGVjdCBkYXRhZ3JpZC1maXhlZC1jb2x1bW5cIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwic2VsZWN0aW9uLnNlbGVjdGlvblR5cGUgPT09IFNFTEVDVElPTl9UWVBFLk11bHRpXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gc3BhY2UgZm9yIHNpbmdsZSBzZWxlY3Rpb24gc3RhdGUgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtY2VsbCBkYXRhZ3JpZC1zZWxlY3QgZGF0YWdyaWQtZml4ZWQtY29sdW1uXCJcbiAgICAgICAgICAgICAgICAqbmdJZj1cInNlbGVjdGlvbi5zZWxlY3Rpb25UeXBlID09PSBTRUxFQ1RJT05fVFlQRS5TaW5nbGVcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPCEtLSBzcGFjZSBmb3Igc2luZ2xlIHJvdyBhY3Rpb247IG9ubHkgZGlzcGxheVR5cGUgaWYgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYWN0aW9uYWJsZSByb3cgaW4gZGF0YWdyaWQgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZGF0YWdyaWQtY2VsbCBkYXRhZ3JpZC1yb3ctYWN0aW9ucyBkYXRhZ3JpZC1maXhlZC1jb2x1bW5cIlxuICAgICAgICAgICAgICAgICpuZ0lmPVwicm93QWN0aW9uU2VydmljZS5oYXNBY3Rpb25hYmxlUm93XCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gc3BhY2UgZm9yIGV4cGFuZGFibGUgY2FyZXQgYWN0aW9uOyBvbmx5IGRpc3BsYXlUeXBlIGlmIHdlIGhhdmUgYXQgbGVhc3Qgb25lIGV4cGFuZGFibGUgcm93IGluIGRhdGFncmlkIC0tPlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cImV4cGFuZGFibGVSb3dzLmhhc0V4cGFuZGFibGVSb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJkYXRhZ3JpZC1leHBhbmRhYmxlLWNhcmV0IGRhdGFncmlkLWZpeGVkLWNvbHVtbiBkYXRhZ3JpZC1jZWxsXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICBgLFxuICBob3N0OiB7XG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1yb3ctZmxleF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5kYXRhZ3JpZC1yb3ctZGV0YWlsXSc6ICd0cnVlJyxcbiAgICAnW2NsYXNzLmRhdGFncmlkLWNvbnRhaW5lcl0nOiAnY2VsbHMubGVuZ3RoID09PSAwJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRSb3dEZXRhaWw8VCA9IGFueT4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAvKiByZWZlcmVuY2UgdG8gdGhlIGVudW0gc28gdGhhdCB0ZW1wbGF0ZSBjYW4gYWNjZXNzIGl0ICovXG4gIHB1YmxpYyBTRUxFQ1RJT05fVFlQRSA9IFNlbGVjdGlvblR5cGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHNlbGVjdGlvbjogU2VsZWN0aW9uLFxuICAgIHB1YmxpYyByb3dBY3Rpb25TZXJ2aWNlOiBSb3dBY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBleHBhbmQ6IEV4cGFuZCxcbiAgICBwdWJsaWMgaGlkZWFibGVDb2x1bW5TZXJ2aWNlOiBIaWRlYWJsZUNvbHVtblNlcnZpY2UsXG4gICAgcHVibGljIGV4cGFuZGFibGVSb3dzOiBFeHBhbmRhYmxlUm93c0NvdW50XG4gICkge31cblxuICBAQ29udGVudENoaWxkcmVuKENsckRhdGFncmlkQ2VsbCkgY2VsbHM6IFF1ZXJ5TGlzdDxDbHJEYXRhZ3JpZENlbGw+O1xuXG4gIEBJbnB1dCgnY2xyRGdSZXBsYWNlJylcbiAgc2V0IHJlcGxhY2UodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmV4cGFuZC5zZXRSZXBsYWNlKCEhdmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwdWJsaWMgcmVwbGFjZWRSb3cgPSBmYWxzZTtcblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgY29uc3QgY29sdW1uc0xpc3QgPSB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5nZXRDb2x1bW5zKCk7XG4gICAgdGhpcy51cGRhdGVDZWxsc0ZvckNvbHVtbnMoY29sdW1uc0xpc3QpO1xuXG4gICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIENlbGxzIGxpc3QgY2hhbmdlcyBwZXIgcm93LXJlbmRlcmVyXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmNlbGxzLmNoYW5nZXMuc3Vic2NyaWJlKGNlbGxMaXN0ID0+IHtcbiAgICAgICAgY29uc3QgY29sdW1uTGlzdCA9IHRoaXMuaGlkZWFibGVDb2x1bW5TZXJ2aWNlLmdldENvbHVtbnMoKTtcbiAgICAgICAgaWYgKGNlbGxMaXN0Lmxlbmd0aCA9PT0gY29sdW1uTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNlbGxzRm9yQ29sdW1ucyhjb2x1bW5MaXN0KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgLy8gVXNlZCB0byBzZXQgdGhpbmdzIHVwIHRoZSBmaXJzdCB0aW1lIGJ1dCBvbmx5IGFmdGVyIGFsbCB0aGUgY29sdW1ucyBhcmUgcmVhZHkuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhpZGVhYmxlQ29sdW1uU2VydmljZS5jb2x1bW5MaXN0Q2hhbmdlLnN1YnNjcmliZShjb2x1bW5MaXN0ID0+IHtcbiAgICAgICAgLy8gUHJldmVudHMgY2VsbCB1cGRhdGVzIHdoZW4gY29scyBhbmQgY2VsbHMgYXJyYXkgYXJlIG5vdCBhbGlnbmVkXG4gICAgICAgIGlmIChjb2x1bW5MaXN0Lmxlbmd0aCA9PT0gdGhpcy5jZWxscy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNlbGxzRm9yQ29sdW1ucyhjb2x1bW5MaXN0KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmV4cGFuZC5yZXBsYWNlLnN1YnNjcmliZShyZXBsYWNlQ2hhbmdlID0+IHtcbiAgICAgICAgdGhpcy5yZXBsYWNlZFJvdyA9IHJlcGxhY2VDaGFuZ2U7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgdXBkYXRlQ2VsbHNGb3JDb2x1bW5zKGNvbHVtbkxpc3Q6IERhdGFncmlkSGlkZWFibGVDb2x1bW5Nb2RlbFtdKSB7XG4gICAgdGhpcy5jZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudENvbHVtbiA9IGNvbHVtbkxpc3RbaW5kZXhdOyAvLyBBY2NvdW50cyBmb3IgbnVsbCBzcGFjZS5cbiAgICAgIGlmIChjdXJyZW50Q29sdW1uKSB7XG4gICAgICAgIGNlbGwuaWQgPSBjdXJyZW50Q29sdW1uLmlkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vLyBAVE9ETyBUaGUgdG9wIHR3byBhcmUgbm90IHVzZWQgbm93LCB3aGljaCBpcyBwcm9iYWJseSBhIHBlcmZvcm1hbmNlIGRyYWcgdGhhdCB3YXMgYnJva2VuIGFsb25nIHRoZSB3YXkuXG4vLyBUaGVyZSB3YXMgYSBwcmV2aW91cyBwYXR0ZXJuIHRvIGhpZGUgZXZlcnl0aGluZyB0byBkbyBjb21wdXRhdGlvbiB0aGVuIGRpc3BsYXksIGZvciBGaXJlZm94LCBuZWVkcyByZXZpc2l0aW5nLlxuZXhwb3J0IGNvbnN0IE5PX0xBWU9VVF9DTEFTUyA9ICdkYXRhZ3JpZC1uby1sYXlvdXQnO1xuZXhwb3J0IGNvbnN0IENPTVBVVEVfV0lEVEhfQ0xBU1MgPSAnZGF0YWdyaWQtY29tcHV0aW5nLWNvbHVtbnMtd2lkdGgnO1xuZXhwb3J0IGNvbnN0IFNUUklDVF9XSURUSF9DTEFTUyA9ICdkYXRhZ3JpZC1maXhlZC13aWR0aCc7XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBlbnVtIERhdGFncmlkQ29sdW1uQ2hhbmdlcyB7XG4gIFdJRFRILFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJTdGVwIH0gZnJvbSAnLi4vZW51bXMvcmVuZGVyLXN0ZXAuZW51bSc7XG5cbmltcG9ydCB7IFNUUklDVF9XSURUSF9DTEFTUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyT3JnYW5pemVyIH0gZnJvbSAnLi9yZW5kZXItb3JnYW5pemVyJztcbmltcG9ydCB7IERhdGFncmlkQ29sdW1uU3RhdGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbHVtbi1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRDb2x1bW5DaGFuZ2VzIH0gZnJvbSAnLi4vZW51bXMvY29sdW1uLWNoYW5nZXMuZW51bSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1kZy1jZWxsJyB9KVxuZXhwb3J0IGNsYXNzIERhdGFncmlkQ2VsbFJlbmRlcmVyIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdGF0ZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIC8vIEBUT0RPKEpFUkVNWSkgV29yayBvdXQgaG93IHRvIGRlZHVwZSBzb21lIG9mIHRoaXMgY29kZSBiZXR3ZWVuIGhlYWRlciBhbmQgY2VsbCByZW5kZXJlcnNcbiAgc2V0IGNvbHVtblN0YXRlKGNvbHVtblN0YXRlOiBCZWhhdmlvclN1YmplY3Q8RGF0YWdyaWRDb2x1bW5TdGF0ZT4pIHtcbiAgICBpZiAodGhpcy5zdGF0ZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdGF0ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlU3Vic2NyaXB0aW9uID0gY29sdW1uU3RhdGUuc3Vic2NyaWJlKHN0YXRlID0+IHRoaXMuc3RhdGVDaGFuZ2VzKHN0YXRlKSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIG9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIG9yZ2FuaXplci5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuQ0xFQVJfV0lEVEhTKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbGVhcldpZHRoKCkpXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goc3ViID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICBpZiAodGhpcy5zdGF0ZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdGF0ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGVDaGFuZ2VzKHN0YXRlOiBEYXRhZ3JpZENvbHVtblN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLmNoYW5nZXMgJiYgc3RhdGUuY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmNoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xuICAgICAgICBzd2l0Y2ggKGNoYW5nZSkge1xuICAgICAgICAgIGNhc2UgRGF0YWdyaWRDb2x1bW5DaGFuZ2VzLldJRFRIOlxuICAgICAgICAgICAgdGhpcy5zZXRXaWR0aChzdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJXaWR0aCgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgbnVsbCk7XG4gIH1cblxuICBwcml2YXRlIHNldFdpZHRoKHN0YXRlOiBEYXRhZ3JpZENvbHVtblN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnN0cmljdFdpZHRoKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsIFNUUklDVF9XSURUSF9DTEFTUyk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCBzdGF0ZS53aWR0aCArICdweCcpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRG9tQWRhcHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2RvbS1hZGFwdGVyL2RvbS1hZGFwdGVyJztcbmltcG9ydCB7IERhdGFncmlkUmVuZGVyU3RlcCB9IGZyb20gJy4uL2VudW1zL3JlbmRlci1zdGVwLmVudW0nO1xuaW1wb3J0IHsgQ29sdW1uUmVzaXplclNlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvY29sdW1uLXJlc2l6ZXIuc2VydmljZSc7XG5pbXBvcnQgeyBTVFJJQ1RfV0lEVEhfQ0xBU1MgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplciB9IGZyb20gJy4vcmVuZGVyLW9yZ2FuaXplcic7XG5pbXBvcnQgeyBEYXRhZ3JpZENvbHVtblN0YXRlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jb2x1bW4tc3RhdGUuaW50ZXJmYWNlJztcbmltcG9ydCB7IERhdGFncmlkQ29sdW1uQ2hhbmdlcyB9IGZyb20gJy4uL2VudW1zL2NvbHVtbi1jaGFuZ2VzLmVudW0nO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGctY29sdW1uJywgcHJvdmlkZXJzOiBbQ29sdW1uUmVzaXplclNlcnZpY2VdIH0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRIZWFkZXJSZW5kZXJlciBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3RhdGVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBzZXQgY29sdW1uU3RhdGUoY29sdW1uU3RhdGU6IEJlaGF2aW9yU3ViamVjdDxEYXRhZ3JpZENvbHVtblN0YXRlPikge1xuICAgIGlmICh0aGlzLnN0YXRlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN0YXRlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGVTdWJzY3JpcHRpb24gPSBjb2x1bW5TdGF0ZS5zdWJzY3JpYmUoc3RhdGUgPT4gdGhpcy5zdGF0ZUNoYW5nZXMoc3RhdGUpKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgb3JnYW5pemVyOiBEYXRhZ3JpZFJlbmRlck9yZ2FuaXplcixcbiAgICBwcml2YXRlIGRvbUFkYXB0ZXI6IERvbUFkYXB0ZXIsXG4gICAgcHJpdmF0ZSBjb2x1bW5SZXNpemVyU2VydmljZTogQ29sdW1uUmVzaXplclNlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm9yZ2FuaXplci5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuQ0xFQVJfV0lEVEhTKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbGVhcldpZHRoKCkpXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMub3JnYW5pemVyXG4gICAgICAgIC5maWx0ZXJSZW5kZXJTdGVwcyhEYXRhZ3JpZFJlbmRlclN0ZXAuREVURUNUX1NUUklDVF9XSURUSFMpXG4gICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kZXRlY3RTdHJpY3RXaWR0aCgpKVxuICAgICk7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJEZ0NvbHVtblJlc2l6ZScpIHJlc2l6ZUVtaXR0ZXI6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbHVtbiBoYXMgYSBzdHJpY3Qgd2lkdGgsIHNvIGl0IGRvZXNuJ3Qgc2hyaW5rIG9yIGV4cGFuZCBiYXNlZCBvbiB0aGUgY29udGVudC5cbiAgICovXG4gIHByaXZhdGUgd2lkdGhTZXQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBhdXRvU2V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gICAgaWYgKHRoaXMuc3RhdGVTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3RhdGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRlQ2hhbmdlcyhzdGF0ZTogRGF0YWdyaWRDb2x1bW5TdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5jaGFuZ2VzICYmIHN0YXRlLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5jaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgc3dpdGNoIChjaGFuZ2UpIHtcbiAgICAgICAgICBjYXNlIERhdGFncmlkQ29sdW1uQ2hhbmdlcy5XSURUSDpcbiAgICAgICAgICAgIHRoaXMuc2V0V2lkdGgoc3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNsZWFyV2lkdGgoKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSB3aWR0aCBvbmx5IGlmIHdlIHNldCBpdCwgYW5kIGl0IGlzIG5vdCBjaGFuZ2VkIGJ5IGRyYWdnaW5nLlxuICAgIGlmICh0aGlzLndpZHRoU2V0ICYmICF0aGlzLmNvbHVtblJlc2l6ZXJTZXJ2aWNlLnJlc2l6ZWRCeSkge1xuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdXRvU2V0KSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRldGVjdFN0cmljdFdpZHRoKCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuY29sdW1uUmVzaXplclNlcnZpY2UucmVzaXplZEJ5KSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2x1bW5SZXNpemVyU2VydmljZS53aWR0aEFmdGVyUmVzaXplO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hdXRvU2V0KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZG9tQWRhcHRlci51c2VyRGVmaW5lZFdpZHRoKHRoaXMuZWwubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlV2lkdGgoc3RyaWN0V2lkdGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgbGV0IHdpZHRoOiBudW1iZXIgPSBzdHJpY3RXaWR0aDtcbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMuZG9tQWRhcHRlci5zY3JvbGxXaWR0aCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBwdWJsaWMgZ2V0Q29sdW1uV2lkdGhTdGF0ZSgpOiBQYXJ0aWFsPERhdGFncmlkQ29sdW1uU3RhdGU+IHtcbiAgICBjb25zdCBzdHJpY3RXaWR0aCA9IHRoaXMuZGV0ZWN0U3RyaWN0V2lkdGgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHRoaXMuY29tcHV0ZVdpZHRoKHN0cmljdFdpZHRoKSxcbiAgICAgIHN0cmljdFdpZHRoOiBzdHJpY3RXaWR0aCxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRXaWR0aChzdGF0ZTogRGF0YWdyaWRDb2x1bW5TdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5zdHJpY3RXaWR0aCkge1xuICAgICAgaWYgKHRoaXMuY29sdW1uUmVzaXplclNlcnZpY2UucmVzaXplZEJ5KSB7XG4gICAgICAgIHRoaXMucmVzaXplRW1pdHRlci5lbWl0KHN0YXRlLndpZHRoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICd3aWR0aCcsIHN0YXRlLndpZHRoICsgJ3B4Jyk7XG4gICAgICAgIHRoaXMud2lkdGhTZXQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHNldCB3aWR0aCBpZiB0aGVyZSBpcyBhIHVzZXItZGVmaW5lZCBvbmUuIEp1c3QgYWRkIHRoZSBzdHJpY3Qgd2lkdGggY2xhc3MuXG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICAgIHRoaXMuYXV0b1NldCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgU1RSSUNUX1dJRFRIX0NMQVNTKTtcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnd2lkdGgnLCBzdGF0ZS53aWR0aCArICdweCcpO1xuICAgICAgdGhpcy53aWR0aFNldCA9IHRydWU7XG4gICAgICB0aGlzLmF1dG9TZXQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vKlxuICogVGhpcyB2ZXJzaW9uIG9mIHRoZSBEb21BZGFwdGVyIGlzIGZvciB1c2Ugb24gbm9uLWJyb3dzZXIgcGxhdGZvcm1zLCB3aGVyZSB0aGVyZSBhcmUgbm9cbiAqIG5hdGl2ZUVsZW1lbnRzIHRvIHVzZSBmb3IgY2FsY3VsYXRpb25zLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOb29wRG9tQWRhcHRlciBpbXBsZW1lbnRzIERvbUFkYXB0ZXIge1xuICB1c2VyRGVmaW5lZFdpZHRoKGVsZW1lbnQ6IGFueSk6IG51bWJlciB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBzY3JvbGxCYXJXaWR0aChlbGVtZW50OiBhbnkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHNjcm9sbFdpZHRoKGVsZW1lbnQ6IGFueSkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29tcHV0ZWRIZWlnaHQoZWxlbWVudDogYW55KTogbnVtYmVyIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNsaWVudFJlY3QoZWxlbWVudDogYW55KTogQ2xpZW50UmVjdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgIH07XG4gIH1cblxuICBtaW5XaWR0aChlbGVtZW50OiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZm9jdXMoZWxlbWVudDogYW55KTogdm9pZCB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZENlbGxSZW5kZXJlciB9IGZyb20gJy4vY2VsbC1yZW5kZXJlcic7XG5pbXBvcnQgeyBDb2x1bW5zU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9jb2x1bW5zLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItZGctcm93LCBjbHItZGctcm93LWRldGFpbCcgfSlcbmV4cG9ydCBjbGFzcyBEYXRhZ3JpZFJvd1JlbmRlcmVyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG4gIEBDb250ZW50Q2hpbGRyZW4oRGF0YWdyaWRDZWxsUmVuZGVyZXIpIHByaXZhdGUgY2VsbHM6IFF1ZXJ5TGlzdDxEYXRhZ3JpZENlbGxSZW5kZXJlcj47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb2x1bW5zU2VydmljZTogQ29sdW1uc1NlcnZpY2UpIHt9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuY2VsbHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRDb2x1bW5TdGF0ZXMoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldHVwQ29sdW1ucygpIHtcbiAgICB0aGlzLnNldENvbHVtblN0YXRlcygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRDb2x1bW5TdGF0ZXMoKSB7XG4gICAgdGhpcy5jZWxscy5mb3JFYWNoKChjZWxsLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY29sdW1uc1NlcnZpY2UuY29sdW1uc1tpbmRleF0pIHtcbiAgICAgICAgY2VsbC5jb2x1bW5TdGF0ZSA9IHRoaXMuY29sdW1uc1NlcnZpY2UuY29sdW1uc1tpbmRleF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIEFmdGVyVmlld0NoZWNrZWQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBPbkRlc3Ryb3ksXG4gIFBMQVRGT1JNX0lELFxuICBRdWVyeUxpc3QsXG4gIFJlbmRlcmVyMixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBEYXRhZ3JpZFJlbmRlclN0ZXAgfSBmcm9tICcuLi9lbnVtcy9yZW5kZXItc3RlcC5lbnVtJztcbmltcG9ydCB7IEl0ZW1zIH0gZnJvbSAnLi4vcHJvdmlkZXJzL2l0ZW1zJztcbmltcG9ydCB7IFBhZ2UgfSBmcm9tICcuLi9wcm92aWRlcnMvcGFnZSc7XG5pbXBvcnQgeyBUYWJsZVNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vcHJvdmlkZXJzL3RhYmxlLXNpemUuc2VydmljZSc7XG5cbmltcG9ydCB7IERvbUFkYXB0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9kb20tYWRhcHRlci9kb20tYWRhcHRlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZEhlYWRlclJlbmRlcmVyIH0gZnJvbSAnLi9oZWFkZXItcmVuZGVyZXInO1xuaW1wb3J0IHsgTm9vcERvbUFkYXB0ZXIgfSBmcm9tICcuL25vb3AtZG9tLWFkYXB0ZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIgfSBmcm9tICcuL3JlbmRlci1vcmdhbml6ZXInO1xuaW1wb3J0IHsgQ29sdW1uc1NlcnZpY2UgfSBmcm9tICcuLi9wcm92aWRlcnMvY29sdW1ucy5zZXJ2aWNlJztcbmltcG9ydCB7IERhdGFncmlkQ29sdW1uU3RhdGUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbHVtbi1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGF0YWdyaWRDb2x1bW5DaGFuZ2VzIH0gZnJvbSAnLi4vZW51bXMvY29sdW1uLWNoYW5nZXMuZW51bSc7XG5pbXBvcnQgeyBEYXRhZ3JpZFJvd1JlbmRlcmVyIH0gZnJvbSAnLi9yb3ctcmVuZGVyZXInO1xuXG4vLyBGaXhlcyBidWlsZCBlcnJvclxuLy8gQGR5bmFtaWMgKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE5Njk4I2lzc3VlY29tbWVudC0zMzgzNDAyMTEpXG5leHBvcnQgY29uc3QgZG9tQWRhcHRlckZhY3RvcnkgPSAocGxhdGZvcm1JZDogT2JqZWN0KSA9PiB7XG4gIGlmIChpc1BsYXRmb3JtQnJvd3NlcihwbGF0Zm9ybUlkKSkge1xuICAgIHJldHVybiBuZXcgRG9tQWRhcHRlcigpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTm9vcERvbUFkYXB0ZXIoKTtcbiAgfVxufTtcblxuLy8gRml4ZXMgYnVpbGQgZXJyb3Jcbi8vIEBkeW5hbWljIChodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTY5OCNpc3N1ZWNvbW1lbnQtMzM4MzQwMjExKVxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnY2xyLWRhdGFncmlkJyxcbiAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBEb21BZGFwdGVyLCB1c2VGYWN0b3J5OiBkb21BZGFwdGVyRmFjdG9yeSwgZGVwczogW1BMQVRGT1JNX0lEXSB9XSxcbn0pXG5leHBvcnQgY2xhc3MgRGF0YWdyaWRNYWluUmVuZGVyZXI8VCA9IGFueT4gaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBBZnRlclZpZXdDaGVja2VkLCBPbkRlc3Ryb3kge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG9yZ2FuaXplcjogRGF0YWdyaWRSZW5kZXJPcmdhbml6ZXIsXG4gICAgcHJpdmF0ZSBpdGVtczogSXRlbXMsXG4gICAgcHJpdmF0ZSBwYWdlOiBQYWdlLFxuICAgIHByaXZhdGUgZG9tQWRhcHRlcjogRG9tQWRhcHRlcixcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIHRhYmxlU2l6ZVNlcnZpY2U6IFRhYmxlU2l6ZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjb2x1bW5zU2VydmljZTogQ29sdW1uc1NlcnZpY2VcbiAgKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLm9yZ2FuaXplclxuICAgICAgICAuZmlsdGVyUmVuZGVyU3RlcHMoRGF0YWdyaWRSZW5kZXJTdGVwLkNPTVBVVEVfQ09MVU1OX1dJRFRIUylcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNvbXB1dGVIZWFkZXJzV2lkdGgoKSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLnBhZ2Uuc2l6ZUNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5faGVpZ2h0U2V0KSB7XG4gICAgICAgICAgdGhpcy5yZXNldERhdGFncmlkSGVpZ2h0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLml0ZW1zLmNoYW5nZS5zdWJzY3JpYmUoKCkgPT4gKHRoaXMuc2hvdWxkU3RhYmlsaXplQ29sdW1ucyA9IHRydWUpKSk7XG4gIH1cblxuICBAQ29udGVudENoaWxkcmVuKERhdGFncmlkSGVhZGVyUmVuZGVyZXIpIHByaXZhdGUgaGVhZGVyczogUXVlcnlMaXN0PERhdGFncmlkSGVhZGVyUmVuZGVyZXI+O1xuICBAQ29udGVudENoaWxkcmVuKERhdGFncmlkUm93UmVuZGVyZXIpIHByaXZhdGUgcm93czogUXVlcnlMaXN0PERhdGFncmlkUm93UmVuZGVyZXI+O1xuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLnNldHVwQ29sdW1ucygpO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmhlYWRlcnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBvbmx5IHJlLXN0YWJpbGl6ZSBpZiBhIGNvbHVtbiB3YXMgYWRkZWQgb3IgcmVtb3ZlZC4gUmVvcmRlcmluZyBpcyBmaW5lLlxuICAgICAgICAvLyBOZWVkIHRvIHNldHVwIGNvbHVtbnMgYmVmb3JlIHN0YWJhbGl6aW5nIHRoZW1cbiAgICAgICAgdGhpcy5zZXR1cENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFiaWxpemVDb2x1bW5zKCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMucm93cy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgIHRoaXMucm93cy5mb3JFYWNoKHJvdyA9PiByb3cuc2V0dXBDb2x1bW5zKCkpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBhbmQgc2V0IFRhYmxlIHdpZHRoIGZvciBob3Jpem9udGFsIHNjcm9sbGluZyBoZXJlLlxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy50YWJsZVNpemVTZXJ2aWNlLnRhYmxlID0gdGhpcy5lbDtcbiAgfVxuXG4gIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICBpZiAodGhpcy5zaG91bGRTdGFiaWxpemVDb2x1bW5zKSB7XG4gICAgICB0aGlzLnN0YWJpbGl6ZUNvbHVtbnMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkQ29tcHV0ZUhlaWdodCgpKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jb21wdXRlRGF0YWdyaWRIZWlnaHQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBDb2x1bW5zKCkge1xuICAgIHRoaXMuaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XG4gICAgICAvLyBXZSB3YW50IHRvIGdldCB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5jb2x1bW5zW2luZGV4XSA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0YWdyaWRDb2x1bW5TdGF0ZT4oaGVhZGVyLmdldENvbHVtbldpZHRoU3RhdGUoKSk7XG4gICAgICBoZWFkZXIuY29sdW1uU3RhdGUgPSB0aGlzLmNvbHVtbnNTZXJ2aWNlLmNvbHVtbnNbaW5kZXhdO1xuICAgIH0pO1xuICAgIHRoaXMuY29sdW1uc1NlcnZpY2UuY29sdW1ucy5zcGxpY2UodGhpcy5oZWFkZXJzLmxlbmd0aCk7IC8vIFRyaW0gYW55IG9sZCBjb2x1bW5zXG4gICAgdGhpcy5yb3dzLmZvckVhY2gocm93ID0+IHJvdy5zZXR1cENvbHVtbnMoKSk7XG4gIH1cblxuICBwcml2YXRlIF9oZWlnaHRTZXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHNob3VsZENvbXB1dGVIZWlnaHQoKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLl9oZWlnaHRTZXQgJiYgdGhpcy5wYWdlLnNpemUgPiAwKSB7XG4gICAgICBpZiAodGhpcy5pdGVtcy5kaXNwbGF5ZWQubGVuZ3RoID09PSB0aGlzLnBhZ2Uuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBoZWlnaHQgb2YgdGhlIGRhdGFncmlkLlxuICAgKlxuICAgKiBOT1RFOiBXZSBoYWQgdG8gY2hvb3NlIHRvIHNldCB0aGUgaGVpZ2h0IGluc3RlYWQgb2YgdGhlIG1pbi1oZWlnaHQgYmVjYXVzZVxuICAgKiBJRSAxMSByZXF1aXJlcyB0aGUgaGVpZ2h0IG9uIHRoZSBwYXJlbnQgZm9yIHRoZSBjaGlsZHJlbiBmbGV4IGdyb3cvc2hyaW5rIHByb3BlcnRpZXMgdG8gd29yay5cbiAgICogV2hlbiB3ZSB1c2VkIG1pbi1oZWlnaHQsIDEgMSBhdXRvIGRvZXNuJ3QgdXNlZCB0byB3b3JrIGluIElFMTEgOi0oXG4gICAqIEJ1dCB0aGlzIGRvZXNuJ3QgYWZmZWN0IHRoZSBmaXguIEl0IHdvcmtzIGluIGJvdGggZml4ZWQgJiB2YXJpYWJsZSBoZWlnaHQgZGF0YWdyaWRzLlxuICAgKlxuICAgKiBSZWZlcjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNDM5NjIwNS9mbGV4LWdyb3ctbm90LXdvcmtpbmctaW4taW50ZXJuZXQtZXhwbG9yZXItMTEtMFxuICAgKi9cbiAgcHJpdmF0ZSBjb21wdXRlRGF0YWdyaWRIZWlnaHQoKSB7XG4gICAgLy8gSUUgZG9lc24ndCByZXR1cm4gY29ycmVjdCB2YWx1ZSBmb3IgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiaGVpZ2h0XCIpXG4gICAgY29uc3QgdmFsdWU6IG51bWJlciA9IHRoaXMuZG9tQWRhcHRlci5jbGllbnRSZWN0KHRoaXMuZWwubmF0aXZlRWxlbWVudCkuaGVpZ2h0O1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgdmFsdWUgKyAncHgnKTtcbiAgICB0aGlzLl9oZWlnaHRTZXQgPSB0cnVlO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldERhdGFncmlkSGVpZ2h0KCkge1xuICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgJycpO1xuICAgIHRoaXMuX2hlaWdodFNldCA9IGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgZWFjaCBoZWFkZXIgY29tcHV0ZSBpdHMgd2lkdGguXG4gICAqL1xuICBwcml2YXRlIGNvbXB1dGVIZWFkZXJzV2lkdGgoKSB7XG4gICAgY29uc3QgbmJDb2x1bW5zOiBudW1iZXIgPSB0aGlzLmhlYWRlcnMubGVuZ3RoO1xuICAgIGxldCBhbGxTdHJpY3QgPSB0cnVlO1xuICAgIHRoaXMuaGVhZGVycy5mb3JFYWNoKChoZWFkZXIsIGluZGV4KSA9PiB7XG4gICAgICAvLyBPbiB0aGUgbGFzdCBoZWFkZXIgY29sdW1uIGNoZWNrIHdoZXRoZXIgYWxsIGNvbHVtbnMgaGF2ZSBzdHJpY3Qgd2lkdGhzLlxuICAgICAgLy8gSWYgYWxsIGNvbHVtbnMgaGF2ZSBzdHJpY3Qgd2lkdGhzLCByZW1vdmUgdGhlIHN0cmljdCB3aWR0aCBmcm9tIHRoZSBsYXN0IGNvbHVtbiBhbmQgbWFrZSBpdCB0aGUgY29sdW1uJ3NcbiAgICAgIC8vIG1pbmltdW0gd2lkdGggc28gdGhhdCB3aGVuIGFsbCBwcmV2aW91cyBjb2x1bW5zIHNocmluaywgaXQgd2lsbCBnZXQgYSBmbGV4aWJsZSB3aWR0aCBhbmQgY292ZXIgdGhlIGVtcHR5XG4gICAgICAvLyBnYXAgaW4gdGhlIERhdGFncmlkLlxuICAgICAgY29uc3Qgc3RhdGU6IFBhcnRpYWw8RGF0YWdyaWRDb2x1bW5TdGF0ZT4gPSB7XG4gICAgICAgIGNoYW5nZXM6IFtEYXRhZ3JpZENvbHVtbkNoYW5nZXMuV0lEVEhdLFxuICAgICAgICAuLi5oZWFkZXIuZ2V0Q29sdW1uV2lkdGhTdGF0ZSgpLFxuICAgICAgfTtcblxuICAgICAgaWYgKCFzdGF0ZS5zdHJpY3RXaWR0aCkge1xuICAgICAgICBhbGxTdHJpY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5iQ29sdW1ucyA9PT0gaW5kZXggKyAxICYmIGFsbFN0cmljdCkge1xuICAgICAgICBzdGF0ZS5zdHJpY3RXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2UuZW1pdFN0YXRlQ2hhbmdlKGluZGV4LCBzdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIGlmIHdlIHdhbnQgdG8gcmUtY29tcHV0ZSBjb2x1bW5zIHdpZHRoLiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbjpcbiAgICogMSkgV2hlbiBoZWFkZXJzIGNoYW5nZSwgd2l0aCBjb2x1bW5zIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWRcbiAgICogMikgV2hlbiByb3dzIGFyZSBsYXppbHkgbG9hZGVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgKi9cbiAgcHJpdmF0ZSBjb2x1bW5zU2l6ZXNTdGFibGUgPSBmYWxzZTtcblxuICBwcml2YXRlIHNob3VsZFN0YWJpbGl6ZUNvbHVtbnMgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIHdob2xlIHJlLXJlbmRyaW5nIGN5Y2xlIHRvIHNldCBjb2x1bW4gc2l6ZXMsIGlmIG5lZWRlZC5cbiAgICovXG4gIHByaXZhdGUgc3RhYmlsaXplQ29sdW1ucygpIHtcbiAgICB0aGlzLnNob3VsZFN0YWJpbGl6ZUNvbHVtbnMgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlc2l6ZSB3aGVuIHRoZSByb3dzIGFyZSBsb2FkZWQuXG4gICAgaWYgKHRoaXMuaXRlbXMuZGlzcGxheWVkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMub3JnYW5pemVyLnJlc2l6ZSgpO1xuICAgICAgdGhpcy5jb2x1bW5zU2l6ZXNTdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBDbHJGb3Jtc01vZHVsZSB9IGZyb20gJy4uLy4uL2Zvcm1zL2Zvcm1zLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vcG9wb3Zlci5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWZFeHBhbmRNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJMb2FkaW5nTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9hZGluZy9sb2FkaW5nLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJPdXRzaWRlQ2xpY2tNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9vdXRzaWRlLWNsaWNrL291dHNpZGUtY2xpY2subW9kdWxlJztcbmltcG9ydCB7IENsckRyYWdBbmREcm9wTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZHJhZy1hbmQtZHJvcC9kcmFnLWFuZC1kcm9wLm1vZHVsZSc7XG5cbmltcG9ydCB7IERhdGFncmlkUm93RXhwYW5kQW5pbWF0aW9uIH0gZnJvbSAnLi9hbmltYXRpb24taGFjay9yb3ctZXhwYW5kLWFuaW1hdGlvbic7XG5pbXBvcnQgeyBEYXRhZ3JpZFN0cmluZ0ZpbHRlciB9IGZyb20gJy4vYnVpbHQtaW4vZmlsdGVycy9kYXRhZ3JpZC1zdHJpbmctZmlsdGVyJztcbmltcG9ydCB7IEFjdGlvbmFibGVPb21wYUxvb21wYSB9IGZyb20gJy4vY2hvY29sYXRlL2FjdGlvbmFibGUtb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IERhdGFncmlkV2lsbHlXb25rYSB9IGZyb20gJy4vY2hvY29sYXRlL2RhdGFncmlkLXdpbGx5LXdvbmthJztcbmltcG9ydCB7IEV4cGFuZGFibGVPb21wYUxvb21wYSB9IGZyb20gJy4vY2hvY29sYXRlL2V4cGFuZGFibGUtb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IENsckRhdGFncmlkIH0gZnJvbSAnLi9kYXRhZ3JpZCc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEFjdGlvbkJhciB9IGZyb20gJy4vZGF0YWdyaWQtYWN0aW9uLWJhcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEFjdGlvbk92ZXJmbG93IH0gZnJvbSAnLi9kYXRhZ3JpZC1hY3Rpb24tb3ZlcmZsb3cnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDZWxsIH0gZnJvbSAnLi9kYXRhZ3JpZC1jZWxsJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uIH0gZnJvbSAnLi9kYXRhZ3JpZC1jb2x1bW4nO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5TZXBhcmF0b3IgfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi1zZXBhcmF0b3InO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGUgfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24gfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtYnV0dG9uJztcbmltcG9ydCB7IENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGUgfSBmcm9tICcuL2RhdGFncmlkLWNvbHVtbi10b2dnbGUtdGl0bGUnO1xuaW1wb3J0IHsgRGF0YWdyaWREZXRhaWxSZWdpc3RlcmVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1kZXRhaWwtcmVnaXN0ZXJlcic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZEZpbHRlciB9IGZyb20gJy4vZGF0YWdyaWQtZmlsdGVyJztcbmltcG9ydCB7IENsckRhdGFncmlkRm9vdGVyIH0gZnJvbSAnLi9kYXRhZ3JpZC1mb290ZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRIaWRlYWJsZUNvbHVtbiB9IGZyb20gJy4vZGF0YWdyaWQtaGlkZWFibGUtY29sdW1uJztcbmltcG9ydCB7IENsckRhdGFncmlkSXRlbXMgfSBmcm9tICcuL2RhdGFncmlkLWl0ZW1zJztcbmltcG9ydCB7IENsckRhdGFncmlkSXRlbXNUcmFja0J5IH0gZnJvbSAnLi9kYXRhZ3JpZC1pdGVtcy10cmFja2J5JztcbmltcG9ydCB7IENsckRhdGFncmlkUGFnaW5hdGlvbiB9IGZyb20gJy4vZGF0YWdyaWQtcGFnaW5hdGlvbic7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFBhZ2VTaXplIH0gZnJvbSAnLi9kYXRhZ3JpZC1wYWdlLXNpemUnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRQbGFjZWhvbGRlciB9IGZyb20gJy4vZGF0YWdyaWQtcGxhY2Vob2xkZXInO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRSb3cgfSBmcm9tICcuL2RhdGFncmlkLXJvdyc7XG5pbXBvcnQgeyBDbHJEYXRhZ3JpZFJvd0RldGFpbCB9IGZyb20gJy4vZGF0YWdyaWQtcm93LWRldGFpbCc7XG5pbXBvcnQgeyBEYXRhZ3JpZENlbGxSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL2NlbGwtcmVuZGVyZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRIZWFkZXJSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL2hlYWRlci1yZW5kZXJlcic7XG5pbXBvcnQgeyBEYXRhZ3JpZE1haW5SZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL21haW4tcmVuZGVyZXInO1xuaW1wb3J0IHsgRGF0YWdyaWRSb3dSZW5kZXJlciB9IGZyb20gJy4vcmVuZGVyL3Jvdy1yZW5kZXJlcic7XG5pbXBvcnQgeyBXcmFwcGVkQ2VsbCB9IGZyb20gJy4vd3JhcHBlZC1jZWxsJztcbmltcG9ydCB7IFdyYXBwZWRDb2x1bW4gfSBmcm9tICcuL3dyYXBwZWQtY29sdW1uJztcbmltcG9ydCB7IFdyYXBwZWRSb3cgfSBmcm9tICcuL3dyYXBwZWQtcm93JztcblxuZXhwb3J0IGNvbnN0IENMUl9EQVRBR1JJRF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgLy8gQ29yZVxuICBDbHJEYXRhZ3JpZCxcbiAgQ2xyRGF0YWdyaWRBY3Rpb25CYXIsXG4gIENsckRhdGFncmlkQWN0aW9uT3ZlcmZsb3csXG4gIENsckRhdGFncmlkQ29sdW1uLFxuICBDbHJEYXRhZ3JpZENvbHVtblNlcGFyYXRvcixcbiAgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGUsXG4gIENsckRhdGFncmlkSGlkZWFibGVDb2x1bW4sXG4gIENsckRhdGFncmlkRmlsdGVyLFxuICBDbHJEYXRhZ3JpZEl0ZW1zLFxuICBDbHJEYXRhZ3JpZEl0ZW1zVHJhY2tCeSxcbiAgQ2xyRGF0YWdyaWRSb3csXG4gIENsckRhdGFncmlkUm93RGV0YWlsLFxuICBEYXRhZ3JpZERldGFpbFJlZ2lzdGVyZXIsXG4gIENsckRhdGFncmlkQ2VsbCxcbiAgQ2xyRGF0YWdyaWRGb290ZXIsXG4gIENsckRhdGFncmlkUGFnaW5hdGlvbixcbiAgQ2xyRGF0YWdyaWRQYWdlU2l6ZSxcbiAgQ2xyRGF0YWdyaWRQbGFjZWhvbGRlcixcbiAgQ2xyRGF0YWdyaWRDb2x1bW5Ub2dnbGVCdXR0b24sXG4gIENsckRhdGFncmlkQ29sdW1uVG9nZ2xlVGl0bGUsXG4gIFdyYXBwZWRDZWxsLFxuICBXcmFwcGVkQ29sdW1uLFxuICBXcmFwcGVkUm93LFxuXG4gIC8vIFJlbmRlcmVyc1xuICBEYXRhZ3JpZE1haW5SZW5kZXJlcixcbiAgRGF0YWdyaWRIZWFkZXJSZW5kZXJlcixcbiAgRGF0YWdyaWRSb3dSZW5kZXJlcixcbiAgRGF0YWdyaWRDZWxsUmVuZGVyZXIsXG5cbiAgLy8gQ2hvY29sYXRlXG4gIERhdGFncmlkV2lsbHlXb25rYSxcbiAgQWN0aW9uYWJsZU9vbXBhTG9vbXBhLFxuICBFeHBhbmRhYmxlT29tcGFMb29tcGEsXG5cbiAgLy8gQW5pbWF0aW9uIGhhY2tcbiAgRGF0YWdyaWRSb3dFeHBhbmRBbmltYXRpb24sXG5cbiAgLy8gQnVpbHQtaW4gc2hvcnRjdXRzXG4gIERhdGFncmlkU3RyaW5nRmlsdGVyLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBDbHJJY29uTW9kdWxlLFxuICAgIENsckZvcm1zTW9kdWxlLFxuICAgIEZvcm1zTW9kdWxlLFxuICAgIENsckNvbW1vblBvcG92ZXJNb2R1bGUsXG4gICAgQ2xyTG9hZGluZ01vZHVsZSxcbiAgICBDbHJPdXRzaWRlQ2xpY2tNb2R1bGUsXG4gICAgQ2xyRHJhZ0FuZERyb3BNb2R1bGUsXG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9EQVRBR1JJRF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9EQVRBR1JJRF9ESVJFQ1RJVkVTLCBDbHJJZkV4cGFuZE1vZHVsZV0sXG4gIGVudHJ5Q29tcG9uZW50czogW1dyYXBwZWRDZWxsLCBXcmFwcGVkQ29sdW1uLCBXcmFwcGVkUm93XSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRGF0YWdyaWRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25Jbml0LCBPcHRpb25hbCwgT3V0cHV0LCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLWJsb2NrJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8ZHQgY2xhc3M9XCJzdGFjay1ibG9jay1sYWJlbFwiXG4gICAgICAgIChjbGljayk9XCJ0b2dnbGVFeHBhbmQoKVwiXG4gICAgICAgIChrZXl1cC5lbnRlcik9XCJ0b2dnbGVFeHBhbmQoKVwiXG4gICAgICAgIChrZXl1cC5zcGFjZSk9XCJ0b2dnbGVFeHBhbmQoKVwiXG4gICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgIChibHVyKT1cImZvY3VzZWQgPSBmYWxzZVwiXG4gICAgICAgIFthdHRyLnJvbGVdPVwicm9sZVwiXG4gICAgICAgIFthdHRyLnRhYmluZGV4XT1cInRhYkluZGV4XCJcbiAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJhcmlhRXhwYW5kZWRcIj5cbiAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNhcmV0XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cInN0YWNrLWJsb2NrLWNhcmV0XCJcbiAgICAgICAgICAgICAgICAqbmdJZj1cImV4cGFuZGFibGVcIlxuICAgICAgICAgICAgICAgIFthdHRyLmRpcl09XCJjYXJldERpcmVjdGlvblwiXG4gICAgICAgICAgICAgICAgW2F0dHIudGl0bGVdPVwiY2FyZXRUaXRsZVwiPjwvY2xyLWljb24+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItc3RhY2stbGFiZWxcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kdD5cbiAgICA8ZGQgY2xhc3M9XCJzdGFjay1ibG9jay1jb250ZW50XCI+XG4gICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9kZD5cbiAgICA8IS0tIEZJWE1FOiByZW1vdmUgdGhpcyBzdHJpbmcgY29uY2F0ZW5hdGlvbiB3aGVuIGJvb2xlYW4gc3RhdGVzIGFyZSBzdXBwb3J0ZWQgLS0+XG4gICAgPGRpdiBbQGNvbGxhcHNlXT1cIicnKyFleHBhbmRlZFwiIGNsYXNzPVwic3RhY2stY2hpbGRyZW5cIiA+XG4gICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItc3RhY2stYmxvY2tcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIGAsXG4gIC8vIEN1c3RvbSBlbGVtZW50cyBhcmUgaW5saW5lIGJ5IGRlZmF1bHRcbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgICA6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9XG4gICAgYCxcbiAgXSxcbiAgLy8gTWFrZSBzdXJlIHRoZSBob3N0IGhhcyB0aGUgcHJvcGVyIGNsYXNzIGZvciBzdHlsaW5nIHB1cnBvc2VzXG4gIGhvc3Q6IHsgJ1tjbGFzcy5zdGFjay1ibG9ja10nOiAndHJ1ZScgfSxcbiAgYW5pbWF0aW9uczogW1xuICAgIHRyaWdnZXIoJ2NvbGxhcHNlJywgW1xuICAgICAgc3RhdGUoJ3RydWUnLCBzdHlsZSh7IGhlaWdodDogMCwgZGlzcGxheTogJ25vbmUnIH0pKSxcbiAgICAgIHRyYW5zaXRpb24oJ3RydWUgPT4gZmFsc2UnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgaGVpZ2h0OiAnKicsIGRpc3BsYXk6ICcqJyB9KSldKSxcbiAgICAgIHRyYW5zaXRpb24oJ2ZhbHNlID0+IHRydWUnLCBbc3R5bGUoeyBoZWlnaHQ6ICcqJywgZGlzcGxheTogJyonIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0JyldKSxcbiAgICBdKSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tCbG9jayBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIEBIb3N0QmluZGluZygnY2xhc3Muc3RhY2stYmxvY2stZXhwYW5kZWQnKVxuICBASW5wdXQoJ2NsclNiRXhwYW5kZWQnKVxuICBleHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBAT3V0cHV0KCdjbHJTYkV4cGFuZGVkQ2hhbmdlJykgZXhwYW5kZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuICBASG9zdEJpbmRpbmcoJ2NsYXNzLnN0YWNrLWJsb2NrLWV4cGFuZGFibGUnKVxuICBASW5wdXQoJ2NsclNiRXhwYW5kYWJsZScpXG4gIGV4cGFuZGFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2NoYW5nZWRDaGlsZHJlbjogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfZnVsbHlJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9jaGFuZ2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5zdGFjay1ibG9jay1jaGFuZ2VkJylcbiAgZ2V0IGdldENoYW5nZWRWYWx1ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlZCB8fCAodGhpcy5fY2hhbmdlZENoaWxkcmVuID4gMCAmJiAhdGhpcy5leHBhbmRlZCk7XG4gIH1cblxuICBASW5wdXQoJ2NsclNiTm90aWZ5Q2hhbmdlJylcbiAgc2V0IHNldENoYW5nZWRWYWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2NoYW5nZWQgPSB2YWx1ZTtcblxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLl9mdWxseUluaXRpYWxpemVkKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2NoYW5nZWRDaGlsZHJlbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2NoYW5nZWRDaGlsZHJlbi0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAgICogVGhpcyB3b3VsZCBiZSBtb3JlIGVmZmljaWVudCB3aXRoIEBDb250ZW50Q2hpbGRyZW4sIHdpdGggdGhlIHBhcmVudCBDbHJTdGFja0Jsb2NrXG4gICAgICogcXVlcnlpbmcgZm9yIGNoaWxkcmVuIFN0YWNrQmxvY2tzLCBidXQgdGhpcyBmZWF0dXJlIGlzIG5vdCBhdmFpbGFibGUgd2hlbiBkb3duZ3JhZGluZ1xuICAgICAqIHRoZSBjb21wb25lbnQgZm9yIEFuZ3VsYXIgMS5cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgQFNraXBTZWxmKClcbiAgICBAT3B0aW9uYWwoKVxuICAgIHByaXZhdGUgcGFyZW50OiBDbHJTdGFja0Jsb2NrLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5hZGRDaGlsZCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIC8vIGluIG9yZGVyIHRvIGFjY2VzcyB0aGUgcGFyZW50IENsclN0YWNrQmxvY2sncyBwcm9wZXJ0aWVzLFxuICAgIC8vIHRoZSBjaGlsZCBDbHJTdGFja0Jsb2NrICBoYXMgdG8gYmUgZnVsbHkgaW5pdGlhbGl6ZWQgYXQgZmlyc3QuXG4gICAgdGhpcy5fZnVsbHlJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBhZGRDaGlsZCgpOiB2b2lkIHtcbiAgICB0aGlzLmV4cGFuZGFibGUgPSB0cnVlO1xuICB9XG5cbiAgdG9nZ2xlRXhwYW5kKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmV4cGFuZGFibGUpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICB9XG4gIH1cblxuICBnZXQgY2FyZXREaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRlZCA/ICdkb3duJyA6ICdyaWdodCc7XG4gIH1cblxuICBnZXQgY2FyZXRUaXRsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGVkID8gdGhpcy5jb21tb25TdHJpbmdzLmNvbGxhcHNlIDogdGhpcy5jb21tb25TdHJpbmdzLmV4cGFuZDtcbiAgfVxuXG4gIGdldCByb2xlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuZXhwYW5kYWJsZSA/ICdidXR0b24nIDogbnVsbDtcbiAgfVxuXG4gIGdldCB0YWJJbmRleCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGUgPyAnMCcgOiBudWxsO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5vbi1mb2N1cycpXG4gIGdldCBvblN0YWNrTGFiZWxGb2N1cygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5leHBhbmRhYmxlICYmICF0aGlzLmV4cGFuZGVkICYmIHRoaXMuZm9jdXNlZDtcbiAgfVxuXG4gIGdldCBhcmlhRXhwYW5kZWQoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMuZXhwYW5kYWJsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGFuZGVkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXN0YWNrLXZpZXcnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjbHItc3RhY2staGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8ZGwgY2xhc3M9XCJzdGFjay12aWV3XCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGw+XG4gICAgYCxcbiAgLy8gQ3VzdG9tIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdC5cbiAgc3R5bGVzOiBbXG4gICAgYFxuICAgICAgICA6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9XG4gICAgYCxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tWaWV3IHtcbiAgLyoqXG4gICAqIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuXG4gICAqL1xuICBlZGl0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoJ2NsclN0YWNrU2F2ZScpIHNhdmU6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oZmFsc2UpO1xuXG4gIHByaXZhdGUgX2VkaXRNb2RlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgZWRpdGluZ0NoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgZ2V0IGVkaXRpbmcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdGFibGUgJiYgdGhpcy5fZWRpdE1vZGU7XG4gIH1cblxuICBzZXQgZWRpdGluZyh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLmVkaXRhYmxlKSB7XG4gICAgICB0aGlzLl9lZGl0TW9kZSA9IHZhbHVlO1xuICAgICAgdGhpcy5lZGl0aW5nQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aGlzLnNhdmUuZW1pdChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVuZCBvZiB1bmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmUuXG4gICAqL1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXcgfSBmcm9tICcuL3N0YWNrLXZpZXcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2staGVhZGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGg0IGNsYXNzPVwic3RhY2staGVhZGVyXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0YWNrLXRpdGxlXCI+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGFjay1hY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnN0YWNrLWFjdGlvblwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8IS0tIFVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZTogaW5saW5lIGVkaXRpbmcuIC0tPlxuICAgICAgICAgICAgICAgIDxidXR0b24gKm5nSWY9XCJzdGFja1ZpZXcuZWRpdGFibGVcIiBjbGFzcz1cInN0YWNrLWFjdGlvbiBidG4gYnRuLXNtIGJ0bi1saW5rXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwic3RhY2tWaWV3LmVkaXRpbmcgPSAhc3RhY2tWaWV3LmVkaXRpbmdcIiB0eXBlPVwiYnV0dG9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBFZGl0XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPCEtLSBFbmQgb2YgdW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlLiAtLT5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9oND5cbiAgICBgLFxuICAvLyBDdXN0b20gZWxlbWVudHMgYXJlIGlubGluZSBieSBkZWZhdWx0XG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfVxuICAgIGAsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrSGVhZGVyIHtcbiAgY29uc3RydWN0b3IocHVibGljIHN0YWNrVmlldzogQ2xyU3RhY2tWaWV3KSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuLyoqXG4gKiBVbmRvY3VtZW50ZWQgZXhwZXJpbWVudGFsIGZlYXR1cmU6IGlubGluZSBlZGl0aW5nLlxuICovXG5cbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyU3RhY2tWaWV3IH0gZnJvbSAnLi9zdGFjay12aWV3JztcblxuZXhwb3J0IGNsYXNzIFN0YWNrQ29udHJvbCB7XG4gIG1vZGVsOiBhbnk7XG4gIG1vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHN0YWNrVmlldzogQ2xyU3RhY2tWaWV3KSB7XG4gICAgLy8gTWFrZSB0aGUgQ2xyU3RhY2tWaWV3IGVkaXRhYmxlLCBzaW5jZSBpdCBjb250YWlucyBhIFN0YWNrQ29udHJvbFxuICAgIHRoaXMuc3RhY2tWaWV3LmVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnN0YWNrVmlldy5lZGl0aW5nQ2hhbmdlLnN1YnNjcmliZSgoZWRpdGluZzogYm9vbGVhbikgPT4ge1xuICAgICAgLy8gRWRpdCBtb2RlIHdhcyBjbG9zZWRcbiAgICAgIGlmICghZWRpdGluZykge1xuICAgICAgICB0aGlzLm1vZGVsQ2hhbmdlLmVtaXQodGhpcy5tb2RlbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbi8qKlxuICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAqXG4gKiBUT0RPOiBzdXBwb3J0IG1vcmUgdHlwZXMgb2YgaW5wdXRzOiBjaGVja2JveCwgcmFkaW8sIC4uLlxuICogVE9ETzogTWlycm9yIGlucHV0IGF0dHJpYnV0ZXMgZnJvbSB0aGUgaG9zdCB0byB0aGUgYWN0dWFsIGlucHV0OiBzaXplLCBtaW4sIG1heCwgcGxhY2Vob2xkZXIsIC4uLlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3RhY2tDb250cm9sIH0gZnJvbSAnLi9zdGFjay1jb250cm9sJztcbmltcG9ydCB7IENsclN0YWNrVmlldyB9IGZyb20gJy4vc3RhY2stdmlldyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1zdGFjay1pbnB1dCcsXG4gIGlucHV0czogWydtb2RlbDogY2xyTW9kZWwnLCAndHlwZSddLFxuICBvdXRwdXRzOiBbJ21vZGVsQ2hhbmdlOiBjbHJNb2RlbENoYW5nZSddLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFzdGFja1ZpZXcuZWRpdGluZ1wiPnt7bW9kZWx9fTwvc3Bhbj5cbiAgICAgICAgPGlucHV0IFt0eXBlXT1cInR5cGVcIiAqbmdJZj1cInN0YWNrVmlldy5lZGl0aW5nXCIgWyhuZ01vZGVsKV09XCJtb2RlbFwiLz5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja0lucHV0IGV4dGVuZHMgU3RhY2tDb250cm9sIHtcbiAgdHlwZTogc3RyaW5nID0gJ3RleHQnO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBzdGFja1ZpZXc6IENsclN0YWNrVmlldykge1xuICAgIHN1cGVyKHN0YWNrVmlldyk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbi8qKlxuICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAqXG4gKiBUT0RPOiBPZmZlciBhIGEgd2F5IHRvIGN1c3RvbWl6ZSB0aGUgdmFsdWUgZGlzcGxheWVkLCBwbGFpbiB2YWx1ZSBtYXkgYmUgdW5yZWFkYWJsZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN0YWNrQ29udHJvbCB9IGZyb20gJy4vc3RhY2stY29udHJvbCc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXcgfSBmcm9tICcuL3N0YWNrLXZpZXcnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItc3RhY2stc2VsZWN0JyxcbiAgaW5wdXRzOiBbJ21vZGVsOiBjbHJNb2RlbCddLFxuICBvdXRwdXRzOiBbJ21vZGVsQ2hhbmdlOiBjbHJNb2RlbENoYW5nZSddLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFzdGFja1ZpZXcuZWRpdGluZ1wiPnt7bW9kZWx9fTwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNlbGVjdFwiICpuZ0lmPVwic3RhY2tWaWV3LmVkaXRpbmdcIiA+XG4gICAgICAgICAgICA8c2VsZWN0IFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyU3RhY2tTZWxlY3QgZXh0ZW5kcyBTdGFja0NvbnRyb2wge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3RhY2tWaWV3OiBDbHJTdGFja1ZpZXcpIHtcbiAgICBzdXBlcihzdGFja1ZpZXcpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLXN0YWNrLWxhYmVsLCBjbHItc3RhY2stY29udGVudCcgfSlcbmV4cG9ydCBjbGFzcyBDbHJTdGFja1ZpZXdDdXN0b21UYWdzIHtcbiAgLy8gTm8gYmVoYXZpb3JcbiAgLy8gVGhlIG9ubHkgcHVycG9zZSBpcyB0byBcImRlY2xhcmVcIiB0aGUgdGFnIGluIEFuZ3VsYXJcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2xyU3RhY2tCbG9jayB9IGZyb20gJy4vc3RhY2stYmxvY2snO1xuaW1wb3J0IHsgQ2xyU3RhY2tIZWFkZXIgfSBmcm9tICcuL3N0YWNrLWhlYWRlcic7XG5pbXBvcnQgeyBDbHJTdGFja0lucHV0IH0gZnJvbSAnLi9zdGFjay1pbnB1dCc7XG5pbXBvcnQgeyBDbHJTdGFja1NlbGVjdCB9IGZyb20gJy4vc3RhY2stc2VsZWN0JztcbmltcG9ydCB7IENsclN0YWNrVmlldyB9IGZyb20gJy4vc3RhY2stdmlldyc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXdDdXN0b21UYWdzIH0gZnJvbSAnLi9zdGFjay12aWV3LWN1c3RvbS10YWdzJztcbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcblxuZXhwb3J0IGNvbnN0IENMUl9TVEFDS19WSUVXX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW1xuICBDbHJTdGFja1ZpZXcsXG4gIENsclN0YWNrSGVhZGVyLFxuICBDbHJTdGFja0Jsb2NrLFxuICBDbHJTdGFja1ZpZXdDdXN0b21UYWdzLFxuICAvKipcbiAgICogVW5kb2N1bWVudGVkIGV4cGVyaW1lbnRhbCBmZWF0dXJlOiBpbmxpbmUgZWRpdGluZy5cbiAgICovXG4gIENsclN0YWNrSW5wdXQsXG4gIENsclN0YWNrU2VsZWN0LFxuICAvKipcbiAgICogRW5kIG9mIHVuZG9jdW1lbnRlZCBleHBlcmltZW50YWwgZmVhdHVyZS5cbiAgICovXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9TVEFDS19WSUVXX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX1NUQUNLX1ZJRVdfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsclN0YWNrVmlld01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG4vLyBUT0RPOiBJJ2QgbGlrZSB0aGlzIHRvIGJlIGEgQ2hlY2tlZFN0YXRlIGVudW0gZm9yIHRoZSBjaGVja2JveGVzIGluIHRoZSBmdXR1cmUuXG5leHBvcnQgZW51bSBDbHJTZWxlY3RlZFN0YXRlIHtcbiAgLy8gV0FSTklORyEgVW5zZWxlY3RlZCBoYXMgdGhlIHZhbHVlIDAsXG4gIC8vIHNvIGl0J3MgYWN0dWFsbHkgdGhlIG9ubHkgb25lIHRoYXQgd2lsbCBldmFsdWF0ZSB0byBmYWxzZSBpZiBjYXN0IHRvIGEgYm9vbGVhbi5cbiAgLy8gRG9uJ3QgbWVzcyB3aXRoIHRoZSBvcmRlciFcbiAgVU5TRUxFQ1RFRCA9IDAsXG4gIFNFTEVDVEVELFxuICBJTkRFVEVSTUlOQVRFLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDbHJTZWxlY3RlZFN0YXRlIH0gZnJvbSAnLi9zZWxlY3RlZC1zdGF0ZS5lbnVtJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVHJlZU5vZGVNb2RlbDxUPiB7XG4gIHNlbGVjdGVkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDbHJTZWxlY3RlZFN0YXRlPihDbHJTZWxlY3RlZFN0YXRlLlVOU0VMRUNURUQpO1xuICBtb2RlbDogVCB8IG51bGw7XG4gIC8qXG4gICAqIElkZWFsbHksIEkgd291bGQgbGlrZSB0byB1c2UgYSBwb2x5bW9ycGhpYyB0aGlzIHR5cGUgaGVyZSB0byBlbnN1cmUgaG9tb2dlbmVpdHkgb2YgdGhlIHRyZWUsIHNvbWV0aGluZyBsaWtlOlxuICAgKiBhYnN0cmFjdCBwYXJlbnQ6IHRoaXM8VD4gfCBudWxsO1xuICAgKiBhYnN0cmFjdCBjaGlsZHJlbjogdGhpczxUPltdO1xuICAgKiBCdXQgSSdtIGhpdHRpbmcgbGltaXRhdGlvbnMgb24gdHlwZXNjcmlwdCBub3QgYWxsb3dpbmcgdGhhdCB0eXBlIGluIGNvbnN0cnVjdG9ycyBvciBzdGF0aWMgbWV0aG9kcy5cbiAgICogU28gSSdtIHJlc29ydGluZyB0byBmb3JjaW5nIG92ZXJyaWRlIHdpdGggbW9yZSBwcmVjaXNlIHR5cGVzIGJ5IG1hcmtpbmcgdGhlc2UgYWJzdHJhY3QuXG4gICAqL1xuICBhYnN0cmFjdCBwYXJlbnQ6IFRyZWVOb2RlTW9kZWw8VD4gfCBudWxsO1xuICBhYnN0cmFjdCBjaGlsZHJlbjogVHJlZU5vZGVNb2RlbDxUPltdO1xuXG4gIC8qXG4gICAqIEJlaW5nIGFibGUgdG8gcHVzaCB0aGlzIGRvd24gdG8gdGhlIFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwgd291bGQgcmVxdWlyZSB0b28gbXVjaCB3b3JrIG9uIHRoZSBhbmd1bGFyIGNvbXBvbmVudHNcbiAgICogcmlnaHQgbm93IGZvciB0aGVtIHRvIGtub3cgd2hpY2gga2luZCBvZiBtb2RlbCB0aGV5IGFyZSB1c2luZy4gU28gSSdtIGxpZnRpbmcgdGhlIHB1YmxpYyBwcm9wZXJ0aWVzIHRvIHRoaXNcbiAgICogYWJzdHJhY3QgcGFyZW50IGNsYXNzIGZvciBub3cgYW5kIHdlIGNhbiByZXZpc2l0IGl0IGxhdGVyLCB3aGVuIHdlJ3JlIG5vdCBmYWNpbmcgc3VjaCBhIGNsb3NlIGRlYWRsaW5lLlxuICAgKi9cbiAgbG9hZGluZyA9IGZhbHNlO1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gSnVzdCB0byBiZSBzYWZlXG4gICAgdGhpcy5zZWxlY3RlZC5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLy8gUHJvcGFnYXRlIGJ5IGRlZmF1bHQgd2hlbiBlYWdlciwgZG9uJ3QgcHJvcGFnYXRlIGluIHRoZSBsYXp5LWxvYWRlZCB0cmVlLlxuICBzZXRTZWxlY3RlZChzdGF0ZTogQ2xyU2VsZWN0ZWRTdGF0ZSwgcHJvcGFnYXRlVXA6IGJvb2xlYW4sIHByb3BhZ2F0ZURvd246IGJvb2xlYW4pIHtcbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuc2VsZWN0ZWQudmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZC5uZXh0KHN0YXRlKTtcbiAgICBpZiAocHJvcGFnYXRlRG93biAmJiBzdGF0ZSAhPT0gQ2xyU2VsZWN0ZWRTdGF0ZS5JTkRFVEVSTUlOQVRFICYmIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5zZXRTZWxlY3RlZChzdGF0ZSwgZmFsc2UsIHRydWUpKTtcbiAgICB9XG4gICAgaWYgKHByb3BhZ2F0ZVVwICYmIHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5fdXBkYXRlU2VsZWN0aW9uRnJvbUNoaWxkcmVuKCk7XG4gICAgfVxuICB9XG5cbiAgdG9nZ2xlU2VsZWN0aW9uKHByb3BhZ2F0ZTogYm9vbGVhbikge1xuICAgIC8vIEJvdGggdW5zZWxlY3RlZCBhbmQgaW5kZXRlcm1pbmF0ZSB0b2dnbGUgdG8gc2VsZWN0ZWRcbiAgICBjb25zdCBuZXdTdGF0ZSA9XG4gICAgICB0aGlzLnNlbGVjdGVkLnZhbHVlID09PSBDbHJTZWxlY3RlZFN0YXRlLlNFTEVDVEVEID8gQ2xyU2VsZWN0ZWRTdGF0ZS5VTlNFTEVDVEVEIDogQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRDtcbiAgICAvLyBOT1RFOiB3ZSBhbHdheXMgcHJvcGFnYXRlIHNlbGVjdGlvbiB1cCBpbiB0aGlzIG1ldGhvZCBiZWNhdXNlIGl0IGlzIG9ubHkgY2FsbGVkIHdoZW4gdGhlIHVzZXIgdGFrZXMgYW4gYWN0aW9uLlxuICAgIC8vIEl0IHNob3VsZCBuZXZlciBiZSBjYWxsZWQgZnJvbSBsaWZlY3ljbGUgaG9va3Mgb3IgYXBwLXByb3ZpZGVkIGlucHV0cy5cbiAgICB0aGlzLnNldFNlbGVjdGVkKG5ld1N0YXRlLCB0cnVlLCBwcm9wYWdhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wdXRlU2VsZWN0aW9uU3RhdGVGcm9tQ2hpbGRyZW4oKSB7XG4gICAgbGV0IG9uZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgbGV0IG9uZVVuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAvLyBVc2luZyBhIGdvb2Qgb2xkIGZvciBsb29wIHRvIGV4aXQgYXMgc29vbiBhcyB3ZSBjYW4gdGVsbCwgZm9yIGJldHRlciBwZXJmb3JtYW5jZSBvbiBsYXJnZSB0cmVlcy5cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIHN3aXRjaCAoY2hpbGQuc2VsZWN0ZWQudmFsdWUpIHtcbiAgICAgICAgY2FzZSBDbHJTZWxlY3RlZFN0YXRlLklOREVURVJNSU5BVEU6XG4gICAgICAgICAgcmV0dXJuIENsclNlbGVjdGVkU3RhdGUuSU5ERVRFUk1JTkFURTtcbiAgICAgICAgY2FzZSBDbHJTZWxlY3RlZFN0YXRlLlNFTEVDVEVEOlxuICAgICAgICAgIG9uZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAob25lVW5zZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIENsclNlbGVjdGVkU3RhdGUuSU5ERVRFUk1JTkFURTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ2xyU2VsZWN0ZWRTdGF0ZS5VTlNFTEVDVEVEOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIERlZmF1bHQgaXMgdGhlIHNhbWUgYXMgdW5zZWxlY3RlZCwgaW4gY2FzZSBhbiB1bmRlZmluZWQgc29tZWhvdyBtYWRlIGl0IGFsbCB0aGUgd2F5IGhlcmUuXG4gICAgICAgICAgb25lVW5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKG9uZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gQ2xyU2VsZWN0ZWRTdGF0ZS5JTkRFVEVSTUlOQVRFO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvbmVTZWxlY3RlZCkge1xuICAgICAgcmV0dXJuIENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9IGVsc2UgaWYgKCFvbmVVbnNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gQ2xyU2VsZWN0ZWRTdGF0ZS5TRUxFQ1RFRDtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBJbnRlcm5hbCwgYnV0IG5lZWRzIHRvIGJlIGNhbGxlZCBieSBvdGhlciBub2Rlc1xuICAgKi9cbiAgX3VwZGF0ZVNlbGVjdGlvbkZyb21DaGlsZHJlbigpIHtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuY29tcHV0ZVNlbGVjdGlvblN0YXRlRnJvbUNoaWxkcmVuKCk7XG4gICAgaWYgKG5ld1N0YXRlID09PSB0aGlzLnNlbGVjdGVkLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0ZWQubmV4dChuZXdTdGF0ZSk7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5fdXBkYXRlU2VsZWN0aW9uRnJvbUNoaWxkcmVuKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IFRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL3RyZWUtbm9kZS5tb2RlbCc7XG5cbi8qXG4gKiBBIGRlY2xhcmF0aXZlIG1vZGVsIGlzIGJ1aWx0IGJ5IHRyYXZlcnNpbmcgdGhlIEFuZ3VsYXIgY29tcG9uZW50IHRyZWUuXG4gKiBEZWNsYXJhdGl2ZSA9IFRyZWUgbm9kZSBjb21wb25lbnRzIGRpY3RhdGUgdGhlIG1vZGVsXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4gZXh0ZW5kcyBUcmVlTm9kZU1vZGVsPFQ+IHtcbiAgY29uc3RydWN0b3IocGFyZW50OiBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD4gfCBudWxsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuX2FkZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gIH1cblxuICAvLyBPdmVycmlkZSBmb3IgYSBtb3JlIHByZWNpc2UgdHlwZVxuICBwYXJlbnQ6IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbDxUPiB8IG51bGw7XG4gIGNoaWxkcmVuOiBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWw8VD5bXTtcblxuICBfYWRkQ2hpbGQoY2hpbGQ6IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbDxUPikge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gIH1cblxuICBfcmVtb3ZlQ2hpbGQoY2hpbGQ6IERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbDxUPikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5fcmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3JlY3Vyc2l2ZS10cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQ2xyUmVjdXJzaXZlRm9yT2ZDb250ZXh0IH0gZnJvbSAnLi9yZWN1cnNpdmUtZm9yLW9mJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4ge1xuICBzZWxlY3RhYmxlID0gZmFsc2U7XG4gIGVhZ2VyID0gdHJ1ZTtcbiAgcmVjdXJzaW9uOiB7XG4gICAgdGVtcGxhdGU6IFRlbXBsYXRlUmVmPENsclJlY3Vyc2l2ZUZvck9mQ29udGV4dDxUPj47XG4gICAgcm9vdDogUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPltdO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJlZUZlYXR1cmVzRmFjdG9yeTxUPihleGlzdGluZzogVHJlZUZlYXR1cmVzU2VydmljZTxUPikge1xuICByZXR1cm4gZXhpc3RpbmcgfHwgbmV3IFRyZWVGZWF0dXJlc1NlcnZpY2UoKTtcbn1cblxuZXhwb3J0IGNvbnN0IFRSRUVfRkVBVFVSRVNfUFJPVklERVIgPSB7XG4gIHByb3ZpZGU6IFRyZWVGZWF0dXJlc1NlcnZpY2UsXG4gIHVzZUZhY3Rvcnk6IHRyZWVGZWF0dXJlc0ZhY3RvcnksXG4gIC8qXG4gICAqIFRoZSBPcHRpb25hbCArIFNraXBTZWxmIHBhdHRlcm4gZW5zdXJlcyB0aGF0IGluIGNhc2Ugb2YgbmVzdGVkIGNvbXBvbmVudHMsIG9ubHkgdGhlIHJvb3Qgb25lIHdpbGxcbiAgICogaW5zdGFudGlhdGUgYSBuZXcgc2VydmljZSBhbmQgYWxsIGl0cyBjaGlsZHJlbiB3aWxsIHJldXNlIHRoZSByb290J3MgaW5zdGFuY2UuXG4gICAqIElmIHRoZXJlIGFyZSBzZXZlcmFsIHJvb3RzIChpbiB0aGlzIGNhc2UsIHNldmVyYWwgaW5kZXBlbmRlbnQgdHJlZXMgb24gYSBwYWdlKSwgZWFjaCByb290IHdpbGwgaW5zdGFudGlhdGVcbiAgICogaXRzIG93biBzZXJ2aWNlIHNvIHRoZXkgd29uJ3QgaW50ZXJmZXJlIHdpdGggb25lIGFub3RoZXIuXG4gICAqXG4gICAqIFRMO0RSIC0gT3B0aW9uYWwgKyBTa2lwU2VsZiA9IDEgaW5zdGFuY2Ugb2YgVHJlZUZlYXR1cmVzU2VydmljZSBwZXIgdHJlZS5cbiAgICovXG4gIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBUcmVlRmVhdHVyZXNTZXJ2aWNlXV0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBhbmltYXRlLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBIb3N0QmluZGluZyxcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPcHRpb25hbCxcbiAgT3V0cHV0LFxuICBTa2lwU2VsZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgRXhwYW5kIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL3Byb3ZpZGVycy9leHBhbmQnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFVOSVFVRV9JRCwgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcbmltcG9ydCB7IExvYWRpbmdMaXN0ZW5lciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy1saXN0ZW5lcic7XG5pbXBvcnQgeyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy9kZWNsYXJhdGl2ZS10cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQ2xyU2VsZWN0ZWRTdGF0ZSB9IGZyb20gJy4vbW9kZWxzL3NlbGVjdGVkLXN0YXRlLmVudW0nO1xuaW1wb3J0IHsgVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3RyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBUUkVFX0ZFQVRVUkVTX1BST1ZJREVSLCBUcmVlRmVhdHVyZXNTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZlYXR1cmVzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdHJlZS1ub2RlJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3RyZWUtbm9kZS5odG1sJyxcbiAgcHJvdmlkZXJzOiBbVU5JUVVFX0lEX1BST1ZJREVSLCBUUkVFX0ZFQVRVUkVTX1BST1ZJREVSLCBFeHBhbmQsIHsgcHJvdmlkZTogTG9hZGluZ0xpc3RlbmVyLCB1c2VFeGlzdGluZzogRXhwYW5kIH1dLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignY2hpbGROb2Rlc1N0YXRlJywgW1xuICAgICAgc3RhdGUoJ2V4cGFuZGVkJywgc3R5bGUoeyBoZWlnaHQ6ICcqJywgJ292ZXJmbG93LXknOiAnaGlkZGVuJyB9KSksXG4gICAgICBzdGF0ZSgnY29sbGFwc2VkJywgc3R5bGUoeyBoZWlnaHQ6IDAsICdvdmVyZmxvdy15JzogJ2hpZGRlbicgfSkpLFxuICAgICAgdHJhbnNpdGlvbignZXhwYW5kZWQgPD0+IGNvbGxhcHNlZCcsIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKSksXG4gICAgXSksXG4gIF0sXG4gIGhvc3Q6IHsgJ1tjbGFzcy5jbHItdHJlZS1ub2RlXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUcmVlTm9kZTxUPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgU1RBVEVTID0gQ2xyU2VsZWN0ZWRTdGF0ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KFVOSVFVRV9JRCkgcHVibGljIG5vZGVJZDogc3RyaW5nLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQFNraXBTZWxmKClcbiAgICBwYXJlbnQ6IENsclRyZWVOb2RlPFQ+LFxuICAgIHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sXG4gICAgcHVibGljIGV4cGFuZFNlcnZpY2U6IEV4cGFuZCxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncyxcbiAgICBpbmplY3RvcjogSW5qZWN0b3JcbiAgKSB7XG4gICAgaWYgKHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbikge1xuICAgICAgLy8gSSdtIGNvbXBsZXRlbHkgc3R1Y2ssIHdlIGhhdmUgdG8gaGFjayBpbnRvIHByaXZhdGUgcHJvcGVydGllcyB1bnRpbCBlaXRoZXJcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE0OTM1IG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE1OTk4XG4gICAgICAvLyBhcmUgZml4ZWRcbiAgICAgIHRoaXMuX21vZGVsID0gKDxhbnk+aW5qZWN0b3IpLnZpZXcuY29udGV4dC5jbHJNb2RlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yY2UgY2FzdCBmb3Igbm93LCBub3Qgc3VyZSBob3cgdG8gdGllIHRoZSBjb3JyZWN0IHR5cGUgaGVyZSB0byBmZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uXG4gICAgICB0aGlzLl9tb2RlbCA9IG5ldyBEZWNsYXJhdGl2ZVRyZWVOb2RlTW9kZWwocGFyZW50ID8gPERlY2xhcmF0aXZlVHJlZU5vZGVNb2RlbDxUPj5wYXJlbnQuX21vZGVsIDogbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgX21vZGVsOiBUcmVlTm9kZU1vZGVsPFQ+O1xuXG4gIGlzRXhwYW5kYWJsZSgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZXhwYW5kYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmV4cGFuZGFibGU7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRhYmxlIHx8IHRoaXMuX21vZGVsLmNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gIH1cblxuICBASW5wdXQoJ2NsclNlbGVjdGVkJylcbiAgZ2V0IHNlbGVjdGVkKCk6IENsclNlbGVjdGVkU3RhdGUgfCBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWU7XG4gIH1cbiAgc2V0IHNlbGVjdGVkKHZhbHVlOiBDbHJTZWxlY3RlZFN0YXRlIHwgYm9vbGVhbikge1xuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLnNlbGVjdGFibGUgPSB0cnVlO1xuICAgIC8vIEdyYWNlZnVsbHkgaGFuZGxlIGZhbHN5IHN0YXRlcyBsaWtlIG51bGwgb3IgdW5kZWZpbmVkIGJlY2F1c2UgaXQncyBqdXN0IGVhc2llciB0aGFuIGFuc3dlcmluZyBxdWVzdGlvbnMuXG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIHdpdGggc3RyaWN0IHR5cGluZyBvbiB0aGUgYXBwJ3Mgc2lkZSwgYnV0IGl0J3Mgbm90IHVwIHRvIHVzLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YWx1ZSA9IENsclNlbGVjdGVkU3RhdGUuVU5TRUxFQ1RFRDtcbiAgICB9XG4gICAgLy8gV2UgbWF0Y2ggYm9vbGVhbnMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgQ2xyU2VsZWN0ZWRTdGF0ZVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSA/IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQgOiBDbHJTZWxlY3RlZFN0YXRlLlVOU0VMRUNURUQ7XG4gICAgfVxuICAgIC8vIFdlIHByb3BhZ2F0ZSBvbmx5IGlmIHRoZSB0cmVlIGlzIGluIHNtYXJ0IG1vZGVcbiAgICB0aGlzLl9tb2RlbC5zZXRTZWxlY3RlZCh2YWx1ZSwgdGhpcy5mZWF0dXJlc1NlcnZpY2UuZWFnZXIsIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyKTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgYW4gYXN5bmMgRXZlbnRFbWl0dGVyIG9yIHdlIHdpbGwgdHJpZ2dlciBjaG9jb2xhdGUgZXJyb3JzIGxpa2UgaXQncyAyMDE2LlxuICBAT3V0cHV0KCdjbHJTZWxlY3RlZENoYW5nZScpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJTZWxlY3RlZFN0YXRlPih0cnVlKTtcblxuICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gIGdldCB0cmVlTm9kZVJvbGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwucGFyZW50ID8gJ3RyZWVpdGVtJyA6ICd0cmVlJztcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW11bHRpc2VsZWN0YWJsZScpXG4gIGdldCByb290QXJpYU11bHRpU2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5fbW9kZWwucGFyZW50IHx8ICF0aGlzLmZlYXR1cmVzU2VydmljZS5zZWxlY3RhYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtc2VsZWN0ZWQnKVxuICBnZXQgYXJpYVNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmZlYXR1cmVzU2VydmljZS5zZWxlY3RhYmxlID8gdGhpcy5fbW9kZWwuc2VsZWN0ZWQudmFsdWUgPT09IENsclNlbGVjdGVkU3RhdGUuU0VMRUNURUQgOiBudWxsO1xuICB9XG5cbiAgLy8gQWxsb3dzIHRoZSBjb25zdW1lciB0byBvdmVycmlkZSBvdXIgbG9naWMgZGVjaWRpbmcgaWYgYSBub2RlIGlzIGV4cGFuZGFibGUuXG4gIC8vIFVzZWZ1bCBmb3IgcmVjdXJzaXZlIHRyZWVzIHRoYXQgZG9uJ3Qgd2FudCB0byBwcmUtbG9hZCBvbmUgbGV2ZWwgYWhlYWQganVzdCB0byBrbm93IHdoaWNoIG5vZGVzIGFyZSBleHBhbmRhYmxlLlxuICBASW5wdXQoJ2NsckV4cGFuZGFibGUnKSBleHBhbmRhYmxlOiBib29sZWFuIHwgdW5kZWZpbmVkO1xuXG4gIC8vIEknbSBjYXZpbmcgb24gdGhpcywgZm9yIHRyZWUgbm9kZXMgSSB0aGluayB3ZSBjYW4gdG9sZXJhdGUgaGF2aW5nIGEgdHdvLXdheSBiaW5kaW5nIG9uIHRoZSBjb21wb25lbnRcbiAgLy8gcmF0aGVyIHRoYW4gZW5mb3JjZSB0aGUgY2xySWZFeHBhbmRlZCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBmb3IgZHluYW1pYyBjYXNlcy4gTW9zdGx5IGJlY2F1c2UgZm9yIHRoZSBzbWFydFxuICAvLyBjYXNlLCB5b3UgY2FuJ3QgdXNlIGEgc3RydWN0dXJhbCBkaXJlY3RpdmUsIGl0IHdvdWxkIG5lZWQgdG8gZ28gb24gYW4gbmctY29udGFpbmVyLlxuICBASW5wdXQoJ2NsckV4cGFuZGVkJylcbiAgZ2V0IGV4cGFuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kZWQ7XG4gIH1cbiAgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5leHBhbmRTZXJ2aWNlLmV4cGFuZGVkID0gdmFsdWU7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLl9tb2RlbC5zZWxlY3RlZC5zdWJzY3JpYmUodmFsdWUgPT4gdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHZhbHVlKSkpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKHZhbHVlID0+IHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSkpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX21vZGVsLmRlc3Ryb3koKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChzdWIgPT4gc3ViLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRSRUVfRkVBVFVSRVNfUFJPVklERVIsIFRyZWVGZWF0dXJlc1NlcnZpY2UgfSBmcm9tICcuL3RyZWUtZmVhdHVyZXMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10cmVlJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPGNsci1yZWN1cnNpdmUtY2hpbGRyZW4gKm5nSWY9XCJmZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY2hpbGRyZW5dPVwiZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbi5yb290XCI+PC9jbHItcmVjdXJzaXZlLWNoaWxkcmVuPlxuICBgLFxuICBwcm92aWRlcnM6IFtUUkVFX0ZFQVRVUkVTX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVHJlZTxUPiB7XG4gIC8vIFRoaXMgY29tcG9uZW50IGNhbiBhbHNvIGJlIHVzZWQganVzdCB0byBkZWNsYXJlIHByb3ZpZGVycyBvbmNlIGZvciB0cmVlcyB3aXRoIG11bHRpcGxlIHJvb3Qgbm9kZXMuXG5cbiAgY29uc3RydWN0b3IocHVibGljIGZlYXR1cmVzU2VydmljZTogVHJlZUZlYXR1cmVzU2VydmljZTxUPikge31cblxuICBASW5wdXQoJ2NsckxhenknKVxuICBzZXQgbGF6eSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZmVhdHVyZXNTZXJ2aWNlLmVhZ2VyID0gIXZhbHVlO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbi8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHBlb3BsZSBjYW4gZ2l2ZSB1cyBudWxsIG9yIHVuZGVmaW5lZCBjaGlsZHJlbiBldmVuIGlmIHRoZXkgcnVuIHN0cmljdCB0eXBlIGNoZWNraW5nLlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5leHBvcnQgdHlwZSBBc3luY0FycmF5PFQ+ID1cbiAgfCBUW11cbiAgfCBudWxsXG4gIHwgdW5kZWZpbmVkXG4gIHwgUHJvbWlzZTxUW10gfCBudWxsIHwgdW5kZWZpbmVkPlxuICB8IE9ic2VydmFibGU8VFtdIHwgbnVsbCB8IHVuZGVmaW5lZD47XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2U8VD4obzogQXN5bmNBcnJheTxUPik6IG8gaXMgUHJvbWlzZTxUW10+IHtcbiAgLy8gU2hhbWVsZXNzbHkgY29waWVkIGZyb20gZXZlcnkgb3Blbi1zb3VyY2UgcHJvamVjdCBvdXQgdGhlcmUuXG4gIHJldHVybiBvICYmIHR5cGVvZiAoPGFueT5vKS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBpc09ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBUcmVlTm9kZU1vZGVsIH0gZnJvbSAnLi90cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQXN5bmNBcnJheSwgaXNQcm9taXNlIH0gZnJvbSAnLi9hc3luYy1hcnJheSc7XG5cbi8qXG4gKiBBIHJlY3Vyc2l2ZSBtb2RlbCBpcyBidWlsdCByZWNlaXZlZCBmcm9tIHRoZSBhcHAgYW5kIHRyYXZlcnNlZCB0byBjcmVhdGUgdGhlIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50cy5cbiAqIFJlY3Vyc2l2ZSA9IE1vZGVsIGRpY3RhdGVzIHRoZSB0cmVlIG5vZGUgY29tcG9uZW50c1xuICovXG5leHBvcnQgY2xhc3MgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPiBleHRlbmRzIFRyZWVOb2RlTW9kZWw8VD4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBtb2RlbDogVCxcbiAgICBwYXJlbnQ6IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWw8VD4gfCBudWxsLFxuICAgIHByaXZhdGUgZ2V0Q2hpbGRyZW46IChub2RlOiBUKSA9PiBBc3luY0FycmF5PFQ+IHwgdW5kZWZpbmVkXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB9XG5cbiAgcGFyZW50OiBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsPFQ+IHwgbnVsbDtcblxuICBwcml2YXRlIGNoaWxkcmVuRmV0Y2hlZCA9IGZhbHNlO1xuXG4gIGZldGNoQ2hpbGRyZW4oKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW5GZXRjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXN5bmNDaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4odGhpcy5tb2RlbCk7XG4gICAgaWYgKGlzUHJvbWlzZShhc3luY0NoaWxkcmVuKSkge1xuICAgICAgdGhpcy5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgIGFzeW5jQ2hpbGRyZW4udGhlbihyYXcgPT4ge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IHRoaXMud3JhcENoaWxkcmVuKHJhdyk7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc09ic2VydmFibGUoYXN5bmNDaGlsZHJlbikpIHtcbiAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGFzeW5jQ2hpbGRyZW4uc3Vic2NyaWJlKHJhdyA9PiB7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gdGhpcy53cmFwQ2hpbGRyZW4ocmF3KTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGFzeW5jQ2hpbGRyZW4pIHtcbiAgICAgIC8vIFN5bmNocm9ub3VzIGNhc2VcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gdGhpcy53cmFwQ2hpbGRyZW4oYXN5bmNDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgfVxuICAgIHRoaXMuY2hpbGRyZW5GZXRjaGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgd3JhcENoaWxkcmVuKHJhd01vZGVsczogVFtdKSB7XG4gICAgcmV0dXJuIHJhd01vZGVscy5tYXAobSA9PiBuZXcgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbChtLCB0aGlzLCB0aGlzLmdldENoaWxkcmVuKSk7XG4gIH1cblxuICBwcml2YXRlIF9jaGlsZHJlbjogUmVjdXJzaXZlVHJlZU5vZGVNb2RlbDxUPltdID0gW107XG4gIGdldCBjaGlsZHJlbigpOiBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsPFQ+W10ge1xuICAgIHRoaXMuZmV0Y2hDaGlsZHJlbigpO1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgfVxuICBzZXQgY2hpbGRyZW4odmFsdWU6IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWw8VD5bXSkge1xuICAgIHRoaXMuX2NoaWxkcmVuID0gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25DaGFuZ2VzLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHJlZUZlYXR1cmVzU2VydmljZSB9IGZyb20gJy4vdHJlZS1mZWF0dXJlcy5zZXJ2aWNlJztcbmltcG9ydCB7IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy9yZWN1cnNpdmUtdHJlZS1ub2RlLm1vZGVsJztcbmltcG9ydCB7IFRyZWVOb2RlTW9kZWwgfSBmcm9tICcuL21vZGVscy90cmVlLW5vZGUubW9kZWwnO1xuaW1wb3J0IHsgQXN5bmNBcnJheSB9IGZyb20gJy4vbW9kZWxzL2FzeW5jLWFycmF5JztcblxuZXhwb3J0IGludGVyZmFjZSBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQ8VD4ge1xuICAkaW1wbGljaXQ6IFQ7XG4gIGNsck1vZGVsOiBUcmVlTm9kZU1vZGVsPFQ+O1xufVxuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUmVjdXJzaXZlRm9yXVtjbHJSZWN1cnNpdmVGb3JPZl0nIH0pXG5leHBvcnQgY2xhc3MgQ2xyUmVjdXJzaXZlRm9yT2Y8VD4gaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQ8VD4+LFxuICAgIHByaXZhdGUgZmVhdHVyZXNTZXJ2aWNlOiBUcmVlRmVhdHVyZXNTZXJ2aWNlPFQ+XG4gICkge31cblxuICAvLyBUT0RPOiBhY2NlcHQgTmdJdGVyYWJsZTxUPlxuICBASW5wdXQoJ2NsclJlY3Vyc2l2ZUZvck9mJykgbm9kZXM6IFQgfCBUW107XG5cbiAgLy8gVE9ETzogYWNjZXB0IE5nSXRlcmFibGU8VD4gcmV0dXJuIHR5cGVcbiAgQElucHV0KCdjbHJSZWN1cnNpdmVGb3JHZXRDaGlsZHJlbicpIGdldENoaWxkcmVuOiAobm9kZTogVCkgPT4gQXN5bmNBcnJheTxUPjtcblxuICAvLyBJJ20gdXNpbmcgT25DaGFuZ2VzIGluc3RlYWQgb2YgT25Jbml0IHRvIGVhc2lseSBrZWVwIHVwIHRvIGRhdGUgd2l0aCBkeW5hbWljIHRyZWVzLiBNYXliZSBvcHRpbWl6YWJsZSBsYXRlci5cbiAgbmdPbkNoYW5nZXMoKSB7XG4gICAgbGV0IHdyYXBwZWQ6IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWw8VD5bXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLm5vZGVzKSkge1xuICAgICAgd3JhcHBlZCA9IHRoaXMubm9kZXMubWFwKG5vZGUgPT4gbmV3IFJlY3Vyc2l2ZVRyZWVOb2RlTW9kZWwobm9kZSwgbnVsbCwgdGhpcy5nZXRDaGlsZHJlbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVkID0gW25ldyBSZWN1cnNpdmVUcmVlTm9kZU1vZGVsKHRoaXMubm9kZXMsIG51bGwsIHRoaXMuZ2V0Q2hpbGRyZW4pXTtcbiAgICB9XG4gICAgdGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uID0ge1xuICAgICAgdGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG4gICAgICByb290OiB3cmFwcGVkLFxuICAgIH07XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBFeHBhbmQgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvcHJvdmlkZXJzL2V4cGFuZCc7XG5pbXBvcnQgeyBUcmVlRmVhdHVyZXNTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWZlYXR1cmVzLnNlcnZpY2UnO1xuaW1wb3J0IHsgVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3RyZWUtbm9kZS5tb2RlbCc7XG5pbXBvcnQgeyBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQgfSBmcm9tICcuL3JlY3Vyc2l2ZS1mb3Itb2YnO1xuaW1wb3J0IHsgUmVjdXJzaXZlVHJlZU5vZGVNb2RlbCB9IGZyb20gJy4vbW9kZWxzL3JlY3Vyc2l2ZS10cmVlLW5vZGUubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItcmVjdXJzaXZlLWNoaWxkcmVuJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwic2hvdWxkUmVuZGVyKClcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNoaWxkIG9mIHBhcmVudD8uY2hpbGRyZW4gfHwgY2hpbGRyZW5cIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImZlYXR1cmVzU2VydmljZS5yZWN1cnNpb24udGVtcGxhdGU7IGNvbnRleHQ6IGdldENvbnRleHQoY2hpbGQpXCI+PC9uZy1jb250YWluZXI+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgYCxcbn0pXG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCwgZG8gbm90IGV4cG9ydCFcbiAqIFRoaXMgaXMgcGFydCBvZiB0aGUgaGFjayB0byBnZXQgYXJvdW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzE1OTk4XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWN1cnNpdmVDaGlsZHJlbjxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmZWF0dXJlc1NlcnZpY2U6IFRyZWVGZWF0dXJlc1NlcnZpY2U8VD4sIEBPcHRpb25hbCgpIHByaXZhdGUgZXhwYW5kU2VydmljZTogRXhwYW5kKSB7XG4gICAgaWYgKGV4cGFuZFNlcnZpY2UgJiYgZmVhdHVyZXNTZXJ2aWNlLnJlY3Vyc2lvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmV4cGFuZFNlcnZpY2UuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICAgIC8vIE9uY2UgYWdhaW4sIEknbSBzdXJlIHdlIGNhbiBmaW5kIGEgd2F5IHRvIGF2b2lkIHRoaXMgY2FzdGluZyBieSB0eXBpbmcgZXZlcnkgY29tcG9uZW50IGluIGEgd2F5IHRoYXRcbiAgICAgICAgICAvLyBsZXRzIHVzIHVzZSB0aGUgbW9yZSBzcGVjaWZpYyBtb2RlbCBjbGFzc2VzIGRlcGVuZGluZyBvbiB0aGUgdXNlIG9mICpjbHJSZWN1cnNpdmVGb3JPZiBvciBub3QuXG4gICAgICAgICAgLy8gQnV0IGl0IHdvdWxkIHRha2UgdGltZSwgd2hpY2ggd2UgZG9uJ3QgaGF2ZSByaWdodCBub3cuXG4gICAgICAgICAgKDxSZWN1cnNpdmVUcmVlTm9kZU1vZGVsPFQ+PnRoaXMucGFyZW50KS5mZXRjaENoaWxkcmVuKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNob3VsZFJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5mZWF0dXJlc1NlcnZpY2UucmVjdXJzaW9uICYmXG4gICAgICAvLyBJbiB0aGUgc21hcnQgY2FzZSwgd2UgZWFnZXJseSByZW5kZXIgYWxsIHRoZSByZWN1cnNpdmUgY2hpbGRyZW5cbiAgICAgIC8vIHRvIG1ha2Ugc3VyZSB0d28td2F5IGJpbmRpbmdzIGZvciBzZWxlY3Rpb24gYXJlIGF2YWlsYWJsZS5cbiAgICAgIC8vIFRoZXkgd2lsbCBiZSBoaWRkZW4gd2l0aCBDU1MgYnkgdGhlIHBhcmVudC5cbiAgICAgICh0aGlzLmZlYXR1cmVzU2VydmljZS5lYWdlciB8fCAhdGhpcy5leHBhbmRTZXJ2aWNlIHx8IHRoaXMuZXhwYW5kU2VydmljZS5leHBhbmRlZClcbiAgICApO1xuICB9XG5cbiAgLy8gT2ZmZXJpbmcgdGhlIG9wdGlvbiB0byBlaXRoZXIgZ2l2ZSB0aGUgcGFyZW50IG5vZGUgdG8gcmVjdXJzZSBwb3RlbnRpYWxseSBsYXppbHksXG4gIC8vIG9yIGRpcmVjdGx5IHRoZSBsaXN0IG9mIGNoaWxkcmVuIHRvIGRpc3BsYXkuXG4gIEBJbnB1dCgncGFyZW50JykgcGFyZW50OiBUcmVlTm9kZU1vZGVsPFQ+O1xuICBASW5wdXQoJ2NoaWxkcmVuJykgY2hpbGRyZW46IFRyZWVOb2RlTW9kZWw8VD5bXTtcblxuICBnZXRDb250ZXh0KG5vZGU6IFRyZWVOb2RlTW9kZWw8VD4pOiBDbHJSZWN1cnNpdmVGb3JPZkNvbnRleHQ8VD4ge1xuICAgIHJldHVybiB7XG4gICAgICAkaW1wbGljaXQ6IG5vZGUubW9kZWwsXG4gICAgICBjbHJNb2RlbDogbm9kZSxcbiAgICB9O1xuICB9XG5cbiAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTG9hZGluZ01vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWZFeHBhbmRNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvaWYtZXhwYW5kLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJUcmVlTm9kZSB9IGZyb20gJy4vdHJlZS1ub2RlJztcbmltcG9ydCB7IENsclRyZWUgfSBmcm9tICcuL3RyZWUnO1xuaW1wb3J0IHsgQ2xyUmVjdXJzaXZlRm9yT2YgfSBmcm9tICcuL3JlY3Vyc2l2ZS1mb3Itb2YnO1xuaW1wb3J0IHsgUmVjdXJzaXZlQ2hpbGRyZW4gfSBmcm9tICcuL3JlY3Vyc2l2ZS1jaGlsZHJlbic7XG5cbmV4cG9ydCBjb25zdCBDTFJfVFJFRV9WSUVXX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsclRyZWUsIENsclRyZWVOb2RlLCBDbHJSZWN1cnNpdmVGb3JPZl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckljb25Nb2R1bGUsIENsckxvYWRpbmdNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfVFJFRV9WSUVXX0RJUkVDVElWRVMsIFJlY3Vyc2l2ZUNoaWxkcmVuXSxcbiAgZXhwb3J0czogW0NMUl9UUkVFX1ZJRVdfRElSRUNUSVZFUywgQ2xySWZFeHBhbmRNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUcmVlVmlld01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyRGF0YWdyaWRNb2R1bGUgfSBmcm9tICcuL2RhdGFncmlkL2RhdGFncmlkLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTdGFja1ZpZXdNb2R1bGUgfSBmcm9tICcuL3N0YWNrLXZpZXcvc3RhY2stdmlldy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVHJlZVZpZXdNb2R1bGUgfSBmcm9tICcuL3RyZWUtdmlldy90cmVlLXZpZXcubW9kdWxlJztcblxuQE5nTW9kdWxlKHsgZXhwb3J0czogW0NsckRhdGFncmlkTW9kdWxlLCBDbHJTdGFja1ZpZXdNb2R1bGUsIENsclRyZWVWaWV3TW9kdWxlXSB9KVxuZXhwb3J0IGNsYXNzIENsckRhdGFNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsLCBTa2lwU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUm9vdERyb3Bkb3duU2VydmljZSB7XG4gIHByaXZhdGUgX2NoYW5nZXM6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIGdldCBjaGFuZ2VzKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgY2xvc2VNZW51cygpOiB2b2lkIHtcbiAgICB0aGlzLl9jaGFuZ2VzLm5leHQoZmFsc2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbHJSb290RHJvcGRvd25GYWN0b3J5KGV4aXN0aW5nOiBSb290RHJvcGRvd25TZXJ2aWNlKSB7XG4gIHJldHVybiBleGlzdGluZyB8fCBuZXcgUm9vdERyb3Bkb3duU2VydmljZSgpO1xufVxuXG5leHBvcnQgY29uc3QgUk9PVF9EUk9QRE9XTl9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogUm9vdERyb3Bkb3duU2VydmljZSxcbiAgdXNlRmFjdG9yeTogY2xyUm9vdERyb3Bkb3duRmFjdG9yeSxcbiAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIFJvb3REcm9wZG93blNlcnZpY2VdXSxcbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPcHRpb25hbCwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbmltcG9ydCB7IFJPT1RfRFJPUERPV05fUFJPVklERVIsIFJvb3REcm9wZG93blNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9kcm9wZG93bi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWRyb3Bkb3duJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZHJvcGRvd25dJzogJ3RydWUnLFxuICAgIC8vIEZJWE1FOiByZW1vdmUgdGhpcyBhcyBzb29uIGFzIHdlIHN0b3Agc3VwcG9ydGluZyB0aGlzIG9sZCA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiPiBzeW50YXhcbiAgICAnW2NsYXNzLm9wZW5dJzogJ2lmT3BlblNlcnZpY2Uub3BlbicsXG4gIH0sXG4gIHByb3ZpZGVyczogW0lmT3BlblNlcnZpY2UsIFJPT1RfRFJPUERPV05fUFJPVklERVIsIHsgcHJvdmlkZTogUE9QT1ZFUl9IT1NUX0FOQ0hPUiwgdXNlRXhpc3Rpbmc6IEVsZW1lbnRSZWYgfV0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyb3Bkb3duIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBTa2lwU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBwdWJsaWMgcGFyZW50OiBDbHJEcm9wZG93bixcbiAgICBwdWJsaWMgaWZPcGVuU2VydmljZTogSWZPcGVuU2VydmljZSxcbiAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgZHJvcGRvd25TZXJ2aWNlOiBSb290RHJvcGRvd25TZXJ2aWNlXG4gICkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKGRyb3Bkb3duU2VydmljZS5jaGFuZ2VzLnN1YnNjcmliZSh2YWx1ZSA9PiAodGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSB2YWx1ZSkpKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChpZk9wZW5TZXJ2aWNlLm9wZW5DaGFuZ2Uuc3Vic2NyaWJlKHZhbHVlID0+IHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpKSk7XG4gIH1cblxuICBASW5wdXQoJ2NsckNsb3NlTWVudU9uSXRlbUNsaWNrJykgaXNNZW51Q2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiBzdWIudW5zdWJzY3JpYmUoKSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRyb3Bkb3duIH0gZnJvbSAnLi9kcm9wZG93bic7XG5pbXBvcnQgeyBSb290RHJvcGRvd25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvZHJvcGRvd24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJEcm9wZG93bkl0ZW1dJywgaG9zdDogeyAnW2NsYXNzLmRyb3Bkb3duLWl0ZW1dJzogJ3RydWUnIH0gfSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93bkl0ZW0gaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBkcm9wZG93bjogQ2xyRHJvcGRvd24sXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9kcm9wZG93blNlcnZpY2U6IFJvb3REcm9wZG93blNlcnZpY2UsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyXG4gICkge31cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5lbC5uYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoKSA9PiB0aGlzLm9uRHJvcGRvd25JdGVtQ2xpY2soKSk7XG4gIH1cblxuICBvbkRyb3Bkb3duSXRlbUNsaWNrKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRyb3Bkb3duLmlzTWVudUNsb3NhYmxlICYmICF0aGlzLmVsLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICB0aGlzLl9kcm9wZG93blNlcnZpY2UuY2xvc2VNZW51cygpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdG9yLCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBYnN0cmFjdFBvcG92ZXIgfSBmcm9tICcuLi9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1kcm9wZG93bi1tZW51JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRyb3Bkb3duLW1lbnVdJzogJ3RydWUnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJEcm9wZG93bk1lbnUgZXh0ZW5kcyBBYnN0cmFjdFBvcG92ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KFBPUE9WRVJfSE9TVF9BTkNIT1IpXG4gICAgcGFyZW50SG9zdDogRWxlbWVudFJlZixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgbmVzdGVkOiBDbHJEcm9wZG93bk1lbnVcbiAgKSB7XG4gICAgaWYgKCFwYXJlbnRIb3N0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1kcm9wZG93bi1tZW51IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLWRyb3Bkb3duJyk7XG4gICAgfVxuICAgIHN1cGVyKGluamVjdG9yLCBwYXJlbnRIb3N0KTtcbiAgICBpZiAoIW5lc3RlZCkge1xuICAgICAgLy8gRGVmYXVsdCBwb3NpdGlvbmluZyBmb3Igbm9ybWFsIGRyb3Bkb3duIGlzIGJvdHRvbS1sZWZ0XG4gICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX0xFRlQ7XG4gICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IHBvc2l0aW9uaW5nIGZvciBuZXN0ZWQgZHJvcGRvd24gaXMgcmlnaHQtdG9wXG4gICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICB9XG4gICAgdGhpcy5wb3BvdmVyT3B0aW9ucy5hbGxvd011bHRpcGxlT3BlbiA9IHRydWU7XG4gICAgdGhpcy5jbG9zZU9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9zaXRpb24nKVxuICBzZXQgcG9zaXRpb24ocG9zaXRpb246IHN0cmluZykge1xuICAgIC8vIHNldCB0aGUgcG9wb3ZlciB2YWx1ZXMgYmFzZWQgb24gbWVudSBwb3NpdGlvblxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfUklHSFQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fUklHSFQ7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9MRUZUO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0LXRvcCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuTEVGVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQtYm90dG9tJzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX0JPVFRPTTtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX0JPVFRPTTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0LXRvcCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5SSUdIVF9UT1A7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdC1ib3R0b20nOlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuTEVGVF9CT1RUT007XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fTEVGVDtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuaW1wb3J0IHsgQ2xyRHJvcGRvd24gfSBmcm9tICcuL2Ryb3Bkb3duJztcblxuQERpcmVjdGl2ZSh7XG4gIC8vIFdlIHN1cHBvcnQgYm90aCBzZWxlY3RvcnMgZm9yIGxlZ2FjeSByZWFzb25zXG4gIHNlbGVjdG9yOiAnW2NsckRyb3Bkb3duVHJpZ2dlcl0sW2NsckRyb3Bkb3duVG9nZ2xlXScsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmRyb3Bkb3duLXRvZ2dsZV0nOiAnaXNSb290TGV2ZWxUb2dnbGUnLFxuICAgICdbY2xhc3MuZHJvcGRvd24taXRlbV0nOiAnIWlzUm9vdExldmVsVG9nZ2xlJyxcbiAgICAnW2NsYXNzLmV4cGFuZGFibGVdJzogJyFpc1Jvb3RMZXZlbFRvZ2dsZScsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ2FjdGl2ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckRyb3Bkb3duVHJpZ2dlciB7XG4gIHB1YmxpYyBpc1Jvb3RMZXZlbFRvZ2dsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoZHJvcGRvd246IENsckRyb3Bkb3duLCBwcml2YXRlIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UpIHtcbiAgICAvLyBpZiB0aGUgY29udGFpbmluZyBkcm9wZG93biBoYXMgYSBwYXJlbnQsIHRoZW4gdGhpcyBpcyBub3QgdGhlIHJvb3QgbGV2ZWwgb25lXG4gICAgaWYgKGRyb3Bkb3duLnBhcmVudCkge1xuICAgICAgdGhpcy5pc1Jvb3RMZXZlbFRvZ2dsZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICBvbkRyb3Bkb3duVHJpZ2dlckNsaWNrKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsckRyb3Bkb3duIH0gZnJvbSAnLi9kcm9wZG93bic7XG5pbXBvcnQgeyBDbHJEcm9wZG93bkl0ZW0gfSBmcm9tICcuL2Ryb3Bkb3duLWl0ZW0nO1xuaW1wb3J0IHsgQ2xyRHJvcGRvd25NZW51IH0gZnJvbSAnLi9kcm9wZG93bi1tZW51JztcbmltcG9ydCB7IENsckRyb3Bkb3duVHJpZ2dlciB9IGZyb20gJy4vZHJvcGRvd24tdHJpZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBDTFJfRFJPUERPV05fRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyRHJvcGRvd24sIENsckRyb3Bkb3duTWVudSwgQ2xyRHJvcGRvd25UcmlnZ2VyLCBDbHJEcm9wZG93bkl0ZW1dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX0RST1BET1dOX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbQ0xSX0RST1BET1dOX0RJUkVDVElWRVMsIENsckNvbmRpdGlvbmFsTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyRHJvcGRvd25Nb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuLy8gQFRPRE8gTWFrZSB0aGlzIGFuIGVudW1cbmV4cG9ydCBjb25zdCBBTEVSVF9UWVBFUzogc3RyaW5nW10gPSBbJ2luZm8nLCAnd2FybmluZycsICdkYW5nZXInLCAnc3VjY2VzcyddO1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFsZXJ0SW5mb09iamVjdCB9IGZyb20gJy4uL3V0aWxzL2FsZXJ0LWluZm8tb2JqZWN0JztcbmltcG9ydCB7IEFMRVJUX1RZUEVTIH0gZnJvbSAnLi4vdXRpbHMvYWxlcnQtdHlwZXMnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEFsZXJ0SWNvbkFuZFR5cGVzU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5ncykge31cblxuICBwcml2YXRlIGRlZmF1bHRJY29uU2hhcGUgPSAnaW5mby1jaXJjbGUnO1xuICBwcml2YXRlIF9hbGVydEljb25TaGFwZSA9ICcnO1xuICBwcml2YXRlIF9hbGVydFR5cGUgPSAnaW5mbyc7XG5cbiAgZ2V0IGFsZXJ0VHlwZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9hbGVydFR5cGU7XG4gIH1cbiAgc2V0IGFsZXJ0VHlwZSh2YWw6IHN0cmluZykge1xuICAgIGlmIChBTEVSVF9UWVBFUy5pbmRleE9mKHZhbCkgPiAtMSkge1xuICAgICAgdGhpcy5fYWxlcnRUeXBlID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhbGVydEljb25TaGFwZSgpOiBzdHJpbmcge1xuICAgIGlmICgnJyA9PT0gdGhpcy5fYWxlcnRJY29uU2hhcGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmljb25JbmZvRnJvbVR5cGUodGhpcy5fYWxlcnRUeXBlKS5zaGFwZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FsZXJ0SWNvblNoYXBlO1xuICB9XG4gIHNldCBhbGVydEljb25TaGFwZSh2YWw6IHN0cmluZykge1xuICAgIGlmICghdmFsKSB7XG4gICAgICB0aGlzLl9hbGVydEljb25TaGFwZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodmFsICE9PSB0aGlzLl9hbGVydEljb25TaGFwZSkge1xuICAgICAgdGhpcy5fYWxlcnRJY29uU2hhcGUgPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGFsZXJ0SWNvblRpdGxlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuaWNvbkluZm9Gcm9tVHlwZSh0aGlzLl9hbGVydFR5cGUpLnRpdGxlO1xuICB9XG5cbiAgcHVibGljIGljb25JbmZvRnJvbVR5cGUodHlwZTogc3RyaW5nKTogQWxlcnRJbmZvT2JqZWN0IHtcbiAgICBjb25zdCByZXR1cm5PYmogPSB7IHNoYXBlOiAnJywgY3NzQ2xhc3M6ICcnLCB0aXRsZTogJycgfTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgIHJldHVybk9iai5zaGFwZSA9ICdleGNsYW1hdGlvbi10cmlhbmdsZSc7XG4gICAgICAgIHJldHVybk9iai5jc3NDbGFzcyA9ICdhbGVydC13YXJuaW5nJztcbiAgICAgICAgcmV0dXJuT2JqLnRpdGxlID0gdGhpcy5jb21tb25TdHJpbmdzLndhcm5pbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGFuZ2VyJzpcbiAgICAgICAgcmV0dXJuT2JqLnNoYXBlID0gJ2V4Y2xhbWF0aW9uLWNpcmNsZSc7XG4gICAgICAgIHJldHVybk9iai5jc3NDbGFzcyA9ICdhbGVydC1kYW5nZXInO1xuICAgICAgICByZXR1cm5PYmoudGl0bGUgPSB0aGlzLmNvbW1vblN0cmluZ3MuZGFuZ2VyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxuICAgICAgICByZXR1cm5PYmouc2hhcGUgPSAnY2hlY2stY2lyY2xlJztcbiAgICAgICAgcmV0dXJuT2JqLmNzc0NsYXNzID0gJ2FsZXJ0LXN1Y2Nlc3MnO1xuICAgICAgICByZXR1cm5PYmoudGl0bGUgPSB0aGlzLmNvbW1vblN0cmluZ3Muc3VjY2VzcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm5PYmouc2hhcGUgPSB0aGlzLmRlZmF1bHRJY29uU2hhcGU7XG4gICAgICAgIHJldHVybk9iai5jc3NDbGFzcyA9ICdhbGVydC1pbmZvJztcbiAgICAgICAgcmV0dXJuT2JqLnRpdGxlID0gdGhpcy5jb21tb25TdHJpbmdzLmluZm87XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXR1cm5PYmo7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IENsckFsZXJ0IH0gZnJvbSAnLi4vYWxlcnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTXVsdGlBbGVydFNlcnZpY2Uge1xuICBwcml2YXRlIGFsbEFsZXJ0czogUXVlcnlMaXN0PENsckFsZXJ0PiA9IG5ldyBRdWVyeUxpc3Q8Q2xyQWxlcnQ+KCk7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX2N1cnJlbnQgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgT2JzZXJ2YWJsZSB0aGF0IGxldHMgb3RoZXIgY2xhc3NlcyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgKi9cbiAgcHJpdmF0ZSBfY2hhbmdlID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICBwdWJsaWMgZ2V0IGNoYW5nZXMoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gIH1cbiAgc2V0IGN1cnJlbnQoaW5kZXg6IG51bWJlcikge1xuICAgIGlmIChpbmRleCAhPT0gdGhpcy5fY3VycmVudCkge1xuICAgICAgdGhpcy5fY3VycmVudCA9IGluZGV4O1xuICAgICAgdGhpcy5fY2hhbmdlLm5leHQoaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhY3RpdmVBbGVydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsQWxlcnRzLmZpbHRlcihhbGVydCA9PiAhYWxlcnQuX2Nsb3NlZCk7XG4gIH1cblxuICBnZXQgY3VycmVudEFsZXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUFsZXJ0c1t0aGlzLmN1cnJlbnRdO1xuICB9XG5cbiAgc2V0IGN1cnJlbnRBbGVydChhbGVydDogQ2xyQWxlcnQpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmFjdGl2ZUFsZXJ0cy5pbmRleE9mKGFsZXJ0KTtcbiAgfVxuXG4gIGdldCBjb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVBbGVydHMubGVuZ3RoO1xuICB9XG5cbiAgbWFuYWdlKGFsZXJ0czogUXVlcnlMaXN0PENsckFsZXJ0Pikge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgdGhpcy5hbGxBbGVydHMgPSBhbGVydHM7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmFsbEFsZXJ0cy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50ID49IHRoaXMuYWxsQWxlcnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBNYXRoLm1heCgwLCB0aGlzLmFsbEFsZXJ0cy5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50ID09PSB0aGlzLmFjdGl2ZUFsZXJ0cy5sZW5ndGggLSAxID8gMCA6IHRoaXMuY3VycmVudCArIDE7XG4gIH1cblxuICBwcmV2aW91cygpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVBbGVydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudCA9PT0gMCA/IHRoaXMuYWN0aXZlQWxlcnRzLmxlbmd0aCAtIDEgOiB0aGlzLmN1cnJlbnQgLSAxO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5wcmV2aW91cygpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPcHRpb25hbCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8vIHByb3ZpZGVyc1xuaW1wb3J0IHsgQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaWNvbi1hbmQtdHlwZXMuc2VydmljZSc7XG5pbXBvcnQgeyBNdWx0aUFsZXJ0U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL211bHRpLWFsZXJ0LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWFsZXJ0JyxcbiAgcHJvdmlkZXJzOiBbQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlXSxcbiAgdGVtcGxhdGVVcmw6ICcuL2FsZXJ0Lmh0bWwnLFxuICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBpY29uU2VydmljZTogQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlLFxuICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIEBPcHRpb25hbCgpIHB1YmxpYyBtdWx0aUFsZXJ0U2VydmljZTogTXVsdGlBbGVydFNlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7fVxuXG4gIEBJbnB1dCgnY2xyQWxlcnRTaXplU21hbGwnKSBpc1NtYWxsOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgnY2xyQWxlcnRDbG9zYWJsZScpIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgQElucHV0KCdjbHJBbGVydEFwcExldmVsJykgaXNBcHBMZXZlbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgnY2xyQWxlcnRDbG9zZWQnKSBfY2xvc2VkOiBib29sZWFuID0gZmFsc2U7XG4gIEBPdXRwdXQoJ2NsckFsZXJ0Q2xvc2VkQ2hhbmdlJykgX2Nsb3NlZENoYW5nZWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIEBJbnB1dCgnY2xyQWxlcnRUeXBlJylcbiAgc2V0IGFsZXJ0VHlwZSh2YWw6IHN0cmluZykge1xuICAgIHRoaXMuaWNvblNlcnZpY2UuYWxlcnRUeXBlID0gdmFsO1xuICB9XG4gIGdldCBhbGVydFR5cGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pY29uU2VydmljZS5hbGVydFR5cGU7XG4gIH1cblxuICBASW5wdXQoJ2NsckFsZXJ0SWNvbicpXG4gIHNldCBhbGVydEljb25TaGFwZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5pY29uU2VydmljZS5hbGVydEljb25TaGFwZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGFsZXJ0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5pY29uU2VydmljZS5pY29uSW5mb0Zyb21UeXBlKHRoaXMuaWNvblNlcnZpY2UuYWxlcnRUeXBlKS5jc3NDbGFzcztcbiAgfVxuXG4gIHByaXZhdGUgcHJldmlvdXNseUhpZGRlbiA9IGZhbHNlO1xuICBwcml2YXRlIGhpZGRlbiA9IGZhbHNlO1xuXG4gIHByaXZhdGUgZGV0ZWN0Q2hhbmdlc0lmTmVlZGVkKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzbHlIaWRkZW4gIT09IHRoaXMuaGlkZGVuKSB7XG4gICAgICB0aGlzLnByZXZpb3VzbHlIaWRkZW4gPSB0aGlzLmhpZGRlbjtcbiAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXNIaWRkZW4oKSB7XG4gICAgaWYgKHRoaXMubXVsdGlBbGVydFNlcnZpY2UpIHtcbiAgICAgIC8vIGNoYW5nZSBkZXRlY3Rpb24gaXNzdWUgaW4gcHJvZHVjdGlvbiBtb2RlIGNhdXNlcyBjdXJyZW50QWxlcnQgdG8gYmUgdW5kZWZpbmVkIHdoZW4gb25seSB0aGUgZmlyc3QgYWxlcnQgZXhpc3RzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdm13YXJlL2NsYXJpdHkvaXNzdWVzLzI0MzBcbiAgICAgIGlmICh0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydCA9PT0gdGhpcyB8fCB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmNvdW50ID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGRlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucHJldmlvdXNseUhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c2x5SGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlc0lmTmVlZGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuaGlkZGVuO1xuICB9XG5cbiAgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmNsb3NhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMubXVsdGlBbGVydFNlcnZpY2UpIHtcbiAgICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2VkQ2hhbmdlZC5lbWl0KHRydWUpO1xuICB9XG5cbiAgb3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZWRDaGFuZ2VkLmVtaXQoZmFsc2UpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvaWNvbi1hbmQtdHlwZXMuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1hbGVydC1pdGVtJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWljb24td3JhcHBlclwiPlxuICAgICAgICAgICAgPGNsci1pY29uIGNsYXNzPVwiYWxlcnQtaWNvblwiIFxuICAgICAgICAgICAgICBbYXR0ci5zaGFwZV09XCJpY29uU2VydmljZS5hbGVydEljb25TaGFwZVwiIFxuICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJpY29uU2VydmljZS5hbGVydEljb25UaXRsZVwiPjwvY2xyLWljb24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDogeyBjbGFzczogJ2FsZXJ0LWl0ZW0nIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckFsZXJ0SXRlbSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBpY29uU2VydmljZTogQWxlcnRJY29uQW5kVHlwZXNTZXJ2aWNlKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGRyZW4sXG4gIEV2ZW50RW1pdHRlcixcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQWxlcnQgfSBmcm9tICcuL2FsZXJ0JztcbmltcG9ydCB7IE11bHRpQWxlcnRTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvbXVsdGktYWxlcnQuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1hbGVydHMnLFxuICB0ZW1wbGF0ZVVybDogJy4vYWxlcnRzLmh0bWwnLFxuICBwcm92aWRlcnM6IFtNdWx0aUFsZXJ0U2VydmljZV0sXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmFsZXJ0c10nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5hbGVydC1kYW5nZXJdJzogXCJ0aGlzLmN1cnJlbnRBbGVydFR5cGUgPT0gJ2RhbmdlcidcIixcbiAgICAnW2NsYXNzLmFsZXJ0LWluZm9dJzogXCJ0aGlzLmN1cnJlbnRBbGVydFR5cGUgPT0gJ2luZm8nXCIsXG4gICAgJ1tjbGFzcy5hbGVydC1zdWNjZXNzXSc6IFwidGhpcy5jdXJyZW50QWxlcnRUeXBlID09ICdzdWNjZXNzJ1wiLFxuICAgICdbY2xhc3MuYWxlcnQtd2FybmluZ10nOiBcInRoaXMuY3VycmVudEFsZXJ0VHlwZSA9PSAnd2FybmluZydcIixcbiAgfSxcbiAgc3R5bGVzOiBbJzpob3N0IHsgZGlzcGxheTogYmxvY2sgfSddLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydHMgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICBAQ29udGVudENoaWxkcmVuKENsckFsZXJ0KSBhbGxBbGVydHM6IFF1ZXJ5TGlzdDxDbHJBbGVydD47XG5cbiAgLyoqXG4gICAqIElucHV0L091dHB1dCB0byBzdXBwb3J0IHR3byB3YXkgYmluZGluZyBvbiBjdXJyZW50IGFsZXJ0IGluZGV4XG4gICAqL1xuICBASW5wdXQoJ2NsckN1cnJlbnRBbGVydEluZGV4JylcbiAgcHVibGljIHNldCBfaW5wdXRDdXJyZW50SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGluZGV4KSAmJiBpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQgPSBpbmRleDtcbiAgICB9XG4gIH1cblxuICBAT3V0cHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleENoYW5nZScpIHB1YmxpYyBjdXJyZW50QWxlcnRJbmRleENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPihmYWxzZSk7XG5cbiAgc2V0IGN1cnJlbnRBbGVydEluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQgPSBpbmRleDtcbiAgfVxuICBnZXQgY3VycmVudEFsZXJ0SW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnB1dC9PdXRwdXQgdG8gc3VwcG9ydCB0d28gd2F5IGJpbmRpbmcgb24gY3VycmVudCBhbGVydCBpbnN0YW5jZVxuICAgKi9cbiAgQElucHV0KCdjbHJDdXJyZW50QWxlcnQnKVxuICBzZXQgY3VycmVudEFsZXJ0KGFsZXJ0OiBDbHJBbGVydCkge1xuICAgIGlmIChhbGVydCkge1xuICAgICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQgPSBhbGVydDtcbiAgICB9XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbGVydCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQ7XG4gIH1cbiAgQE91dHB1dCgnY2xyQ3VycmVudEFsZXJ0Q2hhbmdlJykgcHVibGljIGN1cnJlbnRBbGVydENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Q2xyQWxlcnQ+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW5zdXJlIHdlIGFyZSBvbmx5IGRlYWxpbmcgd2l0aCBhbGVydHMgdGhhdCBoYXZlIG5vdCBiZWVuIGNsb3NlZCB5ZXRcbiAgICovXG4gIGdldCBhbGVydHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxsQWxlcnRzLmZpbHRlcihhbGVydCA9PiB7XG4gICAgICByZXR1cm4gYWxlcnQuaXNIaWRkZW4gPT09IGZhbHNlO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGN1cnJlbnRBbGVydFR5cGUoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50QWxlcnQpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnRBbGVydC5hbGVydFR5cGU7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtdWx0aUFsZXJ0U2VydmljZTogTXVsdGlBbGVydFNlcnZpY2UpIHt9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UubWFuYWdlKHRoaXMuYWxsQWxlcnRzKTtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKGluZGV4ID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UubmV4dChpbmRleCk7XG4gICAgICB0aGlzLmN1cnJlbnRBbGVydENoYW5nZS5uZXh0KHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0KTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuZGVzdHJveSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJBbGVydCB9IGZyb20gJy4vYWxlcnQnO1xuaW1wb3J0IHsgTXVsdGlBbGVydFNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9tdWx0aS1hbGVydC5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci1hbGVydHMtcGFnZXInLFxuICB0ZW1wbGF0ZVVybDogJy4vYWxlcnRzLXBhZ2VyLmh0bWwnLFxuICBob3N0OiB7ICdbY2xhc3MuYWxlcnRzLXBhZ2VyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJBbGVydHNQYWdlciBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBtdWx0aUFsZXJ0U2VydmljZUNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSW5wdXQvT3V0cHV0IHRvIHN1cHBvcnQgdHdvIHdheSBiaW5kaW5nIG9uIGN1cnJlbnQgYWxlcnQgaW5zdGFuY2VcbiAgICovXG4gIEBJbnB1dCgnY2xyQ3VycmVudEFsZXJ0JylcbiAgc2V0IGN1cnJlbnRBbGVydChhbGVydDogQ2xyQWxlcnQpIHtcbiAgICBpZiAoYWxlcnQpIHtcbiAgICAgIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0ID0gYWxlcnQ7XG4gICAgfVxuICB9XG4gIGdldCBjdXJyZW50QWxlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsdGlBbGVydFNlcnZpY2UuY3VycmVudEFsZXJ0O1xuICB9XG5cbiAgQE91dHB1dCgnY2xyQ3VycmVudEFsZXJ0Q2hhbmdlJykgY3VycmVudEFsZXJ0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxDbHJBbGVydD4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBJbnB1dC9PdXRwdXQgdG8gc3VwcG9ydCB0d28gd2F5IGJpbmRpbmcgb24gY3VycmVudCBhbGVydCBpbmRleFxuICAgKi9cbiAgQElucHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleCcpXG4gIHNldCBjdXJyZW50QWxlcnRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5jdXJyZW50ID0gaW5kZXg7XG4gIH1cbiAgZ2V0IGN1cnJlbnRBbGVydEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmN1cnJlbnQ7XG4gIH1cblxuICBAT3V0cHV0KCdjbHJDdXJyZW50QWxlcnRJbmRleENoYW5nZScpIGN1cnJlbnRBbGVydEluZGV4Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgY29uc3RydWN0b3IocHVibGljIG11bHRpQWxlcnRTZXJ2aWNlOiBNdWx0aUFsZXJ0U2VydmljZSwgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZUNoYW5nZXMgPSB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKGluZGV4ID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEFsZXJ0SW5kZXhDaGFuZ2UuZW1pdChpbmRleCk7XG4gICAgICB0aGlzLmN1cnJlbnRBbGVydENoYW5nZS5lbWl0KHRoaXMubXVsdGlBbGVydFNlcnZpY2UuYWN0aXZlQWxlcnRzW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICBwYWdlVXAoKSB7XG4gICAgdGhpcy5tdWx0aUFsZXJ0U2VydmljZS5uZXh0KCk7XG4gIH1cblxuICBwYWdlRG93bigpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlLnByZXZpb3VzKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLm11bHRpQWxlcnRTZXJ2aWNlQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJEcm9wZG93bk1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyQWxlcnQgfSBmcm9tICcuL2FsZXJ0JztcbmltcG9ydCB7IENsckFsZXJ0SXRlbSB9IGZyb20gJy4vYWxlcnQtaXRlbSc7XG5pbXBvcnQgeyBDbHJBbGVydHMgfSBmcm9tICcuL2FsZXJ0cyc7XG5pbXBvcnQgeyBDbHJBbGVydHNQYWdlciB9IGZyb20gJy4vYWxlcnRzLXBhZ2VyJztcblxuZXhwb3J0IGNvbnN0IENMUl9BTEVSVF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJBbGVydCwgQ2xyQWxlcnRJdGVtLCBDbHJBbGVydHMsIENsckFsZXJ0c1BhZ2VyXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyRHJvcGRvd25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfQUxFUlRfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfQUxFUlRfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsckFsZXJ0TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xyQWxlcnRNb2R1bGUgfSBmcm9tICcuL2FsZXJ0L2FsZXJ0Lm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7IGV4cG9ydHM6IFtDbHJBbGVydE1vZHVsZV0gfSlcbmV4cG9ydCBjbGFzcyBDbHJFbXBoYXNpc01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5leHBvcnQgY2xhc3MgUmVzcG9uc2l2ZU5hdkNvZGVzIHtcbiAgcHVibGljIHN0YXRpYyBOQVZfTEVWRUxfMTogbnVtYmVyID0gMTtcbiAgcHVibGljIHN0YXRpYyBOQVZfTEVWRUxfMjogbnVtYmVyID0gMjtcbiAgcHVibGljIHN0YXRpYyBOQVZfQ0xPU0VfQUxMOiBzdHJpbmcgPSAnTkFWX0NMT1NFX0FMTCc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX09QRU46IHN0cmluZyA9ICdOQVZfT1BFTic7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMT1NFOiBzdHJpbmcgPSAnTkFWX0NMT1NFJztcbiAgcHVibGljIHN0YXRpYyBOQVZfVE9HR0xFOiBzdHJpbmcgPSAnTkFWX1RPR0dMRSc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX0hBTUJVUkdFUl9NRU5VOiBzdHJpbmcgPSAnb3Blbi1oYW1idXJnZXItbWVudSc7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX09WRVJGTE9XX01FTlU6IHN0cmluZyA9ICdvcGVuLW92ZXJmbG93LW1lbnUnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19UUklHR0VSXzE6IHN0cmluZyA9ICdoZWFkZXItaGFtYnVyZ2VyLXRyaWdnZXInO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19UUklHR0VSXzI6IHN0cmluZyA9ICdoZWFkZXItb3ZlcmZsb3ctdHJpZ2dlcic7XG4gIHB1YmxpYyBzdGF0aWMgTkFWX0NMQVNTX0xFVkVMXzE6IHN0cmluZyA9ICdjbHItbmF2LWxldmVsLTEnO1xuICBwdWJsaWMgc3RhdGljIE5BVl9DTEFTU19MRVZFTF8yOiBzdHJpbmcgPSAnY2xyLW5hdi1sZXZlbC0yJztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbnRyb2xDb2RlOiBzdHJpbmcsIHByaXZhdGUgX25hdkxldmVsOiBudW1iZXIpIHt9XG5cbiAgZ2V0IGNvbnRyb2xDb2RlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xDb2RlO1xuICB9XG5cbiAgZ2V0IG5hdkxldmVsKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX25hdkxldmVsO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb2RlcyB9IGZyb20gJy4uL3Jlc3BvbnNpdmUtbmF2LWNvZGVzJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSB9IGZyb20gJy4uL3Jlc3BvbnNpdmUtbmF2LWNvbnRyb2wtbWVzc2FnZSc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlIHtcbiAgcHVibGljIHJlc3BvbnNpdmVOYXZMaXN0OiBudW1iZXJbXSA9IFtdO1xuICBwcml2YXRlIHJlZ2lzdGVyTmF2U3ViamVjdDogU3ViamVjdDxudW1iZXJbXT4gPSBuZXcgU3ViamVjdDxudW1iZXJbXT4oKTtcbiAgcHJpdmF0ZSBjb250cm9sTmF2U3ViamVjdDogU3ViamVjdDxSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2U+ID0gbmV3IFN1YmplY3Q8UmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlPigpO1xuXG4gIGdldCByZWdpc3RlcmVkTmF2cygpOiBPYnNlcnZhYmxlPG51bWJlcltdPiB7XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJOYXZTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgZ2V0IG5hdkNvbnRyb2woKTogT2JzZXJ2YWJsZTxSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2U+IHtcbiAgICByZXR1cm4gdGhpcy5jb250cm9sTmF2U3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xvc2VBbGxOYXZzKCk7IC8vIFdlIHN0YXJ0IHdpdGggYWxsIG5hdnMgY2xvc2VkXG4gIH1cblxuICByZWdpc3Rlck5hdihuYXZMZXZlbDogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKCFuYXZMZXZlbCB8fCB0aGlzLmlzTmF2UmVnaXN0ZXJlZChuYXZMZXZlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2TGlzdC5wdXNoKG5hdkxldmVsKTtcbiAgICB0aGlzLnJlZ2lzdGVyTmF2U3ViamVjdC5uZXh0KHRoaXMucmVzcG9uc2l2ZU5hdkxpc3QpO1xuICB9XG5cbiAgaXNOYXZSZWdpc3RlcmVkKG5hdkxldmVsOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5yZXNwb25zaXZlTmF2TGlzdC5pbmRleE9mKG5hdkxldmVsKSA+IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNdWx0aXBsZSBjbHItbmF2LWxldmVsICcgKyBuYXZMZXZlbCArICcgYXR0cmlidXRlcyBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IG9ubHkgb25lIGV4aXN0cycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHVucmVnaXN0ZXJOYXYobmF2TGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZXNwb25zaXZlTmF2TGlzdC5pbmRleE9mKG5hdkxldmVsKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5yZXNwb25zaXZlTmF2TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5yZWdpc3Rlck5hdlN1YmplY3QubmV4dCh0aGlzLnJlc3BvbnNpdmVOYXZMaXN0KTtcbiAgICB9XG4gIH1cblxuICBzZW5kQ29udHJvbE1lc3NhZ2UoY29udHJvbENvZGU6IHN0cmluZywgbmF2TGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IG1lc3NhZ2U6IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZSA9IG5ldyBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UoY29udHJvbENvZGUsIG5hdkxldmVsKTtcbiAgICB0aGlzLmNvbnRyb2xOYXZTdWJqZWN0Lm5leHQobWVzc2FnZSk7XG4gIH1cblxuICBjbG9zZUFsbE5hdnMoKSB7XG4gICAgY29uc3QgbWVzc2FnZTogUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlID0gbmV3IFJlc3BvbnNpdmVOYXZDb250cm9sTWVzc2FnZShcbiAgICAgIFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0VfQUxMLFxuICAgICAgLTk5OVxuICAgICk7XG4gICAgdGhpcy5jb250cm9sTmF2U3ViamVjdC5uZXh0KG1lc3NhZ2UpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vbmF2L3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29kZXMgfSBmcm9tICcuLi9uYXYvcmVzcG9uc2l2ZS1uYXYtY29kZXMnO1xuaW1wb3J0IHsgUmVzcG9uc2l2ZU5hdkNvbnRyb2xNZXNzYWdlIH0gZnJvbSAnLi4vbmF2L3Jlc3BvbnNpdmUtbmF2LWNvbnRyb2wtbWVzc2FnZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci1tYWluLWNvbnRhaW5lcicsIGhvc3Q6IHsgJ1tjbGFzcy5tYWluLWNvbnRhaW5lcl0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsck1haW5Db250YWluZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIF9jbGFzc0xpc3Q6IERPTVRva2VuTGlzdDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsUmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIHJlc3BvbnNpdmVOYXZTZXJ2aWNlOiBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5fY2xhc3NMaXN0ID0gdGhpcy5lbFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdDtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLm5hdkNvbnRyb2wuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChtZXNzYWdlOiBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UpID0+IHtcbiAgICAgICAgdGhpcy5wcm9jZXNzTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcm9jZXNzTWVzc2FnZShtZXNzYWdlOiBSZXNwb25zaXZlTmF2Q29udHJvbE1lc3NhZ2UpOiB2b2lkIHtcbiAgICBsZXQgbmF2Q2xhc3M6IHN0cmluZyA9IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfSEFNQlVSR0VSX01FTlU7XG4gICAgaWYgKG1lc3NhZ2UuY29udHJvbENvZGUgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0VfQUxMKSB7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QucmVtb3ZlKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfSEFNQlVSR0VSX01FTlUpO1xuICAgICAgdGhpcy5fY2xhc3NMaXN0LnJlbW92ZShSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX09WRVJGTE9XX01FTlUpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5uYXZMZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8xKSB7XG4gICAgICB0aGlzLmNvbnRyb2xOYXYobWVzc2FnZS5jb250cm9sQ29kZSwgbmF2Q2xhc3MpO1xuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5uYXZMZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8yKSB7XG4gICAgICBuYXZDbGFzcyA9IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfT1ZFUkZMT1dfTUVOVTtcbiAgICAgIHRoaXMuY29udHJvbE5hdihtZXNzYWdlLmNvbnRyb2xDb2RlLCBuYXZDbGFzcyk7XG4gICAgfVxuICB9XG5cbiAgY29udHJvbE5hdihjb250cm9sQ29kZTogc3RyaW5nLCBuYXZDbGFzczogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKGNvbnRyb2xDb2RlID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX09QRU4pIHtcbiAgICAgIHRoaXMuX2NsYXNzTGlzdC5hZGQobmF2Q2xhc3MpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbENvZGUgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0UpIHtcbiAgICAgIHRoaXMuX2NsYXNzTGlzdC5yZW1vdmUobmF2Q2xhc3MpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbENvZGUgPT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfVE9HR0xFKSB7XG4gICAgICB0aGlzLl9jbGFzc0xpc3QudG9nZ2xlKG5hdkNsYXNzKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTWFpbkNvbnRhaW5lciB9IGZyb20gJy4vbWFpbi1jb250YWluZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX0xBWU9VVF9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtDbHJNYWluQ29udGFpbmVyXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9MQVlPVVRfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfTEFZT1VUX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJNYWluQ29udGFpbmVyTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFdpbGx5V29ua2EgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItbWFpbi1jb250YWluZXInIH0pXG5leHBvcnQgY2xhc3MgTWFpbkNvbnRhaW5lcldpbGx5V29ua2EgZXh0ZW5kcyBXaWxseVdvbmthIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT29tcGFMb29tcGEgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jaG9jb2xhdGUvb29tcGEtbG9vbXBhJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBNYWluQ29udGFpbmVyV2lsbHlXb25rYSB9IGZyb20gJy4vbWFpbi1jb250YWluZXItd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjbHItaGVhZGVyJyB9KVxuZXhwb3J0IGNsYXNzIE5hdkRldGVjdGlvbk9vbXBhTG9vbXBhIGV4dGVuZHMgT29tcGFMb29tcGEge1xuICBwcml2YXRlIHJlc3BvbnNpdmVOYXZTZXJ2aWNlOiBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSB3aWxseVdvbmthOiBNYWluQ29udGFpbmVyV2lsbHlXb25rYSxcbiAgICByZXNwb25zaXZlTmF2U2VydmljZTogUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlXG4gICkge1xuICAgIGlmICghd2lsbHlXb25rYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItaGVhZGVyIHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLW1haW4tY29udGFpbmVyJyk7XG4gICAgfVxuICAgIHN1cGVyKGNkciwgd2lsbHlXb25rYSk7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZSA9IHJlc3BvbnNpdmVOYXZTZXJ2aWNlO1xuICB9XG5cbiAgLy8gTmF2RGV0ZWN0aW9uT29tcGFMb29tcGEgaXMgdGhlIGFkZGl0aW9uIG9mIHRoZSBuYXYgbGV2ZWxzXG4gIC8vIFNpbmNlIHdlIHN1cHBvcnQgMiBsZXZlbHMsIHRoZSBwb3NzaWJpbGl0aWVzIGFyZSAwLCAxIG9yIDMgKDEgKyAyKVxuICBnZXQgZmxhdm9yKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnJlc3BvbnNpdmVOYXZMaXN0LnJlZHVjZSgoc3VtLCBuYXZMZXZlbCkgPT4gc3VtICsgbmF2TGV2ZWwsIDApO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3Jlc3BvbnNpdmUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFJlc3BvbnNpdmVOYXZDb2RlcyB9IGZyb20gJy4vcmVzcG9uc2l2ZS1uYXYtY29kZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItaGVhZGVyJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAqbmdJZj1cImlzTmF2TGV2ZWwxT25QYWdlXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaGVhZGVyLWhhbWJ1cmdlci10cmlnZ2VyXCJcbiAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVOYXYocmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8xKVwiPlxuICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICpuZ0lmPVwiaXNOYXZMZXZlbDJPblBhZ2VcIlxuICAgICAgICAgICAgY2xhc3M9XCJoZWFkZXItb3ZlcmZsb3ctdHJpZ2dlclwiXG4gICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlTmF2KHJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMilcIj5cbiAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWFkZXItYmFja2Ryb3BcIiAoY2xpY2spPVwiY2xvc2VPcGVuTmF2KClcIj48L2Rpdj5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuaGVhZGVyXSc6ICd0cnVlJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJIZWFkZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHVibGljIGlzTmF2TGV2ZWwxT25QYWdlOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBpc05hdkxldmVsMk9uUGFnZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgcmVzcG9uc2l2ZU5hdkNvZGVzID0gUmVzcG9uc2l2ZU5hdkNvZGVzO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVzcG9uc2l2ZU5hdlNlcnZpY2U6IFJlc3BvbnNpdmVOYXZpZ2F0aW9uU2VydmljZSkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UucmVnaXN0ZXJlZE5hdnMuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChuYXZMZXZlbExpc3Q6IG51bWJlcltdKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZU5hdlRyaWdnZXJzKG5hdkxldmVsTGlzdCk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLy8gcmVzZXQgdHJpZ2dlcnMuIGhhbmRsZXMgY2FzZXMgd2hlbiBhbiBhcHBsaWNhdGlvbiBoYXMgZGlmZmVyZW50IG5hdiBsZXZlbHMgb24gZGlmZmVyZW50IHBhZ2VzLlxuICByZXNldE5hdlRyaWdnZXJzKCkge1xuICAgIHRoaXMuaXNOYXZMZXZlbDFPblBhZ2UgPSBmYWxzZTtcbiAgICB0aGlzLmlzTmF2TGV2ZWwyT25QYWdlID0gZmFsc2U7XG4gIH1cblxuICAvLyBkZWNpZGVzIHdoaWNoIHRyaWdnZXJzIHRvIHNob3cgb24gdGhlIGhlYWRlclxuICBpbml0aWFsaXplTmF2VHJpZ2dlcnMobmF2TGlzdDogbnVtYmVyW10pOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0TmF2VHJpZ2dlcnMoKTtcbiAgICBpZiAobmF2TGlzdC5sZW5ndGggPiAyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNb3JlIHRoYW4gMiBOYXYgTGV2ZWxzIGRldGVjdGVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuYXZMaXN0LmZvckVhY2gobmF2TGV2ZWwgPT4ge1xuICAgICAgaWYgKG5hdkxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzEpIHtcbiAgICAgICAgdGhpcy5pc05hdkxldmVsMU9uUGFnZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG5hdkxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzIpIHtcbiAgICAgICAgdGhpcy5pc05hdkxldmVsMk9uUGFnZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBjbG9zZXMgdGhlIG5hdiB0aGF0IGlzIG9wZW5cbiAgY2xvc2VPcGVuTmF2KCkge1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2UuY2xvc2VBbGxOYXZzKCk7XG4gIH1cblxuICAvLyB0b2dnbGVzIHRoZSBuYXYgdGhhdCBpcyBvcGVuXG4gIHRvZ2dsZU5hdihuYXZMZXZlbDogbnVtYmVyKSB7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5zZW5kQ29udHJvbE1lc3NhZ2UoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9UT0dHTEUsIG5hdkxldmVsKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9yZXNwb25zaXZlLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBSZXNwb25zaXZlTmF2Q29kZXMgfSBmcm9tICcuL3Jlc3BvbnNpdmUtbmF2LWNvZGVzJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2Nsci1uYXYtbGV2ZWxdJyB9KVxuZXhwb3J0IGNsYXNzIENsck5hdkxldmVsIGltcGxlbWVudHMgT25Jbml0IHtcbiAgQElucHV0KCdjbHItbmF2LWxldmVsJykgX2xldmVsOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZXNwb25zaXZlTmF2U2VydmljZTogUmVzcG9uc2l2ZU5hdmlnYXRpb25TZXJ2aWNlLCBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKHRoaXMubGV2ZWwgIT09IFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfTEVWRUxfMSAmJiB0aGlzLmxldmVsICE9PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05hdiBMZXZlbCBjYW4gb25seSBiZSAxIG9yIDInKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5yZWdpc3Rlck5hdih0aGlzLmxldmVsKTtcbiAgICB0aGlzLmFkZE5hdkNsYXNzKHRoaXMubGV2ZWwpO1xuICB9XG5cbiAgYWRkTmF2Q2xhc3MobGV2ZWw6IG51bWJlcikge1xuICAgIGNvbnN0IG5hdkhvc3RDbGFzc0xpc3QgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3Q7XG4gICAgaWYgKGxldmVsID09PSBSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0xFVkVMXzEpIHtcbiAgICAgIG5hdkhvc3RDbGFzc0xpc3QuYWRkKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xBU1NfTEVWRUxfMSk7XG4gICAgfSBlbHNlIGlmIChsZXZlbCA9PT0gUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9MRVZFTF8yKSB7XG4gICAgICBuYXZIb3N0Q2xhc3NMaXN0LmFkZChSZXNwb25zaXZlTmF2Q29kZXMuTkFWX0NMQVNTX0xFVkVMXzIpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBsZXZlbCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9sZXZlbDtcbiAgfVxuXG4gIC8vIGdldHRlciB0byBhY2Nlc3MgdGhlIHJlc3BvbnNpdmUgbmF2aWdhdGlvbiBjb2RlcyBmcm9tIHRoZSB0ZW1wbGF0ZVxuICBnZXQgcmVzcG9uc2l2ZU5hdkNvZGVzKCk6IFJlc3BvbnNpdmVOYXZDb2RlcyB7XG4gICAgcmV0dXJuIFJlc3BvbnNpdmVOYXZDb2RlcztcbiAgfVxuXG4gIG9wZW4oKTogdm9pZCB7XG4gICAgdGhpcy5yZXNwb25zaXZlTmF2U2VydmljZS5zZW5kQ29udHJvbE1lc3NhZ2UoUmVzcG9uc2l2ZU5hdkNvZGVzLk5BVl9PUEVOLCB0aGlzLmxldmVsKTtcbiAgfVxuXG4gIGNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMucmVzcG9uc2l2ZU5hdlNlcnZpY2Uuc2VuZENvbnRyb2xNZXNzYWdlKFJlc3BvbnNpdmVOYXZDb2Rlcy5OQVZfQ0xPU0UsIHRoaXMubGV2ZWwpO1xuICB9XG5cbiAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0cyB0aGUgYmVzdCB3YXkgdG8gZG8gdGhpcy4gUG9zc2libGUgbWV0aG9kc1xuICAvLyAxLiBIb3N0TGlzdGVuZXIgKGN1cnJlbnQgc29sdXRpb24pXG4gIC8vIDIuIERpcmVjdGl2ZXMgb24gdGhlIC5uYXYtbGluayBjbGFzcy4gV2UgZGlzY3Vzc2VkIG9uIG1vdmluZyBhd2F5IGZyb20gY2xhc3Mgc2VsZWN0b3JzIGJ1dCBJIGZvcmdldCB0aGUgcmVhc29uXG4gIC8vIHdoeVxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50LnRhcmdldCddKVxuICBvbk1vdXNlQ2xpY2sodGFyZ2V0OiBhbnkpIHtcbiAgICBsZXQgY3VycmVudDogYW55ID0gdGFyZ2V0OyAvLyBHZXQgdGhlIGVsZW1lbnQgaW4gdGhlIERPTSBvbiB3aGljaCB0aGUgbW91c2Ugd2FzIGNsaWNrZWRcbiAgICBjb25zdCBuYXZIb3N0OiBhbnkgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDsgLy8gR2V0IHRoZSBjdXJyZW50IG5hdiBuYXRpdmUgSFRNTCBlbGVtZW50XG5cbiAgICAvLyBTdGFydCBjaGVja2luZyBpZiBjdXJyZW50IGFuZCBuYXZIb3N0IGFyZSBlcXVhbC5cbiAgICAvLyBJZiBub3QgdHJhdmVyc2UgdG8gdGhlIHBhcmVudE5vZGUgYW5kIGNoZWNrIGFnYWluLlxuICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gbmF2SG9zdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCduYXYtbGluaycpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc3BvbnNpdmVOYXZTZXJ2aWNlLnVucmVnaXN0ZXJOYXYodGhpcy5sZXZlbCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckRyb3Bkb3duTW9kdWxlIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBNYWluQ29udGFpbmVyV2lsbHlXb25rYSB9IGZyb20gJy4vY2hvY29sYXRlL21haW4tY29udGFpbmVyLXdpbGx5LXdvbmthJztcbmltcG9ydCB7IE5hdkRldGVjdGlvbk9vbXBhTG9vbXBhIH0gZnJvbSAnLi9jaG9jb2xhdGUvbmF2LWRldGVjdGlvbi1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgQ2xySGVhZGVyIH0gZnJvbSAnLi9oZWFkZXInO1xuaW1wb3J0IHsgQ2xyTmF2TGV2ZWwgfSBmcm9tICcuL25hdi1sZXZlbCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfTkFWSUdBVElPTl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xySGVhZGVyLFxuICBDbHJOYXZMZXZlbCxcbiAgTmF2RGV0ZWN0aW9uT29tcGFMb29tcGEsXG4gIE1haW5Db250YWluZXJXaWxseVdvbmthLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyRHJvcGRvd25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfTkFWSUdBVElPTl9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9OQVZJR0FUSU9OX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJOYXZpZ2F0aW9uTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHRlbXBsYXRlOiBgXG4gICAgICA8bmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVSZWZDb250YWluZXIge1xuICBAVmlld0NoaWxkKFRlbXBsYXRlUmVmKSB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55Pjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRlbXBsYXRlUmVmQ29udGFpbmVyIH0gZnJvbSAnLi90ZW1wbGF0ZS1yZWYtY29udGFpbmVyJztcblxuZXhwb3J0ICogZnJvbSAnLi90ZW1wbGF0ZS1yZWYtY29udGFpbmVyJztcblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1JFRl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtUZW1wbGF0ZVJlZkNvbnRhaW5lcl07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgVEVNUExBVEVfUkVGX0RJUkVDVElWRVMgfSBmcm9tICcuL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW1RFTVBMQVRFX1JFRl9ESVJFQ1RJVkVTXSxcbiAgZW50cnlDb21wb25lbnRzOiBbVEVNUExBVEVfUkVGX0RJUkVDVElWRVNdLFxuICBleHBvcnRzOiBbVEVNUExBVEVfUkVGX0RJUkVDVElWRVNdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUZW1wbGF0ZVJlZk1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaWxseVdvbmthIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL3dpbGx5LXdvbmthJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnY2xyLXRhYnMnIH0pXG5leHBvcnQgY2xhc3MgVGFic1dpbGx5V29ua2EgZXh0ZW5kcyBXaWxseVdvbmthIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBJbmplY3QsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE9vbXBhTG9vbXBhIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2hvY29sYXRlL29vbXBhLWxvb21wYSc7XG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcblxuaW1wb3J0IHsgVGFic1dpbGx5V29ua2EgfSBmcm9tICcuL3RhYnMtd2lsbHktd29ua2EnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyVGFiTGlua10sIGNsci10YWItY29udGVudCcgfSlcbmV4cG9ydCBjbGFzcyBBY3RpdmVPb21wYUxvb21wYSBleHRlbmRzIE9vbXBhTG9vbXBhIHtcbiAgcHJpdmF0ZSBpZkFjdGl2ZTogSWZBY3RpdmVTZXJ2aWNlO1xuICBwcml2YXRlIGlkOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBAT3B0aW9uYWwoKSB3aWxseVdvbmthOiBUYWJzV2lsbHlXb25rYSxcbiAgICBASW5qZWN0KElGX0FDVElWRV9JRCkgaWQ6IG51bWJlcixcbiAgICBpZkFjdGl2ZTogSWZBY3RpdmVTZXJ2aWNlXG4gICkge1xuICAgIGlmICghd2lsbHlXb25rYSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHJUYWJMaW5rIGFuZCBjbHItdGFiLWNvbnRlbnQgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgb2YgYSBjbHItdGFicycpO1xuICAgIH1cbiAgICBzdXBlcihjZHIsIHdpbGx5V29ua2EpO1xuICAgIHRoaXMuaWZBY3RpdmUgPSBpZkFjdGl2ZTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cblxuICBnZXQgZmxhdm9yKCkge1xuICAgIHJldHVybiB0aGlzLmlmQWN0aXZlLmN1cnJlbnQgPT09IHRoaXMuaWQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLy8gVE9ETzogaWYgd2UgZmluZCBtb3JlIGNvbXBvbmVudHMgdGhhdCBjb3VsZCB1c2UgdGhpcywgY29uc2lkZXIgbW92aW5nIHRoaXMgdG8gdXRpbHNcbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBcmlhU2VydmljZSB7XG4gIHB1YmxpYyBhcmlhTGFiZWxsZWRCeTogc3RyaW5nO1xuICBwdWJsaWMgYXJpYUNvbnRyb2xzOiBzdHJpbmc7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTkgVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmV4cG9ydCBlbnVtIFRhYnNMYXlvdXQge1xuICBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnLFxuICBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCcsXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJUYWIgfSBmcm9tICcuLi90YWInO1xuaW1wb3J0IHsgVGFic0xheW91dCB9IGZyb20gJy4uL2VudW1zL3RhYnMtbGF5b3V0LmVudW0nO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVGFic1NlcnZpY2Uge1xuICBwcml2YXRlIF9jaGlsZHJlbjogQ2xyVGFiW10gPSBbXTtcblxuICBsYXlvdXQ6IFRhYnNMYXlvdXQgPSBUYWJzTGF5b3V0LkhPUklaT05UQUw7XG5cbiAgcmVnaXN0ZXIodGFiOiBDbHJUYWIpIHtcbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKHRhYik7XG4gIH1cblxuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZVRhYigpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maW5kKCh0YWI6IENsclRhYikgPT4ge1xuICAgICAgcmV0dXJuIHRhYi5hY3RpdmU7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgb3ZlcmZsb3dUYWJzKCkge1xuICAgIGlmICh0aGlzLmxheW91dCA9PT0gVGFic0xheW91dC5WRVJUSUNBTCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5maWx0ZXIoKHRhYjogQ2xyVGFiKSA9PiB0YWIudGFiTGluay5pbk92ZXJmbG93ID09PSB0cnVlKTtcbiAgICB9XG4gIH1cblxuICB1bnJlZ2lzdGVyKHRhYjogQ2xyVGFiKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YodGFiKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbmplY3QsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IEFyaWFTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvYXJpYS5zZXJ2aWNlJztcblxubGV0IG5iVGFiQ29udGVudENvbXBvbmVudHM6IG51bWJlciA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10YWItY29udGVudCcsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG5nLXRlbXBsYXRlICN0YWJDb250ZW50UHJvamVjdGVkUmVmPlxuICAgICAgPHNlY3Rpb24gW2lkXT1cInRhYkNvbnRlbnRJZFwiIHJvbGU9XCJ0YWJwYW5lbFwiIFtjbGFzcy5hY3RpdmVdPVwiYWN0aXZlXCJcbiAgICAgICAgICAgICAgIFtoaWRkZW5dPVwiIWFjdGl2ZVwiXG4gICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiYXJpYUxhYmVsbGVkQnlcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJhY3RpdmVcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIWFjdGl2ZVwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUYWJDb250ZW50IHtcbiAgQFZpZXdDaGlsZCgndGFiQ29udGVudFByb2plY3RlZFJlZicpIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxDbHJUYWJDb250ZW50PjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgQEluamVjdChJRl9BQ1RJVkVfSUQpIHB1YmxpYyBpZDogbnVtYmVyLFxuICAgIHByaXZhdGUgYXJpYVNlcnZpY2U6IEFyaWFTZXJ2aWNlXG4gICkge1xuICAgIGlmICghdGhpcy50YWJDb250ZW50SWQpIHtcbiAgICAgIHRoaXMudGFiQ29udGVudElkID0gJ2Nsci10YWItY29udGVudC0nICsgbmJUYWJDb250ZW50Q29tcG9uZW50cysrO1xuICAgIH1cbiAgfVxuXG4gIGdldCBhcmlhTGFiZWxsZWRCeSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFMYWJlbGxlZEJ5O1xuICB9XG5cbiAgZ2V0IHRhYkNvbnRlbnRJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFDb250cm9scztcbiAgfVxuXG4gIEBJbnB1dCgnaWQnKVxuICBzZXQgdGFiQ29udGVudElkKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmFyaWFTZXJ2aWNlLmFyaWFDb250cm9scyA9IGlkO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxubGV0IG5iVGFic0NvbXBvbmVudCA9IDA7XG5cbmV4cG9ydCBjb25zdCBUQUJTX0lEID0gbmV3IEluamVjdGlvblRva2VuPG51bWJlcj4oJ1RBQlNfSUQnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuRmFjdG9yeSgpIHtcbiAgcmV0dXJuICdjbHItdGFicy0nICsgbmJUYWJzQ29tcG9uZW50Kys7XG59XG5cbmV4cG9ydCBjb25zdCBUQUJTX0lEX1BST1ZJREVSID0ge1xuICBwcm92aWRlOiBUQUJTX0lELFxuICB1c2VGYWN0b3J5OiB0b2tlbkZhY3RvcnksXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHtcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBIb3N0TGlzdGVuZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElmQWN0aXZlU2VydmljZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2lmLWFjdGl2ZS5zZXJ2aWNlJztcbmltcG9ydCB7IFRlbXBsYXRlUmVmQ29udGFpbmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi1jb250YWluZXInO1xuaW1wb3J0IHsgVGFic1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJzLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBBcmlhU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2FyaWEuc2VydmljZSc7XG5pbXBvcnQgeyBUQUJTX0lEIH0gZnJvbSAnLi90YWJzLWlkLnByb3ZpZGVyJztcbmltcG9ydCB7IFRhYnNMYXlvdXQgfSBmcm9tICcuL2VudW1zL3RhYnMtbGF5b3V0LmVudW0nO1xuXG5sZXQgbmJUYWJMaW5rQ29tcG9uZW50czogbnVtYmVyID0gMDtcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NsclRhYkxpbmtdJyxcbiAgaG9zdDoge1xuICAgICdbYXR0ci5hcmlhLWhpZGRlbl0nOiAnZmFsc2UnLFxuICAgICdbY2xhc3MuYnRuXSc6ICd0cnVlJyxcbiAgICByb2xlOiAndGFiJyxcbiAgICB0eXBlOiAnYnV0dG9uJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFiTGluayB7XG4gIHByaXZhdGUgX2luT3ZlcmZsb3c6IGJvb2xlYW47XG5cbiAgQElucHV0KCdjbHJUYWJMaW5rSW5PdmVyZmxvdycpXG4gIHNldCBpbk92ZXJmbG93KGluT3ZlcmZsb3cpIHtcbiAgICB0aGlzLl9pbk92ZXJmbG93ID0gaW5PdmVyZmxvdztcbiAgfVxuXG4gIGdldCBpbk92ZXJmbG93KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9pbk92ZXJmbG93ICYmIHRoaXMudGFic1NlcnZpY2UubGF5b3V0ICE9PSBUYWJzTGF5b3V0LlZFUlRJQ0FMO1xuICB9XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5idG4tbGluaycpXG4gIEBIb3N0QmluZGluZygnY2xhc3MubmF2LWxpbmsnKVxuICBnZXQgYWRkTGlua0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuICF0aGlzLmluT3ZlcmZsb3c7XG4gIH1cblxuICB0ZW1wbGF0ZVJlZkNvbnRhaW5lcjogVGVtcGxhdGVSZWZDb250YWluZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGlmQWN0aXZlU2VydmljZTogSWZBY3RpdmVTZXJ2aWNlLFxuICAgIEBJbmplY3QoSUZfQUNUSVZFX0lEKSBwcml2YXRlIGlkOiBudW1iZXIsXG4gICAgcHJpdmF0ZSBhcmlhU2VydmljZTogQXJpYVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcml2YXRlIHRhYnNTZXJ2aWNlOiBUYWJzU2VydmljZSxcbiAgICBASW5qZWN0KFRBQlNfSUQpIHB1YmxpYyB0YWJzSWQ6IG51bWJlclxuICApIHtcbiAgICBpZiAoIXRoaXMudGFiTGlua0lkKSB7XG4gICAgICB0aGlzLnRhYkxpbmtJZCA9ICdjbHItdGFiLWxpbmstJyArIG5iVGFiTGlua0NvbXBvbmVudHMrKztcbiAgICB9XG5cbiAgICAvLyBUYWIgbGlua3MgY2FuIGJlIHJlbmRlcmVkIGluIG9uZSBvZiB0d28gcGxhY2VzOiBpbiB0aGUgbWFpbiBhcmVhIG9yIGluc2lkZSB0aGUgb3ZlcmZsb3cgZHJvcGRvd24gbWVudS5cbiAgICAvLyBIZXJlLCB3ZSBjcmVhdGUgYSBjb250YWluZXIgc28gdGhhdCBpdHMgdGVtcGxhdGUgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGVtYmVkZGVkVmlldyBvbiB0aGUgZmx5LlxuICAgIC8vIFNlZSBUYWJzU2VydmljZSdzIHJlbmRlclZpZXcoKSBtZXRob2QgYW5kIGhvdyBpdCdzIHVzZWQgaW4gVGFicyBjbGFzcyBmb3IgYW4gZXhhbXBsZS5cbiAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoVGVtcGxhdGVSZWZDb250YWluZXIpO1xuICAgIHRoaXMudGVtcGxhdGVSZWZDb250YWluZXIgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnksIDEsIHVuZGVmaW5lZCwgW1xuICAgICAgW3RoaXMuZWwubmF0aXZlRWxlbWVudF0sXG4gICAgXSkuaW5zdGFuY2U7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1jb250cm9scycpXG4gIGdldCBhcmlhQ29udHJvbHMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmlhU2VydmljZS5hcmlhQ29udHJvbHM7XG4gIH1cblxuICBnZXQgdGFiTGlua0lkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUxhYmVsbGVkQnk7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2lkJylcbiAgQElucHV0KCdpZCcpXG4gIHNldCB0YWJMaW5rSWQoaWQ6IHN0cmluZykge1xuICAgIHRoaXMuYXJpYVNlcnZpY2UuYXJpYUxhYmVsbGVkQnkgPSBpZDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9IHRoaXMuaWQ7XG4gIH1cblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLmFjdGl2ZScpXG4gIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXNlbGVjdGVkJylcbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSUQsIElGX0FDVElWRV9JRF9QUk9WSURFUiwgSWZBY3RpdmVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtYWN0aXZlLnNlcnZpY2UnO1xuXG5pbXBvcnQgeyBBcmlhU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2FyaWEuc2VydmljZSc7XG5pbXBvcnQgeyBUYWJzU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3RhYnMuc2VydmljZSc7XG5pbXBvcnQgeyBDbHJUYWJDb250ZW50IH0gZnJvbSAnLi90YWItY29udGVudCc7XG5pbXBvcnQgeyBDbHJUYWJMaW5rIH0gZnJvbSAnLi90YWItbGluay5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGFiJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIHByb3ZpZGVyczogW0lGX0FDVElWRV9JRF9QUk9WSURFUiwgQXJpYVNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUYWIge1xuICBAQ29udGVudENoaWxkKENsclRhYkxpbmspIHRhYkxpbms6IENsclRhYkxpbms7XG4gIEBDb250ZW50Q2hpbGQoQ2xyVGFiQ29udGVudCkgdGFiQ29udGVudDogQ2xyVGFiQ29udGVudDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgQEluamVjdChJRl9BQ1RJVkVfSUQpIHB1YmxpYyBpZDogbnVtYmVyLFxuICAgIHByaXZhdGUgdGFic1NlcnZpY2U6IFRhYnNTZXJ2aWNlXG4gICkge1xuICAgIHRhYnNTZXJ2aWNlLnJlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy50YWJzU2VydmljZS51bnJlZ2lzdGVyKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gdGhpcy5pZDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3RvciwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vLi4vcG9wb3Zlci9jb21tb24vYWJzdHJhY3QtcG9wb3Zlcic7XG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdGFiLW92ZXJmbG93LWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuZHJvcGRvd24tbWVudV0nOiAndHJ1ZScsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclRhYk92ZXJmbG93Q29udGVudCBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKGluamVjdG9yOiBJbmplY3RvciwgQFNraXBTZWxmKCkgcGFyZW50SG9zdDogRWxlbWVudFJlZikge1xuICAgIHN1cGVyKGluamVjdG9yLCBwYXJlbnRIb3N0KTtcbiAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuQk9UVE9NX1JJR0hUO1xuICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgIHRoaXMuY2xvc2VPbk91dHNpZGVDbGljayA9IHRydWU7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBJbmplY3QsXG4gIFF1ZXJ5TGlzdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgSG9zdEJpbmRpbmcsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBJZkFjdGl2ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuc2VydmljZSc7XG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcblxuaW1wb3J0IHsgVGFic1NlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy90YWJzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyVGFiIH0gZnJvbSAnLi90YWInO1xuaW1wb3J0IHsgQ2xyVGFiTGluayB9IGZyb20gJy4vdGFiLWxpbmsuZGlyZWN0aXZlJztcbmltcG9ydCB7IENsclRhYkNvbnRlbnQgfSBmcm9tICcuL3RhYi1jb250ZW50JztcbmltcG9ydCB7IFRBQlNfSUQsIFRBQlNfSURfUFJPVklERVIgfSBmcm9tICcuL3RhYnMtaWQucHJvdmlkZXInO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFRhYnNMYXlvdXQgfSBmcm9tICcuL2VudW1zL3RhYnMtbGF5b3V0LmVudW0nO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10YWJzJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHVsIGNsYXNzPVwibmF2XCIgcm9sZT1cInRhYmxpc3RcIiBbYXR0ci5hcmlhLW93bnNdPVwidGFiSWRzXCI+XG4gICAgICAgICAgICA8IS0tdGFiIGxpbmtzLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBsaW5rIG9mIHRhYkxpbmtEaXJlY3RpdmVzXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImxpbmsudGFic0lkID09PSB0YWJzSWQgJiYgIWxpbmsuaW5PdmVyZmxvd1wiPlxuICAgICAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiIGNsYXNzPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGluay50ZW1wbGF0ZVJlZkNvbnRhaW5lci50ZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwidGFic1NlcnZpY2Uub3ZlcmZsb3dUYWJzLmxlbmd0aCA+IDBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFicy1vdmVyZmxvdyBib3R0b20tcmlnaHRcIiBbY2xhc3Mub3Blbl09XCJpZk9wZW5TZXJ2aWNlLm9wZW5cIlxuICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZU92ZXJmbG93KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1saW5rIG5hdi1saW5rIGRyb3Bkb3duLXRvZ2dsZVwiIHR5cGU9XCJidXR0b25cIiBbY2xhc3MuYWN0aXZlXT1cImFjdGl2ZVRhYkluT3ZlcmZsb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Y2xyLWljb24gc2hhcGU9XCJlbGxpcHNpcy1ob3Jpem9udGFsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5pcy1pbmZvXT1cImlmT3BlblNlcnZpY2Uub3BlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci50aXRsZV09XCJjb21tb25TdHJpbmdzLm1vcmVcIj48L2Nsci1pY29uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDwhLS10YWIgbGlua3MgaW4gb3ZlcmZsb3cgbWVudS0tPlxuICAgICAgICAgICAgICAgICAgICA8Y2xyLXRhYi1vdmVyZmxvdy1jb250ZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgbGluayBvZiB0YWJMaW5rRGlyZWN0aXZlc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJsaW5rLnRhYnNJZCA9PT0gdGFic0lkICYmIGxpbmsuaW5PdmVyZmxvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJsaW5rLnRlbXBsYXRlUmVmQ29udGFpbmVyLnRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9jbHItdGFiLW92ZXJmbG93LWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC91bD5cbiAgICAgICAgPCEtLXRhYiBjb250ZW50LS0+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNvbnRlbnQgb2YgdGFiQ29udGVudHNcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29udGVudC50ZW1wbGF0ZVJlZlwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICBgLFxuICBwcm92aWRlcnM6IFtJZkFjdGl2ZVNlcnZpY2UsIElmT3BlblNlcnZpY2UsIFRhYnNTZXJ2aWNlLCBUQUJTX0lEX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFicyBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBASW5wdXQoJ2NsckxheW91dCcpXG4gIHNldCBsYXlvdXQobGF5b3V0OiBUYWJzTGF5b3V0KSB7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoVGFic0xheW91dCkuaW5jbHVkZXMobGF5b3V0KSkge1xuICAgICAgdGhpcy50YWJzU2VydmljZS5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgfVxuICB9XG4gIGdldCBsYXlvdXQoKTogVGFic0xheW91dCB7XG4gICAgcmV0dXJuIHRoaXMudGFic1NlcnZpY2UubGF5b3V0O1xuICB9XG5cbiAgQENvbnRlbnRDaGlsZHJlbihDbHJUYWIpIHByaXZhdGUgdGFiczogUXVlcnlMaXN0PENsclRhYj47XG5cbiAgcHJpdmF0ZSBfdGFiTGlua0RpcmVjdGl2ZXM6IENsclRhYkxpbmtbXSA9IFtdO1xuICBnZXQgdGFiTGlua0RpcmVjdGl2ZXMoKTogQ2xyVGFiTGlua1tdIHtcbiAgICByZXR1cm4gdGhpcy5fdGFiTGlua0RpcmVjdGl2ZXM7XG4gIH1cblxuICBnZXQgdGFiQ29udGVudHMoKTogQ2xyVGFiQ29udGVudFtdIHtcbiAgICByZXR1cm4gdGhpcy50YWJzLmZpbHRlcih0YWIgPT4gISF0YWIudGFiQ29udGVudCkubWFwKHRhYiA9PiB0YWIudGFiQ29udGVudCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgaWZBY3RpdmVTZXJ2aWNlOiBJZkFjdGl2ZVNlcnZpY2UsXG4gICAgcHVibGljIGlmT3BlblNlcnZpY2U6IElmT3BlblNlcnZpY2UsXG4gICAgcHVibGljIHRhYnNTZXJ2aWNlOiBUYWJzU2VydmljZSxcbiAgICBASW5qZWN0KFRBQlNfSUQpIHB1YmxpYyB0YWJzSWQ6IG51bWJlcixcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHt9XG5cbiAgZ2V0IGFjdGl2ZVRhYkluT3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIHRoaXMudGFic1NlcnZpY2Uub3ZlcmZsb3dUYWJzLmluZGV4T2YodGhpcy50YWJzU2VydmljZS5hY3RpdmVUYWIpID4gLTE7XG4gIH1cblxuICBnZXQgdGFiSWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhYnNTZXJ2aWNlLmNoaWxkcmVuLm1hcCh0YWIgPT4gdGFiLnRhYkxpbmsudGFiTGlua0lkKS5qb2luKCcgJyk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgdGhpcy5fdGFiTGlua0RpcmVjdGl2ZXMgPSB0aGlzLnRhYnMubWFwKHRhYiA9PiB0YWIudGFiTGluayk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLnRhYnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLl90YWJMaW5rRGlyZWN0aXZlcyA9IHRoaXMudGFicy5tYXAodGFiID0+IHRhYi50YWJMaW5rKTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5pZkFjdGl2ZVNlcnZpY2UuY3VycmVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy50YWJMaW5rRGlyZWN0aXZlc1swXSkge1xuICAgICAgdGhpcy50YWJMaW5rRGlyZWN0aXZlc1swXS5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZU92ZXJmbG93KGV2ZW50OiBhbnkpIHtcbiAgICB0aGlzLmlmT3BlblNlcnZpY2UudG9nZ2xlV2l0aEV2ZW50KGV2ZW50KTtcbiAgfVxuXG4gIEBIb3N0QmluZGluZygnY2xhc3MudGFicy12ZXJ0aWNhbCcpXG4gIGdldCBpc1ZlcnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLmxheW91dCA9PT0gVGFic0xheW91dC5WRVJUSUNBTDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKHN1YiA9PiB7XG4gICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uLy4uL3BvcG92ZXIvY29tbW9uL3BvcG92ZXIubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvY29uZGl0aW9uYWwubW9kdWxlJztcbmltcG9ydCB7IENsclRlbXBsYXRlUmVmTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdGVtcGxhdGUtcmVmL3RlbXBsYXRlLXJlZi5tb2R1bGUnO1xuXG5pbXBvcnQgeyBBY3RpdmVPb21wYUxvb21wYSB9IGZyb20gJy4vY2hvY29sYXRlL2FjdGl2ZS1vb21wYS1sb29tcGEnO1xuaW1wb3J0IHsgVGFic1dpbGx5V29ua2EgfSBmcm9tICcuL2Nob2NvbGF0ZS90YWJzLXdpbGx5LXdvbmthJztcbmltcG9ydCB7IENsclRhYiB9IGZyb20gJy4vdGFiJztcbmltcG9ydCB7IENsclRhYkNvbnRlbnQgfSBmcm9tICcuL3RhYi1jb250ZW50JztcbmltcG9ydCB7IENsclRhYkxpbmsgfSBmcm9tICcuL3RhYi1saW5rLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJUYWJPdmVyZmxvd0NvbnRlbnQgfSBmcm9tICcuL3RhYi1vdmVyZmxvdy1jb250ZW50JztcbmltcG9ydCB7IENsclRhYnMgfSBmcm9tICcuL3RhYnMnO1xuXG5leHBvcnQgY29uc3QgQ0xSX1RBQlNfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbXG4gIENsclRhYkNvbnRlbnQsXG4gIENsclRhYixcbiAgQ2xyVGFicyxcbiAgQ2xyVGFiT3ZlcmZsb3dDb250ZW50LFxuICBDbHJUYWJMaW5rLFxuICBUYWJzV2lsbHlXb25rYSxcbiAgQWN0aXZlT29tcGFMb29tcGEsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJDb21tb25Qb3BvdmVyTW9kdWxlLCBDbHJDb25kaXRpb25hbE1vZHVsZSwgQ2xySWNvbk1vZHVsZSwgQ2xyVGVtcGxhdGVSZWZNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfVEFCU19ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9UQUJTX0RJUkVDVElWRVMsIENsckNvbmRpdGlvbmFsTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVGFic01vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSB7XG4gIHB1YmxpYyBuYXZHcm91cENvdW50OiBudW1iZXIgPSAwO1xuXG4gIHJlZ2lzdGVyTmF2R3JvdXAoKSB7XG4gICAgdGhpcy5uYXZHcm91cENvdW50Kys7XG4gIH1cblxuICB1bnJlZ2lzdGVyTmF2R3JvdXAoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZHcm91cENvdW50LS07XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVmVydGljYWxOYXZJY29uU2VydmljZSB7XG4gIHByaXZhdGUgX2ljb25zOiBudW1iZXIgPSAwO1xuXG4gIGdldCBoYXNJY29ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5faWNvbnMgPiAwO1xuICB9XG5cbiAgcmVnaXN0ZXJJY29uKCk6IHZvaWQge1xuICAgIHRoaXMuX2ljb25zKys7XG4gIH1cblxuICB1bnJlZ2lzdGVySWNvbigpOiB2b2lkIHtcbiAgICB0aGlzLl9pY29ucy0tO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTmF2U2VydmljZSB7XG4gIHByaXZhdGUgX2FuaW1hdGVPbkNvbGxhcHNlZDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgZ2V0IGFuaW1hdGVPbkNvbGxhcHNlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZU9uQ29sbGFwc2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29sbGFwc2VkQ2hhbmdlZDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgZ2V0IGNvbGxhcHNlZENoYW5nZWQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlZENoYW5nZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9jb2xsYXBzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgY29sbGFwc2VkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9jb2xsYXBzZWQ7XG4gIH1cblxuICBzZXQgY29sbGFwc2VkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh0aGlzLmNvbGxhcHNpYmxlICYmIHRoaXMuX2NvbGxhcHNlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29sbGFwc2VCZWhhdmlvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY29sbGFwc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBnZXQgY29sbGFwc2libGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNpYmxlO1xuICB9XG5cbiAgc2V0IGNvbGxhcHNpYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdmFsdWUgPSAhIXZhbHVlO1xuICAgIGlmICh0aGlzLl9jb2xsYXBzaWJsZSAhPT0gdmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUgJiYgdGhpcy5jb2xsYXBzZWQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb2xsYXBzZUJlaGF2aW9yKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbGxhcHNpYmxlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDb2xsYXBzZUJlaGF2aW9yKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5fYW5pbWF0ZU9uQ29sbGFwc2VkLm5leHQodmFsdWUpO1xuICAgIHRoaXMuX2NvbGxhcHNlZCA9IHZhbHVlO1xuICAgIHRoaXMuX2NvbGxhcHNlZENoYW5nZWQubmV4dCh2YWx1ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLXJlZ2lzdHJhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2SWNvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy92ZXJ0aWNhbC1uYXYtaWNvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2U2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3MgfSBmcm9tICcuLi8uLi91dGlscy9pMThuL2NvbW1vbi1zdHJpbmdzLmludGVyZmFjZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci12ZXJ0aWNhbC1uYXYnLFxuICB0ZW1wbGF0ZVVybDogJy4vdmVydGljYWwtbmF2Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtWZXJ0aWNhbE5hdlNlcnZpY2UsIFZlcnRpY2FsTmF2SWNvblNlcnZpY2UsIFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlXSxcbiAgaG9zdDoge1xuICAgIGNsYXNzOiAnY2xyLXZlcnRpY2FsLW5hdicsXG4gICAgJ1tjbGFzcy5pcy1jb2xsYXBzZWRdJzogJ2NvbGxhcHNlZCcsXG4gICAgJ1tjbGFzcy5oYXMtbmF2LWdyb3Vwc10nOiAnaGFzTmF2R3JvdXBzJyxcbiAgICAnW2NsYXNzLmhhcy1pY29uc10nOiAnaGFzSWNvbnMnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJWZXJ0aWNhbE5hdiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGdldCBjb2xsYXBzaWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbmF2U2VydmljZS5jb2xsYXBzaWJsZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyVmVydGljYWxOYXZDb2xsYXBzaWJsZScpXG4gIHNldCBjb2xsYXBzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2libGUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBjb2xsYXBzZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkO1xuICB9XG5cbiAgQElucHV0KCdjbHJWZXJ0aWNhbE5hdkNvbGxhcHNlZCcpXG4gIHNldCBjb2xsYXBzZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCA9IHZhbHVlO1xuICB9XG5cbiAgQE91dHB1dCgnY2xyVmVydGljYWxOYXZDb2xsYXBzZWRDaGFuZ2UnKVxuICBwcml2YXRlIF9jb2xsYXBzZWRDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIGdldCBoYXNOYXZHcm91cHMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX25hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZS5uYXZHcm91cENvdW50ID4gMDtcbiAgfVxuXG4gIGdldCBoYXNJY29ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fbmF2SWNvblNlcnZpY2UuaGFzSWNvbnM7XG4gIH1cblxuICBwcml2YXRlIF9zdWI6IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9uYXZTZXJ2aWNlOiBWZXJ0aWNhbE5hdlNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbmF2SWNvblNlcnZpY2U6IFZlcnRpY2FsTmF2SWNvblNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlOiBWZXJ0aWNhbE5hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZSxcbiAgICBwdWJsaWMgY29tbW9uU3RyaW5nczogQ2xyQ29tbW9uU3RyaW5nc1xuICApIHtcbiAgICB0aGlzLl9zdWIgPSB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZENoYW5nZWQuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlZENoYW5nZWQuZW1pdCh2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICB0b2dnbGVCeUJ1dHRvbigpIHtcbiAgICB0aGlzLmNvbGxhcHNlZCA9ICF0aGlzLmNvbGxhcHNlZDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1Yi51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBfZXhwYW5kQ2hhbmdlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICBnZXQgZXhwYW5kQ2hhbmdlKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBleHBhbmQoKTogdm9pZCB7XG4gICAgdGhpcy5fZXhwYW5kQ2hhbmdlLm5leHQodHJ1ZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uRXZlbnQsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBFeHBhbmQgfSBmcm9tICcuLi8uLi91dGlscy9leHBhbmQvcHJvdmlkZXJzL2V4cGFuZCc7XG5cbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLXJlZ2lzdHJhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLnNlcnZpY2UnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuY29uc3QgRVhQQU5ERURfU1RBVEU6IHN0cmluZyA9ICdleHBhbmRlZCc7XG5jb25zdCBDT0xMQVBTRURfU1RBVEU6IHN0cmluZyA9ICdjb2xsYXBzZWQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdmVydGljYWwtbmF2LWdyb3VwJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3ZlcnRpY2FsLW5hdi1ncm91cC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbRXhwYW5kLCBWZXJ0aWNhbE5hdkdyb3VwU2VydmljZV0sXG4gIGFuaW1hdGlvbnM6IFtcbiAgICB0cmlnZ2VyKCdjbHJFeHBhbmQnLCBbXG4gICAgICBzdGF0ZShFWFBBTkRFRF9TVEFURSwgc3R5bGUoeyBoZWlnaHQ6ICcqJyB9KSksXG4gICAgICBzdGF0ZShDT0xMQVBTRURfU1RBVEUsIHN0eWxlKHsgaGVpZ2h0OiAwLCAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nLCB2aXNpYmlsaXR5OiAnaGlkZGVuJyB9KSksXG4gICAgICB0cmFuc2l0aW9uKGAke0VYUEFOREVEX1NUQVRFfSA8PT4gJHtDT0xMQVBTRURfU1RBVEV9YCwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpKSxcbiAgICBdKSxcbiAgXSxcbiAgaG9zdDogeyBjbGFzczogJ25hdi1ncm91cCcgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZHcm91cCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX2l0ZW1FeHBhbmQ6IEV4cGFuZCxcbiAgICBwcml2YXRlIF9uYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2U6IFZlcnRpY2FsTmF2R3JvdXBSZWdpc3RyYXRpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgX25hdkdyb3VwU2VydmljZTogVmVydGljYWxOYXZHcm91cFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfbmF2U2VydmljZTogVmVydGljYWxOYXZTZXJ2aWNlLFxuICAgIHB1YmxpYyBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzXG4gICkge1xuICAgIHRoaXMuX25hdkdyb3VwUmVnaXN0cmF0aW9uU2VydmljZS5yZWdpc3Rlck5hdkdyb3VwKCk7XG5cbiAgICAvLyBGSVhNRTogVGhpcyBzdWJzY3JpcHRpb24gaGFuZGxlcyBhIGNvcm5lciBjYXNlXG4gICAgLy8gVmVydGljYWwgTmF2IGNvbGxhcHNlIHJlcXVpcmVzIHRoZSBhbmltYXRpb24gdG8gcnVuIGZpcnN0IGFuZCB0aGVuXG4gICAgLy8gcmVtb3ZlIHRoZSBub2RlcyBmcm9tIHRoZSBET00uIElmIHRoZSB1c2VyIGRpcmVjdGx5IHNldHMgdGhlIGlucHV0XG4gICAgLy8gb24gdGhlIGNscklmRXhwYW5kZWQgZGlyZWN0aXZlLCB3ZSBoYXZlIG5vIGNoYW5jZSB0byBydW4gdGhlIGFuaW1hdGlvblxuICAgIC8vIGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZS4gVGhpcyBzdWJzY3JpcHRpb24gbWFrZXMgc3VyZSB0aGF0IHRoZVxuICAgIC8vIGFuaW1hdGlvbiBzdGF0ZXMgYXJlIGNvcnJlY3QgZm9yIHRoYXQgZWRnZSBjYXNlLlxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX2l0ZW1FeHBhbmQuZXhwYW5kQ2hhbmdlLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID09PSBDT0xMQVBTRURfU1RBVEUpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdlNlcnZpY2UuY29sbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSBFWFBBTkRFRF9TVEFURTtcbiAgICAgICAgfSBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5leHBhbmRBbmltYXRpb25TdGF0ZSA9PT0gRVhQQU5ERURfU1RBVEUpIHtcbiAgICAgICAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyAxLiBJZiB0aGUgbmF2IGlzIGNvbGxhcHNpbmcsIGNsb3NlIHRoZSBvcGVuIG5hdiBncm91cCArIHNhdmUgaXRzIHN0YXRlXG4gICAgLy8gMi4gSWYgdGhlIG5hdiBpcyBleHBhbmRpbmcsIGV4cGFuZCB0aGUgbmF2IGdyb3VwIGlmIHRoZSBwcmV2aW91cyBzdGF0ZSB3YXMgZXhwYW5kZWRcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLl9uYXZTZXJ2aWNlLmFuaW1hdGVPbkNvbGxhcHNlZC5zdWJzY3JpYmUoKGdvaW5nVG9Db2xsYXBzZTogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoZ29pbmdUb0NvbGxhcHNlICYmIHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICB0aGlzLndhc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICAgICAgICB9IGVsc2UgaWYgKCFnb2luZ1RvQ29sbGFwc2UgJiYgdGhpcy53YXNFeHBhbmRlZCkge1xuICAgICAgICAgIHRoaXMuZXhwYW5kR3JvdXAoKTtcbiAgICAgICAgICB0aGlzLndhc0V4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcblxuICAgIC8vIElmIGEgbGluayBpcyBjbGlja2VkLCBleHBhbmQgdGhlIG5hdiBncm91cFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuX25hdkdyb3VwU2VydmljZS5leHBhbmRDaGFuZ2Uuc3Vic2NyaWJlKChleHBhbmQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGV4cGFuZCAmJiAhdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgIHRoaXMuZXhwYW5kR3JvdXAoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSB3YXNFeHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBIb3N0QmluZGluZygnY2xhc3MuaXMtZXhwYW5kZWQnKVxuICBnZXQgZXhwYW5kZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1FeHBhbmQuZXhwYW5kZWQ7XG4gIH1cblxuICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5faXRlbUV4cGFuZC5leHBhbmRlZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuX2l0ZW1FeHBhbmQuZXhwYW5kZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgQElucHV0KCdjbHJWZXJ0aWNhbE5hdkdyb3VwRXhwYW5kZWQnKVxuICBzZXQgdXNlckV4cGFuZGVkSW5wdXQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB2YWx1ZSA9ICEhdmFsdWU7XG4gICAgaWYgKHRoaXMuZXhwYW5kZWQgIT09IHZhbHVlKSB7XG4gICAgICAvLyBXZSBoYXZlIHRvIGNhbGwgdG9nZ2xlRXhwYW5kIGJlY2F1c2Ugc29tZSBjYXNlcyByZXF1aXJlIGFuaW1hdGlvbnMgdG8gb2NjdXIgZmlyc3RcbiAgICAgIC8vIERpcmVjdGx5IHNldHRpbmcgdGhlIEV4cGFuZCBzZXJ2aWNlIHZhbHVlIHNraXBzIHRoZSBhbmltYXRpb24gYW5kIGNhbiByZXN1bHQgaW5cbiAgICAgIC8vIG5vZGVzIGluIHRoZSBET00gYnV0IHRoZSBuYXYgZ3JvdXAgc3RpbGwgYmVpbmcgY29sbGFwc2VkXG4gICAgICB0aGlzLnRvZ2dsZUV4cGFuZCgpO1xuICAgIH1cbiAgfVxuXG4gIEBPdXRwdXQoJ2NsclZlcnRpY2FsTmF2R3JvdXBFeHBhbmRlZENoYW5nZScpIGV4cGFuZGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgcHJpdmF0ZSBfZXhwYW5kQW5pbWF0aW9uU3RhdGU6IHN0cmluZyA9IENPTExBUFNFRF9TVEFURTtcblxuICBleHBhbmRHcm91cCgpOiB2b2lkIHtcbiAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAvLyBFeHBhbmRlZCBhbmltYXRpb24gb2NjdXJzIGFmdGVyIEV4cGFuZC5leHBhbmQgaXMgc2V0IHRvIHRydWVcbiAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gRVhQQU5ERURfU1RBVEU7XG4gIH1cblxuICBjb2xsYXBzZUdyb3VwKCk6IHZvaWQge1xuICAgIC8vIElmIGEgVmVydGljYWwgTmF2IEdyb3VwIHRvZ2dsZSBidXR0b24gaXMgY2xpY2tlZCB3aGlsZSB0aGUgVmVydGljYWwgTmF2IGlzIGluIENvbGxhcHNlZCBzdGF0ZSxcbiAgICAvLyB0aGUgVmVydGljYWwgTmF2IHNob3VsZCBiZSBleHBhbmRlZCBmaXJzdC5cbiAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICB9XG5cbiAgLy8gY2xvc2VzIGEgZ3JvdXAgYWZ0ZXIgdGhlIGNvbGxhcHNlIGFuaW1hdGlvblxuICBleHBhbmRBbmltYXRpb25Eb25lKCRldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICBpZiAoJGV2ZW50LnRvU3RhdGUgPT09IENPTExBUFNFRF9TVEFURSkge1xuICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGdldCBleHBhbmRBbmltYXRpb25TdGF0ZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9leHBhbmRBbmltYXRpb25TdGF0ZTtcbiAgfVxuXG4gIHNldCBleHBhbmRBbmltYXRpb25TdGF0ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLl9leHBhbmRBbmltYXRpb25TdGF0ZSkge1xuICAgICAgdGhpcy5fZXhwYW5kQW5pbWF0aW9uU3RhdGUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVFeHBhbmQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgIHRoaXMuY29sbGFwc2VHcm91cCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBuYXYgaXMgY29sbGFzcGVkLCBmaXJzdCBvcGVuIHRoZSBuYXZcbiAgICAgIGlmICh0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLl9uYXZTZXJ2aWNlLmNvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gdGhlbiBleHBhbmQgdGhlIG5hdiBncm91cFxuICAgICAgdGhpcy5leHBhbmRHcm91cCgpO1xuICAgIH1cbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBpZiBzb21lb25lIG1hcmtzIGEgbmF2IGdyb3VwIGV4cGFuZGVkIGluIGEgY29sbGFwc2VkIG5hdlxuICAgIC8vIHRoZSBleHBhbmRlZCBwcm9wZXJ0eSBpcyBzd2l0Y2hlZCBiYWNrIHRvIGNvbGxhcHNlZCBzdGF0ZS5cbiAgICBpZiAodGhpcy5fbmF2U2VydmljZS5jb2xsYXBzZWQgJiYgdGhpcy5leHBhbmRlZCkge1xuICAgICAgdGhpcy53YXNFeHBhbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLmV4cGFuZEFuaW1hdGlvblN0YXRlID0gQ09MTEFQU0VEX1NUQVRFO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaCgoc3ViOiBTdWJzY3JpcHRpb24pID0+IHN1Yi51bnN1YnNjcmliZSgpKTtcbiAgICB0aGlzLl9uYXZHcm91cFJlZ2lzdHJhdGlvblNlcnZpY2UudW5yZWdpc3Rlck5hdkdyb3VwKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci12ZXJ0aWNhbC1uYXYtZ3JvdXAtY2hpbGRyZW4nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgYCxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZHcm91cENoaWxkcmVuIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmVydGljYWxOYXZJY29uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3ZlcnRpY2FsLW5hdi1pY29uLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyVmVydGljYWxOYXZJY29uXScsIGhvc3Q6IHsgY2xhc3M6ICduYXYtaWNvbicgfSB9KVxuZXhwb3J0IGNsYXNzIENsclZlcnRpY2FsTmF2SWNvbiBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3ZlcnRpY2FsTmF2SWNvblNlcnZpY2U6IFZlcnRpY2FsTmF2SWNvblNlcnZpY2UpIHtcbiAgICB0aGlzLl92ZXJ0aWNhbE5hdkljb25TZXJ2aWNlLnJlZ2lzdGVySWNvbigpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5fdmVydGljYWxOYXZJY29uU2VydmljZS51bnJlZ2lzdGVySWNvbigpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEhvc3RMaXN0ZW5lciwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvdmVydGljYWwtbmF2LWdyb3VwLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdbY2xyVmVydGljYWxOYXZMaW5rXScsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltjbHJWZXJ0aWNhbE5hdkljb25dXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8c3BhbiBjbGFzcz1cIm5hdi10ZXh0XCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+ICAgIFxuICAgICAgICA8L3NwYW4+XG4gICAgYCxcbiAgaG9zdDogeyBjbGFzczogJ25hdi1saW5rJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJWZXJ0aWNhbE5hdkxpbmsge1xuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcml2YXRlIF9uYXZHcm91cFNlcnZpY2U6IFZlcnRpY2FsTmF2R3JvdXBTZXJ2aWNlKSB7fVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgcHVibGljIGV4cGFuZFBhcmVudE5hdkdyb3VwKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9uYXZHcm91cFNlcnZpY2UpIHtcbiAgICAgIHRoaXMuX25hdkdyb3VwU2VydmljZS5leHBhbmQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckljb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENscklmRXhwYW5kTW9kdWxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvZXhwYW5kL2lmLWV4cGFuZC5tb2R1bGUnO1xuXG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdiB9IGZyb20gJy4vdmVydGljYWwtbmF2JztcbmltcG9ydCB7IENsclZlcnRpY2FsTmF2R3JvdXAgfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi1ncm91cCc7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdkdyb3VwQ2hpbGRyZW4gfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi1ncm91cC1jaGlsZHJlbic7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdkljb24gfSBmcm9tICcuL3ZlcnRpY2FsLW5hdi1pY29uJztcbmltcG9ydCB7IENsclZlcnRpY2FsTmF2TGluayB9IGZyb20gJy4vdmVydGljYWwtbmF2LWxpbmsnO1xuXG5leHBvcnQgY29uc3QgQ0xSX1ZFUlRJQ0FMX05BVl9ESVJFQ1RJVkVTOiBUeXBlPGFueT5bXSA9IFtcbiAgQ2xyVmVydGljYWxOYXYsXG4gIENsclZlcnRpY2FsTmF2TGluayxcbiAgQ2xyVmVydGljYWxOYXZHcm91cCxcbiAgQ2xyVmVydGljYWxOYXZHcm91cENoaWxkcmVuLFxuICBDbHJWZXJ0aWNhbE5hdkljb24sXG5dO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJJZkV4cGFuZE1vZHVsZV0sXG4gIGRlY2xhcmF0aW9uczogW0NMUl9WRVJUSUNBTF9OQVZfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfVkVSVElDQUxfTkFWX0RJUkVDVElWRVMsIENscklmRXhwYW5kTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVmVydGljYWxOYXZNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsck1haW5Db250YWluZXJNb2R1bGUgfSBmcm9tICcuL21haW4tY29udGFpbmVyL21haW4tY29udGFpbmVyLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJOYXZpZ2F0aW9uTW9kdWxlIH0gZnJvbSAnLi9uYXYvbmF2aWdhdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyVGFic01vZHVsZSB9IGZyb20gJy4vdGFicy90YWJzLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJWZXJ0aWNhbE5hdk1vZHVsZSB9IGZyb20gJy4vdmVydGljYWwtbmF2L3ZlcnRpY2FsLW5hdi5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoeyBleHBvcnRzOiBbQ2xyTWFpbkNvbnRhaW5lck1vZHVsZSwgQ2xyTmF2aWdhdGlvbk1vZHVsZSwgQ2xyVGFic01vZHVsZSwgQ2xyVmVydGljYWxOYXZNb2R1bGVdIH0pXG5leHBvcnQgY2xhc3MgQ2xyTGF5b3V0TW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNjcm9sbGluZ1NlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55KSB7fVxuXG4gIHN0b3BTY3JvbGxpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCduby1zY3JvbGxpbmcnKTtcbiAgfVxuXG4gIHJlc3VtZVNjcm9sbGluZygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuY29udGFpbnMoJ25vLXNjcm9sbGluZycpKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ25vLXNjcm9sbGluZycpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uRXZlbnQsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEV2ZW50RW1pdHRlcixcbiAgSG9zdEJpbmRpbmcsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5wdXQsXG4gIE9uQ2hhbmdlcyxcbiAgT25EZXN0cm95LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZSxcbiAgVmlld0NoaWxkLFxuICBJbmplY3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGb2N1c1RyYXBEaXJlY3RpdmUgfSBmcm9tICcuLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNjcm9sbGluZ1NlcnZpY2UgfSBmcm9tICcuLi91dGlscy9zY3JvbGxpbmcvc2Nyb2xsaW5nLXNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFVOSVFVRV9JRCwgVU5JUVVFX0lEX1BST1ZJREVSIH0gZnJvbSAnLi4vdXRpbHMvaWQtZ2VuZXJhdG9yL2lkLWdlbmVyYXRvci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLW1vZGFsJyxcbiAgdmlld1Byb3ZpZGVyczogW1Njcm9sbGluZ1NlcnZpY2VdLFxuICB0ZW1wbGF0ZVVybDogJy4vbW9kYWwuaHRtbCcsXG4gIHN0eWxlczogW1xuICAgIGBcbiAgICAgICAgOmhvc3QgeyBkaXNwbGF5OiBub25lOyB9XG4gICAgICAgIDpob3N0Lm9wZW4geyBkaXNwbGF5OiBpbmxpbmU7IH1cbiAgICBgLFxuICBdLFxuICBhbmltYXRpb25zOiBbXG4gICAgdHJpZ2dlcignZmFkZURvd24nLCBbXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IGZhbHNlJywgW3N0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsIC0yNSUpJyB9KSwgYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcpXSksXG4gICAgICB0cmFuc2l0aW9uKCdmYWxzZSA9PiAqJywgW2FuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLCAtMjUlKScgfSkpXSksXG4gICAgXSksXG4gICAgdHJpZ2dlcignZmFkZScsIFtcbiAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gKicsIFtzdHlsZSh7IG9wYWNpdHk6IDAgfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnLCBzdHlsZSh7IG9wYWNpdHk6IDAuODUgfSkpXSksXG4gICAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbYW5pbWF0ZSgnMC4ycyBlYXNlLWluLW91dCcsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSldKSxcbiAgICBdKSxcbiAgXSxcbiAgcHJvdmlkZXJzOiBbVU5JUVVFX0lEX1BST1ZJREVSXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyTW9kYWwgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIEBWaWV3Q2hpbGQoRm9jdXNUcmFwRGlyZWN0aXZlKSBmb2N1c1RyYXA6IEZvY3VzVHJhcERpcmVjdGl2ZTtcblxuICBASG9zdEJpbmRpbmcoJ2NsYXNzLm9wZW4nKVxuICBASW5wdXQoJ2Nsck1vZGFsT3BlbicpXG4gIF9vcGVuOiBib29sZWFuID0gZmFsc2U7XG4gIEBPdXRwdXQoJ2Nsck1vZGFsT3BlbkNoYW5nZScpIF9vcGVuQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgQElucHV0KCdjbHJNb2RhbENsb3NhYmxlJykgY2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoJ2Nsck1vZGFsU2l6ZScpIHNpemU6IHN0cmluZztcbiAgQElucHV0KCdjbHJNb2RhbFN0YXRpY0JhY2tkcm9wJykgc3RhdGljQmFja2Ryb3A6IGJvb2xlYW4gPSB0cnVlO1xuICBASW5wdXQoJ2Nsck1vZGFsU2tpcEFuaW1hdGlvbicpIHNraXBBbmltYXRpb246IHN0cmluZyA9ICdmYWxzZSc7XG5cbiAgLy8gcHJlc2VudGx5IHRoaXMgaXMgb25seSB1c2VkIGJ5IHdpemFyZHNcbiAgQElucHV0KCdjbHJNb2RhbE92ZXJyaWRlU2Nyb2xsU2VydmljZScpIGJ5cGFzc1Njcm9sbFNlcnZpY2U6IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCdjbHJNb2RhbFByZXZlbnRDbG9zZScpIHN0b3BDbG9zZTogYm9vbGVhbiA9IGZhbHNlO1xuICBAT3V0cHV0KCdjbHJNb2RhbEFsdGVybmF0ZUNsb3NlJykgYWx0Q2xvc2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3Njcm9sbGluZ1NlcnZpY2U6IFNjcm9sbGluZ1NlcnZpY2UsXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3MsXG4gICAgQEluamVjdChVTklRVUVfSUQpIHB1YmxpYyBtb2RhbElkOiBzdHJpbmdcbiAgKSB7fVxuXG4gIGdldCBzaXplQ2xhc3MoKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICByZXR1cm4gJ21vZGFsLScgKyB0aGlzLnNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICAvLyBEZXRlY3Qgd2hlbiBfb3BlbiBpcyBzZXQgdG8gdHJ1ZSBhbmQgc2V0IG5vLXNjcm9sbGluZyB0byB0cnVlXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5ieXBhc3NTY3JvbGxTZXJ2aWNlICYmIGNoYW5nZXMgJiYgY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnX29wZW4nKSkge1xuICAgICAgaWYgKGNoYW5nZXMuX29wZW4uY3VycmVudFZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbGluZ1NlcnZpY2Uuc3RvcFNjcm9sbGluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsaW5nU2VydmljZS5yZXN1bWVTY3JvbGxpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zY3JvbGxpbmdTZXJ2aWNlLnJlc3VtZVNjcm9sbGluZygpO1xuICB9XG5cbiAgb3BlbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fb3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vcGVuID0gdHJ1ZTtcbiAgICB0aGlzLl9vcGVuQ2hhbmdlZC5lbWl0KHRydWUpO1xuICB9XG5cbiAgQEhvc3RMaXN0ZW5lcignYm9keTprZXl1cC5lc2NhcGUnKVxuICBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdG9wQ2xvc2UpIHtcbiAgICAgIHRoaXMuYWx0Q2xvc2UuZW1pdChmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5jbG9zYWJsZSB8fCAhdGhpcy5fb3Blbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgLy8gdG9kbzogcmVtb3ZlIHRoaXMgYWZ0ZXIgYW5pbWF0aW9uIGJ1ZyBpcyBmaXhlZCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xNTc5OFxuICAgIC8vIHRoaXMgd2FzIGhhbmRsZWQgYnkgdGhlIGZhZGVEb25lIGV2ZW50IGJlbG93LCBidXQgdGhhdCBBbmltYXRpb25FdmVudCBpcyBub3QgZmlyaW5nIGluIEFuZ3VsYXIgNC4wLlxuICAgIHRoaXMuX29wZW5DaGFuZ2VkLmVtaXQoZmFsc2UpO1xuICAgIC8vIFNQRUNNRVxuICAgIHRoaXMuZm9jdXNUcmFwLnNldFByZXZpb3VzRm9jdXMoKTsgLy8gSGFuZGxlcyBtb3ZpbmcgZm9jdXMgYmFjayB0byB0aGUgZWxlbWVudCB0aGF0IGhhZCBpdCBiZWZvcmUuXG4gIH1cblxuICBmYWRlRG9uZShlOiBBbmltYXRpb25FdmVudCkge1xuICAgIGlmIChlLnRvU3RhdGUgPT09ICd2b2lkJykge1xuICAgICAgdGhpcy5fb3BlbkNoYW5nZWQuZW1pdChmYWxzZSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJGb2N1c1RyYXBNb2R1bGUgfSBmcm9tICcuLi91dGlscy9mb2N1cy10cmFwL2ZvY3VzLXRyYXAubW9kdWxlJztcbmltcG9ydCB7IENsck1vZGFsIH0gZnJvbSAnLi9tb2RhbCc7XG5cbmV4cG9ydCBjb25zdCBDTFJfTU9EQUxfRElSRUNUSVZFUzogVHlwZTxhbnk+W10gPSBbQ2xyTW9kYWxdO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBDbHJJY29uTW9kdWxlLCBDbHJGb2N1c1RyYXBNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfTU9EQUxfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfTU9EQUxfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENsck1vZGFsTW9kdWxlIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBQb2ludCB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyJztcblxuZXhwb3J0IGludGVyZmFjZSBQb3NpdGlvbiB7XG4gIGFuY2hvclBvaW50OiBQb2ludDtcbiAgcG9wb3ZlclBvaW50OiBQb2ludDtcbiAgb2Zmc2V0WTogbnVtYmVyO1xuICBvZmZzZXRYOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjb25zdCBTSUdOUE9TVF9QT1NJVElPTlM6IHsgW2lucHV0OiBzdHJpbmddOiBQb3NpdGlvbiB9ID0ge1xuICAndG9wLWxlZnQnOiB7IGFuY2hvclBvaW50OiBQb2ludC5UT1BfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkJPVFRPTV9SSUdIVCwgb2Zmc2V0WTogLTEwLCBvZmZzZXRYOiAwIH0sXG4gICd0b3AtbWlkZGxlJzogeyBhbmNob3JQb2ludDogUG9pbnQuVE9QX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5CT1RUT01fQ0VOVEVSLCBvZmZzZXRZOiAtMTAsIG9mZnNldFg6IDAgfSxcbiAgJ3RvcC1yaWdodCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LlRPUF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuQk9UVE9NX0xFRlQsIG9mZnNldFk6IC0xMCwgb2Zmc2V0WDogMCB9LFxuICAncmlnaHQtdG9wJzogeyBhbmNob3JQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkxFRlRfQk9UVE9NLCBvZmZzZXRZOiAyLCBvZmZzZXRYOiAxNCB9LFxuICAncmlnaHQtbWlkZGxlJzogeyBhbmNob3JQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkxFRlRfQ0VOVEVSLCBvZmZzZXRZOiA2LCBvZmZzZXRYOiAxNCB9LFxuICAncmlnaHQtYm90dG9tJzogeyBhbmNob3JQb2ludDogUG9pbnQuUklHSFRfQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LkxFRlRfVE9QLCBvZmZzZXRZOiAtMSwgb2Zmc2V0WDogMTQgfSxcbiAgJ2JvdHRvbS1yaWdodCc6IHsgYW5jaG9yUG9pbnQ6IFBvaW50LkJPVFRPTV9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuVE9QX0xFRlQsIG9mZnNldFk6IDksIG9mZnNldFg6IC0xIH0sXG4gICdib3R0b20tbWlkZGxlJzogeyBhbmNob3JQb2ludDogUG9pbnQuQk9UVE9NX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5UT1BfQ0VOVEVSLCBvZmZzZXRZOiA5LCBvZmZzZXRYOiAxMiB9LFxuICAnYm90dG9tLWxlZnQnOiB7IGFuY2hvclBvaW50OiBQb2ludC5CT1RUT01fQ0VOVEVSLCBwb3BvdmVyUG9pbnQ6IFBvaW50LlRPUF9SSUdIVCwgb2Zmc2V0WTogOSwgb2Zmc2V0WDogMCB9LFxuICAnbGVmdC1ib3R0b20nOiB7IGFuY2hvclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5SSUdIVF9UT1AsIG9mZnNldFk6IDAsIG9mZnNldFg6IC0xNCB9LFxuICAnbGVmdC1taWRkbGUnOiB7IGFuY2hvclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5SSUdIVF9DRU5URVIsIG9mZnNldFk6IDQsIG9mZnNldFg6IC0xNCB9LFxuICAnbGVmdC10b3AnOiB7IGFuY2hvclBvaW50OiBQb2ludC5MRUZUX0NFTlRFUiwgcG9wb3ZlclBvaW50OiBQb2ludC5SSUdIVF9CT1RUT00sIG9mZnNldFk6IDAsIG9mZnNldFg6IC0xNCB9LFxuICBkZWZhdWx0OiB7IGFuY2hvclBvaW50OiBQb2ludC5SSUdIVF9DRU5URVIsIHBvcG92ZXJQb2ludDogUG9pbnQuTEVGVF9DRU5URVIsIG9mZnNldFk6IDYsIG9mZnNldFg6IDE0IH0sXG59O1xuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdG9yLCBJbnB1dCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vY29tbW9uL2Fic3RyYWN0LXBvcG92ZXInO1xuaW1wb3J0IHsgUE9QT1ZFUl9IT1NUX0FOQ0hPUiB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLWhvc3QtYW5jaG9yLnRva2VuJztcblxuaW1wb3J0IHsgU0lHTlBPU1RfUE9TSVRJT05TIH0gZnJvbSAnLi9zaWducG9zdC1wb3NpdGlvbnMnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uU3RyaW5ncyB9IGZyb20gJy4uLy4uL3V0aWxzL2kxOG4vY29tbW9uLXN0cmluZ3MuaW50ZXJmYWNlJztcblxuLy8gYWthIHdoZXJlIHRoZSBhcnJvdyAvIHBvaW50ZXIgaXMgYXQgaW4gcmVsYXRpb24gdG8gdGhlIGFuY2hvclxuY29uc3QgUE9TSVRJT05TOiBzdHJpbmdbXSA9IFtcbiAgJ3RvcC1sZWZ0JyxcbiAgJ3RvcC1taWRkbGUnLFxuICAndG9wLXJpZ2h0JyxcbiAgJ3JpZ2h0LXRvcCcsXG4gICdyaWdodC1taWRkbGUnLCAvLyBkZWZhdWx0XG4gICdyaWdodC1ib3R0b20nLFxuICAnYm90dG9tLXJpZ2h0JyxcbiAgJ2JvdHRvbS1taWRkbGUnLFxuICAnYm90dG9tLWxlZnQnLFxuICAnbGVmdC1ib3R0b20nLFxuICAnbGVmdC1taWRkbGUnLFxuICAnbGVmdC10b3AnLFxuXTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXNpZ25wb3N0LWNvbnRlbnQnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2IGNsYXNzPVwic2lnbnBvc3QtZmxleC13cmFwXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3Zlci1wb2ludGVyXCI+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2lnbnBvc3QtY29udGVudC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cInNpZ25wb3N0LWFjdGlvbiBjbG9zZVwiIChjbGljayk9XCJjbG9zZSgpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxjbHItaWNvbiBzaGFwZT1cImNsb3NlXCIgW2F0dHIudGl0bGVdPVwiY29tbW9uU3RyaW5ncy5jbG9zZVwiPjwvY2xyLWljb24+XG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzaWducG9zdC1jb250ZW50LWJvZHlcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgaG9zdDogeyAnW2NsYXNzLnNpZ25wb3N0LWNvbnRlbnRdJzogJ3RydWUnIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsclNpZ25wb3N0Q29udGVudCBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoUE9QT1ZFUl9IT1NUX0FOQ0hPUilcbiAgICBwYXJlbnRIb3N0OiBFbGVtZW50UmVmLFxuICAgIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NcbiAgKSB7XG4gICAgaWYgKCFwYXJlbnRIb3N0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsci1zaWducG9zdC1jb250ZW50IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLXNpZ25wb3N0Jyk7XG4gICAgfVxuICAgIHN1cGVyKGluamVjdG9yLCBwYXJlbnRIb3N0KTtcbiAgICB0aGlzLmNvbW1vblN0cmluZ3MgPSBjb21tb25TdHJpbmdzO1xuICAgIC8vIERlZmF1bHRzXG4gICAgdGhpcy5wb3NpdGlvbiA9ICdyaWdodC1taWRkbGUnO1xuICAgIHRoaXMuY2xvc2VPbk91dHNpZGVDbGljayA9IHRydWU7XG4gIH1cblxuICBjb21tb25TdHJpbmdzOiBDbHJDb21tb25TdHJpbmdzO1xuXG4gIC8qKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDbG9zZSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhlIHNpZ25wb3N0IGluc3RhbmNlIHRvIHRvZ2dsZSB0aGUgc3RhdGUgb2YgdGhlIGNvbnRlbnQgcG9wb3Zlci5cbiAgICpcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIF9wb3NpdGlvbjogc3RyaW5nO1xuXG4gIGdldCBwb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gIH1cblxuICAvKioqKioqKioqXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBIHNldHRlciBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSBDbHJTaWducG9zdENvbnRlbnQgcG9wb3Zlci4gVGhpcyBpcyBhIGNvbWJpbmF0aW9uIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqIC0gYW5jaG9yUG9pbnQgLSB3aGVyZSBvbiB0aGUgdHJpZ2dlciB0byBhbmNob3IgdGhlIENsclNpZ25wb3N0Q29udGVudFxuICAgKiAtIHBvcG92ZXJQb2ludCAtIHdoZXJlIG9uIHRoZSBDbHJTaWducG9zdENvbnRlbnQgY29udGFpbmVyIHRvIGFsaWduIHdpdGggdGhlIGFuY2hvclBvaW50XG4gICAqIC0gb2Zmc2V0WSAtIHdoZXJlIG9uIHRoZSBZIGF4aXMgdG8gYWxpZ24gdGhlIENsclNpZ25wb3N0Q29udGVudCBzbyBpdCBtZWV0cyBzcGVjc1xuICAgKiAtIG9mZnNldFggLSB3aGVyZSBvbiB0aGUgWCBheGlzIHRvIGFsaWduIHRoZSBDbHJTaWducG9zdENvbnRlbnQgc28gaXQgbWVldHMgc3BlY3NcbiAgICogVGhlcmUgYXJlIDEyIHBvc3NpYmxlIHBvc2l0aW9ucyB0byBwbGFjZSBhIENsclNpZ25wb3N0Q29udGVudCBjb250YWluZXI6XG4gICAqIC0gdG9wLWxlZnRcbiAgICogLSB0b3AtbWlkZGxlXG4gICAqIC0gdG9wLXJpZ2h0XG4gICAqIC0gcmlnaHQtdG9wXG4gICAqIC0gcmlnaHQtbWlkZGxlXG4gICAqIC0gcmlnaHQtYm90dG9tXG4gICAqIC0gYm90dG9tLXJpZ2h0XG4gICAqIC0gYm90dG9tLW1pZGRsZVxuICAgKiAtIGJvdHRvbS1sZWZ0XG4gICAqIC0gbGVmdC1ib3R0b21cbiAgICogLSBsZWZ0LW1pZGRsZVxuICAgKiAtIGxlZnQtdG9wXG4gICAqXG4gICAqIEkgdGhpbmsgb2YgaXQgYXMgZm9sbG93cyBmb3IgJ3RvcC1sZWZ0JyAtPiBDT05UQUlORVJfU0lERS1TSURFX1BPU0lUSU9OLiBJbiB0aGlzIGNhc2UgQ09OVEFJTkVSX1NJREUgaXMgJ3RvcCdcbiAgICogbWVhbmluZyB0aGUgdG9wIG9mIHRoZSB0cmlnZ2VyIGljb24gKGFib3ZlIHRoZSBpY29uIHRoYXQgaGlkZXMvc2hvd3MpIHRoZSBDbHJTaWducG9zdENvbnRlbnQuIEFuZCwgU0lERV9QT1NJVElPTlxuICAgKiBpcyAnbGVmdCcgbWVhbmluZyB0d28gdGhpbmdzOiAxKSB0aGUgQ2xyU2lnbnBvc3RDb250ZW50IGNvbnRhaW5lciBleHRlbmRzIHRvIHRoZSBsZWZ0IGFuZCAyKSB0aGUgJ2Fycm93L3BvaW50ZXInXG4gICAqIGxpbmtpbmcgdGhlIFNpbmdwb3N0Q29udGVudCB0byB0aGUgdHJpZ2dlciBwb2ludHMgZG93biBhdCB0aGUgaG9yaXpvbnRhbCBjZW50ZXIgb2YgdGhlIHRyaWdnZXIgaWNvbi5cbiAgICpcbiAgICogQHBhcmFtIG5ld1Bvc2l0aW9uXG4gICAqL1xuICBASW5wdXQoJ2NsclBvc2l0aW9uJylcbiAgc2V0IHBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpIHtcbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5wb3NpdGlvbik7XG4gICAgaWYgKHBvc2l0aW9uICYmIFBPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA+IC0xKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9ICdyaWdodC1taWRkbGUnO1xuICAgIH1cbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgdGhpcy5wb3NpdGlvbik7XG5cbiAgICBjb25zdCBzZXRQb3NpdGlvbiA9IFNJR05QT1NUX1BPU0lUSU9OU1t0aGlzLnBvc2l0aW9uXTtcbiAgICB0aGlzLmFuY2hvclBvaW50ID0gc2V0UG9zaXRpb24uYW5jaG9yUG9pbnQ7XG4gICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBzZXRQb3NpdGlvbi5wb3BvdmVyUG9pbnQ7XG4gICAgdGhpcy5wb3BvdmVyT3B0aW9ucy5vZmZzZXRZID0gc2V0UG9zaXRpb24ub2Zmc2V0WTtcbiAgICB0aGlzLnBvcG92ZXJPcHRpb25zLm9mZnNldFggPSBzZXRQb3NpdGlvbi5vZmZzZXRYO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi4vLi4vaWNvbi9pY29uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb25kaXRpb25hbE1vZHVsZSB9IGZyb20gJy4uLy4uL3V0aWxzL2NvbmRpdGlvbmFsL2NvbmRpdGlvbmFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJDb21tb25Qb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXIubW9kdWxlJztcblxuaW1wb3J0IHsgQ2xyU2lnbnBvc3QgfSBmcm9tICcuL3NpZ25wb3N0JztcbmltcG9ydCB7IENsclNpZ25wb3N0Q29udGVudCB9IGZyb20gJy4vc2lnbnBvc3QtY29udGVudCc7XG5pbXBvcnQgeyBDbHJTaWducG9zdFRyaWdnZXIgfSBmcm9tICcuL3NpZ25wb3N0LXRyaWdnZXInO1xuXG5leHBvcnQgY29uc3QgQ0xSX1NJR05QT1NUX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsclNpZ25wb3N0LCBDbHJTaWducG9zdENvbnRlbnQsIENsclNpZ25wb3N0VHJpZ2dlcl07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckNvbW1vblBvcG92ZXJNb2R1bGUsIENsckljb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfU0lHTlBPU1RfRElSRUNUSVZFU10sXG4gIGV4cG9ydHM6IFtDTFJfU0lHTlBPU1RfRElSRUNUSVZFUywgQ2xyQ29uZGl0aW9uYWxNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJTaWducG9zdE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZk9wZW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvY29uZGl0aW9uYWwvaWYtb3Blbi5zZXJ2aWNlJztcbmltcG9ydCB7IFBPUE9WRVJfSE9TVF9BTkNIT1IgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlci1ob3N0LWFuY2hvci50b2tlbic7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Nsci10b29sdGlwJyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnRvb2x0aXBdJzogJ3RydWUnLFxuICB9LFxuICBwcm92aWRlcnM6IFtJZk9wZW5TZXJ2aWNlLCB7IHByb3ZpZGU6IFBPUE9WRVJfSE9TVF9BTkNIT1IsIHVzZUV4aXN0aW5nOiBFbGVtZW50UmVmIH1dLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUb29sdGlwIHt9XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5pbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0b3IsIElucHV0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RQb3BvdmVyIH0gZnJvbSAnLi4vY29tbW9uL2Fic3RyYWN0LXBvcG92ZXInO1xuaW1wb3J0IHsgUG9pbnQgfSBmcm9tICcuLi9jb21tb24vcG9wb3Zlcic7XG5pbXBvcnQgeyBQT1BPVkVSX0hPU1RfQU5DSE9SIH0gZnJvbSAnLi4vY29tbW9uL3BvcG92ZXItaG9zdC1hbmNob3IudG9rZW4nO1xuXG5jb25zdCBQT1NJVElPTlM6IHN0cmluZ1tdID0gWydib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ3JpZ2h0JywgJ2xlZnQnXTtcblxuY29uc3QgU0laRVM6IHN0cmluZ1tdID0gWyd4cycsICdzbScsICdtZCcsICdsZyddO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItdG9vbHRpcC1jb250ZW50JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLnRvb2x0aXAtY29udGVudF0nOiAndHJ1ZScsXG4gICAgLy8gSSdtIGdpdmluZyB1cCBvbiBhbmltYXRpb24sIHRoZXkgZGlkIG5vdCB3b3JrIGJlZm9yZSBhbmQgd2lsbCBub3Qgd29yayBub3cuXG4gICAgLy8gVG9vIG1hbnkgY29uZmxpY3RzIHdpdGggQ2xhcml0eSBVSS5cbiAgICAnW3N0eWxlLm9wYWNpdHldJzogJzEnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJUb29sdGlwQ29udGVudCBleHRlbmRzIEFic3RyYWN0UG9wb3ZlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoUE9QT1ZFUl9IT1NUX0FOQ0hPUilcbiAgICBwYXJlbnRIb3N0OiBFbGVtZW50UmVmXG4gICkge1xuICAgIGlmICghcGFyZW50SG9zdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbHItdG9vbHRpcC1jb250ZW50IHNob3VsZCBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGEgY2xyLXRvb2x0aXAnKTtcbiAgICB9XG4gICAgc3VwZXIoaW5qZWN0b3IsIHBhcmVudEhvc3QpO1xuICAgIC8vIERlZmF1bHRzXG4gICAgdGhpcy5wb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgdGhpcy5zaXplID0gJ3NtJztcbiAgfVxuXG4gIHByaXZhdGUgX3Bvc2l0aW9uOiBzdHJpbmc7XG5cbiAgZ2V0IHBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyUG9zaXRpb24nKVxuICBzZXQgcG9zaXRpb24ocG9zaXRpb246IHN0cmluZykge1xuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndG9vbHRpcC0nICsgdGhpcy5wb3NpdGlvbik7XG4gICAgaWYgKHBvc2l0aW9uICYmIFBPU0lUSU9OUy5pbmRleE9mKHBvc2l0aW9uKSA+IC0xKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbiA9ICdyaWdodCc7XG4gICAgfVxuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndG9vbHRpcC0nICsgdGhpcy5wb3NpdGlvbik7XG5cbiAgICAvLyBzZXQgdGhlIHBvcG92ZXIgdmFsdWVzIGJhc2VkIG9uIGRpcmVjdGlvblxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5UT1BfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlRPUF9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfQk9UVE9NO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgIHRoaXMuYW5jaG9yUG9pbnQgPSBQb2ludC5CT1RUT01fQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbS1sZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkJPVFRPTV9DRU5URVI7XG4gICAgICAgIHRoaXMucG9wb3ZlclBvaW50ID0gUG9pbnQuUklHSFRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LlJJR0hUX0NFTlRFUjtcbiAgICAgICAgdGhpcy5wb3BvdmVyUG9pbnQgPSBQb2ludC5MRUZUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGhpcy5hbmNob3JQb2ludCA9IFBvaW50LkxFRlRfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LlJJR0hUX1RPUDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmFuY2hvclBvaW50ID0gUG9pbnQuUklHSFRfQ0VOVEVSO1xuICAgICAgICB0aGlzLnBvcG92ZXJQb2ludCA9IFBvaW50LkxFRlRfVE9QO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9zaXplOiBzdHJpbmc7XG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cblxuICBASW5wdXQoJ2NsclNpemUnKVxuICBzZXQgc2l6ZShzaXplOiBzdHJpbmcpIHtcbiAgICAvLyBVZ2hcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3Rvb2x0aXAtJyArIHRoaXMuc2l6ZSk7XG4gICAgaWYgKHNpemUgJiYgU0laRVMuaW5kZXhPZihzaXplKSA+IC0xKSB7XG4gICAgICB0aGlzLl9zaXplID0gc2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2l6ZSA9ICdzbSc7XG4gICAgfVxuICAgIC8vIFVnaFxuICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndG9vbHRpcC0nICsgdGhpcy5zaXplKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElmT3BlblNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1vcGVuLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyVG9vbHRpcFRyaWdnZXJdJywgaG9zdDogeyAnW2F0dHIudGFiaW5kZXhdJzogJzAnLCAnW2NsYXNzLnRvb2x0aXAtdHJpZ2dlcl0nOiAndHJ1ZScgfSB9KVxuZXhwb3J0IGNsYXNzIENsclRvb2x0aXBUcmlnZ2VyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpZk9wZW5TZXJ2aWNlOiBJZk9wZW5TZXJ2aWNlKSB7fVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKVxuICBASG9zdExpc3RlbmVyKCdmb2N1cycpXG4gIHNob3dUb29sdGlwKCk6IHZvaWQge1xuICAgIHRoaXMuaWZPcGVuU2VydmljZS5vcGVuID0gdHJ1ZTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgaGlkZVRvb2x0aXAoKTogdm9pZCB7XG4gICAgdGhpcy5pZk9wZW5TZXJ2aWNlLm9wZW4gPSBmYWxzZTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xySWNvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29uZGl0aW9uYWxNb2R1bGUgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyQ29tbW9uUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL2NvbW1vbi9wb3BvdmVyLm1vZHVsZSc7XG5cbmltcG9ydCB7IENsclRvb2x0aXAgfSBmcm9tICcuL3Rvb2x0aXAnO1xuaW1wb3J0IHsgQ2xyVG9vbHRpcENvbnRlbnQgfSBmcm9tICcuL3Rvb2x0aXAtY29udGVudCc7XG5pbXBvcnQgeyBDbHJUb29sdGlwVHJpZ2dlciB9IGZyb20gJy4vdG9vbHRpcC10cmlnZ2VyJztcblxuZXhwb3J0IGNvbnN0IENMUl9UT09MVElQX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsclRvb2x0aXAsIENsclRvb2x0aXBUcmlnZ2VyLCBDbHJUb29sdGlwQ29udGVudF07XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIENsckNvbW1vblBvcG92ZXJNb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtDTFJfVE9PTFRJUF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9UT09MVElQX0RJUkVDVElWRVMsIENsckNvbmRpdGlvbmFsTW9kdWxlLCBDbHJJY29uTW9kdWxlXSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyVG9vbHRpcE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyRHJvcGRvd25Nb2R1bGUgfSBmcm9tICcuL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJTaWducG9zdE1vZHVsZSB9IGZyb20gJy4vc2lnbnBvc3Qvc2lnbnBvc3QubW9kdWxlJztcbmltcG9ydCB7IENsclRvb2x0aXBNb2R1bGUgfSBmcm9tICcuL3Rvb2x0aXAvdG9vbHRpcC5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoeyBleHBvcnRzOiBbQ2xyRHJvcGRvd25Nb2R1bGUsIENsclNpZ25wb3N0TW9kdWxlLCBDbHJUb29sdGlwTW9kdWxlXSB9KVxuZXhwb3J0IGNsYXNzIENsclBvcG92ZXJNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQnV0dG9uSHViU2VydmljZSB7XG4gIHB1YmxpYyBidXR0b25zUmVhZHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIF9wcmV2aW91c0J0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgcHJldmlvdXNCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX25leHRCdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IG5leHRCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRCdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZGFuZ2VyQnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBkYW5nZXJCdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhbmdlckJ0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwcml2YXRlIF9jYW5jZWxCdG5DbGlja2VkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICBwdWJsaWMgZ2V0IGNhbmNlbEJ0bkNsaWNrZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5fY2FuY2VsQnRuQ2xpY2tlZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZpbmlzaEJ0bkNsaWNrZWQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gIHB1YmxpYyBnZXQgZmluaXNoQnRuQ2xpY2tlZCgpOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hCdG5DbGlja2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfY3VzdG9tQnRuQ2xpY2tlZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgcHVibGljIGdldCBjdXN0b21CdG5DbGlja2VkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2N1c3RvbUJ0bkNsaWNrZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBwdWJsaWMgYnV0dG9uQ2xpY2tlZChidXR0b25UeXBlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoJ3ByZXZpb3VzJyA9PT0gYnV0dG9uVHlwZSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNCdG5DbGlja2VkLm5leHQoKTtcbiAgICB9IGVsc2UgaWYgKCduZXh0JyA9PT0gYnV0dG9uVHlwZSkge1xuICAgICAgdGhpcy5fbmV4dEJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJ2ZpbmlzaCcgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaEJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJ2RhbmdlcicgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX2RhbmdlckJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoJ2NhbmNlbCcgPT09IGJ1dHRvblR5cGUpIHtcbiAgICAgIHRoaXMuX2NhbmNlbEJ0bkNsaWNrZWQubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jdXN0b21CdG5DbGlja2VkLm5leHQoYnV0dG9uVHlwZSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi4vd2l6YXJkLXBhZ2UnO1xuXG4vKipcbiAqIFBhZ2VDb2xsZWN0aW9uU2VydmljZSBtYW5hZ2VzIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzIGFzc2lnbmVkIHRvIHRoZSB3aXphcmQgYW5kIG9mZmVyc1xuICogYSBudW1iZXIgb2YgZnVuY3Rpb25zIHVzZWZ1bCBhY3Jvc3MgdGhlIHdpemFyZHMgcHJvdmlkZXJzIGFuZCBzdWJjb21wb25lbnRzIC0tIGFsbCByZWxhdGVkXG4gKiB0byBlc3NlbnRpYWxseSBsb29rdXBzIG9uIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzLlxuICpcbiAqIFRoZSBlYXNpZXN0IHdheSB0byBhY2Nlc3MgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIGlzIHZpYSB0aGUgd2l6YXJkLiBUaGVcbiAqIGZvbGxvd2luZyBleGFtcGxlIHdvdWxkIGFsbG93IHlvdSB0byBhY2Nlc3MgeW91ciBpbnN0YW5jZSBvZiB0aGUgd2l6YXJkIGZyb20geW91ciBob3N0XG4gKiBjb21wb25lbnQgYW5kIHRoZXJlYnkgYWNjZXNzIHRoZSBwYWdlIGNvbGxlY3Rpb24gdmlhIFlvdXJIb3N0Q29tcG9uZW50LndpemFyZC5wYWdlQ29sbGVjdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGNsci13aXphcmQgI3dpemFyZCAuLi4+XG4gKlxuICogQGV4YW1wbGVcbiAqIGV4cG9ydCBjbGFzcyBZb3VySG9zdENvbXBvbmVudCB7XG4gKiAgIEBWaWV3Q2hpbGQoXCJ3aXphcmRcIikgd2l6YXJkOiBXaXphcmQ7XG4gKiAgIC4uLlxuICogfVxuICpcbiAqIFRoZSBoZWFydCBvZiB0aGUgcGFnZSBjb2xsZWN0aW9uIGlzIHRoZSBxdWVyeSBsaXN0IG9mIHBhZ2VzLCB3aGljaCBpdCBpcyBhc3NpZ25lZCBhcyBhXG4gKiByZWZlcmVuY2UgdG8gdGhlIFdpemFyZC5wYWdlcyBRdWVyeUxpc3Qgd2hlbiB0aGUgd2l6YXJkIGlzIGNyZWF0ZWQuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIHtcbiAgLyoqXG4gICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBXaXphcmQucGFnZXMgUXVlcnlMaXN0LlxuICAgKlxuICAgKiBQb3B1bGF0ZWQgd2hlbiB0aGUgd2l6YXJkIGlzIGNyZWF0ZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwYWdlczogUXVlcnlMaXN0PENscldpemFyZFBhZ2U+O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLnBhZ2VzIFF1ZXJ5TGlzdCB0byBhbiBhcnJheSBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogVXNlZnVsIGZvciBtYW55IGluc3RhbmNlcyB3aGVuIHlvdSB3b3VsZCBwcmVmZXIgYSBRdWVyeUxpc3QgdG8gYWN0IGxpa2UgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgcGFnZXNBc0FycmF5KCk6IENscldpemFyZFBhZ2VbXSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZXMgPyB0aGlzLnBhZ2VzLnRvQXJyYXkoKSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFnZXMgcXVlcnkgbGlzdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBwYWdlc0NvdW50KCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMucGFnZXMgPyB0aGlzLnBhZ2VzLmxlbmd0aCA6IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dC10by1sYXN0IHBhZ2UgaW4gdGhlIHF1ZXJ5IGxpc3Qgb2YgcGFnZXMuIE9wZXJhdGVzIGFzIGEgZ2V0dGVyXG4gICAqIHNvIHRoYXQgaXQgaXNuJ3Qgd29ya2luZyB3aXRoIHN0YWxlIGRhdGEuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgcGVudWx0aW1hdGVQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGNvbnN0IHBhZ2VDb3VudCA9IHRoaXMucGFnZXNDb3VudDtcblxuICAgIGlmIChwYWdlQ291bnQgPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFnZXNBc0FycmF5W3BhZ2VDb3VudCAtIDJdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhc3QgcGFnZSBpbiB0aGUgcXVlcnkgbGlzdCBvZiBwYWdlcy4gT3BlcmF0ZXMgYXMgYSBnZXR0ZXJcbiAgICogc28gdGhhdCBpdCBpc24ndCB3b3JraW5nIHdpdGggc3RhbGUgZGF0YS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBsYXN0UGFnZSgpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBjb25zdCBwYWdlQ291bnQgPSB0aGlzLnBhZ2VzQ291bnQ7XG5cbiAgICBpZiAocGFnZUNvdW50IDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhZ2VzQXNBcnJheVtwYWdlQ291bnQgLSAxXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBxdWVyeSBsaXN0IG9mIHBhZ2VzLiBPcGVyYXRlcyBhcyBhIGdldHRlclxuICAgKiBzbyB0aGF0IGl0IGlzbid0IHdvcmtpbmcgd2l0aCBzdGFsZSBkYXRhLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGZpcnN0UGFnZSgpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBpZiAoIXRoaXMucGFnZXNDb3VudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhZ2VzQXNBcnJheVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIG1vc3RseSBpbnRlcm5hbGx5LCBidXQgYWNjZXB0cyBhIHN0cmluZyBJRCBhbmQgcmV0dXJucyBhIENscldpemFyZFBhZ2VcbiAgICogb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgSUQgcGFzc2VkLiBOb3RlIHRoYXQgSURzIGhlcmUgc2hvdWxkIGluY2x1ZGUgdGhlIHByZWZpeFxuICAgKiBcImNsci13aXphcmQtcGFnZS1cIi5cbiAgICpcbiAgICogUmV0dXJucyB0aGUgbmV4dC10by1sYXN0IHBhZ2UgaW4gdGhlIHF1ZXJ5IGxpc3Qgb2YgcGFnZXMuIE9wZXJhdGVzIGFzIGEgZ2V0dGVyXG4gICAqIHNvIHRoYXQgaXQgaXNuJ3Qgd29ya2luZyB3aXRoIHN0YWxlIGRhdGEuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXRQYWdlQnlJZChpZDogc3RyaW5nKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgZm91bmRQYWdlczogQ2xyV2l6YXJkUGFnZVtdID0gdGhpcy5wYWdlcy5maWx0ZXIoKHBhZ2U6IENscldpemFyZFBhZ2UpID0+IGlkID09PSBwYWdlLmlkKTtcbiAgICByZXR1cm4gdGhpcy5jaGVja1Jlc3VsdHMoZm91bmRQYWdlcywgaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgcyBudW1iZXIgYXMgYSBwYXJhbWV0ZXIgYW5kIHRyZWF0cyB0aGF0IG51bWJlciBhcyB0aGUgaW5kZXggb2YgdGhlIHBhZ2VcbiAgICogeW91J3JlIGxvb2tpbmcgZm9yIGluIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzLiBSZXR1cm5zIGEgIHdpemFyZCBwYWdlIG9iamVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFBhZ2VCeUluZGV4KGluZGV4OiBudW1iZXIpOiBDbHJXaXphcmRQYWdlIHtcbiAgICBjb25zdCBwYWdlQ291bnQgPSB0aGlzLnBhZ2VzQ291bnQ7XG4gICAgY29uc3QgcGFnZXNMYXN0SW5kZXg6IG51bWJlciA9IHBhZ2VDb3VudCA+IDEgPyBwYWdlQ291bnQgLSAxIDogMDtcblxuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJldHJpZXZlIHBhZ2Ugd2l0aCBpbmRleCBvZiAnICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+IHBhZ2VzTGFzdEluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhZ2UgaW5kZXggaXMgZ3JlYXRlciB0aGFuIGxlbmd0aCBvZiBwYWdlcyBhcnJheS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2VzIGEgd2l6YXJkIHBhZ2Ugb2JqZWN0IGFzIGEgcGFyYW1ldGVyIGFuZCByZXR1cm5zIGl0cyBpbmRleCBpbiB0aGVcbiAgICogY29sbGVjdGlvbiBvZiBwYWdlcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFBhZ2VJbmRleChwYWdlOiBDbHJXaXphcmRQYWdlKTogbnVtYmVyIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucGFnZXNBc0FycmF5LmluZGV4T2YocGFnZSk7XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCBwYWdlIGNhbm5vdCBiZSBmb3VuZCBpbiBjb2xsZWN0aW9uIG9mIHBhZ2VzLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZXMgZ3VhcmQgbG9naWMgdGhhdCBwcmV2ZW50cyBhIGNvdXBsZSBvZiB1bmZvcnR1bmF0ZSBlZGdlIGNhc2VzIHdpdGhcbiAgICogbG9vayB1cHMgb24gdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgY2hlY2tSZXN1bHRzKHJlc3VsdHM6IENscldpemFyZFBhZ2VbXSwgcmVxdWVzdGVkUGFnZUlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmb3VuZFBhZ2VzQ291bnQ6IG51bWJlciA9IHJlc3VsdHMubGVuZ3RoIHx8IDA7XG5cbiAgICBpZiAoZm91bmRQYWdlc0NvdW50ID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb3JlIHRoYW4gb25lIHBhZ2UgaGFzIHRoZSByZXF1ZXN0ZWQgaWQgJyArIHJlcXVlc3RlZFBhZ2VJZCArICcuJyk7XG4gICAgfSBlbHNlIGlmIChmb3VuZFBhZ2VzQ291bnQgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHBhZ2UgY2FuIGJlIGZvdW5kIHdpdGggdGhlIGlkICcgKyByZXF1ZXN0ZWRQYWdlSWQgKyAnLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyB0d28gbnVtZXJpYyBpbmRleGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHdpemFyZCBwYWdlIG9iamVjdHMgdGhhdCBpbmNsdWRlXG4gICAqIGFsbCB3aXphcmQgcGFnZXMgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbiBmcm9tIHRoZSBmaXJzdCBpbmRleCB0byB0aGUgc2Vjb25kLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcGFnZVJhbmdlKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogQ2xyV2l6YXJkUGFnZVtdIHtcbiAgICBsZXQgcGFnZXM6IENscldpemFyZFBhZ2VbXSA9IFtdO1xuXG4gICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IHR5cGVvZiBzdGFydCA9PT0gJ3VuZGVmaW5lZCcgfHwgaXNOYU4oc3RhcnQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gbnVsbCB8fCB0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJyB8fCBpc05hTihlbmQpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKGVuZCA+IHRoaXMucGFnZXNDb3VudCkge1xuICAgICAgZW5kID0gdGhpcy5wYWdlc0NvdW50O1xuICAgIH1cblxuICAgIHBhZ2VzID0gdGhpcy5wYWdlc0FzQXJyYXk7XG5cbiAgICBpZiAoZW5kIC0gc3RhcnQgPT09IDApIHtcbiAgICAgIC8vIGp1c3QgcmV0dXJuIHRoZSBvbmUgcGFnZSB0aGV5IHdhbnRcbiAgICAgIHJldHVybiBbdGhpcy5nZXRQYWdlQnlJbmRleChzdGFydCldO1xuICAgIH1cblxuICAgIC8vIHNsaWNlIGVuZCBkb2VzIG5vdCBpbmNsdWRlIGl0ZW0gcmVmZXJlbmNlZCBieSBlbmQgaW5kZXgsIHdoaWNoIGlzIHdlaXJkIGZvciB1c2Vyc1xuICAgIC8vIGluY3JlbWVudGluZyBlbmQgaW5kZXggaGVyZSB0byBjb3JyZWN0IHRoYXQgc28gdXNlcnMgYW5kIG90aGVyIG1ldGhvZHNcbiAgICAvLyBkb24ndCBoYXZlIHRvIHRoaW5rIGFib3V0IGl0XG4gICAgZW5kID0gZW5kICsgMTtcblxuICAgIC8vIHNsaWNlIGRvZXMgbm90IHJldHVybiB0aGUgbGFzdCBvbmUgaW4gdGhlIHJhbmdlIGJ1dCBpdCBkb2VzIGluY2x1ZGUgdGhlIGZpcnN0IG9uZVxuICAgIC8vIGRvZXMgbm90IG1vZGlmeSBvcmlnaW5hbCBhcnJheVxuICAgIHJldHVybiBwYWdlcy5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIHR3byB3aXphcmQgcGFnZSBvYmplY3RzIGFuZCByZXR1cm5zIHRob3NlIHBhZ2Ugb2JqZWN0cyB3aXRoIGFsbCBvdGhlciBwYWdlXG4gICAqIG9iamVjdHMgYmV0d2VlbiB0aGVtIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24uIEl0IGRvZXNuJ3QgY2FyZSB3aGljaCBwYWdlIGlzIGFoZWFkIG9mIHRoZVxuICAgKiBvdGhlciBpbiB0aGUgcGFyYW1ldGVycy4gSXQgd2lsbCBiZSBzbWFydCBlbm91Z2ggdG8gZmlndXJlIHRoYXQgb3V0ICBvbiBpdHMgb3duLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0UGFnZVJhbmdlRnJvbVBhZ2VzKHBhZ2U6IENscldpemFyZFBhZ2UsIG90aGVyUGFnZTogQ2xyV2l6YXJkUGFnZSk6IENscldpemFyZFBhZ2VbXSB7XG4gICAgY29uc3QgcGFnZUluZGV4ID0gdGhpcy5nZXRQYWdlSW5kZXgocGFnZSk7XG4gICAgY29uc3Qgb3RoZXJQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChvdGhlclBhZ2UpO1xuICAgIGxldCBzdGFydEluZGV4OiBudW1iZXI7XG4gICAgbGV0IGVuZEluZGV4OiBudW1iZXI7XG5cbiAgICBpZiAocGFnZUluZGV4IDw9IG90aGVyUGFnZUluZGV4KSB7XG4gICAgICBzdGFydEluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgZW5kSW5kZXggPSBvdGhlclBhZ2VJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRJbmRleCA9IG90aGVyUGFnZUluZGV4O1xuICAgICAgZW5kSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhZ2VSYW5nZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdGhlIHdpemFyZCBwYWdlIG9iamVjdCBvZlxuICAgKiB0aGUgcGFnZSBpbW1lZGlhdGVseSBiZWZvcmUgaXQgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbi4gUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzXG4gICAqIG5vIHBhZ2UgYmVmb3JlIHRoZSBwYWdlIGl0IGlzIHBhc3NlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldFByZXZpb3VzUGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgbXlQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChwYWdlKTtcbiAgICBjb25zdCBwcmV2aW91c1BhZ2VJbmRleCA9IG15UGFnZUluZGV4IC0gMTtcbiAgICBpZiAocHJldmlvdXNQYWdlSW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUJ5SW5kZXgocHJldmlvdXNQYWdlSW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdHMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgYSBCb29sZWFuIHRoYXQgc2F5cyBpZlxuICAgKiB0aGUgcGFnZSB5b3Ugc2VudCBpdCBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzUGFnZUlzQ29tcGxldGVkKHBhZ2U6IENscldpemFyZFBhZ2UpIHtcbiAgICBsZXQgcHJldmlvdXNQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJldmlvdXNQYWdlID0gdGhpcy5nZXRQcmV2aW91c1BhZ2UocGFnZSk7XG5cbiAgICBpZiAobnVsbCA9PT0gcHJldmlvdXNQYWdlKSB7XG4gICAgICAvLyBwYWdlIGlzIHRoZSBmaXJzdCBwYWdlLiBubyBwcmV2aW91cyBwYWdlLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZpb3VzUGFnZS5jb21wbGV0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIHJldHVybnMgdGhlIHdpemFyZCBwYWdlIG9iamVjdCBvZlxuICAgKiB0aGUgcGFnZSBpbW1lZGlhdGVseSBhZnRlciBpdCBpbiB0aGUgcGFnZSBjb2xsZWN0aW9uLiBSZXR1cm5zIG51bGwgaWYgdGhlcmUgaXNcbiAgICogbm8gcGFnZSBhZnRlciB0aGUgcGFnZSBpdCBpcyBwYXNzZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXROZXh0UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgbXlQYWdlSW5kZXggPSB0aGlzLmdldFBhZ2VJbmRleChwYWdlKTtcbiAgICBjb25zdCBuZXh0UGFnZUluZGV4ID0gbXlQYWdlSW5kZXggKyAxO1xuXG4gICAgaWYgKG5leHRQYWdlSW5kZXggPj0gdGhpcy5wYWdlc0FzQXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGFnZUJ5SW5kZXgobmV4dFBhZ2VJbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSB3aXphcmQgcGFnZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgYW5kIGdlbmVyYXRlcyBhIHN0ZXAgaXRlbSBpZCBmcm9tIHRoZVxuICAgKiBwYWdlIElELiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgc3RlcCBpdGVtIElEIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RlcEl0ZW1JZEZvclBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIGNvbnN0IHBhZ2VJZCA9IHBhZ2UuaWQ7XG4gICAgY29uc3QgcGFnZUlkUGFydHMgPSBwYWdlSWQuc3BsaXQoJy0nKS5yZXZlcnNlKCk7XG5cbiAgICBwYWdlSWRQYXJ0c1sxXSA9ICdzdGVwJztcbiAgICByZXR1cm4gcGFnZUlkUGFydHMucmV2ZXJzZSgpLmpvaW4oJy0nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmFsbHkgb25seSB1c2VkIGludGVybmFsbHkgdG8gbWFyayB0aGF0IGEgc3BlY2lmaWMgcGFnZSBoYXMgYmVlbiBcImNvbW1pdHRlZFwiLlxuICAgKiBUaGlzIGludm9sdmVzIG1hcmtpbmcgdGhlIHBhZ2UgY29tcGxldGUgYW5kIGZpcmluZyB0aGUgQ2xyV2l6YXJkUGFnZS5vbkNvbW1pdFxuICAgKiAoY2xyV2l6YXJkUGFnZU9uQ29tbWl0KSBvdXRwdXQuIFRha2VzIHRoZSB3aXphcmQgcGFnZSBvYmplY3QgdGhhdCB5b3UgaW50ZW5kIHRvXG4gICAqIG1hcmsgY29tcGxldGVkIGFzIGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY29tbWl0UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgY29uc3QgcGFnZUhhc092ZXJyaWRlcyA9IHBhZ2Uuc3RvcE5leHQgfHwgcGFnZS5wcmV2ZW50RGVmYXVsdDtcbiAgICBwYWdlLmNvbXBsZXRlZCA9IHRydWU7XG5cbiAgICBpZiAoIXBhZ2VIYXNPdmVycmlkZXMpIHtcbiAgICAgIC8vIHByZXZlbnQgbG9vcCBvZiBldmVudCBlbWlzc2lvbjsgYWx0ZXJuYXRlIGZsb3dzIHdvcmsgb2ZmXG4gICAgICAvLyBvZiBldmVudCBlbWl0dGVycyB0aGlzIGlzIGhvdyB0aGV5IGJyZWFrIHRoYXQgY3ljbGUuXG4gICAgICBwYWdlLm9uQ29tbWl0LmVtaXQocGFnZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gdXNlZCBieSB0aGUgbmF2U2VydmljZSB0byBuYXZpZ2F0ZSBiYWNrIHRvIGZpcnN0IHBvc3NpYmxlIHN0ZXAgYWZ0ZXJcbiAgLy8gcGFnZXMgYXJlIHJlc2V0XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX3BhZ2VzUmVzZXQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHRoYXQgdGhlIG5hdmlnYXRpb24gc2VydmljZSBsaXN0ZW5zIHRvIGluIG9yZGVyIHRvIGtub3cgd2hlblxuICAgKiB0aGUgcGFnZSBjb2xsZWN0aW9uIGNvbXBsZXRlZCBzdGF0ZXMgaGF2ZSBiZWVuIHJlc2V0IHRvIGZhbHNlIHNvIHRoYXQgd2F5IGl0XG4gICAqIGNhbiBhbHNvIHJlc2V0IHRoZSBuYXZpZ2F0aW9uIHRvIG1ha2UgdGhlIGZpcnN0IHBhZ2UgaW4gdGhlIHBhZ2UgY29sbGVjdGlvblxuICAgKiBjdXJyZW50L2FjdGl2ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBwYWdlc1Jlc2V0KCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9wYWdlc1Jlc2V0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYWxsIGNvbXBsZXRlZCBzdGF0ZXMgb2YgdGhlIHBhZ2VzIGluIHRoZSBwYWdlIGNvbGxlY3Rpb24gdG8gZmFsc2UgYW5kXG4gICAqIG5vdGlmaWVzIHRoZSBuYXZpZ2F0aW9uIHNlcnZpY2UgdG8gbGlrZXdpc2UgcmVzZXQgdGhlIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQYWdlQ29sbGVjdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyByZXNldCgpIHtcbiAgICB0aGlzLnBhZ2VzQXNBcnJheS5mb3JFYWNoKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiB7XG4gICAgICBwYWdlLmNvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHRoaXMuX3BhZ2VzUmVzZXQubmV4dCh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSb2xscyB0aHJvdWdoIGFsbCB0aGUgcGFnZXMgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbiB0byBtYWtlIHN1cmUgdGhlcmUgYXJlIG5vXG4gICAqIGluY29tcGxldGUgcGFnZXMgc2FuZHdpY2hlZCBiZXR3ZWVuIGNvbXBsZXRlZCBwYWdlcyBpbiB0aGUgd29ya2Zsb3cuIElkZW50aWZpZXNcbiAgICogdGhlIGZpcnN0IGluY29tcGxldGUgcGFnZSBpbmRleCBhbmQgc2V0cyBhbGwgcGFnZXMgYmVoaW5kIGl0IHRvIGEgY29tcGxldGVkXG4gICAqIHN0YXRlIG9mIGZhbHNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29tcGxldGVkU3RhdGVzKCk6IHZvaWQge1xuICAgIGNvbnN0IGZpcnN0SW5jb21wbGV0ZUluZGV4ID0gdGhpcy5maW5kRmlyc3RJbmNvbXBsZXRlUGFnZUluZGV4KCk7XG5cbiAgICBpZiAoZmlyc3RJbmNvbXBsZXRlSW5kZXggPT09IHRoaXMucGFnZXNBc0FycmF5Lmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGFsbCBjb21wbGV0ZSBubyBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wYWdlc0FzQXJyYXkuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKGluZGV4ID4gZmlyc3RJbmNvbXBsZXRlSW5kZXgpIHtcbiAgICAgICAgcGFnZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpbmNvbXBsZXRlIHBhZ2UgaW4gdGhlIHBhZ2UgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBhZ2VDb2xsZWN0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZpbmRGaXJzdEluY29tcGxldGVQYWdlSW5kZXgoKTogbnVtYmVyIHtcbiAgICBsZXQgcmV0dXJuSW5kZXg6IG51bWJlciA9IG51bGw7XG4gICAgdGhpcy5wYWdlc0FzQXJyYXkuZm9yRWFjaCgocGFnZTogQ2xyV2l6YXJkUGFnZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKG51bGwgPT09IHJldHVybkluZGV4ICYmIGZhbHNlID09PSBwYWdlLmNvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm5JbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmFsbHRocm91Z2gsIGFsbCBjb21wbGV0ZWQsIHJldHVybiBsYXN0IHBhZ2VcbiAgICBpZiAobnVsbCA9PT0gcmV0dXJuSW5kZXgpIHtcbiAgICAgIHJldHVybkluZGV4ID0gdGhpcy5wYWdlc0NvdW50IC0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuSW5kZXg7XG4gIH1cblxuICBwdWJsaWMgZmluZEZpcnN0SW5jb21wbGV0ZVBhZ2UoKTogQ2xyV2l6YXJkUGFnZSB7XG4gICAgY29uc3QgbXlJbmNvbXBsZXRlSW5kZXggPSB0aGlzLmZpbmRGaXJzdEluY29tcGxldGVQYWdlSW5kZXgoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlc0FzQXJyYXlbbXlJbmNvbXBsZXRlSW5kZXhdO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi4vd2l6YXJkLXBhZ2UnO1xuXG5pbXBvcnQgeyBCdXR0b25IdWJTZXJ2aWNlIH0gZnJvbSAnLi9idXR0b24taHViLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5cbi8qKlxuICogUGVyZm9ybXMgbmF2aWdhdGlvbiBmdW5jdGlvbnMgZm9yIGEgd2l6YXJkIGFuZCBtYW5hZ2VzIHRoZSBjdXJyZW50IHBhZ2UuIFByZXNlbnRlZCBhcyBhXG4gKiBzZXBhcmF0ZSBzZXJ2aWNlIHRvIGVuY2Fwc3VsYXRlIHRoZSBiZWhhdmlvciBvZiBuYXZpZ2F0aW5nIGFuZCBjb21wbGV0aW5nIHRoZSB3aXphcmQgc29cbiAqIHRoYXQgaXQgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgdGhlIHdpemFyZCBhbmQgaXRzIHN1Yi1jb21wb25lbnRzLlxuICpcbiAqIFRoZSBlYXNpZXN0IHdheSB0byBhY2Nlc3MgdGhlIG5hdmlnYXRpb24gc2VydmljZSBpcyB0aGVyZSBhIHJlZmVyZW5jZSBvbiB5b3VyIHdpemFyZC4gVGhlXG4gKiBGb2xsb3dpbmcgZXhhbXBsZSB3b3VsZCBhbGxvdyB5b3UgdG8gYWNjZXNzIHlvdXIgaW5zdGFuY2Ugb2YgdGhlIHdpemFyZCBmcm9tIHlvdXIgaG9zdFxuICogY29tcG9uZW50IGFuZCB0aGVyZWJ5IGFjY2VzcyB0aGUgbmF2aWdhdGlvbiBzZXJ2aWNlIHZpYSBZb3VySG9zdENvbXBvbmVudC53aXphcmQubmF2U2VydmljZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogPGNsci13aXphcmQgI3dpemFyZCAuLi4+XG4gKlxuICogQGV4YW1wbGVcbiAqIGV4cG9ydCBjbGFzcyBZb3VySG9zdENvbXBvbmVudCB7XG4gKiAgIEBWaWV3Q2hpbGQoXCJ3aXphcmRcIikgd2l6YXJkOiBXaXphcmQ7XG4gKiAgIC4uLlxuICogfVxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBwcmV2aW91cyBidXR0b24gaXMgY2xpY2tlZCBpbiB0aGUgd2l6YXJkLiBQZXJmb3JtcyBjaGVja3NcbiAgICogYmVmb3JlIGFsZXJ0aW5nIHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhlIGJ1dHRvbiBjbGljay4gRW5hY3RzIG5hdmlnYXRpb24gdG9cbiAgICogdGhlIHByZXZpb3VzIHBhZ2UgaWYgbm90IG92ZXJyaWRkZW4gYXQgdGhlIHBhZ2UgbGV2ZWwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBOZXh0IGJ1dHRvbiBpcyBjbGlja2VkIGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIG5leHRCdXR0b25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSXMgbm90aWZpZWQgd2hlbiBhIGRhbmdlciBidXR0b24gaXMgY2xpY2tlZCBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBkYW5nZXJCdXR0b25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvKipcbiAgICogSXMgbm90aWZpZWQgd2hlbiBhICBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZmluaXNoQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBDdXN0b20gYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY3VzdG9tQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIElzIG5vdGlmaWVkIHdoZW4gYSBDYW5jZWwgYnV0dG9uIGlzIGNsaWNrZWQgaW4gdGhlIHdpemFyZC4gTm90aWZpZXMgdGhlIHdpemFyZCxcbiAgICogd2hpY2ggaGFuZGxlcyBhbGwgY2FuY2VsIGZ1bmN0aW9uYWxpdHksIGlmIGNhbmNlbCBpcyBub3Qgb3ZlcnJpZGRlbiBhdCB0aGUgcGFnZVxuICAgKiBsZXZlbC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBuYXZpZ2F0aW9uIHRvIG1ha2UgdGhlIGZpcnN0IHBhZ2UgY3VycmVudCB3aGVuIHRoZSBwYWdlIGNvbGxlY3Rpb24gc2VydmljZVxuICAgKiBlbWl0cyBhbiBldmVudCBub3RpZnlpbmcgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgdGhhdCBpdCBoYXMgcmVzZXQgYWxsIHBhZ2VzXG4gICAqIHRvIHRoZWlyIHByaXN0aW5lLCBpbmNvbXBsZXRlIHN0YXRlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBwYWdlc1Jlc2V0U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UuIEFsc28gc2V0cyB1cCBzdWJzY3JpcHRpb25zXG4gICAqIHRoYXQgbGlzdGVuIHRvIHRoZSBidXR0b24gc2VydmljZSB0byBkZXRlcm1pbmUgd2hlbiBhIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAqIGluIHRoZSB3aXphcmQuIElzIGFsc28gcmVzcG9uc2libGUgZm9yIHRha2luZyBhY3Rpb24gd2hlbiB0aGUgcGFnZSBjb2xsZWN0aW9uXG4gICAqIHJlcXVlc3RzIHRoYXQgbmF2aWdhdGlvbiBiZSByZXNldCB0byBpdHMgcHJpc3RpbmUgc3RhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VDb2xsZWN0aW9uOiBQYWdlQ29sbGVjdGlvblNlcnZpY2UsIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlKSB7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5wcmV2aW91c0J0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlSXNGaXJzdCB8fCBjdXJyZW50UGFnZS5wcmV2aW91c1N0ZXBEaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50UGFnZS5wcmV2aW91c0J1dHRvbkNsaWNrZWQuZW1pdChjdXJyZW50UGFnZSk7XG4gICAgICBpZiAoIWN1cnJlbnRQYWdlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMubmV4dEJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5uZXh0QnRuQ2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCduZXh0Jyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRhbmdlckJ1dHRvblN1YnNjcmlwdGlvbiA9IHRoaXMuYnV0dG9uU2VydmljZS5kYW5nZXJCdG5DbGlja2VkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQW5kQ29tbWl0Q3VycmVudFBhZ2UoJ2RhbmdlcicpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5maW5pc2hCdXR0b25TdWJzY3JpcHRpb24gPSB0aGlzLmJ1dHRvblNlcnZpY2UuZmluaXNoQnRuQ2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCdmaW5pc2gnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY3VzdG9tQnV0dG9uU3Vic2NyaXB0aW9uID0gdGhpcy5idXR0b25TZXJ2aWNlLmN1c3RvbUJ0bkNsaWNrZWQuc3Vic2NyaWJlKCh0eXBlOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmICghdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRQYWdlLmN1c3RvbUJ1dHRvbkNsaWNrZWQuZW1pdCh0eXBlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uID0gdGhpcy5idXR0b25TZXJ2aWNlLmNhbmNlbEJ0bkNsaWNrZWQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudFBhZ2UucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZS5wYWdlT25DYW5jZWwuZW1pdCh0aGlzLmN1cnJlbnRQYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhZ2VzUmVzZXRTdWJzY3JpcHRpb24gPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzUmVzZXQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0Rmlyc3RQYWdlQ3VycmVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5wcmV2aW91c0J1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMubmV4dEJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuZGFuZ2VyQnV0dG9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5maW5pc2hCdXR0b25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLmN1c3RvbUJ1dHRvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2FuY2VsQnV0dG9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5wYWdlc1Jlc2V0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9jdXJyZW50Q2hhbmdlZCA9IG5ldyBTdWJqZWN0PENscldpemFyZFBhZ2U+KCk7XG5cbiAgLyoqXG4gICAqIEFuIE9ic2VydmFibGUgdGhhdCBpcyBwcmVkb21pbmFudGx5IHVzZWQgYW1vbmdzdCB0aGUgc3ViY29tcG9uZW50cyBhbmQgc2VydmljZXNcbiAgICogb2YgdGhlIHdpemFyZC4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB1c2VycyBsaXN0ZW4gdG8gdGhlIENscldpemFyZFBhZ2Uub25Mb2FkXG4gICAqIChjbHJXaXphcmRQYWdlT25Mb2FkKSBvdXRwdXQgaW5zdGVhZCBvZiB0aGlzIE9ic2VydmFibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUNoYW5nZWQoKTogT2JzZXJ2YWJsZTxDbHJXaXphcmRQYWdlPiB7XG4gICAgLy8gVE9ETzogTUFLRSBTVVJFIEVYVEVSTkFMIE9VVFBVVFMgU0FZICdDSEFOR0UnIE5PVCAnQ0hBTkdFRCdcbiAgICAvLyBBIEJSRUFLSU5HIENIQU5HRSBTTyBBV0FJVElORyBNSU5PUiBSRUxFQVNFXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaGFuZ2VkLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgQm9vbGVhbiBmbGFnIHVzZWQgYnkgdGhlIENscldpemFyZFBhZ2UgdG8gYXZvaWQgYSByYWNlIGNvbmRpdGlvbiB3aGVuIHBhZ2VzIGFyZVxuICAgKiBsb2FkaW5nIGFuZCB0aGVyZSBpcyBubyBjdXJyZW50IHBhZ2UgZGVmaW5lZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgbmF2U2VydmljZUxvYWRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuZm9yY2VGb3J3YXJkIChjbHJXaXphcmRGb3JjZUZvcndhcmROYXZpZ2F0aW9uKSBpbnB1dC4gV2hlbiB0cnVlLFxuICAgKiBuYXZpZ2F0aW5nIGJhY2t3YXJkcyBpbiB0aGUgc3RlcG5hdiBtZW51IHdpbGwgcmVzZXQgYW55IHNraXBwZWQgcGFnZXMnIGNvbXBsZXRlZFxuICAgKiBzdGF0ZSB0byBmYWxzZS5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiBhIHdpemFyZCBleGVjdXRlcyB2YWxpZGF0aW9uIG9uIGEgcGFnZS1ieS1wYWdlIGJhc2lzIHdoZW5cbiAgICogdGhlIG5leHQgYnV0dG9uIGlzIGNsaWNrZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGZvcmNlRm9yd2FyZE5hdmlnYXRpb24gPSBmYWxzZTtcblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IGN1cnJlbnRQYWdlVGl0bGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgLy8gd2hlbiB0aGUgcXVlcnlsaXN0IG9mIHBhZ2VzIGlzIGVtcHR5LiB0aGlzIGlzIHRoZSBmaXJzdCBwbGFjZSBpdCBmYWlscy4uLlxuICAgIGlmICghdGhpcy5jdXJyZW50UGFnZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRQYWdlLnRpdGxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCb29sZWFuIHRoYXQgdGVsbHMgeW91IHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlIGZpcnN0XG4gICAqIHBhZ2UgaW4gdGhlIFdpemFyZC5cbiAgICpcbiAgICogVGhpcyBpcyBoZWxwZnVsIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIGEgcGFnZSBpcyBuYXZpZ2FibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUlzRmlyc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGFnZUNvbGxlY3Rpb24uZmlyc3RQYWdlID09PSB0aGlzLmN1cnJlbnRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBCb29sZWFuIHRoYXQgdGVsbHMgeW91IHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlXG4gICAqIGxhc3QgcGFnZSBpbiB0aGUgV2l6YXJkLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGJ1dHRvbnMgc2hvdWxkIGRpc3BsYXkgaW4gdGhlIHdpemFyZCBmb290ZXIuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUlzTGFzdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5sYXN0UGFnZSA9PT0gdGhpcy5jdXJyZW50UGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX2N1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBDbHJXaXphcmRQYWdlIG9iamVjdCBvZiB0aGUgY3VycmVudCBwYWdlIG9yIG51bGwuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgZ2V0IGN1cnJlbnRQYWdlKCk6IENscldpemFyZFBhZ2Uge1xuICAgIGlmICghdGhpcy5fY3VycmVudFBhZ2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIENscldpemFyZFBhZ2Ugb2JqZWN0LCBzaW5jZSB0aGF0IG9iamVjdCB0byBiZSB0aGUgY3VycmVudC9hY3RpdmVcbiAgICogcGFnZSBpbiB0aGUgd2l6YXJkLCBhbmQgZW1pdHMgdGhlIENscldpemFyZFBhZ2Uub25Mb2FkIChjbHJXaXphcmRQYWdlT25Mb2FkKVxuICAgKiBldmVudCBmb3IgdGhhdCBwYWdlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYWxsIG9mIHRoaXMgd29yayBpcyBieXBhc3NlZCBpZiB0aGUgQ2xyV2l6YXJkUGFnZSBvYmplY3QgaXMgYWxyZWFkeVxuICAgKiB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHNldCBjdXJyZW50UGFnZShwYWdlOiBDbHJXaXphcmRQYWdlKSB7XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYWdlICE9PSBwYWdlICYmICF0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICB0aGlzLl9jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICBwYWdlLm9uTG9hZC5lbWl0KHBhZ2UuaWQpO1xuICAgICAgdGhpcy5fY3VycmVudENoYW5nZWQubmV4dChwYWdlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwcml2YXRlIF9tb3ZlZFRvTmV4dFBhZ2UgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHVzZWQgaW50ZXJuYWxseSB0byBhbGVydCB0aGUgd2l6YXJkIHRoYXQgZm9yd2FyZCBuYXZpZ2F0aW9uXG4gICAqIGhhcyBvY2N1cnJlZC4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIHRoZSBXaXphcmQub25Nb3ZlTmV4dFxuICAgKiAoY2xyV2l6YXJkT25OZXh0KSBvdXRwdXQgaW5zdGVhZCBvZiB0aGlzIG9uZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ2V0IG1vdmVkVG9OZXh0UGFnZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZWRUb05leHRQYWdlLmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHJpdmF0ZSBfd2l6YXJkRmluaXNoZWQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBBbiBvYnNlcnZhYmxlIHVzZWQgaW50ZXJuYWxseSB0byBhbGVydCB0aGUgd2l6YXJkIHRoYXQgdGhlIG5hdiBzZXJ2aWNlXG4gICAqIGhhcyBhcHByb3ZlZCBjb21wbGV0aW9uIG9mIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEl0IGlzIHJlY29tbWVuZGVkIHRoYXQgeW91IHVzZSB0aGUgV2l6YXJkLndpemFyZEZpbmlzaGVkIChjbHJXaXphcmRPbkZpbmlzaClcbiAgICogb3V0cHV0IGluc3RlYWQgb2YgdGhpcyBvbmUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGdldCB3aXphcmRGaW5pc2hlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fd2l6YXJkRmluaXNoZWQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgYWR2YW5jZVxuICAgKiB0aGUgdXNlciB0byB0aGUgbmV4dCBwYWdlLlxuICAgKlxuICAgKiBXaGVuIGludm9rZWQsIHRoaXMgbWV0aG9kIHdpbGwgbW92ZSB0aGUgd2l6YXJkIHRvIHRoZSBuZXh0IHBhZ2UgYWZ0ZXJcbiAgICogc3VjY2Vzc2Z1bCB2YWxpZGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZ29lcyB0aHJvdWdoIGFsbCBjaGVja3NcbiAgICogYW5kIGV2ZW50IGVtaXNzaW9ucyBhcyBpZiBXaXphcmQubmV4dChmYWxzZSkgaGFkIGJlZW4gY2FsbGVkLlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHVzZSBXaXphcmQubmV4dChmYWxzZSkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIG5leHQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2VJc0xhc3QpIHtcbiAgICAgIHRoaXMuY2hlY2tBbmRDb21taXRDdXJyZW50UGFnZSgnZmluaXNoJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCduZXh0Jyk7XG5cbiAgICBpZiAoIXRoaXMud2l6YXJkSGFzQWx0TmV4dCAmJiAhdGhpcy53aXphcmRTdG9wTmF2aWdhdGlvbikge1xuICAgICAgdGhpcy5fbW92ZWRUb05leHRQYWdlLm5leHQodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ5cGFzc2VzIGNoZWNrcyBhbmQgbW9zdCBldmVudCBlbWlzc2lvbnMgdG8gZm9yY2UgYSBwYWdlIHRvIG5hdmlnYXRlIGZvcndhcmQuXG4gICAqXG4gICAqIENvbXBhcmFibGUgdG8gY2FsbGluZyBXaXphcmQubmV4dCgpIG9yIFdpemFyZC5mb3JjZU5leHQoKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZm9yY2VOZXh0KCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRQYWdlOiBDbHJXaXphcmRQYWdlID0gdGhpcy5jdXJyZW50UGFnZTtcbiAgICBjb25zdCBuZXh0UGFnZTogQ2xyV2l6YXJkUGFnZSA9IHRoaXMucGFnZUNvbGxlY3Rpb24uZ2V0TmV4dFBhZ2UoY3VycmVudFBhZ2UpO1xuXG4gICAgLy8gY2F0Y2ggZXJyYW50IG51bGwgb3IgdW5kZWZpbmVkcyB0aGF0IGNyZWVwIGluXG4gICAgaWYgKCFuZXh0UGFnZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgd2l6YXJkIGhhcyBubyBuZXh0IHBhZ2UgdG8gZ28gdG8uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWN1cnJlbnRQYWdlLmNvbXBsZXRlZCkge1xuICAgICAgLy8gdGhpcyBpcyBhIHN0YXRlIHRoYXQgYWx0IG5leHQgZmxvd3MgY2FuIGdldCB0aGVtc2VsdmVzIGluLi4uXG4gICAgICB0aGlzLnBhZ2VDb2xsZWN0aW9uLmNvbW1pdFBhZ2UoY3VycmVudFBhZ2UpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gbmV4dFBhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBhIGJ1dHRvbi9hY3Rpb24gdHlwZSBhcyBhIHBhcmFtZXRlci4gRW5jYXBzdWxhdGVzIGFsbCBsb2dpYyBmb3JcbiAgICogZXZlbnQgZW1pc3Npb25zLCBzdGF0ZSBvZiB0aGUgY3VycmVudCBwYWdlLCBhbmQgd2l6YXJkIGFuZCBwYWdlIGxldmVsIG92ZXJyaWRlcy5cbiAgICpcbiAgICogQXZvaWQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5IHVubGVzcyB5b3UgcmVhbGx5IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNoZWNrQW5kQ29tbWl0Q3VycmVudFBhZ2UoYnV0dG9uVHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFBhZ2U6IENscldpemFyZFBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlO1xuICAgIGxldCBpQW1UaGVMYXN0UGFnZTogYm9vbGVhbjtcblxuICAgIGxldCBpc05leHQ6IGJvb2xlYW47XG4gICAgbGV0IGlzRGFuZ2VyOiBib29sZWFuO1xuICAgIGxldCBpc0Rhbmdlck5leHQ6IGJvb2xlYW47XG4gICAgbGV0IGlzRGFuZ2VyRmluaXNoOiBib29sZWFuO1xuICAgIGxldCBpc0ZpbmlzaDogYm9vbGVhbjtcblxuICAgIGlmICghY3VycmVudFBhZ2UucmVhZHlUb0NvbXBsZXRlIHx8IHRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpQW1UaGVMYXN0UGFnZSA9IHRoaXMuY3VycmVudFBhZ2VJc0xhc3Q7XG5cbiAgICBpc05leHQgPSBidXR0b25UeXBlID09PSAnbmV4dCc7XG4gICAgaXNEYW5nZXIgPSBidXR0b25UeXBlID09PSAnZGFuZ2VyJztcbiAgICBpc0Rhbmdlck5leHQgPSBpc0RhbmdlciAmJiAhaUFtVGhlTGFzdFBhZ2U7XG4gICAgaXNEYW5nZXJGaW5pc2ggPSBpc0RhbmdlciAmJiBpQW1UaGVMYXN0UGFnZTtcbiAgICBpc0ZpbmlzaCA9IGJ1dHRvblR5cGUgPT09ICdmaW5pc2gnIHx8IGlzRGFuZ2VyRmluaXNoO1xuXG4gICAgaWYgKGlzRmluaXNoICYmICFpQW1UaGVMYXN0UGFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRQYWdlLnByaW1hcnlCdXR0b25DbGlja2VkLmVtaXQoYnV0dG9uVHlwZSk7XG5cbiAgICBpZiAoaXNGaW5pc2gpIHtcbiAgICAgIGN1cnJlbnRQYWdlLmZpbmlzaEJ1dHRvbkNsaWNrZWQuZW1pdChjdXJyZW50UGFnZSk7XG4gICAgfSBlbHNlIGlmIChpc0Rhbmdlcikge1xuICAgICAgY3VycmVudFBhZ2UuZGFuZ2VyQnV0dG9uQ2xpY2tlZC5lbWl0KCk7XG4gICAgfSBlbHNlIGlmIChpc05leHQpIHtcbiAgICAgIGN1cnJlbnRQYWdlLm5leHRCdXR0b25DbGlja2VkLmVtaXQoKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFBhZ2Uuc3RvcE5leHQgfHwgY3VycmVudFBhZ2UucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGN1cnJlbnRQYWdlLm9uQ29tbWl0LmVtaXQoY3VycmVudFBhZ2UuaWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG9yZGVyIGlzIHZlcnkgaW1wb3J0YW50IHdpdGggdGhlc2UgZW1pdHRlcnMhXG4gICAgaWYgKGlzRmluaXNoKSB7XG4gICAgICAvLyBtYXJrIHBhZ2UgYXMgY29tcGxldGVcbiAgICAgIGlmICghdGhpcy53aXphcmRIYXNBbHROZXh0KSB7XG4gICAgICAgIHRoaXMucGFnZUNvbGxlY3Rpb24uY29tbWl0UGFnZShjdXJyZW50UGFnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl93aXphcmRGaW5pc2hlZC5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2l6YXJkSGFzQWx0TmV4dCkge1xuICAgICAgdGhpcy5wYWdlQ29sbGVjdGlvbi5jb21taXRQYWdlKGN1cnJlbnRQYWdlKTtcblxuICAgICAgaWYgKGlzTmV4dCB8fCBpc0Rhbmdlck5leHQpIHtcbiAgICAgICAgdGhpcy5fbW92ZWRUb05leHRQYWdlLm5leHQodHJ1ZSk7XG4gICAgICB9XG4gICAgICAvLyBqdW1wIG91dCBoZXJlLCBubyBtYXR0ZXIgd2hhdCB0eXBlIHdlJ3JlIGxvb2tpbmcgYXRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXh0IHx8IGlzRGFuZ2VyTmV4dCkge1xuICAgICAgdGhpcy5mb3JjZU5leHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIHB1YmxpYyBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgY29uY2x1ZGVcbiAgICogdGhlIHdpemFyZC5cbiAgICpcbiAgICogV2hlbiBpbnZva2VkLCB0aGlzIG1ldGhvZCB3aWxsICBpbml0aWF0ZSB0aGUgd29yayBpbnZvbHZlZCB3aXRoIGZpbmFsaXppbmdcbiAgICogYW5kIGZpbmlzaGluZyB0aGUgd2l6YXJkIHdvcmtmbG93LiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZ29lcyB0aHJvdWdoIGFsbFxuICAgKiBjaGVja3MgYW5kIGV2ZW50IGVtaXNzaW9ucyBhcyBpZiBXaXphcmQuZmluaXNoKGZhbHNlKSBoYWQgYmVlbiBjYWxsZWQuXG4gICAqXG4gICAqIEluIG1vc3QgY2FzZXMsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gdXNlIFdpemFyZC5maW5pc2goZmFsc2UpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBmaW5pc2goKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja0FuZENvbW1pdEN1cnJlbnRQYWdlKCdmaW5pc2gnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX21vdmVkVG9QcmV2aW91c1BhZ2UgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gIC8qKlxuICAgKiBOb3RpZmllcyB0aGUgd2l6YXJkIHdoZW4gYmFja3dhcmRzIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkIHZpYSB0aGVcbiAgICogcHJldmlvdXMgYnV0dG9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbW92ZWRUb1ByZXZpb3VzUGFnZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fbW92ZWRUb1ByZXZpb3VzUGFnZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9ncmFtbWF0aWNhbGx5IG1vdmVzIHRoZSB3aXphcmQgdG8gdGhlIHBhZ2UgYmVmb3JlIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIEluIG1vc3QgaW5zdGFuY2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGNhbGwgV2l6YXJkLnByZXZpb3VzKClcbiAgICogd2hpY2ggZG9lcyB0aGUgc2FtZSB0aGluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgbGV0IHByZXZpb3VzUGFnZTogQ2xyV2l6YXJkUGFnZTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlSXNGaXJzdCB8fCB0aGlzLndpemFyZFN0b3BOYXZpZ2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHJldmlvdXNQYWdlID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5nZXRQcmV2aW91c1BhZ2UodGhpcy5jdXJyZW50UGFnZSk7XG5cbiAgICBpZiAoIXByZXZpb3VzUGFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21vdmVkVG9QcmV2aW91c1BhZ2UubmV4dCh0cnVlKTtcblxuICAgIGlmICh0aGlzLmZvcmNlRm9yd2FyZE5hdmlnYXRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudFBhZ2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IHByZXZpb3VzUGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHByaXZhdGUgX2NhbmNlbFdpemFyZCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIHdpemFyZCB0aGF0IGEgdXNlciBpcyB0cnlpbmcgdG8gY2FuY2VsIGl0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBnZXQgbm90aWZ5V2l6YXJkQ2FuY2VsKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbmNlbFdpemFyZC5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSBob29rIGludG8gdGhlIGNhbmNlbCB3b3JrZmxvdyBvZiB0aGUgd2l6YXJkIGZyb20gdGhlIG5hdiBzZXJ2aWNlLiBOb3RlIHRoYXRcbiAgICogdGhpcyByb3V0ZSBnb2VzIHRocm91Z2ggYWxsIGNoZWNrcyBhbmQgZXZlbnQgZW1pc3Npb25zIGFzIGlmIGEgY2FuY2VsIGJ1dHRvbiBoYWRcbiAgICogYmVlbiBjbGlja2VkLlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCB1c2VycyBsb29raW5nIGZvciBhIGhvb2sgaW50byB0aGUgY2FuY2VsIHJvdXRpbmUgYXJlIGFjdHVhbGx5IGxvb2tpbmdcbiAgICogZm9yIGEgd2F5IHRvIGNsb3NlIHRoZSB3aXphcmQgZnJvbSB0aGVpciBob3N0IGNvbXBvbmVudCBiZWNhdXNlIHRoZXkgaGF2ZSBwcmV2ZW50ZWRcbiAgICogdGhlIGRlZmF1bHQgY2FuY2VsIGFjdGlvbi5cbiAgICpcbiAgICogSW4gdGhpcyBpbnN0YW5jZSwgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIFdpemFyZC5jbG9zZSgpIHRvIGF2b2lkIGFueSBldmVudFxuICAgKiBlbWlzc2lvbiBsb29wIHJlc3VsdGluZyBmcm9tIGFuIGV2ZW50IGhhbmRsZXIgY2FsbGluZyBiYWNrIGludG8gcm91dGluZSB0aGF0IHdpbGxcbiAgICogYWdhaW4gZXZva2UgdGhlIGV2ZW50cyBpdCBoYW5kbGVzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBjYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5fY2FuY2VsV2l6YXJkLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuc3RvcENhbmNlbCAoY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWwpIGlucHV0LiBXaGVuIHRydWUsIHRoZSBjYW5jZWxcbiAgICogcm91dGluZSBpcyBzdWJ2ZXJ0ZWQgYW5kIG11c3QgYmUgcmVpbnN0YXRlZCBpbiB0aGUgaG9zdCBjb21wb25lbnQgY2FsbGluZyBXaXphcmQuY2xvc2UoKVxuICAgKiBhdCBzb21lIHBvaW50LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyB3aXphcmRIYXNBbHRDYW5jZWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBib29sZWFuIGZsYWcgc2hhcmVkIGFjcm9zcyB0aGUgV2l6YXJkIHN1YmNvbXBvbmVudHMgdGhhdCBmb2xsb3dzIHRoZSB2YWx1ZVxuICAgKiBvZiB0aGUgV2l6YXJkLnN0b3BOZXh0IChjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQpIGlucHV0LiBXaGVuIHRydWUsIHRoZSBuZXh0IGFuZCBmaW5pc2hcbiAgICogcm91dGluZXMgYXJlIHN1YnZlcnRlZCBhbmQgbXVzdCBiZSByZWluc3RhdGVkIGluIHRoZSBob3N0IGNvbXBvbmVudCBjYWxsaW5nIFdpemFyZC5uZXh0KCksXG4gICAqIFdpemFyZC5mb3JjZU5leHQoKSwgV2l6YXJkLmZpbmlzaCgpLCBvciBXaXphcmQuZm9yY2VGaW5pc2goKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgd2l6YXJkSGFzQWx0TmV4dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGJvb2xlYW4gZmxhZyBzaGFyZWQgYWNyb3NzIHRoZSBXaXphcmQgc3ViY29tcG9uZW50cyB0aGF0IGZvbGxvd3MgdGhlIHZhbHVlXG4gICAqIG9mIHRoZSBXaXphcmQuc3RvcE5hdmlnYXRpb24gKGNscldpemFyZFByZXZlbnROYXZpZ2F0aW9uKSBpbnB1dC4gV2hlbiB0cnVlLCBhbGxcbiAgICogbmF2aWdhdGlvbmFsIGVsZW1lbnRzIGluIHRoZSB3aXphcmQgYXJlIGRpc2FibGVkLlxuICAgKlxuICAgKiBUaGlzIGlzIGludGVuZGVkIHRvIGZyZWV6ZSB0aGUgd2l6YXJkIGluIHBsYWNlLiBFdmVudHMgYXJlIG5vdCBmaXJlZCBzbyB0aGlzIGlzXG4gICAqIG5vdCBhIHdheSB0byBpbXBsZW1lbnQgYWx0ZXJuYXRlIGZ1bmN0aW9uYWxpdHkgZm9yIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHdpemFyZFN0b3BOYXZpZ2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBmbGFnIHNoYXJlZCB3aXRoIHRoZSBzdGVwbmF2IGl0ZW1zIHRoYXQgcHJldmVudHMgdXNlciBjbGlja3Mgb25cbiAgICogc3RlcG5hdiBpdGVtcyBmcm9tIG5hdmlnYXRpbmcgdGhlIHdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgd2l6YXJkRGlzYWJsZVN0ZXBuYXY6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYWxsIHJlcXVpcmVkIGNoZWNrcyB0byBkZXRlcm1pbmUgaWYgYSB1c2VyIGNhbiBuYXZpZ2F0ZSB0byBhIHBhZ2UuIENoZWNraW5nIGF0IGVhY2hcbiAgICogcG9pbnQgaWYgYSBwYWdlIGlzIG5hdmlnYWJsZSAtLSBjb21wbGV0ZWQgd2hlcmUgdGhlIHBhZ2UgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3QgY29tcGxldGVkXG4gICAqIHBhZ2UuXG4gICAqXG4gICAqIFRha2VzIHR3byBwYXJhbWV0ZXJzLiBUaGUgZmlyc3Qgb25lIG11c3QgYmUgZWl0aGVyIHRoZSBDbHJXaXphcmRQYWdlIG9iamVjdCBvciB0aGUgSUQgb2YgdGhlXG4gICAqIENscldpemFyZFBhZ2Ugb2JqZWN0IHRoYXQgeW91IHdhbnQgdG8gbWFrZSB0aGUgY3VycmVudCBwYWdlLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyBvcHRpb25hbCBhbmQgaXMgYSBCb29sZWFuIGZsYWcgZm9yIFwibGF6eSBjb21wbGV0aW9uXCIuIFdoYXQgdGhpcyBtZWFuc1xuICAgKiBpcyB0aGUgV2l6YXJkIHdpbGwgbWFyayBhbGwgcGFnZXMgYmV0d2VlbiB0aGUgY3VycmVudCBwYWdlIGFuZCB0aGUgcGFnZSB5b3Ugd2FudCB0byBuYXZpZ2F0ZVxuICAgKiB0byBhcyBjb21wbGV0ZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBpbmZvcm1hdGlvbmFsIHdpemFyZHMgdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGFjdGlvbixcbiAgICogYWxsb3dpbmcgYW4gZWFzeSBtZWFucyBmb3IgdXNlcnMgdG8ganVtcCBhaGVhZC5cbiAgICpcbiAgICogVG8gYXZvaWQgY2hlY2tzIG9uIG5hdmlnYXRpb24sIHVzZSBDbHJXaXphcmRQYWdlLm1ha2VDdXJyZW50KCkgaW5zdGVhZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgZ29UbyhwYWdlVG9Hb1RvT3JJZDogYW55LCBsYXp5Q29tcGxldGU6IGJvb2xlYW4gPSBmYWxzZSkge1xuICAgIGxldCBwYWdlVG9Hb1RvOiBDbHJXaXphcmRQYWdlO1xuICAgIGxldCBjdXJyZW50UGFnZTogQ2xyV2l6YXJkUGFnZTtcbiAgICBsZXQgbXlQYWdlczogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIGxldCBwYWdlc1RvQ2hlY2s6IENscldpemFyZFBhZ2VbXTtcbiAgICBsZXQgb2theVRvTW92ZTogYm9vbGVhbjtcbiAgICBsZXQgZ29pbmdGb3J3YXJkOiBib29sZWFuO1xuICAgIGxldCBjdXJyZW50UGFnZUluZGV4OiBudW1iZXI7XG4gICAgbGV0IGdvVG9QYWdlSW5kZXg6IG51bWJlcjtcblxuICAgIG15UGFnZXMgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uO1xuICAgIHBhZ2VUb0dvVG8gPSB0eXBlb2YgcGFnZVRvR29Ub09ySWQgPT09ICdzdHJpbmcnID8gbXlQYWdlcy5nZXRQYWdlQnlJZChwYWdlVG9Hb1RvT3JJZCkgOiBwYWdlVG9Hb1RvT3JJZDtcbiAgICBjdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG5cbiAgICAvLyBubyBwb2ludCBpbiBnb2luZyB0byB0aGUgY3VycmVudCBwYWdlLiB5b3UncmUgdGhlcmUgYWxyZWFkeSFcbiAgICAvLyBhbHNvIGhhcmQgYmxvY2sgb24gYW55IG5hdmlnYXRpb24gd2hlbiBzdG9wTmF2aWdhdGlvbiBpcyB0cnVlXG4gICAgaWYgKHBhZ2VUb0dvVG8gPT09IGN1cnJlbnRQYWdlIHx8IHRoaXMud2l6YXJkU3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50UGFnZUluZGV4ID0gbXlQYWdlcy5nZXRQYWdlSW5kZXgoY3VycmVudFBhZ2UpO1xuICAgIGdvVG9QYWdlSW5kZXggPSBteVBhZ2VzLmdldFBhZ2VJbmRleChwYWdlVG9Hb1RvKTtcbiAgICBnb2luZ0ZvcndhcmQgPSBnb1RvUGFnZUluZGV4ID4gY3VycmVudFBhZ2VJbmRleDtcbiAgICBwYWdlc1RvQ2hlY2sgPSBteVBhZ2VzLmdldFBhZ2VSYW5nZUZyb21QYWdlcyh0aGlzLmN1cnJlbnRQYWdlLCBwYWdlVG9Hb1RvKTtcblxuICAgIG9rYXlUb01vdmUgPSBsYXp5Q29tcGxldGUgfHwgdGhpcy5jYW5Hb1RvKHBhZ2VzVG9DaGVjayk7XG5cbiAgICBpZiAoIW9rYXlUb01vdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZ29pbmdGb3J3YXJkICYmIGxhenlDb21wbGV0ZSkge1xuICAgICAgcGFnZXNUb0NoZWNrLmZvckVhY2goKHBhZ2U6IENscldpemFyZFBhZ2UpID0+IHtcbiAgICAgICAgaWYgKHBhZ2UgIT09IHBhZ2VUb0dvVG8pIHtcbiAgICAgICAgICBwYWdlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWdvaW5nRm9yd2FyZCAmJiB0aGlzLmZvcmNlRm9yd2FyZE5hdmlnYXRpb24pIHtcbiAgICAgIHBhZ2VzVG9DaGVjay5mb3JFYWNoKChwYWdlOiBDbHJXaXphcmRQYWdlKSA9PiB7XG4gICAgICAgIHBhZ2UuY29tcGxldGVkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZVRvR29UbztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIGEgcmFuZ2Ugb2YgQ2xyV2l6YXJkUGFnZSBvYmplY3RzIGFzIGEgcGFyYW1ldGVyLiBQZXJmb3JtcyB0aGUgd29yayBvZiBjaGVja2luZ1xuICAgKiB0aG9zZSBvYmplY3RzIHRvIGRldGVybWluZSBpZiBuYXZpZ2F0aW9uIGNhbiBiZSBhY2NvbXBsaXNoZWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIGNhbkdvVG8ocGFnZXNUb0NoZWNrOiBDbHJXaXphcmRQYWdlW10pOiBib29sZWFuIHtcbiAgICBsZXQgb2theVRvTW92ZSA9IHRydWU7XG4gICAgY29uc3QgbXlQYWdlcyA9IHRoaXMucGFnZUNvbGxlY3Rpb247XG5cbiAgICAvLyBwcmV2aW91cyBwYWdlIGNhbiBiZSBpbXBvcnRhbnQgd2hlbiBtb3ZpbmcgYmVjYXVzZSBpZiBpdCdzIGNvbXBsZXRlZCBpdFxuICAgIC8vIGFsbG93cyB1cyB0byBtb3ZlIHRvIHRoZSBwYWdlIGV2ZW4gaWYgaXQncyBpbmNvbXBsZXRlLi4uXG4gICAgbGV0IHByZXZpb3VzUGFnZVBhc3NlczogYm9vbGVhbjtcblxuICAgIGlmICghcGFnZXNUb0NoZWNrIHx8IHBhZ2VzVG9DaGVjay5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcGFnZXNUb0NoZWNrLmZvckVhY2goKHBhZ2U6IENscldpemFyZFBhZ2UpID0+IHtcbiAgICAgIGxldCBwcmV2aW91c1BhZ2U6IENscldpemFyZFBhZ2U7XG5cbiAgICAgIGlmICghb2theVRvTW92ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlLmNvbXBsZXRlZCkge1xuICAgICAgICAvLyBkZWZhdWx0IGlzIHRydWUuIGp1c3QganVtcCBvdXQgaW5zdGVhZCBvZiBjb21wbGljYXRpbmcgaXQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gc28gd2Uga25vdyBvdXIgcGFnZSBpcyBub3QgY29tcGxldGVkLi4uXG4gICAgICBwcmV2aW91c1BhZ2UgPSBteVBhZ2VzLmdldFBhZ2VJbmRleChwYWdlKSA+IDAgPyBteVBhZ2VzLmdldFByZXZpb3VzUGFnZShwYWdlKSA6IG51bGw7XG4gICAgICBwcmV2aW91c1BhZ2VQYXNzZXMgPSBwcmV2aW91c1BhZ2UgPT09IG51bGwgfHwgcHJldmlvdXNQYWdlLmNvbXBsZXRlZCA9PT0gdHJ1ZTtcblxuICAgICAgLy8gd2UgYXJlIGZhbHNlIGlmIG5vdCB0aGUgY3VycmVudCBwYWdlIEFORCBwcmV2aW91cyBwYWdlIGlzIG5vdCBjb21wbGV0ZWRcbiAgICAgIC8vIChidXQgbXVzdCBoYXZlIGEgcHJldmlvdXMgcGFnZSlcbiAgICAgIGlmICghcGFnZS5jdXJyZW50ICYmICFwcmV2aW91c1BhZ2VQYXNzZXMpIHtcbiAgICAgICAgb2theVRvTW92ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaCB0byB0cnVlIGFzIGRlZmF1bHRcbiAgICB9KTtcblxuICAgIHJldHVybiBva2F5VG9Nb3ZlO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2tzIHRocm91Z2ggdGhlIGNvbGxlY3Rpb24gb2YgcGFnZXMgdG8gZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXMgaW5jb21wbGV0ZVxuICAgKiBhbmQgbWFrZXMgdGhhdCBwYWdlIHRoZSBjdXJyZW50L2FjdGl2ZSBwYWdlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyBzZXRMYXN0RW5hYmxlZFBhZ2VDdXJyZW50KCk6IHZvaWQge1xuICAgIGNvbnN0IGFsbFBhZ2VzOiBDbHJXaXphcmRQYWdlW10gPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzQXNBcnJheTtcbiAgICBsZXQgbGFzdENvbXBsZXRlZFBhZ2VJbmRleDogbnVtYmVyID0gbnVsbDtcblxuICAgIGFsbFBhZ2VzLmZvckVhY2goKHBhZ2U6IENscldpemFyZFBhZ2UsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChwYWdlLmNvbXBsZXRlZCkge1xuICAgICAgICBsYXN0Q29tcGxldGVkUGFnZUluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobGFzdENvbXBsZXRlZFBhZ2VJbmRleCA9PT0gbnVsbCkge1xuICAgICAgLy8gYWx3YXlzIGlzIGF0IGxlYXN0IHRoZSBmaXJzdCBpdGVtLi4uXG4gICAgICBsYXN0Q29tcGxldGVkUGFnZUluZGV4ID0gMDtcbiAgICB9IGVsc2UgaWYgKGxhc3RDb21wbGV0ZWRQYWdlSW5kZXggKyAxIDwgYWxsUGFnZXMubGVuZ3RoKSB7XG4gICAgICBsYXN0Q29tcGxldGVkUGFnZUluZGV4ID0gbGFzdENvbXBsZXRlZFBhZ2VJbmRleCArIDE7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IGFsbFBhZ2VzW2xhc3RDb21wbGV0ZWRQYWdlSW5kZXhdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBjb2xsZWN0aW9uIG9mIHBhZ2VzIGFuZCBtYWtlcyB0aGF0IHBhZ2UgdGhlXG4gICAqIGN1cnJlbnQvYWN0aXZlIHBhZ2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKi9cbiAgcHVibGljIHNldEZpcnN0UGFnZUN1cnJlbnQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IHRoaXMucGFnZUNvbGxlY3Rpb24ucGFnZXNBc0FycmF5WzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0ZXBuYXYgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgd2l6YXJkIHdoZW4gcGFnZXMgYXJlIGR5bmFtaWNhbGx5XG4gICAqIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgY29sbGVjdGlvbiBvZiBwYWdlcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlTmF2aWdhdGlvbigpOiB2b2lkIHtcbiAgICBsZXQgdG9TZXRDdXJyZW50OiBDbHJXaXphcmRQYWdlO1xuICAgIGxldCBjdXJyZW50UGFnZVJlbW92ZWQ6IGJvb2xlYW47XG5cbiAgICB0aGlzLnBhZ2VDb2xsZWN0aW9uLnVwZGF0ZUNvbXBsZXRlZFN0YXRlcygpO1xuXG4gICAgY3VycmVudFBhZ2VSZW1vdmVkID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5wYWdlc0FzQXJyYXkuaW5kZXhPZih0aGlzLmN1cnJlbnRQYWdlKSA8IDA7XG4gICAgaWYgKGN1cnJlbnRQYWdlUmVtb3ZlZCkge1xuICAgICAgdG9TZXRDdXJyZW50ID0gdGhpcy5wYWdlQ29sbGVjdGlvbi5maW5kRmlyc3RJbmNvbXBsZXRlUGFnZSgpO1xuICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHRvU2V0Q3VycmVudDtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRIZWFkZXJBY3Rpb24gfSBmcm9tICcuLi93aXphcmQtaGVhZGVyLWFjdGlvbic7XG5pbXBvcnQgeyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBIZWFkZXJBY3Rpb25TZXJ2aWNlIHtcbiAgLy8gdGhpcyBzZXJ2aWNlIGNvbW11bmljYXRlcyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcHJlc2VuY2UvZGlzcGxheSBvZiBoZWFkZXIgYWN0aW9uc1xuICAvLyBhY3Jvc3MgdGhlIHdpemFyZFxuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYXZTZXJ2aWNlOiBXaXphcmROYXZpZ2F0aW9uU2VydmljZSkge31cblxuICBwdWJsaWMgd2l6YXJkSGVhZGVyQWN0aW9uczogUXVlcnlMaXN0PENscldpemFyZEhlYWRlckFjdGlvbj47XG5cbiAgcHVibGljIGdldCB3aXphcmRIYXNIZWFkZXJBY3Rpb25zKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHdpemFyZEhkckFjdGlvbnMgPSB0aGlzLndpemFyZEhlYWRlckFjdGlvbnM7XG4gICAgaWYgKCF3aXphcmRIZHJBY3Rpb25zKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB3aXphcmRIZHJBY3Rpb25zLnRvQXJyYXkoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZUhhc0hlYWRlckFjdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZSA/IHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZS5oYXNIZWFkZXJBY3Rpb25zIDogZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNob3dXaXphcmRIZWFkZXJBY3Rpb25zKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5jdXJyZW50UGFnZUhhc0hlYWRlckFjdGlvbnMgJiYgdGhpcy53aXphcmRIYXNIZWFkZXJBY3Rpb25zO1xuICB9XG5cbiAgcHVibGljIGdldCBkaXNwbGF5SGVhZGVyQWN0aW9uc1dyYXBwZXIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFBhZ2VIYXNIZWFkZXJBY3Rpb25zIHx8IHRoaXMud2l6YXJkSGFzSGVhZGVyQWN0aW9ucztcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5sZXQgd2l6YXJkSGVhZGVyQWN0aW9uSW5kZXggPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItd2l6YXJkLWhlYWRlci1hY3Rpb24nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBjbGFzcz1cImJ0biBjbHItd2l6YXJkLWhlYWRlci1hY3Rpb24gYnRuLWxpbmtcIlxuICAgICAgICAgICAgW2lkXT1cImlkXCJcbiAgICAgICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xpY2soKVwiXG4gICAgICAgICAgICBbdGl0bGVdPVwidGl0bGVcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9idXR0b24+XG4gICAgYCxcbiAgaG9zdDogeyBjbGFzczogJ2Nsci13aXphcmQtaGVhZGVyLWFjdGlvbi13cmFwcGVyJyB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRIZWFkZXJBY3Rpb24ge1xuICAvLyB0aXRsZSBpcyBleHBsYW5hdG9yeSB0ZXh0IGFkZGVkIHRvIHRoZSBoZWFkZXIgYWN0aW9uXG4gIEBJbnB1dCgndGl0bGUnKSB0aXRsZTogc3RyaW5nID0gJyc7XG5cbiAgLy8gSWYgb3VyIGhvc3QgaGFzIGFuIElEIGF0dHJpYnV0ZSwgd2UgdXNlIHRoaXMgaW5zdGVhZCBvZiBvdXIgaW5kZXguXG4gIEBJbnB1dCgnaWQnKSBfaWQ6IHN0cmluZyA9ICh3aXphcmRIZWFkZXJBY3Rpb25JbmRleCsrKS50b1N0cmluZygpO1xuXG4gIHB1YmxpYyBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNsci13aXphcmQtaGVhZGVyLWFjdGlvbi0ke3RoaXMuX2lkfWA7XG4gIH1cblxuICBASW5wdXQoJ2NscldpemFyZEhlYWRlckFjdGlvbkRpc2FibGVkJykgcHVibGljIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQE91dHB1dCgnYWN0aW9uQ2xpY2tlZCcpIGhlYWRlckFjdGlvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcihmYWxzZSk7XG5cbiAgY2xpY2soKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBwYXNzaW5nIHRoZSBoZWFkZXIgYWN0aW9uIGlkIGFsbG93cyB1c2VycyB0byBoYXZlIG9uZSBtZXRob2QgdGhhdFxuICAgIC8vIHJvdXRlcyB0byBtYW55IGRpZmZlcmVudCBhY3Rpb25zIGJhc2VkIG9uIHRoZSB0eXBlIG9mIGhlYWRlciBhY3Rpb25cbiAgICAvLyBjbGlja2VkLiB0aGlzIGlzIGZ1cnRoZXIgYWlkZWQgYnkgdXNlcnMgYmVpbmcgYWJsZSB0byBzcGVjaWZ5IGlkc1xuICAgIC8vIGZvciB0aGVpciBoZWFkZXIgYWN0aW9ucy5cbiAgICB0aGlzLmhlYWRlckFjdGlvbkNsaWNrZWQuZW1pdCh0aGlzLl9pZCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUGFnZUJ1dHRvbnNdJyB9KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFBhZ2VCdXR0b25zIHtcbiAgY29uc3RydWN0b3IocHVibGljIHBhZ2VCdXR0b25zVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW2NsclBhZ2VIZWFkZXJBY3Rpb25zXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlSGVhZGVyQWN0aW9uc1RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBEaXJlY3RpdmUsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1tjbHJQYWdlTmF2VGl0bGVdJyB9KVxuZXhwb3J0IGNsYXNzIENscldpemFyZFBhZ2VOYXZUaXRsZSB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlTmF2VGl0bGVUZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Pikge31cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbY2xyUGFnZVRpdGxlXScgfSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRQYWdlVGl0bGUge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcGFnZVRpdGxlVGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQnV0dG9uSHViU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2J1dHRvbi1odWIuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlQ29sbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9wYWdlLWNvbGxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZUJ1dHRvbnMgfSBmcm9tICcuL3dpemFyZC1wYWdlLWJ1dHRvbnMnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZUhlYWRlckFjdGlvbnMgfSBmcm9tICcuL3dpemFyZC1wYWdlLWhlYWRlci1hY3Rpb25zJztcbmltcG9ydCB7IENscldpemFyZFBhZ2VOYXZUaXRsZSB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtbmF2dGl0bGUnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZVRpdGxlIH0gZnJvbSAnLi93aXphcmQtcGFnZS10aXRsZSc7XG5cbmxldCB3aXphcmRQYWdlSW5kZXggPSAwO1xuXG4vKipcbiAqIFRoZSBDbHJXaXphcmRQYWdlIGNvbXBvbmVudCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcGxheWluZyB0aGUgY29udGVudCBvZiBlYWNoIHN0ZXBcbiAqIGluIHRoZSB3aXphcmQgd29ya2Zsb3cuXG4gKlxuICogQ2xyV2l6YXJkUGFnZSBjb21wb25lbnQgaGFzIGhvb2tzIGludG8gdGhlIG5hdmlnYXRpb24gc2VydmljZSAoQ2xyV2l6YXJkUGFnZS5uYXZTZXJ2aWNlKSxcbiAqIHBhZ2UgY29sbGVjdGlvbiAoQ2xyV2l6YXJkUGFnZS5wYWdlQ29sbGVjdGlvbiksIGFuZCBidXR0b24gc2VydmljZVxuICogKENscldpemFyZFBhZ2UuYnV0dG9uU2VydmljZSkuIFRoZXNlIHRocmVlIHByb3ZpZGVycyBhcmUgc2hhcmVkIGFjcm9zcyB0aGUgY29tcG9uZW50c1xuICogd2l0aGluIGVhY2ggaW5zdGFuY2Ugb2YgYSBXaXphcmQuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItd2l6YXJkLXBhZ2UnLFxuICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICBob3N0OiB7XG4gICAgJ1tpZF0nOiAnaWQnLFxuICAgIHJvbGU6ICd0YWJwYW5lbCcsXG4gICAgJ1thdHRyLmFyaWEtaGlkZGVuXSc6ICchY3VycmVudCcsXG4gICAgJ1thdHRyLmFyaWEtbGFiZWxsZWRieV0nOiAnc3RlcEl0ZW1JZCcsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ2N1cnJlbnQnLFxuICAgICdbY2xhc3MuY2xyLXdpemFyZC1wYWdlXSc6ICd0cnVlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkUGFnZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENscldpemFyZFBhZ2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBwYWdlQ29sbGVjdGlvbjogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlXG4gICkge31cblxuICAvKipcbiAgICogQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIHBhZ2UgdGl0bGUgd2hpY2ggaXMgdXNlZCBmb3IgYSBudW1iZXJcbiAgICogb2YgZGlmZmVyZW50IHRhc2tzIGZvciBkaXNwbGF5IGluIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkKENscldpemFyZFBhZ2VUaXRsZSkgcHVibGljIHBhZ2VUaXRsZTogQ2xyV2l6YXJkUGFnZVRpdGxlO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgZGVzaXJlZCB0aXRsZSBmb3IgdGhlIHBhZ2UncyBzdGVwIGluIHRoZVxuICAgKiBuYXZpZ2F0aW9uIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHdpemFyZC4gQ2FuIGJlIHByb2plY3RlZCB0byBjaGFuZ2UgdGhlXG4gICAqIG5hdmlnYXRpb24gbGluaydzIHRleHQuXG4gICAqXG4gICAqIElmIG5vdCBkZWZpbmVkLCB0aGVuIENscldpemFyZFBhZ2UucGFnZVRpdGxlIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBzdGVwbmF2LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJXaXphcmRQYWdlTmF2VGl0bGUpIHB1YmxpYyBwYWdlTmF2VGl0bGU6IENscldpemFyZFBhZ2VOYXZUaXRsZTtcblxuICAvKipcbiAgICogQ29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGJ1dHRvbnMgZGVmaW5lZCB3aXRoaW4gdGhlIHBhZ2UuIElmIG5vdCBkZWZpbmVkLFxuICAgKiB0aGUgd2l6YXJkIGRlZmF1bHRzIHRvIHRoZSBzZXQgb2YgYnV0dG9ucyBkZWZpbmVkIGFzIGEgZGlyZWN0IGNoaWxkIG9mIHRoZVxuICAgKiB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAQ29udGVudENoaWxkKENscldpemFyZFBhZ2VCdXR0b25zKSBwdWJsaWMgX2J1dHRvbnM6IENscldpemFyZFBhZ2VCdXR0b25zO1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgaGVhZGVyIGFjdGlvbnMgZGVmaW5lZCB3aXRoaW4gdGhlIHBhZ2UuIElmIG5vdCBkZWZpbmVkLFxuICAgKiB0aGUgd2l6YXJkIGRlZmF1bHRzIHRvIHRoZSBzZXQgb2YgaGVhZGVyIGFjdGlvbnMgZGVmaW5lZCBhcyBhIGRpcmVjdCBjaGlsZCBvZiB0aGVcbiAgICogd2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQENvbnRlbnRDaGlsZChDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucykgcHVibGljIF9oZWFkZXJBY3Rpb25zOiBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucztcblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHByaXZhdGUgX25leHRTdGVwRGlzYWJsZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQSBnZXR0ZXIgdGhhdCB0ZWxscyB3aGV0aGVyIG9yIG5vdCB0aGUgd2l6YXJkIHNob3VsZCBiZSBhbGxvd2VkXG4gICAqIHRvIG1vdmUgdG8gdGhlIG5leHQgcGFnZS5cbiAgICpcbiAgICogVXNlZnVsIGZvciBpbi1wYWdlIHZhbGlkYXRpb24gYmVjYXVzZSBpdCBwcmV2ZW50cyBmb3J3YXJkIG5hdmlnYXRpb25cbiAgICogYW5kIHZpc2libHkgZGlzYWJsZXMgdGhlIG5leHQgYnV0dG9uLlxuICAgKlxuICAgKiBEb2VzIG5vdCByZXF1aXJlIHRoYXQgeW91IHJlLWltcGxlbWVudCBuYXZpZ2F0aW9uIHJvdXRpbmVzIGxpa2UgeW91XG4gICAqIHdvdWxkIGlmIHlvdSB3ZXJlIHVzaW5nIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHQgb3JcbiAgICogV2l6YXJkLnByZXZlbnREZWZhdWx0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBuZXh0U3RlcERpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9uZXh0U3RlcERpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciB0aGUgcGFnZSBzaG91bGQgYWxsb3cgZm9yd2FyZCBuYXZpZ2F0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQYWdlTmV4dERpc2FibGVkJylcbiAgcHVibGljIHNldCBuZXh0U3RlcERpc2FibGVkKHZhbDogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhbEJvb2wgPSAhIXZhbDtcbiAgICBpZiAodmFsQm9vbCAhPT0gdGhpcy5fbmV4dFN0ZXBEaXNhYmxlZCkge1xuICAgICAgdGhpcy5fbmV4dFN0ZXBEaXNhYmxlZCA9IHZhbEJvb2w7XG4gICAgICB0aGlzLm5leHRTdGVwRGlzYWJsZWRDaGFuZ2UuZW1pdCh2YWxCb29sKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgdmFsdWUgb2YgQ2xyV2l6YXJkUGFnZS5uZXh0U3RlcERpc2FibGVkIGNoYW5nZXMuXG4gICAqIFNob3VsZCBlbWl0IHRoZSBuZXcgdmFsdWUgb2YgbmV4dFN0ZXBEaXNhYmxlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VOZXh0RGlzYWJsZWRDaGFuZ2UnKSBuZXh0U3RlcERpc2FibGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9wcmV2aW91c1N0ZXBEaXNhYmxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGdldHRlciB0aGF0IHRlbGxzIHdoZXRoZXIgb3Igbm90IHRoZSB3aXphcmQgc2hvdWxkIGJlIGFsbG93ZWRcbiAgICogdG8gbW92ZSB0byB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICpcbiAgICogVXNlZnVsIGZvciBpbi1wYWdlIHZhbGlkYXRpb24gYmVjYXVzZSBpdCBwcmV2ZW50cyBiYWNrd2FyZCBuYXZpZ2F0aW9uXG4gICAqIGFuZCB2aXNpYmx5IGRpc2FibGVzIHRoZSBwcmV2aW91cyBidXR0b24uXG4gICAqXG4gICAqIERvZXMgbm90IHJlcXVpcmUgdGhhdCB5b3UgcmUtaW1wbGVtZW50IG5hdmlnYXRpb24gcm91dGluZXMgbGlrZSB5b3VcbiAgICogd291bGQgaWYgeW91IHdlcmUgdXNpbmcgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdCBvclxuICAgKiBXaXphcmQucHJldmVudERlZmF1bHQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHByZXZpb3VzU3RlcERpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9wcmV2aW91c1N0ZXBEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIHBhZ2Ugc2hvdWxkIGFsbG93IGJhY2t3YXJkIG5hdmlnYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VQcmV2aW91c0Rpc2FibGVkJylcbiAgcHVibGljIHNldCBwcmV2aW91c1N0ZXBEaXNhYmxlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX3ByZXZpb3VzU3RlcERpc2FibGVkKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c1N0ZXBEaXNhYmxlZCA9IHZhbEJvb2w7XG4gICAgICB0aGlzLnByZXZpb3VzU3RlcERpc2FibGVkQ2hhbmdlLmVtaXQodmFsQm9vbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHZhbHVlIG9mIENscldpemFyZFBhZ2UucHJldmlvdXNTdGVwRGlzYWJsZWQgY2hhbmdlcy5cbiAgICogU2hvdWxkIGVtaXQgdGhlIG5ldyB2YWx1ZSBvZiBwcmV2aW91c1N0ZXBEaXNhYmxlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VQcmV2aW91c0Rpc2FibGVkQ2hhbmdlJylcbiAgcHVibGljIHByZXZpb3VzU3RlcERpc2FibGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBhbGwgYWN0aW9ucyBmcm9tIHRoZSBwYWdlIGxldmVsLCBzbyB5b3UgY2FuIHVzZSBhbiBhbHRlcm5hdGUgZnVuY3Rpb24gZm9yXG4gICAqIHZhbGlkYXRpb24gb3IgZGF0YS1tdW5naW5nIHdpdGggYSBDbHJXaXphcmRQYWdlLm9uQ29tbWl0IChjbHJXaXphcmRQYWdlT25Db21taXQgb3V0cHV0KSxcbiAgICogQ2xyV2l6YXJkUGFnZS5vbkNhbmNlbCAoY2xyV2l6YXJkUGFnZU9uQ2FuY2VsIG91dHB1dCksIG9yIG9uZVxuICAgKiBvZiB0aGUgZ3JhbnVsYXIgcGFnZS1sZXZlbCBidXR0b24gY2xpY2sgZXZlbnQgZW1pdHRlcnMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdCcpIHB1YmxpYyBwcmV2ZW50RGVmYXVsdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBfc3RvcENhbmNlbCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGdldHRlciB0aGF0IHJldHJpZXZlcyB3aGV0aGVyIHRoZSBwYWdlIGlzIHByZXZlbnRpbmcgdGhlIGNhbmNlbCBhY3Rpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0b3BDYW5jZWwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3BDYW5jZWw7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGVzIHRoZSBjYW5jZWwgYWN0aW9uIGZyb20gdGhlIHBhZ2UgbGV2ZWwuIEFsbG93cyB5b3UgdG8gdXNlIGFuXG4gICAqIGFsdGVybmF0ZSBmdW5jdGlvbiBmb3IgdmFsaWRhdGlvbiBvciBkYXRhLW11bmdpbmcgYmVmb3JlIGNhbmNlbGxpbmcgdGhlXG4gICAqIHdpemFyZCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIENscldpemFyZFBhZ2Uub25DYW5jZWxcbiAgICogKHRoZSBjbHJXaXphcmRQYWdlT25DYW5jZWwgb3V0cHV0KS5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhhdCB5b3UgbWFudWFsbHkgY2xvc2UgdGhlIHdpemFyZCBmcm9tIHlvdXIgaG9zdCBjb21wb25lbnQsXG4gICAqIHVzdWFsbHkgd2l0aCBhIGNhbGwgdG8gV2l6YXJkLmZvcmNlTmV4dCgpIG9yIHdpemFyZC5uZXh0KCk7XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRQYWdlXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdENhbmNlbCcpXG4gIHB1YmxpYyBzZXQgc3RvcENhbmNlbCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX3N0b3BDYW5jZWwpIHtcbiAgICAgIHRoaXMuX3N0b3BDYW5jZWwgPSB2YWxCb29sO1xuICAgICAgdGhpcy5zdG9wQ2FuY2VsQ2hhbmdlLmVtaXQodmFsQm9vbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHRDYW5jZWxDaGFuZ2UnKSBzdG9wQ2FuY2VsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9zdG9wTmV4dCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIGdldHRlciB0aGF0IHRlbGxzIHlvdSB3aGV0aGVyIHRoZSBwYWdlIGlzIHByZXZlbnRpbmcgdGhlIG5leHQgYWN0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBzdG9wTmV4dCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcE5leHQ7XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGZvcndhcmQgbmF2aWdhdGlvbiBmcm9tIHRoZSBwYWdlIGxldmVsLiBBbGxvd3MgeW91IHRvIHVzZSBhblxuICAgKiBhbHRlcm5hdGUgZnVuY3Rpb24gZm9yIHZhbGlkYXRpb24gb3IgZGF0YS1tdW5naW5nIGJlZm9yZSBtb3ZpbmcgdGhlXG4gICAqIHdpemFyZCB0byB0aGUgbmV4dCBwYWdld2hlbiBjb21iaW5lZCB3aXRoIHRoZSBDbHJXaXphcmRQYWdlLm9uQ29tbWl0XG4gICAqIChjbHJXaXphcmRQYWdlT25Db21taXQpIG9yIENscldpemFyZFBhZ2UubmV4dEJ1dHRvbkNsaWNrZWRcbiAgICogKGNscldpemFyZFBhZ2VOZXh0KSBvdXRwdXRzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGF0IHlvdSBtYW51YWxseSB0ZWxsIHRoZSB3aXphcmQgdG8gbmF2aWdhdGUgZm9yd2FyZCBmcm9tXG4gICAqIHRoZSBob3N0Q29tcG9uZW50LCB1c3VhbGx5IHdpdGggYSBjYWxsIHRvIFdpemFyZC5mb3JjZU5leHQoKSBvclxuICAgKiB3aXphcmQubmV4dCgpO1xuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkUGFnZVxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRQYWdlUHJldmVudERlZmF1bHROZXh0JylcbiAgcHVibGljIHNldCBzdG9wTmV4dCh2YWw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YWxCb29sID0gISF2YWw7XG4gICAgaWYgKHZhbEJvb2wgIT09IHRoaXMuX3N0b3BOZXh0KSB7XG4gICAgICB0aGlzLl9zdG9wTmV4dCA9IHZhbEJvb2w7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFuIGV2ZW50IGVtaXR0ZXIgY2FycmllZCBvdmVyIGZyb20gYSBsZWdhY3kgdmVyc2lvbiBvZiBDbHJXaXphcmRQYWdlLlxuICAgKiBGaXJlcyBhbiBldmVudCBvbiBDbHJXaXphcmRQYWdlIHdoZW5ldmVyIHRoZSBuZXh0IG9yIGZpbmlzaCBidXR0b25zXG4gICAqIGFyZSBjbGlja2VkIGFuZCB0aGUgcGFnZSBpcyB0aGUgY3VycmVudCBwYWdlIG9mIHRoZSBXaXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGF1dG9tYXRpY2FsbHkgZW1pdCBhbiBldmVudCB3aGVuIGEgY3VzdG9tXG4gICAqIGJ1dHRvbiBpcyB1c2VkIGluIHBsYWNlIG9mIGEgbmV4dCBvciBmaW5pc2ggYnV0dG9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZU9uQ29tbWl0Jykgb25Db21taXQ6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiBDbHJXaXphcmRQYWdlIGJlY29tZXMgdGhlIGN1cnJlbnQgcGFnZSBvZiB0aGVcbiAgICogV2l6YXJkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZU9uTG9hZCcpIG9uTG9hZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIENscldpemFyZFBhZ2UgaW52b2tlcyB0aGUgY2FuY2VsIHJvdXRpbmUgZm9yIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2Uuc3RvcENhbmNlbFxuICAgKiAoY2xyV2l6YXJkUGFnZVByZXZlbnREZWZhdWx0Q2FuY2VsKSBvciBDbHJXaXphcmRQYWdlLnByZXZlbnREZWZhdWx0XG4gICAqIChjbHJXaXphcmRQYWdlUGFnZVByZXZlbnREZWZhdWx0KSBpbnB1dHMgdG8gaW1wbGVtZW50IGN1c3RvbSBjYW5jZWxcbiAgICogZnVuY3Rpb25hbGl0eSBhdCB0aGUgcGFnZSBsZXZlbC4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG9cbiAgICogdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuIHVzZXJzIGJlZm9yZSBjYW5jZWxsaW5nIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHlvdSB0byBjYWxsIFdpemFyZC5jbG9zZSgpIGZyb20gdGhlIGhvc3QgY29tcG9uZW50LlxuICAgKiBUaGlzIGNvbnN0aXR1ZXMgYSBmdWxsIHJlcGxhY2VtZW50IG9mIHRoZSBjYW5jZWwgZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VPbkNhbmNlbCcpIHBhZ2VPbkNhbmNlbDogRXZlbnRFbWl0dGVyPENscldpemFyZFBhZ2U+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZSBDbHJXaXphcmRQYWdlIGlzXG4gICAqIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gZmluaXNoXG4gICAqIGZ1bmN0aW9uYWxpdHkgYXQgdGhlIHBhZ2UgbGV2ZWwuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvXG4gICAqIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FybiB1c2VycyBiZWZvcmUgYWxsb3dpbmcgdGhlbSB0byBjb21wbGV0ZVxuICAgKiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuZmluaXNoKCkgb3IgV2l6YXJkLmZvcmNlRmluaXNoKClcbiAgICogZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXMgY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2ZcbiAgICogdGhlIGZpbmlzaCBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkUGFnZUZpbmlzaCcpIGZpbmlzaEJ1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxDbHJXaXphcmRQYWdlPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgcHJldmlvdXMgYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZSBDbHJXaXphcmRQYWdlIGlzXG4gICAqIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gYmFja3dhcmRzXG4gICAqIG5hdmlnYXRpb24gYXQgdGhlIHBhZ2UgbGV2ZWwuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3b3VsZCBsaWtlIHRvIGRvXG4gICAqIHZhbGlkYXRpb24sIHNhdmUgZGF0YSwgb3Igd2FybiB1c2VycyBiZWZvcmUgYWxsb3dpbmcgdGhlbSB0byBnb1xuICAgKiBiYWNrd2FyZHMgaW4gdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLnByZXZpb3VzKClcbiAgICogZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXMgY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2ZcbiAgICogdGhlIGJhY2t3YXJkcyBuYXZpZ2F0aW9uIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlUHJldmlvdXMnKSBwcmV2aW91c0J1dHRvbkNsaWNrZWQ6IEV2ZW50RW1pdHRlcjxDbHJXaXphcmRQYWdlPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbmV4dCBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIENscldpemFyZFBhZ2UgaXNcbiAgICogdGhlIHdpemFyZCdzIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXQgdG8gaW1wbGVtZW50IGN1c3RvbSBmb3J3YXJkc1xuICAgKiBuYXZpZ2F0aW9uIGF0IHRoZSBwYWdlIGxldmVsLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkb1xuICAgKiB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm4gdXNlcnMgYmVmb3JlIGFsbG93aW5nIHRoZW0gdG8gZ29cbiAgICogdG8gdGhlIG5leHQgcGFnZSBpbiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuZm9yY2VOZXh0KCkgb3IgV2l6YXJkLm5leHQoKVxuICAgKiBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC4gVGhpcyBjb21iaW5hdGlvbiBjcmVhdGVzIGEgZnVsbCByZXBsYWNlbWVudCBvZlxuICAgKiB0aGUgZm9yd2FyZCBuYXZpZ2F0aW9uIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlTmV4dCcpIG5leHRCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8Q2xyV2l6YXJkUGFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gYSBkYW5nZXIgYnV0dG9uIGlzIGNsaWNrZWQgYW5kIHRoZSBDbHJXaXphcmRQYWdlIGlzXG4gICAqIHRoZSB3aXphcmQncyBjdXJyZW50IHBhZ2UuIEJ5IGRlZmF1bHQsIGEgZGFuZ2VyIGJ1dHRvbiB3aWxsIGFjdCBhc1xuICAgKiBlaXRoZXIgYSBcIm5leHRcIiBvciBcImZpbmlzaFwiIGJ1dHRvbiBkZXBlbmRpbmcgb24gaWYgdGhlIENscldpemFyZFBhZ2UgaXMgdGhlXG4gICAqIGxhc3QgcGFnZSBvciBub3QuXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENscldpemFyZFBhZ2UucHJldmVudERlZmF1bHRcbiAgICogKGNscldpemFyZFBhZ2VQYWdlUHJldmVudERlZmF1bHQpIGlucHV0IHRvIGltcGxlbWVudCBjdXN0b20gZm9yd2FyZHNcbiAgICogb3IgZmluaXNoIG5hdmlnYXRpb24gYXQgdGhlIHBhZ2UgbGV2ZWwgd2hlbiB0aGUgZGFuZ2VyIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd291bGQgbGlrZSB0byBkbyB2YWxpZGF0aW9uLCBzYXZlIGRhdGEsIG9yIHdhcm5cbiAgICogdXNlcnMgYmVmb3JlIGFsbG93aW5nIHRoZW0gdG8gZ28gdG8gdGhlIG5leHQgcGFnZSBpbiB0aGUgd2l6YXJkIG9yXG4gICAqIGZpbmlzaCB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyByZXF1aXJlcyB5b3UgdG8gY2FsbCBXaXphcmQuZmluaXNoKCksIFdpemFyZC5mb3JjZUZpbmlzaCgpLFxuICAgKiBXaXphcmQuZm9yY2VOZXh0KCkgb3IgV2l6YXJkLm5leHQoKSBmcm9tIHRoZSBob3N0IGNvbXBvbmVudC4gVGhpc1xuICAgKiBjb21iaW5hdGlvbiBjcmVhdGVzIGEgZnVsbCByZXBsYWNlbWVudCBvZiB0aGUgZm9yd2FyZCBuYXZpZ2F0aW9uIGFuZFxuICAgKiBmaW5pc2ggZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZFBhZ2VEYW5nZXInKSBkYW5nZXJCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8Q2xyV2l6YXJkUGFnZT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gYSBuZXh0LCBmaW5pc2gsIG9yIGRhbmdlciBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlXG4gICAqIENscldpemFyZFBhZ2UgaXMgdGhlIHdpemFyZCdzIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ2xyV2l6YXJkUGFnZS5wcmV2ZW50RGVmYXVsdFxuICAgKiAoY2xyV2l6YXJkUGFnZVBhZ2VQcmV2ZW50RGVmYXVsdCkgaW5wdXQgdG8gaW1wbGVtZW50IGN1c3RvbSBmb3J3YXJkc1xuICAgKiBvciBmaW5pc2ggbmF2aWdhdGlvbiBhdCB0aGUgcGFnZSBsZXZlbCwgcmVnYXJkbGVzcyBvZiB0aGUgdHlwZSBvZlxuICAgKiBwcmltYXJ5IGJ1dHRvbi5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gZG8gdmFsaWRhdGlvbiwgc2F2ZSBkYXRhLCBvciB3YXJuXG4gICAqIHVzZXJzIGJlZm9yZSBhbGxvd2luZyB0aGVtIHRvIGdvIHRvIHRoZSBuZXh0IHBhZ2UgaW4gdGhlIHdpemFyZCBvclxuICAgKiBmaW5pc2ggdGhlIHdpemFyZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgcmVxdWlyZXMgeW91IHRvIGNhbGwgV2l6YXJkLmZpbmlzaCgpLCBXaXphcmQuZm9yY2VGaW5pc2goKSxcbiAgICogV2l6YXJkLmZvcmNlTmV4dCgpIG9yIFdpemFyZC5uZXh0KCkgZnJvbSB0aGUgaG9zdCBjb21wb25lbnQuIFRoaXNcbiAgICogY29tYmluYXRpb24gY3JlYXRlcyBhIGZ1bGwgcmVwbGFjZW1lbnQgb2YgdGhlIGZvcndhcmQgbmF2aWdhdGlvbiBhbmRcbiAgICogZmluaXNoIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlUHJpbWFyeScpIHByaW1hcnlCdXR0b25DbGlja2VkOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBAT3V0cHV0KCdjbHJXaXphcmRQYWdlQ3VzdG9tQnV0dG9uJykgY3VzdG9tQnV0dG9uQ2xpY2tlZDogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgLyoqXG4gICAqIEFuIGlucHV0IHZhbHVlIHRoYXQgaXMgdXNlZCBpbnRlcm5hbGx5IHRvIGdlbmVyYXRlIHRoZSBDbHJXaXphcmRQYWdlIElEIGFzXG4gICAqIHdlbGwgYXMgdGhlIHN0ZXAgbmF2IGl0ZW0gSUQuXG4gICAqXG4gICAqIFR5cGVkIGFzIGFueSBiZWNhdXNlIGl0IHNob3VsZCBiZSBhYmxlIHRvIGFjY2VwdCBudW1iZXJzIGFzIHdlbGwgYXNcbiAgICogc3RyaW5ncy4gUGFzc2luZyBhbiBpbmRleCBmb3Igd2l6YXJkIHdob3NlIHBhZ2VzIGFyZSBjcmVhdGVkIHdpdGggYW5cbiAgICogbmdGb3IgbG9vcCBpcyBhIGNvbW1vbiB1c2UgY2FzZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnaWQnKSBfaWQ6IGFueSA9ICh3aXphcmRQYWdlSW5kZXgrKykudG9TdHJpbmcoKTtcblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgZ2VuZXJhdGVzIGFuIElEIHN0cmluZyBmb3IgdGhlIHdpemFyZCBwYWdlIGZyb21cbiAgICogZWl0aGVyIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIENscldpemFyZFBhZ2UgXCJpZFwiIGlucHV0IG9yIGEgd2l6YXJkIHBhZ2VcbiAgICogY291bnRlciBzaGFyZWQgYWNyb3NzIGFsbCB3aXphcmQgcGFnZXMgaW4gdGhlIGFwcGxpY2F0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIHZhbHVlIHBhc3NlZCBpbnRvIHRoZSBJRCBpbnB1dCBXaWxsIGJlIHByZWZpeGVkIHdpdGhcbiAgICogXCJjbHItd2l6YXJkLXBhZ2UtXCIuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkUGFnZVxuICAgKi9cbiAgcHVibGljIGdldCBpZCgpIHtcbiAgICAvLyBjb3ZlcnMgdGhpbmdzIGxpa2UgbnVsbCwgdW5kZWZpbmVkLCBmYWxzZSwgYW5kIGVtcHR5IHN0cmluZ1xuICAgIC8vIHdoaWxlIGFsbG93aW5nIHplcm8gdG8gcGFzc1xuICAgIGNvbnN0IGlkSXNOb25aZXJvRmFsc3kgPSAhdGhpcy5faWQgJiYgdGhpcy5faWQgIT09IDA7XG5cbiAgICAvLyBpbiBhZGRpdGlvbiB0byBub24temVybyBmYWxzeSB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIF9pZCBpcyBub3QgYSBuZWdhdGl2ZVxuICAgIC8vIG51bWJlci5cbiAgICBpZiAoaWRJc05vblplcm9GYWxzeSB8fCB0aGlzLl9pZCA8IDApIHtcbiAgICAgIC8vIGd1YXJkIGhlcmUgaW4gdGhlIGV2ZW50IHRoYXQgaW5wdXQgYmVjb21lcyB1bmRlZmluZWQgb3IgbnVsbCBieSBhY2NpZGVudFxuICAgICAgdGhpcy5faWQgPSAod2l6YXJkUGFnZUluZGV4KyspLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBgY2xyLXdpemFyZC1wYWdlLSR7dGhpcy5faWR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCBzZXJ2ZXMgYXMgYSBjb252ZW5pZW5jZSBmb3IgdGhvc2Ugd2hvIHdvdWxkIHJhdGhlclxuICAgKiBub3QgdGhpbmsgaW4gdGhlIHRlcm1zIG9mICFDbHJXaXphcmRQYWdlLm5leHRTdGVwRGlzYWJsZWQuIEZvciBzb21lIHVzZSBjYXNlcyxcbiAgICogQ2xyV2l6YXJkUGFnZS5yZWFkeVRvQ29tcGxldGUgaXMgbW9yZSBsb2dpY2FsIGFuZCBkZWNsYXJhdGl2ZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgcmVhZHlUb0NvbXBsZXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5uZXh0U3RlcERpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwcml2YXRlIF9jb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBBIHBhZ2UgaXMgbWFya2VkIGFzIGNvbXBsZXRlZCBpZiBpdCBpcyBib3RoIHJlYWR5VG9Db21wbGV0ZSBhbmQgY29tcGxldGVkLFxuICAgKiBhcyBpbiB0aGUgbmV4dCBvciBmaW5pc2ggYWN0aW9uIGhhcyBiZWVuIGV4ZWN1dGVkIHdoaWxlIHRoaXMgcGFnZSB3YXMgY3VycmVudC5cbiAgICpcbiAgICogTm90ZSB0aGVyZSBpcyBhbmQgb3BlbiBxdWVzdGlvbiBhYm91dCBob3cgdG8gaGFuZGxlIHBhZ2VzIHRoYXQgYXJlIG1hcmtlZFxuICAgKiBjb21wbGV0ZSBidXQgd2hvIGFyZSBubyBsb25nZXIgcmVhZHlUb0NvbXBsZXRlLiBUaGlzIG1pZ2h0IGluZGljYXRlIGFuIGVycm9yXG4gICAqIHN0YXRlIGZvciB0aGUgQ2xyV2l6YXJkUGFnZS4gQ3VycmVudGx5LCB0aGUgd2l6YXJkIGRvZXMgbm90IGFja25vd2xlZGdlIHRoaXMgc3RhdGVcbiAgICogYW5kIG9ubHkgcmV0dXJucyB0aGF0IHRoZSBwYWdlIGlzIGluY29tcGxldGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNvbXBsZXRlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGxldGUgJiYgdGhpcy5yZWFkeVRvQ29tcGxldGU7XG5cbiAgICAvLyBGT1IgVjI6IFVOV0lORCBDT01QTEVURUQsIFJFQURZVE9DT01QTEVURSwgQU5EIEVSUk9SU1xuICAgIC8vIFNVQ0ggVEhBVCBFUlJPUlMgSVMgSVRTIE9XTiBJTlBVVC4gSUYgQSBTVEVQIElTXG4gICAgLy8gSU5DT01QTEVURSBBTkQgRVJST1JFRCwgRVJST1JFRCBXSUxMIE5PVCBTSE9XLlxuICAgIC8vIEZJUlNUIFFVRVNUSU9OOiBBTSBJIEdSRVkgT1IgQ09MT1JFRD9cbiAgICAvLyBTRUNPTkQgUVVFU1RJT046IEFNIEkgR1JFRU4gT1IgUkVEP1xuICB9XG5cbiAgLyoqXG4gICAqIEEgQ2xyV2l6YXJkUGFnZSBjYW4gYmUgbWFudWFsbHkgc2V0IHRvIGNvbXBsZXRlZCB1c2luZyB0aGlzIGJvb2xlYW4gc2V0dGVyLlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHVzZXJzIHJlbHkgb24gdGhlIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyBpbiB0aGUgd2l6YXJkXG4gICAqIGFuZCBuYXZpZ2F0aW9uIHNlcnZpY2UgaW5zdGVhZCBvZiBtYW51YWxseSBzZXR0aW5nIHBhZ2Vzw6LCgMKZIGNvbXBsZXRpb24gc3RhdGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRQYWdlXG4gICAqL1xuICBwdWJsaWMgc2V0IGNvbXBsZXRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2NvbXBsZXRlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdpdGggdGhlIG5hdmlnYXRpb24gc2VydmljZSB0byBzZWUgaWYgaXQgaXMgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgY3VycmVudCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlID09PSB0aGlzO1xuICB9XG5cbiAgcHVibGljIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXRoaXMuZW5hYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHJlYWQtb25seSBnZXR0ZXIgdGhhdCByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBwYWdlIGlzIG5hdmlnYWJsZVxuICAgKiBpbiB0aGUgd2l6YXJkLiBBIHdpemFyZCBwYWdlIGNhbiBiZSBuYXZpZ2F0ZWQgdG8gaWYgaXQgaXMgY29tcGxldGVkXG4gICAqIG9yIHRoZSBwYWdlIGJlZm9yZSBpdCBpcyBjb21wbGV0ZWQuXG4gICAqXG4gICAqIFRoaXMgZ2V0dGVyIGhhbmRsZXMgdGhlIGxvZ2ljIGZvciBlbmFibGluZyBvciBkaXNhYmxpbmcgdGhlIGxpbmtzIGluXG4gICAqIHRoZSBzdGVwIG5hdiBvbiB0aGUgbGVmdCBTaWRlIG9mIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudCB8fCB0aGlzLmNvbXBsZXRlZCB8fCB0aGlzLnByZXZpb3VzQ29tcGxldGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHBhZ2UgYmVmb3JlIHRoaXNcbiAgICogQ2xyV2l6YXJkUGFnZSBpcyBjb21wbGV0ZWQuIFRoaXMgaXMgdXNlZnVsIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIG9yIG5vdFxuICAgKiBhIHBhZ2UgaXMgbmF2aWdhYmxlIGlmIGl0IGlzIG5vdCBjdXJyZW50IG9yIGFscmVhZHkgY29tcGxldGVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBwcmV2aW91c0NvbXBsZXRlZCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBwcmV2aW91c1BhZ2UgPSB0aGlzLnBhZ2VDb2xsZWN0aW9uLmdldFByZXZpb3VzUGFnZSh0aGlzKTtcblxuICAgIGlmICghcHJldmlvdXNQYWdlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldmlvdXNQYWdlLmNvbXBsZXRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCB0aXRsZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5wYWdlVGl0bGUucGFnZVRpdGxlVGVtcGxhdGVSZWY7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgbmF2VGl0bGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgaWYgKHRoaXMucGFnZU5hdlRpdGxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYWdlTmF2VGl0bGUucGFnZU5hdlRpdGxlVGVtcGxhdGVSZWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhZ2VUaXRsZS5wYWdlVGl0bGVUZW1wbGF0ZVJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBoZWFkZXJBY3Rpb25zKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIGlmICghdGhpcy5faGVhZGVyQWN0aW9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faGVhZGVyQWN0aW9ucy5wYWdlSGVhZGVyQWN0aW9uc1RlbXBsYXRlUmVmO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhhc0hlYWRlckFjdGlvbnMoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdGhpcy5faGVhZGVyQWN0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBidXR0b25zKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgIGlmICghdGhpcy5fYnV0dG9ucykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnV0dG9ucy5wYWdlQnV0dG9uc1RlbXBsYXRlUmVmO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgcmVhZC1vbmx5IGdldHRlciB0aGF0IHJldHVybnMgYSBib29sZWFuIHRoYXQgc2F5cyB3aGV0aGVyIG9yXG4gICAqIG5vdCB0aGUgQ2xyV2l6YXJkUGFnZSBpbmNsdWRlcyBidXR0b25zLiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVcbiAgICogV2l6YXJkIHNob3VsZCBvdmVycmlkZSB0aGUgZGVmYXVsdCBidXR0b24gc2V0IGRlZmluZWQgYXNcbiAgICogaXRzIGRpcmVjdCBjaGlsZHJlbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFBhZ2VcbiAgICpcbiAgICovXG4gIHB1YmxpYyBnZXQgaGFzQnV0dG9ucygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLl9idXR0b25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZXMgdGhlIG5hdiBzZXJ2aWNlIHRvIG1ha2UgdGhlIENscldpemFyZFBhZ2UgdGhlIGN1cnJlbnQgcGFnZSBpbiB0aGVcbiAgICogd2l6YXJkLiBCeXBhc3NlcyBhbGwgY2hlY2tzIGJ1dCBzdGlsbCBlbWl0cyB0aGUgQ2xyV2l6YXJkUGFnZS5vbkxvYWRcbiAgICogKGNscldpemFyZFBhZ2VPbkxvYWQpIG91dHB1dC5cbiAgICpcbiAgICogSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSB0aGUgZGVmYXVsdCBuYXZpZ2F0aW9uIGZ1bmN0aW9uc1xuICAgKiBpbiBXaXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgbWFrZUN1cnJlbnQoKTogdm9pZCB7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlID0gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5rcyB0aGUgbmF2IHNlcnZpY2UgYW5kIGVzdGFibGlzaGVzIHRoZSBjdXJyZW50IHBhZ2UgaWYgb25lIGlzIG5vdCBkZWZpbmVkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkUGFnZVxuICAgKlxuICAgKi9cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGNvbnN0IG5hdlNlcnZpY2UgPSB0aGlzLm5hdlNlcnZpY2U7XG4gICAgaWYgKCFuYXZTZXJ2aWNlLmN1cnJlbnRQYWdlICYmICFuYXZTZXJ2aWNlLm5hdlNlcnZpY2VMb2FkZWQpIHtcbiAgICAgIHRoaXMubWFrZUN1cnJlbnQoKTtcbiAgICAgIHRoaXMubmF2U2VydmljZS5uYXZTZXJ2aWNlTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSByZWFkLW9ubHkgZ2V0dGVyIHRoYXQgcmV0dXJucyB0aGUgaWQgdXNlZCBieSB0aGUgc3RlcCBuYXYgaXRlbSBhc3NvY2lhdGVkIHdpdGggdGhlIHBhZ2UuXG4gICAqXG4gICAqIENscldpemFyZFBhZ2UgbmVlZHMgdGhpcyBJRCBzdHJpbmcgZm9yIGFyaWEgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRQYWdlXG4gICAqXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0ZXBJdGVtSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlQ29sbGVjdGlvbi5nZXRTdGVwSXRlbUlkRm9yUGFnZSh0aGlzKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQge1xuICBBZnRlckNvbnRlbnRJbml0LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRG9DaGVjayxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgSXRlcmFibGVEaWZmZXJzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IEJ1dHRvbkh1YlNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9idXR0b24taHViLnNlcnZpY2UnO1xuaW1wb3J0IHsgSGVhZGVyQWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL2hlYWRlci1hY3Rpb25zLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGFnZUNvbGxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvcGFnZS1jb2xsZWN0aW9uLnNlcnZpY2UnO1xuLy8gcHJvdmlkZXJzXG5pbXBvcnQgeyBXaXphcmROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3dpemFyZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkSGVhZGVyQWN0aW9uIH0gZnJvbSAnLi93aXphcmQtaGVhZGVyLWFjdGlvbic7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi93aXphcmQtcGFnZSc7XG5cbi8qKlxuICpcbiAqIFRoZSBXaXphcmQgY29tcG9uZW50XG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItd2l6YXJkJyxcbiAgcHJvdmlkZXJzOiBbV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UsIFBhZ2VDb2xsZWN0aW9uU2VydmljZSwgQnV0dG9uSHViU2VydmljZSwgSGVhZGVyQWN0aW9uU2VydmljZV0sXG4gIHRlbXBsYXRlVXJsOiAnLi93aXphcmQuaHRtbCcsXG4gIGhvc3Q6IHtcbiAgICAnW2NsYXNzLmNsci13aXphcmRdJzogJ3RydWUnLFxuICAgICdbY2xhc3Mud2l6YXJkLW1kXSc6IFwic2l6ZSA9PSAnbWQnXCIsXG4gICAgJ1tjbGFzcy53aXphcmQtbGddJzogXCJzaXplID09ICdsZydcIixcbiAgICAnW2NsYXNzLndpemFyZC14bF0nOiBcInNpemUgPT0gJ3hsJ1wiLFxuICAgICdbY2xhc3MubGFzdFBhZ2VdJzogJ25hdlNlcnZpY2UuY3VycmVudFBhZ2VJc0xhc3QnLFxuICB9LFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdCwgRG9DaGVjayB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFdpemFyZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG5hdlNlcnZpY2U6IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBwYWdlQ29sbGVjdGlvbjogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlLFxuICAgIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlLFxuICAgIHB1YmxpYyBoZWFkZXJBY3Rpb25TZXJ2aWNlOiBIZWFkZXJBY3Rpb25TZXJ2aWNlLFxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnNcbiAgKSB7XG4gICAgdGhpcy5nb05leHRTdWJzY3JpcHRpb24gPSB0aGlzLm5hdlNlcnZpY2UubW92ZWRUb05leHRQYWdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLm9uTW92ZU5leHQuZW1pdCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5nb1ByZXZpb3VzU3Vic2NyaXB0aW9uID0gdGhpcy5uYXZTZXJ2aWNlLm1vdmVkVG9QcmV2aW91c1BhZ2Uuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMub25Nb3ZlUHJldmlvdXMuZW1pdCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW5jZWxTdWJzY3JpcHRpb24gPSB0aGlzLm5hdlNlcnZpY2Uubm90aWZ5V2l6YXJkQ2FuY2VsLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrQW5kQ2FuY2VsKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLndpemFyZEZpbmlzaGVkU3Vic2NyaXB0aW9uID0gdGhpcy5uYXZTZXJ2aWNlLndpemFyZEZpbmlzaGVkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RvcE5leHQpIHtcbiAgICAgICAgdGhpcy5mb3JjZUZpbmlzaCgpO1xuICAgICAgfVxuICAgICAgdGhpcy53aXphcmRGaW5pc2hlZC5lbWl0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRpZmZlciA9IGRpZmZlcnMuZmluZChbXSkuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgZm9yIG1hcmtpbmcgd2hlbiB0aGUgY29sbGVjdGlvbiBvZiB3aXphcmQgcGFnZXMgaGFzIGJlZW4gYWRkZWQgdG8gb3IgZGVsZXRlZCBmcm9tXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIGRpZmZlcjogYW55O1xuXG4gIC8qKlxuICAgKiBDb250YWlucyB0aGUgc2l6ZSBkZWZpbmVkIGJ5IHRoZSBjbHJXaXphcmRTaXplIGlucHV0XG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkU2l6ZScpIHNpemU6IHN0cmluZyA9ICd4bCc7XG5cbiAgLyoqXG4gICAqIFJlc2V0cyBwYWdlIGNvbXBsZXRlZCBzdGF0ZXMgd2hlbiBuYXZpZ2F0aW5nIGJhY2t3YXJkcy4gQ2FuIGJlIHNldCB1c2luZ1xuICAgKiB0aGUgY2xyV2l6YXJkRm9yY2VGb3J3YXJkTmF2aWdhdGlvbiBpbnB1dC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQElucHV0KCdjbHJXaXphcmRGb3JjZUZvcndhcmROYXZpZ2F0aW9uJylcbiAgc2V0IGZvcmNlRm9yd2FyZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2ZvcmNlRm9yd2FyZCA9ICEhdmFsdWU7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLmZvcmNlRm9yd2FyZE5hdmlnYXRpb24gPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9mb3JjZUZvcndhcmQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IGZvcmNlRm9yd2FyZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VGb3J3YXJkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlbGxzIHRoZSBtb2RhbCBwYXJ0IG9mIHRoZSB3aXphcmQgd2hldGhlciBpdCBzaG91bGQgaGF2ZSBhIGNsb3NlIFwiWFwiXG4gICAqIGluIHRoZSB0b3AgcmlnaHQgY29ybmVyLiBTZXQgd2l0aCB0aGUgY2xyV2l6YXJkQ2xvc2FibGUgaW5wdXQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkQ2xvc2FibGUnKSBjbG9zYWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgb3Blbi9jbG9zZSBvZiB0aGUgd2l6YXJkIGNvbXBvbmVudC4gU2V0IHVzaW5nIHRoZSBjbHJXaXphcmRPcGVuXG4gICAqIGlucHV0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBwdWJsaWMgX29wZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgQElucHV0KCdjbHJXaXphcmRPcGVuJylcbiAgc2V0IGNscldpemFyZE9wZW4ob3BlbjogYm9vbGVhbikge1xuICAgIGlmIChvcGVuKSB7XG4gICAgICB0aGlzLmJ1dHRvblNlcnZpY2UuYnV0dG9uc1JlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fb3BlbiA9IG9wZW47XG4gIH1cblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIG9wZW5lZCBvciBjbG9zZWQuIEVtaXRzIHRocm91Z2ggdGhlXG4gICAqIGNscldpemFyZE9wZW5DaGFuZ2Ugb3V0cHV0LiBXb3JrcyBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZVxuICAgKiBjbHJXaXphcmRPcGVuIGJpbmRpbmcgc28geW91IGNhbiB1c2UuLi5cbiAgICpcbiAgICogPGNsci13aXphcmQgWyhjbHJXaXphcmRPcGVuKV09XCJibGFoXCJcbiAgICogLi4ub3IuLi5cbiAgICogPGNsci13aXphcmQgW2NscldpemFyZE9wZW5dPVwic29tZXRoaW5nXCIgKGNscldpemFyZE9wZW5DaGFuZ2UpPVwiZG9Tb21ldGhpZ24oJGV2ZW50KVwiPlxuICAgKlxuICAgKiAuLi5mb3IgdHdvLXdheSBiaW5kaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRPcGVuQ2hhbmdlJykgX29wZW5DaGFuZ2VkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIGlzIGNhbmNlbGVkLiBDYW4gYmUgb2JzZXJ2ZWQgdGhyb3VnaCB0aGUgY2xyV2l6YXJkT25DYW5jZWxcbiAgICogb3V0cHV0LlxuICAgKlxuICAgKiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWwgaW5wdXQgdG8gY3JlYXRlXG4gICAqIHdpemFyZC1sZXZlbCBjdXN0b20gY2FuY2VsIHJvdXRpbmVzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRPbkNhbmNlbCcpIG9uQ2FuY2VsOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PihmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIHdpemFyZCBpcyBjb21wbGV0ZWQuIENhbiBiZSBvYnNlcnZlZCB0aHJvdWdoIHRoZSBjbHJXaXphcmRPbkZpbmlzaFxuICAgKiBvdXRwdXQuXG4gICAqXG4gICAqIENhbiBiZSBjb21iaW5lZCB3aXRoIHRoZSBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQgaW5wdXQgdG8gY3JlYXRlXG4gICAqIHdpemFyZC1sZXZlbCBjdXN0b20gY29tcGxldGlvbiByb3V0aW5lcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgQE91dHB1dCgnY2xyV2l6YXJkT25GaW5pc2gnKSB3aXphcmRGaW5pc2hlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIHRoZSB3aXphcmQgaXMgcmVzZXQuIFNlZSAucmVzZXQoKS4gQ2FuIGJlIG9ic2VydmVkIHRocm91Z2hcbiAgICogdGhlIGNscldpemFyZE9uUmVzZXQgb3V0cHV0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRPblJlc2V0Jykgb25SZXNldDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBBIFF1ZXJ5TGlzdCBvZiB0aGUgcGFnZXMgaW4gdGhlIHdpemFyZC4gTm90ZSB0aGF0IGEgUXVlcnlMaXN0IGlzIHNvcnQgb2ZcbiAgICogbGlrZSBhbiBBcnJheSBidXQgbm90IHJlYWxseS4gTm90ZSBhbHNvIHRoYXQgcGFnZXMgZG9lcyBub3QgY29udGFpblxuICAgKiBXaXphcmRQYWdlcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIHdpdGggYW4gbmdJZi5cbiAgICpcbiAgICogTW9zdCBpbnRlcmFjdGlvbnMgd2l0aCBhIENscldpemFyZCdzIHBhZ2VzIGFyZSBtb3JlIGVhc2lseSBkb25lIHVzaW5nIHRoZVxuICAgKiBoZWxwZXIgZnVuY3Rpb24gaW4gdGhlIFBhZ2VDb2xsZWN0aW9uU2VydmljZSwgYWNjZXNzaWJsZSBmcm9tIHRoZVxuICAgKiBDbHJXaXphcmQgdGhyb3VnaCBDbHJXaXphcmQucGFnZUNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyV2l6YXJkUGFnZSkgcHVibGljIHBhZ2VzOiBRdWVyeUxpc3Q8Q2xyV2l6YXJkUGFnZT47XG5cbiAgLyoqXG4gICAqIEEgUXVlcnlMaXN0IG9mIHRoZSBoZWFkZXIgYWN0aW9ucyBkZWZpbmVkIGF0IHRoZSBDbHJXaXphcmQgbGV2ZWwuIERvZXMgbm90XG4gICAqIGNvbnRhaW4gaGVhZGVyIGFjdGlvbnMgZGVmaW5lZCBhdCB0aGUgcGFnZSBsZXZlbC4gTW9zdGx5IHVzZWQgYnkgb3RoZXIgZnVuY3Rpb25hbGl0eVxuICAgKiB0aGF0IG5lZWRzIHRvIGVpdGhlciBrbm93IGlmIHRoZSBDbHJXaXphcmQgaGFzIGhlYWRlciBhY3Rpb25zIG9yIG5lZWRzIHRvIHN0YW1wIHRoZW1cbiAgICogc29tZXdoZXJlLlxuICAgKlxuICAgKiBDb3VsZCBiZSB1c2VmdWwgaWYgeW91IG5lZWRlZCB0byBsb2NhdGUgYW5kIHByb2dyYW1tYXRpY2FsbHkgYWN0aXZhdGUgYSBzcGVjaWZpY1xuICAgKiBoZWFkZXIgYWN0aW9uLiBCdXQgdGhpcyBpcyBwcm9iYWJseSBlYXNpZXIgdG8gZG8gYnkgaW52b2tpbmcgdGhlIGhlYWRlciBhY3Rpb24nc1xuICAgKiBldmVudCBoYW5kbGVyIGluIHlvdXIgaG9zdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBDb250ZW50Q2hpbGRyZW4oQ2xyV2l6YXJkSGVhZGVyQWN0aW9uKSBwdWJsaWMgaGVhZGVyQWN0aW9uczogUXVlcnlMaXN0PENscldpemFyZEhlYWRlckFjdGlvbj47XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gdGhlIGN1cnJlbnQgcGFnZSBoYXMgY2hhbmdlZC4gQ2FuIGJlIG9ic2VydmVkIHRocm91Z2ggdGhlIGNscldpemFyZEN1cnJlbnRQYWdlQ2hhbmdlZFxuICAgKiBvdXRwdXQuIFRoaXMgY2FuIGhhcHBlbiBvbiAubmV4dCgpIG9yIC5wcmV2aW91cygpLlxuICAgKiBVc2VmdWwgZm9yIG5vbi1ibG9ja2luZyB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBAT3V0cHV0KCdjbHJXaXphcmRDdXJyZW50UGFnZUNoYW5nZWQnKSBjdXJyZW50UGFnZUNoYW5nZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIG1vdmVzIHRvIHRoZSBuZXh0IHBhZ2UuIENhbiBiZSBvYnNlcnZlZCB0aHJvdWdoIHRoZSBjbHJXaXphcmRPbk5leHRcbiAgICogb3V0cHV0LlxuICAgKlxuICAgKiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0IGlucHV0IHRvIGNyZWF0ZVxuICAgKiB3aXphcmQtbGV2ZWwgY3VzdG9tIG5hdmlnYXRpb24gcm91dGluZXMsIHdoaWNoIGFyZSB1c2VmdWwgZm9yIHZhbGlkYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZE9uTmV4dCcpIG9uTW92ZU5leHQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KGZhbHNlKTtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiB0aGUgd2l6YXJkIG1vdmVzIHRvIHRoZSBwcmV2aW91cyBwYWdlLiBDYW4gYmUgb2JzZXJ2ZWQgdGhyb3VnaCB0aGVcbiAgICogY2xyV2l6YXJkT25QcmV2aW91cyBvdXRwdXQuXG4gICAqXG4gICAqIENhbiBiZSB1c2VmdWwgZm9yIHZhbGlkYXRpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBPdXRwdXQoJ2NscldpemFyZE9uUHJldmlvdXMnKSBvbk1vdmVQcmV2aW91czogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBDbHJXaXphcmQgZnJvbSBtb3ZpbmcgdG8gdGhlIG5leHQgcGFnZSBvciBjbG9zaW5nIGl0c2VsZiBvbiBmaW5pc2hpbmcuXG4gICAqIFNldCB1c2luZyB0aGUgY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0IGlucHV0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdXNpbmcgc3RvcE5leHQgd2lsbCByZXF1aXJlIHlvdSB0byBjcmVhdGUgeW91ciBvd24gY2FsbHMgdG9cbiAgICogLm5leHQoKSBhbmQgLmZpbmlzaCgpIGluIHlvdXIgaG9zdCBjb21wb25lbnQgdG8gbWFrZSB0aGUgQ2xyV2l6YXJkIHdvcmsgYXNcbiAgICogZXhwZWN0ZWQuXG4gICAqXG4gICAqIFByaW1hcmlseSB1c2VkIGZvciB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgV2l6YXJkXG4gICAqXG4gICAqL1xuICBASW5wdXQoJ2NscldpemFyZFByZXZlbnREZWZhdWx0TmV4dCcpXG4gIHNldCBzdG9wTmV4dCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3N0b3BOZXh0ID0gISF2YWx1ZTtcbiAgICB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkSGFzQWx0TmV4dCA9IHZhbHVlO1xuICB9XG4gIHByaXZhdGUgX3N0b3BOZXh0OiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBzdG9wTmV4dCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcE5leHQ7XG4gIH1cblxuICAvKipcbiAgICogUHJldmVudHMgQ2xyV2l6YXJkIGZyb20gY2xvc2luZyB3aGVuIHRoZSBjYW5jZWwgYnV0dG9uIG9yIGNsb3NlIFwiWFwiIGlzIGNsaWNrZWQuXG4gICAqIFNldCB1c2luZyB0aGUgY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWwgaW5wdXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB1c2luZyBzdG9wQ2FuY2VsIHdpbGwgcmVxdWlyZSB5b3UgdG8gY3JlYXRlIHlvdXIgb3duIGNhbGxzIHRvXG4gICAqIC5jbG9zZSgpIGluIHlvdXIgaG9zdCBjb21wb25lbnQgdG8gbWFrZSB0aGUgQ2xyV2l6YXJkIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAqXG4gICAqIFVzZWZ1bCBmb3IgZG9pbmcgY2hlY2tzIG9yIHByb21wdHMgYmVmb3JlIGNsb3NpbmcgYSBDbHJXaXphcmQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUHJldmVudERlZmF1bHRDYW5jZWwnKVxuICBzZXQgc3RvcENhbmNlbCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3N0b3BDYW5jZWwgPSAhIXZhbHVlO1xuICAgIHRoaXMubmF2U2VydmljZS53aXphcmRIYXNBbHRDYW5jZWwgPSB2YWx1ZTtcbiAgfVxuICBwcml2YXRlIF9zdG9wQ2FuY2VsOiBib29sZWFuID0gZmFsc2U7XG4gIGdldCBzdG9wQ2FuY2VsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdG9wQ2FuY2VsO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIENscldpemFyZCBmcm9tIHBlcmZvcm1pbmcgYW55IGZvcm0gb2YgbmF2aWdhdGlvbiBhd2F5IGZyb20gdGhlIGN1cnJlbnRcbiAgICogcGFnZS4gU2V0IHVzaW5nIHRoZSBjbHJXaXphcmRQcmV2ZW50TmF2aWdhdGlvbiBpbnB1dC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHN0b3BOYXZpZ2F0aW9uIGlzIG1lYW50IHRvIGZyZWV6ZSB0aGUgd2l6YXJkIGluIHBsYWNlLCB0eXBpY2FsbHlcbiAgICogZHVyaW5nIGEgbG9uZyB2YWxpZGF0aW9uIG9yIGJhY2tncm91bmQgYWN0aW9uIHdoZXJlIHlvdSB3YW50IHRoZSB3aXphcmQgdG9cbiAgICogZGlzcGxheSBsb2FkaW5nIGNvbnRlbnQgYnV0IG5vdCBhbGxvdyB0aGUgdXNlciB0byBleGVjdXRlIG5hdmlnYXRpb24gaW5cbiAgICogdGhlIHN0ZXBuYXYsIGNsb3NlIFgsIG9yIHRoZSAgYmFjaywgZmluaXNoLCBvciBuZXh0IGJ1dHRvbnMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUHJldmVudE5hdmlnYXRpb24nKVxuICBzZXQgc3RvcE5hdmlnYXRpb24odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9zdG9wTmF2aWdhdGlvbiA9ICEhdmFsdWU7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLndpemFyZFN0b3BOYXZpZ2F0aW9uID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfc3RvcE5hdmlnYXRpb246IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IHN0b3BOYXZpZ2F0aW9uKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdG9wTmF2aWdhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBjbGlja3Mgb24gdGhlIGxpbmtzIGluIHRoZSBzdGVwbmF2IGZyb20gd29ya2luZy5cbiAgICpcbiAgICogQSBtb3JlIGdyYW51bGFyIGJ5cGFzc2luZyBvZiBuYXZpZ2F0aW9uIHdoaWNoIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3VyXG4gICAqIENscldpemFyZCBpcyBpbiBhIHN0YXRlIG9mIGNvbXBsZXRpb24gYW5kIHlvdSBkb24ndCB3YW50IHVzZXJzIHRvIGJlXG4gICAqIGFibGUgdG8ganVtcCBiYWNrd2FyZHMgYW5kIGNoYW5nZSB0aGluZ3MuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkRGlzYWJsZVN0ZXBuYXYnKVxuICBzZXQgZGlzYWJsZVN0ZXBuYXYodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9kaXNhYmxlU3RlcG5hdiA9ICEhdmFsdWU7XG4gICAgdGhpcy5uYXZTZXJ2aWNlLndpemFyZERpc2FibGVTdGVwbmF2ID0gdmFsdWU7XG4gIH1cbiAgcHJpdmF0ZSBfZGlzYWJsZVN0ZXBuYXY6IGJvb2xlYW4gPSBmYWxzZTtcbiAgZ2V0IGRpc2FibGVTdGVwbmF2KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlU3RlcG5hdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIG9ubHkgdG8gY29tbXVuaWNhdGUgdG8gdGhlIHVuZGVybHlpbmcgbW9kYWwgdGhhdCBhbmltYXRpb25zIGFyZSBub3RcbiAgICogd2FudGVkLiBQcmltYXJ5IHVzZSBpcyBmb3IgdGhlIGRpc3BsYXkgb2Ygc3RhdGljL2lubGluZSB3aXphcmRzLlxuICAgKlxuICAgKiBTZXQgdXNpbmcgY2xyV2l6YXJkUHJldmVudE1vZGFsQW5pbWF0aW9uIGlucHV0LiBCdXQgeW91IHNob3VsZCBuZXZlciBzZXQgaXQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIEBJbnB1dCgnY2xyV2l6YXJkUHJldmVudE1vZGFsQW5pbWF0aW9uJykgX3N0b3BNb2RhbEFuaW1hdGlvbnM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHVibGljIGdldCBzdG9wTW9kYWxBbmltYXRpb25zKCk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuX3N0b3BNb2RhbEFuaW1hdGlvbnMpIHtcbiAgICAgIHJldHVybiAndHJ1ZSc7XG4gICAgfVxuICAgIHJldHVybiAnZmFsc2UnO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFBhZ2VTdWJzY3JpcHRpb24gPSB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2VDaGFuZ2VkLnN1YnNjcmliZSgocGFnZTogQ2xyV2l6YXJkUGFnZSkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50UGFnZUNoYW5nZWQuZW1pdCgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnb05leHRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSBnb1ByZXZpb3VzU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgY2FuY2VsU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgY3VycmVudFBhZ2VTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSB3aXphcmRGaW5pc2hlZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmdvTmV4dFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5nb05leHRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ29QcmV2aW91c1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5nb1ByZXZpb3VzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNhbmNlbFN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5jYW5jZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudFBhZ2VTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY3VycmVudFBhZ2VTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMud2l6YXJkRmluaXNoZWRTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMud2l6YXJkRmluaXNoZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCByZWZlcmVuY2VzIHRoYXQgYXJlIG5lZWRlZCBieSB0aGUgcHJvdmlkZXJzLlxuICAgKlxuICAgKiBAbmFtZSBuZ0FmdGVyQ29udGVudEluaXRcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICB0aGlzLnBhZ2VDb2xsZWN0aW9uLnBhZ2VzID0gdGhpcy5wYWdlcztcbiAgICB0aGlzLmhlYWRlckFjdGlvblNlcnZpY2Uud2l6YXJkSGVhZGVyQWN0aW9ucyA9IHRoaXMuaGVhZGVyQWN0aW9ucztcblxuICAgIC8vIE9ubHkgdHJpZ2dlciBidXR0b25zIHJlYWR5IGlmIGRlZmF1bHQgaXMgb3BlbiAoaW5saW5lZClcbiAgICBpZiAodGhpcy5fb3Blbikge1xuICAgICAgdGhpcy5idXR0b25TZXJ2aWNlLmJ1dHRvbnNSZWFkeSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2Ygd2hlbiBwYWdlcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoaXMucGFnZXNcbiAgICpcbiAgICogQG5hbWUgbmdEb0NoZWNrXG4gICAqIEBtZW1iZXJvZiBXaXphcmRcbiAgICpcbiAgICovXG4gIHB1YmxpYyBuZ0RvQ2hlY2soKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZGlmZmVyLmRpZmYodGhpcy5wYWdlcyk7XG4gICAgaWYgKGNoYW5nZXMpIHtcbiAgICAgIGNoYW5nZXMuZm9yRWFjaEFkZGVkSXRlbSgocjogYW55KSA9PiB7XG4gICAgICAgIHRoaXMubmF2U2VydmljZS51cGRhdGVOYXZpZ2F0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIGNoYW5nZXMuZm9yRWFjaFJlbW92ZWRJdGVtKChyOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLnVwZGF0ZU5hdmlnYXRpb24oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW50IHByb3BlcnR5IGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIGEgd2l6YXJkIGlzIHN0YXRpYy9pbi1saW5lIG9yIG5vdC5cbiAgICpcbiAgICogQG5hbWUgaXNTdGF0aWNcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBpc1N0YXRpYygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjbHItd2l6YXJkLS1pbmxpbmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyBhIGdldHRlciwgY3VycmVudCBwYWdlIGlzIGEgY29udmVuaWVudCB3YXkgdG8gcmV0cmlldmUgdGhlIGN1cnJlbnQgcGFnZSBmcm9tXG4gICAqIHRoZSBXaXphcmROYXZpZ2F0aW9uU2VydmljZS5cbiAgICpcbiAgICogQXMgYSBzZXR0ZXIsIGN1cnJlbnQgcGFnZSBhY2NlcHRzIGEgQ2xyV2l6YXJkUGFnZSBhbmQgcGFzc2VzIGl0IHRvIFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlXG4gICAqIHRvIGJlIG1hZGUgdGhlIGN1cnJlbnQgcGFnZS4gY3VycmVudFBhZ2UgcGVyZm9ybXMgY2hlY2tzIHRvIG1ha2Ugc3VyZSBpdCBjYW4gbmF2aWdhdGVcbiAgICogdG8gdGhlIGRlc2lnbmF0ZWQgcGFnZS5cbiAgICpcbiAgICogQG5hbWUgY3VycmVudFBhZ2VcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBjdXJyZW50UGFnZSgpOiBDbHJXaXphcmRQYWdlIHtcbiAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmN1cnJlbnRQYWdlO1xuICB9XG4gIHB1YmxpYyBzZXQgY3VycmVudFBhZ2UocGFnZTogQ2xyV2l6YXJkUGFnZSkge1xuICAgIHRoaXMubmF2U2VydmljZS5nb1RvKHBhZ2UsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbnQgcHJvcGVydHkgZm9yIGRldGVybWluaW5nIGlmIHRoZSBjdXJyZW50IHBhZ2UgaXMgdGhlIGxhc3QgcGFnZSBvZlxuICAgKiB0aGUgd2l6YXJkLlxuICAgKlxuICAgKiBAbmFtZSBpc0xhc3RcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBpc0xhc3QoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubmF2U2VydmljZS5jdXJyZW50UGFnZUlzTGFzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW50IHByb3BlcnR5IGZvciBkZXRlcm1pbmluZyBpZiB0aGUgY3VycmVudCBwYWdlIGlzIHRoZSBmaXJzdCBwYWdlIG9mXG4gICAqIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIEBuYW1lIGlzRmlyc3RcbiAgICpcbiAgICogQG1lbWJlcm9mIFdpemFyZFxuICAgKlxuICAgKi9cbiAgcHVibGljIGdldCBpc0ZpcnN0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2VJc0ZpcnN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIHRoZSBhY3Rpb25zIG5lZWRlZCB0byBvcGVuIHRoZSB3aXphcmQuIElmIHRoZXJlIGlzIG5vIGN1cnJlbnRcbiAgICogcGFnZSBkZWZpbmVkLCBzZXRzIHRoZSBmaXJzdCBwYWdlIGluIHRoZSB3aXphcmQgdG8gYmUgY3VycmVudC5cbiAgICpcbiAgICogQG5hbWUgb3BlblxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgb3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLl9vcGVuID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5jdXJyZW50UGFnZSkge1xuICAgICAgdGhpcy5uYXZTZXJ2aWNlLnNldEZpcnN0UGFnZUN1cnJlbnQoKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IHJlbmRlciBidXR0b25zIHdoZW4gd2l6YXJkIGlzIG9wZW5lZCwgdG8gYXZvaWQgY2hvY29sYXRlIGVycm9yc1xuICAgIHRoaXMuYnV0dG9uU2VydmljZS5idXR0b25zUmVhZHkgPSB0cnVlO1xuXG4gICAgdGhpcy5fb3BlbkNoYW5nZWQuZW1pdCh0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIHRoZSB3b3JrIGludm9sdmVkIHdpdGggY2xvc2luZyB0aGUgd2l6YXJkLiBDYWxsIHRoaXMgZGlyZWN0bHkgaW5zdGVhZFxuICAgKiBvZiBjYW5jZWwoKSB0byBpbXBsZW1lbnQgYWx0ZXJuYXRpdmUgY2FuY2VsIGZ1bmN0aW9uYWxpdHkuXG4gICAqXG4gICAqIEBuYW1lIGNsb3NlXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBjbG9zZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdG9wTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX29wZW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGVuQ2hhbmdlZC5lbWl0KGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW50IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gb3BlbiBhbmQgY2xvc2UgdGhlIHdpemFyZC4gSXQgb3BlcmF0ZXNcbiAgICogYnkgY2hlY2tpbmcgYSBCb29sZWFuIHBhcmFtZXRlci4gSWYgdHJ1ZSwgdGhlIHdpemFyZCBpcyBvcGVuZWQuIElmIGZhbHNlLFxuICAgKiBpdCBpcyBjbG9zZWQuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUgZm9yIHRoaXMgcGFyYW1ldGVyLCBzbyBieSBkZWZhdWx0IHRoZSB3aXphcmQgd2lsbFxuICAgKiBjbG9zZSBpZiBpbnZva2VkIHdpdGggbm8gcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAbmFtZSB0b2dnbGVcbiAgICpcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIHRvZ2dsZSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIHdpemFyZCB0byB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICpcbiAgICogQG5hbWUgcHJldmlvdXNcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIHByZXZpb3VzKCk6IHZvaWQge1xuICAgIHRoaXMubmF2U2VydmljZS5wcmV2aW91cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY2x1ZGVzIGEgQm9vbGVhbiBwYXJhbWV0ZXIgdGhhdCB3aWxsIHNraXAgY2hlY2tzIGFuZCBldmVudCBlbWlzc2lvbnMuXG4gICAqIElmIHRydWUsIHRoZSB3aXphcmQgd2lsbCBtb3ZlIHRvIHRoZSBuZXh0IHBhZ2UgcmVnYXJkbGVzcyBvZiB0aGUgc3RhdGUgb2ZcbiAgICogaXRzIGN1cnJlbnQgcGFnZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGFsdGVybmF0aXZlIG5hdmlnYXRpb24gd2hlcmUgZXZlbnRcbiAgICogZW1pc3Npb25zIGhhdmUgYWxyZWFkeSBiZWVuIGRvbmUgYW5kIGZpcmluZyB0aGVtIGFnYWluIG1heSBjYXVzZSBhbiBldmVudCBsb29wLlxuICAgKlxuICAgKiBHZW5lcmFsbHksIHdpdGggYWx0ZXJuYXRpdmUgbmF2aWdhdGlvbiwgdXNlcnMgYXJlIHN1cHBseWluZyB0aGVpciBvd24gY2hlY2tzXG4gICAqIGFuZCB2YWxpZGF0aW9uLiBTbyB0aGVyZSBpcyBubyBwb2ludCBpbiBzdXBlcnNlZGluZyB0aGVpciBidXNpbmVzcyBsb2dpY1xuICAgKiB3aXRoIG91ciBkZWZhdWx0IGJlaGF2aW9yLlxuICAgKlxuICAgKiBJZiBmYWxzZSwgdGhlIHdpemFyZCB3aWxsIGV4ZWN1dGUgZGVmYXVsdCBjaGVja3MgYW5kIGVtaXQgZXZlbnRzIGFzIG5vcm1hbC5cbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGN1c3RvbSBidXR0b25zIG9yIHByb2dyYW1tYXRpYyB3b3JrZmxvd3MgdGhhdCBhcmUgbm90XG4gICAqIGV4ZWN1dGluZyB0aGUgd2l6YXJkcyBkZWZhdWx0IGNoZWNrcyBhbmQgZW1pc3Npb25zLiBJdCBpcyBhbm90aGVyIHdheSB0b1xuICAgKiBuYXZpZ2F0ZSB3aXRob3V0IGhhdmluZyB0byByZXdyaXRlIHRoZSB3aXphcmTDosKAwplzIGRlZmF1bHQgZnVuY3Rpb25hbGl0eVxuICAgKiBmcm9tIHNjcmF0Y2guXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIG5leHQoKSBkb2VzIG5vdCBleGVjdXRlIGV2ZW50IGVtaXNzaW9ucyBvciBjaGVja3MgYmVjYXVzZSB0aGVcbiAgICogODAlIGNhc2UgaXMgdGhhdCB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhcyBwYXJ0IG9mIGFuIGFsdGVybmF0aXZlXG4gICAqIG5hdmlnYXRpb24gd2l0aCBjbHJXaXphcmRQcmV2ZW50RGVmYXVsdE5leHQuXG4gICAqXG4gICAqIEBuYW1lIG5leHRcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIG5leHQoc2tpcENoZWNrc0FuZEVtaXRzOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgIGlmIChza2lwQ2hlY2tzQW5kRW1pdHMpIHtcbiAgICAgIHRoaXMuZm9yY2VOZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmF2U2VydmljZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluY2x1ZGVzIGEgQm9vbGVhbiBwYXJhbWV0ZXIgdGhhdCB3aWxsIHNraXAgY2hlY2tzIGFuZCBldmVudCBlbWlzc2lvbnMuXG4gICAqIElmIHRydWUsIHRoZSB3aXphcmQgd2lsbCAgY29tcGxldGUgYW5kIGNsb3NlIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXRlIG9mXG4gICAqIGl0cyBjdXJyZW50IHBhZ2UuIFRoaXMgaXMgdXNlZnVsIGZvciBhbHRlcm5hdGl2ZSBuYXZpZ2F0aW9uIHdoZXJlIGV2ZW50XG4gICAqIGVtaXNzaW9ucyBoYXZlIGFscmVhZHkgYmVlbiBkb25lIGFuZCBmaXJpbmcgdGhlbSBhZ2FpbiBtYXkgY2F1c2UgYW4gZXZlbnQgbG9vcC5cbiAgICpcbiAgICogSWYgZmFsc2UsIHRoZSB3aXphcmQgd2lsbCBleGVjdXRlIGRlZmF1bHQgY2hlY2tzIGFuZCBlbWl0IGV2ZW50cyBiZWZvcmVcbiAgICogY29tcGxldGluZyBhbmQgY2xvc2luZy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgZmluaXNoKCkgZG9lcyBub3QgZXhlY3V0ZSBldmVudCBlbWlzc2lvbnMgb3IgY2hlY2tzIGJlY2F1c2UgdGhlXG4gICAqIDgwJSBjYXNlIGlzIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgYXMgcGFydCBvZiBhbiBhbHRlcm5hdGl2ZVxuICAgKiBuYXZpZ2F0aW9uIHdpdGggY2xyV2l6YXJkUHJldmVudERlZmF1bHROZXh0LlxuICAgKlxuICAgKiBAbmFtZSBmaW5pc2hcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIGZpbmlzaChza2lwQ2hlY2tzQW5kRW1pdHM6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgaWYgKHNraXBDaGVja3NBbmRFbWl0cykge1xuICAgICAgdGhpcy5mb3JjZUZpbmlzaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5hdlNlcnZpY2UuZmluaXNoKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgdGhlIHdvcmsgb2YgZmluaXNoaW5nIHVwIHRoZSB3aXphcmQgYW5kIGNsb3NpbmcgaXQgYnV0IGRvZXNuJ3QgZG8gdGhlXG4gICAqIGNoZWNrcyBhbmQgZW1pc3Npb25zIHRoYXQgb3RoZXIgcGF0aHMgZG8uIEdvb2QgZm9yIGEgbGFzdCBzdGVwIGluIGFuXG4gICAqIGFsdGVybmF0ZSB3b3JrZmxvdy5cbiAgICpcbiAgICogRG9lcyB0aGUgc2FtZSB0aGluZyBhcyBjYWxsaW5nIENscldpemFyZC5maW5pc2godHJ1ZSkgb3IgQ2xyV2l6YXJkLmZpbmlzaCgpXG4gICAqIHdpdGhvdXQgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBuYW1lIGZvcmNlRmluaXNoXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBmb3JjZUZpbmlzaCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdG9wTmF2aWdhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEb2VzIHRoZSB3b3JrIG9mIG1vdmluZyB0aGUgd2l6YXJkIHRvIHRoZSBuZXh0IHBhZ2Ugd2l0aG91dCB0aGVcbiAgICogY2hlY2tzIGFuZCBlbWlzc2lvbnMgdGhhdCBvdGhlciBwYXRocyBkby4gR29vZCBmb3IgYSBsYXN0IHN0ZXAgaW4gYW5cbiAgICogYWx0ZXJuYXRlIHdvcmtmbG93LlxuICAgKlxuICAgKiBEb2VzIHRoZSBzYW1lIHRoaW5nIGFzIGNhbGxpbmcgQ2xyV2l6YXJkLm5leHQodHJ1ZSkgb3IgQ2xyV2l6YXJkLm5leHQoKVxuICAgKiB3aXRob3V0IGEgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAbmFtZSBmb3JjZU5leHRcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIGZvcmNlTmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLm5hdlNlcnZpY2UuZm9yY2VOZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIHRoZSBmdW5jdGlvbmFsaXR5IHRoYXQgY2FuY2VscyBhbmQgY2xvc2VzIHRoZSB3aXphcmQuXG4gICAqXG4gICAqIERvIG5vdCB1c2UgdGhpcyBmb3IgYW4gb3ZlcnJpZGUgb2YgdGhlIGNhbmNlbCB0aGUgZnVuY3Rpb25hbGl0eVxuICAgKiB3aXRoIGNscldpemFyZFByZXZlbnREZWZhdWx0Q2FuY2VsLCBjbHJXaXphcmRQcmV2ZW50UGFnZURlZmF1bHRDYW5jZWwsXG4gICAqIG9yIGNscldpemFyZFBhZ2VQcmV2ZW50RGVmYXVsdCBiZWNhdXNlIGl0IHdpbGwgaW5pdGlhdGUgdGhlIHNhbWUgY2hlY2tzXG4gICAqIGFuZCBldmVudCBlbWlzc2lvbnMgdGhhdCBpbnZva2VkIHlvdXIgZXZlbnQgaGFuZGxlci5cbiAgICpcbiAgICogVXNlIENscldpemFyZC5jbG9zZSgpIGluc3RlYWQuXG4gICAqXG4gICAqIEBuYW1lIGNhbmNlbFxuICAgKiBAbWVtYmVyb2YgQ2xyV2l6YXJkXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMubmF2U2VydmljZS5jYW5jZWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYmVoYXZpb3Igb2YgdGhlIHVuZGVybHlpbmcgbW9kYWwgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoXG4gICAqIGFsdGVybmF0aXZlIGNhbmNlbCBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBJbiBtb3N0IGNhc2VzLCB1c2UgQ2xyV2l6YXJkLmNhbmNlbCgpIGluc3RlYWQuXG4gICAqXG4gICAqIEBuYW1lIG1vZGFsQ2FuY2VsXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBtb2RhbENhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrQW5kQ2FuY2VsKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGZvciBhbHRlcm5hdGl2ZSBjYW5jZWwgZmxvd3MgZGVmaW5lZCBhdCB0aGUgY3VycmVudCBwYWdlIG9yXG4gICAqIHdpemFyZCBsZXZlbC4gUGVyZm9ybXMgYSBjYW5jZWxlZCBpZiBub3QuIEVtaXRzIGV2ZW50cyB0aGF0IGluaXRpYXRlXG4gICAqIHRoZSBhbHRlcm5hdGl2ZSBjYW5jZWwgb3V0cHV0cyAoY2xyV2l6YXJkUGFnZU9uQ2FuY2VsIGFuZFxuICAgKiBjbHJXaXphcmRPbkNhbmNlbCkgaWYgc28uXG4gICAqXG4gICAqIEBuYW1lIGNoZWNrQW5kQ2FuY2VsXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBjaGVja0FuZENhbmNlbCgpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50UGFnZSA9IHRoaXMuY3VycmVudFBhZ2U7XG4gICAgY29uc3QgY3VycmVudFBhZ2VIYXNPdmVycmlkZXMgPSBjdXJyZW50UGFnZS5zdG9wQ2FuY2VsIHx8IGN1cnJlbnRQYWdlLnByZXZlbnREZWZhdWx0O1xuXG4gICAgaWYgKHRoaXMuc3RvcE5hdmlnYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50UGFnZS5wYWdlT25DYW5jZWwuZW1pdCgpO1xuICAgIGlmICghY3VycmVudFBhZ2VIYXNPdmVycmlkZXMpIHtcbiAgICAgIHRoaXMub25DYW5jZWwuZW1pdCgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdG9wQ2FuY2VsICYmICFjdXJyZW50UGFnZUhhc092ZXJyaWRlcykge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHRzIHRoZSB3aXphcmQgSUQgYXMgYSBzdHJpbmcgcGFyYW1ldGVyIGFuZCBjYWxscyB0byBXaXphcmROYXZpZ2F0aW9uU2VydmljZVxuICAgKiB0byBuYXZpZ2F0ZSB0byB0aGUgcGFnZSB3aXRoIHRoYXQgSUQuIE5hdmlnYXRpb24gd2lsbCBpbnZva2UgdGhlIHdpemFyZMOiwoDCmXMgZGVmYXVsdFxuICAgKiBjaGVja3MgYW5kIGV2ZW50IGVtaXNzaW9ucy5cbiAgICpcbiAgICogUHJvYmFibHkgbGVzcyB1c2VmdWwgdGhhbiBjYWxsaW5nIGRpcmVjdGx5IHRvIENscldpemFyZC5uYXZTZXJ2aWNlLmdvVG8oKSBiZWNhdXNlIHRoZVxuICAgKiBuYXYgc2VydmljZSBtZXRob2QgY2FuIGFjY2VwdCBlaXRoZXIgYSBzdHJpbmcgSUQgb3IgYSBwYWdlIG9iamVjdC5cbiAgICpcbiAgICogVGhlIGZvcm1hdCBvZiB0aGUgZXhwZWN0ZWQgSUQgcGFyYW1ldGVyIGNhbiBiZSBmb3VuZCBpbiB0aGUgcmV0dXJuIG9mIHRoZVxuICAgKiBDbHJXaXphcmRQYWdlLmlkIGdldHRlciwgdXN1YWxseSBwcmVmaXhlZCB3aXRoIMOiwoDCnGNsci13aXphcmQtcGFnZS3DosKAwpwgYW5kIHRoZW4gZWl0aGVyIGFcbiAgICogbnVtZXJpYyBJRCBvciB0aGUgSUQgc3BlY2lmaWVkIGZvciB0aGUgQ2xyV2l6YXJkUGFnZSBjb21wb25lbnTDosKAwplzIMOiwoDCnGlkw6LCgMKdIGlucHV0LlxuICAgKlxuICAgKiBAbmFtZSBnb1RvXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDbHJXaXphcmRcbiAgICovXG4gIHB1YmxpYyBnb1RvKHBhZ2VJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFwYWdlSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5hdlNlcnZpY2UuZ29UbyhwYWdlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCBjYWxscyB0byBQYWdlQ29sbGVjdGlvblNlcnZpY2UucmVzZXQoKSBhbmQgZW1pdHMgdGhlXG4gICAqIENscldpemFyZC5vblJlc2V0IGV2ZW50LlxuICAgKlxuICAgKiBSZXNldCBzZXRzIGFsbCBXaXphcmRQYWdlcyB0byBpbmNvbXBsZXRlIGFuZCBzZXRzIHRoZSBmaXJzdCBwYWdlIGluIHRoZSBDbHJXaXphcmQgdG9cbiAgICogYmUgdGhlIGN1cnJlbnQgcGFnZSwgZXNzZW50aWFsbHkgcmVzZXR0aW5nIHRoZSB3aXphcmQgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogVXNlcnMgd291bGQgdGhlbiB1c2UgdGhlIG9uUmVzZXQgZXZlbnQgdG8gcmVzZXQgdGhlIGRhdGEgb3IgbW9kZWwgaW4gdGhlaXJcbiAgICogaG9zdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEl0IGNvdWxkIGJlIHVzZWZ1bCB0byBjYWxsIGEgcmVzZXQgd2l0aG91dCBmaXJpbmcgdGhlIG9uUmVzZXQgZXZlbnQuIFRvIGRvIHRoaXMsXG4gICAqIGp1c3QgY2FsbCBDbHJXaXphcmQucGFnZUNvbGxlY3Rpb24ucmVzZXQoKSBkaXJlY3RseS5cbiAgICpcbiAgICogQG5hbWUgcmVzZXRcbiAgICogQG1lbWJlcm9mIENscldpemFyZFxuICAgKi9cbiAgcHVibGljIHJlc2V0KCkge1xuICAgIHRoaXMucGFnZUNvbGxlY3Rpb24ucmVzZXQoKTtcbiAgICB0aGlzLm9uUmVzZXQubmV4dCgpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEJ1dHRvbkh1YlNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9idXR0b24taHViLnNlcnZpY2UnO1xuaW1wb3J0IHsgV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy93aXphcmQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQlVUVE9OX1RZUEVTOiBhbnkgPSB7XG4gIGNhbmNlbDogJ2NhbmNlbCcsXG4gIHByZXZpb3VzOiAncHJldmlvdXMnLFxuICBuZXh0OiAnbmV4dCcsXG4gIGZpbmlzaDogJ2ZpbmlzaCcsXG4gIGRhbmdlcjogJ2RhbmdlcicsXG59O1xuXG5leHBvcnQgY29uc3QgQ1VTVE9NX0JVVFRPTl9UWVBFUzogYW55ID0ge1xuICBjYW5jZWw6ICdjdXN0b20tY2FuY2VsJyxcbiAgcHJldmlvdXM6ICdjdXN0b20tcHJldmlvdXMnLFxuICBuZXh0OiAnY3VzdG9tLW5leHQnLFxuICBmaW5pc2g6ICdjdXN0b20tZmluaXNoJyxcbiAgZGFuZ2VyOiAnY3VzdG9tLWRhbmdlcicsXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItd2l6YXJkLWJ1dHRvbicsXG4gIHRlbXBsYXRlOiBgXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgY2xhc3M9XCJidG4gY2xyLXdpemFyZC1idG5cIlxuICAgICAgICAgICAgW2NsYXNzLmJ0bi1saW5rXT1cImlzQ2FuY2VsXCJcbiAgICAgICAgICAgIFtjbGFzcy5jbHItd2l6YXJkLWJ0bi0tdGVydGlhcnldPVwiaXNDYW5jZWxcIlxuICAgICAgICAgICAgW2NsYXNzLmJ0bi1vdXRsaW5lXT1cImlzUHJldmlvdXNcIlxuICAgICAgICAgICAgW2NsYXNzLmNsci13aXphcmQtYnRuLS1zZWNvbmRhcnldPVwiaXNQcmV2aW91c1wiXG4gICAgICAgICAgICBbY2xhc3MuYnRuLXByaW1hcnldPVwiaXNQcmltYXJ5QWN0aW9uXCJcbiAgICAgICAgICAgIFtjbGFzcy5jbHItd2l6YXJkLWJ0bi0tcHJpbWFyeV09XCJpc1ByaW1hcnlBY3Rpb25cIlxuICAgICAgICAgICAgW2NsYXNzLmJ0bi1zdWNjZXNzXT1cImlzRmluaXNoXCJcbiAgICAgICAgICAgIFtjbGFzcy5idG4tZGFuZ2VyXT1cImlzRGFuZ2VyXCJcbiAgICAgICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJpc0Rpc2FibGVkXCJcbiAgICAgICAgICAgIFthdHRyLmRpc2FibGVkXT1cIl9kaXNhYmxlZEF0dHJpYnV0ZVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiY2xpY2soKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2J1dHRvbj5cbiAgICBgLFxuICBob3N0OiB7IGNsYXNzOiAnY2xyLXdpemFyZC1idG4td3JhcHBlcicsICdbYXR0ci5hcmlhLWhpZGRlbl0nOiAnaXNIaWRkZW4nIH0sXG4gIHN0eWxlczogWydbYXJpYS1oaWRkZW49XCJ0cnVlXCJdIHsgZGlzcGxheTogbm9uZTsgfSddLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJXaXphcmRCdXR0b24ge1xuICBASW5wdXQoJ3R5cGUnKSBwdWJsaWMgdHlwZTogc3RyaW5nID0gJyc7XG5cbiAgQElucHV0KCdjbHJXaXphcmRCdXR0b25EaXNhYmxlZCcpIHB1YmxpYyBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBJbnB1dCgnY2xyV2l6YXJkQnV0dG9uSGlkZGVuJykgcHVibGljIGhpZGRlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIEV2ZW50RW1pdHRlciB3aGljaCBpcyBlbWl0dGVkIHdoZW4gYSBidXR0b24gaXMgY2xpY2tlZC5cbiAgQE91dHB1dCgnY2xyV2l6YXJkQnV0dG9uQ2xpY2tlZCcpIHdhc0NsaWNrZWQ6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KGZhbHNlKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmF2U2VydmljZTogV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UsIHB1YmxpYyBidXR0b25TZXJ2aWNlOiBCdXR0b25IdWJTZXJ2aWNlKSB7fVxuXG4gIHByaXZhdGUgY2hlY2tEZWZhdWx0QW5kQ3VzdG9tVHlwZSh2YWx1ZVRvQ2hlY2s6IHN0cmluZyA9ICcnLCB0eXBlVG9Mb29rVXA6IHN0cmluZykge1xuICAgIGlmIChERUZBVUxUX0JVVFRPTl9UWVBFU1t0eXBlVG9Mb29rVXBdID09PSB2YWx1ZVRvQ2hlY2spIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQ1VTVE9NX0JVVFRPTl9UWVBFU1t0eXBlVG9Mb29rVXBdID09PSB2YWx1ZVRvQ2hlY2spIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzQ2FuY2VsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNoZWNrRGVmYXVsdEFuZEN1c3RvbVR5cGUodGhpcy50eXBlLCAnY2FuY2VsJyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzTmV4dCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ25leHQnKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNQcmV2aW91cygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jaGVja0RlZmF1bHRBbmRDdXN0b21UeXBlKHRoaXMudHlwZSwgJ3ByZXZpb3VzJyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzRmluaXNoKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNoZWNrRGVmYXVsdEFuZEN1c3RvbVR5cGUodGhpcy50eXBlLCAnZmluaXNoJyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzRGFuZ2VyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNoZWNrRGVmYXVsdEFuZEN1c3RvbVR5cGUodGhpcy50eXBlLCAnZGFuZ2VyJyk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzUHJpbWFyeUFjdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc05leHQgfHwgdGhpcy5pc0RhbmdlciB8fCB0aGlzLmlzRmluaXNoO1xuICB9XG5cbiAgcHVibGljIGdldCBfZGlzYWJsZWRBdHRyaWJ1dGUoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNEaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAvLyBkZWFsaW5nIHdpdGggbmVnYXRpdmVzIGhlcmUuIGNvZ25pdGl2ZWx5IGVhc2llciB0byB0aGluayBvZiBpdCBsaWtlIHRoaXMuLi5cbiAgICBjb25zdCBkaXNhYmxlZCA9IHRydWU7XG4gICAgY29uc3QgbmF2ID0gdGhpcy5uYXZTZXJ2aWNlO1xuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLm5hdlNlcnZpY2UuY3VycmVudFBhZ2U7XG5cbiAgICAvLyBFbnN1cmUgd2UgZG9uJ3QgY2hhbmdlIHRoZSByZXNwb25zZSB1bnRpbCBidXR0b25zIGFyZSByZWFkeSB0byBhdm9pZCBjaG9jb2xhdGVcbiAgICBpZiAoIXRoaXMuYnV0dG9uU2VydmljZS5idXR0b25zUmVhZHkpIHtcbiAgICAgIHJldHVybiAhZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgbmF2LndpemFyZFN0b3BOYXZpZ2F0aW9uIHx8ICFwYWdlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NhbmNlbCkge1xuICAgICAgcmV0dXJuICFkaXNhYmxlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1ByZXZpb3VzICYmIChuYXYuY3VycmVudFBhZ2VJc0ZpcnN0IHx8IHBhZ2UucHJldmlvdXNTdGVwRGlzYWJsZWQpKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNEYW5nZXIgJiYgIXBhZ2UucmVhZHlUb0NvbXBsZXRlKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOZXh0ICYmIChuYXYuY3VycmVudFBhZ2VJc0xhc3QgfHwgIXBhZ2UucmVhZHlUb0NvbXBsZXRlKSkge1xuICAgICAgcmV0dXJuIGRpc2FibGVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRmluaXNoICYmICghbmF2LmN1cnJlbnRQYWdlSXNMYXN0IHx8ICFwYWdlLnJlYWR5VG9Db21wbGV0ZSkpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gIWRpc2FibGVkO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0hpZGRlbigpOiBib29sZWFuIHtcbiAgICAvLyBkZWFsaW5nIHdpdGggbmVnYXRpdmVzIGhlcmUuIGNvZ25pdGl2ZWx5IGVhc2llciB0byB0aGluayBvZiBpdCBsaWtlIHRoaXMuLi5cbiAgICBjb25zdCBoaWRkZW4gPSB0cnVlO1xuICAgIGNvbnN0IG5hdiA9IHRoaXMubmF2U2VydmljZTtcblxuICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBjaGFuZ2UgdGhlIHJlc3BvbnNlIHVudGlsIGJ1dHRvbnMgYXJlIHJlYWR5IHRvIGF2b2lkIGNob2NvbGF0ZVxuICAgIGlmICghdGhpcy5idXR0b25TZXJ2aWNlLmJ1dHRvbnNSZWFkeSkge1xuICAgICAgcmV0dXJuICFoaWRkZW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGlkZGVuKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0NhbmNlbCkge1xuICAgICAgcmV0dXJuICFoaWRkZW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQcmV2aW91cyAmJiBuYXYuY3VycmVudFBhZ2VJc0ZpcnN0KSB7XG4gICAgICByZXR1cm4gaGlkZGVuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTmV4dCAmJiBuYXYuY3VycmVudFBhZ2VJc0xhc3QpIHtcbiAgICAgIHJldHVybiBoaWRkZW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNGaW5pc2ggJiYgIW5hdi5jdXJyZW50UGFnZUlzTGFzdCkge1xuICAgICAgcmV0dXJuIGhpZGRlbjtcbiAgICB9XG5cbiAgICByZXR1cm4gIWhpZGRlbjtcbiAgfVxuXG4gIGNsaWNrKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndhc0NsaWNrZWQuZW1pdCh0aGlzLnR5cGUpO1xuICAgIHRoaXMuYnV0dG9uU2VydmljZS5idXR0b25DbGlja2VkKHRoaXMudHlwZSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ2Nsci13aXphcmQtdGl0bGUsIGNsci13aXphcmQtcGFnZXRpdGxlJyB9KVxuZXhwb3J0IGNsYXNzIENscldpemFyZEN1c3RvbVRhZ3Mge1xuICAvLyBObyBiZWhhdmlvclxuICAvLyBUaGUgb25seSBwdXJwb3NlIGlzIHRvIFwiZGVjbGFyZVwiIHRoZSB0YWcgaW4gQW5ndWxhclxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFBhZ2VDb2xsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UtY29sbGVjdGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLXdpemFyZC1zdGVwbmF2JyxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPG9sIGNsYXNzPVwiY2xyLXdpemFyZC1zdGVwbmF2LWxpc3RcIiByb2xlPVwidGFibGlzdFwiPlxuICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBwYWdlIG9mIHBhZ2VTZXJ2aWNlLnBhZ2VzXCIgY2xyLXdpemFyZC1zdGVwbmF2LWl0ZW0gXG4gICAgICAgICAgICBbcGFnZV09XCJwYWdlXCIgY2xhc3M9XCJjbHItd2l6YXJkLXN0ZXBuYXYtaXRlbVwiPjwvbGk+XG4gICAgICAgIDwvb2w+XG4gICAgYCxcbiAgaG9zdDogeyBjbGFzczogJ2Nsci13aXphcmQtc3RlcG5hdicgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkU3RlcG5hdiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYWdlU2VydmljZTogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlKSB7fVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBhZ2VDb2xsZWN0aW9uU2VydmljZSB9IGZyb20gJy4vcHJvdmlkZXJzL3BhZ2UtY29sbGVjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFdpemFyZE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvd2l6YXJkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi93aXphcmQtcGFnZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ1tjbHItd2l6YXJkLXN0ZXBuYXYtaXRlbV0nLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tbGluayBjbHItd2l6YXJkLXN0ZXBuYXYtbGlua1wiIChjbGljayk9XCJjbGljaygpXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwicGFnZS5uYXZUaXRsZVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIGAsXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICdpZCcsXG4gICAgJ1thdHRyLmFyaWEtc2VsZWN0ZWRdJzogJ2lzQ3VycmVudCcsXG4gICAgJ1thdHRyLmFyaWEtY29udHJvbHNdJzogJ2lkJyxcbiAgICByb2xlOiAndGFiJyxcbiAgICAnW2NsYXNzLmNsci1uYXYtbGlua10nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5uYXYtaXRlbV0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5hY3RpdmVdJzogJ2lzQ3VycmVudCcsXG4gICAgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnaXNEaXNhYmxlZCcsXG4gICAgJ1tjbGFzcy5uby1jbGlja10nOiAnIWNhbk5hdmlnYXRlJyxcbiAgICAnW2NsYXNzLmNvbXBsZXRlXSc6ICdpc0NvbXBsZXRlJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyV2l6YXJkU3RlcG5hdkl0ZW0ge1xuICBASW5wdXQoJ3BhZ2UnKSBwdWJsaWMgcGFnZTogQ2xyV2l6YXJkUGFnZTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmF2U2VydmljZTogV2l6YXJkTmF2aWdhdGlvblNlcnZpY2UsIHB1YmxpYyBwYWdlQ29sbGVjdGlvbjogUGFnZUNvbGxlY3Rpb25TZXJ2aWNlKSB7fVxuXG4gIHByaXZhdGUgcGFnZUd1YXJkKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5wYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpemFyZCBzdGVwbmF2IGl0ZW0gaXMgbm90IGFzc29jaWF0ZWQgd2l0aCBhIHdpemFyZCBwYWdlLicpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICB0aGlzLnBhZ2VHdWFyZCgpO1xuICAgIHJldHVybiB0aGlzLnBhZ2VDb2xsZWN0aW9uLmdldFN0ZXBJdGVtSWRGb3JQYWdlKHRoaXMucGFnZSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgdGhpcy5wYWdlR3VhcmQoKTtcbiAgICByZXR1cm4gdGhpcy5wYWdlLmRpc2FibGVkIHx8IHRoaXMubmF2U2VydmljZS53aXphcmRTdG9wTmF2aWdhdGlvbiB8fCB0aGlzLm5hdlNlcnZpY2Uud2l6YXJkRGlzYWJsZVN0ZXBuYXY7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzQ3VycmVudCgpOiBib29sZWFuIHtcbiAgICB0aGlzLnBhZ2VHdWFyZCgpO1xuICAgIHJldHVybiB0aGlzLnBhZ2UuY3VycmVudDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNDb21wbGV0ZSgpOiBib29sZWFuIHtcbiAgICB0aGlzLnBhZ2VHdWFyZCgpO1xuICAgIHJldHVybiB0aGlzLnBhZ2UuY29tcGxldGVkO1xuICB9XG5cbiAgcHVibGljIGdldCBjYW5OYXZpZ2F0ZSgpOiBib29sZWFuIHtcbiAgICB0aGlzLnBhZ2VHdWFyZCgpO1xuICAgIHJldHVybiB0aGlzLnBhZ2VDb2xsZWN0aW9uLnByZXZpb3VzUGFnZUlzQ29tcGxldGVkKHRoaXMucGFnZSk7XG4gIH1cblxuICBjbGljaygpOiB2b2lkIHtcbiAgICB0aGlzLnBhZ2VHdWFyZCgpO1xuXG4gICAgLy8gaWYgd2UgY2xpY2sgb24gb3VyIG93biBzdGVwbmF2IG9yIGEgZGlzYWJsZWQgc3RlcG5hdiwgd2UgZG9uJ3Qgd2FudCB0byBkbyBhbnl0aGluZ1xuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQgfHwgdGhpcy5pc0N1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5hdlNlcnZpY2UuZ29Ubyh0aGlzLnBhZ2UpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2LTIwMTggVk13YXJlLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBUaGlzIHNvZnR3YXJlIGlzIHJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlLlxuICogVGhlIGZ1bGwgbGljZW5zZSBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaW4gTElDRU5TRSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBwcm9qZWN0LlxuICovXG5cbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDbHJBbGVydE1vZHVsZSB9IGZyb20gJy4uL2VtcGhhc2lzL2FsZXJ0L2FsZXJ0Lm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJNb2RhbE1vZHVsZSB9IGZyb20gJy4uL21vZGFsL21vZGFsLm1vZHVsZSc7XG5cbmltcG9ydCB7IENscldpemFyZCB9IGZyb20gJy4vd2l6YXJkJztcbmltcG9ydCB7IENscldpemFyZEJ1dHRvbiB9IGZyb20gJy4vd2l6YXJkLWJ1dHRvbic7XG5pbXBvcnQgeyBDbHJXaXphcmRDdXN0b21UYWdzIH0gZnJvbSAnLi93aXphcmQtY3VzdG9tLXRhZ3MnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkSGVhZGVyQWN0aW9uIH0gZnJvbSAnLi93aXphcmQtaGVhZGVyLWFjdGlvbic7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlIH0gZnJvbSAnLi93aXphcmQtcGFnZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlQnV0dG9ucyB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtYnV0dG9ucyc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlSGVhZGVyQWN0aW9ucyB9IGZyb20gJy4vd2l6YXJkLXBhZ2UtaGVhZGVyLWFjdGlvbnMnO1xuaW1wb3J0IHsgQ2xyV2l6YXJkUGFnZU5hdlRpdGxlIH0gZnJvbSAnLi93aXphcmQtcGFnZS1uYXZ0aXRsZSc7XG5pbXBvcnQgeyBDbHJXaXphcmRQYWdlVGl0bGUgfSBmcm9tICcuL3dpemFyZC1wYWdlLXRpdGxlJztcbmltcG9ydCB7IENscldpemFyZFN0ZXBuYXYgfSBmcm9tICcuL3dpemFyZC1zdGVwbmF2JztcbmltcG9ydCB7IENscldpemFyZFN0ZXBuYXZJdGVtIH0gZnJvbSAnLi93aXphcmQtc3RlcG5hdi1pdGVtJztcblxuZXhwb3J0IGNvbnN0IENMUl9XSVpBUkRfRElSRUNUSVZFUzogYW55W10gPSBbXG4gIENscldpemFyZCxcbiAgQ2xyV2l6YXJkUGFnZSxcbiAgQ2xyV2l6YXJkU3RlcG5hdixcbiAgQ2xyV2l6YXJkU3RlcG5hdkl0ZW0sXG4gIENscldpemFyZEJ1dHRvbixcbiAgQ2xyV2l6YXJkSGVhZGVyQWN0aW9uLFxuICBDbHJXaXphcmRDdXN0b21UYWdzLFxuICBDbHJXaXphcmRQYWdlVGl0bGUsXG4gIENscldpemFyZFBhZ2VOYXZUaXRsZSxcbiAgQ2xyV2l6YXJkUGFnZUJ1dHRvbnMsXG4gIENscldpemFyZFBhZ2VIZWFkZXJBY3Rpb25zLFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgQ2xyTW9kYWxNb2R1bGUsIENsckFsZXJ0TW9kdWxlXSxcbiAgZGVjbGFyYXRpb25zOiBbQ0xSX1dJWkFSRF9ESVJFQ1RJVkVTXSxcbiAgZXhwb3J0czogW0NMUl9XSVpBUkRfRElSRUNUSVZFU10sXG59KVxuZXhwb3J0IGNsYXNzIENscldpemFyZE1vZHVsZSB7fVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xyQnV0dG9uTW9kdWxlIH0gZnJvbSAnLi9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJEYXRhTW9kdWxlIH0gZnJvbSAnLi9kYXRhL2RhdGEubW9kdWxlJztcbmltcG9ydCB7IENsckRyYWdBbmREcm9wTW9kdWxlIH0gZnJvbSAnLi91dGlscy9kcmFnLWFuZC1kcm9wL2RyYWctYW5kLWRyb3AubW9kdWxlJztcbmltcG9ydCB7IENsckVtcGhhc2lzTW9kdWxlIH0gZnJvbSAnLi9lbXBoYXNpcy9lbXBoYXNpcy5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyRm9ybXNNb2R1bGUgfSBmcm9tICcuL2Zvcm1zL2Zvcm1zLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJJY29uTW9kdWxlIH0gZnJvbSAnLi9pY29uL2ljb24ubW9kdWxlJztcbmltcG9ydCB7IENsckxheW91dE1vZHVsZSB9IGZyb20gJy4vbGF5b3V0L2xheW91dC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xyTW9kYWxNb2R1bGUgfSBmcm9tICcuL21vZGFsL21vZGFsLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyTW9kdWxlIH0gZnJvbSAnLi9wb3BvdmVyL3BvcG92ZXIubW9kdWxlJztcbmltcG9ydCB7IENsckNvbmRpdGlvbmFsTW9kdWxlIH0gZnJvbSAnLi91dGlscy9jb25kaXRpb25hbC9jb25kaXRpb25hbC5tb2R1bGUnO1xuaW1wb3J0IHsgQ2xySWZFeHBhbmRNb2R1bGUgfSBmcm9tICcuL3V0aWxzL2V4cGFuZC9pZi1leHBhbmQubW9kdWxlJztcbmltcG9ydCB7IENsckZvY3VzVHJhcE1vZHVsZSB9IGZyb20gJy4vdXRpbHMvZm9jdXMtdHJhcC9mb2N1cy10cmFwLm1vZHVsZSc7XG5pbXBvcnQgeyBDbHJMb2FkaW5nTW9kdWxlIH0gZnJvbSAnLi91dGlscy9sb2FkaW5nL2xvYWRpbmcubW9kdWxlJztcbmltcG9ydCB7IENscldpemFyZE1vZHVsZSB9IGZyb20gJy4vd2l6YXJkL3dpemFyZC5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICBleHBvcnRzOiBbXG4gICAgQ2xyRW1waGFzaXNNb2R1bGUsXG4gICAgQ2xyRGF0YU1vZHVsZSxcbiAgICBDbHJJY29uTW9kdWxlLFxuICAgIENsck1vZGFsTW9kdWxlLFxuICAgIENsckxvYWRpbmdNb2R1bGUsXG4gICAgQ2xySWZFeHBhbmRNb2R1bGUsXG4gICAgQ2xyQ29uZGl0aW9uYWxNb2R1bGUsXG4gICAgQ2xyRm9jdXNUcmFwTW9kdWxlLFxuICAgIENsckJ1dHRvbk1vZHVsZSxcbiAgICBDbHJGb3Jtc01vZHVsZSxcbiAgICBDbHJMYXlvdXRNb2R1bGUsXG4gICAgQ2xyUG9wb3Zlck1vZHVsZSxcbiAgICBDbHJXaXphcmRNb2R1bGUsXG4gICAgQ2xyRHJhZ0FuZERyb3BNb2R1bGUsXG4gIF0sXG59KVxuZXhwb3J0IGNsYXNzIENsYXJpdHlNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbi8qKlxuICogUHJpdmF0ZSBjb3VudGVyIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMgZm9yIHRoZSBjaGVja2JveGVzLCB0byBiaW5kIHRoZSBsYWJlbHMgdG8gdGhlbS5cbiAqL1xubGV0IGxhdGVzdElkID0gMDtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBDbHJDaGVja2JveCB3aWxsIGJlIHJlbmFtZWQgdG8gQ2xyQ2hlY2tib3hEZXByZWNhdGVkIGluIDAuMTIsIGFuZCB3aWxsIGJlIHJlcGxhY2VkIHdpdGggYSBuZXdcbiAqIGltcGxlbWVudGF0aW9uIGluIDAuMTMsIHNvIGlmIHlvdSBpbXBvcnQgaXQgeW91IHdpbGwgbmVlZCB0byB1cGRhdGUgeW91ciByZWZlcmVuY2VzLlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjbHItY2hlY2tib3gnLFxuICB0ZW1wbGF0ZTogYFxuICAgICAgICA8IS0tXG4gICAgICAgICAgICBGSVhNRTogV2UgYXJlIG5vdCBzdWJzY3JpYmVkIHRvIHRoZSBjaGFuZ2UgZXZlbnQgYnV0IHRoZSBjbGljayBldmVudCBoZXJlLlxuICAgICAgICAgICAgVGhlIHJlYXNvbiBmb3IgdGhhdCBpcyBiZWNhdXNlIGNoZWNrYm94ZXMgYmVoYXZlIGRpZmZlcmVudGx5IG9uIElFICYgRWRnZS5cbiAgICAgICAgICAgIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTQ0NzkzOVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBUbyBmaXggdGhhdCwgd2UgbGlzdGVuIHRvIGV2ZXJ5IGNsaWNrIGV2ZW50IGFuZCB0aGVuIHRvZ2dsZSB0aGUgY2hlY2tib3ggbWFudWFsbHlcbiAgICAgICAgICAgIHRvIG1ha2UgaXQgYmVoYXZlIHRoZSBzYW1lIHdheSBhY3Jvc3MgdGhlIGJyb3dzZXJzIHdlIHN1cHBvcnQuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFRoaXMgd29ya3MgZm9yIGNhc2VzIHdoZW4gdXNlcnMgdG9nZ2xlIHRoZSBjaGVja2JveCB1c2luZyB0aGUga2V5Ym9hcmQgdG9vOlxuICAgICAgICAgICAgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjc4Nzg5NDAvc3BhY2ViYXItdHJpZ2dlcmluZy1jbGljay1ldmVudC1vbi1jaGVja2JveFxuICAgICAgICAtLT5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJjbHJBcmlhTGFiZWxlZEJ5XCJcbiAgICAgICAgICAgICAgIFtpZF09XCJpZFwiIFtuYW1lXT1cIm5hbWVcIiBbY2hlY2tlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgICAgIFtpbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgKGJsdXIpPVwidG91Y2goKVwiIChjbGljayk9XCJjaGVja0luZGV0ZXJtaW5hdGVTdGF0ZSgpXCI+XG4gICAgICAgIDxsYWJlbCBbYXR0ci5mb3JdPVwiaWRcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9sYWJlbD5cbiAgICBgLFxuICBob3N0OiB7ICdbY2xhc3MuY2hlY2tib3hdJzogJyFpbmxpbmUnLCAnW2NsYXNzLmNoZWNrYm94LWlubGluZV0nOiAnaW5saW5lJywgJ1tjbGFzcy5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnIH0sXG4gIC8qXG4gICAgICogVGhpcyBwcm92aWRlciBsZXRzIHVzIGRlY2xhcmUgb3VyIGNoZWNrYm94IGFzIGEgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICogd2hpY2ggYWxsb3dzIHVzIHRvIHVzZSBbKG5nTW9kZWwpXSBkaXJlY3RseSBvbiBvdXIgY29tcG9uZW50LFxuICAgICAqIHdpdGggYWxsIHRoZSBhdXRvbWF0aWMgZmVhdHVyZXMgd2lyaW5nIHRoYXQgY29tZSB3aXRoIGl0LlxuICAgICAqL1xuICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDbHJDaGVja2JveERlcHJlY2F0ZWQpLCBtdWx0aTogdHJ1ZSB9XSxcbn0pXG5leHBvcnQgY2xhc3MgQ2xyQ2hlY2tib3hEZXByZWNhdGVkIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAvLyBJZiBvdXIgaG9zdCBoYXMgYW4gSUQgYXR0cmlidXRlLCB3ZSB1c2UgdGhpcyBpbnN0ZWFkIG9mIG91ciBpbmRleC5cbiAgQElucHV0KCdpZCcpIF9pZDogc3RyaW5nID0gKGxhdGVzdElkKyspLnRvU3RyaW5nKCk7XG5cbiAgcHVibGljIGdldCBpZCgpIHtcbiAgICByZXR1cm4gYGNsci1jaGVja2JveC0ke3RoaXMuX2lkfWA7XG4gIH1cblxuICAvLyBJZiBob3N0IHByb3ZpZGVzIGFuIGNsckFyaWFMYWJlbGVkQnkgaW5wdXQsIHdlIGFwcGx5IGl0IHRvIHRoZSBjaGVja2JveFxuICBASW5wdXQoJ2NsckFyaWFMYWJlbGVkQnknKSBwdWJsaWMgY2xyQXJpYUxhYmVsZWRCeTogc3RyaW5nID0gbnVsbDtcblxuICAvLyBJZiBvdXIgaG9zdCBoYXMgYSBuYW1lIGF0dHJpYnV0ZSwgd2UgYXBwbHkgaXQgdG8gdGhlIGNoZWNrYm94LlxuICBASW5wdXQoJ25hbWUnKSBwdWJsaWMgbmFtZTogc3RyaW5nID0gbnVsbDtcblxuICAvLyBJZiB0aGUgaG9zdCBpcyBkaXNhYmxlZCB3ZSBhcHBseSBpdCB0byB0aGUgY2hlY2tib3hcbiAgQElucHV0KCdjbHJEaXNhYmxlZCcpIHB1YmxpYyBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8vIFN1cHBvcnQgZm9yIGlubGluZSBjaGVja2JveGVzLCBhZGRzIHRoZSBuZWNlc3NhcnkgY2xhc3MgdG8gdGhlIGhvc3RcbiAgQElucHV0KCdjbHJJbmxpbmUnKSBwdWJsaWMgaW5saW5lID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfY2hlY2tlZCA9IGZhbHNlO1xuXG4gIHB1YmxpYyBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hlY2tlZDtcbiAgfVxuXG4gIEBJbnB1dCgnY2xyQ2hlY2tlZCcpXG4gIHB1YmxpYyBzZXQgY2hlY2tlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fY2hlY2tlZCkge1xuICAgICAgaWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgdGhpcy5zZXRJbmRldGVybWluYXRlKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2hlY2tlZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaW5kZXRlcm1pbmF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHB1YmxpYyBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXRlcm1pbmF0ZTtcbiAgfVxuXG4gIEBJbnB1dCgnY2xySW5kZXRlcm1pbmF0ZScpXG4gIHB1YmxpYyBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLl9pbmRldGVybWluYXRlICE9PSB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX2NoZWNrZWQpIHtcbiAgICAgICAgdGhpcy5zZXRDaGVja2VkKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0SW5kZXRlcm1pbmF0ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgQE91dHB1dCgnY2xySW5kZXRlcm1pbmF0ZUNoYW5nZScpXG4gIHB1YmxpYyBpbmRldGVybWluYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KGZhbHNlKTtcblxuICBwcml2YXRlIHNldEluZGV0ZXJtaW5hdGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pbmRldGVybWluYXRlID0gdmFsdWU7XG4gICAgdGhpcy5pbmRldGVybWluYXRlQ2hhbmdlLmVtaXQodGhpcy5faW5kZXRlcm1pbmF0ZSk7XG4gIH1cblxuICBwcml2YXRlIHNldENoZWNrZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9jaGVja2VkID0gdmFsdWU7XG4gICAgdGhpcy5jaGFuZ2UuZW1pdCh0aGlzLl9jaGVja2VkKTtcbiAgfVxuXG4gIEBPdXRwdXQoJ2NsckNoZWNrZWRDaGFuZ2UnKSBwdWJsaWMgY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPihmYWxzZSk7XG5cbiAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLmNoZWNrZWQpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHRoaXMuY2hlY2tlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICAgKiBUaGVzZSBjYWxsYmFja3Mgd2lsbCBiZSBnaXZlbiB0byB1cyB0aHJvdWdoIHRoZSBDb250cm9sVmFsdWVBY2Nlc3NvciBpbnRlcmZhY2UsXG4gICAgICogYW5kIHdlIG5lZWQgdG8gY2FsbCB0aGVtIHdoZW4gdGhlIHVzZXIgaW50ZXJhY3RzIHdpdGggdGhlIGNoZWNrYm94LlxuICAgICAqL1xuICBwcml2YXRlIG9uQ2hhbmdlQ2FsbGJhY2sgPSAoXzogYW55KSA9PiB7fTtcblxuICByZWdpc3Rlck9uQ2hhbmdlKG9uQ2hhbmdlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZTtcbiAgfVxuXG4gIHByaXZhdGUgb25Ub3VjaGVkQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuICByZWdpc3Rlck9uVG91Y2hlZChvblRvdWNoZWQ6IGFueSk6IHZvaWQge1xuICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBvblRvdWNoZWQ7XG4gIH1cblxuICBwdWJsaWMgdG91Y2goKSB7XG4gICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgY2hlY2tJbmRldGVybWluYXRlU3RhdGUoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENsckNoZWNrYm94RGVwcmVjYXRlZCB9IGZyb20gJy4vY2hlY2tib3gnO1xuXG5leHBvcnQgY29uc3QgQ0xSX0NIRUNLQk9YX0RJUkVDVElWRVM6IFR5cGU8YW55PltdID0gW0NsckNoZWNrYm94RGVwcmVjYXRlZF07XG5cbkBOZ01vZHVsZSh7IGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLCBkZWNsYXJhdGlvbnM6IFtDTFJfQ0hFQ0tCT1hfRElSRUNUSVZFU10sIGV4cG9ydHM6IFtDTFJfQ0hFQ0tCT1hfRElSRUNUSVZFU10gfSlcbmV4cG9ydCBjbGFzcyBDbHJDaGVja2JveERlcHJlY2F0ZWRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENsckRhdGVwaWNrZXJNb2R1bGUgfSBmcm9tICcuLi9mb3Jtcy9kYXRlcGlja2VyL2RhdGVwaWNrZXIubW9kdWxlJztcbmltcG9ydCB7IENsckNoZWNrYm94RGVwcmVjYXRlZE1vZHVsZSB9IGZyb20gJy4vY2hlY2tib3gvY2hlY2tib3gubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sXG4gIGV4cG9ydHM6IFtDbHJDaGVja2JveERlcHJlY2F0ZWRNb2R1bGUsIENsckRhdGVwaWNrZXJNb2R1bGVdLFxufSlcbmV4cG9ydCBjbGFzcyBDbHJGb3Jtc0RlcHJlY2F0ZWRNb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbk1ldGFkYXRhLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24gfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbGxhcHNlKCk6IEFuaW1hdGlvbk1ldGFkYXRhW10ge1xuICAndXNlIHN0cmljdCc7XG4gIHJldHVybiBbXG4gICAgc3RhdGUoJ3RydWUnLCBzdHlsZSh7IGhlaWdodDogMCwgJ292ZXJmbG93LXknOiAnaGlkZGVuJyB9KSksXG4gICAgdHJhbnNpdGlvbigndHJ1ZSA9PiBmYWxzZScsIFthbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBoZWlnaHQ6ICcqJywgJ292ZXJmbG93LXknOiAnaGlkZGVuJyB9KSldKSxcbiAgICB0cmFuc2l0aW9uKCdmYWxzZSA9PiB0cnVlJywgW3N0eWxlKHsgaGVpZ2h0OiAnKicsICdvdmVyZmxvdy15JzogJ2hpZGRlbicgfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKV0pLFxuICBdO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uTWV0YWRhdGEsIHN0eWxlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWRlKG9wYWNpdHk6IG51bWJlciA9IDEpOiBBbmltYXRpb25NZXRhZGF0YVtdIHtcbiAgcmV0dXJuIFtcbiAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbc3R5bGUoeyBvcGFjaXR5OiAwIH0pLCBhbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiBvcGFjaXR5IH0pKV0pLFxuICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFthbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKV0pLFxuICBdO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDE4IFZNd2FyZSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqIFRoZSBmdWxsIGxpY2Vuc2UgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGluIExJQ0VOU0UgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgcHJvamVjdC5cbiAqL1xuaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uTWV0YWRhdGEsIHN0eWxlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWRlU2xpZGUoZGlyZWN0aW9uOiBzdHJpbmcpOiBBbmltYXRpb25NZXRhZGF0YVtdIHtcbiAgbGV0IHRyYW5zZm9ybTogc3RyaW5nID0gbnVsbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgMjUlKSc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnZG93bicpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsIC0yNSUpJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMjUlLCAwKSc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMjUlLCAwKSc7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRpcmVjdGlvbiAnICsgZGlyZWN0aW9uICsgJyBmb3Igc2xpZGUgYW5pbWF0aW9uLicpO1xuICB9XG4gIHJldHVybiBbXG4gICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW3N0eWxlKHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKV0pLFxuICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFthbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyBvcGFjaXR5OiAwLCB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9KSldKSxcbiAgXTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxOCBWTXdhcmUsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbk1ldGFkYXRhLCBzdHlsZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2xpZGUoZGlyZWN0aW9uOiBzdHJpbmcpOiBBbmltYXRpb25NZXRhZGF0YVtdIHtcbiAgbGV0IHRyYW5zZm9ybTogc3RyaW5nID0gbnVsbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwgMjUlKSc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnZG93bicpIHtcbiAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsIC0yNSUpJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdsZWZ0Jykge1xuICAgIHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMjUlLCAwKSc7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnKSB7XG4gICAgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMjUlLCAwKSc7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRpcmVjdGlvbiAnICsgZGlyZWN0aW9uICsgJyBmb3Igc2xpZGUgYW5pbWF0aW9uLicpO1xuICB9XG4gIHJldHVybiBbXG4gICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgW3N0eWxlKHsgdHJhbnNmb3JtOiB0cmFuc2Zvcm0gfSksIGFuaW1hdGUoJzAuMnMgZWFzZS1pbi1vdXQnKV0pLFxuICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFthbmltYXRlKCcwLjJzIGVhc2UtaW4tb3V0Jywgc3R5bGUoeyB0cmFuc2Zvcm06IHRyYW5zZm9ybSB9KSldKSxcbiAgXTtcbn1cbiJdLCJuYW1lcyI6WyJ0c2xpYl8xLl9fdmFsdWVzIiwic3RhdGUiLCJ0c2xpYl8xLl9fZXh0ZW5kcyIsImZpbHRlciIsInRyaWdnZXIiLCJ0b2tlbkZhY3RvcnkiLCJQT1NJVElPTlMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7SUFPQTtLQUlDOztnQkFKQSxTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFOztJQUluQyx1QkFBQztDQUpEOzs7Ozs7O0FDR0EsSUFBYSxtQkFBbUIsR0FBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQztBQUVsRTtJQUFBO0tBQzZCOztnQkFENUIsUUFBUSxTQUFDLEVBQUUsT0FBTyxF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